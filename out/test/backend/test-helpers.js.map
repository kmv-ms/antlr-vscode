{"version":3,"file":"test-helpers.js","sourceRoot":"","sources":["../../../test/backend/test-helpers.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\nimport fs from \"fs\";\r\n\r\n/**\r\n * Generates the alignment.g4 grammar from formatting options in the alignment-template.g4 file.\r\n */\r\nexport const createAlignmentGrammar = (): void => {\r\n    let grammar = \"grammar alignment;\\n\\n// $antlr-format reset, columnLimit 200\\n\";\r\n    const template = fs.readFileSync(\"test/backend/formatting/alignment-template.g4\", { encoding: \"utf8\" });\r\n    const sections = template.split(\"\\n\");\r\n\r\n    // For each section create 100 rules with some random parts.\r\n    for (const section of sections) {\r\n        grammar += \"\\n\" + section + \"\\n\";\r\n\r\n        // Make it 30 lexer rules and 20 parser rules (less parser rules as we always use grouped alignments for them).\r\n        for (let i = 0; i < 30; ++i) {\r\n            if (i === 0) {\r\n                grammar += \"// $antlr-format groupedAlignments off\\n\";\r\n            } else if (i === 15) {\r\n                grammar += \"// $antlr-format groupedAlignments on\\n\";\r\n            }\r\n\r\n            const ruleNameFillCount = Math.random() * 25 + 1;\r\n            const useLexerAction = Math.random() < 0.5;\r\n            const useComment = Math.random() < 0.5;\r\n            const usePredicate = Math.random() < 0.5;\r\n            const useAction = Math.random() < 0.5;\r\n\r\n            const filler = \"_\".repeat(ruleNameFillCount);\r\n            let line = `Keyword${filler}${i}:'Keyword${filler}${i}'`;\r\n\r\n            if (useAction) {\r\n                if (usePredicate) {\r\n                    // Both, action and predicate. Make order random too.\r\n                    if (Math.random() < 0.5) {\r\n                        line += \"{domeSomething($text);} \";\r\n                        line += \"{doesItBlend()}? \";\r\n                    } else {\r\n                        line += \"{doesItBlend()}? \";\r\n                        line += \"{domeSomething($text);} \";\r\n                    }\r\n                } else {\r\n                    line += \"{domeSomething($text);} \";\r\n                }\r\n            } else if (usePredicate) {\r\n                line += \"{doesItBlend()}? \";\r\n            }\r\n\r\n            if (useLexerAction) {\r\n                const type = Math.random() < 0.5 ? \"mode\" : \"type\";\r\n                line += \"-> \" + type + \"(SomethingReallyMeaningful) \";\r\n            }\r\n\r\n            line += \";\";\r\n            if (useComment) {\r\n                line += \" // Specified in the interest of formatting.\";\r\n            }\r\n\r\n            grammar += line + \"\\n\";\r\n        }\r\n\r\n        grammar += \"// $antlr-format groupedAlignments on\\n\";\r\n        for (let i = 0; i < 20; ++i) {\r\n            if (i === 0) {\r\n                grammar += \"// $antlr-format allowShortRulesOnASingleLine false, allowShortBlocksOnASingleLine false\\n\";\r\n            } else if (i === 10) {\r\n                grammar += \"// $antlr-format allowShortRulesOnASingleLine true, allowShortBlocksOnASingleLine true\\n\";\r\n            }\r\n\r\n            const ruleNameFillCount = Math.random() * 25 + 1;\r\n            const useComment = Math.random() < 0.25;\r\n            const action = Math.random() < 0.25 ? \"{doSomething($text);}\" : \" \";\r\n            const predicate = Math.random() < 0.25 ? \"{doesItBlend}?\" : \" \";\r\n            const useLabels = Math.random() < 0.5;\r\n\r\n            let line = `rule${\"_\".repeat(ruleNameFillCount)}${i}: (`;\r\n\r\n            if (useComment) {\r\n                line += predicate + \"alt1\" + action + \"ruleA// Mom look, a trailing comment.\\n\";\r\n                line += \"|\" + predicate + \"____alt2\" + action + \"ruleB// And another comment.\\n\";\r\n                line += \"|\" + predicate + \"____alt3\" + action + \"ruleB/* Not aligned comment.*/\\n\";\r\n            } else {\r\n                line += predicate + \"alt1\" + action + \"ruleA|____alt2\" + action + \"ruleB\";\r\n            }\r\n            line += \")\";\r\n\r\n            if (!useLabels) {\r\n                line += \"rule_ | rule__ | rule____ | rule________ \";\r\n            } else {\r\n                line += \"rule_ # label_ | rule__ # label__ | rule____ #label____| rule________#label________ \";\r\n            }\r\n\r\n            line += action + predicate + \";\";\r\n            if (useComment) {\r\n                line += \" // Final trailing comment.\";\r\n            }\r\n\r\n            grammar += line + \"\\n\";\r\n        }\r\n    }\r\n\r\n    fs.writeFileSync(\"test/backend/formatting/alignment.g4\", grammar, \"utf8\");\r\n};\r\n\r\n/**\r\n * Converts the given position in the text to a character index (assuming 4 chars tab width).\r\n *\r\n * @param text The text for which to convert the position.\r\n * @param column The position in the text line.\r\n * @param row The line in the text.\r\n *\r\n * @returns The character index in the text for the given position.\r\n */\r\nexport const positionToIndex = (text: string, column: number, row: number): number => {\r\n    let currentRow = 1; // Remember: row numbers in ANTLR4 are one-based.\r\n    let currentColumn = 0;\r\n\r\n    for (let i = 0; i < text.length; ++i) {\r\n        if (row < currentRow) { // Happens when the column value was greater than previous column width.\r\n            return i - 1;\r\n        }\r\n\r\n        if (currentRow === row && currentColumn === column) {\r\n            return i;\r\n        }\r\n        switch (text[i]) {\r\n            case \"\\n\": {\r\n                currentColumn = 0;\r\n                ++currentRow;\r\n                break;\r\n            }\r\n            case \"\\t\": {\r\n                currentColumn += 4 - (currentColumn % 4);\r\n                break;\r\n            }\r\n            default:\r\n                ++currentColumn;\r\n                break;\r\n        }\r\n    }\r\n\r\n    return text.length;\r\n};\r\n\r\n/**\r\n * Converts the given character index into a column/row pair (assuming 4 chars tab width).\r\n *\r\n * @param text The text for which to convert the index.\r\n * @param index The character index in the text.\r\n *\r\n * @returns A [column, row] tuple with the position of the given index.\r\n */\r\nexport const indexToPosition = (text: string, index: number): [number, number] => {\r\n    let currentRow = 1;\r\n    let currentColumn = 0;\r\n    for (let i = 0; i < text.length; ++i) {\r\n        if (i === index) {\r\n            return [currentColumn, currentRow];\r\n        }\r\n        switch (text[i]) {\r\n            case \"\\n\": {\r\n                currentColumn = 0;\r\n                ++currentRow;\r\n                break;\r\n            }\r\n            case \"\\t\": {\r\n                currentColumn += 4 - (currentColumn % 4);\r\n                break;\r\n            }\r\n            default:\r\n                ++currentColumn;\r\n                break;\r\n        }\r\n    }\r\n\r\n    return [currentColumn, currentRow];\r\n};\r\n"]}