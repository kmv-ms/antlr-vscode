{"version":3,"file":"formatting.spec.js","sourceRoot":"","sources":["../../../test/backend/formatting.spec.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\nimport * as fs from \"fs\";\r\n\r\nimport { AntlrFacade } from \"../../src/backend/facade\";\r\nimport { positionToIndex, indexToPosition } from \"./test-helpers\";\r\n\r\ninterface ITestRange {\r\n    source: {\r\n        start: {\r\n            column: number;\r\n            row: number;\r\n        };\r\n        end: {\r\n            column: number;\r\n            row: number;\r\n        };\r\n    };\r\n    target: {\r\n        start: {\r\n            column: number;\r\n            row: number;\r\n        };\r\n        end: {\r\n            column: number;\r\n            row: number;\r\n        };\r\n    };\r\n    result: string;\r\n}\r\n\r\ndescribe(\"Formatting\", () => {\r\n    const backend = new AntlrFacade(\".\", process.cwd()); // Search path is cwd for this test.\r\n    jest.setTimeout(30000);\r\n\r\n    it(\"With all options (except alignment)\", () => {\r\n        // Format a file with all kinds of syntactic elements. Start out with default\r\n        // formatting options and change them in the file to test all variations.\r\n        const [text] = backend.formatGrammar(\"test/backend/formatting/raw.g4\", {}, 0, 1e10);\r\n\r\n        //fs.writeFileSync(\"test/backend/formatting-results/raw2.g4\", text, \"utf8\");\r\n        const expected = fs.readFileSync(\"test/backend/formatting-results/raw.g4\", { encoding: \"utf8\" });\r\n        expect(expected).toEqual(text);\r\n    });\r\n\r\n    it(\"Alignment formatting\", () => {\r\n        //createAlignmentGrammar();\r\n\r\n        // Load a large file with all possible alignment combinations (50 rules for each permutation),\r\n        // checking so also the overall performance (9600 rules).\r\n        const [text] = backend.formatGrammar(\"test/backend/formatting/alignment.g4\", {}, 0, 1e10);\r\n\r\n        //fs.writeFileSync(\"test/backend/formatting-results/alignment.g4\", text, \"utf8\");\r\n        const expected = fs.readFileSync(\"test/backend/formatting-results/alignment.g4\", { encoding: \"utf8\" });\r\n        expect(expected).toEqual(text);\r\n    });\r\n\r\n    it(\"Ranged formatting\", () => {\r\n        let [text, targetStart, targetStop] = backend.formatGrammar(\"test/backend/formatting/raw.g4\", {}, -10, -20);\r\n        expect(text).toHaveLength(0);\r\n        expect(targetStart).toEqual(0);\r\n        expect(targetStop).toEqual(4);\r\n\r\n        const rangeTests = JSON.parse(fs.readFileSync(\"test/backend/formatting/ranges.json\",\r\n            { encoding: \"utf8\" })) as ITestRange[];\r\n        const source = fs.readFileSync(\"test/backend/formatting/raw.g4\", { encoding: \"utf8\" });\r\n        for (let i = 1; i <= rangeTests.length; ++i) {\r\n            const rangeTest = rangeTests[i - 1];\r\n\r\n            // Range ends are non-inclusive.\r\n            const startIndex = positionToIndex(source, rangeTest.source.start.column, rangeTest.source.start.row);\r\n            const stopIndex = positionToIndex(source, rangeTest.source.end.column, rangeTest.source.end.row) - 1;\r\n            [text, targetStart, targetStop] = backend.formatGrammar(\"test/backend/formatting/raw.g4\", {},\r\n                startIndex, stopIndex);\r\n\r\n            const [startColumn, startRow] = indexToPosition(source, targetStart);\r\n            const [stopColumn, stopRow] = indexToPosition(source, targetStop + 1);\r\n            const range = {\r\n                start: { column: startColumn, row: startRow }, end: { column: stopColumn, row: stopRow },\r\n            };\r\n\r\n            //fs.writeFileSync(\"test/backend/formatting-results/\" + rangeTest.result, text, \"utf8\");\r\n            const expected = fs.readFileSync(\"test/backend/formatting-results/\" + rangeTest.result,\r\n                { encoding: \"utf8\" });\r\n            expect(range).toStrictEqual(rangeTest.target);\r\n            expect(expected).toEqual(text);\r\n        }\r\n    });\r\n});\r\n"]}