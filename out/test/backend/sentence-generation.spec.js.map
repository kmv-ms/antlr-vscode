{"version":3,"file":"sentence-generation.spec.js","sourceRoot":"","sources":["../../../test/backend/sentence-generation.spec.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\nimport * as fs from \"fs\";\r\n\r\nimport { AntlrFacade } from \"../../src/backend/facade\";\r\nimport { IRuleMappings } from \"../../src/backend/types\";\r\n\r\ndescribe(\"Sentence Generation\", () => {\r\n    const backend = new AntlrFacade(\".\", process.cwd()); // Search path is cwd for this test.\r\n    jest.setTimeout(30000);\r\n\r\n    /**\r\n     * Remove occurrences of known strings that are inserted at non-deterministic positions.\r\n     *\r\n     * @param sentence The sentence to filter.\r\n     * @returns The filtered sentence.\r\n     */\r\n    const filter = (sentence: string): string => {\r\n        sentence = sentence.replace(/12345/g, \"\");\r\n        sentence = sentence.replace(/54321/g, \"\");\r\n        sentence = sentence.replace(/DEADBEEF/g, \"\");\r\n        sentence = sentence.replace(/Mike/g, \"\");\r\n        sentence = sentence.replace(/John/g, \"\");\r\n        sentence = sentence.replace(/Mary/g, \"\");\r\n        sentence = sentence.replace(/µπåƒ/g, \"\");\r\n        sentence = sentence.replace(/você/g, \"\");\r\n        sentence = sentence.replace(/𑃖𓂷/g, \"\");\r\n        sentence = sentence.replace(/𑃖ꫪ𝚫/g, \"\");\r\n        sentence = sentence.replace(/𑃖𠦄𣛯𪃾/g, \"\");\r\n        sentence = sentence.replace(/𑃖പửၒ/g, \"\");\r\n        sentence = sentence.replace(/𑃖ᚱꙍ𒅍/g, \"\");\r\n        sentence = sentence.replace(/red/g, \"\");\r\n        sentence = sentence.replace(/green/g, \"\");\r\n        sentence = sentence.replace(/blue/g, \"\");\r\n        sentence = sentence.replace(/[0-9{},.:]/g, \"\");\r\n\r\n        return sentence.trim();\r\n    };\r\n\r\n    beforeAll(async () => {\r\n        let result = await backend.generate(\"grammars/OracleAntlrParser.g4\", {\r\n            outputDir: \"generated-sentence\",\r\n            language: \"CSharp\",\r\n            alternativeJar: \"antlr/antlr-4.9.2-complete.jar\",\r\n        });\r\n        for (const file of result) {\r\n            const diagnostics = backend.getDiagnostics(file);\r\n            if (diagnostics.length > 0) {\r\n                if (diagnostics[0].message.includes(\"no non-fragment rules\")) {\r\n                    diagnostics.shift();\r\n                } else {\r\n                    console.log(\"Generation error: \" + diagnostics[0].message);\r\n                }\r\n            }\r\n            expect(diagnostics).toHaveLength(0);\r\n        }\r\n    });\r\n\r\n    it(\"Generation with mixed definition values\", () => {\r\n        const ruleMappings: IRuleMappings = {\r\n            /* eslint-disable @typescript-eslint/naming-convention */\r\n            DIGITS: \"12345\",\r\n            SimpleIdentifier: [\"Mike\"],\r\n            UnicodeIdentifier: [\"µπåƒ\", \"você\", \"𑃖𓂷\", \"𑃖ꫪ𝚫\", \"𑃖𠦄𣛯𪃾\", \"𑃖പửၒ\", \"𑃖ᚱꙍ𒅍\"],\r\n            /* eslint-enable @typescript-eslint/naming-convention */\r\n        };\r\n\r\n\r\n        const tester = (rule: string, sentence: string) => {\r\n            let ctime = Date.now().toString();\r\n            console.log(rule + \": \" + ctime);\r\n\r\n            fs.writeFileSync(\"./GeneratedSQL/\" + ctime + \".sql\", sentence);\r\n            //const errors = backend.parseTestInput(\"grammars/OracleAntlrParser.g4\", sentence, rule);\r\n            //expect(errors).toHaveLength(0);\r\n        };\r\n\r\n        //const rules = backend.getRuleList(\"grammars/OracleAntlr.g4\")!;\r\n        let rule: string = 'sqlInputFile';\r\n        rule = 'sqlStatement';\r\n        console.log(rule);\r\n        backend.generateSentence(\"grammars/OracleAntlrParser.g4\", rule , {\r\n            count: 100,\r\n            maxLexerIterations: 1,\r\n            maxParserIterations: 1,\r\n        }, tester.bind(this, rule));\r\n    });\r\n\r\n    afterAll(() => {\r\n        backend.releaseGrammar(\"grammars/OracleAntlrParser.g4\");\r\n        //fs.rmSync(\"generated-sentence\", { recursive: true, force: true });\r\n    });\r\n});\r\n"]}