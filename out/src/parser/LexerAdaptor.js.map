{"version":3,"file":"LexerAdaptor.js","sourceRoot":"","sources":["../../../src/parser/LexerAdaptor.ts"],"names":[],"mappings":";;;AAOA,uCAAwC;AACxC,wCAAyC;AAEzC,iDAA8C;AAE9C,MAAsB,YAAa,SAAQ,gBAAK;IACpC,eAAe,GAAW,gBAAK,CAAC,YAAY,CAAC;IAErC,IAAI;QAChB,IAAI,IAAI,CAAC,IAAI,KAAK,2BAAY,CAAC,EAAE,EAAE;YAC/B,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CACtC,IAAI,eAAQ,CAAC,IAAI,CAAC,oBAAoB,EAAE,IAAI,CAAC,oBAAoB,CAAC,CACrE,CAAC;YACF,IAAI,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,EAAE;gBAC3D,IAAI,CAAC,IAAI,GAAG,2BAAY,CAAC,SAAS,CAAC;aACtC;iBAAM;gBACH,IAAI,CAAC,IAAI,GAAG,2BAAY,CAAC,QAAQ,CAAC;aACrC;YAED,IAAI,IAAI,CAAC,eAAe,KAAK,gBAAK,CAAC,YAAY,EAAE;gBAC7C,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,IAAI,CAAC;aACpC;SACJ;aAAM,IAAI,IAAI,CAAC,IAAI,KAAK,2BAAY,CAAC,IAAI,EAAE;YACxC,IAAI,CAAC,eAAe,GAAG,gBAAK,CAAC,YAAY,CAAC;SAC7C;QAED,OAAO,KAAK,CAAC,IAAI,EAAE,CAAC;IACxB,CAAC;IAES,mBAAmB;QACzB,IAAI,IAAI,CAAC,eAAe,KAAK,2BAAY,CAAC,SAAS,EAAE;YACjD,IAAI,CAAC,QAAQ,CAAC,2BAAY,CAAC,YAAY,CAAC,CAAC;YACzC,IAAI,CAAC,IAAI,EAAE,CAAC;SACf;aAAM;YACH,IAAI,CAAC,QAAQ,CAAC,2BAAY,CAAC,QAAQ,CAAC,CAAC;SACxC;IACL,CAAC;IAES,iBAAiB;QACvB,IAAI,CAAC,OAAO,EAAE,CAAC;QAEf,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,GAAG,CAAC,EAAE;YAC1B,IAAI,CAAC,IAAI,GAAG,2BAAY,CAAC,gBAAgB,CAAC;SAC7C;IACL,CAAC;IAES,eAAe;QACrB,IAAI,CAAC,OAAO,EAAE,CAAC;QAEf,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,GAAG,CAAC,EAAE;YAC1B,IAAI,CAAC,IAAI,GAAG,2BAAY,CAAC,cAAc,CAAC;SAC3C;IACL,CAAC;CACJ;AAhDD,oCAgDC","sourcesContent":["/*\r\n * This file is released under the MIT license.\r\n * Copyright (c) 2016, 2020, Mike Lischke\r\n *\r\n * See LICENSE file for more info.\r\n */\r\n\r\nimport { Lexer, Token } from \"antlr4ts\";\r\nimport { Interval } from \"antlr4ts/misc\";\r\n\r\nimport { ANTLRv4Lexer } from \"./ANTLRv4Lexer\";\r\n\r\nexport abstract class LexerAdaptor extends Lexer {\r\n    private currentRuleType: number = Token.INVALID_TYPE;\r\n\r\n    public override emit(): Token {\r\n        if (this.type === ANTLRv4Lexer.ID) {\r\n            const firstChar = this.inputStream.getText(\r\n                new Interval(this._tokenStartCharIndex, this._tokenStartCharIndex),\r\n            );\r\n            if (firstChar.charAt(0) === firstChar.charAt(0).toUpperCase()) {\r\n                this.type = ANTLRv4Lexer.TOKEN_REF;\r\n            } else {\r\n                this.type = ANTLRv4Lexer.RULE_REF;\r\n            }\r\n\r\n            if (this.currentRuleType === Token.INVALID_TYPE) { // if outside of rule def\r\n                this.currentRuleType = this.type; // set to inside lexer or parser rule\r\n            }\r\n        } else if (this.type === ANTLRv4Lexer.SEMI) { // exit rule def\r\n            this.currentRuleType = Token.INVALID_TYPE;\r\n        }\r\n\r\n        return super.emit();\r\n    }\r\n\r\n    protected handleBeginArgument(): void {\r\n        if (this.currentRuleType === ANTLRv4Lexer.TOKEN_REF) {\r\n            this.pushMode(ANTLRv4Lexer.LexerCharSet);\r\n            this.more();\r\n        } else {\r\n            this.pushMode(ANTLRv4Lexer.Argument);\r\n        }\r\n    }\r\n\r\n    protected handleEndArgument(): void {\r\n        this.popMode();\r\n        // eslint-disable-next-line no-underscore-dangle\r\n        if (this._modeStack.size > 0) {\r\n            this.type = ANTLRv4Lexer.ARGUMENT_CONTENT;\r\n        }\r\n    }\r\n\r\n    protected handleEndAction(): void {\r\n        this.popMode();\r\n        // eslint-disable-next-line no-underscore-dangle\r\n        if (this._modeStack.size > 0) {\r\n            this.type = ANTLRv4Lexer.ACTION_CONTENT;\r\n        }\r\n    }\r\n}\r\n"]}