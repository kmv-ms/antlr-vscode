{"version":3,"file":"CompatibleATNDeserializer.js","sourceRoot":"","sources":["../../../src/backend/CompatibleATNDeserializer.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n *\r\n * Parts of this file not copied from the original ATNDeserializer.ts file are released under the MIT license.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n *\r\n * All copied parts are released under the BSD-3-Clause.\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n */\r\n\r\n/* spell-checker: disable */\r\n\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\n\r\nimport {\r\n    ATNDeserializer, ATNDeserializationOptions, ATN, ATNType, LoopEndState, BlockStartState, ATNStateType,\r\n    InvalidState, ATNState, BlockEndState, DecisionState, RuleStartState, RuleStopState, TokensStartState, Transition,\r\n    RuleTransition, EpsilonTransition, PlusLoopbackState, PlusBlockStartState, StarLoopbackState, StarLoopEntryState,\r\n    LexerAction, LexerActionType, ActionTransition, LexerCustomAction, BasicBlockStartState, BasicState,\r\n    AtomTransition, TransitionType, ParserATNSimulator, SetTransition, RangeTransition, NotSetTransition,\r\n} from \"antlr4ts/atn\";\r\nimport { UUID, IntervalSet, Array2DHashSet, Interval, BitSet } from \"antlr4ts/misc\";\r\nimport { NotNull } from \"antlr4ts/Decorators\";\r\nimport { Token } from \"antlr4ts\";\r\nimport { DFA } from \"antlr4ts/dfa/DFA\";\r\n\r\ninterface IUnicodeDeserializer {\r\n    // Work around Java not allowing mutation of captured variables\r\n    // by returning amount by which to increment p after each read\r\n    readonly size: number;\r\n\r\n    // Wrapper for readInt() or readInt32()\r\n    readUnicode(data: Uint16Array, p: number): number;\r\n}\r\n\r\nconst enum UnicodeDeserializingMode {\r\n    UNICODE_BMP,\r\n    UNICODE_SMP,\r\n}\r\n\r\n/**\r\n * This derived deserializer makes loading of ATNs generated by standard ANTLR possible. The antlr4ts library uses\r\n * an incompatible version.\r\n * Unfortunately, we have to duplicate all the private stuff to make the class working.\r\n */\r\nexport class CompatibleATNDeserializer extends ATNDeserializer {\r\n    private static readonly BASE_SERIALIZED_UUID2: UUID = UUID.fromString(\"E4178468-DF95-44D0-AD87-F22A5D5FB6D3\");\r\n    private static readonly ADDED_LEXER_ACTIONS2: UUID = UUID.fromString(\"AB35191A-1603-487E-B75A-479B831EAF6D\");\r\n    private static readonly ADDED_UNICODE_SMP2: UUID = UUID.fromString(\"C23FEA89-0605-4f51-AFB8-058BCAB8C91B\");\r\n\r\n    // antlr4ts uses a different UUID for ADDED_UNICODE_SMP than the original ANTLR4 tool.\r\n    private static readonly ADDED_UNICODE_SMP_ORIGINAL: UUID = UUID.fromString(\"59627784-3BE5-417A-B9EB-8131A7286089\");\r\n\r\n    private static readonly SUPPORTED_UUIDS2: UUID[] = [\r\n        CompatibleATNDeserializer.BASE_SERIALIZED_UUID2,\r\n        CompatibleATNDeserializer.ADDED_LEXER_ACTIONS2,\r\n        CompatibleATNDeserializer.ADDED_UNICODE_SMP_ORIGINAL,\r\n        CompatibleATNDeserializer.ADDED_UNICODE_SMP2,\r\n    ];\r\n\r\n    /**\r\n     * This is the current serialized UUID.\r\n     */\r\n    private static readonly SERIALIZED_UUID2: UUID = CompatibleATNDeserializer.ADDED_UNICODE_SMP2;\r\n\r\n    @NotNull\r\n    private readonly deserializationOptions2: ATNDeserializationOptions;\r\n\r\n    public constructor(deserializationOptions?: ATNDeserializationOptions) {\r\n        super(deserializationOptions);\r\n        if (deserializationOptions == null) {\r\n            deserializationOptions = ATNDeserializationOptions.defaultOptions;\r\n        }\r\n\r\n        this.deserializationOptions2 = deserializationOptions;\r\n    }\r\n\r\n    /**\r\n     * Determines if a particular serialized representation of an ATN supports\r\n     * a particular feature, identified by the {@link UUID} used for serializing\r\n     * the ATN at the time the feature was first introduced.\r\n     *\r\n     * @param feature The {@link UUID} marking the first time the feature was\r\n     * supported in the serialized ATN.\r\n     * @param actualUuid The {@link UUID} of the actual serialized ATN which is\r\n     * currently being deserialized.\r\n     * @returns `true` if the `actualUuid` value represents a\r\n     * serialized ATN at or after the feature identified by `feature` was\r\n     * introduced; otherwise, `false`.\r\n     */\r\n    public static override isFeatureSupported(feature: UUID, actualUuid: UUID): boolean {\r\n        const featureIndex = CompatibleATNDeserializer.SUPPORTED_UUIDS2.findIndex((e) => { return e.equals(feature); });\r\n        if (featureIndex < 0) {\r\n            return false;\r\n        }\r\n\r\n        return CompatibleATNDeserializer.SUPPORTED_UUIDS2.findIndex((e) => {\r\n            return e.equals(actualUuid);\r\n        }) >= featureIndex;\r\n    }\r\n\r\n    private static getUnicodeDeserializer2(mode: UnicodeDeserializingMode): IUnicodeDeserializer {\r\n        if (mode === UnicodeDeserializingMode.UNICODE_BMP) {\r\n            return {\r\n                readUnicode: (data: Uint16Array, p: number): number => { return ATNDeserializer.toInt(data[p]); },\r\n                size: 1,\r\n            };\r\n        } else {\r\n            return {\r\n                readUnicode: (data: Uint16Array, p: number): number => { return ATNDeserializer.toInt32(data, p); },\r\n                size: 2,\r\n            };\r\n        }\r\n    }\r\n\r\n    private static inlineSetRules2(atn: ATN): number {\r\n        let inlinedCalls = 0;\r\n\r\n        const ruleToInlineTransition = new Array<Transition | undefined>(atn.ruleToStartState.length);\r\n        for (let i = 0; i < atn.ruleToStartState.length; i++) {\r\n            const startState: RuleStartState = atn.ruleToStartState[i];\r\n            let middleState: ATNState = startState;\r\n            while (middleState.onlyHasEpsilonTransitions\r\n                && middleState.numberOfOptimizedTransitions === 1\r\n                && middleState.getOptimizedTransition(0).serializationType === TransitionType.EPSILON) {\r\n                middleState = middleState.getOptimizedTransition(0).target;\r\n            }\r\n\r\n            if (middleState.numberOfOptimizedTransitions !== 1) {\r\n                continue;\r\n            }\r\n\r\n            const matchTransition: Transition = middleState.getOptimizedTransition(0);\r\n            const matchTarget: ATNState = matchTransition.target;\r\n            if (matchTransition.isEpsilon\r\n                || !matchTarget.onlyHasEpsilonTransitions\r\n                || matchTarget.numberOfOptimizedTransitions !== 1\r\n                || !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState)) {\r\n                continue;\r\n            }\r\n\r\n            switch (matchTransition.serializationType) {\r\n                case TransitionType.ATOM:\r\n                case TransitionType.RANGE:\r\n                case TransitionType.SET:\r\n                    ruleToInlineTransition[i] = matchTransition;\r\n                    break;\r\n\r\n                case TransitionType.NOT_SET:\r\n                case TransitionType.WILDCARD:\r\n                    // not implemented yet\r\n                    continue;\r\n\r\n                default:\r\n                    continue;\r\n            }\r\n        }\r\n\r\n        for (const state of atn.states) {\r\n            if (state.ruleIndex < 0) {\r\n                continue;\r\n            }\r\n\r\n            let optimizedTransitions: Transition[] | undefined;\r\n            for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\r\n                const transition: Transition = state.getOptimizedTransition(i);\r\n                if (!(transition instanceof RuleTransition)) {\r\n                    if (optimizedTransitions !== undefined) {\r\n                        optimizedTransitions.push(transition);\r\n                    }\r\n\r\n                    continue;\r\n                }\r\n\r\n                const ruleTransition: RuleTransition = transition;\r\n                const effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];\r\n                if (effective == null) {\r\n                    if (optimizedTransitions !== undefined) {\r\n                        optimizedTransitions.push(transition);\r\n                    }\r\n\r\n                    continue;\r\n                }\r\n\r\n                if (optimizedTransitions == null) {\r\n                    optimizedTransitions = [];\r\n                    for (let j = 0; j < i; j++) {\r\n                        optimizedTransitions.push(state.getOptimizedTransition(i));\r\n                    }\r\n                }\r\n\r\n                inlinedCalls++;\r\n                const target: ATNState = ruleTransition.followState;\r\n                const intermediateState: ATNState = new BasicState();\r\n                intermediateState.setRuleIndex(target.ruleIndex);\r\n                atn.addState(intermediateState);\r\n                optimizedTransitions.push(new EpsilonTransition(intermediateState));\r\n\r\n                switch (effective.serializationType) {\r\n                    case TransitionType.ATOM:\r\n                        intermediateState.addTransition(new AtomTransition(target,\r\n                            (effective as AtomTransition).label.maxElement)); // The label interval only has one member.\r\n                        break;\r\n\r\n                    case TransitionType.RANGE:\r\n                        intermediateState.addTransition(new RangeTransition(target, (effective as RangeTransition).from,\r\n                            (effective as RangeTransition).to));\r\n                        break;\r\n\r\n                    case TransitionType.SET:\r\n                        intermediateState.addTransition(new SetTransition(target, (effective as SetTransition).label));\r\n                        break;\r\n\r\n                    default:\r\n                        throw new Error(\"UnsupportedOperationException\");\r\n                }\r\n            }\r\n\r\n            if (optimizedTransitions !== undefined) {\r\n                if (state.isOptimized) {\r\n                    while (state.numberOfOptimizedTransitions > 0) {\r\n                        state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);\r\n                    }\r\n                }\r\n\r\n                for (const transition of optimizedTransitions) {\r\n                    state.addOptimizedTransition(transition);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (ParserATNSimulator.debug) {\r\n            console.log(`ATN runtime optimizer removed ${inlinedCalls} rule invocations by inlining sets.`);\r\n        }\r\n\r\n        return inlinedCalls;\r\n    }\r\n\r\n    private static combineChainedEpsilons2(atn: ATN): number {\r\n        let removedEdges = 0;\r\n\r\n        for (const state of atn.states) {\r\n            if (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState) {\r\n                continue;\r\n            }\r\n\r\n            let optimizedTransitions: Transition[] | undefined;\r\n            nextTransition:\r\n            for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\r\n                const transition: Transition = state.getOptimizedTransition(i);\r\n                const intermediate: ATNState = transition.target;\r\n                if (transition.serializationType !== TransitionType.EPSILON\r\n                    || (transition as EpsilonTransition).outermostPrecedenceReturn !== -1\r\n                    || intermediate.stateType !== ATNStateType.BASIC\r\n                    || !intermediate.onlyHasEpsilonTransitions) {\r\n                    if (optimizedTransitions !== undefined) {\r\n                        optimizedTransitions.push(transition);\r\n                    }\r\n\r\n                    continue;\r\n                }\r\n\r\n                for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {\r\n                    if (intermediate.getOptimizedTransition(j).serializationType !== TransitionType.EPSILON\r\n                        || (intermediate.getOptimizedTransition(j) as EpsilonTransition)\r\n                            .outermostPrecedenceReturn !== -1) {\r\n                        if (optimizedTransitions !== undefined) {\r\n                            optimizedTransitions.push(transition);\r\n                        }\r\n\r\n                        continue nextTransition;\r\n                    }\r\n                }\r\n\r\n                removedEdges++;\r\n                if (optimizedTransitions == null) {\r\n                    optimizedTransitions = [];\r\n                    for (let j = 0; j < i; j++) {\r\n                        optimizedTransitions.push(state.getOptimizedTransition(j));\r\n                    }\r\n                }\r\n\r\n                for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {\r\n                    const target: ATNState = intermediate.getOptimizedTransition(j).target;\r\n                    optimizedTransitions.push(new EpsilonTransition(target));\r\n                }\r\n            }\r\n\r\n            if (optimizedTransitions !== undefined) {\r\n                if (state.isOptimized) {\r\n                    while (state.numberOfOptimizedTransitions > 0) {\r\n                        state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);\r\n                    }\r\n                }\r\n\r\n                for (const transition of optimizedTransitions) {\r\n                    state.addOptimizedTransition(transition);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (ParserATNSimulator.debug) {\r\n            console.log(`ATN runtime optimizer removed ${removedEdges} transitions by combining chained epsilon ` +\r\n                `transitions.`);\r\n        }\r\n\r\n        return removedEdges;\r\n    }\r\n\r\n    private static optimizeSets2(atn: ATN, preserveOrder: boolean): number {\r\n        if (preserveOrder) {\r\n            // this optimization currently doesn't preserve edge order.\r\n            return 0;\r\n        }\r\n\r\n        let removedPaths = 0;\r\n        const decisions: DecisionState[] = atn.decisionToState;\r\n        for (const decision of decisions) {\r\n            const setTransitions: IntervalSet = new IntervalSet();\r\n            for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {\r\n                const epsTransition: Transition = decision.getOptimizedTransition(i);\r\n                if (!(epsTransition instanceof EpsilonTransition)) {\r\n                    continue;\r\n                }\r\n\r\n                if (epsTransition.target.numberOfOptimizedTransitions !== 1) {\r\n                    continue;\r\n                }\r\n\r\n                const transition: Transition = epsTransition.target.getOptimizedTransition(0);\r\n                if (!(transition.target instanceof BlockEndState)) {\r\n                    continue;\r\n                }\r\n\r\n                if (transition instanceof NotSetTransition) {\r\n                    // TODO: not yet implemented\r\n                    continue;\r\n                }\r\n\r\n                if (transition instanceof AtomTransition\r\n                    || transition instanceof RangeTransition\r\n                    || transition instanceof SetTransition) {\r\n                    setTransitions.add(i);\r\n                }\r\n            }\r\n\r\n            if (setTransitions.size <= 1) {\r\n                continue;\r\n            }\r\n\r\n            const optimizedTransitions: Transition[] = [];\r\n            for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {\r\n                if (!setTransitions.contains(i)) {\r\n                    optimizedTransitions.push(decision.getOptimizedTransition(i));\r\n                }\r\n            }\r\n\r\n            const blockEndState: ATNState = decision.getOptimizedTransition(setTransitions.minElement).target\r\n                .getOptimizedTransition(0).target;\r\n            const matchSet: IntervalSet = new IntervalSet();\r\n            for (const interval of setTransitions.intervals) {\r\n                for (let j = interval.a; j <= interval.b; j++) {\r\n                    const matchTransition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);\r\n                    if (matchTransition instanceof NotSetTransition) {\r\n                        throw new Error(\"Not yet implemented.\");\r\n                    } else {\r\n                        matchSet.addAll(matchTransition.label as IntervalSet);\r\n                    }\r\n                }\r\n            }\r\n\r\n            let newTransition: Transition;\r\n            if (matchSet.intervals.length === 1) {\r\n                if (matchSet.size === 1) {\r\n                    newTransition = new AtomTransition(blockEndState, matchSet.minElement);\r\n                } else {\r\n                    const matchInterval: Interval = matchSet.intervals[0];\r\n                    newTransition = new RangeTransition(blockEndState, matchInterval.a, matchInterval.b);\r\n                }\r\n            } else {\r\n                newTransition = new SetTransition(blockEndState, matchSet);\r\n            }\r\n\r\n            const setOptimizedState: ATNState = new BasicState();\r\n            setOptimizedState.setRuleIndex(decision.ruleIndex);\r\n            atn.addState(setOptimizedState);\r\n\r\n            setOptimizedState.addTransition(newTransition);\r\n            optimizedTransitions.push(new EpsilonTransition(setOptimizedState));\r\n\r\n            removedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;\r\n\r\n            if (decision.isOptimized) {\r\n                while (decision.numberOfOptimizedTransitions > 0) {\r\n                    decision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);\r\n                }\r\n            }\r\n\r\n            for (const transition of optimizedTransitions) {\r\n                decision.addOptimizedTransition(transition);\r\n            }\r\n        }\r\n\r\n        if (ParserATNSimulator.debug) {\r\n            console.log(`ATN runtime optimizer removed ${removedPaths} paths by collapsing sets.`);\r\n        }\r\n\r\n        return removedPaths;\r\n    }\r\n\r\n    private static identifyTailCalls2(atn: ATN): void {\r\n        for (const state of atn.states) {\r\n            for (let i = 0; i < state.numberOfTransitions; i++) {\r\n                const transition = state.transition(i);\r\n                if (!(transition instanceof RuleTransition)) {\r\n                    continue;\r\n                }\r\n\r\n                transition.tailCall = this.testTailCall2(atn, transition, false);\r\n                transition.optimizedTailCall = this.testTailCall2(atn, transition, true);\r\n            }\r\n\r\n            if (!state.isOptimized) {\r\n                continue;\r\n            }\r\n\r\n            for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\r\n                const transition = state.getOptimizedTransition(i);\r\n                if (!(transition instanceof RuleTransition)) {\r\n                    continue;\r\n                }\r\n\r\n                transition.tailCall = this.testTailCall2(atn, transition, false);\r\n                transition.optimizedTailCall = this.testTailCall2(atn, transition, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static testTailCall2(atn: ATN, transition: RuleTransition, optimizedPath: boolean): boolean {\r\n        if (!optimizedPath && transition.tailCall) {\r\n            return true;\r\n        }\r\n        if (optimizedPath && transition.optimizedTailCall) {\r\n            return true;\r\n        }\r\n\r\n        const reachable: BitSet = new BitSet(atn.states.length);\r\n        const worklist: ATNState[] = [];\r\n        worklist.push(transition.followState);\r\n        while (true) {\r\n            const state = worklist.pop();\r\n            if (!state) {\r\n                break;\r\n            }\r\n\r\n            if (reachable.get(state.stateNumber)) {\r\n                continue;\r\n            }\r\n\r\n            if (state instanceof RuleStopState) {\r\n                continue;\r\n            }\r\n\r\n            if (!state.onlyHasEpsilonTransitions) {\r\n                return false;\r\n            }\r\n\r\n            const transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;\r\n            for (let i = 0; i < transitionCount; i++) {\r\n                const t = optimizedPath ? state.getOptimizedTransition(i) : state.transition(i);\r\n                if (t.serializationType !== TransitionType.EPSILON) {\r\n                    return false;\r\n                }\r\n\r\n                worklist.push(t.target);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override deserialize(@NotNull data: Uint16Array): ATN {\r\n        // Each Uint16 value in data is shifted by +2 at the entry to this method. This is an encoding optimization\r\n        // targeting the serialized values 0 and -1 (serialized to 0xFFFF), each of which are very common in the\r\n        // serialized form of the ATN. In the modified UTF-8 that Java uses for compiled string literals, these two\r\n        // character values have multi-byte forms. By shifting each value by +2, they become characters 2 and 1 prior to\r\n        // writing the string, each of which have single-byte representations. Since the shift occurs in the tool during\r\n        // ATN serialization, each target is responsible for adjusting the values during deserialization.\r\n        //\r\n        // As a special case, note that the first element of data is not adjusted because it contains the major version\r\n        // number of the serialized ATN, which was fixed at 3 at the time the value shifting was implemented.\r\n        const version: number = data[0];\r\n        if (version !== ATNDeserializer.SERIALIZED_VERSION) {\r\n            const reason =\r\n                `Could not deserialize ATN with version ${version} (expected ${ATNDeserializer.SERIALIZED_VERSION}).`;\r\n            throw new Error(reason);\r\n        }\r\n\r\n        data.forEach((value, index, array) => {\r\n            array[index] = (value - 2) & 0xFFFF;\r\n        });\r\n\r\n        let p = 1;\r\n\r\n        const uuid: UUID = ATNDeserializer.toUUID(data, p);\r\n        p += 8;\r\n        if (CompatibleATNDeserializer.SUPPORTED_UUIDS2.findIndex((e) => { return e.equals(uuid); }) < 0) {\r\n            const reason = `Could not deserialize ATN with UUID ${uuid.toString()} (expected ` +\r\n                `${CompatibleATNDeserializer.SERIALIZED_UUID2.toString()} or a legacy UUID).`;\r\n            throw new Error(reason);\r\n        }\r\n        const generatedByOriginalANTLR4 = uuid.equals(CompatibleATNDeserializer.ADDED_UNICODE_SMP_ORIGINAL);\r\n\r\n        const supportsLexerActions = CompatibleATNDeserializer.isFeatureSupported(\r\n            CompatibleATNDeserializer.ADDED_LEXER_ACTIONS2, uuid,\r\n        );\r\n\r\n        const grammarType: ATNType = data[p++];\r\n        const maxTokenType: number = data[p++];\r\n        const atn: ATN = new ATN(grammarType, maxTokenType);\r\n\r\n        //\r\n        // STATES\r\n        //\r\n        const loopBackStateNumbers: Array<[LoopEndState, number]> = [];\r\n        const endStateNumbers: Array<[BlockStartState, number]> = [];\r\n        const nstates: number = data[p++];\r\n        for (let i = 0; i < nstates; i++) {\r\n            const stype: ATNStateType = data[p++];\r\n            // ignore bad type of states\r\n            if (stype === ATNStateType.INVALID_TYPE) {\r\n                atn.addState(new InvalidState());\r\n                continue;\r\n            }\r\n\r\n            let ruleIndex: number = data[p++];\r\n            if (ruleIndex === 0xFFFF) {\r\n                ruleIndex = -1;\r\n            }\r\n\r\n            const s: ATNState = this.stateFactory(stype, ruleIndex);\r\n            if (stype === ATNStateType.LOOP_END) { // special case\r\n                const loopBackStateNumber: number = data[p++];\r\n                loopBackStateNumbers.push([s as LoopEndState, loopBackStateNumber]);\r\n            } else if (s instanceof BlockStartState) {\r\n                const endStateNumber: number = data[p++];\r\n                endStateNumbers.push([s, endStateNumber]);\r\n            }\r\n            atn.addState(s);\r\n        }\r\n\r\n        // delay the assignment of loop back and end states until we know all the state instances have been initialized\r\n        for (const pair of loopBackStateNumbers) {\r\n            pair[0].loopBackState = atn.states[pair[1]];\r\n        }\r\n\r\n        for (const pair of endStateNumbers) {\r\n            pair[0].endState = atn.states[pair[1]] as BlockEndState;\r\n        }\r\n\r\n        const numNonGreedyStates: number = data[p++];\r\n        for (let i = 0; i < numNonGreedyStates; i++) {\r\n            const stateNumber: number = data[p++];\r\n            (atn.states[stateNumber] as DecisionState).nonGreedy = true;\r\n        }\r\n\r\n        if (!generatedByOriginalANTLR4) {\r\n            const numSllDecisions: number = data[p++];\r\n            for (let i = 0; i < numSllDecisions; i++) {\r\n                const stateNumber: number = data[p++];\r\n                (atn.states[stateNumber] as DecisionState).sll = true;\r\n            }\r\n        }\r\n\r\n        const numPrecedenceStates: number = data[p++];\r\n        for (let i = 0; i < numPrecedenceStates; i++) {\r\n            const stateNumber: number = data[p++];\r\n            (atn.states[stateNumber] as RuleStartState).isPrecedenceRule = true;\r\n        }\r\n\r\n        //\r\n        // RULES\r\n        //\r\n        const nrules: number = data[p++];\r\n        if (atn.grammarType === ATNType.LEXER) {\r\n            atn.ruleToTokenType = new Int32Array(nrules);\r\n        }\r\n\r\n        atn.ruleToStartState = new Array<RuleStartState>(nrules);\r\n        for (let i = 0; i < nrules; i++) {\r\n            const s: number = data[p++];\r\n            const startState: RuleStartState = atn.states[s] as RuleStartState;\r\n            if (!generatedByOriginalANTLR4) {\r\n                startState.leftFactored = data[p++] !== 0;\r\n            }\r\n            atn.ruleToStartState[i] = startState;\r\n            if (atn.grammarType === ATNType.LEXER) {\r\n                let tokenType: number = data[p++];\r\n                if (tokenType === 0xFFFF) {\r\n                    tokenType = Token.EOF;\r\n                }\r\n\r\n                atn.ruleToTokenType[i] = tokenType;\r\n\r\n                if (!CompatibleATNDeserializer.isFeatureSupported(\r\n                    CompatibleATNDeserializer.ADDED_LEXER_ACTIONS2, uuid)) {\r\n                    // this piece of unused metadata was serialized prior to the\r\n                    // addition of LexerAction\r\n                    let actionIndexIgnored: number = data[p++];\r\n                    if (actionIndexIgnored === 0xFFFF) {\r\n                        actionIndexIgnored = -1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        atn.ruleToStopState = new Array<RuleStopState>(nrules);\r\n        for (const state of atn.states) {\r\n            if (!(state instanceof RuleStopState)) {\r\n                continue;\r\n            }\r\n\r\n            atn.ruleToStopState[state.ruleIndex] = state;\r\n            atn.ruleToStartState[state.ruleIndex].stopState = state;\r\n        }\r\n\r\n        //\r\n        // MODES\r\n        //\r\n        const nmodes: number = data[p++];\r\n        for (let i = 0; i < nmodes; i++) {\r\n            const s: number = data[p++];\r\n            atn.modeToStartState.push(atn.states[s] as TokensStartState);\r\n        }\r\n\r\n        atn.modeToDFA = new Array<DFA>(nmodes);\r\n        for (let i = 0; i < nmodes; i++) {\r\n            atn.modeToDFA[i] = new DFA(atn.modeToStartState[i]);\r\n        }\r\n\r\n        //\r\n        // SETS\r\n        //\r\n        const sets: IntervalSet[] = [];\r\n        // First, read all sets with 16-bit Unicode code points <= U+FFFF.\r\n        p = this.deserializeSets2(data, p, sets,\r\n            CompatibleATNDeserializer.getUnicodeDeserializer2(UnicodeDeserializingMode.UNICODE_BMP));\r\n\r\n        // Next, if the ATN was serialized with the Unicode SMP feature,\r\n        // deserialize sets with 32-bit arguments <= U+10FFFF.\r\n        if (CompatibleATNDeserializer.isFeatureSupported(CompatibleATNDeserializer.ADDED_UNICODE_SMP2, uuid)\r\n            || CompatibleATNDeserializer.isFeatureSupported(\r\n                CompatibleATNDeserializer.ADDED_UNICODE_SMP_ORIGINAL, uuid)) {\r\n            p = this.deserializeSets2(data, p, sets,\r\n                CompatibleATNDeserializer.getUnicodeDeserializer2(UnicodeDeserializingMode.UNICODE_SMP));\r\n        }\r\n\r\n        //\r\n        // EDGES\r\n        //\r\n        const nedges: number = data[p++];\r\n        for (let i = 0; i < nedges; i++) {\r\n            const src: number = ATNDeserializer.toInt(data[p]);\r\n            const trg: number = ATNDeserializer.toInt(data[p + 1]);\r\n            const ttype: number = ATNDeserializer.toInt(data[p + 2]);\r\n            const arg1: number = ATNDeserializer.toInt(data[p + 3]);\r\n            const arg2: number = ATNDeserializer.toInt(data[p + 4]);\r\n            const arg3: number = ATNDeserializer.toInt(data[p + 5]);\r\n            const trans: Transition = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\r\n            const srcState: ATNState = atn.states[src];\r\n            srcState.addTransition(trans);\r\n            p += 6;\r\n        }\r\n\r\n        // edges for rule stop states can be derived, so they aren't serialized\r\n        interface T { stopState: number; returnState: number; outermostPrecedenceReturn: number; }\r\n        const returnTransitionsSet = new Array2DHashSet<T>({\r\n            hashCode: (o: T) => { return o.stopState ^ o.returnState ^ o.outermostPrecedenceReturn; },\r\n\r\n            equals: (a: T, b: T): boolean => {\r\n                return a.stopState === b.stopState\r\n                    && a.returnState === b.returnState\r\n                    && a.outermostPrecedenceReturn === b.outermostPrecedenceReturn;\r\n            },\r\n        });\r\n        const returnTransitions: T[] = [];\r\n        for (const state of atn.states) {\r\n            const returningToLeftFactored: boolean = state.ruleIndex >= 0\r\n                && atn.ruleToStartState[state.ruleIndex].leftFactored;\r\n            for (let i = 0; i < state.numberOfTransitions; i++) {\r\n                const t: Transition = state.transition(i);\r\n                if (!(t instanceof RuleTransition)) {\r\n                    continue;\r\n                }\r\n\r\n                const ruleTransition: RuleTransition = t;\r\n                const returningFromLeftFactored = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;\r\n                if (!returningFromLeftFactored && returningToLeftFactored) {\r\n                    continue;\r\n                }\r\n\r\n                let outermostPrecedenceReturn = -1;\r\n                if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {\r\n                    if (ruleTransition.precedence === 0) {\r\n                        outermostPrecedenceReturn = ruleTransition.target.ruleIndex;\r\n                    }\r\n                }\r\n\r\n                const current = {\r\n                    stopState: ruleTransition.target.ruleIndex,\r\n                    returnState: ruleTransition.followState.stateNumber,\r\n                    outermostPrecedenceReturn,\r\n                };\r\n                if (returnTransitionsSet.add(current)) {\r\n                    returnTransitions.push(current);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Add all elements from returnTransitions to the ATN\r\n        for (const returnTransition of returnTransitions) {\r\n            const transition = new EpsilonTransition(atn.states[returnTransition.returnState],\r\n                returnTransition.outermostPrecedenceReturn);\r\n            atn.ruleToStopState[returnTransition.stopState].addTransition(transition);\r\n        }\r\n\r\n        for (const state of atn.states) {\r\n            if (state instanceof BlockStartState) {\r\n                // we need to know the end state to set its start state\r\n                if (state.endState == null) {\r\n                    throw new Error(\"IllegalStateException\");\r\n                }\r\n\r\n                // block end states can only be associated to a single block start state\r\n                if (state.endState.startState !== undefined) {\r\n                    throw new Error(\"IllegalStateException\");\r\n                }\r\n\r\n                state.endState.startState = state;\r\n            }\r\n\r\n            if (state instanceof PlusLoopbackState) {\r\n                const loopbackState: PlusLoopbackState = state;\r\n                for (let i = 0; i < loopbackState.numberOfTransitions; i++) {\r\n                    const target: ATNState = loopbackState.transition(i).target;\r\n                    if (target instanceof PlusBlockStartState) {\r\n                        target.loopBackState = loopbackState;\r\n                    }\r\n                }\r\n            } else if (state instanceof StarLoopbackState) {\r\n                const loopbackState: StarLoopbackState = state;\r\n                for (let i = 0; i < loopbackState.numberOfTransitions; i++) {\r\n                    const target: ATNState = loopbackState.transition(i).target;\r\n                    if (target instanceof StarLoopEntryState) {\r\n                        target.loopBackState = loopbackState;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //\r\n        // DECISIONS\r\n        //\r\n        const ndecisions: number = data[p++];\r\n        for (let i = 1; i <= ndecisions; i++) {\r\n            const s: number = data[p++];\r\n            const decState: DecisionState = atn.states[s] as DecisionState;\r\n            atn.decisionToState.push(decState);\r\n            decState.decision = i - 1;\r\n        }\r\n\r\n        //\r\n        // LEXER ACTIONS\r\n        //\r\n        if (atn.grammarType === ATNType.LEXER) {\r\n            if (supportsLexerActions) {\r\n                atn.lexerActions = new Array<LexerAction>(data[p++]);\r\n                for (let i = 0; i < atn.lexerActions.length; i++) {\r\n                    const actionType: LexerActionType = data[p++];\r\n                    let data1: number = data[p++];\r\n                    if (data1 === 0xFFFF) {\r\n                        data1 = -1;\r\n                    }\r\n\r\n                    let data2: number = data[p++];\r\n                    if (data2 === 0xFFFF) {\r\n                        data2 = -1;\r\n                    }\r\n\r\n                    const lexerAction: LexerAction = this.lexerActionFactory(actionType, data1, data2);\r\n\r\n                    atn.lexerActions[i] = lexerAction;\r\n                }\r\n            } else {\r\n                // for compatibility with older serialized ATNs, convert the old\r\n                // serialized action index for action transitions to the new\r\n                // form, which is the index of a LexerCustomAction\r\n                const legacyLexerActions: LexerAction[] = [];\r\n                for (const state of atn.states) {\r\n                    for (let i = 0; i < state.numberOfTransitions; i++) {\r\n                        const transition: Transition = state.transition(i);\r\n                        if (!(transition instanceof ActionTransition)) {\r\n                            continue;\r\n                        }\r\n\r\n                        const ruleIndex: number = transition.ruleIndex;\r\n                        const actionIndex: number = transition.actionIndex;\r\n                        const lexerAction: LexerCustomAction = new LexerCustomAction(ruleIndex, actionIndex);\r\n                        state.setTransition(i, new ActionTransition(transition.target, ruleIndex,\r\n                            legacyLexerActions.length, false));\r\n                        legacyLexerActions.push(lexerAction);\r\n                    }\r\n                }\r\n\r\n                atn.lexerActions = legacyLexerActions;\r\n            }\r\n        }\r\n\r\n        this.markPrecedenceDecisions(atn);\r\n\r\n        atn.decisionToDFA = new Array<DFA>(ndecisions);\r\n        for (let i = 0; i < ndecisions; i++) {\r\n            atn.decisionToDFA[i] = new DFA(atn.decisionToState[i], i);\r\n        }\r\n\r\n        if (this.deserializationOptions2.isVerifyATN) {\r\n            this.verifyATN(atn);\r\n        }\r\n\r\n        if (this.deserializationOptions2.isGenerateRuleBypassTransitions && atn.grammarType === ATNType.PARSER) {\r\n            atn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);\r\n            for (let i = 0; i < atn.ruleToStartState.length; i++) {\r\n                atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\r\n            }\r\n\r\n            for (let i = 0; i < atn.ruleToStartState.length; i++) {\r\n                const bypassStart: BasicBlockStartState = new BasicBlockStartState();\r\n                bypassStart.ruleIndex = i;\r\n                atn.addState(bypassStart);\r\n\r\n                const bypassStop: BlockEndState = new BlockEndState();\r\n                bypassStop.ruleIndex = i;\r\n                atn.addState(bypassStop);\r\n\r\n                bypassStart.endState = bypassStop;\r\n                atn.defineDecisionState(bypassStart);\r\n\r\n                bypassStop.startState = bypassStart;\r\n\r\n                let endState: ATNState | undefined;\r\n                let excludeTransition: Transition | undefined;\r\n                if (atn.ruleToStartState[i].isPrecedenceRule) {\r\n                    // wrap from the beginning of the rule to the StarLoopEntryState\r\n                    endState = undefined;\r\n                    for (const state of atn.states) {\r\n                        if (state.ruleIndex !== i) {\r\n                            continue;\r\n                        }\r\n\r\n                        if (!(state instanceof StarLoopEntryState)) {\r\n                            continue;\r\n                        }\r\n\r\n                        const maybeLoopEndState: ATNState = state.transition(state.numberOfTransitions - 1).target;\r\n                        if (!(maybeLoopEndState instanceof LoopEndState)) {\r\n                            continue;\r\n                        }\r\n\r\n                        if (maybeLoopEndState.epsilonOnlyTransitions\r\n                            && maybeLoopEndState.transition(0).target instanceof RuleStopState) {\r\n                            endState = state;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (!endState) {\r\n                        throw new Error(\"Couldn't identify final state of the precedence rule prefix section.\");\r\n                    }\r\n\r\n                    excludeTransition = (endState as StarLoopEntryState).loopBackState.transition(0);\r\n                } else {\r\n                    endState = atn.ruleToStopState[i];\r\n                }\r\n\r\n                // all non-excluded transitions that currently target end state need to target blockEnd instead\r\n                for (const state of atn.states) {\r\n                    for (let tansitionIndex = 0; tansitionIndex < state.numberOfTransitions; tansitionIndex++) {\r\n                        const transition = state.transition(tansitionIndex);\r\n                        if (transition === excludeTransition) {\r\n                            continue;\r\n                        }\r\n\r\n                        if (transition.target === endState) {\r\n                            transition.target = bypassStop;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // all transitions leaving the rule start state need to leave blockStart instead\r\n                while (atn.ruleToStartState[i].numberOfTransitions > 0) {\r\n                    const transition: Transition = atn.ruleToStartState[i].removeTransition(\r\n                        atn.ruleToStartState[i].numberOfTransitions - 1);\r\n                    bypassStart.addTransition(transition);\r\n                }\r\n\r\n                // link the new states\r\n                atn.ruleToStartState[i].addTransition(new EpsilonTransition(bypassStart));\r\n                bypassStop.addTransition(new EpsilonTransition(endState));\r\n\r\n                const matchState: ATNState = new BasicState();\r\n                atn.addState(matchState);\r\n                matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[i]));\r\n                bypassStart.addTransition(new EpsilonTransition(matchState));\r\n            }\r\n\r\n            if (this.deserializationOptions2.isVerifyATN) {\r\n                // reverify after modification\r\n                this.verifyATN(atn);\r\n            }\r\n        }\r\n\r\n        if (this.deserializationOptions2.isOptimize) {\r\n            while (true) {\r\n                let optimizationCount = 0;\r\n                optimizationCount += CompatibleATNDeserializer.inlineSetRules2(atn);\r\n                optimizationCount += CompatibleATNDeserializer.combineChainedEpsilons2(atn);\r\n                const preserveOrder: boolean = atn.grammarType === ATNType.LEXER;\r\n                optimizationCount += CompatibleATNDeserializer.optimizeSets2(atn, preserveOrder);\r\n                if (optimizationCount === 0) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (this.deserializationOptions2.isVerifyATN) {\r\n                // reverify after modification\r\n                this.verifyATN(atn);\r\n            }\r\n        }\r\n\r\n        CompatibleATNDeserializer.identifyTailCalls2(atn);\r\n\r\n        return atn;\r\n    }\r\n\r\n    private deserializeSets2(data: Uint16Array, p: number, sets: IntervalSet[],\r\n        unicodeDeserializer: IUnicodeDeserializer): number {\r\n        const nsets: number = data[p++];\r\n        for (let i = 0; i < nsets; i++) {\r\n            const nintervals: number = ATNDeserializer.toInt(data[p]);\r\n            p++;\r\n            const set: IntervalSet = new IntervalSet();\r\n            sets.push(set);\r\n\r\n            const containsEof: boolean = data[p++] !== 0;\r\n            if (containsEof) {\r\n                set.add(-1);\r\n            }\r\n\r\n            for (let j = 0; j < nintervals; j++) {\r\n                const a: number = unicodeDeserializer.readUnicode(data, p);\r\n                p += unicodeDeserializer.size;\r\n                const b: number = unicodeDeserializer.readUnicode(data, p);\r\n                p += unicodeDeserializer.size;\r\n                set.add(a, b);\r\n            }\r\n        }\r\n\r\n        return p;\r\n    }\r\n}\r\n"]}