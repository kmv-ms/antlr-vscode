import { Vocabulary } from "antlr4ts";
import { ParseTree } from "antlr4ts/tree";
import { BaseSymbol } from "antlr4-c3";
import { ISymbolInfo, IDiagnosticEntry, IReferenceNode, IGenerationOptions, ISentenceGenerationOptions, IFormattingOptions, IDefinition, IContextDetails, CodeActionType, SymbolKind } from "./types";
import { IInterpreterData } from "./InterpreterDataReader";
import { ContextSymbolTable } from "./ContextSymbolTable";
import { IATNGraphData } from "../webview-scripts/types";
export declare class SourceContext {
    fileName: string;
    private extensionDir;
    private static globalSymbols;
    private static symbolToKindMap;
    private static printableChars;
    symbolTable: ContextSymbolTable;
    sourceId: string;
    info: IContextDetails;
    diagnostics: IDiagnosticEntry[];
    private references;
    private rrdScripts;
    private semanticAnalysisDone;
    private tokenStream;
    private parser;
    private errorListener;
    private lexerErrorListener;
    private grammarLexerData;
    private grammarLexerRuleMap;
    private grammarParserData;
    private grammarParserRuleMap;
    private tree;
    constructor(fileName: string, extensionDir: string);
    get isInterpreterDataLoaded(): boolean;
    get interpreterData(): [IInterpreterData | undefined, IInterpreterData | undefined];
    get hasErrors(): boolean;
    static getKindFromSymbol(symbol: BaseSymbol): SymbolKind;
    static definitionForContext(ctx: ParseTree | undefined, keepQuotes: boolean): IDefinition | undefined;
    symbolAtPosition(column: number, row: number, limitToChildren: boolean): ISymbolInfo | undefined;
    enclosingSymbolAtPosition(column: number, row: number, ruleScope: boolean): ISymbolInfo | undefined;
    listTopLevelSymbols(includeDependencies: boolean): ISymbolInfo[];
    getVocabulary(): Vocabulary | undefined;
    getRuleList(): string[] | undefined;
    getChannels(): string[] | undefined;
    getModes(): string[] | undefined;
    listActions(type: CodeActionType): ISymbolInfo[];
    getActionCounts(): Map<CodeActionType, number>;
    getCodeCompletionCandidates(column: number, row: number): Promise<ISymbolInfo[]>;
    setText(source: string): void;
    parse(): string[];
    getDiagnostics(): IDiagnosticEntry[];
    getReferenceGraph(): Map<string, IReferenceNode>;
    getRRDScript(ruleName: string): string | undefined;
    addAsReferenceTo(context: SourceContext): void;
    removeDependency(context: SourceContext): void;
    getReferenceCount(symbol: string): number;
    getAllSymbols(recursive: boolean): Promise<BaseSymbol[]>;
    ruleFromPosition(column: number, row: number): [string | undefined, number | undefined];
    generate(dependencies: Set<SourceContext>, options: IGenerationOptions): Promise<string[]>;
    getATNGraph(rule: string): IATNGraphData | undefined;
    generateSentence(dependencies: Set<SourceContext>, rule: string, options: ISentenceGenerationOptions, callback: (sentence: string, index: number) => void): void;
    lexTestInput(input: string, actionFile?: string): [string[], string];
    parseTestInput(input: string, startRule: string, actionFile?: string): string[];
    getSymbolInfo(symbol: string | BaseSymbol): ISymbolInfo | undefined;
    resolveSymbol(symbolName: string): BaseSymbol | undefined;
    formatGrammar(options: IFormattingOptions, start: number, stop: number): [string, number, number];
    setupInterpreters(outputDir?: string): string;
    private doGeneration;
    private runSemanticAnalysisIfNeeded;
    private intervalSetToStrings;
}
