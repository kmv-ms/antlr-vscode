{"version":3,"file":"ErrorParser.js","sourceRoot":"","sources":["../../../src/backend/ErrorParser.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\n/* eslint-disable max-len */\r\n\r\nimport { IDiagnosticEntry, DiagnosticType } from \"./types\";\r\nimport { SourceContext } from \"./SourceContext\";\r\n\r\n/**\r\n * ANTLR uses ST templates for generating messages. We use the \"antlr\" message format which is generated from\r\n * the following template rules:\r\n *   location(file, line, column) ::= \"<file>:<line>:<column>:\"\r\n *   message(id, text) ::= \"(<id>) <text>\"\r\n *   report(location, message, type) ::= \"<type>(<message.id>): <location> <message.text>\"\r\n *   wantsSingleLineMessage() ::= \"false\"\r\n */\r\n\r\nexport class ErrorParser {\r\n    private static errorPattern = /(\\w+)\\s*\\((\\d+)\\):\\s*((?:\\w:)?[^:]*):(\\d*):(\\d*):\\s*(.+)/;\r\n    private static errorCodeToPattern: Map<number, RegExp> = new Map([\r\n        [8, /grammar name (\\w+)/],\r\n        [56, /:\\s+(\\w+)/],\r\n        [57, /rule (\\w+) in non-local ref (\\w+)/],\r\n        [63, /reference (\\w+) in (\\w+)/],\r\n        [64, /parameter (\\w+) of rule (\\w+) is not accessible in this scope: (\\w+)/],\r\n        [65, /attribute (\\w+) for rule (\\w+) in (\\w+)/],\r\n        [66, /attribute (\\w+) isn't a valid property in (\\w+)/],\r\n        [67, /reference (\\w+) in (\\w+)/],\r\n        [69, /label (\\w+)/],\r\n        [70, /label (\\w+)/],\r\n        [72, /label (\\w+)/],\r\n        [73, /label (\\w+)/],\r\n        [74, /label (\\w+)/],\r\n        [75, /label (\\w+)[^:]+: (\\w+)/],\r\n        [76, /value (\\w+)/],\r\n        [79, /reference: (\\w+)/],\r\n        [80, /rule (\\w+)/],\r\n        [84, /value (\\w+)/],\r\n        [94, /of (\\w+)/],\r\n        [106, /rule (\\w+)/],\r\n        [108, /name (\\w+)/],\r\n        [110, /grammar (\\w+)/],\r\n        [111, /import \\w+ grammar (\\w+)/],\r\n        [113, /import \\w+ grammar (\\w+)/],\r\n        [160, /file (\\w+)/],\r\n        [118, /alt (\\w+)/],\r\n        [122, /rule (\\w+)/],\r\n        [123, /alt label (\\w+) redefined in rule (\\w+), originally in rule (\\w+)/],\r\n        [124, /label (\\w+) conflicts with rule (\\w+)/],\r\n\r\n        [125, /of token (\\w+)/],\r\n        [126, /grammar: (\\w+)/],\r\n        [128, /actions: (\\$\\w+)/],\r\n        [130, /label (\\w+)/],\r\n        [131, /block \\(\\)(\\w+)/],\r\n        [132, /rule (\\w+)/],\r\n        [133, /rule (\\w+)/],\r\n        [134, /symbol (\\w+)/],\r\n        //[134, /rule reference (\\w+)/], Duplicate error code.\r\n        [135, /label (\\w+)/],\r\n        [136, /value (\\w+)/],\r\n        [137, /value (\\w+)/],\r\n        [138, /parameter (\\w+)/],\r\n        [139, /parameter (\\w+)/],\r\n        [140, /local (\\w+)/],\r\n        [141, /local (\\w+)/],\r\n        [142, /local (\\w+)/],\r\n        [143, /local (\\w+)/],\r\n        [144, /sets: (\\w+)/],\r\n        [145, /mode (\\w+)/],\r\n        [146, /rule (\\w+)/],\r\n        [147, /rule (\\w+)/],\r\n        [148, /rule (\\w+)/],\r\n        [149, /command (\\w+)/],\r\n        [150, /command (\\w+)/],\r\n        [151, /command (\\w+)/],\r\n        [153, /rule (\\w+)/],\r\n        [154, /rule (\\w+)/],\r\n        [155, /rule (\\w+)/],\r\n        [156, /sequence (\\w+)/],\r\n        [158, /rule (\\w+)/],\r\n        [159, /name (\\w+)/],\r\n        [161, /channel (\\w+)/],\r\n        [162, /channel (\\w+)/],\r\n        [169, /rule (\\w+)/],\r\n        [170, /mode (\\w+)/],\r\n        [171, /name (\\w+)/],\r\n        [172, /name (\\w+)/],\r\n        [173, /name (\\w+)/],\r\n        [174, /empty: (\\w+)/],\r\n        [175, /(\\w+) is not/],\r\n        [176, /(\\w+) is not/],\r\n        [177, /(\\w+) is not/],\r\n        [178, /command (\\w+)/],\r\n        [179, /commands (\\w+)/],\r\n        [180, /used multiple times in set (.+)/],\r\n        [181, /parser: ('[^']+'\\.\\.'[^']+')/],\r\n        [182, /range: (\\w+)/],\r\n    ]);\r\n\r\n    public constructor(private contexts: Set<SourceContext>) {\r\n        contexts.forEach((context) => {\r\n            context.diagnostics.length = 0; // Remove all own diagnostics. We use ANTLR generated ones now.\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts errors generated by the ANTLR tool into our diagnostics structure for reporting.\r\n     *\r\n     * @param text The error text.\r\n     *\r\n     * @returns True if the conversion was successful, false otherwise.\r\n     */\r\n    public convertErrorsToDiagnostics(text: string): boolean {\r\n        const lines = text.split(\"\\n\");\r\n        for (const line of lines) {\r\n            if (line.length > 0) {\r\n                const firstLevelMatches = ErrorParser.errorPattern.exec(line);\r\n                if (!firstLevelMatches) {\r\n                    // If we find something that doesn't conform to an ANTLR error we got probably\r\n                    // another unexpected error (crash in ANTLR, execution problem etc.).\r\n                    // Return a flag to indicate that.\r\n                    return false;\r\n                } else {\r\n                    const fileName = firstLevelMatches[3];\r\n\r\n                    // Find the context this error belongs to.\r\n                    let context: SourceContext | undefined;\r\n                    for (const candidate of this.contexts) {\r\n                        // Usually error messages come with the full path, but in case of grammar <-> filename conflicts\r\n                        // we only get the base name.\r\n                        if (candidate.fileName === fileName || candidate.fileName.endsWith(fileName)) {\r\n                            context = candidate;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!context) {\r\n                        continue;\r\n                    }\r\n\r\n                    const errorCode = Number(firstLevelMatches[2]);\r\n                    const errorText = firstLevelMatches[6];\r\n\r\n                    // The error message contains positioning information if only a single symbol is causing\r\n                    // the problem. For many error messages, however, there are multiple symbols involved\r\n                    // (e.g. indirect left recursion) or non-symbol related problems occurred (e.g. grammar name\r\n                    // doesn't match file name).\r\n                    // For all these cases we need to scan the error message for details.\r\n                    if (firstLevelMatches[4].length > 0) {\r\n                        let range = {\r\n                            start: { row: Number(firstLevelMatches[4]), column: Number(firstLevelMatches[5]) },\r\n                            end: { row: Number(firstLevelMatches[4]), column: Number(firstLevelMatches[5]) + 1 },\r\n                        };\r\n\r\n                        switch (errorCode) {\r\n                            case 8: // \"grammar name <arg> and file name <arg2> differ\", ErrorSeverity.ERROR\r\n                            case 56: // \"reference to undefined rule: <arg>\", ErrorSeverity.ERROR\r\n                            case 57: // \"reference to undefined rule <arg> in non-local ref <arg3>\", ErrorSeverity.ERROR\r\n                            case 63: // \"unknown attribute reference <arg> in <arg2>\", ErrorSeverity.ERROR\r\n                            case 64: // \"parameter <arg> of rule <arg2> is not accessible in this scope: <arg3>\", ErrorSeverity.ERROR\r\n                            case 65: // \"unknown attribute <arg> for rule <arg2> in <arg3>\", ErrorSeverity.ERROR\r\n                            case 66: // \"attribute <arg> isn't a valid property in <arg2>\", ErrorSeverity.ERROR\r\n                            case 67: // \"missing attribute access on rule reference <arg> in <arg2>\", ErrorSeverity.ERROR\r\n                            case 75: // \"label <arg> type mismatch with previous definition: <arg2>\", ErrorSeverity.ERROR\r\n                            case 79: // \"missing argument(s) on rule reference: <arg>\", ErrorSeverity.ERROR\r\n                            case 84: // \"unsupported option value <arg>=<arg2>\", ErrorSeverity.WARNING\r\n                            case 94: // \"redefinition of <arg> action\", ErrorSeverity.ERROR\r\n                            case 106: // \"rule <arg2> is not defined in grammar <arg>\", ErrorSeverity.ERROR\r\n                            case 108: // \"token name <arg> is already defined\", ErrorSeverity.WARNING\r\n                            case 110: // \"can't find or load grammar <arg>\", ErrorSeverity.ERROR\r\n                            case 111: // \"<arg.typeString> grammar <arg.name> cannot import <arg2.typeString> grammar <arg2.name>\", ErrorSeverity.ERROR\r\n                            case 113: // \"<arg.typeString> grammar <arg.name> and imported <arg2.typeString> grammar <arg2.name> both generate <arg2.recognizerName>\", ErrorSeverity.ERROR\r\n                            case 118: // deprecated, \"all operators of alt <arg> of left-recursive rule must have same associativity\", ErrorSeverity.WARNING\r\n                            case 122: // \"rule <arg>: must label all alternatives or none\", ErrorSeverity.ERROR\r\n                            case 123: // \"rule alt label <arg> redefined in rule <arg2>, originally in rule <arg3>\", ErrorSeverity.ERROR\r\n                            case 125: // \"implicit definition of token <arg> in parser\", ErrorSeverity.WARNING\r\n                            case 126: // \"cannot create implicit token for string literal in non-combined grammar: <arg>\", ErrorSeverity.ERROR\r\n                            case 128: // \"attribute references not allowed in lexer actions: $<arg>\", ErrorSeverity.ERROR\r\n                            case 130: // \"label <arg> assigned to a block which is not a set\", ErrorSeverity.ERROR\r\n                            case 131: // \"greedy block ()<arg> contains wildcard; the non-greedy syntax ()<arg>? may be preferred\", ErrorSeverity.WARNING\r\n                            case 132: // \"action in lexer rule <arg> must be last element of single outermost alt\", ErrorSeverity.ERROR\r\n                            case 133: // \"->command in lexer rule <arg> must be last element of single outermost alt\", ErrorSeverity.ERROR\r\n                            case 134: // \"symbol <arg> conflicts with generated code in target language or runtime\", ErrorSeverity.ERROR\r\n                            case 135: // \"cannot assign a value to list label <arg>\", ErrorSeverity.ERROR\r\n                            case 136: // \"return value <arg> conflicts with rule with same name\", ErrorSeverity.ERROR\r\n                            case 137: // \"return value <arg> conflicts with token with same name\", ErrorSeverity.ERROR\r\n                            case 138: // \"parameter <arg> conflicts with rule with same name\", ErrorSeverity.ERROR\r\n                            case 139: // \"parameter <arg> conflicts with token with same name\", ErrorSeverity.ERROR\r\n                            case 140: // \"local <arg> conflicts with rule with same name\", ErrorSeverity.ERROR\r\n                            case 141: // \"local <arg> conflicts with rule token same name\", ErrorSeverity.ERROR\r\n                            case 142: // \"local <arg> conflicts with parameter with same name\", ErrorSeverity.ERROR\r\n                            case 143: // \"local <arg> conflicts with return value with same name\", ErrorSeverity.ERROR\r\n                            case 144: // \"multi-character literals are not allowed in lexer sets: <arg>\", ErrorSeverity.ERROR\r\n                            case 145: // \"lexer mode <arg> must contain at least one non-fragment rule\", ErrorSeverity.ERROR\r\n                            case 146: // \"non-fragment lexer rule <arg> can match the empty string\", ErrorSeverity.WARNING\r\n                            case 147: // \"left recursive rule <arg> must contain an alternative which is not left recursive\", ErrorSeverity.ERROR\r\n                            case 148: // \"left recursive rule <arg> contains a left recursive alternative which can be followed by the empty string\", ErrorSeverity.ERROR\r\n                            case 149: // \"lexer command <arg> does not exist or is not supported by the current target\", ErrorSeverity.ERROR\r\n                            case 150: // \"missing argument for lexer command <arg>\", ErrorSeverity.ERROR\r\n                            case 151: // \"lexer command <arg> does not take any arguments\", ErrorSeverity.ERROR\r\n                            case 153: // \"rule <arg> contains a closure with at least one alternative that can match an empty string\", ErrorSeverity.ERROR\r\n                            case 154: // \"rule <arg> contains an optional block with at least one alternative that can match an empty string\", ErrorSeverity.WARNING\r\n                            case 155: // \"rule <arg> contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\", ErrorSeverity.WARNING\r\n                            case 156: // \"invalid escape sequence <arg>\", ErrorSeverity.WARNING\r\n                            case 158: // \"fragment rule <arg> contains an action or command which can never be executed\", ErrorSeverity.WARNING\r\n                            case 159: // \"cannot declare a rule with reserved name <arg>\", ErrorSeverity.ERROR\r\n                            case 160: // \"cannot find tokens file <arg>\", ErrorSeverity.ERROR\r\n                            case 161: // \"channel <arg> conflicts with token with same name\", ErrorSeverity.ERROR\r\n                            case 162: // \"channel <arg> conflicts with mode with same name\", ErrorSeverity.ERROR\r\n                            case 169: // \"rule <arg> is left recursive but doesn't conform to a errorPattern ANTLR can handle\", ErrorSeverity.ERROR\r\n                            case 170: // \"mode <arg> conflicts with token with same name\", ErrorSeverity.ERROR\r\n                            case 171: // \"cannot use or declare token with reserved name <arg>\", ErrorSeverity.ERROR\r\n                            case 172: // \"cannot use or declare channel with reserved name <arg>\", ErrorSeverity.ERROR\r\n                            case 173: // \"cannot use or declare mode with reserved name <arg>\", ErrorSeverity.ERROR\r\n                            case 174: // \"string literals and sets cannot be empty: <arg>\", ErrorSeverity.ERROR\r\n                            case 175: // \"<arg> is not a recognized token name\", ErrorSeverity.ERROR\r\n                            case 176: // \"<arg> is not a recognized mode name\", ErrorSeverity.ERROR\r\n                            case 177: // \"<arg> is not a recognized channel name\", ErrorSeverity.ERROR\r\n                            case 178: // \"duplicated command <arg>\", ErrorSeverity.WARNING\r\n                            case 179: // \"incompatible commands <arg> and <arg2>\", ErrorSeverity.WARNING\r\n                            case 180: // \"chars <arg> used multiple times in set <arg2>\", ErrorSeverity.WARNING\r\n                            case 181: // \"token ranges not allowed in parser: <arg>..<arg2>\", ErrorSeverity.ERROR\r\n                            case 182: { // \"unicode property escapes not allowed in lexer charset range: <arg>\", ErrorSeverity.ERROR\r\n                                const matches = ErrorParser.errorCodeToPattern.get(errorCode)!.exec(errorText);\r\n                                if (matches) {\r\n                                    if (matches.length > 2) {\r\n                                        // Multiple symbols in the message.\r\n                                        const symbols: string[] = [];\r\n                                        for (let i = 1; i < symbols.length; ++i) { // Not the first entry\r\n                                            symbols.push(matches[i]);\r\n                                        }\r\n\r\n                                        this.addDiagnosticsForSymbols(symbols, errorText, DiagnosticType.Error,\r\n                                            context);\r\n                                        continue;\r\n                                    }\r\n                                    range.end.column += matches[1].length - 1; // -1 for the +1 we use as default.\r\n                                }\r\n                                break;\r\n                            }\r\n\r\n                            case 50: { // \"syntax error: <arg>\", ErrorSeverity.ERROR\r\n                                // All kinds of syntax errors. No need to create dozens of error patterns,\r\n                                // but instead look for a quoted string which usually denotes the input char(s) that\r\n                                // caused the trouble.\r\n                                const matches = /\\(missing '[^']+'\\)?[^']+'([^']+)'/.exec(errorText);\r\n                                if (matches) {\r\n                                    range.end.column += matches[1].length - 1; // -1 for the +1 we use as default.\r\n                                }\r\n                                break;\r\n                            }\r\n\r\n                            case 69: // \"label <arg> conflicts with rule with same name\", ErrorSeverity.ERROR\r\n                            case 70: // \"label <arg> conflicts with token with same name\", ErrorSeverity.ERROR\r\n                            case 72: // \"label <arg> conflicts with parameter with same name\", ErrorSeverity.ERROR\r\n                            case 73: // \"label <arg> conflicts with return value with same name\", ErrorSeverity.ERROR\r\n                            case 74: // \"label <arg> conflicts with local with same name\", ErrorSeverity.ERROR\r\n                            case 76: // \"return value <arg> conflicts with parameter with same name\", ErrorSeverity.ERROR\r\n                            case 80:  // \"rule <arg> has no defined parameters\", ErrorSeverity.ERROR\r\n                            case 124: { // \"rule alt label <arg> conflicts with rule <arg2>\", ErrorSeverity.ERROR\r\n                                const matches = ErrorParser.errorCodeToPattern.get(errorCode)!.exec(errorText);\r\n                                if (matches) {\r\n                                    // We're adding two entries here: one for each symbol.\r\n                                    this.addDiagnosticsForSymbols([matches[1]], errorText, DiagnosticType.Warning,\r\n                                        context);\r\n                                    range.end.column += matches[1].length - 1;\r\n                                }\r\n                                break;\r\n                            }\r\n\r\n                            case 83: { // \"unsupported option <arg>\", ErrorSeverity.WARNING\r\n                                const matches = /unsupported option (\\w+)/.exec(errorText);\r\n                                if (matches) {\r\n                                    range.end.column += matches[1].length - 1;\r\n                                }\r\n                                break;\r\n                            }\r\n\r\n                            case 105: { // \"reference to undefined grammar in rule reference: <arg>.<arg2>\", ErrorSeverity.ERROR\r\n                                const matches = /reference: (\\w+).(\\w+)/.exec(errorText);\r\n                                if (matches) {\r\n                                    range.end.column += matches[1].length + matches[2].length;\r\n                                }\r\n                                break;\r\n                            }\r\n\r\n                            case 109: // \"options ignored in imported grammar <arg>\", ErrorSeverity.WARNING\r\n                                range.end.column += \"options\".length - 1;\r\n                                break;\r\n\r\n                            case 202: { // \"tokens {A; B;} syntax is now tokens {A, B} in ANTLR 4\", ErrorSeverity.WARNING\r\n                                const enclosingRange = context.enclosingSymbolAtPosition(range.start.column,\r\n                                    range.start.row, true);\r\n                                if (enclosingRange && enclosingRange.definition) {\r\n                                    range = enclosingRange.definition.range;\r\n                                }\r\n                                break;\r\n                            }\r\n\r\n                            case 157: // \"rule <arg> contains an assoc terminal option in an unrecognized location\", ErrorSeverity.WARNING\r\n                                range.end.column += \"assoc\".length - 1;\r\n                                break;\r\n\r\n                            case 204: // \"{...}?=> explicitly gated semantic predicates are deprecated in ANTLR 4; use {...}? instead\", ErrorSeverity.WARNING\r\n                                range.end.column += 7; // Arbitrary length, we have no info how long the predicate is.\r\n                                break;\r\n\r\n                            case 205: // \"(...)=> syntactic predicates are not supported in ANTLR 4\", ErrorSeverity.ERROR\r\n                                range.end.column += 1; // Just the arrow.\r\n                                break;\r\n\r\n                            default: {\r\n                                const info = context.symbolAtPosition(range.start.column, range.start.row, false);\r\n                                if (info) {\r\n                                    range.end.column += info.name.length - 1;\r\n                                }\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        const error: IDiagnosticEntry = {\r\n                            type: (firstLevelMatches[1] === \"error\") ? DiagnosticType.Error : DiagnosticType.Warning,\r\n                            message: errorText,\r\n                            range,\r\n                        };\r\n                        context.diagnostics.push(error);\r\n                    } else {\r\n                        switch (errorCode) {\r\n                            case 1: // \"cannot write file <arg>: <arg2>\", ErrorSeverity.ERROR\r\n                            case 2: // \"unknown command-line option <arg>\", ErrorSeverity.ERROR\r\n                            case 4: // \"error reading tokens file <arg>: <arg2>\", ErrorSeverity.ERROR\r\n                            case 5: // \"directory not found: <arg>\", ErrorSeverity.ERROR\r\n                            case 6: // \"output directory is a file: <arg>\", ErrorSeverity.ERROR\r\n                            case 7: // \"cannot find or open file: <arg><if(exception&&verbose)>; reason: <exception><endif>\", ErrorSeverity.ERROR\r\n                            case 9: // \"invalid -Dname=value syntax: <arg>\", ErrorSeverity.ERROR\r\n                            case 10: // \"warning treated as error\", ErrorSeverity.ERROR_ONE_OFF\r\n                            case 11: // \"error reading imported grammar <arg> referenced in <arg2>\", ErrorSeverity.ERROR\r\n                            case 20: // \"internal error: <arg> <arg2><if(exception&&verbose)>: <exception><stackTrace; separator=\\\"\\\\n\\\"><endif>\", ErrorSeverity.ERROR\r\n                            case 21: // \".tokens file syntax error <arg>:<arg2>\", ErrorSeverity.ERROR\r\n                            case 22: // \"template error: <arg> <arg2><if(exception&&verbose)>: <exception><stackTrace; separator=\\\"\\\\n\\\"><endif>\", ErrorSeverity.WARNING\r\n                            case 30: // \"can't find code generation templates: <arg>\", ErrorSeverity.ERROR\r\n                            case 31: // \"ANTLR cannot generate <arg> code as of version \"+ Tool.VERSION, ErrorSeverity.ERROR_ONE_OFF\r\n                            case 32: // \"code generation template <arg> has missing, misnamed, or incomplete arg list; missing <arg2>\", ErrorSeverity.ERROR\r\n                            case 33: // \"missing code generation template <arg>\", ErrorSeverity.ERROR\r\n                            case 34: // \"no mapping to template name for output model class <arg>\", ErrorSeverity.ERROR\r\n                            case 35: // \"<arg3> code generation target requires ANTLR <arg2>; it can't be loaded by the current ANTLR <arg>\", ErrorSeverity.ERROR\r\n                            case 54: // \"repeated grammar prequel spec (options, tokens, or import); please merge\", ErrorSeverity.ERROR\r\n                            case 99: // \"<if(arg2.implicitLexerOwner)>implicitly generated <endif>grammar <arg> has no rules\", ErrorSeverity.ERROR\r\n                                this.addGenericDiagnosis(errorText, DiagnosticType.Error, context);\r\n                                break;\r\n\r\n                            case 119: { // \"The following sets of rules are mutually left-recursive <arg:{c| [<c:{r|<r.name>}; separator=\\\", \\\">]}; separator=\\\" and \\\">\", ErrorSeverity.ERROR\r\n                                const matches = /\\[([^\\]]+)]/.exec(errorText);\r\n                                if (matches) {\r\n                                    const symbols = matches[1].split(\",\");\r\n                                    this.addDiagnosticsForSymbols(symbols, errorText, DiagnosticType.Error, context);\r\n                                }\r\n                                break;\r\n                            }\r\n\r\n                            case 180: {\r\n                                // Charset collision testing is currently buggy. It reports each problem twice, once from the optimizer\r\n                                // (w/o token position info, which is why we land here) and once with (handled above).\r\n                                // We ignore the duplicate w/o code position.\r\n                                break;\r\n                            }\r\n\r\n                            default:\r\n                                this.addGenericDiagnosis(\r\n                                    `[Internal Error] Unhandled error message (code ${errorCode}, message: ` +\r\n                                    `${errorText}\\nPlease file a bug report at ` +\r\n                                    \"https://github.com/mike-lischke/vscode-antlr4/issues)\",\r\n                                    DiagnosticType.Error, context);\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private addDiagnosticsForSymbols(symbols: string[], text: string, type: DiagnosticType,\r\n        context: SourceContext) {\r\n        for (const symbol of symbols) {\r\n            const info = context.getSymbolInfo(symbol.trim());\r\n            if (info) {\r\n                const error: IDiagnosticEntry = {\r\n                    type,\r\n                    message: text,\r\n                    range: info.definition!.range,\r\n                };\r\n                context.diagnostics.push(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private addGenericDiagnosis(text: string, type: DiagnosticType, context: SourceContext) {\r\n        const error: IDiagnosticEntry = {\r\n            type,\r\n            message: text,\r\n            range: { start: { column: 0, row: 1 }, end: { column: 0, row: 1 } },\r\n        };\r\n        context.diagnostics.push(error);\r\n    }\r\n}\r\n"]}