{"version":3,"file":"SentenceGenerator.js","sourceRoot":"","sources":["../../../src/backend/SentenceGenerator.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,uCAAyB;AACzB,uCAAyB;AAEzB,sCAGsB;AAGtB,wCAA4C;AAE5C,uCAAmE;AAEnE,6DAAmF;AAMnF,MAAa,iBAAiB;IAoCd;IACA;IApCJ,MAAM,CAAC,gBAAgB,CAAc;IAGtC,YAAY,CAAqB;IAEhC,eAAe,CAAyB;IACxC,gBAAgB,CAA0B;IAI1C,iBAAiB,CAAS;IAC1B,mBAAmB,CAAwB;IAC3C,oBAAoB,CAAwB;IAE5C,mBAAmB,CAAS;IAC5B,mBAAmB,CAAS;IAC5B,kBAAkB,CAAS;IAC3B,kBAAkB,CAAS;IAC3B,aAAa,CAAS;IACtB,iBAAiB,CAAS;IAC1B,eAAe,GAAG,IAAI,GAAG,EAAkB,CAAC;IAE5C,YAAY,CAAiB;IAG7B,WAAW,GAAa,EAAE,CAAC;IAQnC,YACI,OAAsB,EACd,SAA2B,EAC3B,UAAwC,EAChD,UAA8B;QAFtB,cAAS,GAAT,SAAS,CAAkB;QAC3B,eAAU,GAAV,UAAU,CAA8B;QAIhD,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,WAAW,CAAC,0BAA0B,CAAC,yCAAoB,CAAC,CAAC;QAC5F,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC,WAAW,CAAC,0BAA0B,CAAC,0CAAqB,CAAC,CAAC;QAG9F,IAAI,UAAU,EAAE;YACZ,MAAM,IAAI,GAAG,EAAE,CAAC,YAAY,CAAC,UAAU,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC,GAAG;;;aAGjE,CAAC;YAGF,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC,eAAe,CAAC,IAAI,CAAsB,CAAC;SACrE;IACL,CAAC;IAUM,QAAQ,CAAC,OAAmC,EAAE,KAAqB;QAEtE,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC,iBAAiB,IAAI,IAAI,CAAC;QAE3D,IAAI,CAAC,mBAAmB,GAAG,OAAO,CAAC,mBAAmB,IAAI,CAAC,CAAC;QAC5D,IAAI,IAAI,CAAC,mBAAmB,GAAG,CAAC,EAAE;YAC9B,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC;SAChC;aAAM;YACH,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;SACnE;QAED,IAAI,CAAC,mBAAmB,GAAG,OAAO,CAAC,mBAAmB,IAAI,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC;QACvF,IAAI,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,mBAAmB,EAAE;YACrD,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC;SAC3D;aAAM;YACH,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;SAClE;QAED,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,IAAI,CAAC,CAAC;QAC1D,IAAI,IAAI,CAAC,kBAAkB,GAAG,CAAC,EAAE;YAC7B,IAAI,CAAC,kBAAkB,GAAG,CAAC,CAAC;SAC/B;aAAM;YACH,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;SACjE;QAED,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,IAAI,IAAI,CAAC,kBAAkB,GAAG,EAAE,CAAC;QACrF,IAAI,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,kBAAkB,EAAE;YACnD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,kBAAkB,GAAG,EAAE,CAAC;SAC1D;aAAM;YACH,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;SAChE;QAED,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC,OAAO,CAAC,aAAa,IAAI,OAAO,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC;QACvG,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC,iBAAiB,IAAI,GAAG,CAAC;QAE1D,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;QAC7B,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,YAAY,CAAC;QAEzC,IAAI,CAAC,mBAAmB,GAAG,IAAI,GAAG,EAAoB,CAAC;QACvD,IAAI,CAAC,oBAAoB,GAAG,IAAI,GAAG,EAAoB,CAAC;QAExD,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;QAE5B,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,KAAK,CAAC,SAAS,EAAE,KAAK,CAAC,GAAG,KAAK,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;QAExG,OAAO,MAAM,CAAC;IAClB,CAAC;IAEM,OAAO,CAAC,SAAiB,EAAE,SAAiB,EAAE,OAAgB;QACjE,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,IAAI,SAAS,GAAG,EAAE,CAAC;YACnB,IAAI,OAAO,EAAE;gBACT,IAAI,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE;oBACzC,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC,OAAQ,CAAC,IAAI,CAAC;iBAC7D;aACJ;iBAAM;gBACH,IAAI,SAAS,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE;oBAC1C,SAAS,GAAG,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC,OAAQ,CAAC,IAAI,CAAC;iBAC9D;aACJ;YAED,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;gBACtB,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBACzD,IAAI;oBACA,OAAO,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;iBACvC;gBAAC,OAAO,CAAC,EAAE;oBACR,MAAM,KAAK,CAAC,kDAAkD,SAAS,KAAK;wBACxE,uBAAuB,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;iBAC5C;aACJ;SACJ;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAQO,WAAW,CAAC,OAAgB,EAAE,KAAa;QAC/C,IAAI,OAAO,EAAE;YACT,OAAO,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SAC1C;QAED,IAAI,IAAI,CAAC,UAAU,EAAE;YACjB,OAAO,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SAC3C;QAED,OAAO,SAAS,CAAC;IACrB,CAAC;IASO,UAAU,CAAC,IAAY;QAC3B,MAAM,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAC7C,IAAI,KAAK,EAAE;YACP,IAAI,KAAK,GAAG,IAAI,CAAC,aAAa,EAAE;gBAC5B,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;gBAE1C,OAAO,IAAI,CAAC;aACf;YAED,OAAO,KAAK,CAAC;SAChB;QAED,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QAElC,OAAO,IAAI,CAAC;IAChB,CAAC;IAQO,SAAS,CAAC,IAAY;QAC1B,IAAI,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAC3C,IAAI,KAAK,EAAE;YACP,EAAE,KAAK,CAAC;YACR,IAAI,KAAK,KAAK,CAAC,EAAE;gBACb,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;aACrC;iBAAM;gBACH,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;aACzC;SACJ;IACL,CAAC;IAWO,uBAAuB,CAAC,KAAe,EAAE,IAAc,EAAE,QAAiB;QAC9E,MAAM,OAAO,GAAG,KAAK,CAAC,GAAG,KAAK,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC;QACjD,MAAM,MAAM,GAAG,KAAK,CAAC,SAAS,KAAK,kBAAY,CAAC,UAAU,CAAC;QAE3D,IAAI,QAA4B,CAAC;QACjC,IAAI,MAAM,EAAE;YAER,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC;YACtD,IAAI,CAAC,QAAQ,EAAE;gBACX,OAAO,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;aACtB;YAED,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC,QAAQ,CAAC,CAAC;YACnD,IAAI,YAAY,EAAE;gBACd,IAAI,OAA2B,CAAC;gBAEhC,IAAI,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;oBAC7B,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE;wBAC3B,OAAO,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;qBAC7B;yBAAM,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;wBAChC,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC;wBACpE,MAAM,aAAa,GAAG,YAAY,CAAC,WAAW,CAAC,CAAC;wBAEhD,OAAO,GAAG,aAAa,CAAC;qBAC3B;iBACJ;qBAAM;oBACH,OAAO,GAAG,YAAY,CAAC;iBAC1B;gBAED,IAAI,OAAO,EAAE;oBACT,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,OAAO,GAAG,GAAG,CAAC,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;iBACtD;aACJ;YAED,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;gBAC5B,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,iBAAiB,GAAG,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,iBAAiB,EAAE,KAAK,CAAC,CAAC;aACpF;SACJ;QAGD,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,IAAI,kBAAkB,GAAG,KAAK,CAAC;QAE/B,IAAI,GAAG,GAAG,KAAK,CAAC;QAChB,OAAO,GAAG,KAAK,IAAI,EAAE;YACjB,QAAQ,GAAG,CAAC,SAAS,EAAE;gBACnB,KAAK,kBAAY,CAAC,WAAW,CAAC,CAAC;oBAC3B,MAAM,IAAI,IAAI,CAAC,yBAAyB,CAAC,GAAsB,EAAE,CAAC,OAAO,CAAC,CAAC;oBAC3E,GAAG,GAAI,GAAuB,CAAC,QAAQ,CAAC;oBAExC,MAAM;iBACT;gBAED,KAAK,kBAAY,CAAC,gBAAgB,CAAC,CAAC;oBAChC,MAAM,QAAQ,GAAI,GAA2B,CAAC,aAAa,CAAC;oBAC5D,MAAM,KAAK,GAAG,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;oBACrD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,EAAE,CAAC,EAAE;wBAC5B,MAAM,IAAI,IAAI,CAAC,yBAAyB,CAAC,GAA0B,EAAE,CAAC,OAAO,CAAC,CAAC;qBAClF;oBAED,GAAG,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;oBAEpC,MAAM;iBACT;gBAED,KAAK,kBAAY,CAAC,eAAe,CAAC,CAAC;oBAC/B,MAAM,OAAO,GAAG,GAAyB,CAAC;oBAC1C,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;oBAC5C,IAAI,UAAU,EAAE;wBACZ,MAAM,KAAK,GAAG,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;wBACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,EAAE,CAAC,EAAE;4BAC5B,MAAM,IAAI,IAAI,CAAC,yBAAyB,CAAC,UAAU,EAAE,CAAC,OAAO,CAAC,CAAC;yBAClE;qBACJ;oBACD,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC;oBAEpC,MAAM;iBACT;gBAED,OAAO,CAAC,CAAC;oBACL,MAAM,UAAU,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;oBACrC,QAAQ,UAAU,CAAC,iBAAiB,EAAE;wBAClC,MAAwB,CAAC,CAAC;4BACtB,GAAG,GAAI,UAA6B,CAAC,WAAW,CAAC;4BACjD,MAAM,SAAS,GAAG,UAAU,CAAC,MAAwB,CAAC;4BACtD,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,uBAAuB,CAAC,SAAS,EAAE,SAAS,CAAC,SAAS,EAAE,CAAC,OAAO,CAAC,CAAC;4BACtF,MAAM,IAAI,IAAI,CAAC;4BAEf,MAAM;yBACT;wBAED,MAA4B,CAAC,CAAC;4BAC1B,IAAI,IAAI,GAAG,EAAE,CAAC;4BACd,IAAI,OAAO,EAAE;gCAGT,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,8BAA8B,CAAC,wBAAc,CAAC,CAAC;6BAChE;iCAAM;gCAEH,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE;oCACtC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;gCAChD,MAAM,KAAK,GAAmB,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;gCAC7E,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,KAAK,CAAC,SAAS,EAAE,CAAC,OAAO,CAAC,CAAC;6BAE3E;4BACD,MAAM,IAAI,IAAI,CAAC;4BACf,GAAG,GAAG,UAAU,CAAC,MAAM,CAAC;4BAExB,MAAM;yBACT;wBAED,MAA6B,CAAC,CAAC;4BAI3B,MAAM,mBAAmB,GAAG,UAAiC,CAAC;4BAC9D,kBAAkB,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,mBAAmB,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;4BAC1F,GAAG,GAAG,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC;4BACpD,MAAM;yBACT;wBAED,OAAO,CAAC,CAAC;4BAEL,IAAI,OAAO,EAAE;gCACT,IAAI,UAAU,CAAC,KAAK,IAAI,UAAU,CAAC,KAAK,CAAC,UAAU,GAAG,CAAC,CAAC,EAAE;oCACtD,IAAI,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC;oCAC7B,IAAI,UAAU,YAAY,sBAAgB,EAAE;wCACxC,KAAK,GAAG,KAAK,CAAC,UAAU,CAAC,kBAAW,CAAC,iBAAiB,CAAC,CAAC;qCAC3D;oCACD,MAAM,IAAI,IAAI,CAAC,8BAA8B,CAAC,KAAK,CAAC,CAAC;iCACxD;6BACJ;iCAAM;gCACH,IAAI,UAAU,CAAC,KAAK,IAAI,UAAU,CAAC,KAAK,CAAC,UAAU,GAAG,CAAC,CAAC,EAAE;oCACtD,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;oCACtE,MAAM,KAAK,GAAG,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;oCACrE,MAAM,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,eAAe,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;oCACrE,IAAI,UAAU,KAAK,CAAC,CAAC,EAAE;wCAGnB,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;wCACnE,IAAI,SAAS,EAAE;4CACX,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC,SAAS,CAAC,CAAC;4CACpD,IAAI,OAA2B,CAAC;4CAEhC,IAAI,YAAY,EAAE;gDACd,IAAI,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;oDAC7B,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE;wDAC3B,OAAO,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;qDAC7B;yDAAM,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;wDAChC,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE;4DACxC,YAAY,CAAC,MAAM,CAAC,CAAC;wDACzB,OAAO,GAAG,YAAY,CAAC,WAAW,CAAC,CAAC;qDACvC;iDACJ;qDAAM,IAAI,YAAY,EAAE;oDACrB,OAAO,GAAG,YAAY,CAAC;iDAC1B;6CACJ;4CAED,IAAI,OAAO,EAAE;gDACT,MAAM,IAAI,QAAQ,CAAC,CAAC,CAAC,OAAO,GAAG,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC;6CAChD;iDAAM;gDACH,MAAM,IAAI,QAAQ,CAAC,CAAC,CAAC,SAAS,GAAG,GAAG,CAAC,CAAC,CAAC,SAAS,CAAC;6CACpD;yCACJ;6CAAM;4CACH,MAAM,IAAI,4CAA4C,KAAK,GAAG,CAAC;yCAClE;qCACJ;yCAAM;wCACH,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;wCAC9D,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,KAAK,CAAC,SAAS,EAAE,CAAC,OAAO,CAAC,CAAC;wCAC9E,MAAM,IAAI,IAAI,CAAC;qCAClB;iCACJ;6BACJ;4BACD,GAAG,GAAG,UAAU,CAAC,MAAM,CAAC;4BAExB,MAAM;yBACT;qBACJ;iBACJ;aACJ;SACJ;QAED,IAAI,MAAM,EAAE;YACR,IAAI,CAAC,SAAS,CAAC,QAAS,CAAC,CAAC;YAC1B,IAAI,QAAQ,EAAE;gBACV,OAAO,CAAC,MAAM,GAAG,GAAG,EAAE,kBAAkB,CAAC,CAAC;aAC7C;SACJ;QAED,OAAO,CAAC,MAAM,EAAE,kBAAkB,CAAC,CAAC;IACxC,CAAC;IAcO,yBAAyB,CAAC,KAAoB,EAAE,QAAiB;QACrE,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,IAAI,OAAO,GAAG,KAAK,CAAC;QAEpB,GAAG;YACC,MAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;YAC/C,IAAI,QAAQ,GAAG,CAAC,EAAE;gBACd,OAAO,EAAE,CAAC;aACb;YAGD,MAAM,cAAc,GAAG,KAAK,CAAC,GAAG,KAAK,IAAI,CAAC,SAAS,CAAC,GAAG;gBACnD,CAAC,CAAC,IAAI,CAAC,mBAAmB;gBAC1B,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC;YAChC,MAAM,SAAS,GAAG,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,QAAQ,CAAE,CAAC;YACtD,EAAE,SAAS,CAAC,QAAQ,CAAC,CAAC;YAEtB,IAAI,QAAQ,CAAC;YACb,QAAQ,KAAK,CAAC,SAAS,EAAE;gBACrB,KAAK,kBAAY,CAAC,gBAAgB,CAAC;gBACnC,KAAK,kBAAY,CAAC,WAAW,CAAC,CAAC;oBAC3B,QAAQ,GAAI,KAAyB,CAAC,QAAQ,CAAC;oBAC/C,MAAM;iBACT;gBAED,KAAK,kBAAY,CAAC,gBAAgB,CAAC,CAAC;oBAChC,QAAQ,GAAI,KAA6B,CAAC,aAAa,CAAC;oBACxD,MAAM;iBACT;gBAED,OAAO,CAAC,CAAC;oBACL,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;iBACjE;aACJ;YAED,CAAC,MAAM,EAAE,OAAO,CAAC,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;YACxG,IAAI,OAAO,EAAE;gBACT,SAAS,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC;aAC7B;SACJ,QAAQ,OAAO,EAAE;QAElB,OAAO,MAAM,CAAC;IAClB,CAAC;IAWO,iBAAiB,CAAC,KAAoB;QAC1C,MAAM,cAAc,GAAG,KAAK,CAAC,GAAG,KAAK,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC;QAE/G,MAAM,OAAO,GAAG,IAAI,KAAK,CAAS,KAAK,CAAC,mBAAmB,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACrE,IAAI,SAAS,GAAG,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QACnD,IAAI,CAAC,SAAS,EAAE;YACZ,SAAS,GAAG,IAAI,KAAK,CAAS,KAAK,CAAC,mBAAmB,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACjE,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;SACjD;aAAM;YACH,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;gBACvC,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,iBAAiB,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;aAC/D;SACJ;QAED,MAAM,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,WAAW,EAAE,OAAO,EAAE,EAAE;YAChD,OAAO,WAAW,GAAG,OAAO,CAAC;QACjC,CAAC,CAAC,CAAC;QAEH,IAAI,WAAW,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC;QACtC,IAAI,WAAW,GAAG,CAAC,CAAC;QACpB,OAAO,WAAW,GAAG,SAAS,CAAC,MAAM,EAAE;YACnC,WAAW,IAAI,OAAO,CAAC,WAAW,CAAC,CAAC;YACpC,IAAI,WAAW,GAAG,CAAC,EAAE;gBACjB,OAAO,WAAW,CAAC;aACtB;YACD,EAAE,WAAW,CAAC;SACjB;QAED,OAAO,CAAC,CAAC,CAAC;IACd,CAAC;IASO,OAAO,CAAC,KAAe;QAC3B,KAAK,MAAM,UAAU,IAAI,KAAK,CAAC,cAAc,EAAE,EAAE;YAC7C,IAAI,UAAU,CAAC,MAAM,CAAC,SAAS,KAAK,kBAAY,CAAC,QAAQ,EAAE;gBACvD,OAAO,UAAU,CAAC,MAAM,CAAC;aAC5B;SACJ;QAED,OAAO,SAAS,CAAC;IACrB,CAAC;IAEO,UAAU,CAAC,KAAyB;QACxC,KAAK,MAAM,UAAU,IAAI,KAAK,CAAC,cAAc,EAAE,EAAE;YAC7C,IAAI,UAAU,CAAC,MAAM,CAAC,SAAS,KAAK,kBAAY,CAAC,gBAAgB,EAAE;gBAC/D,OAAO,UAAU,CAAC,MAA6B,CAAC;aACnD;SACJ;IACL,CAAC;IAYO,kBAAkB,CAAC,GAAgB,EAAE,KAAa;QACtD,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,KAAK,MAAM,QAAQ,IAAI,GAAG,CAAC,SAAS,EAAE;YAClC,MAAM,YAAY,GAAG,QAAQ,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC;YACjD,IAAI,KAAK,GAAG,YAAY,GAAG,YAAY,EAAE;gBACrC,OAAO,QAAQ,CAAC,CAAC,GAAG,KAAK,GAAG,YAAY,CAAC;aAC5C;YACD,YAAY,IAAI,YAAY,CAAC;SAChC;QAED,OAAO,YAAY,CAAC;IACxB,CAAC;IAEO,8BAA8B,CAAC,GAAgB;QAEnD,MAAM,QAAQ,GAAG,iBAAiB,CAAC,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC7D,IAAI,QAAQ,CAAC,IAAI,KAAK,CAAC,EAAE;YAErB,OAAO,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SACnG;QAED,OAAO,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAC9G,CAAC;IAEO,kBAAkB,CAAC,OAAgB,EAAE,WAAoB;QAC7D,IAAI,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,mBAAmB,CAAC;QACvE,IAAI,WAAW,IAAI,GAAG,KAAK,CAAC,EAAE;YAC1B,GAAG,GAAG,CAAC,CAAC;SACX;QACD,MAAM,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,mBAAmB,CAAC;QAEzE,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;IAC7D,CAAC;IAED;QACI,KAAK,IAAA,gCAAsB,EAAC;YACxB,UAAU,EAAE,IAAI;YAChB,UAAU,EAAE,IAAI;YAChB,UAAU,EAAE,KAAK;YACjB,sBAAsB,EAAE,IAAI;SAC/B,CAAC,CAAC,IAAI,CAAC,CAAC,WAAW,EAAE,EAAE;YACpB,IAAI,CAAC,gBAAgB,GAAG,WAAW,CAAC;QACxC,CAAC,CAAC,CAAC;IAGP,CAAC;CACJ;AAjkBD,8CAikBC","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\nimport * as vm from \"vm\";\r\nimport * as fs from \"fs\";\r\n\r\nimport {\r\n    ATNState, ATNStateType, BlockStartState, PlusBlockStartState, StarLoopEntryState, TransitionType,\r\n    RuleTransition, StarBlockStartState, RuleStartState, NotSetTransition, DecisionState, PredicateTransition,\r\n} from \"antlr4ts/atn\";\r\n\r\nimport { ISentenceGenerationOptions, IRuleMappings, PredicateFunction } from \"./types\";\r\nimport { IntervalSet } from \"antlr4ts/misc\";\r\n\r\nimport { printableUnicodePoints, fullUnicodeSet } from \"./Unicode\";\r\nimport { IInterpreterData } from \"./InterpreterDataReader\";\r\nimport { LexerPredicateSymbol, ParserPredicateSymbol } from \"./ContextSymbolTable\";\r\nimport { SourceContext } from \"./SourceContext\";\r\n\r\n/**\r\n * This class generates a number of strings, each valid input for a given ATN.\r\n */\r\nexport class SentenceGenerator {\r\n    private static printableUnicode: IntervalSet;\r\n\r\n    // Allow evaluating predicates.\r\n    public runPredicate?: PredicateFunction;\r\n\r\n    private lexerPredicates: LexerPredicateSymbol[];\r\n    private parserPredicates: ParserPredicateSymbol[];\r\n\r\n    // Convergence data for recursive rule invocations. We count here the invocation of each alt\r\n    // of a decision state.\r\n    private convergenceFactor: number;\r\n    private lexerDecisionCounts: Map<number, number[]>;\r\n    private parserDecisionCounts: Map<number, number[]>;\r\n\r\n    private minParserIterations: number;\r\n    private maxParserIterations: number;\r\n    private minLexerIterations: number;\r\n    private maxLexerIterations: number;\r\n    private maxRecursions: number;\r\n    private maxRecursionLabel: string;\r\n    private ruleInvocations = new Map<string, number>();\r\n\r\n    private ruleMappings?: IRuleMappings;\r\n\r\n    // To limit recursions we need to track through which rules we are walking currently.\r\n    private parserStack: number[] = [];\r\n\r\n    /**\r\n     * @param context The context for the grammar file.\r\n     * @param lexerData The generated lexer data for this grammar.\r\n     * @param parserData The generated parser data for this grammar.\r\n     * @param actionFile The name of a file that allows executing predicates/actions.\r\n     */\r\n    public constructor(\r\n        context: SourceContext,\r\n        private lexerData: IInterpreterData,\r\n        private parserData: IInterpreterData | undefined,\r\n        actionFile: string | undefined) {\r\n\r\n        // Get the symbols for all predicates (to enable predicate evaluation).\r\n        this.lexerPredicates = context.symbolTable.getNestedSymbolsOfTypeSync(LexerPredicateSymbol);\r\n        this.parserPredicates = context.symbolTable.getNestedSymbolsOfTypeSync(ParserPredicateSymbol);\r\n\r\n        // Need to disable a number of linter checks in order to allow importing the action file.\r\n        if (actionFile) {\r\n            const code = fs.readFileSync(actionFile, { encoding: \"utf-8\" }) + `\r\n            const runPredicate = (predicate) => eval(predicate);\r\n            runPredicate;\r\n            `;\r\n\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n            this.runPredicate = vm.runInNewContext(code) as PredicateFunction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates a single sentence for the given rule.\r\n     *\r\n     * @param options A number of settings that control the generation process.\r\n     * @param start The ATN start state of the rule for which to generate the sentence.\r\n     *\r\n     * @returns A string that can successfully be parsed by the rule.\r\n     */\r\n    public generate(options: ISentenceGenerationOptions, start: RuleStartState): string {\r\n\r\n        this.convergenceFactor = options.convergenceFactor ?? 0.25;\r\n\r\n        this.minParserIterations = options.minParserIterations ?? 0;\r\n        if (this.minParserIterations < 0) {\r\n            this.minParserIterations = 0;\r\n        } else {\r\n            this.minParserIterations = Math.floor(this.minParserIterations);\r\n        }\r\n\r\n        this.maxParserIterations = options.maxParserIterations ?? this.minParserIterations + 1;\r\n        if (this.maxParserIterations < this.minParserIterations) {\r\n            this.maxParserIterations = this.minParserIterations + 1;\r\n        } else {\r\n            this.maxParserIterations = Math.ceil(this.maxParserIterations);\r\n        }\r\n\r\n        this.minLexerIterations = options.minLexerIterations ?? 0;\r\n        if (this.minLexerIterations < 0) {\r\n            this.minLexerIterations = 0;\r\n        } else {\r\n            this.minLexerIterations = Math.floor(this.minLexerIterations);\r\n        }\r\n\r\n        this.maxLexerIterations = options.maxLexerIterations ?? this.minLexerIterations + 10;\r\n        if (this.maxLexerIterations < this.minLexerIterations) {\r\n            this.maxLexerIterations = this.minLexerIterations + 10;\r\n        } else {\r\n            this.maxLexerIterations = Math.ceil(this.maxLexerIterations);\r\n        }\r\n\r\n        this.maxRecursions = (!options.maxRecursions || options.maxRecursions < 1) ? 3 : options.maxRecursions;\r\n        this.maxRecursionLabel = options.maxRecursionLabel ?? \"⨱\";\r\n\r\n        this.ruleInvocations.clear();\r\n        this.ruleMappings = options.ruleMappings;\r\n\r\n        this.lexerDecisionCounts = new Map<number, number[]>();\r\n        this.parserDecisionCounts = new Map<number, number[]>();\r\n\r\n        this.parserStack.length = 0;\r\n\r\n        const [result] = this.generateFromATNSequence(start, start.stopState, start.atn === this.lexerData.atn);\r\n\r\n        return result;\r\n    }\r\n\r\n    public sempred(ruleIndex: number, predIndex: number, inLexer: boolean): boolean {\r\n        if (this.runPredicate) {\r\n            let predicate = \"\";\r\n            if (inLexer) {\r\n                if (predIndex < this.lexerPredicates.length) {\r\n                    predicate = this.lexerPredicates[predIndex].context!.text;\r\n                }\r\n            } else {\r\n                if (predIndex < this.parserPredicates.length) {\r\n                    predicate = this.parserPredicates[predIndex].context!.text;\r\n                }\r\n            }\r\n\r\n            if (predicate.length > 2) {\r\n                predicate = predicate.substring(1, predicate.length - 1); // Remove outer curly braces.\r\n                try {\r\n                    return this.runPredicate(predicate);\r\n                } catch (e) {\r\n                    throw Error(`There was an error while evaluating predicate \"${predicate}\". ` +\r\n                        `Evaluation returned: ` + String(e));\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @param inLexer A flag to tell where to lookup the symbol name.\r\n     * @param index The rule index to convert.\r\n     *\r\n     * @returns The name of the rule with the given index.\r\n     */\r\n    private getRuleName(inLexer: boolean, index: number): string | undefined {\r\n        if (inLexer) {\r\n            return this.lexerData.ruleNames[index];\r\n        }\r\n\r\n        if (this.parserData) {\r\n            return this.parserData.ruleNames[index];\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Records the invocation of the given rule.\r\n     *\r\n     * @param name The name of the rule.\r\n     *\r\n     * @returns True if that rule's invocation count is less than the maximum recursion count.\r\n     */\r\n    private invokeRule(name: string): boolean {\r\n        const count = this.ruleInvocations.get(name);\r\n        if (count) {\r\n            if (count < this.maxRecursions) {\r\n                this.ruleInvocations.set(name, count + 1);\r\n\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        this.ruleInvocations.set(name, 1);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Remove one invocation step for the given rule. If the count is zero after that, then the rule is removed\r\n     * from the invocation list altogether.\r\n     *\r\n     * @param name The name of the rule.\r\n     */\r\n    private leaveRule(name: string) {\r\n        let count = this.ruleInvocations.get(name);\r\n        if (count) {\r\n            --count;\r\n            if (count === 0) {\r\n                this.ruleInvocations.delete(name);\r\n            } else {\r\n                this.ruleInvocations.set(name, count);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes a single sequence of ATN states (a rule or a single alt in a block).\r\n     *\r\n     * @param start The node from where to start walking.\r\n     * @param stop The node that ends the sequence to walk over.\r\n     * @param addSpace If true a space char is added between each ATN node label.\r\n     *\r\n     * @returns The generated string and a flag that indicates if the process succeeded.\r\n     */\r\n    private generateFromATNSequence(start: ATNState, stop: ATNState, addSpace: boolean): [string, boolean] {\r\n        const inLexer = start.atn === this.lexerData.atn;\r\n        const isRule = start.stateType === ATNStateType.RULE_START;\r\n\r\n        let ruleName: string | undefined;\r\n        if (isRule) {\r\n            // Check if there's a predefined result for the given rule.\r\n            ruleName = this.getRuleName(inLexer, start.ruleIndex);\r\n            if (!ruleName) {\r\n                return [\"\", false];\r\n            }\r\n\r\n            const mappingValue = this.ruleMappings?.[ruleName];\r\n            if (mappingValue) {\r\n                let mapping: string | undefined;\r\n\r\n                if (Array.isArray(mappingValue)) {\r\n                    if (mappingValue.length === 1) {\r\n                        mapping = mappingValue[0];\r\n                    } else if (mappingValue.length > 0) {\r\n                        const randomIndex = Math.floor(Math.random() * mappingValue.length);\r\n                        const randomElement = mappingValue[randomIndex];\r\n\r\n                        mapping = randomElement;\r\n                    }\r\n                } else {\r\n                    mapping = mappingValue;\r\n                }\r\n\r\n                if (mapping) {\r\n                    return [addSpace ? mapping + \" \" : mapping, false];\r\n                }\r\n            }\r\n\r\n            if (!this.invokeRule(ruleName)) {\r\n                return [addSpace ? this.maxRecursionLabel + \" \" : this.maxRecursionLabel, false];\r\n            }\r\n        }\r\n\r\n\r\n        let result = \"\";\r\n        let blockedByPredicate = false;\r\n\r\n        let run = start;\r\n        while (run !== stop) {\r\n            switch (run.stateType) {\r\n                case ATNStateType.BLOCK_START: {\r\n                    result += this.generateFromDecisionState(run as BlockStartState, !inLexer);\r\n                    run = (run as BlockStartState).endState;\r\n\r\n                    break;\r\n                }\r\n\r\n                case ATNStateType.PLUS_BLOCK_START: {\r\n                    const loopBack = (run as PlusBlockStartState).loopBackState;\r\n                    const count = this.getRandomLoopCount(inLexer, true);\r\n                    for (let i = 0; i < count; ++i) {\r\n                        result += this.generateFromDecisionState(run as PlusBlockStartState, !inLexer);\r\n                    }\r\n\r\n                    run = loopBack.transition(1).target;\r\n\r\n                    break;\r\n                }\r\n\r\n                case ATNStateType.STAR_LOOP_ENTRY: {\r\n                    const slEntry = run as StarLoopEntryState;\r\n                    const blockStart = this.blockStart(slEntry);\r\n                    if (blockStart) {\r\n                        const count = this.getRandomLoopCount(inLexer, false);\r\n                        for (let i = 0; i < count; ++i) {\r\n                            result += this.generateFromDecisionState(blockStart, !inLexer);\r\n                        }\r\n                    }\r\n                    run = this.loopEnd(slEntry) || stop;\r\n\r\n                    break;\r\n                }\r\n\r\n                default: {\r\n                    const transition = run.transition(0);\r\n                    switch (transition.serializationType) {\r\n                        case TransitionType.RULE: { // Transition into a sub rule.\r\n                            run = (transition as RuleTransition).followState;\r\n                            const ruleStart = transition.target as RuleStartState;\r\n                            const [text] = this.generateFromATNSequence(ruleStart, ruleStart.stopState, !inLexer);\r\n                            result += text;\r\n\r\n                            break;\r\n                        }\r\n\r\n                        case TransitionType.WILDCARD: {\r\n                            let text = \"\";\r\n                            if (inLexer) {\r\n                                // Any char from the entire Unicode range. The generator takes care to pick only\r\n                                // valid characters.\r\n                                [text] = this.getRandomCharacterFromInterval(fullUnicodeSet);\r\n                            } else {\r\n                                // Pick a random lexer rule.\r\n                                const ruleIndex = Math.floor(Math.random() *\r\n                                    this.lexerData.atn.ruleToStartState.length);\r\n                                const state: RuleStartState = this.lexerData.atn.ruleToStartState[ruleIndex];\r\n                                [text] = this.generateFromATNSequence(state, state.stopState, !inLexer);\r\n\r\n                            }\r\n                            result += text;\r\n                            run = transition.target;\r\n\r\n                            break;\r\n                        }\r\n\r\n                        case TransitionType.PREDICATE: {\r\n                            // Evaluate the predicate if possible (or assume it succeeds if not).\r\n                            // If evaluation returns false then return immediately with a flag to tell the caller\r\n                            // to use a different decision (if possible).\r\n                            const predicateTransition = transition as PredicateTransition;\r\n                            blockedByPredicate = !this.sempred(run.ruleIndex, predicateTransition.predIndex, inLexer);\r\n                            run = blockedByPredicate ? stop : transition.target;\r\n                            break;\r\n                        }\r\n\r\n                        default: {\r\n                            // Any other basic transition. See if there is a label we can use.\r\n                            if (inLexer) {\r\n                                if (transition.label && transition.label.minElement > -1) {\r\n                                    let label = transition.label;\r\n                                    if (transition instanceof NotSetTransition) {\r\n                                        label = label.complement(IntervalSet.COMPLETE_CHAR_SET);\r\n                                    }\r\n                                    result += this.getRandomCharacterFromInterval(label);\r\n                                }\r\n                            } else {\r\n                                if (transition.label && transition.label.maxElement > -1) {\r\n                                    const randomIndex = Math.floor(Math.random() * transition.label.size);\r\n                                    const token = this.getIntervalElement(transition.label, randomIndex);\r\n                                    const tokenIndex = this.lexerData.atn.ruleToTokenType.indexOf(token);\r\n                                    if (tokenIndex === -1) {\r\n                                        // Found a virtual token. Either use its mapping as value or\r\n                                        // its name for the output.\r\n                                        const tokenName = this.lexerData.vocabulary.getSymbolicName(token);\r\n                                        if (tokenName) {\r\n                                            const mappingValue = this.ruleMappings?.[tokenName];\r\n                                            let mapping: string | undefined;\r\n\r\n                                            if (mappingValue) {\r\n                                                if (Array.isArray(mappingValue)) {\r\n                                                    if (mappingValue.length === 1) {\r\n                                                        mapping = mappingValue[0];\r\n                                                    } else if (mappingValue.length > 0) {\r\n                                                        const randomIndex = Math.floor(Math.random() *\r\n                                                            mappingValue.length);\r\n                                                        mapping = mappingValue[randomIndex];\r\n                                                    }\r\n                                                } else if (mappingValue) {\r\n                                                    mapping = mappingValue;\r\n                                                }\r\n                                            }\r\n\r\n                                            if (mapping) {\r\n                                                result += addSpace ? mapping + \" \" : mapping;\r\n                                            } else {\r\n                                                result += addSpace ? tokenName + \" \" : tokenName;\r\n                                            }\r\n                                        } else {\r\n                                            result += `[Cannot generate value for virtual token ${token}]`;\r\n                                        }\r\n                                    } else {\r\n                                        const state = this.lexerData.atn.ruleToStartState[tokenIndex];\r\n                                        const [text] = this.generateFromATNSequence(state, state.stopState, !inLexer);\r\n                                        result += text;\r\n                                    }\r\n                                }\r\n                            }\r\n                            run = transition.target;\r\n\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (isRule) {\r\n            this.leaveRule(ruleName!);\r\n            if (addSpace) {\r\n                return [result + \" \", blockedByPredicate];\r\n            }\r\n        }\r\n\r\n        return [result, blockedByPredicate];\r\n    }\r\n\r\n    /**\r\n     * Picks a random entry from all possible alternatives. Each alt gets a specific weight depending on its\r\n     * previous invocations (the higher the invocation count the smaller the weight).\r\n     *\r\n     * If a decision is blocked by a failing predicate then an attempt is made to select another random decision.\r\n     * If none is left for consideration then an empty string is returned.\r\n     *\r\n     * @param state The state from which to select on decision.\r\n     * @param addSpace If true a space char is added between each ATN node label.\r\n     *\r\n     * @returns The generated string.\r\n     */\r\n    private generateFromDecisionState(state: DecisionState, addSpace: boolean): string {\r\n        let result = \"\";\r\n        let blocked = false; // Current decision blocked by a predicate?\r\n\r\n        do {\r\n            const decision = this.getRandomDecision(state);\r\n            if (decision < 0) {\r\n                return \"\";\r\n            }\r\n\r\n            // The alt counts are initialized in the call above if they don't exist yet.\r\n            const decisionCounts = state.atn === this.lexerData.atn\r\n                ? this.lexerDecisionCounts\r\n                : this.parserDecisionCounts;\r\n            const altCounts = decisionCounts.get(state.decision)!;\r\n            ++altCounts[decision];\r\n\r\n            let endState;\r\n            switch (state.stateType) {\r\n                case ATNStateType.STAR_BLOCK_START:\r\n                case ATNStateType.BLOCK_START: {\r\n                    endState = (state as BlockStartState).endState;\r\n                    break;\r\n                }\r\n\r\n                case ATNStateType.PLUS_BLOCK_START: {\r\n                    endState = (state as PlusBlockStartState).loopBackState;\r\n                    break;\r\n                }\r\n\r\n                default: {\r\n                    throw new Error(\"Unhandled state type in sentence generator\");\r\n                }\r\n            }\r\n\r\n            [result, blocked] = this.generateFromATNSequence(state.transition(decision).target, endState, addSpace);\r\n            if (blocked) {\r\n                altCounts[decision] = 1e6; // Set a large execution count to effectively disable this decision.\r\n            }\r\n        } while (blocked);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Determines a random decision (one of the outgoing transitions) depending on the already taken\r\n     * transitions. If the decision state has an exit state (for ?, * and + operators) this exit state\r\n     * always has a weight of 1, so it will always serve as exit point if other weights become to low.\r\n     *\r\n     * @param state The decision state to examine.\r\n     *\r\n     * @returns A random decision index.\r\n     */\r\n    private getRandomDecision(state: DecisionState): number {\r\n        const decisionCounts = state.atn === this.lexerData.atn ? this.lexerDecisionCounts : this.parserDecisionCounts;\r\n\r\n        const weights = new Array<number>(state.numberOfTransitions).fill(1);\r\n        let altCounts = decisionCounts.get(state.decision);\r\n        if (!altCounts) {\r\n            altCounts = new Array<number>(state.numberOfTransitions).fill(0);\r\n            decisionCounts.set(state.decision, altCounts);\r\n        } else {\r\n            for (let i = 0; i < altCounts.length; ++i) {\r\n                weights[i] = Math.pow(this.convergenceFactor, altCounts[i]);\r\n            }\r\n        }\r\n\r\n        const sum = weights.reduce((accumulated, current) => {\r\n            return accumulated + current;\r\n        });\r\n\r\n        let randomValue = Math.random() * sum;\r\n        let randomIndex = 0;\r\n        while (randomIndex < altCounts.length) {\r\n            randomValue -= weights[randomIndex];\r\n            if (randomValue < 0) {\r\n                return randomIndex;\r\n            }\r\n            ++randomIndex;\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Goes through all transitions of the given state to find a loop end state.\r\n     *\r\n     * @param state The state to go from.\r\n     *\r\n     * @returns The found state or undefined.\r\n     */\r\n    private loopEnd(state: ATNState): ATNState | undefined {\r\n        for (const transition of state.getTransitions()) {\r\n            if (transition.target.stateType === ATNStateType.LOOP_END) {\r\n                return transition.target;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    private blockStart(state: StarLoopEntryState): StarBlockStartState | undefined {\r\n        for (const transition of state.getTransitions()) {\r\n            if (transition.target.stateType === ATNStateType.STAR_BLOCK_START) {\r\n                return transition.target as StarBlockStartState;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the value at the given index. In order to avoid converting large intervals\r\n     * into equally large arrays we take a different approach here to find the value.\r\n     * It's assumed the given index is always in range.\r\n     *\r\n     * @param set The interval set from which to return a value.\r\n     * @param index The value index in this set.\r\n     *\r\n     * @returns The value at index `index`.\r\n     */\r\n    private getIntervalElement(set: IntervalSet, index: number): number {\r\n        let runningIndex = 0;\r\n        for (const interval of set.intervals) {\r\n            const intervalSize = interval.b - interval.a + 1;\r\n            if (index < runningIndex + intervalSize) {\r\n                return interval.a + index - runningIndex;\r\n            }\r\n            runningIndex += intervalSize;\r\n        }\r\n\r\n        return runningIndex;\r\n    }\r\n\r\n    private getRandomCharacterFromInterval(set: IntervalSet): String {\r\n        //const randomBlockSet = randomCodeBlocks();\r\n        const validSet = SentenceGenerator.printableUnicode.and(set);\r\n        if (validSet.size === 0) {\r\n            // Very likely just a single script or a simple set of elements.\r\n            return String.fromCodePoint(this.getIntervalElement(set, Math.floor(Math.random() * set.size)));\r\n        }\r\n\r\n        return String.fromCodePoint(this.getIntervalElement(validSet, Math.floor(Math.random() * validSet.size)));\r\n    }\r\n\r\n    private getRandomLoopCount(inLexer: boolean, forPlusLoop: boolean): number {\r\n        let min = inLexer ? this.minLexerIterations : this.minParserIterations;\r\n        if (forPlusLoop && min === 0) {\r\n            min = 1;\r\n        }\r\n        const max = inLexer ? this.maxLexerIterations : this.maxParserIterations;\r\n\r\n        return Math.floor(Math.random() * (max - min + 1) + min);\r\n    }\r\n\r\n    static {\r\n        void printableUnicodePoints({\r\n            excludeCJK: true,\r\n            excludeRTL: true,\r\n            limitToBMP: false,\r\n            includeLineTerminators: true,\r\n        }).then((intervalSet) => {\r\n            this.printableUnicode = intervalSet;\r\n        });\r\n\r\n\r\n    }\r\n}\r\n"]}