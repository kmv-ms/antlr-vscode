{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../src/backend/types.ts"],"names":[],"mappings":";;;AAKA,IAAY,WAKX;AALD,WAAY,WAAW;IACnB,mDAAO,CAAA;IACP,iDAAM,CAAA;IACN,+CAAK,CAAA;IACL,qDAAQ,CAAA;AACZ,CAAC,EALW,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAKtB;AAGD,IAAY,eAKX;AALD,WAAY,eAAe;IACvB,6DAAQ,CAAA;IACR,2DAAO,CAAA;IACP,+DAAS,CAAA;IACT,qEAAY,CAAA;AAChB,CAAC,EALW,eAAe,GAAf,uBAAe,KAAf,uBAAe,QAK1B;AAED,IAAY,UAgCX;AAhCD,WAAY,UAAU;IAClB,iDAAO,CAAA;IAEP,mDAAQ,CAAA;IACR,iDAAO,CAAA;IACP,uDAAU,CAAA;IACV,+CAAM,CAAA;IACN,qEAAiB,CAAA;IACjB,qEAAiB,CAAA;IACjB,uEAAkB,CAAA;IAClB,qDAAS,CAAA;IACT,yDAAW,CAAA;IACX,sDAAS,CAAA;IACT,gEAAc,CAAA;IACd,4DAAY,CAAA;IACZ,wDAAU,CAAA;IACV,oDAAQ,CAAA;IACR,gDAAM,CAAA;IACN,gEAAc,CAAA;IACd,8DAAa,CAAA;IACb,4DAAY,CAAA;IAGZ,sEAAiB,CAAA;IACjB,oEAAgB,CAAA;IAChB,kEAAe,CAAA;IACf,8DAAa,CAAA;IACb,4DAAY,CAAA;IACZ,0DAAW,CAAA;IACX,kEAAe,CAAA;IACf,gEAAc,CAAA;IACd,sDAAS,CAAA;AACb,CAAC,EAhCW,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAgCrB;AA2BD,IAAY,cAKX;AALD,WAAY,cAAc;IACtB,mDAAI,CAAA;IACJ,mDAAI,CAAA;IACJ,yDAAO,CAAA;IACP,qDAAK,CAAA;AACT,CAAC,EALW,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAKzB;AA0ED,IAAY,cAOX;AAPD,WAAY,cAAc;IACtB,iEAAW,CAAA;IACX,+DAAU,CAAA;IACV,mEAAY,CAAA;IACZ,iEAAW,CAAA;IACX,yEAAe,CAAA;IACf,uEAAc,CAAA;AAClB,CAAC,EAPW,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAOzB","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\nexport enum GrammarType {\r\n    Unknown,\r\n    Parser,\r\n    Lexer,\r\n    Combined,\r\n}\r\n\r\n/** Multiple symbol kinds can be involved in a symbol lookup. */\r\nexport enum SymbolGroupKind {\r\n    TokenRef,\r\n    RuleRef,\r\n    LexerMode,\r\n    TokenChannel,\r\n}\r\n\r\nexport enum SymbolKind {\r\n    Unknown,\r\n\r\n    Terminal,\r\n    Keyword,\r\n    TokenVocab,\r\n    Import,\r\n    BuiltInLexerToken,\r\n    VirtualLexerToken,\r\n    FragmentLexerToken,\r\n    LexerRule,\r\n    BuiltInMode,\r\n    LexerMode,\r\n    BuiltInChannel,\r\n    TokenChannel,\r\n    ParserRule,\r\n    Operator,\r\n    Option,\r\n    TokenReference,\r\n    RuleReference,\r\n    LexerCommand,\r\n\r\n    // Native code.\r\n    GlobalNamedAction,\r\n    LocalNamedAction,\r\n    ExceptionAction,\r\n    FinallyAction,\r\n    ParserAction,\r\n    LexerAction,\r\n    ParserPredicate,\r\n    LexerPredicate,\r\n    Arguments,\r\n}\r\n\r\n/**\r\n * A range within a text. Just like the range object in vscode the end position is not included in the range.\r\n * Hence when start and end position are equal the range is empty.\r\n */\r\nexport interface ILexicalRange {\r\n    start: { column: number; row: number; };\r\n    end: { column: number; row: number; };\r\n}\r\n\r\n/** The definition of a single symbol (range and content it is made of). */\r\nexport interface IDefinition {\r\n    text: string;\r\n    range: ILexicalRange;\r\n}\r\n\r\nexport interface ISymbolInfo {\r\n    kind: SymbolKind;\r\n    name: string;\r\n    source: string;\r\n    definition?: IDefinition;\r\n\r\n    /** Used for code completion. Provides a small description for certain symbols. */\r\n    description?: string;\r\n}\r\n\r\nexport enum DiagnosticType {\r\n    Hint,\r\n    Info,\r\n    Warning,\r\n    Error,\r\n}\r\n\r\nexport interface IDiagnosticEntry {\r\n    type: DiagnosticType;\r\n    message: string;\r\n    range: ILexicalRange;\r\n}\r\n\r\n/**\r\n * Contains a number of values for a lexer token. Used when constructing a token list and parse trees in the debugger.\r\n */\r\nexport interface ILexerToken {\r\n    [key: string]: string | number | object;\r\n\r\n    text: string;\r\n    type: number;\r\n    name: string;\r\n    line: number;\r\n\r\n    /** Offset in the line. */\r\n    offset: number;\r\n    channel: number;\r\n    tokenIndex: number;\r\n    startIndex: number;\r\n    stopIndex: number;\r\n}\r\n\r\n/**\r\n * Describes the a range in an input stream (character indexes in a char stream or token indexes in a token stream).\r\n * Indexes can be < 0 if there's no input representation for a tree node (e.g. when it did not match anything).\r\n */\r\nexport interface IIndexRange {\r\n    startIndex: number;\r\n    stopIndex: number;\r\n    length: number;\r\n}\r\n\r\n/**\r\n * This interface is what exported parse trees are made of, which are created by the debugger interface.\r\n * Each node stands either for an invoked rule, a terminal node or an error node.\r\n * NOTE: there's a copy of the it in webview-scripts/types.ts, so keep them in sync!\r\n */\r\nexport interface IParseTreeNode {\r\n    type: \"rule\" | \"terminal\" | \"error\";\r\n\r\n    /** A unique id for D3.js. */\r\n    id: number;\r\n\r\n    /** Only valid for the rule node type. */\r\n    ruleIndex?: number;\r\n    name: string;\r\n    start?: ILexerToken;\r\n    stop?: ILexerToken;\r\n    range?: IIndexRange;\r\n\r\n    /** Only valid for non-rule nodes. */\r\n    symbol?: ILexerToken;\r\n\r\n    /** Available for all node types, but empty for non-rule types. */\r\n    children: IParseTreeNode[];\r\n}\r\n\r\n/**\r\n * All references of a rule (both lexer and parser) to other rules and string literals.\r\n * Lexer rules obviously cannot have any parser rule reference. String literals are mostly interesting\r\n * for parser rules to check for implicit lexer tokens.\r\n */\r\nexport interface IReferenceNode {\r\n    kind: SymbolKind;\r\n    rules: Set<string>;\r\n    tokens: Set<string>;\r\n    literals: Set<string>;\r\n}\r\n\r\nexport enum CodeActionType {\r\n    GlobalNamed,\r\n    LocalNamed,\r\n    ParserAction,\r\n    LexerAction,\r\n    ParserPredicate,\r\n    LexerPredicate,\r\n}\r\n\r\n/** Options used by the parser files generation. */\r\nexport interface IGenerationOptions {\r\n    /**\r\n     * The folder in which to run the generation process. Should be an absolute path for predictable results.\r\n     * Used internally only.\r\n     */\r\n    baseDir?: string;\r\n\r\n    /** Search path for the ANTLR tool. */\r\n    libDir?: string;\r\n\r\n    /** The folder where to place generated files in (relative to baseDir or absolute) (default: grammar dir). */\r\n    outputDir?: string;\r\n\r\n    /** Package or namespace name for generated files (default: none). */\r\n    package?: string;\r\n\r\n    /** The target language for the generated files. (default: what's given in the grammar or Java). */\r\n    language?: string;\r\n\r\n    /** Generate listener files if set (default: true). */\r\n    listeners?: boolean;\r\n\r\n    /** Generate visitor files if set (default: false). */\r\n    visitors?: boolean;\r\n\r\n    /** Don't generate anything. Just try to load interpreter data and do interpreter setup. */\r\n    loadOnly?: boolean;\r\n\r\n    /** Used with `loadOnly` to generate if no interpreter data exists yet. */\r\n    generateIfNeeded?: boolean;\r\n\r\n    /** Use this jar for work instead of the built-in one(s). */\r\n    alternativeJar?: string;\r\n\r\n    /** Any additional parameter you want to send to ANTLR4 for generation (e.g. \"-XdbgST\"). */\r\n    additionalParameters?: string;\r\n}\r\n\r\n/**\r\n * Options used by the sentence generation.\r\n */\r\nexport interface ISentenceGenerationOptions {\r\n    /** The number of sentences to generate in one call. */\r\n    count?: number;\r\n\r\n    /** Clear output on each run (used for output printing in the UI). */\r\n    clear?: boolean;\r\n\r\n    /**\r\n     * Determines how quick the weight for a decision to be select converges towards 0 (between 0 and 1, default: 0.25).\r\n     * Each time a decision is taken its weight will decrease. The lower the weight is, compared to other decisions from\r\n     * a particular decision state, the less likely will it be selected.\r\n     */\r\n    convergenceFactor?: number;\r\n\r\n    /**\r\n     * The minimum number of iterations used for `+` and `*` loops in the parser (default: 1 for `+`, 0 for `*`).\r\n     * Must be a positive integer (or 0) and must be smaller than maxParserIterations (if that is given).\r\n     * If set to 0 then for `+` loops 1 is used, automatically.\r\n     */\r\n    minParserIterations?: number;\r\n\r\n    /**\r\n     * The maximum number of iterations in the parser. Must be a number > 0 and > minParserIterations.\r\n     * If that is not the case or the value is not specified then it is set to minParserIterations + 1.\r\n     */\r\n    maxParserIterations?: number;\r\n\r\n    /**\r\n     * The minimum number of iterations in the lexer (default: 1 for `+`, 0 for `*`).\r\n     * Must be a positive integer (or 0) and must be smaller than maxLexerIterations (if that is given).\r\n     * If set to 0 then for `+` loops 1 is used, automatically.\r\n     */\r\n    minLexerIterations?: number;\r\n\r\n    /**\r\n     * The maximum number of iterations in the lexer. Must be a number > 0 and > than minLexerIterations.\r\n     * If that is not the case or the value is not specified then it is set to minLexerIterations + 10.\r\n     */\r\n    maxLexerIterations?: number;\r\n\r\n    /** The maximum number of recursions (rules calling themselves directly or indirectly, default: 3). */\r\n    maxRecursions?: number;\r\n\r\n    /** The string to use when the maximum recursion level was reached (default: \"â¨±\"). */\r\n    maxRecursionLabel?: string;\r\n\r\n    /**\r\n     * A mapping of rule names to string literals, which should be used instead of running the generation for that rule.\r\n     */\r\n    ruleMappings?: IRuleMappings;\r\n\r\n    /** The name of a file which contains code to evaluate grammar actions and predicates. */\r\n    actionFile?: string;\r\n}\r\n\r\n/**\r\n * Mappings from rule names to strings, which define output to use for specific rules when generating sentences.\r\n */\r\nexport interface IRuleMappings {\r\n    [key: string]: string | string[];\r\n}\r\n\r\n/**\r\n * Options for grammar text formatting. Some names, values and meanings have been taken from clang-format\r\n * (http://clang.llvm.org/docs/ClangFormatStyleOptions.html), but may have slight variations tailored towards\r\n * ANTLR grammars. Deviations from that are mentioned in comments, otherwise see clang-format and the documentation for\r\n * descriptions + examples.\r\n */\r\nexport interface IFormattingOptions {\r\n    /** Index signature to allow accessing properties via brackets. */\r\n    [key: string]: boolean | number | string | undefined;\r\n\r\n    /** Default: false */\r\n    alignTrailingComments?: boolean;\r\n\r\n    /** Default: true; */\r\n    allowShortBlocksOnASingleLine?: boolean;\r\n\r\n    /** When true start predicates and actions on a new line. Default: false. */\r\n    breakBeforeBraces?: boolean;\r\n\r\n    /** Default: 100 chars. */\r\n    columnLimit?: number;\r\n\r\n    /** For line continuation (only used if useTab is false). Default: same as indentWith. */\r\n    continuationIndentWidth?: number;\r\n\r\n    /** Default: 4 chars. */\r\n    indentWidth?: number;\r\n\r\n    /** Default: false. */\r\n    keepEmptyLinesAtTheStartOfBlocks?: boolean;\r\n\r\n    /** Default: 1. */\r\n    maxEmptyLinesToKeep?: number;\r\n\r\n    /** Default: true. */\r\n    reflowComments?: boolean;\r\n\r\n    /** Default: true */\r\n    spaceBeforeAssignmentOperators?: boolean;\r\n\r\n    /** Default: 4. */\r\n    tabWidth?: number;\r\n\r\n    /** Default: true. */\r\n    useTab?: boolean;\r\n\r\n    /**\r\n     * Values not found in clang-format:\r\n     * When set to \"none\" places the colon directly behind the rule name. Trailing alignment aligns colons of\r\n     * consecutive single line rules (with at least one whitespace between rule name and colon). Hanging alignment\r\n     * moves the colon to the next line (after the normal indentation, aligning it so with the alt pipe chars).\r\n     * Default: none.\r\n     */\r\n    alignColons?: \"none\" | \"trailing\" | \"hanging\";\r\n\r\n    /**\r\n     * When `allowShortRulesOnASingleLine` is true and `alignColon` is set to \"hanging\" this setting determines which\r\n     * gets precedence. If true (the default) a rule is placed on a single line if it fits, ignoring the \"hanging\"\r\n     * setting.\r\n     */\r\n    singleLineOverrulesHangingColon?: boolean;\r\n\r\n    /** Like allowShortBlocksOnASingleLine, but for entire rules. Default: true. */\r\n    allowShortRulesOnASingleLine?: boolean;\r\n\r\n    /**\r\n     * Place semicolon behind last code token or on an own line (with or w/o indentation). Default: ownLine\r\n     * (no indentation). This setting has no effect for non-rule commands that end with a semicolon\r\n     * (e.g. \"grammar Test;\", \"import Blah;\" etc.). Such commands are always placed on a single line.\r\n     */\r\n    alignSemicolons?: \"none\" | \"ownLine\" | \"hanging\";\r\n\r\n    /** For blocks: if true puts opening parentheses on an own line. Default: false. */\r\n    breakBeforeParens?: boolean;\r\n\r\n    /**\r\n     * Place rule internals (return value, local variables, @init, @after) all on a single line, if true.\r\n     * Default: false.\r\n     */\r\n    ruleInternalsOnSingleLine?: boolean;\r\n\r\n    /** Between top level elements, how many empty lines must exist? Default: 0. */\r\n    minEmptyLines?: number;\r\n\r\n    /**\r\n     * When true alignments are organized in groups of lines where they apply. These line groups are separated\r\n     * by lines where a specific alignment type does not appear. Default: true.\r\n     */\r\n    groupedAlignments?: boolean;\r\n\r\n    /** Align first tokens in rules after the colon. Default: false. */\r\n    alignFirstTokens?: boolean;\r\n\r\n    /** Align arrows from lexer commands. Default: false. */\r\n    alignLexerCommands?: boolean;\r\n\r\n    /** Align actions ({} blocks in rules) and predicates. Default: false. */\r\n    alignActions?: boolean;\r\n\r\n    /** Align alt labels (# name). Default: true. */\r\n    alignLabels?: boolean;\r\n\r\n    /**\r\n     * When true a single alignment for labels, actions, lexer commands and trailing comments is used instead of\r\n     * individual alignments for each type. This avoids large whitespace runs if you have a mix of these types.\r\n     * Setting alignTrailers disables the individual alignment settings of the mentioned types.\r\n     */\r\n    alignTrailers?: boolean;\r\n}\r\n\r\nexport type PredicateFunction = (predicate: string) => boolean;\r\n\r\nexport interface IContextDetails {\r\n    type: GrammarType;\r\n    unreferencedRules: string[];\r\n    imports: string[];\r\n}\r\n\r\nexport interface ISelfDiagnostics {\r\n    contextCount: number;\r\n}\r\n"]}