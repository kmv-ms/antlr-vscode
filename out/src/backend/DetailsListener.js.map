{"version":3,"file":"DetailsListener.js","sourceRoot":"","sources":["../../../src/backend/DetailsListener.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\n// Need explicit any and any-spread for constructor functions.\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n/* eslint-disable @typescript-eslint/no-unsafe-argument */\r\n\r\nimport { ANTLRv4ParserListener } from \"../parser/ANTLRv4ParserListener\";\r\nimport {\r\n    LexerRuleSpecContext, ParserRuleSpecContext, TokensSpecContext, ChannelsSpecContext,\r\n    ModeSpecContext, DelegateGrammarContext, TerminalRuleContext, RulerefContext,\r\n    BlockContext, AlternativeContext, RuleBlockContext, EbnfSuffixContext,\r\n    OptionsSpecContext, ActionBlockContext, ArgActionBlockContext, LabeledElementContext,\r\n    LexerRuleBlockContext, LexerAltContext, ElementContext, LexerElementContext, NamedActionContext,\r\n    LexerCommandContext, OptionContext, OptionValueContext, ANTLRv4Parser,\r\n} from \"../parser/ANTLRv4Parser\";\r\n\r\nimport {\r\n    ContextSymbolTable, FragmentTokenSymbol, TokenSymbol, TokenReferenceSymbol, RuleSymbol, RuleReferenceSymbol,\r\n    VirtualTokenSymbol, TokenChannelSymbol, LexerModeSymbol, ImportSymbol, AlternativeSymbol, EbnfSuffixSymbol,\r\n    ArgumentSymbol, OperatorSymbol, GlobalNamedActionSymbol, ExceptionActionSymbol, FinallyActionSymbol,\r\n    ParserActionSymbol, LexerActionSymbol, OptionsSymbol, OptionSymbol, LexerPredicateSymbol,\r\n    ParserPredicateSymbol, LocalNamedActionSymbol, LexerCommandSymbol,\r\n} from \"./ContextSymbolTable\";\r\n\r\nimport { SourceContext } from \"./SourceContext\";\r\n\r\nimport { LiteralSymbol, BlockSymbol, BaseSymbol, VariableSymbol, SymbolConstructor } from \"antlr4-c3\";\r\nimport { ParseTree, TerminalNode } from \"antlr4ts/tree\";\r\nimport { ANTLRv4Lexer } from \"../parser/ANTLRv4Lexer\";\r\n\r\n/**\r\n * Removes outer quotes from the input.\r\n *\r\n * @param input The input to clean up.\r\n * @param quoteChar The quote char to remove.\r\n *\r\n * @returns The cleaned string.\r\n */\r\nconst unquote = (input: string, quoteChar?: string): string => {\r\n    quoteChar = quoteChar || '\"';\r\n    if (input[0] === quoteChar && input[input.length - 1] === quoteChar) {\r\n        return input.slice(1, input.length - 1);\r\n    }\r\n\r\n    return input;\r\n};\r\n\r\nexport class DetailsListener implements ANTLRv4ParserListener {\r\n    private symbolStack: BaseSymbol[] = [];\r\n\r\n    public constructor(private symbolTable: ContextSymbolTable, private imports: string[]) { }\r\n\r\n    /**\r\n     * The symbol stack usually contains entries beginning with a rule context, followed by a number of blocks and alts\r\n     * as well as additional parts like actions or predicates.\r\n     * This function returns the name of the first symbol, which represents the rule (parser/lexer) which we are\r\n     * currently walking over.\r\n     *\r\n     * @returns The rule name from the start symbol.\r\n     */\r\n    private get ruleName(): string {\r\n        return this.symbolStack.length === 0 ? \"\" : this.symbolStack[0].name;\r\n    }\r\n\r\n    public enterParserRuleSpec(ctx: ParserRuleSpecContext): void {\r\n        this.pushNewSymbol(RuleSymbol, ctx, ctx.RULE_REF().text);\r\n    }\r\n\r\n    public exitParserRuleSpec(_ctx: ParserRuleSpecContext): void {\r\n        this.popSymbol();\r\n    }\r\n\r\n    public enterRuleBlock(ctx: RuleBlockContext): void {\r\n        this.pushNewSymbol(BlockSymbol, ctx, \"\");\r\n    }\r\n\r\n    public exitRuleBlock(): void {\r\n        this.popSymbol();\r\n    }\r\n\r\n    public enterLexerRuleSpec(ctx: LexerRuleSpecContext): void {\r\n        if (ctx.FRAGMENT()) {\r\n            this.pushNewSymbol(FragmentTokenSymbol, ctx, ctx.TOKEN_REF().text);\r\n        } else {\r\n            this.pushNewSymbol(TokenSymbol, ctx, ctx.TOKEN_REF().text);\r\n        }\r\n    }\r\n\r\n    public exitLexerRuleSpec(): void {\r\n        this.popSymbol();\r\n    }\r\n\r\n    public enterLexerRuleBlock(ctx: LexerRuleBlockContext): void {\r\n        this.pushNewSymbol(BlockSymbol, ctx, \"\");\r\n    }\r\n\r\n    public exitLexerRuleBlock(_ctx: LexerRuleBlockContext): void {\r\n        this.popSymbol();\r\n    }\r\n\r\n    public enterBlock(ctx: BlockContext): void {\r\n        this.pushNewSymbol(BlockSymbol, ctx, \"\");\r\n    }\r\n\r\n    public exitBlock(_ctx: BlockContext): void {\r\n        this.popSymbol();\r\n    }\r\n\r\n    public enterAlternative(ctx: AlternativeContext): void {\r\n        this.pushNewSymbol(AlternativeSymbol, ctx, \"\");\r\n    }\r\n\r\n    public exitAlternative(_ctx: AlternativeContext): void {\r\n        this.popSymbol();\r\n    }\r\n\r\n    public enterLexerAlt(ctx: LexerAltContext): void {\r\n        this.pushNewSymbol(AlternativeSymbol, ctx, \"\");\r\n    }\r\n\r\n    public exitLexerAlt(_ctx: LexerAltContext): void {\r\n        this.popSymbol();\r\n    }\r\n\r\n    public exitTokensSpec(ctx: TokensSpecContext): void {\r\n        const idList = ctx.idList();\r\n        if (idList) {\r\n            for (const identifier of idList.identifier()) {\r\n                this.addNewSymbol(VirtualTokenSymbol, ctx, identifier.text);\r\n            }\r\n        }\r\n    }\r\n\r\n    public exitChannelsSpec(ctx: ChannelsSpecContext): void {\r\n        const idList = ctx.idList();\r\n        if (idList) {\r\n            for (const identifier of idList.identifier()) {\r\n                this.addNewSymbol(TokenChannelSymbol, ctx, identifier.text);\r\n            }\r\n        }\r\n    }\r\n\r\n    public exitTerminalRule(ctx: TerminalRuleContext): void {\r\n        let token = ctx.TOKEN_REF();\r\n        if (token) {\r\n            this.addNewSymbol(TokenReferenceSymbol, ctx, token.text);\r\n        } else {\r\n            // Must be a string literal then.\r\n            token = ctx.STRING_LITERAL();\r\n            if (token) {\r\n                const refName = unquote(token.text, \"'\");\r\n                this.addNewSymbol(LiteralSymbol, token, refName, refName);\r\n            }\r\n        }\r\n    }\r\n\r\n    public exitRuleref(ctx: RulerefContext): void {\r\n        const token = ctx.RULE_REF();\r\n        if (token) {\r\n            this.addNewSymbol(RuleReferenceSymbol, ctx, token.text);\r\n        }\r\n    }\r\n\r\n    public exitModeSpec(ctx: ModeSpecContext): void {\r\n        this.addNewSymbol(LexerModeSymbol, ctx, ctx.identifier().text);\r\n    }\r\n\r\n    public exitDelegateGrammar(ctx: DelegateGrammarContext): void {\r\n        const context = ctx.identifier()[ctx.identifier().length - 1];\r\n        if (context) {\r\n            const name = SourceContext.definitionForContext(context, false)!.text;\r\n            this.addNewSymbol(ImportSymbol, context, name);\r\n            this.imports.push(name);\r\n        }\r\n    }\r\n\r\n    public enterOptionsSpec(ctx: OptionsSpecContext): void {\r\n        this.pushNewSymbol(OptionsSymbol, ctx, \"options\");\r\n    }\r\n\r\n    public exitOptionsSpec(_ctx: OptionsSpecContext): void {\r\n        this.popSymbol();\r\n    }\r\n\r\n    public exitOption(ctx: OptionContext): void {\r\n        const option = ctx.identifier().text;\r\n        const valueContext = ctx.tryGetRuleContext(0, OptionValueContext);\r\n        if (valueContext && valueContext.childCount > 0) {\r\n            const symbol = this.addNewSymbol(OptionSymbol, valueContext.getChild(0), option);\r\n            symbol.value = valueContext.text;\r\n            if (option === \"tokenVocab\") {\r\n                this.imports.push(valueContext.text);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles all types of native actions in various locations, instead of doing that in individual listener methods.\r\n     *\r\n     * @param ctx The parser context for the action block.\r\n     */\r\n    public exitActionBlock(ctx: ActionBlockContext): void {\r\n        let run = ctx.parent;\r\n\r\n        while (run) {\r\n            switch (run.ruleIndex) {\r\n                case ANTLRv4Parser.RULE_optionValue: {\r\n                    // The grammar allows to assign a native action block to an option variable, but ANTLR4 itself\r\n                    // doesn't accept that. So we ignore it here too.\r\n                    return;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_namedAction: {\r\n                    // Global level named action, like @parser.\r\n                    const localContext = run as NamedActionContext;\r\n                    let prefix = \"\";\r\n\r\n                    const actionScopeName = localContext.actionScopeName();\r\n                    if (actionScopeName) {\r\n                        prefix = actionScopeName.text + \"::\";\r\n                    }\r\n\r\n                    const symbol = this.addNewSymbol(GlobalNamedActionSymbol, ctx,\r\n                        prefix + localContext.identifier().text);\r\n                    this.symbolTable.defineNamedAction(symbol);\r\n\r\n                    return;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_exceptionHandler: {\r\n                    this.addNewSymbol(ExceptionActionSymbol, ctx);\r\n\r\n                    return;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_finallyClause: {\r\n                    this.addNewSymbol(FinallyActionSymbol, ctx);\r\n\r\n                    return;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_ruleAction: {\r\n                    // Rule level named actions, like @init.\r\n                    const symbol = this.addNewSymbol(LocalNamedActionSymbol, ctx, this.ruleName);\r\n                    this.symbolTable.defineNamedAction(symbol);\r\n\r\n                    return;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_lexerElement: {\r\n                    // Lexer inline action or predicate.\r\n                    const localContext = run as LexerElementContext;\r\n                    if (localContext.QUESTION()) {\r\n                        const symbol = this.addNewSymbol(LexerPredicateSymbol, ctx);\r\n                        this.symbolTable.definePredicate(symbol);\r\n                    } else {\r\n                        const symbol = this.addNewSymbol(LexerActionSymbol, ctx);\r\n                        this.symbolTable.defineLexerAction(symbol);\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_element: {\r\n                    // Parser inline action or predicate.\r\n                    const localContext = run as ElementContext;\r\n                    if (localContext.QUESTION()) {\r\n                        const symbol = this.addNewSymbol(ParserPredicateSymbol, ctx);\r\n                        this.symbolTable.definePredicate(symbol);\r\n                    } else {\r\n                        const symbol = this.addNewSymbol(ParserActionSymbol, ctx);\r\n                        this.symbolTable.defineParserAction(symbol);\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                default: {\r\n                    run = run.parent;\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles argument action code blocks.\r\n     *\r\n     * @param ctx The parser context for the action block.\r\n     */\r\n    public exitArgActionBlock(ctx: ArgActionBlockContext): void {\r\n        if (this.symbolStack.length === 0) {\r\n            return;\r\n        }\r\n\r\n        let run = ctx.parent;\r\n        while (run && run !== this.symbolStack[0].context) {\r\n            run = run.parent;\r\n        }\r\n\r\n        if (run) {\r\n            switch (run.ruleIndex) {\r\n                case ANTLRv4Parser.RULE_exceptionHandler: {\r\n                    this.addNewSymbol(ArgumentSymbol, ctx, \"exceptionHandler\");\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_finallyClause: {\r\n                    this.addNewSymbol(ArgumentSymbol, ctx, \"finallyClause\");\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_ruleReturns: {\r\n                    this.addNewSymbol(ArgumentSymbol, ctx, \"ruleReturns\");\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_localsSpec: {\r\n                    this.addNewSymbol(ArgumentSymbol, ctx, \"localsSpec\");\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_ruleref: {\r\n                    this.addNewSymbol(ArgumentSymbol, ctx, \"ruleRef\");\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_parserRuleSpec: {\r\n                    this.addNewSymbol(ArgumentSymbol, ctx, \"parserRuleSpec\");\r\n\r\n                    break;\r\n                }\r\n\r\n                default: {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public exitEbnfSuffix(ctx: EbnfSuffixContext): void {\r\n        this.addNewSymbol(EbnfSuffixSymbol, ctx, ctx.text);\r\n    }\r\n\r\n    public enterLexerCommand(ctx: LexerCommandContext): void {\r\n        this.pushNewSymbol(LexerCommandSymbol, ctx, ctx.lexerCommandName().text);\r\n    }\r\n\r\n    public exitLexerCommand(_ctx: LexerCommandContext): void {\r\n        this.popSymbol();\r\n    }\r\n\r\n    public exitLabeledElement(ctx: LabeledElementContext): void {\r\n        this.addNewSymbol(VariableSymbol, ctx, ctx.identifier().text);\r\n    }\r\n\r\n    public visitTerminal = (node: TerminalNode): void => {\r\n        // Ignore individual terminals under certain circumstances.\r\n        if (this.currentSymbol() instanceof LexerCommandSymbol) {\r\n            return;\r\n        }\r\n\r\n        switch (node.symbol.type) {\r\n            case ANTLRv4Lexer.COLON:\r\n            case ANTLRv4Lexer.COLONCOLON:\r\n            case ANTLRv4Lexer.COMMA:\r\n            case ANTLRv4Lexer.SEMI:\r\n            case ANTLRv4Lexer.LPAREN:\r\n            case ANTLRv4Lexer.RPAREN:\r\n            case ANTLRv4Lexer.LBRACE:\r\n            case ANTLRv4Lexer.RBRACE:\r\n            case ANTLRv4Lexer.RARROW:\r\n            case ANTLRv4Lexer.LT:\r\n            case ANTLRv4Lexer.GT:\r\n            case ANTLRv4Lexer.ASSIGN:\r\n            case ANTLRv4Lexer.QUESTION:\r\n            case ANTLRv4Lexer.STAR:\r\n            case ANTLRv4Lexer.PLUS_ASSIGN:\r\n            case ANTLRv4Lexer.PLUS:\r\n            case ANTLRv4Lexer.OR:\r\n            case ANTLRv4Lexer.DOLLAR:\r\n            case ANTLRv4Lexer.RANGE:\r\n            case ANTLRv4Lexer.DOT:\r\n            case ANTLRv4Lexer.AT:\r\n            case ANTLRv4Lexer.POUND:\r\n            case ANTLRv4Lexer.NOT: {\r\n                this.addNewSymbol(OperatorSymbol, node, node.text);\r\n                break;\r\n            }\r\n\r\n            default: {\r\n                // Ignore the rest.\r\n                break;\r\n            }\r\n        }\r\n    };\r\n\r\n    private currentSymbol<T extends BaseSymbol>(): T | undefined {\r\n        if (this.symbolStack.length === 0) {\r\n            return undefined;\r\n        }\r\n\r\n        return this.symbolStack[this.symbolStack.length - 1] as T;\r\n    }\r\n\r\n    /**\r\n     * Adds a new symbol to the current symbol TOS.\r\n     *\r\n     * @param type The type of the symbol to add.\r\n     * @param context The symbol's parse tree, to allow locating it.\r\n     * @param args The actual arguments for the new symbol.\r\n     *\r\n     * @returns The new symbol.\r\n     */\r\n    private addNewSymbol<T extends BaseSymbol>(type: new (...args: any[]) => T, context: ParseTree,\r\n        ...args: any[]): T {\r\n        const symbol = this.symbolTable.addNewSymbolOfType(type, this.currentSymbol(), ...args);\r\n        symbol.context = context;\r\n\r\n        return symbol;\r\n    }\r\n\r\n    /**\r\n     * Creates a new symbol and starts a new scope with it on the symbol stack.\r\n     *\r\n     * @param type The type of the symbol to add.\r\n     * @param context The symbol's parse tree, to allow locating it.\r\n     * @param args The actual arguments for the new symbol.\r\n     *\r\n     * @returns The new scoped symbol.\r\n     */\r\n    private pushNewSymbol<T extends BaseSymbol, Args extends unknown[]>(type: SymbolConstructor<T, Args>,\r\n        context: ParseTree, ...args: Args): BaseSymbol {\r\n        const symbol = this.symbolTable.addNewSymbolOfType<T, Args>(type, this.currentSymbol(), ...args);\r\n        symbol.context = context;\r\n        this.symbolStack.push(symbol);\r\n\r\n        return symbol;\r\n    }\r\n\r\n    private popSymbol(): BaseSymbol | undefined {\r\n        return this.symbolStack.pop();\r\n    }\r\n}\r\n"]}