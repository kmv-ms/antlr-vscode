{"version":3,"file":"ContextSymbolTable.js","sourceRoot":"","sources":["../../../src/backend/ContextSymbolTable.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\n/* eslint-disable max-classes-per-file */\r\n\r\nimport { ParserRuleContext } from \"antlr4ts\";\r\nimport { SymbolTable, SymbolTableOptions, BaseSymbol, ScopedSymbol, SymbolConstructor } from \"antlr4-c3\";\r\n\r\nimport { ISymbolInfo, CodeActionType, SymbolKind, SymbolGroupKind } from \"./types\";\r\nimport { SourceContext } from \"./SourceContext\";\r\nimport { ParseTree } from \"antlr4ts/tree\";\r\n\r\nexport class OptionSymbol extends BaseSymbol {\r\n    public value: string;\r\n}\r\n\r\nexport class ImportSymbol extends BaseSymbol { }\r\nexport class BuiltInTokenSymbol extends BaseSymbol { }\r\nexport class VirtualTokenSymbol extends BaseSymbol { }\r\nexport class FragmentTokenSymbol extends ScopedSymbol { }\r\nexport class TokenSymbol extends ScopedSymbol { }\r\nexport class TokenReferenceSymbol extends BaseSymbol { }\r\nexport class BuiltInModeSymbol extends BaseSymbol { }\r\nexport class LexerModeSymbol extends BaseSymbol { }\r\nexport class BuiltInChannelSymbol extends BaseSymbol { }\r\nexport class TokenChannelSymbol extends BaseSymbol { }\r\nexport class RuleSymbol extends ScopedSymbol { }\r\nexport class RuleReferenceSymbol extends BaseSymbol { }\r\nexport class AlternativeSymbol extends ScopedSymbol { }\r\nexport class EbnfSuffixSymbol extends BaseSymbol { }\r\nexport class OptionsSymbol extends ScopedSymbol { }\r\nexport class ArgumentSymbol extends ScopedSymbol { }\r\nexport class OperatorSymbol extends BaseSymbol { }\r\nexport class TerminalSymbol extends BaseSymbol { }          // Any other terminal but operators.\r\nexport class LexerCommandSymbol extends BaseSymbol { }      // Commands in lexer rules after the -> introducer.\r\n\r\n// Symbols for all kind of native code blocks in a grammar.\r\nexport class GlobalNamedActionSymbol extends BaseSymbol { } // Top level actions prefixed with @.\r\nexport class LocalNamedActionSymbol extends BaseSymbol { }  // Rule level actions prefixed with @.\r\n\r\nexport class ExceptionActionSymbol extends BaseSymbol { }   // Action code in exception blocks.\r\nexport class FinallyActionSymbol extends BaseSymbol { }     // Ditto for finally clauses.\r\n\r\nexport class ParserActionSymbol extends BaseSymbol { }      // Simple code blocks in rule alts for a parser rule.\r\nexport class LexerActionSymbol extends BaseSymbol { }       // Ditto for lexer rules.\r\n\r\nexport class ParserPredicateSymbol extends BaseSymbol { }   // Predicate code in a parser rule.\r\nexport class LexerPredicateSymbol extends BaseSymbol { }    // Ditto for lexer rules.\r\n\r\nexport class ArgumentsSymbol extends BaseSymbol { }          // Native code for argument blocks and local variables.\r\n\r\nexport class ContextSymbolTable extends SymbolTable {\r\n    public tree: ParserRuleContext; // Set by the owning source context after each parse run.\r\n\r\n    private symbolReferences = new Map<string, number>();\r\n\r\n    // Caches with reverse lookup for indexed symbols.\r\n    private namedActions: BaseSymbol[] = [];\r\n    private parserActions: BaseSymbol[] = [];\r\n    private lexerActions: BaseSymbol[] = [];\r\n    private parserPredicates: BaseSymbol[] = [];\r\n    private lexerPredicates: BaseSymbol[] = [];\r\n\r\n    public constructor(name: string, options: SymbolTableOptions, public owner?: SourceContext) {\r\n        super(name, options);\r\n    }\r\n\r\n    public override clear(): void {\r\n        // Before clearing the dependencies make sure the owners are updated.\r\n        if (this.owner) {\r\n            for (const dep of this.dependencies) {\r\n                if ((dep as ContextSymbolTable).owner) {\r\n                    this.owner.removeDependency((dep as ContextSymbolTable).owner!);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.symbolReferences.clear();\r\n        this.namedActions = [];\r\n        this.parserActions = [];\r\n        this.lexerActions = [];\r\n        this.parserPredicates = [];\r\n        this.lexerPredicates = [];\r\n\r\n        super.clear();\r\n    }\r\n\r\n    public symbolExists(name: string, kind: SymbolKind, localOnly: boolean): boolean {\r\n        return this.getSymbolOfType(name, kind, localOnly) !== undefined;\r\n    }\r\n\r\n    public symbolExistsInGroup(symbol: string, kind: SymbolGroupKind, localOnly: boolean): boolean {\r\n        // Group of lookups.\r\n        switch (kind) {\r\n            case SymbolGroupKind.TokenRef: {\r\n                if (this.symbolExists(symbol, SymbolKind.BuiltInLexerToken, localOnly)) {\r\n                    return true;\r\n                }\r\n                if (this.symbolExists(symbol, SymbolKind.VirtualLexerToken, localOnly)) {\r\n                    return true;\r\n                }\r\n                if (this.symbolExists(symbol, SymbolKind.FragmentLexerToken, localOnly)) {\r\n                    return true;\r\n                }\r\n                if (this.symbolExists(symbol, SymbolKind.LexerRule, localOnly)) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n\r\n            case SymbolGroupKind.LexerMode: {\r\n                if (this.symbolExists(symbol, SymbolKind.BuiltInMode, localOnly)) {\r\n                    return true;\r\n                }\r\n                if (this.symbolExists(symbol, SymbolKind.LexerMode, localOnly)) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n\r\n            case SymbolGroupKind.TokenChannel: {\r\n                if (this.symbolExists(symbol, SymbolKind.BuiltInChannel, localOnly)) {\r\n                    return true;\r\n                }\r\n                if (this.symbolExists(symbol, SymbolKind.TokenChannel, localOnly)) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n\r\n            case SymbolGroupKind.RuleRef: {\r\n                if (this.symbolExists(symbol, SymbolKind.ParserRule, localOnly)) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n\r\n            default: {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public contextForSymbol(symbolName: string, kind: SymbolKind, localOnly: boolean): ParseTree | undefined {\r\n        const symbol = this.getSymbolOfType(symbolName, kind, localOnly);\r\n        if (!symbol) {\r\n            return undefined;\r\n        }\r\n\r\n        return symbol.context;\r\n    }\r\n\r\n    public getSymbolInfo(symbol: string | BaseSymbol): ISymbolInfo | undefined {\r\n        if (!(symbol instanceof BaseSymbol)) {\r\n            const temp = this.resolveSync(symbol);\r\n            if (!temp) {\r\n                return undefined;\r\n            }\r\n            symbol = temp;\r\n        }\r\n\r\n        let kind = SourceContext.getKindFromSymbol(symbol);\r\n        const name = symbol.name;\r\n\r\n        // Special handling for certain symbols.\r\n        switch (kind) {\r\n            case SymbolKind.TokenVocab:\r\n            case SymbolKind.Import: {\r\n                // Get the source id from a dependent module.\r\n                this.dependencies.forEach((table: ContextSymbolTable) => {\r\n                    if (table.owner && table.owner.sourceId.includes(name)) {\r\n                        return { // TODO: implement a best match search.\r\n                            kind,\r\n                            name,\r\n                            source: table.owner.fileName,\r\n                            definition: SourceContext.definitionForContext(table.tree, true),\r\n                        };\r\n                    }\r\n                });\r\n\r\n                break;\r\n            }\r\n\r\n            case SymbolKind.Terminal: {\r\n                // These are references to a depending grammar.\r\n                this.dependencies.forEach((table: ContextSymbolTable) => {\r\n                    const actualSymbol = table.resolveSync(name);\r\n                    if (actualSymbol) {\r\n                        symbol = actualSymbol;\r\n                        kind = SourceContext.getKindFromSymbol(actualSymbol);\r\n                    }\r\n                });\r\n\r\n                break;\r\n            }\r\n\r\n            default: {\r\n                break;\r\n            }\r\n        }\r\n\r\n        const symbolTable = symbol.symbolTable as ContextSymbolTable;\r\n\r\n        return {\r\n            kind,\r\n            name,\r\n            source: (symbol.context && symbolTable && symbolTable.owner) ? symbolTable.owner.fileName : \"ANTLR runtime\",\r\n            definition: SourceContext.definitionForContext(symbol.context, true),\r\n            description: undefined,\r\n        };\r\n\r\n    }\r\n\r\n    public listTopLevelSymbols(localOnly: boolean): ISymbolInfo[] {\r\n        const result: ISymbolInfo[] = [];\r\n\r\n        const options = this.resolveSync(\"options\", true);\r\n        if (options) {\r\n            const tokenVocab = options.resolveSync(\"tokenVocab\", true);\r\n            if (tokenVocab) {\r\n                const value = this.getSymbolInfo(tokenVocab);\r\n                if (value) {\r\n                    result.push(value);\r\n                }\r\n            }\r\n        }\r\n\r\n        let symbols = this.symbolsOfType(ImportSymbol, localOnly);\r\n        result.push(...symbols);\r\n        symbols = this.symbolsOfType(BuiltInTokenSymbol, localOnly);\r\n        result.push(...symbols);\r\n        symbols = this.symbolsOfType(VirtualTokenSymbol, localOnly);\r\n        result.push(...symbols);\r\n        symbols = this.symbolsOfType(FragmentTokenSymbol, localOnly);\r\n        result.push(...symbols);\r\n        symbols = this.symbolsOfType(TokenSymbol, localOnly);\r\n        result.push(...symbols);\r\n        symbols = this.symbolsOfType(BuiltInModeSymbol, localOnly);\r\n        result.push(...symbols);\r\n        symbols = this.symbolsOfType(LexerModeSymbol, localOnly);\r\n        result.push(...symbols);\r\n        symbols = this.symbolsOfType(BuiltInChannelSymbol, localOnly);\r\n        result.push(...symbols);\r\n        symbols = this.symbolsOfType(TokenChannelSymbol, localOnly);\r\n        result.push(...symbols);\r\n        symbols = this.symbolsOfType(RuleSymbol, localOnly);\r\n        result.push(...symbols);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Collects a list of action symbols.\r\n     *\r\n     * @param type The type of actions to return.\r\n     *\r\n     * @returns BaseSymbol information for each defined action.\r\n     */\r\n    public listActions(type: CodeActionType): ISymbolInfo[] {\r\n        const result: ISymbolInfo[] = [];\r\n\r\n        try {\r\n            const list = this.actionListOfType(type);\r\n            for (const entry of list) {\r\n                const definition = SourceContext.definitionForContext(entry.context, true);\r\n                if (definition && entry.name.toLowerCase() === \"skip\") {\r\n                    // Seems there's a bug for the skip action where the parse tree indicates a\r\n                    // single letter source range.\r\n                    definition.range.end.column = definition.range.start.column + 3;\r\n                }\r\n\r\n                result.push({\r\n                    kind: SourceContext.getKindFromSymbol(entry),\r\n                    name: entry.name,\r\n                    source: this.owner ? this.owner.fileName : \"\",\r\n                    definition,\r\n                    description: entry.context!.text,\r\n                });\r\n            }\r\n        } catch (e) {\r\n            result.push({\r\n                kind: SymbolKind.Unknown,\r\n                name: \"Error getting actions list\",\r\n                description: \"Internal error occurred while collecting the list of defined actions\",\r\n                source: \"\",\r\n            });\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    public getActionCounts(): Map<CodeActionType, number> {\r\n        const result = new Map<CodeActionType, number>();\r\n\r\n        let list = this.namedActions.filter((symbol) => {\r\n            return symbol instanceof LocalNamedActionSymbol;\r\n        });\r\n        result.set(CodeActionType.LocalNamed, list.length);\r\n\r\n        list = this.namedActions.filter((symbol) => {\r\n            return symbol instanceof GlobalNamedActionSymbol;\r\n        });\r\n        result.set(CodeActionType.GlobalNamed, list.length);\r\n\r\n        result.set(CodeActionType.ParserAction, this.parserActions.length);\r\n        result.set(CodeActionType.LexerAction, this.lexerActions.length);\r\n        result.set(CodeActionType.ParserPredicate, this.parserPredicates.length);\r\n        result.set(CodeActionType.LexerPredicate, this.lexerPredicates.length);\r\n\r\n        return result;\r\n    }\r\n\r\n    public getReferenceCount(symbolName: string): number {\r\n        const reference = this.symbolReferences.get(symbolName);\r\n        if (reference) {\r\n            return reference;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    public getUnreferencedSymbols(): string[] {\r\n        const result: string[] = [];\r\n        for (const entry of this.symbolReferences) {\r\n            if (entry[1] === 0) {\r\n                result.push(entry[0]);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    public incrementSymbolRefCount(symbolName: string): void {\r\n        const reference = this.symbolReferences.get(symbolName);\r\n        if (reference) {\r\n            this.symbolReferences.set(symbolName, reference + 1);\r\n        } else {\r\n            this.symbolReferences.set(symbolName, 1);\r\n        }\r\n    }\r\n\r\n    public getSymbolOccurrences(symbolName: string, localOnly: boolean): ISymbolInfo[] {\r\n        const result: ISymbolInfo[] = [];\r\n\r\n        const symbols = this.getAllSymbolsSync(BaseSymbol, localOnly);\r\n        for (const symbol of symbols) {\r\n            const owner = (symbol.root as ContextSymbolTable).owner;\r\n\r\n            if (owner) {\r\n                if (symbol.context && symbol.name === symbolName) {\r\n                    let context = symbol.context;\r\n                    if (symbol instanceof FragmentTokenSymbol) {\r\n                        context = (symbol.context as ParserRuleContext).children![1];\r\n                    } else if (symbol instanceof TokenSymbol || symbol instanceof RuleSymbol) {\r\n                        context = (symbol.context as ParserRuleContext).children![0];\r\n                    }\r\n\r\n                    result.push({\r\n                        kind: SourceContext.getKindFromSymbol(symbol),\r\n                        name: symbolName,\r\n                        source: owner.fileName,\r\n                        definition: SourceContext.definitionForContext(context, true),\r\n                        description: undefined,\r\n                    });\r\n                }\r\n\r\n                if (symbol instanceof ScopedSymbol) {\r\n                    const references = symbol.getAllNestedSymbolsSync(symbolName);\r\n                    for (const reference of references) {\r\n                        result.push({\r\n                            kind: SourceContext.getKindFromSymbol(reference),\r\n                            name: symbolName,\r\n                            source: owner.fileName,\r\n                            definition: SourceContext.definitionForContext(reference.context, true),\r\n                            description: undefined,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Stores the given symbol in the named action cache.\r\n     *\r\n     * @param action The symbol representing the action.\r\n     */\r\n    public defineNamedAction(action: BaseSymbol): void {\r\n        this.namedActions.push(action);\r\n    }\r\n\r\n    /**\r\n     * Stores the given action in the parser action cache.\r\n     *\r\n     * @param action The symbol representing the action.\r\n     */\r\n    public defineParserAction(action: BaseSymbol): void {\r\n        this.parserActions.push(action);\r\n    }\r\n\r\n    /**\r\n     * Stores the given symbol in the lexer action cache.\r\n     *\r\n     * @param action The symbol representing the action.\r\n     */\r\n    public defineLexerAction(action: BaseSymbol): void {\r\n        this.lexerActions.push(action);\r\n    }\r\n\r\n    /**\r\n     * Stores the given symbol in the predicate cache. The current size of the cache\r\n     * defines its index, as used in predicate evaluation.\r\n     *\r\n     * @param predicate The symbol representing the predicate.\r\n     */\r\n    public definePredicate(predicate: BaseSymbol): void {\r\n        if (predicate instanceof LexerPredicateSymbol) {\r\n            this.lexerPredicates.push(predicate);\r\n        } else {\r\n            this.parserPredicates.push(predicate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Does a depth-first search in the table for a symbol which contains the given context.\r\n     * The search is based on the token indices which the context covers and goes down as much as possible to find\r\n     * the closes covering symbol.\r\n     *\r\n     * @param context The context to search for.\r\n     *\r\n     * @returns The symbol covering the given context or undefined if nothing was found.\r\n     */\r\n    public symbolContainingContext(context: ParseTree): BaseSymbol | undefined {\r\n        const findRecursive = (parent: ScopedSymbol): BaseSymbol | undefined => {\r\n            for (const symbol of parent.children) {\r\n                if (!symbol.context) {\r\n                    continue;\r\n                }\r\n\r\n                if (symbol.context.sourceInterval.properlyContains(context.sourceInterval)) {\r\n                    let child;\r\n                    if (symbol instanceof ScopedSymbol) {\r\n                        child = findRecursive(symbol);\r\n\r\n                    }\r\n\r\n                    if (child) {\r\n                        return child;\r\n                    } else {\r\n                        return symbol;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        return findRecursive(this);\r\n    }\r\n\r\n    /**\r\n     * Collects a list of action symbols.\r\n     *\r\n     * @param type The type of actions to return.\r\n     *\r\n     * @returns BaseSymbol information for each defined action.\r\n     */\r\n    private actionListOfType(type: CodeActionType): BaseSymbol[] {\r\n        switch (type) {\r\n            case CodeActionType.LocalNamed: {\r\n                return this.namedActions.filter((symbol) => {\r\n                    return symbol instanceof LocalNamedActionSymbol;\r\n                });\r\n            }\r\n\r\n            case CodeActionType.ParserAction: {\r\n                return this.parserActions;\r\n            }\r\n\r\n            case CodeActionType.LexerAction: {\r\n                return this.lexerActions;\r\n\r\n            }\r\n\r\n            case CodeActionType.ParserPredicate: {\r\n                return this.parserPredicates;\r\n\r\n            }\r\n\r\n            case CodeActionType.LexerPredicate: {\r\n                return this.lexerPredicates;\r\n            }\r\n\r\n            default: {\r\n                return this.namedActions.filter((symbol) => {\r\n                    return symbol instanceof GlobalNamedActionSymbol;\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    private symbolsOfType<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>,\r\n        localOnly = false): ISymbolInfo[] {\r\n        const result: ISymbolInfo[] = [];\r\n\r\n        const symbols = this.getAllSymbolsSync(t, localOnly);\r\n        const filtered = new Set(symbols); // Filter for duplicates.\r\n        for (const symbol of filtered) {\r\n            const root = symbol.root as ContextSymbolTable;\r\n            result.push({\r\n                kind: SourceContext.getKindFromSymbol(symbol),\r\n                name: symbol.name,\r\n                source: root.owner ? root.owner.fileName : \"ANTLR runtime\",\r\n                definition: SourceContext.definitionForContext(symbol.context, true),\r\n                description: undefined,\r\n            });\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private getSymbolOfType(name: string, kind: SymbolKind, localOnly: boolean): BaseSymbol | undefined {\r\n        switch (kind) {\r\n            case SymbolKind.TokenVocab: {\r\n                const options = this.resolveSync(\"options\", true);\r\n                if (options) {\r\n                    return options.resolveSync(name, localOnly);\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case SymbolKind.Import: {\r\n                return this.resolveSync(name, localOnly) as ImportSymbol;\r\n            }\r\n\r\n            case SymbolKind.BuiltInLexerToken: {\r\n                return this.resolveSync(name, localOnly) as BuiltInTokenSymbol;\r\n            }\r\n\r\n            case SymbolKind.VirtualLexerToken: {\r\n                return this.resolveSync(name, localOnly) as VirtualTokenSymbol;\r\n            }\r\n\r\n            case SymbolKind.FragmentLexerToken: {\r\n                return this.resolveSync(name, localOnly) as FragmentTokenSymbol;\r\n            }\r\n\r\n            case SymbolKind.LexerRule: {\r\n                return this.resolveSync(name, localOnly) as TokenSymbol;\r\n            }\r\n\r\n            case SymbolKind.BuiltInMode: {\r\n                return this.resolveSync(name, localOnly) as BuiltInModeSymbol;\r\n            }\r\n\r\n            case SymbolKind.LexerMode: {\r\n                return this.resolveSync(name, localOnly) as LexerModeSymbol;\r\n            }\r\n\r\n            case SymbolKind.BuiltInChannel: {\r\n                return this.resolveSync(name, localOnly) as BuiltInChannelSymbol;\r\n            }\r\n\r\n            case SymbolKind.TokenChannel: {\r\n                return this.resolveSync(name, localOnly) as TokenChannelSymbol;\r\n            }\r\n\r\n            case SymbolKind.ParserRule: {\r\n                return this.resolveSync(name, localOnly) as RuleSymbol;\r\n            }\r\n\r\n            default:\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n}\r\n"]}