{"version":3,"file":"GrammarDebugger.js","sourceRoot":"","sources":["../../../src/backend/GrammarDebugger.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\nimport { EventEmitter } from \"events\";\r\n\r\nimport { CharStreams, CommonTokenStream, CommonToken, ParserRuleContext, Token, Lexer } from \"antlr4ts\";\r\nimport { ParseTree, ErrorNode, TerminalNode } from \"antlr4ts/tree\";\r\nimport { ScopedSymbol, VariableSymbol } from \"antlr4-c3\";\r\n\r\nimport { IInterpreterData } from \"./InterpreterDataReader\";\r\nimport { ILexerToken, ILexicalRange, IParseTreeNode, PredicateFunction } from \"./types\";\r\n\r\nimport { RuleSymbol } from \"./ContextSymbolTable\";\r\nimport { SourceContext } from \"./SourceContext\";\r\nimport {\r\n    GrammarLexerInterpreter, InterpreterLexerErrorListener, GrammarParserInterpreter, InterpreterParserErrorListener,\r\n    RunMode,\r\n} from \"./GrammarInterpreters\";\r\n\r\nimport * as vm from \"vm\";\r\nimport * as fs from \"fs\";\r\n\r\nexport interface IGrammarBreakPoint {\r\n    source: string;\r\n    validated: boolean;\r\n    line: number;\r\n    id: number;\r\n}\r\n\r\nexport interface IGrammarStackFrame {\r\n    name: string;\r\n    source: string;\r\n    next: ILexicalRange[];\r\n}\r\n\r\n/**\r\n * This class provides debugging support for a grammar.\r\n */\r\nexport class GrammarDebugger extends EventEmitter {\r\n    // Interpreter data for the main grammar as well as all imported grammars.\r\n    private lexerData: IInterpreterData | undefined;\r\n    private parserData: IInterpreterData | undefined;\r\n\r\n    private lexer: GrammarLexerInterpreter;\r\n    private tokenStream: CommonTokenStream;\r\n    private parser: GrammarParserInterpreter | undefined;\r\n    private parseTree: ParserRuleContext | undefined;\r\n\r\n    private breakPoints = new Map<number, IGrammarBreakPoint>();\r\n    private nextBreakPointId = 0;\r\n\r\n    public constructor(private contexts: SourceContext[], actionFile: string) {\r\n        super();\r\n\r\n        if (this.contexts.length === 0) {\r\n            return;\r\n        }\r\n\r\n        let predicateFunction;\r\n\r\n        if (actionFile) {\r\n            const code = fs.readFileSync(actionFile, { encoding: \"utf-8\" }) + `\r\n            const runPredicate = (predicate) => eval(predicate);\r\n            runPredicate;\r\n            `;\r\n\r\n            predicateFunction = vm.runInNewContext(code) as PredicateFunction;\r\n        }\r\n\r\n        // The context list contains all dependencies of the main grammar (which is the first entry).\r\n        // There can be only one context with lexer data (either the main context if that represents a combined\r\n        // grammar) or a dedicated lexer context. Parser data is merged into one set (by ANTLR4) even if there\r\n        // are sub grammars. We need sub grammar contexts for breakpoint validation and call stacks.\r\n        if (this.isValid) {\r\n            // Set up the required structures with an empty input stream.\r\n            // On start we will replace that with the actual input.\r\n            let lexerName = \"\";\r\n            for (const context of this.contexts) {\r\n                const [lexerData, parserData] = context.interpreterData;\r\n                if (!this.lexerData && lexerData) {\r\n                    this.lexerData = lexerData;\r\n                    lexerName = context.fileName;\r\n                }\r\n\r\n                if (!this.parserData && parserData) {\r\n                    this.parserData = parserData;\r\n                }\r\n            }\r\n\r\n            const eventSink = (event: string | symbol, ...args: unknown[]): void => {\r\n                setImmediate((_) => { return this.emit(event, args); });\r\n            };\r\n\r\n            if (this.lexerData) {\r\n                const stream = CharStreams.fromString(\"\");\r\n                this.lexer = new GrammarLexerInterpreter(predicateFunction, this.contexts[0], lexerName,\r\n                    this.lexerData, stream);\r\n                this.lexer.removeErrorListeners();\r\n                this.lexer.addErrorListener(new InterpreterLexerErrorListener(eventSink));\r\n                this.tokenStream = new CommonTokenStream(this.lexer);\r\n            }\r\n\r\n            if (this.parserData) {\r\n                this.parser = new GrammarParserInterpreter(eventSink, predicateFunction, this.contexts[0],\r\n                    this.parserData, this.tokenStream);\r\n                this.parser.buildParseTree = true;\r\n                this.parser.removeErrorListeners();\r\n                this.parser.addErrorListener(new InterpreterParserErrorListener(eventSink));\r\n            }\r\n        }\r\n    }\r\n\r\n    public get isValid(): boolean {\r\n        return this.contexts.find((context) => { return !context.isInterpreterDataLoaded; }) === undefined;\r\n    }\r\n\r\n    public start(startRuleIndex: number, input: string, noDebug: boolean): void {\r\n        const stream = CharStreams.fromString(input);\r\n        this.lexer.inputStream = stream;\r\n\r\n        if (!this.parser) {\r\n            this.sendEvent(\"end\");\r\n\r\n            return;\r\n        }\r\n\r\n        this.parseTree = undefined;\r\n        this.parser.breakPoints.clear();\r\n\r\n        if (noDebug) {\r\n            this.parser.setProfile(false).then(() => {\r\n                if (this.parser) {\r\n                    this.parseTree = this.parser.parse(startRuleIndex);\r\n                }\r\n\r\n                this.sendEvent(\"end\");\r\n            }).catch((reason) => {\r\n                this.sendEvent(\"error\", reason);\r\n            });\r\n        } else {\r\n            this.breakPoints.forEach((breakPoint) => {\r\n                this.validateBreakPoint(breakPoint);\r\n            });\r\n\r\n            this.parseTree = this.parser.start(startRuleIndex);\r\n            this.continue();\r\n        }\r\n    }\r\n\r\n    public continue(): void {\r\n        if (this.parser) {\r\n            this.parseTree = this.parser.continue(RunMode.Normal);\r\n        }\r\n    }\r\n\r\n    public stepIn(): void {\r\n        if (this.parser) {\r\n            this.parseTree = this.parser.continue(RunMode.StepIn);\r\n        }\r\n    }\r\n\r\n    public stepOut(): void {\r\n        if (this.parser) {\r\n            this.parseTree = this.parser.continue(RunMode.StepOut);\r\n        }\r\n    }\r\n\r\n    public stepOver(): void {\r\n        if (this.parser) {\r\n            this.parseTree = this.parser.continue(RunMode.StepOver);\r\n        }\r\n    }\r\n\r\n    public stop(): void {\r\n        // no-op\r\n    }\r\n\r\n    public pause(): void {\r\n        // no-op\r\n    }\r\n\r\n    public clearBreakPoints(): void {\r\n        this.breakPoints.clear();\r\n        if (this.parser) {\r\n            this.parser.breakPoints.clear();\r\n        }\r\n    }\r\n\r\n    public addBreakPoint(path: string, line: number): IGrammarBreakPoint {\r\n        const breakPoint: IGrammarBreakPoint = {\r\n            source: path,\r\n            validated: false,\r\n            line,\r\n            id: this.nextBreakPointId++,\r\n        };\r\n        this.breakPoints.set(breakPoint.id, breakPoint);\r\n\r\n        void this.validateBreakPoint(breakPoint);\r\n\r\n        return breakPoint;\r\n    }\r\n\r\n    /**\r\n     * @returns the list of tokens in the test input.\r\n     */\r\n    public get tokenList(): CommonToken[] {\r\n        this.tokenStream.fill();\r\n\r\n        return this.tokenStream.getTokens() as CommonToken[];\r\n    }\r\n\r\n    public get errorCount(): number {\r\n        if (!this.parser) {\r\n            return 0;\r\n        }\r\n\r\n        return this.parser.numberOfSyntaxErrors;\r\n    }\r\n\r\n    public get inputSize(): number {\r\n        if (!this.parser) {\r\n            return 0;\r\n        }\r\n\r\n        return this.parser.inputStream.size;\r\n    }\r\n\r\n    public ruleNameFromIndex(ruleIndex: number): string | undefined {\r\n        if (!this.parser) {\r\n            return;\r\n        }\r\n        if (ruleIndex < 0 || ruleIndex >= this.parser.ruleNames.length) {\r\n            return;\r\n        }\r\n\r\n        return this.parser.ruleNames[ruleIndex];\r\n    }\r\n\r\n    public ruleIndexFromName(ruleName: string): number {\r\n        if (!this.parser) {\r\n            return -1;\r\n        }\r\n\r\n        return this.parser.ruleNames.findIndex((entry) => {\r\n            return entry === ruleName;\r\n        });\r\n    }\r\n\r\n    public get currentParseTree(): IParseTreeNode | undefined {\r\n        if (!this.parseTree) {\r\n            return undefined;\r\n        }\r\n\r\n        const aa = this.parseContextToNode(this.parseTree);\r\n\r\n        return aa;\r\n    }\r\n\r\n    public get currentStackTrace(): IGrammarStackFrame[] {\r\n        const result: IGrammarStackFrame[] = [];\r\n        if (this.parser) {\r\n            for (const frame of this.parser.callStack) {\r\n                const externalFrame = <IGrammarStackFrame>{\r\n                    name: frame.name,\r\n                    source: frame.source,\r\n                    next: [],\r\n                };\r\n\r\n                for (const next of frame.next) {\r\n                    if (next.context instanceof ParserRuleContext) {\r\n                        const start = next.context.start;\r\n                        const stop = next.context.stop;\r\n                        externalFrame.next.push({\r\n                            start: { column: start.charPositionInLine, row: start.line },\r\n                            end: { column: stop ? stop.charPositionInLine : 0, row: stop ? stop.line : start.line },\r\n                        });\r\n                    } else {\r\n                        const terminal = (next.context as TerminalNode).symbol;\r\n                        const length = terminal.stopIndex - terminal.startIndex + 1;\r\n                        externalFrame.next.push({\r\n                            start: { column: terminal.charPositionInLine, row: terminal.line },\r\n                            end: { column: terminal.charPositionInLine + length, row: terminal.line },\r\n                        });\r\n                    }\r\n                }\r\n                result.push(externalFrame);\r\n            }\r\n        }\r\n\r\n        return result.reverse();\r\n    }\r\n\r\n    public get currentTokenIndex(): number {\r\n        return this.tokenStream.index;\r\n    }\r\n\r\n    /**\r\n     * Return a string describing the stack frame at the given index.\r\n     * Note: we return the stack trace reverted, so we have to account for that here.\r\n     *\r\n     * @param index The index of the entry to return info for.\r\n     *\r\n     * @returns A string representation of the stack frame.\r\n     */\r\n    public getStackInfo(index: number): string {\r\n        if (!this.parser || index < 0 || index > this.parser.callStack.length) {\r\n            return \"Invalid Stack Frame\";\r\n        }\r\n        const frame = this.parser.callStack[this.parser.callStack.length - index - 1];\r\n\r\n        return \"Context \" + frame.name;\r\n    }\r\n\r\n    public async getVariables(index: number): Promise<Array<[string, string]>> {\r\n        const result: Array<[string, string]> = [];\r\n        if (!this.parser || index < 0 || index > this.parser.callStack.length) {\r\n            return [];\r\n        }\r\n        const frame = this.parser.callStack[this.parser.callStack.length - index - 1];\r\n\r\n        // There's always at least one current symbol in the given frame.\r\n        // Go up the parent chain to find the rule symbol which contains this current symbol.\r\n        let run = frame.current[0];\r\n        while (run && !(run instanceof RuleSymbol)) {\r\n            run = run.parent as ScopedSymbol;\r\n        }\r\n\r\n        if (run) {\r\n            // Walk up the parent chain of the current parser rule context to find the\r\n            // corresponding context for our stack frame.\r\n            let context = this.parser.context;\r\n            while (index-- > 0) {\r\n                context = context.parent!;\r\n            }\r\n\r\n            const parent = run as ScopedSymbol;\r\n            const symbols = await parent.getNestedSymbolsOfType(VariableSymbol);\r\n\r\n            // Coalesce variable names and look up the value.\r\n            const variables: Set<string> = new Set<string>();\r\n            for (const symbol of symbols) {\r\n                variables.add(symbol.name);\r\n            }\r\n            /*\r\n            for (const variable of variables) {\r\n                // TODO: there are no variables stored in the interpreter.\r\n                // Possible solution: handle that manually with the help of the symbol table.\r\n            }*/\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    public tokenTypeName(token: CommonToken): string {\r\n        // For implicit tokens we use the same approach like ANTLR4 does for the naming.\r\n        return this.lexer.vocabulary.getSymbolicName(token.type) || `T__${token.type}`;\r\n    }\r\n\r\n    public get recognizer(): Lexer {\r\n        return this.lexer;\r\n    }\r\n\r\n    private sendEvent(event: string, ...args: unknown[]) {\r\n        setImmediate((_) => {\r\n            this.emit(event, ...args);\r\n        });\r\n    }\r\n\r\n    private parseContextToNode(tree: ParseTree): IParseTreeNode {\r\n        if (tree instanceof ParserRuleContext) {\r\n            const children: IParseTreeNode[] = [];\r\n            if (tree.children) {\r\n                for (const child of tree.children) {\r\n                    if ((child instanceof TerminalNode) && (child.symbol.type === Token.EOF)) {\r\n                        continue;\r\n                    }\r\n                    children.push(this.parseContextToNode(child));\r\n                }\r\n            }\r\n\r\n            return {\r\n                type: \"rule\",\r\n                ruleIndex: tree.ruleIndex,\r\n                name: this.parser!.ruleNames[tree.ruleIndex],\r\n                start: this.convertToken(tree.start as CommonToken),\r\n                stop: this.convertToken(tree.stop as CommonToken),\r\n                id: this.computeHash(tree),\r\n                range: {\r\n                    startIndex: tree.sourceInterval.a,\r\n                    stopIndex: tree.sourceInterval.b,\r\n                    length: tree.sourceInterval.length,\r\n                },\r\n                children,\r\n            };\r\n        } else if (tree instanceof ErrorNode) {\r\n            const symbol = this.convertToken(tree.symbol as CommonToken);\r\n\r\n            return {\r\n                type: \"error\",\r\n                symbol,\r\n                id: this.computeHash(tree.symbol as CommonToken),\r\n                name: symbol ? symbol.name : \"<no name>\",\r\n                children: [],\r\n            };\r\n        } else {\r\n            // Must be a terminal node then.\r\n            const token = (tree as TerminalNode).symbol as CommonToken;\r\n            const symbol = this.convertToken((tree as TerminalNode).symbol as CommonToken);\r\n\r\n            return {\r\n                type: \"terminal\",\r\n                symbol,\r\n                id: this.computeHash(token),\r\n                name: symbol ? symbol.name : \"<no name>\",\r\n                children: [],\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A simple hash function for rule contexts and common tokens.\r\n     *\r\n     * @param input The value to create the hash for.\r\n     *\r\n     * @returns The computed hash.\r\n     */\r\n    private computeHash(input: ParserRuleContext | CommonToken): number {\r\n        let hash = 0;\r\n        if (input instanceof ParserRuleContext) {\r\n            // Seed with a value that for sure goes beyond any possible token index.\r\n            hash = (31 * hash) + input.start.inputStream!.size;\r\n            if (input.parent) {\r\n                // Multiple invocations of the same rule which matches nothing appear as nodes in the parse tree with\r\n                // the same start token, so we need an additional property to tell them apart: the child index.\r\n                hash = (31 * hash) + input.parent.children!.findIndex((element) => {\r\n                    return element === input;\r\n                });\r\n            }\r\n            hash = (31 * hash) + input.depth();\r\n            hash = (31 * hash) + input.ruleIndex;\r\n            hash = (31 * hash) + input.start.type >>> 0;\r\n            hash = (31 * hash) + input.start.tokenIndex >>> 0;\r\n            hash = (31 * hash) + input.start.channel >>> 0;\r\n        } else if (input instanceof CommonToken) {\r\n            hash = (31 * hash) + input.tokenIndex >>> 0;\r\n            hash = (31 * hash) + input.type >>> 0;\r\n            hash = (31 * hash) + input.channel >>> 0;\r\n        }\r\n\r\n        return hash;\r\n    }\r\n\r\n    private convertToken(token: CommonToken): ILexerToken | undefined {\r\n        if (!token) {\r\n            return;\r\n        }\r\n\r\n        return {\r\n            text: token.text ? token.text : \"\",\r\n            type: token.type,\r\n            name: this.tokenTypeName(token),\r\n            line: token.line,\r\n            offset: token.charPositionInLine,\r\n            channel: token.channel,\r\n            tokenIndex: token.tokenIndex,\r\n            startIndex: token.startIndex,\r\n            stopIndex: token.stopIndex,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Validates a breakpoint's position.\r\n     * Breakpoints are aligned either to the first or the last rule line, hence the debugger\r\n     * can only break on enter or on exit of the rule.\r\n     *\r\n     * @param breakPoint The breakpoint to validate.\r\n     */\r\n    private validateBreakPoint(breakPoint: IGrammarBreakPoint) {\r\n        const context = this.contexts.find((entry) => {\r\n            return entry.fileName === breakPoint.source;\r\n        });\r\n\r\n        if (!context || !this.parserData) {\r\n            return;\r\n        }\r\n\r\n        // Assuming here a rule always starts in column 0.\r\n        const rule = context.enclosingSymbolAtPosition(0, breakPoint.line, true);\r\n        if (rule) {\r\n            breakPoint.validated = true;\r\n\r\n            // Main and sub grammars are combined in the ATN (and interpreter data), which means\r\n            // the rule index must be looked up in the main context, regardless of the source file.\r\n            const index = this.ruleIndexFromName(rule.name);\r\n            if (breakPoint.line === rule.definition!.range.end.row) {\r\n                // If the breakpoint's line is on the rule's end (the semicolon) then\r\n                // use the rule's end state for break.\r\n                const stop = this.parserData.atn.ruleToStopState[index];\r\n                this.parser!.breakPoints.add(stop);\r\n            } else {\r\n                const start = this.parserData.atn.ruleToStartState[index];\r\n                this.parser!.breakPoints.add(start);\r\n                breakPoint.line = rule.definition!.range.start.row;\r\n            }\r\n\r\n            this.sendEvent(\"breakpointValidated\", breakPoint);\r\n        }\r\n    }\r\n}\r\n"]}