{"version":3,"file":"SourceContext.js","sourceRoot":"","sources":["../../../src/backend/SourceContext.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\n// This file contains the handling for a single source file. It provides syntactic and semantic\r\n// information, symbol lookups and more.\r\n\r\nimport * as child_process from \"child_process\";\r\nimport * as path from \"path\";\r\nimport * as fs from \"fs\";\r\nimport * as vm from \"vm\";\r\n\r\nimport {\r\n    CharStreams, CommonTokenStream, BailErrorStrategy, DefaultErrorStrategy, Token, RuleContext, ParserRuleContext,\r\n    Vocabulary,\r\n} from \"antlr4ts\";\r\nimport {\r\n    PredictionMode, ATNState, RuleTransition, TransitionType, ATNStateType, RuleStartState, ActionTransition,\r\n    PredicateTransition, PrecedencePredicateTransition,\r\n} from \"antlr4ts/atn\";\r\nimport { ParseCancellationException, IntervalSet, Interval } from \"antlr4ts/misc\";\r\nimport { ParseTreeWalker, TerminalNode, ParseTree } from \"antlr4ts/tree\";\r\n\r\nimport { CodeCompletionCore, BaseSymbol, LiteralSymbol } from \"antlr4-c3\";\r\n\r\nimport {\r\n    ANTLRv4Parser, ParserRuleSpecContext, LexerRuleSpecContext, GrammarSpecContext, OptionsSpecContext, ModeSpecContext,\r\n} from \"../parser/ANTLRv4Parser\";\r\nimport { ANTLRv4Lexer } from \"../parser/ANTLRv4Lexer\";\r\n\r\nimport {\r\n    ISymbolInfo, IDiagnosticEntry, DiagnosticType, IReferenceNode, IGenerationOptions,\r\n    ISentenceGenerationOptions, IFormattingOptions, IDefinition, IContextDetails, PredicateFunction,\r\n    CodeActionType, SymbolKind, GrammarType,\r\n} from \"./types\";\r\n\r\nimport { ContextErrorListener } from \"./ContextErrorListener\";\r\nimport { ContextLexerErrorListener } from \"./ContextLexerErrorListener\";\r\n\r\nimport { DetailsListener } from \"./DetailsListener\";\r\nimport { SemanticListener } from \"./SemanticListener\";\r\nimport { RuleVisitor } from \"./RuleVisitor\";\r\nimport { InterpreterDataReader, IInterpreterData } from \"./InterpreterDataReader\";\r\nimport { ErrorParser } from \"./ErrorParser\";\r\n\r\nimport {\r\n    ContextSymbolTable, BuiltInChannelSymbol, BuiltInTokenSymbol, BuiltInModeSymbol, RuleSymbol,\r\n    VirtualTokenSymbol, FragmentTokenSymbol, TokenSymbol, RuleReferenceSymbol, TokenReferenceSymbol, ImportSymbol,\r\n    LexerModeSymbol, TokenChannelSymbol, OperatorSymbol, ArgumentsSymbol, ExceptionActionSymbol,\r\n    FinallyActionSymbol, LexerActionSymbol, LexerPredicateSymbol, ParserActionSymbol, ParserPredicateSymbol,\r\n    LexerCommandSymbol, TerminalSymbol, GlobalNamedActionSymbol, LocalNamedActionSymbol,\r\n} from \"./ContextSymbolTable\";\r\n\r\nimport { SentenceGenerator } from \"./SentenceGenerator\";\r\nimport { GrammarFormatter } from \"./Formatter\";\r\nimport {\r\n    GrammarLexerInterpreter, InterpreterLexerErrorListener, GrammarParserInterpreter, InterpreterParserErrorListener,\r\n} from \"./GrammarInterpreters\";\r\nimport { printableUnicodePoints } from \"./Unicode\";\r\nimport { BackendUtils } from \"./BackendUtils\";\r\n\r\nimport { IATNGraphData, IATNLink, IATNNode } from \"../webview-scripts/types\";\r\n\r\n// One source context per file. Source contexts can reference each other (e.g. for symbol lookups).\r\nexport class SourceContext {\r\n    private static globalSymbols = new ContextSymbolTable(\"Global Symbols\", { allowDuplicateSymbols: false });\r\n    private static symbolToKindMap: Map<new () => BaseSymbol, SymbolKind> = new Map([\r\n        [GlobalNamedActionSymbol, SymbolKind.GlobalNamedAction],\r\n        [LocalNamedActionSymbol, SymbolKind.LocalNamedAction],\r\n        [ImportSymbol, SymbolKind.Import],\r\n        [BuiltInTokenSymbol, SymbolKind.BuiltInLexerToken],\r\n        [VirtualTokenSymbol, SymbolKind.VirtualLexerToken],\r\n        [FragmentTokenSymbol, SymbolKind.FragmentLexerToken],\r\n        [TokenSymbol, SymbolKind.LexerRule],\r\n        [BuiltInModeSymbol, SymbolKind.BuiltInMode],\r\n        [LexerModeSymbol, SymbolKind.LexerMode],\r\n        [BuiltInChannelSymbol, SymbolKind.BuiltInChannel],\r\n        [TokenChannelSymbol, SymbolKind.TokenChannel],\r\n        [RuleSymbol, SymbolKind.ParserRule],\r\n        [OperatorSymbol, SymbolKind.Operator],\r\n        [TerminalSymbol, SymbolKind.Terminal],\r\n        [TokenReferenceSymbol, SymbolKind.TokenReference],\r\n        [RuleReferenceSymbol, SymbolKind.RuleReference],\r\n        [LexerCommandSymbol, SymbolKind.LexerCommand],\r\n\r\n        [ExceptionActionSymbol, SymbolKind.ExceptionAction],\r\n        [FinallyActionSymbol, SymbolKind.FinallyAction],\r\n        [ParserActionSymbol, SymbolKind.ParserAction],\r\n        [LexerActionSymbol, SymbolKind.LexerAction],\r\n        [ParserPredicateSymbol, SymbolKind.ParserPredicate],\r\n        [LexerPredicateSymbol, SymbolKind.LexerPredicate],\r\n        [ArgumentsSymbol, SymbolKind.Arguments],\r\n    ]);\r\n\r\n    private static printableChars: IntervalSet;\r\n\r\n    public symbolTable: ContextSymbolTable;\r\n    public sourceId: string;\r\n    public info: IContextDetails = {\r\n        type: GrammarType.Unknown,\r\n        unreferencedRules: [],\r\n        imports: [],\r\n    };\r\n\r\n    /* @internal */\r\n    public diagnostics: IDiagnosticEntry[] = [];\r\n\r\n    // eslint-disable-next-line no-use-before-define\r\n    private references: SourceContext[] = []; // Contexts referencing us.\r\n\r\n    // Result related fields.\r\n    //private diagnostics: DiagnosticEntry[] = [];\r\n    private rrdScripts: Map<string, string>;\r\n    private semanticAnalysisDone = false; // Includes determining reference counts.\r\n\r\n    // Grammar parsing infrastructure.\r\n    private tokenStream: CommonTokenStream;\r\n    private parser: ANTLRv4Parser | undefined;\r\n    private errorListener: ContextErrorListener = new ContextErrorListener(this.diagnostics);\r\n    private lexerErrorListener: ContextLexerErrorListener = new ContextLexerErrorListener(this.diagnostics);\r\n\r\n    // Grammar data.\r\n    private grammarLexerData: IInterpreterData | undefined;\r\n    private grammarLexerRuleMap = new Map<string, number>(); // A mapping from lexer rule names to their index.\r\n    private grammarParserData: IInterpreterData | undefined;\r\n    private grammarParserRuleMap = new Map<string, number>(); // A mapping from parser rule names to their index.\r\n\r\n    private tree: GrammarSpecContext | undefined; // The root context from the last parse run.\r\n\r\n    public constructor(public fileName: string, private extensionDir: string) {\r\n        this.sourceId = path.basename(fileName, path.extname(fileName));\r\n        this.symbolTable = new ContextSymbolTable(this.sourceId, { allowDuplicateSymbols: true }, this);\r\n\r\n        // Initialize static global symbol table, if not yet done.\r\n        const eof = SourceContext.globalSymbols.resolve(\"EOF\");\r\n        eof.then((value) => {\r\n            if (!value) {\r\n                SourceContext.globalSymbols.addNewSymbolOfType(BuiltInChannelSymbol, undefined,\r\n                    \"DEFAULT_TOKEN_CHANNEL\");\r\n                SourceContext.globalSymbols.addNewSymbolOfType(BuiltInChannelSymbol, undefined, \"HIDDEN\");\r\n                SourceContext.globalSymbols.addNewSymbolOfType(BuiltInTokenSymbol, undefined, \"EOF\");\r\n                SourceContext.globalSymbols.addNewSymbolOfType(BuiltInModeSymbol, undefined, \"DEFAULT_MODE\");\r\n            }\r\n        }).catch(() => {\r\n            // ignore\r\n        });\r\n    }\r\n\r\n    public get isInterpreterDataLoaded(): boolean {\r\n        return this.grammarLexerData !== undefined || this.grammarParserData !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Internal function to provide interpreter data to certain internal classes (e.g. the debugger).\r\n     *\r\n     * @returns Lexer and parser interpreter data for use outside of this context.\r\n     */\r\n    public get interpreterData(): [IInterpreterData | undefined, IInterpreterData | undefined] {\r\n        return [this.grammarLexerData, this.grammarParserData];\r\n    }\r\n\r\n    public get hasErrors(): boolean {\r\n        for (const diagnostic of this.diagnostics) {\r\n            if (diagnostic.type === DiagnosticType.Error) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static getKindFromSymbol(symbol: BaseSymbol): SymbolKind {\r\n        if (symbol.name === \"tokenVocab\") {\r\n            return SymbolKind.TokenVocab;\r\n        }\r\n\r\n        return this.symbolToKindMap.get(symbol.constructor as typeof BaseSymbol) || SymbolKind.Unknown;\r\n    }\r\n\r\n    /**\r\n     * @param ctx The context to get info for.\r\n     * @param keepQuotes A flag indicating if quotes should be kept if there are any around the context's text.\r\n     *\r\n     * @returns The definition info for the given rule context.\r\n     */\r\n    public static definitionForContext(ctx: ParseTree | undefined, keepQuotes: boolean): IDefinition | undefined {\r\n        if (!ctx) {\r\n            return undefined;\r\n        }\r\n\r\n        const result: IDefinition = {\r\n            text: \"\",\r\n            range: {\r\n                start: { column: 0, row: 0 },\r\n                end: { column: 0, row: 0 },\r\n            },\r\n        };\r\n\r\n        if (ctx instanceof ParserRuleContext) {\r\n            const range = <Interval>{ a: ctx.start.startIndex, b: ctx.stop!.stopIndex };\r\n\r\n            result.range.start.column = ctx.start.charPositionInLine;\r\n            result.range.start.row = ctx.start.line;\r\n            result.range.end.column = ctx.stop!.charPositionInLine;\r\n            result.range.end.row = ctx.stop!.line;\r\n\r\n            // For mode definitions we only need the init line, not all the lexer rules following it.\r\n            if (ctx.ruleIndex === ANTLRv4Parser.RULE_modeSpec) {\r\n                const modeSpec = ctx as ModeSpecContext;\r\n                range.b = modeSpec.SEMI().symbol.stopIndex;\r\n                result.range.end.column = modeSpec.SEMI().symbol.charPositionInLine;\r\n                result.range.end.row = modeSpec.SEMI().symbol.line;\r\n            } else if (ctx.ruleIndex === ANTLRv4Parser.RULE_grammarSpec) {\r\n                // Similar for entire grammars. We only need the introducer line here.\r\n                const grammarSpec: GrammarSpecContext = <GrammarSpecContext>ctx;\r\n                range.b = grammarSpec.SEMI().symbol.stopIndex;\r\n                result.range.end.column = grammarSpec.SEMI().symbol.charPositionInLine;\r\n                result.range.end.row = grammarSpec.SEMI().symbol.line;\r\n\r\n                range.a = grammarSpec.grammarType().start.startIndex;\r\n                result.range.start.column = grammarSpec.grammarType().start.charPositionInLine;\r\n                result.range.start.row = grammarSpec.grammarType().start.line;\r\n            }\r\n\r\n            if (ctx.start.tokenSource?.inputStream) {\r\n                const stream = ctx.start.tokenSource.inputStream;\r\n                try {\r\n                    result.text = stream.getText(range);\r\n                } catch (e) {\r\n                    // The method getText uses an unreliable JS String API which can throw on larger texts.\r\n                    // In this case we cannot return the text of the given context.\r\n                    // A context with such a large size is probably an error case anyway (unfinished multi line comment\r\n                    // or unfinished action).\r\n                }\r\n            }\r\n        } else if (ctx instanceof TerminalNode) {\r\n            result.text = ctx.text;\r\n\r\n            result.range.start.column = ctx.symbol.charPositionInLine;\r\n            result.range.start.row = ctx.symbol.line;\r\n            result.range.end.column = ctx.symbol.charPositionInLine + result.text.length;\r\n            result.range.end.row = ctx.symbol.line;\r\n        }\r\n\r\n        if (keepQuotes || result.text.length < 2) {\r\n            return result;\r\n        }\r\n\r\n        const quoteChar = result.text[0];\r\n        if ((quoteChar === '\"' || quoteChar === \"`\" || quoteChar === \"'\")\r\n            && quoteChar === result.text[result.text.length - 1]) {\r\n            result.text = result.text.substr(1, result.text.length - 2);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    public symbolAtPosition(column: number, row: number, limitToChildren: boolean): ISymbolInfo | undefined {\r\n\r\n        const terminal = BackendUtils.parseTreeFromPosition(this.tree!, column, row);\r\n        if (!terminal || !(terminal instanceof TerminalNode)) {\r\n            return undefined;\r\n        }\r\n\r\n        // If limitToChildren is set we only want to show info for symbols in specific contexts.\r\n        // These are contexts which are used as subrules in rule definitions.\r\n        if (!limitToChildren) {\r\n            return this.getSymbolInfo(terminal.text);\r\n        }\r\n\r\n        let parent = (terminal.parent as RuleContext);\r\n        if (parent.ruleIndex === ANTLRv4Parser.RULE_identifier) {\r\n            parent = (parent.parent as RuleContext);\r\n        }\r\n\r\n        switch (parent.ruleIndex) {\r\n            case ANTLRv4Parser.RULE_ruleref:\r\n            case ANTLRv4Parser.RULE_terminalRule: {\r\n                let symbol = this.symbolTable.symbolContainingContext(terminal);\r\n                if (symbol) {\r\n                    // This is only the reference to a symbol. See if that symbol exists actually.\r\n                    symbol = this.resolveSymbol(symbol.name);\r\n                    if (symbol) {\r\n                        return this.getSymbolInfo(symbol);\r\n                    }\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case ANTLRv4Parser.RULE_actionBlock:\r\n            case ANTLRv4Parser.RULE_ruleAction:\r\n            case ANTLRv4Parser.RULE_lexerCommandExpr:\r\n            case ANTLRv4Parser.RULE_optionValue:\r\n            case ANTLRv4Parser.RULE_delegateGrammar:\r\n            case ANTLRv4Parser.RULE_modeSpec:\r\n            case ANTLRv4Parser.RULE_setElement: {\r\n                const symbol = this.symbolTable.symbolContainingContext(terminal);\r\n                if (symbol) {\r\n                    return this.getSymbolInfo(symbol);\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case ANTLRv4Parser.RULE_lexerCommand:\r\n            case ANTLRv4Parser.RULE_lexerCommandName: {\r\n                const symbol = this.symbolTable.symbolContainingContext(terminal);\r\n                if (symbol) {\r\n                    return this.getSymbolInfo(symbol);\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            default: {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns the symbol at the given position or one of its outer scopes.\r\n     *\r\n     * @param column The position within a source line.\r\n     * @param row The source line index.\r\n     * @param ruleScope If true find the enclosing rule (if any) and return it's range, instead of the directly\r\n     *                  enclosing scope.\r\n     *\r\n     * @returns The symbol at the given position (if there's any).\r\n     */\r\n    public enclosingSymbolAtPosition(column: number, row: number, ruleScope: boolean): ISymbolInfo | undefined {\r\n        let context = BackendUtils.parseTreeFromPosition(this.tree!, column, row);\r\n        if (!context) {\r\n            return undefined;\r\n        }\r\n\r\n        if (context instanceof TerminalNode) {\r\n            context = context.parent;\r\n        }\r\n\r\n        if (ruleScope) {\r\n            let run = context;\r\n            while (run\r\n                && !(run instanceof ParserRuleSpecContext)\r\n                && !(run instanceof OptionsSpecContext)\r\n                && !(run instanceof LexerRuleSpecContext)) {\r\n                run = run.parent;\r\n            }\r\n            if (run) {\r\n                context = run;\r\n            }\r\n        }\r\n\r\n        if (context) {\r\n            const symbol = this.symbolTable.symbolWithContextSync(context);\r\n            if (symbol) {\r\n                return this.symbolTable.getSymbolInfo(symbol);\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    public listTopLevelSymbols(includeDependencies: boolean): ISymbolInfo[] {\r\n        return this.symbolTable.listTopLevelSymbols(includeDependencies);\r\n    }\r\n\r\n    public getVocabulary(): Vocabulary | undefined {\r\n        if (this.grammarLexerData) {\r\n            return this.grammarLexerData.vocabulary;\r\n        }\r\n    }\r\n\r\n    public getRuleList(): string[] | undefined {\r\n        if (this.grammarParserData) {\r\n            return this.grammarParserData.ruleNames;\r\n        }\r\n    }\r\n\r\n    public getChannels(): string[] | undefined {\r\n        if (this.grammarLexerData) {\r\n            return this.grammarLexerData.channels;\r\n        }\r\n    }\r\n\r\n    public getModes(): string[] | undefined {\r\n        if (this.grammarLexerData) {\r\n            return this.grammarLexerData.modes;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a list of actions of a specific kind from the context's symbol table.\r\n     *\r\n     * @param type The type of list to return.\r\n     *\r\n     * @returns The list of actions.\r\n     */\r\n    public listActions(type: CodeActionType): ISymbolInfo[] {\r\n        return this.symbolTable.listActions(type);\r\n    }\r\n\r\n    /**\r\n     * Returns numbers of registered actions of each kind.\r\n     *\r\n     * @returns An object containing the individual action counts.\r\n     */\r\n    public getActionCounts(): Map<CodeActionType, number> {\r\n        return this.symbolTable.getActionCounts();\r\n    }\r\n\r\n    public async getCodeCompletionCandidates(column: number, row: number): Promise<ISymbolInfo[]> {\r\n        if (!this.parser) {\r\n            return [];\r\n        }\r\n\r\n        const core = new CodeCompletionCore(this.parser);\r\n        core.showResult = false;\r\n        core.ignoredTokens = new Set([\r\n            ANTLRv4Lexer.TOKEN_REF,\r\n            ANTLRv4Lexer.RULE_REF,\r\n            ANTLRv4Lexer.LEXER_CHAR_SET,\r\n            ANTLRv4Lexer.DOC_COMMENT,\r\n            ANTLRv4Lexer.BLOCK_COMMENT,\r\n            ANTLRv4Lexer.LINE_COMMENT,\r\n            ANTLRv4Lexer.INT,\r\n            ANTLRv4Lexer.STRING_LITERAL,\r\n            ANTLRv4Lexer.UNTERMINATED_STRING_LITERAL,\r\n            ANTLRv4Lexer.MODE,\r\n            ANTLRv4Lexer.COLON,\r\n            ANTLRv4Lexer.COLONCOLON,\r\n            ANTLRv4Lexer.COMMA,\r\n            ANTLRv4Lexer.SEMI,\r\n            ANTLRv4Lexer.LPAREN,\r\n            ANTLRv4Lexer.RPAREN,\r\n            ANTLRv4Lexer.LBRACE,\r\n            ANTLRv4Lexer.RBRACE,\r\n            //ANTLRv4Lexer.RARROW,\r\n            //ANTLRv4Lexer.LT,\r\n            ANTLRv4Lexer.GT,\r\n            //ANTLRv4Lexer.ASSIGN,\r\n            //ANTLRv4Lexer.QUESTION,\r\n            //ANTLRv4Lexer.STAR,\r\n            //ANTLRv4Lexer.PLUS_ASSIGN,\r\n            //ANTLRv4Lexer.PLUS,\r\n            //ANTLRv4Lexer.OR,\r\n            ANTLRv4Lexer.DOLLAR,\r\n            ANTLRv4Lexer.RANGE,\r\n            ANTLRv4Lexer.DOT,\r\n            ANTLRv4Lexer.AT,\r\n            ANTLRv4Lexer.POUND,\r\n            ANTLRv4Lexer.NOT,\r\n            ANTLRv4Lexer.ID,\r\n            ANTLRv4Lexer.WS,\r\n            ANTLRv4Lexer.END_ARGUMENT,\r\n            ANTLRv4Lexer.UNTERMINATED_ARGUMENT,\r\n            ANTLRv4Lexer.ARGUMENT_CONTENT,\r\n            ANTLRv4Lexer.END_ACTION,\r\n            ANTLRv4Lexer.UNTERMINATED_ACTION,\r\n            ANTLRv4Lexer.ACTION_CONTENT,\r\n            ANTLRv4Lexer.UNTERMINATED_CHAR_SET,\r\n            ANTLRv4Lexer.EOF,\r\n            -2, // TODO: Erroneously inserted. Needs fix in antlr4-c3.\r\n        ]);\r\n\r\n        core.preferredRules = new Set([\r\n            ANTLRv4Parser.RULE_argActionBlock,\r\n            ANTLRv4Parser.RULE_actionBlock,\r\n            ANTLRv4Parser.RULE_terminalRule,\r\n            ANTLRv4Parser.RULE_lexerCommandName,\r\n            ANTLRv4Parser.RULE_identifier,\r\n            ANTLRv4Parser.RULE_ruleref,\r\n        ]);\r\n\r\n        // Search the token index which covers our caret position.\r\n        let index: number;\r\n        this.tokenStream.fill();\r\n        for (index = 0; ; ++index) {\r\n            const token = this.tokenStream.get(index);\r\n            //console.log(token.toString());\r\n            if (token.type === Token.EOF || token.line > row) {\r\n                break;\r\n            }\r\n            if (token.line < row) {\r\n                continue;\r\n            }\r\n            const length = token.text ? token.text.length : 0;\r\n            if ((token.charPositionInLine + length) >= column) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        const candidates = core.collectCandidates(index);\r\n        const result: ISymbolInfo[] = [];\r\n\r\n        candidates.tokens.forEach((following: number[], type: number) => {\r\n            switch (type) {\r\n                case ANTLRv4Lexer.RARROW: {\r\n                    result.push({\r\n                        kind: SymbolKind.Operator,\r\n                        name: \"->\",\r\n                        description: \"Lexer action introducer\",\r\n                        source: this.fileName,\r\n                    });\r\n\r\n                    break;\r\n                }\r\n                case ANTLRv4Lexer.LT: {\r\n                    result.push({\r\n                        kind: SymbolKind.Operator,\r\n                        name: \"< key = value >\",\r\n                        description: \"Rule element option\",\r\n                        source: this.fileName,\r\n                    });\r\n\r\n                    break;\r\n                }\r\n                case ANTLRv4Lexer.ASSIGN: {\r\n                    result.push({\r\n                        kind: SymbolKind.Operator,\r\n                        name: \"=\",\r\n                        description: \"Variable assignment\",\r\n                        source: this.fileName,\r\n                    });\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.QUESTION: {\r\n                    result.push({\r\n                        kind: SymbolKind.Operator,\r\n                        name: \"?\",\r\n                        description: \"Zero or one repetition operator\",\r\n                        source: this.fileName,\r\n                    });\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.STAR: {\r\n                    result.push({\r\n                        kind: SymbolKind.Operator,\r\n                        name: \"*\",\r\n                        description: \"Zero or more repetition operator\",\r\n                        source: this.fileName,\r\n                    });\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.PLUS_ASSIGN: {\r\n                    result.push({\r\n                        kind: SymbolKind.Operator,\r\n                        name: \"+=\",\r\n                        description: \"Variable list addition\",\r\n                        source: this.fileName,\r\n                    });\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.PLUS: {\r\n                    result.push({\r\n                        kind: SymbolKind.Operator,\r\n                        name: \"+\",\r\n                        description: \"One or more repetition operator\",\r\n                        source: this.fileName,\r\n                    });\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.OR: {\r\n                    result.push({\r\n                        kind: SymbolKind.Operator,\r\n                        name: \"|\",\r\n                        description: \"Rule alt separator\",\r\n                        source: this.fileName,\r\n                    });\r\n                    break;\r\n                }\r\n\r\n                default: {\r\n                    const value = this.parser!.vocabulary.getDisplayName(type);\r\n                    result.push({\r\n                        kind: SymbolKind.Keyword,\r\n                        name: value[0] === \"'\" ? value.substr(1, value.length - 2) : value, // Remove quotes.\r\n                        source: this.fileName,\r\n                    });\r\n\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n\r\n        const promises: Array<Promise<BaseSymbol[] | undefined>> = [];\r\n        candidates.rules.forEach((candidateRule, key) => {\r\n            switch (key) {\r\n                case ANTLRv4Parser.RULE_argActionBlock: {\r\n                    result.push({\r\n                        kind: SymbolKind.Arguments,\r\n                        name: \"[ argument action code ]\",\r\n                        source: this.fileName,\r\n                        definition: undefined,\r\n                        description: undefined,\r\n                    });\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_actionBlock: {\r\n                    result.push({\r\n                        kind: SymbolKind.ParserAction,\r\n                        name: \"{ action code }\",\r\n                        source: this.fileName,\r\n                        definition: undefined,\r\n                        description: undefined,\r\n                    });\r\n\r\n                    // Include predicates only when we are in a lexer or parser element.\r\n                    const list = candidateRule.ruleList;\r\n                    if (list[list.length - 1] === ANTLRv4Parser.RULE_lexerElement) {\r\n                        result.push({\r\n                            kind: SymbolKind.LexerPredicate,\r\n                            name: \"{ predicate }?\",\r\n                            source: this.fileName,\r\n                            definition: undefined,\r\n                            description: undefined,\r\n                        });\r\n                    } else if (list[list.length - 1] === ANTLRv4Parser.RULE_element) {\r\n                        result.push({\r\n                            kind: SymbolKind.ParserPredicate,\r\n                            name: \"{ predicate }?\",\r\n                            source: this.fileName,\r\n                            definition: undefined,\r\n                            description: undefined,\r\n                        });\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_terminalRule: { // Lexer rules.\r\n                    promises.push(this.symbolTable.getAllSymbols(BuiltInTokenSymbol));\r\n                    promises.push(this.symbolTable.getAllSymbols(VirtualTokenSymbol));\r\n                    promises.push(this.symbolTable.getAllSymbols(TokenSymbol));\r\n\r\n                    // Include fragment rules only when referenced from a lexer rule.\r\n                    const list = candidateRule.ruleList;\r\n                    if (list[list.length - 1] === ANTLRv4Parser.RULE_lexerAtom) {\r\n                        promises.push(this.symbolTable.getAllSymbols(FragmentTokenSymbol));\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_lexerCommandName: {\r\n                    [\"channel\", \"skip\", \"more\", \"mode\", \"push\", \"pop\"].forEach((symbol) => {\r\n                        result.push({\r\n                            kind: SymbolKind.Keyword,\r\n                            name: symbol,\r\n                            source: this.fileName,\r\n                            definition: undefined,\r\n                            description: undefined,\r\n                        });\r\n                    });\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_ruleref: {\r\n                    promises.push(this.symbolTable.getAllSymbols(RuleSymbol));\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Parser.RULE_identifier: {\r\n                    // Identifiers can be a lot of things. We only handle special cases here.\r\n                    // More concrete identifiers should be captured by rules further up in the call chain.\r\n                    const list = candidateRule.ruleList;\r\n                    switch (list[list.length - 1]) {\r\n                        case ANTLRv4Parser.RULE_option: {\r\n                            [\"superClass\", \"tokenVocab\", \"TokenLabelType\", \"contextSuperClass\", \"exportMacro\"]\r\n                                .forEach((symbol) => {\r\n                                    result.push({\r\n                                        kind: SymbolKind.Option,\r\n                                        name: symbol,\r\n                                        source: this.fileName,\r\n                                        definition: undefined,\r\n                                        description: undefined,\r\n                                    });\r\n                                });\r\n                            break;\r\n                        }\r\n\r\n                        case ANTLRv4Parser.RULE_namedAction: {\r\n                            [\"header\", \"members\", \"preinclude\", \"postinclude\", \"context\", \"declarations\", \"definitions\",\r\n                                \"listenerpreinclude\", \"listenerpostinclude\", \"listenerdeclarations\", \"listenermembers\",\r\n                                \"listenerdefinitions\", \"baselistenerpreinclude\", \"baselistenerpostinclude\",\r\n                                \"baselistenerdeclarations\", \"baselistenermembers\", \"baselistenerdefinitions\",\r\n                                \"visitorpreinclude\", \"visitorpostinclude\", \"visitordeclarations\", \"visitormembers\",\r\n                                \"visitordefinitions\", \"basevisitorpreinclude\", \"basevisitorpostinclude\",\r\n                                \"basevisitordeclarations\", \"basevisitormembers\", \"basevisitordefinitions\"]\r\n                                .forEach((symbol) => {\r\n                                    result.push({\r\n                                        kind: SymbolKind.Keyword,\r\n                                        name: symbol,\r\n                                        source: this.fileName,\r\n                                        definition: undefined,\r\n                                        description: undefined,\r\n                                    });\r\n                                });\r\n\r\n                            break;\r\n                        }\r\n\r\n                        default: {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                default: {\r\n                    break;\r\n                }\r\n            }\r\n\r\n        });\r\n\r\n        const symbolLists = await Promise.all(promises);\r\n        symbolLists.forEach((symbols) => {\r\n            if (symbols) {\r\n                symbols.forEach((symbol) => {\r\n                    if (symbol.name !== \"EOF\") {\r\n                        result.push({\r\n                            kind: SourceContext.getKindFromSymbol(symbol),\r\n                            name: symbol.name,\r\n                            source: this.fileName,\r\n                            definition: undefined,\r\n                            description: undefined,\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Should be called on every change to keep the input stream up to date, particularly for code completion.\r\n     * This call doesn't do any expensive processing (parse() does).\r\n     *\r\n     * @param source The new content of the editor.\r\n     */\r\n    public setText(source: string): void {\r\n        const input = CharStreams.fromString(source);\r\n        const lexer = new ANTLRv4Lexer(input);\r\n\r\n        // There won't be lexer errors actually. They are silently bubbled up and will cause parser errors.\r\n        lexer.removeErrorListeners();\r\n        lexer.addErrorListener(this.lexerErrorListener);\r\n        this.tokenStream = new CommonTokenStream(lexer);\r\n\r\n        // Keep the old parser around until the next parse run. Code completion could kick in before that.\r\n        // this.parser = undefined;\r\n    }\r\n\r\n    public parse(): string[] {\r\n        // Rewind the input stream for a new parse run.\r\n        // Might be unnecessary when we just created that via setText.\r\n        this.tokenStream.seek(0);\r\n        this.parser = new ANTLRv4Parser(this.tokenStream);\r\n        this.parser.removeErrorListeners();\r\n        this.parser.addErrorListener(this.errorListener);\r\n\r\n        this.parser.errorHandler = new BailErrorStrategy();\r\n        this.parser.interpreter.setPredictionMode(PredictionMode.SLL);\r\n\r\n        this.tree = undefined;\r\n\r\n        this.info.type = GrammarType.Unknown;\r\n        this.info.imports.length = 0;\r\n\r\n        this.grammarLexerData = undefined;\r\n        this.grammarLexerRuleMap.clear();\r\n        this.grammarParserData = undefined;\r\n        this.grammarLexerRuleMap.clear();\r\n\r\n        this.semanticAnalysisDone = false;\r\n        this.diagnostics.length = 0;\r\n\r\n        this.symbolTable.clear();\r\n        this.symbolTable.addDependencies(SourceContext.globalSymbols);\r\n\r\n        try {\r\n            this.tree = this.parser.grammarSpec();\r\n        } catch (e) {\r\n            if (e instanceof ParseCancellationException) {\r\n                this.tokenStream.seek(0);\r\n                this.parser.reset();\r\n                this.parser.errorHandler = new DefaultErrorStrategy();\r\n                this.parser.interpreter.setPredictionMode(PredictionMode.LL);\r\n                this.tree = this.parser.grammarSpec();\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n\r\n        if (this.tree && this.tree.childCount > 0) {\r\n            try {\r\n                const typeContext = this.tree.grammarType();\r\n                if (typeContext.LEXER()) {\r\n                    this.info.type = GrammarType.Lexer;\r\n                } else if (typeContext.PARSER()) {\r\n                    this.info.type = GrammarType.Parser;\r\n                } else {\r\n                    this.info.type = GrammarType.Combined;\r\n                }\r\n            } catch (e) {\r\n                // ignored\r\n            }\r\n        }\r\n\r\n        this.symbolTable.tree = this.tree;\r\n        const listener = new DetailsListener(this.symbolTable, this.info.imports);\r\n        ParseTreeWalker.DEFAULT.walk(listener, this.tree);\r\n\r\n        this.info.unreferencedRules = this.symbolTable.getUnreferencedSymbols();\r\n\r\n        return this.info.imports;\r\n    }\r\n\r\n    public getDiagnostics(): IDiagnosticEntry[] {\r\n        this.runSemanticAnalysisIfNeeded();\r\n\r\n        return this.diagnostics;\r\n    }\r\n\r\n    public getReferenceGraph(): Map<string, IReferenceNode> {\r\n        this.runSemanticAnalysisIfNeeded();\r\n\r\n        const result = new Map<string, IReferenceNode>();\r\n        for (const symbol of this.symbolTable.getAllSymbolsSync(BaseSymbol, false)) {\r\n            if (symbol instanceof RuleSymbol\r\n                || symbol instanceof TokenSymbol\r\n                || symbol instanceof FragmentTokenSymbol) {\r\n                const entry: IReferenceNode = {\r\n                    kind: symbol instanceof RuleSymbol ? SymbolKind.ParserRule : SymbolKind.LexerRule,\r\n                    rules: new Set<string>(),\r\n                    tokens: new Set<string>(),\r\n                    literals: new Set<string>(),\r\n                };\r\n\r\n                for (const child of symbol.getNestedSymbolsOfTypeSync(RuleReferenceSymbol)) {\r\n                    const resolved = this.symbolTable.resolveSync(child.name, false);\r\n                    if (resolved) {\r\n                        entry.rules.add(resolved.qualifiedName());\r\n                    } else {\r\n                        entry.rules.add(child.name);\r\n                    }\r\n                }\r\n\r\n                for (const child of symbol.getNestedSymbolsOfTypeSync(TokenReferenceSymbol)) {\r\n                    const resolved = this.symbolTable.resolveSync(child.name, false);\r\n                    if (resolved) {\r\n                        entry.tokens.add(resolved.qualifiedName());\r\n                    } else {\r\n                        entry.tokens.add(child.name);\r\n                    }\r\n                }\r\n\r\n                for (const child of symbol.getNestedSymbolsOfTypeSync(LiteralSymbol)) {\r\n                    const resolved = this.symbolTable.resolveSync(child.name, false);\r\n                    if (resolved) {\r\n                        entry.literals.add(resolved.qualifiedName());\r\n                    } else {\r\n                        entry.literals.add(child.name);\r\n                    }\r\n                }\r\n\r\n                result.set(symbol.qualifiedName(), entry);\r\n            } else if (symbol instanceof BuiltInTokenSymbol) {\r\n                result.set(symbol.qualifiedName(), {\r\n                    kind: SymbolKind.BuiltInLexerToken,\r\n                    rules: new Set<string>(),\r\n                    tokens: new Set<string>(),\r\n                    literals: new Set<string>(),\r\n                });\r\n            } else if (symbol instanceof VirtualTokenSymbol) {\r\n                result.set(symbol.qualifiedName(), {\r\n                    kind: SymbolKind.VirtualLexerToken,\r\n                    rules: new Set<string>(),\r\n                    tokens: new Set<string>(),\r\n                    literals: new Set<string>(),\r\n                });\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    public getRRDScript(ruleName: string): string | undefined {\r\n        this.runSemanticAnalysisIfNeeded();\r\n\r\n        return this.rrdScripts.get(ruleName);\r\n    }\r\n\r\n    /**\r\n     * Add this context to the list of referencing contexts in the given context.\r\n     *\r\n     * @param context The context to add.\r\n     */\r\n    public addAsReferenceTo(context: SourceContext): void {\r\n        // Check for mutual inclusion. References are organized like a mesh.\r\n        const pipeline: SourceContext[] = [context];\r\n        while (pipeline.length > 0) {\r\n            const current = pipeline.shift();\r\n            if (!current) {\r\n                continue;\r\n            }\r\n\r\n            if (current.references.indexOf(this) > -1) {\r\n                return; // Already in the list.\r\n            }\r\n\r\n            pipeline.push(...current.references);\r\n        }\r\n        context.references.push(this);\r\n        this.symbolTable.addDependencies(context.symbolTable);\r\n    }\r\n\r\n    /**\r\n     * Remove the given context from our list of dependencies.\r\n     *\r\n     * @param context The context to remove.\r\n     */\r\n    public removeDependency(context: SourceContext): void {\r\n        const index = context.references.indexOf(this);\r\n        if (index > -1) {\r\n            context.references.splice(index, 1);\r\n        }\r\n        this.symbolTable.removeDependency(context.symbolTable);\r\n    }\r\n\r\n    public getReferenceCount(symbol: string): number {\r\n        this.runSemanticAnalysisIfNeeded();\r\n\r\n        let result = this.symbolTable.getReferenceCount(symbol);\r\n\r\n        for (const reference of this.references) {\r\n            result += reference.getReferenceCount(symbol);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    public async getAllSymbols(recursive: boolean): Promise<BaseSymbol[]> {\r\n        // The symbol table returns symbols of itself and those it depends on (if recursive is true).\r\n        const result = await this.symbolTable.getAllSymbols(BaseSymbol, !recursive);\r\n\r\n        // Add also symbols from contexts referencing us, this time not recursive\r\n        // as we have added our content already.\r\n        for (const reference of this.references) {\r\n            const symbols = await reference.symbolTable.getAllSymbols(BaseSymbol, true);\r\n            symbols.forEach((value) => {\r\n                result.push(value);\r\n            });\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Similar like `enclosingRangeForSymbol` but returns the rule's name and index, if found.\r\n     *\r\n     * @param column The position within a line.\r\n     * @param row The line index.\r\n     *\r\n     * @returns A rule name and its index if found.\r\n     */\r\n    public ruleFromPosition(column: number, row: number): [string | undefined, number | undefined] {\r\n        const tree = BackendUtils.parseTreeFromPosition(this.tree!, column, row);\r\n        if (!tree) {\r\n            return [undefined, undefined];\r\n        }\r\n\r\n        let context: RuleContext | undefined = (tree as RuleContext);\r\n        while (context && context.ruleIndex !== ANTLRv4Parser.RULE_parserRuleSpec\r\n            && context.ruleIndex !== ANTLRv4Parser.RULE_lexerRuleSpec) {\r\n            context = context.parent;\r\n        }\r\n\r\n        if (context) {\r\n            if (context.ruleIndex === ANTLRv4Parser.RULE_parserRuleSpec) {\r\n                const ruleName = (context as ParserRuleSpecContext).RULE_REF().text;\r\n                let ruleIndex;\r\n                if (this.grammarParserData) {\r\n                    ruleIndex = this.grammarParserRuleMap.get(ruleName);\r\n                }\r\n\r\n                return [ruleName, ruleIndex];\r\n            }\r\n\r\n            const name = (context as LexerRuleSpecContext).TOKEN_REF().text;\r\n            let index;\r\n            if (this.grammarLexerData) {\r\n                index = this.grammarLexerRuleMap.get(name);\r\n            }\r\n\r\n            return [name, index];\r\n        }\r\n\r\n        return [undefined, undefined];\r\n    }\r\n\r\n    /**\r\n     * Use ANTLR4 jars to generate target files for the grammar managed in this context and all its dependencies.\r\n     *\r\n     * @param dependencies A list of additional grammars which need generation too.\r\n     * @param options Options to customize the generation process.\r\n     *\r\n     * @returns List of names of all participating files.\r\n     */\r\n    public async generate(dependencies: Set<SourceContext>, options: IGenerationOptions): Promise<string[]> {\r\n        if (options.loadOnly) {\r\n            const errors = this.setupInterpreters(options.outputDir);\r\n            if (errors.length === 0) {\r\n                // If no interpreter data was loaded at all then it might be we have to do a first generation run.\r\n                if (this.grammarParserData || this.grammarLexerData || !options.generateIfNeeded) {\r\n                    return Promise.resolve([]);\r\n                }\r\n            } else {\r\n                return Promise.reject(errors);\r\n            }\r\n        }\r\n\r\n        const parameters = [\"-jar\"];\r\n        if (options.alternativeJar) {\r\n            parameters.push(options.alternativeJar);\r\n        } else {\r\n            if (options.language?.toLowerCase() === \"typescript\") {\r\n                parameters.push(path.join(this.extensionDir, \"antlr/antlr4-typescript-4.9.0-SNAPSHOT-complete.jar\"));\r\n            } else {\r\n                parameters.push(path.join(this.extensionDir, \"antlr/antlr-4.9.2-complete.jar\"));\r\n            }\r\n        }\r\n\r\n        if (options.language) {\r\n            parameters.push(\"-Dlanguage=\" + options.language);\r\n        }\r\n\r\n        parameters.push(\"-message-format\");\r\n        parameters.push(\"antlr\");\r\n        if (options.libDir) {\r\n            parameters.push(\"-lib\");\r\n            parameters.push(options.libDir);\r\n        }\r\n\r\n        if (options.outputDir) {\r\n            parameters.push(\"-o\");\r\n            parameters.push(options.outputDir);\r\n        }\r\n\r\n        if (options.package) {\r\n            parameters.push(\"-package\");\r\n            parameters.push(options.package);\r\n        }\r\n\r\n        const genListener = options.listeners === undefined || options.listeners === true;\r\n        parameters.push(genListener ? \"-listener\" : \"-no-listener\");\r\n        parameters.push(options.visitors === true ? \"-visitor\" : \"-no-visitor\");\r\n        parameters.push(\"-Xexact-output-dir\"); // Available starting with 4.7.2.\r\n\r\n        if (options.additionalParameters) {\r\n            parameters.push(options.additionalParameters);\r\n        }\r\n\r\n        dependencies.add(this); // Needs this also in the error parser.\r\n\r\n        let message = \"\";\r\n        const fileList: string[] = [];\r\n        const spawnOptions = { cwd: options.baseDir ? options.baseDir : undefined };\r\n\r\n        const errorParser = new ErrorParser(dependencies);\r\n        for await (const dependency of dependencies) {\r\n            fileList.push(dependency.fileName);\r\n\r\n            const actualParameters = [...parameters, dependency.fileName];\r\n            const result = await this.doGeneration(actualParameters, spawnOptions, errorParser, options.outputDir);\r\n            if (result.length > 0) {\r\n                message += \"\\n\" + result;\r\n            }\r\n        }\r\n\r\n        if (message.length > 0) {\r\n            throw new Error(message);\r\n        }\r\n\r\n        return fileList;\r\n    }\r\n\r\n    public getATNGraph(rule: string): IATNGraphData | undefined {\r\n        const isLexerRule = rule[0] === rule[0].toUpperCase();\r\n        if ((isLexerRule && !this.grammarLexerData) || (!isLexerRule && !this.grammarParserData)) {\r\n            // Requires a generation run.\r\n            return;\r\n        }\r\n\r\n        const ruleIndexMap = isLexerRule ? this.grammarLexerRuleMap : this.grammarParserRuleMap;\r\n        if (!ruleIndexMap.has(rule)) {\r\n            return;\r\n        }\r\n        const ruleIndex: number = ruleIndexMap.get(rule)!;\r\n\r\n        const atn = isLexerRule ? this.grammarLexerData!.atn : this.grammarParserData!.atn;\r\n        const ruleNames = isLexerRule ? this.grammarLexerData!.ruleNames : this.grammarParserData!.ruleNames;\r\n        const vocabulary = isLexerRule ? this.grammarLexerData!.vocabulary : this.grammarParserData!.vocabulary;\r\n\r\n        const startState = atn.ruleToStartState[ruleIndex];\r\n        const stopState = atn.ruleToStopState[ruleIndex];\r\n\r\n        const lexerPredicates = this.listActions(CodeActionType.LexerPredicate);\r\n        const parserPredicates = this.listActions(CodeActionType.ParserPredicate);\r\n\r\n        const seenStates: Set<ATNState> = new Set([startState]);\r\n        const pipeline: ATNState[] = [startState];\r\n\r\n        const nodes: IATNNode[] = [];\r\n        const links: IATNLink[] = [];\r\n\r\n        // Maps an ATN state to its index in the rules list.\r\n        const stateToIndex = new Map<number, number>();\r\n        let currentRuleIndex = -1;\r\n\r\n        /**\r\n         * Checks the list of used ATN nodes for the given id and adds a new ATN node if no entry could be found.\r\n         *\r\n         * @param id The state identifier (usually the state number).\r\n         * @param state The ATN state represented by the ATN node, if a new node must be added.\r\n         *\r\n         * @returns The index of the ATN node for the given state.\r\n         */\r\n        const ensureATNNode = (id: number, state: ATNState): number => {\r\n            let index = stateToIndex.get(id);\r\n            if (index === undefined) {\r\n                const transitions = state.getTransitions();\r\n\r\n                index = nodes.length;\r\n                stateToIndex.set(id, index);\r\n                nodes.push({\r\n                    id,\r\n                    name: id.toString(),\r\n                    type: state.stateType,\r\n                });\r\n\r\n                // If this state transits to a new rule, create also a fake node for that rule.\r\n                if (transitions.length === 1 && transitions[0].target.stateType === ATNStateType.RULE_START) {\r\n                    const marker = state.stateNumber * transitions[0].target.stateNumber;\r\n                    stateToIndex.set(marker, index + 1);\r\n\r\n                    // Type 0 is used to denote a rule.\r\n                    nodes.push({\r\n                        id: currentRuleIndex--,\r\n                        name: ruleNames[transitions[0].target.ruleIndex],\r\n                        type: ATNStateType.INVALID_TYPE,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return index;\r\n        };\r\n\r\n        while (pipeline.length > 0) {\r\n            const state = pipeline.shift()!;\r\n\r\n            const sourceIndex = ensureATNNode(state.stateNumber, state);\r\n            for (const transition of state.getTransitions()) {\r\n                // Rule stop states usually point to the follow state in the calling rule, but can also\r\n                // point to a state in itself if the rule is left recursive. In any case we don't need to follow\r\n                // transitions going out from a stop state.\r\n                if (state === stopState) {\r\n                    continue;\r\n                }\r\n\r\n                const transitsToRule = transition.target.stateType === ATNStateType.RULE_START;\r\n                const marker = transition.target.stateNumber * (transitsToRule ? state.stateNumber : 1);\r\n                const targetIndex = ensureATNNode(marker, transition.target);\r\n\r\n                const labels: Array<{ content: string; class?: string; }> = [];\r\n                const link: IATNLink = {\r\n                    source: sourceIndex,\r\n                    target: targetIndex,\r\n                    type: transition.serializationType,\r\n                    labels,\r\n                };\r\n\r\n                switch (transition.serializationType) {\r\n                    case TransitionType.EPSILON: {\r\n                        // Label added below.\r\n                        break;\r\n                    }\r\n\r\n                    case TransitionType.RANGE: {\r\n                        labels.push({ content: \"Range Transition\", class: \"heading\" });\r\n\r\n                        break;\r\n                    }\r\n\r\n                    case TransitionType.RULE: {\r\n                        labels.push({ content: \"Rule Transition\", class: \"heading\" });\r\n\r\n                        break;\r\n                    }\r\n\r\n                    case TransitionType.PREDICATE: {\r\n                        const predicateTransition = transition as PredicateTransition;\r\n                        const index = predicateTransition.predIndex;\r\n                        labels.push({\r\n                            content: `Predicate Transition (${index})`,\r\n                            class: \"heading\",\r\n                        });\r\n\r\n                        let predicateText;\r\n                        if (isLexerRule) {\r\n                            const symbol = lexerPredicates[index];\r\n                            predicateText = symbol.description;\r\n                        } else {\r\n                            const symbol = parserPredicates[index];\r\n                            predicateText = symbol.description;\r\n                        }\r\n\r\n                        if (predicateText) {\r\n                            labels.push({\r\n                                content: predicateText,\r\n                                class: \"predicate\",\r\n                            });\r\n                        }\r\n\r\n                        break;\r\n                    }\r\n\r\n                    case TransitionType.ATOM: {\r\n                        labels.push({ content: \"Atom Transition\", class: \"heading\" });\r\n\r\n\r\n                        break;\r\n                    }\r\n\r\n                    case TransitionType.ACTION: {\r\n                        const actionTransition = transition as ActionTransition;\r\n                        const index = actionTransition.actionIndex === 0xFFFF ? -1 : actionTransition.actionIndex;\r\n                        if (isLexerRule) {\r\n                            labels.push({ content: `Lexer Action (${index})`, class: \"action\" });\r\n                        } else {\r\n                            // Parser actions are directly embedded. No idea why there are still action transitions\r\n                            // in the parser ATN (always with -1 index).\r\n                            labels.push({ content: \"Parser Action\", class: \"action\" });\r\n                        }\r\n\r\n                        break;\r\n                    }\r\n\r\n                    case TransitionType.SET: {\r\n                        labels.push({ content: \"Set Transition\", class: \"heading\" });\r\n                        break;\r\n                    }\r\n\r\n                    case TransitionType.NOT_SET: {\r\n                        labels.push({ content: \"Not-Set Transition\", class: \"heading\" });\r\n                        break;\r\n                    }\r\n\r\n                    case TransitionType.WILDCARD: {\r\n                        labels.push({ content: \"Wildcard Transition\", class: \"heading\" });\r\n                        break;\r\n                    }\r\n\r\n                    case TransitionType.PRECEDENCE: {\r\n                        const precedenceTransition = transition as PrecedencePredicateTransition;\r\n                        labels.push({\r\n                            content: `Precedence Predicate (${precedenceTransition.precedence})`,\r\n                            class: \"heading\",\r\n                        });\r\n                        break;\r\n                    }\r\n\r\n                    default: {\r\n\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (transition.serializationType !== TransitionType.PREDICATE) {\r\n                    if (transition.isEpsilon) {\r\n                        labels.push({ content: \"\" });\r\n                    } else if (transition.label) {\r\n                        if (isLexerRule) {\r\n                            this.intervalSetToStrings(transition.label).forEach((value) => {\r\n                                labels.push({ content: value });\r\n                            });\r\n                        } else {\r\n                            for (const label of transition.label.toArray()) {\r\n                                labels.push({ content: vocabulary.getDisplayName(label) });\r\n                            }\r\n                        }\r\n                    } else {\r\n                        labels.push({ content: \"\" });\r\n                    }\r\n                }\r\n\r\n                links.push(link);\r\n\r\n                let nextState: ATNState;\r\n                if (transitsToRule) {\r\n                    // Target is a state in a different rule (or this rule if left recursive).\r\n                    // Add a back link from that sub rule into ours.\r\n                    nextState = (transition as RuleTransition).followState;\r\n                    const returnIndex = ensureATNNode(nextState.stateNumber, nextState);\r\n\r\n                    const nodeLink: IATNLink = {\r\n                        source: targetIndex,\r\n                        target: returnIndex,\r\n                        type: TransitionType.RULE,\r\n                        labels: [{ content: \"\" }],\r\n                    };\r\n                    links.push(nodeLink);\r\n                } else {\r\n                    nextState = transition.target;\r\n                }\r\n\r\n                if (seenStates.has(nextState)) {\r\n                    continue;\r\n                }\r\n\r\n                seenStates.add(nextState);\r\n                pipeline.push(nextState);\r\n            }\r\n        }\r\n\r\n        return {\r\n            links,\r\n            nodes,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Generates strings that are valid input for the managed grammar.\r\n     *\r\n     * @param dependencies All source contexts on which this one depends (usually the lexer,\r\n     *                     if this is a split grammar).\r\n     * @param rule The rule to generate a sentence for.\r\n     * @param options The settings controlling the generation.\r\n     * @param callback A function to call for each generated sentence.\r\n     */\r\n    public generateSentence(dependencies: Set<SourceContext>, rule: string,\r\n        options: ISentenceGenerationOptions, callback: (sentence: string, index: number) => void): void {\r\n        if (!this.isInterpreterDataLoaded) {\r\n            // Requires a generation run.\r\n            callback(\"[No grammar data available]\", 0);\r\n\r\n            return;\r\n        }\r\n\r\n        if (rule.length === 0) {\r\n            callback(\"[No rule specified]\", 0);\r\n\r\n            return;\r\n        }\r\n\r\n        const isLexerRule = rule[0] === rule[0].toUpperCase();\r\n        let lexerData: IInterpreterData | undefined;\r\n        let parserData: IInterpreterData | undefined;\r\n\r\n        switch (this.info.type) {\r\n            case GrammarType.Combined: {\r\n                lexerData = this.grammarLexerData;\r\n                parserData = this.grammarParserData;\r\n                break;\r\n            }\r\n\r\n            case GrammarType.Lexer: {\r\n                lexerData = this.grammarLexerData;\r\n                break;\r\n            }\r\n            case GrammarType.Parser: {\r\n                // Get lexer data from dependency.\r\n                for (const dependency of dependencies) {\r\n                    if (dependency.info.type === GrammarType.Lexer) {\r\n                        lexerData = dependency.grammarLexerData;\r\n                        break;\r\n                    }\r\n                }\r\n                parserData = this.grammarParserData;\r\n                break;\r\n            }\r\n\r\n            default: {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!lexerData) { // Lexer data must always exist.\r\n            callback(\"[No lexer data available]\", 0);\r\n\r\n            return;\r\n        }\r\n\r\n        if (!isLexerRule && !parserData) { // Parser data is only required for parser sentence generation.\r\n            callback(\"[No parser data available]\", 0);\r\n\r\n            return;\r\n        }\r\n\r\n        let start: RuleStartState;\r\n        if (isLexerRule) {\r\n            const index = this.grammarLexerRuleMap.get(rule);\r\n            if (index === undefined) {\r\n                callback(\"[Virtual or undefined token]\", 0);\r\n\r\n                return;\r\n            }\r\n            start = lexerData.atn.ruleToStartState[index];\r\n        } else {\r\n            const index = this.grammarParserRuleMap.get(rule);\r\n            if (index === undefined) {\r\n                callback(\"[Undefined rule]\", 0);\r\n\r\n                return;\r\n            }\r\n            start = parserData!.atn.ruleToStartState[index];\r\n        }\r\n\r\n        try {\r\n            const generator = new SentenceGenerator(this, lexerData, parserData, options.actionFile);\r\n\r\n            const count = Math.max(options.count ?? 1, 1);\r\n            for (let i = 0; i < count; ++i) {\r\n                callback(generator.generate(options, start), i);\r\n            }\r\n        } catch (e) {\r\n            callback(String(e), 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Testing support: take the input and run it through the lexer interpreter to see if it produces correct tokens.\r\n     *\r\n     * @param input The text to lex.\r\n     * @param actionFile The name of a file that allows executing predicates/actions.\r\n     *\r\n     * @returns A tuple with recognized token names and an error message, if an error occurred.\r\n     */\r\n    public lexTestInput(input: string, actionFile?: string): [string[], string] {\r\n        const result: string[] = [];\r\n        let error = \"\";\r\n\r\n        if (this.grammarLexerData) {\r\n            let predicateFunction;\r\n            if (actionFile) {\r\n                const code = fs.readFileSync(actionFile, { encoding: \"utf-8\" }) + `\r\n                const runPredicate = (predicate) => eval(predicate);\r\n                runPredicate;\r\n                `;\r\n\r\n                predicateFunction = vm.runInNewContext(code) as PredicateFunction;\r\n            }\r\n\r\n            const stream = CharStreams.fromString(input);\r\n            const lexer = new GrammarLexerInterpreter(predicateFunction, this, \"<unnamed>\",\r\n                this.grammarLexerData, stream);\r\n            lexer.removeErrorListeners();\r\n\r\n            lexer.addErrorListener(\r\n                new InterpreterLexerErrorListener((event: string | symbol, ...args: unknown[]): boolean => {\r\n                    error += (args[0] as string) + \"\\n\";\r\n\r\n                    return true;\r\n                }),\r\n            );\r\n            const tokenStream = new CommonTokenStream(lexer);\r\n            tokenStream.fill();\r\n\r\n            for (const token of tokenStream.getTokens()) {\r\n                const name = lexer.vocabulary.getSymbolicName(token.type);\r\n                result.push(name!);\r\n            }\r\n        }\r\n\r\n        return [result, error];\r\n    }\r\n\r\n    /**\r\n     * Testing support: take the input and run it through the parser interpreter to see if it is syntactically correct.\r\n     *\r\n     * @param input The text to parse.\r\n     * @param startRule The rule to use for the parse run.\r\n     * @param actionFile The name of a file that allows executing predicates/actions.\r\n     *\r\n     * @returns A list of errors if one occurred.\r\n     */\r\n    public parseTestInput(input: string, startRule: string, actionFile?: string): string[] {\r\n        const errors: string[] = [];\r\n\r\n        if (!this.grammarLexerData || !this.grammarParserData) {\r\n            return [\"No interpreter data available\"];\r\n        }\r\n\r\n        let predicateFunction;\r\n        if (actionFile) {\r\n            const code = fs.readFileSync(actionFile, { encoding: \"utf-8\" }) + `\r\n            const runPredicate = (predicate) => eval(predicate);\r\n            runPredicate;\r\n            `;\r\n\r\n            predicateFunction = vm.runInNewContext(code) as PredicateFunction;\r\n        }\r\n\r\n        const eventSink = (event: string | symbol, ...args: unknown[]): void => {\r\n            errors.push(args[0] as string);\r\n        };\r\n\r\n        const stream = CharStreams.fromString(input);\r\n        const lexer = new GrammarLexerInterpreter(predicateFunction, this, \"<unnamed>\", this.grammarLexerData, stream);\r\n        lexer.removeErrorListeners();\r\n\r\n        lexer.addErrorListener(new InterpreterLexerErrorListener(eventSink));\r\n        const tokenStream = new CommonTokenStream(lexer);\r\n        tokenStream.fill();\r\n\r\n        const parser = new GrammarParserInterpreter(eventSink, predicateFunction, this, this.grammarParserData,\r\n            tokenStream);\r\n        parser.buildParseTree = true;\r\n        parser.removeErrorListeners();\r\n        parser.addErrorListener(new InterpreterParserErrorListener(eventSink));\r\n\r\n        const startRuleIndex = parser.getRuleIndex(startRule);\r\n        parser.parse(startRuleIndex);\r\n\r\n        return errors;\r\n    }\r\n\r\n    public getSymbolInfo(symbol: string | BaseSymbol): ISymbolInfo | undefined {\r\n        return this.symbolTable.getSymbolInfo(symbol);\r\n    }\r\n\r\n    public resolveSymbol(symbolName: string): BaseSymbol | undefined {\r\n        return this.symbolTable.resolveSync(symbolName, false);\r\n    }\r\n\r\n    public formatGrammar(options: IFormattingOptions, start: number, stop: number): [string, number, number] {\r\n        this.tokenStream.fill();\r\n        const tokens = this.tokenStream.getTokens();\r\n        const formatter = new GrammarFormatter(tokens);\r\n\r\n        return formatter.formatGrammar(options, start, stop);\r\n    }\r\n\r\n    /**\r\n     * Loads interpreter data if it exists and sets up the interpreters.\r\n     *\r\n     * @param outputDir The path in which the output from the parser generation run, which contains the interpreter\r\n     *                  data files.\r\n     *\r\n     * @returns An empty string if all went fine or the error text, if something went wrong.\r\n     */\r\n    public setupInterpreters(outputDir?: string): string {\r\n        // Load interpreter data if the code generation was successful.\r\n        // For that we only need the final parser and lexer files, not any imported stuff.\r\n        // The target path is either the output path (if one was given) or the grammar path.\r\n        let lexerInterpreterDataFile = \"\";\r\n        let parserInterpreterDataFile = \"\";\r\n        const baseName = (this.fileName.endsWith(\".g4\")\r\n            ? path.basename(this.fileName, \".g4\")\r\n            : path.basename(this.fileName, \".g\"));\r\n        const grammarPath = (outputDir) ? outputDir : path.dirname(this.fileName);\r\n\r\n        switch (this.info.type) {\r\n            case GrammarType.Combined: {\r\n                // In a combined grammar the lexer is implicitly extracted and treated as a separate file.\r\n                // We have no own source context for this case and hence load both lexer and parser data here.\r\n                parserInterpreterDataFile = path.join(grammarPath, baseName) + \".interp\";\r\n                lexerInterpreterDataFile = path.join(grammarPath, baseName) + \"Lexer.interp\";\r\n                break;\r\n            }\r\n\r\n            case GrammarType.Lexer: {\r\n                lexerInterpreterDataFile = path.join(grammarPath, baseName) + \".interp\";\r\n                break;\r\n            }\r\n\r\n            case GrammarType.Parser: {\r\n                parserInterpreterDataFile = path.join(grammarPath, baseName) + \".interp\";\r\n                break;\r\n            }\r\n\r\n            default: // Unknown, no data is loaded.\r\n                break;\r\n        }\r\n\r\n        let errors = \"\";\r\n        if (fs.existsSync(lexerInterpreterDataFile)) {\r\n            try {\r\n                this.grammarLexerData = InterpreterDataReader.parseFile(lexerInterpreterDataFile);\r\n                const map = new Map<string, number>();\r\n                for (let i = 0; i < this.grammarLexerData.ruleNames.length; ++i) {\r\n                    map.set(this.grammarLexerData.ruleNames[i], i);\r\n                }\r\n                this.grammarLexerRuleMap = map;\r\n            } catch (error) {\r\n                errors +=\r\n                    `Error while reading lexer interpreter data (${lexerInterpreterDataFile}): ${String(error)}\\n`;\r\n            }\r\n        } else {\r\n            this.grammarLexerData = undefined;\r\n            this.grammarLexerRuleMap.clear();\r\n        }\r\n\r\n        if (fs.existsSync(parserInterpreterDataFile)) {\r\n            try {\r\n                this.grammarParserData = InterpreterDataReader.parseFile(parserInterpreterDataFile);\r\n                const map = new Map<string, number>();\r\n                for (let i = 0; i < this.grammarParserData.ruleNames.length; ++i) {\r\n                    map.set(this.grammarParserData.ruleNames[i], i);\r\n                }\r\n                this.grammarParserRuleMap = map;\r\n            } catch (error) {\r\n                errors +=\r\n                    `Error while reading parser interpreter data (${lexerInterpreterDataFile}): ${String(error)}\\n`;\r\n            }\r\n        } else {\r\n            this.grammarParserData = undefined;\r\n            this.grammarParserRuleMap.clear();\r\n        }\r\n\r\n        return errors;\r\n    }\r\n\r\n    /**\r\n     * This method runs the generation for one file.\r\n     *\r\n     * @param parameters The command line parameters fro ANTLR4.\r\n     * @param spawnOptions The options for spawning Java.\r\n     * @param errorParser The parser to use for ANTLR4 error messages.\r\n     * @param outputDir The directory to find the interpreter data.\r\n     *\r\n     * @returns A string containing the error for non-grammar problems (process or java issues) otherwise empty.\r\n     */\r\n    private doGeneration(parameters: string[], spawnOptions: object, errorParser: ErrorParser,\r\n        outputDir?: string): Promise<string> {\r\n        return new Promise((resolve, reject) => {\r\n            const java = child_process.spawn(\"java\", parameters, spawnOptions);\r\n\r\n            java.on(\"error\", (error) => {\r\n                resolve(`Error while running Java: \"${error.message}\". Is Java installed on you machine?`);\r\n            });\r\n\r\n            let buffer = \"\";\r\n            java.stderr.on(\"data\", (data: Buffer) => {\r\n                let text = data.toString();\r\n                if (text.startsWith(\"Picked up _JAVA_OPTIONS:\")) {\r\n                    const endOfInfo = text.indexOf(\"\\n\");\r\n                    if (endOfInfo === -1) {\r\n                        text = \"\";\r\n                    } else {\r\n                        text = text.substring(endOfInfo + 1);\r\n                    }\r\n                }\r\n\r\n                if (text.length > 0) {\r\n                    buffer += \"\\n\" + text;\r\n                }\r\n            });\r\n\r\n            java.on(\"close\", (_code) => {\r\n                const flag = errorParser.convertErrorsToDiagnostics(buffer);\r\n                if (flag) {\r\n                    resolve(this.setupInterpreters(outputDir));\r\n                } else {\r\n                    reject(buffer); // Treat this as non-grammar output (e.g. Java exception).\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private runSemanticAnalysisIfNeeded() {\r\n        if (!this.semanticAnalysisDone) {\r\n            this.semanticAnalysisDone = true;\r\n            //this.diagnostics.length = 0; Don't, we would lose our syntax errors from last parse run.\r\n            this.rrdScripts = new Map<string, string>();\r\n            const semanticListener = new SemanticListener(this.diagnostics, this.symbolTable);\r\n            ParseTreeWalker.DEFAULT.walk(semanticListener, this.tree!);\r\n\r\n            const visitor = new RuleVisitor(this.rrdScripts);\r\n            visitor.visit(this.tree!);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert an interval set to a list of ranges, consumable by a human.\r\n     *\r\n     * @param set The set to convert.\r\n     * @returns A list of strings, one for each defined interval.\r\n     */\r\n    private intervalSetToStrings(set: IntervalSet): string[] {\r\n        const result: string[] = [];\r\n\r\n        /**\r\n         * Return a readable representation of a code point. The input can be anything from the\r\n         * full Unicode range.\r\n         *\r\n         * @param char The code point to convert.\r\n         *\r\n         * @returns The string representation of the character.\r\n         */\r\n        const characterRepresentation = (char: number): string => {\r\n            if (char < 0) {\r\n                return \"EOF\";\r\n            }\r\n\r\n            if (SourceContext.printableChars.contains(char)) {\r\n                return \"'\" + String.fromCharCode(char) + \"'\";\r\n            }\r\n\r\n            const value = char.toString(16).toUpperCase();\r\n\r\n            return \"\\\\u\" + \"0\".repeat(4 - value.length) + value;\r\n        };\r\n\r\n        for (const interval of set.intervals) {\r\n            let entry = characterRepresentation(interval.a);\r\n            if (interval.a !== interval.b) {\r\n                entry += \" - \" + characterRepresentation(interval.b);\r\n            }\r\n            result.push(entry);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    static {\r\n        void printableUnicodePoints({}).then((intervalSet) => {\r\n            this.printableChars = intervalSet;\r\n        });\r\n    }\r\n}\r\n"]}