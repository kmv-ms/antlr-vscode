{"version":3,"file":"SemanticListener.js","sourceRoot":"","sources":["../../../src/backend/SemanticListener.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\nimport { IDiagnosticEntry, DiagnosticType, SymbolGroupKind } from \"./types\";\r\nimport { ContextSymbolTable } from \"./ContextSymbolTable\";\r\nimport { ANTLRv4ParserListener } from \"../parser/ANTLRv4ParserListener\";\r\nimport {\r\n    TerminalRuleContext, RulerefContext, SetElementContext, LexerCommandContext, LexerRuleSpecContext,\r\n    ParserRuleSpecContext,\r\n} from \"../parser/ANTLRv4Parser\";\r\n\r\nimport { Token, ParserRuleContext } from \"antlr4ts\";\r\nimport { TerminalNode } from \"antlr4ts/tree\";\r\n\r\nexport class SemanticListener implements ANTLRv4ParserListener {\r\n\r\n    private seenSymbols = new Map<string, Token>();\r\n\r\n    public constructor(private diagnostics: IDiagnosticEntry[], private symbolTable: ContextSymbolTable) { }\r\n\r\n    // Check references to other lexer tokens.\r\n    public exitTerminalRule = (ctx: TerminalRuleContext): void => {\r\n        const tokenRef = ctx.TOKEN_REF();\r\n        if (tokenRef) {\r\n            const symbol = tokenRef.text;\r\n            this.checkSymbolExistence(true, SymbolGroupKind.TokenRef, symbol, \"Unknown token reference\",\r\n                tokenRef.symbol);\r\n            this.symbolTable.incrementSymbolRefCount(symbol);\r\n        }\r\n    };\r\n\r\n    // Check references to other parser rules.\r\n    public exitRuleref = (ctx: RulerefContext): void => {\r\n        const ruleRef = ctx.RULE_REF();\r\n        if (ruleRef) {\r\n            const symbol = ruleRef.text;\r\n            this.checkSymbolExistence(true, SymbolGroupKind.RuleRef, symbol, \"Unknown parser rule\", ruleRef.symbol);\r\n            this.symbolTable.incrementSymbolRefCount(symbol);\r\n        }\r\n    };\r\n\r\n    // Check references to other lexer tokens.\r\n    public exitSetElement = (ctx: SetElementContext): void => {\r\n        const tokenRef = ctx.TOKEN_REF();\r\n        if (tokenRef) {\r\n            const symbol = tokenRef.text;\r\n            this.checkSymbolExistence(true, SymbolGroupKind.TokenRef, symbol, \"Unknown token reference\",\r\n                tokenRef.symbol);\r\n            this.symbolTable.incrementSymbolRefCount(symbol);\r\n        }\r\n    };\r\n\r\n    // Check references to modes + channels in lexer actions.\r\n    public exitLexerCommand = (ctx: LexerCommandContext): void => {\r\n        const lexerCommandExpr = ctx.lexerCommandExpr();\r\n        const lexerCommandExprId = lexerCommandExpr ? lexerCommandExpr.identifier() : undefined;\r\n        if (lexerCommandExprId) {\r\n            let name = ctx.lexerCommandName().text;\r\n            let kind = SymbolGroupKind.TokenRef;\r\n\r\n            const value = name.toLowerCase();\r\n            if (value === \"pushmode\" || value === \"mode\") {\r\n                name = \"mode\";\r\n                kind = SymbolGroupKind.LexerMode;\r\n            } else if (value === \"channel\") {\r\n                kind = SymbolGroupKind.TokenChannel;\r\n            }\r\n            const symbol = lexerCommandExprId.text;\r\n            this.checkSymbolExistence(true, kind, symbol, \"Unknown \" + name, lexerCommandExprId.start);\r\n            this.symbolTable.incrementSymbolRefCount(symbol);\r\n        }\r\n    };\r\n\r\n    // Check definition of a lexer token.\r\n    public exitLexerRuleSpec = (ctx: LexerRuleSpecContext): void => {\r\n        const tokenRef = ctx.TOKEN_REF();\r\n        const name = tokenRef.text;\r\n\r\n        // The symbol table already contains an entry for this symbol. So we can only partially use that\r\n        // for duplicate checks. `seenSymbols` tracks occurrences for symbols in the main symbol table.\r\n        const seenSymbol = this.seenSymbols.get(name);\r\n        if (seenSymbol) {\r\n            this.reportDuplicateSymbol(name, tokenRef.symbol, seenSymbol);\r\n        } else {\r\n            // Otherwise we haven't come across this symbol yet.\r\n            this.seenSymbols.set(name, tokenRef.symbol);\r\n            void this.resolveAndReportDuplicate(name, tokenRef);\r\n        }\r\n    };\r\n\r\n    // Check definition of a parser rule.\r\n    public exitParserRuleSpec = (ctx: ParserRuleSpecContext): void => {\r\n        // Same processing here as for lexer rules.\r\n        const ruleRef = ctx.RULE_REF();\r\n        const name = ruleRef.text;\r\n        const seenSymbol = this.seenSymbols.get(name);\r\n        if (seenSymbol) {\r\n            this.reportDuplicateSymbol(name, ruleRef.symbol, seenSymbol);\r\n        } else {\r\n            this.seenSymbols.set(name, ruleRef.symbol);\r\n            void this.resolveAndReportDuplicate(name, ruleRef);\r\n        }\r\n    };\r\n\r\n    public visitTerminal = (_node: TerminalNode): void => {\r\n        // Nothing to do here.\r\n    };\r\n\r\n    protected checkSymbolExistence(mustExist: boolean, kind: SymbolGroupKind, symbol: string, message: string,\r\n        offendingToken: Token): void {\r\n        if (this.symbolTable.symbolExistsInGroup(symbol, kind, false) !== mustExist) {\r\n            const entry: IDiagnosticEntry = {\r\n                type: DiagnosticType.Error,\r\n                message: message + \" '\" + symbol + \"'\",\r\n                range: {\r\n                    start: {\r\n                        column: offendingToken.charPositionInLine,\r\n                        row: offendingToken.line,\r\n                    },\r\n                    end: {\r\n                        column: offendingToken.charPositionInLine + offendingToken.stopIndex -\r\n                            offendingToken.startIndex + 1,\r\n                        row: offendingToken.line,\r\n                    },\r\n                },\r\n            };\r\n            this.diagnostics.push(entry);\r\n        }\r\n    }\r\n\r\n    protected reportDuplicateSymbol(symbol: string, offendingToken: Token, _previousToken: Token | undefined): void {\r\n        const entry: IDiagnosticEntry = {\r\n            type: DiagnosticType.Error,\r\n            message: \"Duplicate symbol '\" + symbol + \"'\",\r\n            range: {\r\n                start: {\r\n                    column: offendingToken.charPositionInLine,\r\n                    row: offendingToken.line,\r\n                },\r\n                end: {\r\n                    column: offendingToken.charPositionInLine + offendingToken.stopIndex -\r\n                        offendingToken.startIndex + 1,\r\n                    row: offendingToken.line,\r\n                },\r\n            },\r\n        };\r\n        this.diagnostics.push(entry);\r\n    }\r\n\r\n    private async resolveAndReportDuplicate(name: string, ruleRef: TerminalNode): Promise<void> {\r\n        // Check if there are dependencies which already have this symbol, expressed by the fact\r\n        // that the found symbol is not defined in the main symbol table.\r\n        const symbol = await this.symbolTable.resolve(name);\r\n        if (symbol) {\r\n            if (symbol.root !== this.symbolTable) {\r\n                let start;\r\n                if (symbol.context instanceof ParserRuleContext) {\r\n                    start = symbol.context.start;\r\n                } else if (symbol.context instanceof TerminalNode) {\r\n                    start = symbol.context.symbol;\r\n                }\r\n                this.reportDuplicateSymbol(name, ruleRef.symbol, start);\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n"]}