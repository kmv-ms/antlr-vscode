{"version":3,"file":"GrammarInterpreters.js","sourceRoot":"","sources":["../../../src/backend/GrammarInterpreters.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\n// I want to keep all related classes (most of them really small) in a single place.\r\n/* eslint-disable max-classes-per-file */\r\n\r\n/* eslint-disable no-underscore-dangle */\r\n\r\nimport {\r\n    LexerInterpreter, ParserInterpreter, TokenStream, CommonToken, ParserRuleContext, RecognitionException,\r\n    ANTLRErrorListener, Recognizer, Token, Lexer, RuleContext, CharStream,\r\n} from \"antlr4ts\";\r\n\r\nimport { RuleStartState, ATNState, ATNStateType, TransitionType, Transition, ATNSimulator } from \"antlr4ts/atn\";\r\nimport { TerminalNode } from \"antlr4ts/tree\";\r\nimport { BaseSymbol, VariableSymbol, ScopedSymbol, BlockSymbol } from \"antlr4-c3\";\r\n\r\nimport { IInterpreterData } from \"./InterpreterDataReader\";\r\nimport {\r\n    ContextSymbolTable, RuleReferenceSymbol, RuleSymbol, EbnfSuffixSymbol, LexerPredicateSymbol,\r\n    ParserPredicateSymbol, LexerActionSymbol, ParserActionSymbol,\r\n} from \"./ContextSymbolTable\";\r\nimport { SourceContext } from \"./SourceContext\";\r\nimport { PredicateFunction } from \"./types\";\r\nimport { TerminalRuleContext } from \"../parser/ANTLRv4Parser\";\r\n\r\nexport enum RunMode {\r\n    Normal,\r\n    StepIn,\r\n    StepOver,\r\n    StepOut\r\n}\r\n\r\nexport interface IInternalStackFrame {\r\n    name: string;\r\n    source?: string;\r\n    current: BaseSymbol[];\r\n    next: BaseSymbol[];\r\n}\r\n\r\nexport class GrammarLexerInterpreter extends LexerInterpreter {\r\n    private predicates: LexerPredicateSymbol[];\r\n\r\n    public constructor(\r\n        private runPredicate: PredicateFunction | undefined,\r\n        private mainContext: SourceContext,\r\n        grammarFileName: string,\r\n        lexerData: IInterpreterData,\r\n        input: CharStream) {\r\n\r\n        super(grammarFileName, lexerData.vocabulary, lexerData.ruleNames, lexerData.channels, lexerData.modes,\r\n            lexerData.atn, input);\r\n\r\n        this.mainContext.symbolTable.getNestedSymbolsOfType(LexerPredicateSymbol).then((symbols) => {\r\n            this.predicates = symbols;\r\n        }).catch(() => {\r\n            this.predicates = [];\r\n        });\r\n    }\r\n\r\n    public override sempred(_localctx: RuleContext | undefined, ruleIndex: number, predIndex: number): boolean {\r\n        if (this.runPredicate) {\r\n            if (predIndex < this.predicates.length) {\r\n                let predicate = this.predicates[predIndex].context!.text;\r\n                if (predicate.length > 2) {\r\n                    predicate = predicate.substring(1, predicate.length - 2); // Remove outer curly braces.\r\n                    try {\r\n                        return this.runPredicate(predicate);\r\n                    } catch (e) {\r\n                        throw Error(`There was an error while evaluating predicate \"${predicate}\". ` +\r\n                            \"Evaluation returned: \" + String(e));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nexport class GrammarParserInterpreter extends ParserInterpreter {\r\n    public breakPoints = new Set<ATNState>();\r\n    public callStack: IInternalStackFrame[];\r\n    public pauseRequested = false;\r\n\r\n    private startIsPrecedenceRule: boolean;\r\n    private predicates: ParserPredicateSymbol[];\r\n\r\n    public constructor(\r\n        private eventSink: (event: string | symbol, ...args: unknown[]) => void,\r\n        private runPredicate: PredicateFunction | undefined,\r\n        private mainContext: SourceContext,\r\n        parserData: IInterpreterData,\r\n        input: TokenStream) {\r\n\r\n        super(mainContext.fileName, parserData.vocabulary, parserData.ruleNames, parserData.atn, input);\r\n\r\n        this.mainContext.symbolTable.getNestedSymbolsOfType(ParserPredicateSymbol).then((symbols) => {\r\n            this.predicates = symbols;\r\n        }).catch(() => {\r\n            this.predicates = [];\r\n        });\r\n\r\n    }\r\n\r\n    public start(startRuleIndex: number): ParserRuleContext {\r\n        this.pauseRequested = false;\r\n        this.callStack = [];\r\n        const startRuleStartState: RuleStartState = this.atn.ruleToStartState[startRuleIndex];\r\n        this._rootContext = this.createInterpreterRuleContext(undefined, ATNState.INVALID_STATE_NUMBER, startRuleIndex);\r\n        if (startRuleStartState.isPrecedenceRule) {\r\n            this.enterRecursionRule(this.rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);\r\n        } else {\r\n            this.enterRule(this.rootContext, startRuleStartState.stateNumber, startRuleIndex);\r\n        }\r\n        this.startIsPrecedenceRule = startRuleStartState.isPrecedenceRule;\r\n\r\n        return this.rootContext;\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Resume parsing from the current ATN state until the end or we hit a breakpoint.\r\n     *\r\n     * @param runMode The mode to use for further run.\r\n     *\r\n     * @returns The context with which we ended the run.\r\n     */\r\n    public continue(runMode: RunMode): ParserRuleContext {\r\n        // Need the current step depth for step over/out.\r\n        const stackDepth = this.callStack.length;\r\n\r\n        // If we are not going to jump into a rule then make step over a step in.\r\n        // This way we can use step over exclusively for rule processing.\r\n        let p = this.atnState;\r\n        if (p.transition(0).serializationType !== TransitionType.RULE && runMode === RunMode.StepOver) {\r\n            runMode = RunMode.StepIn;\r\n        }\r\n\r\n        // We don't stop directly on the break point state but on the next rule/non-epsilon transition.\r\n        let breakPointPending = false;\r\n        while (true) {\r\n            if (this.pauseRequested) {\r\n                this.pauseRequested = false;\r\n                runMode = RunMode.StepIn; // Stop at next possible position.\r\n            }\r\n\r\n            if (this.breakPoints.has(p) && p.stateType !== ATNStateType.RULE_STOP) {\r\n                // Don't mark a pending rule end break point here. That has already been handled.\r\n                breakPointPending = true;\r\n                runMode = RunMode.StepIn;\r\n            }\r\n\r\n            switch (p.stateType) {\r\n                case ATNStateType.RULE_STOP: {\r\n                    if (this._ctx.isEmpty) {\r\n                        // End of start rule.\r\n                        if (this.startIsPrecedenceRule) {\r\n                            const result = this._ctx;\r\n                            const parentContext = this._parentContextStack.pop()!;\r\n                            this.unrollRecursionContexts(parentContext[0]);\r\n                            this.eventSink(\"end\");\r\n\r\n                            return result;\r\n                        } else {\r\n                            this.exitRule();\r\n                            this.eventSink(\"end\");\r\n\r\n                            return this.rootContext;\r\n                        }\r\n                    }\r\n\r\n                    this.callStack.pop();\r\n                    this.visitRuleStopState(p);\r\n                    if ((runMode === RunMode.StepOut && stackDepth === this.callStack.length + 1)\r\n                        || (runMode === RunMode.StepOver && stackDepth === this.callStack.length)) {\r\n                        // Reached the rule end right before a step over/out.\r\n                        // Continue with step-in to stop at the next work item.\r\n                        runMode = RunMode.StepIn;\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ATNStateType.RULE_START: {\r\n                    const ruleName = this.ruleNameFromIndex(this.atnState.ruleIndex);\r\n                    if (ruleName) {\r\n                        const ruleSymbol = this.mainContext.resolveSymbol(ruleName);\r\n                        if (ruleSymbol) {\r\n                            // Get the source name from the symbol's symbol table (which doesn't\r\n                            // necessarily correspond to the one we have set for the debugger).\r\n                            const st = ruleSymbol.symbolTable as ContextSymbolTable;\r\n                            this.callStack.push({\r\n                                name: ruleName,\r\n                                current: [ruleSymbol],\r\n                                next: [ruleSymbol],\r\n                                source: st.owner ? st.owner.fileName : undefined,\r\n                            });\r\n                        } else {\r\n                            throw new Error(\"Cannot find rule \\\"\" + ruleName + \"\\\" - debugging aborted.\");\r\n                        }\r\n                    }\r\n                    // [fall-through]\r\n                }\r\n\r\n                default: {\r\n                    try {\r\n                        this.visitState(p);\r\n                    } catch (e) {\r\n                        if (e instanceof RecognitionException) {\r\n                            this.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;\r\n                            this.context.exception = e;\r\n                            this.errorHandler.reportError(this, e);\r\n                            this.recover(e);\r\n                        } else {\r\n                            throw e;\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Update the list of next symbols if there's a label or rule ahead.\r\n            p = this.atnState;\r\n            if (p.numberOfTransitions === 1) {\r\n                const transition = p.transition(0);\r\n                switch (transition.serializationType) {\r\n                    case TransitionType.RULE:\r\n                    case TransitionType.ATOM:\r\n                    case TransitionType.NOT_SET:\r\n                    case TransitionType.RANGE:\r\n                    case TransitionType.SET:\r\n                    case TransitionType.WILDCARD: {\r\n                        const lastStackFrame = this.callStack[this.callStack.length - 1];\r\n                        lastStackFrame.current = lastStackFrame.next;\r\n                        this.computeNextSymbols(lastStackFrame, transition);\r\n                        if (runMode === RunMode.StepIn) {\r\n                            if (breakPointPending) {\r\n                                this.eventSink(\"stopOnBreakpoint\");\r\n                            } else {\r\n                                this.eventSink(\"stopOnStep\");\r\n                            }\r\n\r\n                            return this.rootContext;\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case TransitionType.EPSILON: { // Stop on the rule's semicolon.\r\n                        if (transition.target.stateType === ATNStateType.RULE_STOP) {\r\n                            const isBreakPoint = this.breakPoints.has(transition.target);\r\n                            if (runMode === RunMode.StepIn || isBreakPoint) {\r\n                                const lastStackFrame = this.callStack[this.callStack.length - 1];\r\n                                lastStackFrame.current = lastStackFrame.next;\r\n                                this.computeNextSymbols(lastStackFrame, transition);\r\n                                if (isBreakPoint) {\r\n                                    this.eventSink(\"stopOnBreakpoint\");\r\n                                } else {\r\n                                    this.eventSink(\"stopOnStep\");\r\n                                }\r\n\r\n                                return this.rootContext;\r\n                            }\r\n                        }\r\n\r\n                        break;\r\n                    }\r\n\r\n                    default:\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public override sempred(_localctx: RuleContext | undefined, ruleIndex: number, predIndex: number): boolean {\r\n        if (this.runPredicate) {\r\n            if (predIndex < this.predicates.length) {\r\n                let predicate = this.predicates[predIndex].context!.text;\r\n                if (predicate.length > 2) {\r\n                    predicate = predicate.substr(1, predicate.length - 2); // Remove outer curly braces.\r\n                    try {\r\n                        return this.runPredicate(predicate);\r\n                    } catch (e) {\r\n                        throw Error(`There was an error while evaluating predicate \"${predicate}\". ` +\r\n                            \"Evaluation returned: \" + String(e));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override action(_localctx: RuleContext | undefined, _ruleIndex: number, _actionIndex: number): void {\r\n        // not used yet\r\n    }\r\n\r\n    private ruleNameFromIndex(ruleIndex: number): string | undefined {\r\n        if (ruleIndex < 0 || ruleIndex >= this.ruleNames.length) {\r\n            return;\r\n        }\r\n\r\n        return this.ruleNames[ruleIndex];\r\n    }\r\n\r\n    /**\r\n     * Determines which symbols correspond to the target state we reach from the given transition.\r\n     * Even though the prediction algorithm determines a single path through the ATN we may get\r\n     * more than one result for ambiguities, since at the moment we only know a part of the path.\r\n     *\r\n     * @param frame The frame from which to compute the next symbol list.\r\n     * @param transition The transition to the next ATN state for which we want the symbol.\r\n     */\r\n    private computeNextSymbols(frame: IInternalStackFrame, transition: Transition) {\r\n        frame.next = [];\r\n\r\n        const terminalMatches = (node: TerminalNode): boolean => {\r\n            const type = this.tokenIndexFromName(node.symbol.text!);\r\n            const currentType = this.inputStream.LA(1);\r\n            if (type === currentType\r\n                && transition.matches(currentType, Lexer.MIN_CHAR_VALUE, Lexer.MAX_CHAR_VALUE)) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        };\r\n\r\n        for (const source of frame.current) {\r\n            const candidates = this.nextCandidates(source);\r\n            for (const candidate of candidates) {\r\n                if (candidate instanceof RuleReferenceSymbol) {\r\n                    frame.next.push(candidate);\r\n                } else {\r\n                    if (candidate.name === \";\") { // Special case: end of rule.\r\n                        frame.next.push(candidate);\r\n                    } else if (candidate.context instanceof TerminalRuleContext) {\r\n                        if (candidate.context.TOKEN_REF()) {\r\n                            if (terminalMatches(candidate.context.TOKEN_REF()!)) {\r\n                                frame.next.push(candidate);\r\n                            }\r\n                        }\r\n                    } else if (candidate.context instanceof TerminalNode) {\r\n                        if (terminalMatches(candidate.context)) {\r\n                            frame.next.push(candidate);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param start The symbol to start searching from.\r\n     * @returns A list of reachable leaf symbols from the given symbol.\r\n     */\r\n    private nextCandidates(start: BaseSymbol): BaseSymbol[] {\r\n        const result: BaseSymbol[] = [];\r\n\r\n        // We can get a rule symbol as start, which means we want to get the candidates\r\n        // from the rule's block, instead its sibling (which is another rule).\r\n        let next: BaseSymbol | undefined;\r\n        if (start instanceof RuleSymbol) {\r\n            next = start.children[1]; // 3 children in a rule: the colon, the rule block and the semicolon.\r\n        } else {\r\n            // unknown other case. Continue with the next directly following symbol.\r\n            next = start.nextSibling;\r\n\r\n            // Check EBNF suffixes first.\r\n            if (next instanceof EbnfSuffixSymbol) {\r\n                switch (next.name[0]) {\r\n                    case \"?\": { // The previous symbol was optional. We are done with it.\r\n                        next = next.nextSibling;\r\n                        break;\r\n                    }\r\n\r\n                    case \"+\":\r\n                    case \"*\": { // A loop - the previous symbol is again a candidate.\r\n                        result.push(start);\r\n                        next = next.nextSibling;\r\n                        break;\r\n                    }\r\n\r\n                    default: {\r\n                        break;\r\n                    }\r\n                }\r\n            } else if (next instanceof VariableSymbol) {\r\n                // Skip over variables (element labels) and their operator.\r\n                next = next.nextSibling;\r\n                if (next) {\r\n                    next = next.nextSibling;\r\n                }\r\n            } else if (next instanceof ParserActionSymbol || next instanceof LexerActionSymbol) {\r\n                // Also skip over action blocks.\r\n                next = next.nextSibling;\r\n            } else if (next instanceof ParserPredicateSymbol || next instanceof LexerPredicateSymbol) {\r\n                // Need 2 skips for predicates.\r\n                next = next.nextSibling;\r\n                if (next) {\r\n                    next = next.nextSibling;\r\n                }\r\n            }\r\n\r\n            if (!next) {\r\n                // Nothing more in the current alt. Walk up the parent chain until we find a block with content.\r\n                let block = start;\r\n                while (true) {\r\n                    if (block.parent instanceof RuleSymbol && block.lastSibling) {\r\n                        result.push(block.lastSibling); // The semicolon.\r\n\r\n                        return result;\r\n                    }\r\n\r\n                    block = (block.parent as ScopedSymbol).parent!;\r\n                    next = block.nextSibling;\r\n                    if (next) {\r\n                        if (next instanceof EbnfSuffixSymbol) {\r\n                            switch (next.name[0]) {\r\n                                case \"?\": {\r\n                                    next = next.nextSibling;\r\n                                    break;\r\n                                }\r\n\r\n                                case \"+\":\r\n                                case \"*\": {\r\n                                    // Include the candidates from the previous block again.\r\n                                    result.push(...this.candidatesFromBlock(block as ScopedSymbol));\r\n                                    next = next.nextSibling;\r\n                                    break;\r\n                                }\r\n\r\n                                default: {\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (next) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (next instanceof BlockSymbol) {\r\n            result.push(...this.candidatesFromBlock(next));\r\n        } else {\r\n            result.push(next);\r\n        }\r\n\r\n        // Check cardinality which allows optional elements.\r\n        next = next.nextSibling;\r\n        if (next instanceof EbnfSuffixSymbol) {\r\n            if (next.name[0] === \"?\" || next.name[0] === \"*\") {\r\n                const subResult = this.nextCandidates(next);\r\n                result.push(...subResult);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private candidatesFromBlock(block: ScopedSymbol): BaseSymbol[] {\r\n        const result: BaseSymbol[] = [];\r\n        for (const symbol of block.children) {\r\n            let next = (symbol instanceof ScopedSymbol) ? symbol.firstChild : undefined;\r\n            if (next instanceof VariableSymbol) { // Jump over variable assignments.\r\n                next = next.nextSibling;\r\n                if (next) {\r\n                    next = next.nextSibling;\r\n                }\r\n            } else if (next instanceof ParserActionSymbol || next instanceof LexerActionSymbol) {\r\n                // Also skip over action blocks.\r\n                next = next.nextSibling;\r\n            } else if (next instanceof ParserPredicateSymbol || next instanceof LexerPredicateSymbol) {\r\n                // Need 2 skips for predicates.\r\n                next = next.nextSibling;\r\n                if (next) {\r\n                    next = next.nextSibling;\r\n                }\r\n            }\r\n\r\n            if (next) {\r\n                if (next instanceof BlockSymbol) {\r\n                    result.push(...this.candidatesFromBlock(next));\r\n                } else {\r\n                    result.push(next);\r\n                }\r\n\r\n                // Check cardinality which allows optional elements.\r\n                next = next.nextSibling;\r\n                if (next instanceof EbnfSuffixSymbol) {\r\n                    if (next.name[0] === \"?\" || next.name[0] === \"*\") {\r\n                        const subResult = this.nextCandidates(next);\r\n                        result.push(...subResult);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private tokenIndexFromName(tokenName: string): number {\r\n        const vocab = this.vocabulary;\r\n        for (let i = 0; i <= vocab.maxTokenType; ++i) {\r\n            if (vocab.getSymbolicName(i) === tokenName) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        // Implicit literals don't have a symbolic name.\r\n        // Therefor we do another search run here for the literal \"name\".\r\n        for (let i = 0; i <= vocab.maxTokenType; ++i) {\r\n            if (vocab.getLiteralName(i) === tokenName) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n}\r\n\r\nexport class InterpreterLexerErrorListener implements ANTLRErrorListener<number> {\r\n    public constructor(private eventSink: (event: string | symbol, ...args: unknown[]) => void) {\r\n    }\r\n\r\n    public syntaxError<T extends number>(recognizer: Recognizer<T, ATNSimulator>, offendingSymbol: T | undefined,\r\n        line: number, charPositionInLine: number, msg: string, _e: RecognitionException | undefined): void {\r\n        this.eventSink(\"output\", `Lexer error (${line}, ${charPositionInLine + 1}): ${msg}`,\r\n            recognizer.inputStream!.sourceName, line, charPositionInLine, true);\r\n    }\r\n}\r\n\r\nexport class InterpreterParserErrorListener implements ANTLRErrorListener<CommonToken> {\r\n    public constructor(private eventSink: (event: string | symbol, ...args: unknown[]) => void) {\r\n    }\r\n\r\n    public syntaxError<T extends Token>(recognizer: Recognizer<T, ATNSimulator>, offendingSymbol: T | undefined,\r\n        line: number, charPositionInLine: number, msg: string, _e: RecognitionException | undefined): void {\r\n        this.eventSink(\"output\", `Parser error (${line}, ${charPositionInLine + 1}): ${msg}`,\r\n            recognizer.inputStream!.sourceName, line, charPositionInLine, true);\r\n    }\r\n}\r\n"]}