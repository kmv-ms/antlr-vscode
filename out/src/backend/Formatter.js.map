{"version":3,"file":"Formatter.js","sourceRoot":"","sources":["../../../src/backend/Formatter.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\nimport { IFormattingOptions } from \"./types\";\r\n\r\nimport { Token } from \"antlr4ts\";\r\nimport { Interval } from \"antlr4ts/misc\";\r\n\r\nimport { ANTLRv4Lexer } from \"../parser/ANTLRv4Lexer\";\r\n\r\n/** Insert markers are what the output pipeline (see below) is made of (if not direct token indices). */\r\ntype InsertMarker = number;\r\n\r\nconst formatIntroducer = \"$antlr-format\";\r\n\r\n/** Enum used to address a specific alignment status in the alignment map. */\r\nenum AlignmentType {\r\n    Colon,\r\n    FirstToken,\r\n    Label,\r\n    LexerCommand,\r\n    Action,\r\n    TrailingComment,\r\n\r\n    /** Align all of label, action, trailing comment and lexer command (whatever comes first). */\r\n    Trailers\r\n}\r\n\r\n/** All alignments in the order they will be evaluated. */\r\nconst allAlignments = [\r\n    AlignmentType.Colon, AlignmentType.FirstToken, AlignmentType.Label, AlignmentType.Action,\r\n    AlignmentType.LexerCommand, AlignmentType.TrailingComment, AlignmentType.Trailers,\r\n];\r\n\r\n/**\r\n * Holds line number and group index for a specific alignment. For each alignment type there's an own\r\n * status, to allow multiple alignments per line and ordered processing.\r\n */\r\ninterface IAlignmentStatus {\r\n    /** The line number of the last alignment entry in the current group (if there's one currently). */\r\n    lastLine: number;\r\n\r\n    /** A list of output pipeline indices for groups of alignments. */\r\n    groups: number[][];\r\n}\r\n\r\nexport class GrammarFormatter {\r\n    // Some predefined insert markers:\r\n    // Token markers (EOF is -1).\r\n    public static readonly LineBreak = -2;\r\n\r\n    public static readonly Space = -3;\r\n    public static readonly Tab = -4;\r\n\r\n    public static readonly Undefined = 0;\r\n\r\n    // Markers for a group of elements.\r\n    public static readonly Whitespace = -100;\r\n    public static readonly Comment = -101;\r\n\r\n    // Action markers.\r\n    public static readonly WhitespaceEraser = -102; // Marker for any future whitespace to be ignored.\r\n    public static readonly Error = -103;\r\n\r\n    // Block markers.\r\n    public static readonly Range = -100000;           // Indirect index into the range list.\r\n    public static readonly Alignment = -200000;       // Indirect index into the alignment groups list.\r\n    public static readonly WhitespaceBlock = -300000;  // Indirect index into the whitespace list.\r\n\r\n    private options: IFormattingOptions;\r\n\r\n    // The pipeline contains markers for constructing the final text.\r\n    // A marker is either an index in the token list (if >= 0) or one of the special markers\r\n    // (when < 0), like space, line break, alignment and range markers.\r\n    private outputPipeline: InsertMarker[];\r\n\r\n    private currentIndentation: number;\r\n    private formattingDisabled: boolean; // When true no formatting takes place.\r\n\r\n    private currentLine: number;\r\n    private currentColumn: number;\r\n\r\n    // When a block has been determined to fit as a whole on a single line (relevant only if\r\n    // allowShortBlocksOnASingleLine is true), this var directs line break handling.\r\n    // Note: counting begins on the most outer block that can be formatted on a single line, which is not necessarily\r\n    //       the rule itself.\r\n    private singleLineBlockNesting: number;\r\n\r\n    // A list of index pairs describing start and end of a token sequence in the original token stream.\r\n    // This is mostly used to avoid having to place a large list of action tokens in the generated list.\r\n    private ranges: Array<[InsertMarker, InsertMarker]>;\r\n    private currentRangeIndex: InsertMarker; // When scanning a range this contains the start token index.\r\n    private rangeStart: number; // Holds the start index of a range when collecting.\r\n\r\n    // For each possible alignment type (colon, first token, trailing predicate, trailing comment etc.)\r\n    // there's one status record in this map.\r\n    private alignments = new Map<AlignmentType, IAlignmentStatus>();\r\n    private whitespaceList: string[]; // A list of strings containing whitespaces to insert for alignment.\r\n\r\n    public constructor(private tokens: Token[]) { }\r\n\r\n    /**\r\n     * This is the main formatting routine.\r\n     *\r\n     * @param options Options that control the formatting process. Can be overridden in the code.\r\n     * @param start The character index in the input to start from.\r\n     * @param stop The character index in the input to end with.\r\n     * @returns A tuple containing the formatted text as well as new start/stop indices that should be used\r\n     *          to replace the old text range.\r\n     */\r\n    public formatGrammar(options: IFormattingOptions, start: number, stop: number): [string, number, number] {\r\n        if (this.tokens.length === 0) {\r\n            return [\"\", -1, -1];\r\n        }\r\n\r\n        this.setDefaultOptions();\r\n        this.options = Object.assign(this.options, options); // Overwrite default values with passed in values.\r\n        if (this.options.columnLimit! <= 0) {\r\n            this.options.columnLimit = 1e30;\r\n        }\r\n\r\n        this.outputPipeline = [];\r\n        this.currentIndentation = 0;\r\n        this.singleLineBlockNesting = 0;\r\n\r\n        this.ranges = [];\r\n        this.currentRangeIndex = GrammarFormatter.Undefined;\r\n        this.rangeStart = -1;\r\n\r\n        this.alignments.clear();\r\n        this.whitespaceList = [];\r\n\r\n        // Position info of the target text.\r\n        this.currentColumn = 0;\r\n        this.currentLine = 1;\r\n        this.formattingDisabled = false;\r\n\r\n        let coalesceWhitespaces = false; // Set in situations where we don't want multiple consecutive whitespaces.\r\n        let inBraces = false; // Set between {} (e.g. in options).\r\n        let inRule = false;   // Set when we are processing a lexer or parser rule.\r\n        let inNamedAction = false; // Ditto for a named action.\r\n        let inLexerCommand = false; // Ditto for a lexer command (the part starting with ->).\r\n        let inCatchFinally = false; // Ditto for catch/finally blocks.\r\n\r\n        let inSingleLineRule = false; // Set when an entire rule is placed on a single line.\r\n        let minLineInsertionPending = false; // Set when the min line setting must be enforced after next line break.\r\n\r\n        // Start by determining the actual formatting range. This is specified for the unformatted text,\r\n        // which allows the caller to use it directly to replace the old text.\r\n        let startIndex = this.tokenFromIndex(start, true);\r\n        const endIndex = this.tokenFromIndex(stop, false);\r\n\r\n        // Adjust the start index if we are within a single line comment which is part of a comment block\r\n        // and we are reflowing comment text. Include all single line comment entries of that block.\r\n        // For other comment types this is not necessary, as they are blocks by nature.\r\n        if (this.options.reflowComments && this.tokens[startIndex].type === ANTLRv4Lexer.LINE_COMMENT) {\r\n            let runningIndex = startIndex;\r\n            while (runningIndex > 0) {\r\n                if (this.tokens[runningIndex--].text!.indexOf(formatIntroducer) >= 0) {\r\n                    break; // Don't include comment lines containing (potential) formatting instructions.\r\n                }\r\n\r\n                // The comment must be the only non-whitespace token on the line.\r\n                if (this.tokens[runningIndex].type !== ANTLRv4Lexer.WS\r\n                    || this.tokens[runningIndex].line + 1 !== this.tokens[runningIndex + 1].line) {\r\n                    break;\r\n                }\r\n                startIndex = runningIndex + 1;\r\n\r\n                if (this.tokens[--runningIndex].type !== ANTLRv4Lexer.LINE_COMMENT) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        let targetStart = this.tokens[startIndex].startIndex;\r\n        let startRow = this.tokens[startIndex].line;\r\n        const targetStop = this.tokens[endIndex].stopIndex;\r\n\r\n        // If the start token doesn't begin at the first column walk back in the text to ensure the target\r\n        // range starts directly after a line break, to allow fixing the indentation on the start line.\r\n        targetStart -= this.tokens[startIndex].charPositionInLine;\r\n\r\n        // Next step is to determine the context the start token is in.\r\n        let run = startIndex;\r\n        let done = false;\r\n        while (run > 0 && !done) {\r\n            switch (this.tokens[run].type) {\r\n                case ANTLRv4Lexer.SEMI: {\r\n                    // Top level or options block.\r\n                    let localRun = run;\r\n                    while (localRun-- > 0 && !done) {\r\n                        switch (this.tokens[localRun].type) {\r\n                            case ANTLRv4Lexer.LBRACE: {\r\n                                // In an options {} rule. Increase indentation if the token is not\r\n                                // on the same line as the start token (in which case we would do that\r\n                                // in the main formatting loop then).\r\n                                if (this.tokens[localRun].line < startRow) {\r\n                                    ++this.currentIndentation;\r\n                                    inBraces = true;\r\n                                }\r\n\r\n                                // Determine if we are in an assignment or between them.\r\n                                localRun = startIndex;\r\n                                let type = 0;\r\n                                do {\r\n                                    type = this.tokens[localRun].type;\r\n                                    if (type !== ANTLRv4Lexer.WS\r\n                                        && type !== ANTLRv4Lexer.LINE_COMMENT\r\n                                        && type !== ANTLRv4Lexer.BLOCK_COMMENT\r\n                                        && type !== ANTLRv4Lexer.DOC_COMMENT) {\r\n                                        break;\r\n                                    }\r\n                                } while (localRun-- > 0);\r\n                                coalesceWhitespaces = type !== ANTLRv4Lexer.SEMI;\r\n                                done = true;\r\n                                break;\r\n                            }\r\n\r\n                            // These are indicators for not being in a braced block.\r\n                            case ANTLRv4Lexer.BEGIN_ACTION:\r\n                            case ANTLRv4Lexer.END_ACTION:\r\n                            case ANTLRv4Lexer.COLON:\r\n                            case ANTLRv4Lexer.COLONCOLON:\r\n                            case ANTLRv4Lexer.OR: {\r\n                                done = true;\r\n                                break;\r\n                            }\r\n\r\n                            default: {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    done = true;\r\n                    break;\r\n                }\r\n                case ANTLRv4Lexer.COLON: // Also pretty clear. We are in a rule.\r\n                    if (this.tokens[run].line < startRow) {\r\n                        ++this.currentIndentation;\r\n                        inRule = true;\r\n                        coalesceWhitespaces = true;\r\n                    }\r\n                    done = true;\r\n                    break;\r\n                case ANTLRv4Lexer.AT: // A named action. Want this to be formatted as a whole.\r\n                    startRow = this.tokens[run].line;\r\n                    startIndex = run;\r\n                    targetStart = this.tokens[run].startIndex;\r\n                    done = true;\r\n                    break;\r\n                case ANTLRv4Lexer.LBRACE:\r\n                case ANTLRv4Lexer.BEGIN_ACTION:\r\n                    // A braced block (e.g. tokens, channels etc.).\r\n                    if (this.tokens[run].line < startRow) {\r\n                        ++this.currentIndentation;\r\n                        inBraces = true;\r\n                    }\r\n                    done = true;\r\n                    break;\r\n                case ANTLRv4Lexer.RBRACE:\r\n                case ANTLRv4Lexer.END_ACTION:\r\n                    done = true;\r\n                    break;\r\n                case ANTLRv4Lexer.LPAREN:\r\n                    if (this.tokens[run].line < startRow) {\r\n                        ++this.currentIndentation;\r\n                    }\r\n                    --run;\r\n                    break;\r\n                case ANTLRv4Lexer.RPAREN:\r\n                    if (this.tokens[run].line < startRow) {\r\n                        --this.currentIndentation;\r\n                    }\r\n                    --run;\r\n                    break;\r\n                default:\r\n                    --run;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Here starts the main formatting loop.\r\n        this.currentLine = startRow;\r\n        this.pushCurrentIndentation();\r\n        for (let i = startIndex; i <= endIndex; ++i) {\r\n            const token = this.tokens[i];\r\n\r\n            // If no whitespace is coming up we don't need the eraser marker anymore.\r\n            if (token.type !== ANTLRv4Lexer.WS && this.lastEntryIs(GrammarFormatter.WhitespaceEraser)) {\r\n                this.outputPipeline.pop();\r\n            }\r\n\r\n            if (minLineInsertionPending && token.type !== ANTLRv4Lexer.WS && token.type !== ANTLRv4Lexer.LINE_COMMENT) {\r\n                minLineInsertionPending = false;\r\n                this.ensureMinEmptyLines();\r\n            }\r\n\r\n            switch (token.type) {\r\n                case ANTLRv4Lexer.WS: {\r\n                    if (i === 0 || this.formattingDisabled) {\r\n                        // Ignore leading whitespaces at the beginning of the grammar.\r\n                        break;\r\n                    }\r\n\r\n                    const nextType = this.tokens[i + 1].type;\r\n                    const localCommentAhead = (nextType === ANTLRv4Lexer.LINE_COMMENT\r\n                        || nextType === ANTLRv4Lexer.BLOCK_COMMENT || nextType === ANTLRv4Lexer.DOC_COMMENT);\r\n\r\n                    if (this.lastEntryIs(GrammarFormatter.WhitespaceEraser)) {\r\n                        // And ignore these incoming whitespaces if there is an eraser marker\r\n                        // (unless comments after a line break follow, which we want to stay on their line).\r\n                        this.outputPipeline.pop();\r\n\r\n                        if (!localCommentAhead) {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    // Analyze whitespaces, we can have a mix of tab/space and line breaks here.\r\n                    const text = token.text!.replace(\"\\r\\n\", \"\\n\");\r\n                    const hasLineBreaks = text.indexOf(\"\\n\") >= 0;\r\n                    if (!localCommentAhead || !hasLineBreaks) {\r\n                        if (!hasLineBreaks || coalesceWhitespaces || this.singleLineBlockNesting > 0) {\r\n                            if (!this.lastEntryIs(GrammarFormatter.Whitespace)) {\r\n                                this.addSpace();\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    const parts = text.split(\"\\n\");\r\n                    let breakCount = 0;\r\n\r\n                    // Limit the number of line breaks before a comment right after a left parenthesis.\r\n                    if (localCommentAhead && this.lastCodeTokenIs(ANTLRv4Lexer.LPAREN)\r\n                        && !this.options.keepEmptyLinesAtTheStartOfBlocks) {\r\n                        breakCount = 1;\r\n                    } else {\r\n                        // Take into account any line breaks that are already in the pipeline.\r\n                        let j = this.outputPipeline.length - 1;\r\n                        while (j >= 0) {\r\n                            if (this.entryIs(j, GrammarFormatter.LineBreak)) {\r\n                                ++breakCount;\r\n                            } else {\r\n                                break;\r\n                            }\r\n                            --j;\r\n                        }\r\n\r\n                        breakCount = Math.max(breakCount, parts.length - 1);\r\n                        breakCount = Math.min(breakCount, this.options.maxEmptyLinesToKeep! + 1);\r\n                    }\r\n                    this.removeTrailingWhitespaces();\r\n\r\n                    const lineBreaks: number[] = Array(breakCount).fill(GrammarFormatter.LineBreak);\r\n                    this.outputPipeline.push(...lineBreaks);\r\n                    this.currentLine += breakCount;\r\n                    this.currentColumn = 0;\r\n\r\n                    // Ensure empty lines only if still have something to format.\r\n                    if (i < endIndex && minLineInsertionPending) {\r\n                        minLineInsertionPending = false;\r\n                        this.ensureMinEmptyLines();\r\n                    }\r\n                    this.pushCurrentIndentation();\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.SEMI: {\r\n                    this.removeTrailingWhitespaces();\r\n\r\n                    // Single line mode here can be caused by 2 situations:\r\n                    // single line block from the last alt or single line rule.\r\n                    // In the first case we have to end single line mode now, otherwise\r\n                    // after the alignment handling.\r\n                    if (!inSingleLineRule) {\r\n                        this.singleLineBlockNesting = 0;\r\n                    }\r\n\r\n                    // Even if the rule is on a single line we have to check for semicolon placement,\r\n                    // because in case of a hanging colon only the body of the rule is on a single line,\r\n                    // while name and semicolon are placed on own lines.\r\n                    const canAlignSemicolon = !inSingleLineRule || this.options.alignColons === \"hanging\";\r\n                    if (canAlignSemicolon && !inBraces && inRule) {\r\n                        switch (this.options.alignSemicolons) {\r\n                            case \"none\": {\r\n                                break;\r\n                            }\r\n\r\n                            case \"ownLine\": {\r\n                                const forceNewLine = !this.options.singleLineOverrulesHangingColon\r\n                                    && this.options.alignColons === \"hanging\";\r\n                                this.addLineBreak(forceNewLine);\r\n                                break;\r\n                            }\r\n                            case \"hanging\": {\r\n                                this.addLineBreak();\r\n                                this.pushCurrentIndentation();\r\n                                break;\r\n                            }\r\n\r\n                            default: {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    this.add(i);\r\n\r\n\r\n                    if (!inBraces && this.currentIndentation > 0) {\r\n                        --this.currentIndentation;\r\n                    }\r\n\r\n                    // Now we can end single line mode in any case (if not done yet above).\r\n                    this.singleLineBlockNesting = 0;\r\n                    inSingleLineRule = false;\r\n\r\n                    if (this.currentIndentation === 0) {\r\n                        minLineInsertionPending = true;\r\n                    } else {\r\n                        this.addLineBreak();\r\n                        this.pushCurrentIndentation();\r\n                    }\r\n\r\n                    coalesceWhitespaces = false;\r\n                    inLexerCommand = false;\r\n                    if (!inBraces) {\r\n                        inRule = false;\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.LBRACE: {\r\n                    if (this.singleLineBlockNesting === 0 && this.options.breakBeforeBraces) {\r\n                        this.removeTrailingWhitespaces();\r\n                        this.addLineBreak();\r\n                        this.pushCurrentIndentation();\r\n                        this.add(i);\r\n                    } else {\r\n                        this.removeTrailingWhitespaces();\r\n                        this.addSpace();\r\n                        this.add(i);\r\n                    }\r\n\r\n                    ++this.currentIndentation;\r\n                    inBraces = true;\r\n\r\n                    if (!this.nonBreakingTrailerAhead(i)) {\r\n                        this.addLineBreak();\r\n                        this.pushCurrentIndentation();\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.RBRACE: {\r\n                    this.removeTrailingWhitespaces();\r\n                    this.addLineBreak();\r\n                    if (this.currentIndentation > 0) {\r\n                        --this.currentIndentation;\r\n                    }\r\n                    this.pushCurrentIndentation();\r\n                    this.add(i);\r\n\r\n                    minLineInsertionPending = this.currentIndentation === 0;\r\n\r\n                    inBraces = false;\r\n                    coalesceWhitespaces = false;\r\n                    inRule = false;\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.BEGIN_ACTION: {\r\n                    if (this.formattingDisabled) {\r\n                        break;\r\n                    }\r\n\r\n                    if (this.options.alignTrailers) {\r\n                        this.addAlignmentEntry(AlignmentType.Trailers);\r\n                    } else if (this.options.alignActions) {\r\n                        this.addAlignmentEntry(AlignmentType.Action);\r\n                    }\r\n\r\n                    this.add(i++);\r\n                    if (inCatchFinally && this.tokens[i].text !== \"\\n\") {\r\n                        this.addLineBreak();\r\n                    }\r\n\r\n                    // Find the action end token (or the last in the given source range).\r\n                    const actionStart = i;\r\n                    while (i <= endIndex\r\n                        && this.tokens[i].type !== Token.EOF\r\n                        && this.tokens[i].type !== ANTLRv4Lexer.END_ACTION) {\r\n                        ++i;\r\n                    }\r\n\r\n                    // Add a new range for the action code.\r\n                    this.addRaw(actionStart, i - 1);\r\n                    if (i <= endIndex) {\r\n                        if (inCatchFinally && this.tokens[i - 1].text !== \"\\n\") {\r\n                            this.addLineBreak();\r\n                        }\r\n                        this.add(i);\r\n                        this.addSpace();\r\n\r\n                        minLineInsertionPending = this.currentIndentation === 0;\r\n                        if (!inRule) {\r\n                            inNamedAction = false;\r\n                            coalesceWhitespaces = false;\r\n                        }\r\n                        inCatchFinally = false;\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.LINE_COMMENT:\r\n                case ANTLRv4Lexer.BLOCK_COMMENT: {\r\n                    this.processFormattingCommands(i);\r\n                    // [falls-through]\r\n                }\r\n\r\n                case ANTLRv4Lexer.DOC_COMMENT: {\r\n                    // If this comment is the first non-whitespace entry on the current line\r\n                    // some extra processing is required.\r\n                    const hasLineContent = this.lineHasNonWhitespaceContent();\r\n                    let comment = token.text!;\r\n                    if (hasLineContent) {\r\n                        if (token.type === ANTLRv4Lexer.LINE_COMMENT) {\r\n                            // There's something before the comment on the current line.\r\n                            // Trigger normal alignment handling then.\r\n                            if (this.options.alignTrailers) {\r\n                                this.addAlignmentEntry(AlignmentType.Trailers);\r\n                            } else if (this.options.alignTrailingComments) {\r\n                                this.addAlignmentEntry(AlignmentType.TrailingComment);\r\n                            }\r\n                        }\r\n                    } else if (comment.indexOf(formatIntroducer) < 0\r\n                        && this.options.reflowComments\r\n                        && token.type === ANTLRv4Lexer.LINE_COMMENT) {\r\n                        // Scan forward and collect all consecutive single line comments lines\r\n                        // which stand alone on a line.\r\n                        while (true) {\r\n                            let nextToken = this.tokens[i + 1];\r\n                            if (nextToken.type === ANTLRv4Lexer.EOF) {\r\n                                break;\r\n                            }\r\n                            const content = nextToken.text!; // Must be whitespaces.\r\n                            if (content.split(\"\\n\").length > 2) { // More than a single line break. Stop here.\r\n                                break;\r\n                            }\r\n\r\n                            nextToken = this.tokens[i + 2];\r\n                            if (nextToken.type !== ANTLRv4Lexer.LINE_COMMENT\r\n                                || nextToken.text!.indexOf(formatIntroducer) >= 0) {\r\n                                break;\r\n                            }\r\n\r\n                            comment += \"\\n\" + nextToken.text!;\r\n                            i += 2;\r\n                            this.processFormattingCommands(i);\r\n                        }\r\n                    }\r\n\r\n                    if (this.options.reflowComments && comment.indexOf(\"\\n\") > 0) {\r\n                        const formatted = this.reflowComment(comment, token.type);\r\n                        const whitespaceIndex = GrammarFormatter.WhitespaceBlock - this.whitespaceList.length;\r\n                        this.outputPipeline.push(whitespaceIndex);\r\n                        this.whitespaceList.push(formatted);\r\n\r\n                        // Update the current line member.\r\n                        for (const char of formatted) {\r\n                            if (char === \"\\n\") {\r\n                                ++this.currentLine;\r\n                            }\r\n                        }\r\n\r\n                        this.addLineBreak();\r\n                        this.pushCurrentIndentation();\r\n                    } else {\r\n                        this.add(i);\r\n                        if (token.type === ANTLRv4Lexer.LINE_COMMENT) {\r\n                            if (this.currentIndentation > 0) {\r\n                                this.addLineBreak();\r\n                                this.pushCurrentIndentation();\r\n                            }\r\n                        } else {\r\n                            this.addSpace();\r\n                        }\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.ASSIGN:\r\n                case ANTLRv4Lexer.PLUS_ASSIGN: {\r\n                    if (this.options.spaceBeforeAssignmentOperators) {\r\n                        if (!this.lastEntryIs(GrammarFormatter.Whitespace)) {\r\n                            this.addSpace();\r\n                        }\r\n                        this.add(i);\r\n                        this.addSpace();\r\n                    } else {\r\n                        if (this.lastEntryIs(GrammarFormatter.Whitespace)) {\r\n                            this.removeLastEntry();\r\n                        }\r\n                        this.add(i);\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.AT: {\r\n                    if (inRule) {\r\n                        this.removeTrailingWhitespaces();\r\n                        if (this.options.ruleInternalsOnSingleLine) {\r\n                            this.addSpace();\r\n                        } else {\r\n                            this.addLineBreak();\r\n                            ++this.currentIndentation;\r\n                            this.pushCurrentIndentation();\r\n                            --this.currentIndentation;\r\n                        }\r\n                    } else {\r\n                        inNamedAction = true;\r\n                    }\r\n\r\n                    this.add(i);\r\n                    this.add(GrammarFormatter.WhitespaceEraser);\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.COLON: {\r\n                    ++this.currentIndentation;\r\n\r\n                    let { singleLineLength } = this.getBlockInfo(i, new Set([ANTLRv4Lexer.SEMI]));\r\n                    singleLineLength += this.currentColumn;\r\n                    if (this.options.allowShortRulesOnASingleLine\r\n                        && singleLineLength <= (2 * this.options.columnLimit! / 3)) {\r\n                        ++this.singleLineBlockNesting;\r\n                        inSingleLineRule = true;\r\n                    }\r\n\r\n                    switch (this.options.alignColons) {\r\n                        case \"hanging\": {\r\n                            this.removeTrailingWhitespaces();\r\n\r\n                            const forceNewLine = !this.options.singleLineOverrulesHangingColon;\r\n                            this.addLineBreak(forceNewLine);\r\n                            this.pushCurrentIndentation(forceNewLine);\r\n                            this.add(i);\r\n                            this.addSpace();\r\n                            break;\r\n                        }\r\n                        case \"none\": {\r\n                            this.removeTrailingWhitespaces();\r\n                            this.add(i);\r\n                            if (!this.nonBreakingTrailerAhead(i) && !inSingleLineRule) {\r\n                                this.addLineBreak();\r\n                                this.pushCurrentIndentation();\r\n                            } else {\r\n                                this.addSpace();\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        case \"trailing\": {\r\n                            this.removeTrailingWhitespaces();\r\n                            if (this.singleLineBlockNesting > 0) {\r\n                                this.addAlignmentEntry(AlignmentType.Colon);\r\n                                this.add(GrammarFormatter.WhitespaceEraser);\r\n                            }\r\n                            this.add(i);\r\n                            if (!this.nonBreakingTrailerAhead(i) && !inSingleLineRule) {\r\n                                this.addLineBreak();\r\n                                this.pushCurrentIndentation();\r\n                            } else {\r\n                                this.addSpace();\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        default: {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    // Aligning the first token only makes sense if the entire rule is on a single line.\r\n                    if (this.options.alignFirstTokens && inSingleLineRule) {\r\n                        this.addAlignmentEntry(AlignmentType.FirstToken);\r\n                        this.add(GrammarFormatter.WhitespaceEraser);\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.COLONCOLON:\r\n                    this.removeTrailingWhitespaces();\r\n                    this.add(i);\r\n                    this.add(GrammarFormatter.WhitespaceEraser);\r\n                    break;\r\n\r\n                case ANTLRv4Lexer.IMPORT:\r\n                case ANTLRv4Lexer.LEXER:\r\n                case ANTLRv4Lexer.PARSER:\r\n                case ANTLRv4Lexer.GRAMMAR:\r\n                case ANTLRv4Lexer.MODE: {\r\n                    if (!inNamedAction && !inRule) {\r\n                        // We increase the current indentation here only to have an easier time\r\n                        // when handling the ending semicolon. Otherwise we would have to add\r\n                        // extra checks to know which command the semicolon ends.\r\n                        ++this.currentIndentation;\r\n\r\n                        inSingleLineRule = true;\r\n                        coalesceWhitespaces = true;\r\n                        inRule = true;\r\n                    }\r\n                    this.add(i);\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.FRAGMENT:\r\n                case ANTLRv4Lexer.PRIVATE:\r\n                case ANTLRv4Lexer.PROTECTED:\r\n                case ANTLRv4Lexer.PUBLIC:\r\n                case ANTLRv4Lexer.TOKEN_REF:\r\n                case ANTLRv4Lexer.RULE_REF: {\r\n                    if (!inNamedAction && !inBraces) {\r\n                        inRule = true;\r\n                    }\r\n                    // [falls-through]\r\n                }\r\n\r\n                case ANTLRv4Lexer.OPTIONS:\r\n                case ANTLRv4Lexer.TOKENS:\r\n                case ANTLRv4Lexer.CHANNELS: {\r\n                    coalesceWhitespaces = true;\r\n                    this.add(i);\r\n                    if (!inLexerCommand) {\r\n                        this.addSpace();\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.PLUS:\r\n                case ANTLRv4Lexer.QUESTION:\r\n                case ANTLRv4Lexer.STAR: {\r\n                    this.removeTrailingWhitespaces();\r\n                    this.add(i);\r\n\r\n                    this.addSpace();\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.OR: {\r\n                    // Starts a new alt. If we are in the first single line nesting level\r\n                    // (not to be confused with block nesting, we can have the first single line block\r\n                    // at, say, block nesting 10), we have to end the current single line block\r\n                    // (which is the previous alt) and see if we can start a new one.\r\n                    if (this.singleLineBlockNesting > 1) {\r\n                        this.addSpace();\r\n                    } else {\r\n                        if (!inSingleLineRule) {\r\n                            // If we are in a single line rule block it means we are not ending a\r\n                            // single line alt block.\r\n                            this.singleLineBlockNesting = 0;\r\n\r\n                            this.removeTrailingTabsAndSpaces();\r\n                            if (this.outputPipeline.length > 0 && !this.lastEntryIs(GrammarFormatter.LineBreak)) {\r\n                                this.addLineBreak();\r\n                            }\r\n                            this.pushCurrentIndentation();\r\n\r\n                            const { containsAlts, singleLineLength } = this.getBlockInfo(i,\r\n                                new Set([ANTLRv4Lexer.OR, ANTLRv4Lexer.SEMI]));\r\n\r\n                            // See if we should enter single line mode.\r\n                            if ((!containsAlts || this.options.allowShortBlocksOnASingleLine)\r\n                                && singleLineLength <= (this.options.columnLimit! / 2 + 3)) {\r\n                                ++this.singleLineBlockNesting;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this.add(i);\r\n                    this.addSpace();\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.LPAREN: {\r\n                    if (inLexerCommand) {\r\n                        this.add(i);\r\n                        break;\r\n                    }\r\n\r\n                    if (this.singleLineBlockNesting > 0) {\r\n                        // If we are already in single line mode add a nesting level.\r\n                        // It's impossible to have a multi line block within a single line block.\r\n                        // The other way around it's well possible, though.\r\n                        // See a few lines below why we increase by 2.\r\n                        this.singleLineBlockNesting += 2;\r\n                        ++this.currentIndentation;\r\n                        this.add(i);\r\n                    } else {\r\n                        // First check if we can put the entire block on a single line (if the block option is set).\r\n                        if (this.options.allowShortBlocksOnASingleLine) {\r\n                            let { singleLineLength } = this.getBlockInfo(i, new Set([ANTLRv4Lexer.RPAREN]));\r\n                            singleLineLength += this.currentColumn;\r\n\r\n                            if (singleLineLength <= (2 * this.options.columnLimit! / 3)) {\r\n                                // Increase by 2: one for the block and one for the first alt.\r\n                                // We increase for the alt even if there's no content or only a single alt.\r\n                                // Doing that simplifies handling when closing the block.\r\n                                this.singleLineBlockNesting += 2;\r\n                            }\r\n                        }\r\n\r\n                        if (this.singleLineBlockNesting === 0) {\r\n                            if (this.options.breakBeforeParens) {\r\n                                this.removeTrailingWhitespaces();\r\n                                this.addLineBreak();\r\n                                this.pushCurrentIndentation();\r\n                            }\r\n\r\n                            this.add(i);\r\n                            ++this.currentIndentation;\r\n\r\n                            this.addLineBreak();\r\n                            this.pushCurrentIndentation();\r\n\r\n                            if (this.options.allowShortBlocksOnASingleLine) {\r\n                                // If the entire block is too long, see if the first alt would fit on a single line.\r\n                                let { singleLineLength } = this.getBlockInfo(i,\r\n                                    new Set([ANTLRv4Lexer.OR, ANTLRv4Lexer.RPAREN]));\r\n                                singleLineLength += this.currentColumn;\r\n                                if (singleLineLength <= (this.options.columnLimit! / 2 + 3)) {\r\n                                    ++this.singleLineBlockNesting;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            this.add(i);\r\n                            this.add(GrammarFormatter.WhitespaceEraser);\r\n                            ++this.currentIndentation;\r\n                        }\r\n\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.RPAREN: {\r\n                    if (inLexerCommand) {\r\n                        this.add(i);\r\n                        break;\r\n                    }\r\n\r\n                    if (this.singleLineBlockNesting > 0) {\r\n                        // If we are in single line mode when we end an alt it means\r\n                        // the nesting counter was increased for it. Hence we can count down here.\r\n                        --this.singleLineBlockNesting;\r\n                    }\r\n\r\n                    if (this.currentIndentation > 0) {\r\n                        --this.currentIndentation;\r\n                    }\r\n\r\n                    this.removeTrailingWhitespaces();\r\n\r\n                    // If the single line counter is still > 0 it means the entire block is\r\n                    // to be formatted on a single line.\r\n                    if (this.singleLineBlockNesting > 0) {\r\n                        this.add(i);\r\n                    } else {\r\n                        this.addLineBreak();\r\n                        this.pushCurrentIndentation();\r\n                        this.add(i);\r\n                    }\r\n\r\n                    this.addSpace();\r\n\r\n                    if (this.singleLineBlockNesting > 0) {\r\n                        // Now decrease single line block counter for the closing parenthesis too.\r\n                        --this.singleLineBlockNesting;\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.GT: {\r\n                    this.removeTrailingWhitespaces();\r\n                    this.add(i);\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.RARROW: {\r\n                    inLexerCommand = true;\r\n                    if (this.options.alignTrailers) {\r\n                        this.addAlignmentEntry(AlignmentType.Trailers);\r\n                    } else if (this.options.alignLexerCommands) {\r\n                        this.addAlignmentEntry(AlignmentType.LexerCommand);\r\n                    } else {\r\n                        if (!this.lastEntryIs(GrammarFormatter.Space)) {\r\n                            this.addSpace();\r\n                        }\r\n                    }\r\n                    this.add(i);\r\n                    this.addSpace();\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.COMMA: {\r\n                    this.removeTrailingWhitespaces();\r\n                    this.add(i);\r\n                    if (inBraces) {\r\n                        coalesceWhitespaces = false; // For tokens block.\r\n                        if (!this.nonBreakingTrailerAhead(i)) {\r\n                            this.addLineBreak();\r\n                            this.pushCurrentIndentation();\r\n                        }\r\n                    } else {\r\n                        this.addSpace();\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.POUND: {\r\n                    // Starting a label. They are not trailing per se, but we treat them so\r\n                    // if not in single line mode, as they look similar like trailing comments.\r\n                    let willUseAlignment = false;\r\n                    if (!inSingleLineRule) {\r\n                        // Labels can only be specified for top level alts, hence we test on the entire\r\n                        // rule if we are in single line mode, not the current alt's mode.\r\n                        if (this.options.alignTrailers) {\r\n                            willUseAlignment = true;\r\n                            this.addAlignmentEntry(AlignmentType.Trailers);\r\n                        } else if (this.options.alignLabels) {\r\n                            willUseAlignment = true;\r\n                            this.addAlignmentEntry(AlignmentType.Label);\r\n                        }\r\n                    }\r\n\r\n                    if (!willUseAlignment && !this.lastEntryIs(GrammarFormatter.Space)) {\r\n                        this.addSpace();\r\n                    }\r\n                    this.add(i);\r\n                    this.addSpace();\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.BEGIN_ARGUMENT: {\r\n                    if (this.formattingDisabled) {\r\n                        break;\r\n                    }\r\n\r\n                    this.removeTrailingWhitespaces();\r\n                    this.add(i++);\r\n\r\n                    // Find the argument end token.\r\n                    const argumentStartIndex = i;\r\n                    while (this.tokens[i].type !== Token.EOF && this.tokens[i].type !== ANTLRv4Lexer.END_ARGUMENT) {\r\n                        ++i;\r\n                    }\r\n\r\n                    // Add a new range for the action code.\r\n                    this.addRaw(argumentStartIndex, i);\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.CATCH:\r\n                case ANTLRv4Lexer.FINALLY: {\r\n                    inCatchFinally = true;\r\n                    this.removeTrailingWhitespaces();\r\n                    this.addLineBreak();\r\n                    this.add(i);\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.RETURNS:\r\n                case ANTLRv4Lexer.LOCALS: {\r\n                    this.removeTrailingWhitespaces();\r\n                    if (this.options.ruleInternalsOnSingleLine) {\r\n                        this.addSpace();\r\n                    } else {\r\n                        this.addLineBreak();\r\n                        ++this.currentIndentation;\r\n                        this.pushCurrentIndentation();\r\n                        --this.currentIndentation;\r\n                    }\r\n                    this.add(i);\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.STRING_LITERAL:\r\n                    this.add(i);\r\n                    this.addSpace();\r\n                    break;\r\n\r\n                case Token.EOF:\r\n                    // Ensure a line break at the end of the text.\r\n                    this.removeTrailingWhitespaces();\r\n                    this.addLineBreak();\r\n                    break;\r\n\r\n                default:\r\n                    coalesceWhitespaces = true;\r\n                    this.add(i);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (this.lastEntryIs(GrammarFormatter.WhitespaceEraser)) {\r\n            this.removeLastEntry();\r\n        }\r\n\r\n        // If we ended with an alignment entry, we apply it only if the selected range ends in whitespaces.\r\n        if (this.tokens[endIndex].type !== ANTLRv4Lexer.WS) {\r\n            // If the end index is not at a whitespace then we neither apply any trailing alignments nor\r\n            // keep trailing whitespaces in our output pipeline.\r\n            if (this.lastEntryIs(GrammarFormatter.Alignment)) {\r\n                this.removeLastEntry();\r\n            }\r\n            this.removeTrailingWhitespaces();\r\n        }\r\n\r\n        // If formatting was disabled and never enabled again we have to add the raw text to\r\n        // output pipeline as well.\r\n        if (this.formattingDisabled && this.rangeStart > -1) {\r\n            this.addRaw(this.rangeStart, endIndex);\r\n        }\r\n\r\n        // Output phase: compose all collected entries into a result string.\r\n        // Start with computing all alignments.\r\n        this.computeAlignments();\r\n\r\n        let result = \"\";\r\n        let pendingLineComment = -1;\r\n        let hadErrorOnLine = false;\r\n        for (const entry of this.outputPipeline) {\r\n            switch (entry) {\r\n                case GrammarFormatter.LineBreak:\r\n                    if (pendingLineComment > 0) {\r\n                        if (result.length > 0) {\r\n                            const lastChar = result[result.length - 1];\r\n                            if (lastChar !== \" \" && lastChar !== \"\\t\" && lastChar !== \"\\n\") {\r\n                                result += \" \";\r\n                            }\r\n                        }\r\n                        result += this.tokens[pendingLineComment].text;\r\n                        pendingLineComment = -1;\r\n                    }\r\n                    result += \"\\n\";\r\n                    hadErrorOnLine = false;\r\n                    break;\r\n                case GrammarFormatter.Space:\r\n                    result += \" \";\r\n                    break;\r\n                case GrammarFormatter.Tab:\r\n                    result += \"\\t\";\r\n                    break;\r\n                case GrammarFormatter.WhitespaceEraser: // Ignore.\r\n                    break;\r\n                case GrammarFormatter.Error:\r\n                    if (!hadErrorOnLine) { // Don't output more than one error per line.\r\n                        result += \"<<Unexpected input or wrong formatter command>>\";\r\n                        hadErrorOnLine = true;\r\n                    }\r\n                    break;\r\n                default:\r\n                    if (entry < 0) {\r\n                        // One of the block markers. Alignment blocks are removed at this point and\r\n                        // replaced by whitespace indices.\r\n                        if (this.isWhitespaceBlock(entry)) {\r\n                            result += this.whitespaceList[-(entry - GrammarFormatter.WhitespaceBlock)];\r\n                        } else if (this.isRangeBlock(entry)) {\r\n                            // Copy an entire block.\r\n                            const rangeIndex = -(entry - GrammarFormatter.Range);\r\n                            const tokenStart = this.ranges[rangeIndex][0];\r\n                            const tokenEnd = this.ranges[rangeIndex][1];\r\n                            const interval = Interval.of(this.tokens[tokenStart].startIndex,\r\n                                this.tokens[tokenEnd].stopIndex);\r\n                            result += this.tokens[0].inputStream!.getText(interval);\r\n                        }\r\n                    } else {\r\n                        if (this.tokens[entry].type === ANTLRv4Lexer.LINE_COMMENT) {\r\n                            // Ensure we don't print out a line comment before anything\r\n                            // but a line break.\r\n                            pendingLineComment = entry;\r\n                            break;\r\n                        }\r\n                        result += this.tokens[entry].text;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (pendingLineComment > 0) {\r\n            if (result.length > 0) {\r\n                const lastChar = result[result.length - 1];\r\n                if (lastChar !== \" \" && lastChar !== \"\\t\" && lastChar !== \"\\n\") {\r\n                    result += \" \";\r\n                }\r\n            }\r\n            result += this.tokens[pendingLineComment].text;\r\n        }\r\n\r\n        return [result, targetStart, targetStop];\r\n    }\r\n\r\n    private setDefaultOptions() {\r\n        this.options = {};\r\n        this.options.alignTrailingComments = false;\r\n        this.options.allowShortBlocksOnASingleLine = true;\r\n        this.options.breakBeforeBraces = false;\r\n        this.options.columnLimit = 100;\r\n        this.options.indentWidth = 4;\r\n        this.options.continuationIndentWidth = this.options.indentWidth;\r\n        this.options.keepEmptyLinesAtTheStartOfBlocks = false;\r\n        this.options.maxEmptyLinesToKeep = 1;\r\n        this.options.reflowComments = true;\r\n        this.options.spaceBeforeAssignmentOperators = true;\r\n        this.options.tabWidth = 4;\r\n        this.options.useTab = true;\r\n\r\n        this.options.alignColons = \"none\";\r\n        this.options.allowShortRulesOnASingleLine = true;\r\n        this.options.alignSemicolons = \"ownLine\";\r\n        this.options.singleLineOverrulesHangingColon = true;\r\n        this.options.breakBeforeParens = false;\r\n        this.options.ruleInternalsOnSingleLine = false;\r\n        this.options.minEmptyLines = 0;\r\n        this.options.groupedAlignments = true;\r\n        this.options.alignFirstTokens = false;\r\n        this.options.alignLexerCommands = false;\r\n        this.options.alignActions = false;\r\n        this.options.alignLabels = true;\r\n        this.options.alignTrailers = false;\r\n    }\r\n\r\n    /**\r\n     * Is the value at the given index in the token list of the given type?\r\n     *\r\n     * @param index The index for the value.\r\n     * @param marker The marker type for which to test.\r\n     *\r\n     * @returns True if the value is of the given type.\r\n     */\r\n    private entryIs(index: number, marker: InsertMarker): boolean {\r\n        if (index < 0 || index >= this.outputPipeline.length) {\r\n            return false;\r\n        }\r\n\r\n        const entry = this.outputPipeline[index];\r\n        switch (marker) {\r\n            case GrammarFormatter.Whitespace: {\r\n                return entry === GrammarFormatter.LineBreak || entry === GrammarFormatter.Space\r\n                    || entry === GrammarFormatter.Tab;\r\n            }\r\n\r\n            case GrammarFormatter.Space: {\r\n                return entry === GrammarFormatter.Space;\r\n            }\r\n\r\n            case GrammarFormatter.Tab: {\r\n                return entry === GrammarFormatter.Tab;\r\n            }\r\n\r\n            case GrammarFormatter.LineBreak: {\r\n                return entry === GrammarFormatter.LineBreak;\r\n            }\r\n\r\n            case GrammarFormatter.Comment: {\r\n                if (entry < 0) {\r\n                    return false;\r\n                }\r\n                const token = this.tokens[entry];\r\n\r\n                return token.type === ANTLRv4Lexer.BLOCK_COMMENT || token.type === ANTLRv4Lexer.LINE_COMMENT\r\n                    || token.type === ANTLRv4Lexer.DOC_COMMENT;\r\n            }\r\n\r\n            default: {\r\n                if (entry < 0) {\r\n                    return entry === marker;\r\n                }\r\n                const token = this.tokens[entry];\r\n\r\n                return token.type === marker;\r\n            }\r\n        }\r\n    }\r\n\r\n    private lastEntryIs(marker: InsertMarker): boolean {\r\n        return this.entryIs(this.outputPipeline.length - 1, marker);\r\n    }\r\n\r\n    private lineHasNonWhitespaceContent(): boolean {\r\n        let index = this.outputPipeline.length;\r\n        while (--index > 0) {\r\n            if (this.outputPipeline[index] !== GrammarFormatter.Space\r\n                && this.outputPipeline[index] !== GrammarFormatter.Tab) {\r\n                break;\r\n            }\r\n        }\r\n        if (index <= 0) {\r\n            return false;\r\n        }\r\n\r\n        return this.outputPipeline[index] !== GrammarFormatter.LineBreak;\r\n    }\r\n\r\n    /**\r\n     * Skips over all comments and whitespaces backwards and checks the value of the value after that.\r\n     *\r\n     * @param marker The marker type for which to test.\r\n     *\r\n     * @returns True if the last non-whitespace token is of the given type.\r\n     */\r\n    private lastCodeTokenIs(marker: InsertMarker): boolean {\r\n        let i = this.outputPipeline.length - 1;\r\n        while (i >= 0) {\r\n            if (!this.entryIs(i, GrammarFormatter.WhitespaceEraser)\r\n                && !this.entryIs(i, GrammarFormatter.Whitespace)\r\n                && !this.entryIs(i, GrammarFormatter.LineBreak)\r\n                && !this.entryIs(i, GrammarFormatter.Comment)) {\r\n                break;\r\n            }\r\n            --i;\r\n        }\r\n        if (i < 0 || this.outputPipeline[i] < 0) {\r\n            return false;\r\n        }\r\n\r\n        return this.tokens[this.outputPipeline[i]].type === marker;\r\n    }\r\n\r\n    private removeLastEntry() {\r\n        if (this.formattingDisabled) {\r\n            return;\r\n        }\r\n\r\n        const lastEntry = this.outputPipeline[this.outputPipeline.length - 1];\r\n        this.outputPipeline.pop();\r\n        switch (lastEntry) {\r\n            case GrammarFormatter.WhitespaceEraser:\r\n                break; // Ignore.\r\n            case GrammarFormatter.LineBreak:\r\n                --this.currentLine;\r\n                break;\r\n            case GrammarFormatter.Tab: {\r\n                const offset = this.currentColumn % this.options.tabWidth!;\r\n                this.currentColumn -= (offset > 0 ? offset : this.options.tabWidth!);\r\n                break;\r\n            }\r\n\r\n            default:\r\n                --this.currentColumn;\r\n                break;\r\n        }\r\n        console.assert(this.currentLine >= 0, \"Current line can never be less than 0\");\r\n        console.assert(this.currentColumn >= 0, \"Current column can never be less than 0\");\r\n    }\r\n\r\n    /**\r\n     * Scans backwards and removes any pipeline entry up to the first non-space entry.\r\n     */\r\n    private removeTrailingTabsAndSpaces() {\r\n        if (this.formattingDisabled) {\r\n            return;\r\n        }\r\n\r\n        while (this.lastEntryIs(GrammarFormatter.Space) || this.lastEntryIs(GrammarFormatter.Tab)) {\r\n            this.removeLastEntry();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Scans backwards and removes any pipeline entry up to the first non-whitespace entry.\r\n     */\r\n    private removeTrailingWhitespaces() {\r\n        if (this.formattingDisabled) {\r\n            return;\r\n        }\r\n\r\n        while (this.lastEntryIs(GrammarFormatter.Whitespace)) {\r\n            this.removeLastEntry();\r\n        }\r\n    }\r\n\r\n    private pushCurrentIndentation(force = false) {\r\n        if (this.formattingDisabled || (!force && this.singleLineBlockNesting > 0)) {\r\n            return;\r\n        }\r\n\r\n        if (this.options.useTab) {\r\n            const tabs: number[] = Array(this.currentIndentation).fill(GrammarFormatter.Tab);\r\n            this.outputPipeline.push(...tabs);\r\n            this.currentColumn = this.currentIndentation * this.options.tabWidth!;\r\n        } else {\r\n            const spaces: number[] = Array(this.currentIndentation * (this.options.indentWidth ?? 4))\r\n                .fill(GrammarFormatter.Space);\r\n            this.outputPipeline.push(...spaces);\r\n            this.currentColumn = this.currentIndentation * this.options.indentWidth!;\r\n        }\r\n    }\r\n\r\n    private applyLineContinuation() {\r\n        while (this.lastEntryIs(GrammarFormatter.Space) || this.lastEntryIs(GrammarFormatter.Tab)) {\r\n            this.removeLastEntry();\r\n        }\r\n\r\n        if (!this.lastEntryIs(GrammarFormatter.LineBreak)) {\r\n            this.outputPipeline.push(GrammarFormatter.LineBreak);\r\n            ++this.currentLine;\r\n        }\r\n        this.currentColumn = 0;\r\n        this.pushCurrentIndentation(true);\r\n        if (this.options.useTab) {\r\n            this.outputPipeline.push(GrammarFormatter.Tab);\r\n        } else {\r\n            const spaces: number[] = Array(this.options.continuationIndentWidth).fill(GrammarFormatter.Space);\r\n            this.outputPipeline.push(...spaces);\r\n        }\r\n        this.currentColumn += this.options.continuationIndentWidth!;\r\n    }\r\n\r\n    /**\r\n     * Adds the given marker to the output pipeline and updates current line + column.\r\n     *\r\n     * @param marker The marker to add.\r\n     */\r\n    private add(marker: InsertMarker) {\r\n        if (this.formattingDisabled) {\r\n            return;\r\n        }\r\n\r\n        /**\r\n         * Helper function to insert a block with embedded line breaks.\r\n         *\r\n         * @param token The token for which to enter the block.\r\n         */\r\n        const insertBlock = (token: Token): void => {\r\n            const parts = token.text!.split(\"\\n\");\r\n            if (parts.length === 1) {\r\n                this.currentColumn += token.text!.length;\r\n            } else {\r\n                this.currentLine += parts.length - 1;\r\n                this.currentColumn = this.computeLineLength(parts[parts.length - 1]);\r\n            }\r\n            this.outputPipeline.push(marker);\r\n        };\r\n\r\n        switch (marker) {\r\n            case GrammarFormatter.WhitespaceEraser: { // Doesn't move current position.\r\n                this.outputPipeline.push(marker);\r\n\r\n                return;\r\n            }\r\n\r\n            case GrammarFormatter.LineBreak: {\r\n                this.outputPipeline.push(marker);\r\n                ++this.currentLine;\r\n                this.currentColumn = 0;\r\n\r\n                return;\r\n            }\r\n\r\n            default: {\r\n                let token: Token | undefined;\r\n                if (marker >= 0) {\r\n                    token = this.tokens[marker];\r\n                }\r\n\r\n                if (token) {\r\n                    switch (token.type) {\r\n                        case ANTLRv4Lexer.BLOCK_COMMENT: {\r\n                            insertBlock(token);\r\n\r\n                            return;\r\n                        }\r\n\r\n                        case ANTLRv4Lexer.ACTION_CONTENT: { // Action content can contain line breaks.\r\n                            insertBlock(this.tokens[marker]);\r\n\r\n                            return;\r\n                        }\r\n\r\n                        default: {\r\n                            const tokenLength = token.stopIndex - token.startIndex + 1;\r\n                            if (this.currentColumn + tokenLength > this.options.columnLimit!) {\r\n                                // Note: this implementation works on non-aligned content and allows alignments\r\n                                // after the word wrapping.\r\n                                // In cases where alignment moves text beyond the column limit, we don't do\r\n                                // another word wrapping round. Instead we let alignments overrule the column limit.\r\n                                // The same applies for exceeding of the column limit caused by deep/large indentation,\r\n                                // where the indentation already goes beyond that limit.\r\n                                if (this.lineHasNonWhitespaceContent()) {\r\n                                    this.applyLineContinuation();\r\n                                }\r\n                            }\r\n                            this.currentColumn += tokenLength;\r\n                            this.outputPipeline.push(marker);\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    ++this.currentColumn;\r\n                    this.outputPipeline.push(marker);\r\n                }\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the index for the token which covers the given character index.\r\n     * If no token can be found for that position return the EOF token index.\r\n     *\r\n     * @param charIndex The character index to examine.\r\n     * @param first If this is true the search behavior is changed and returns the first token on the line\r\n     *              where the found token is on.\r\n     *\r\n     * @returns The index of the token as requested.\r\n     */\r\n    private tokenFromIndex(charIndex: number, first: boolean): number {\r\n        // Sanity checks first.\r\n        if (charIndex < 0) {\r\n            return 0;\r\n        }\r\n        if (charIndex >= this.tokens[0].inputStream!.size) {\r\n            return this.tokens.length - 1;\r\n        }\r\n\r\n        for (let i = 0; i < this.tokens.length; ++i) {\r\n            const token = this.tokens[i];\r\n            if (token.startIndex > charIndex) {\r\n                if (i === 0) {\r\n                    return i;\r\n                }\r\n                --i;\r\n\r\n                if (!first) {\r\n                    return i;\r\n                }\r\n\r\n                const row = this.tokens[i].line;\r\n                while (i > 0 && this.tokens[i - 1].line === row) {\r\n                    --i;\r\n                }\r\n\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return this.tokens.length - 1;\r\n    }\r\n\r\n    /**\r\n     * Computes the length of the given text, with tab stops.\r\n     * There must be no line breaks in the text.\r\n     *\r\n     * @param text The line for which to return the length.\r\n     *\r\n     * @returns The computed length, which is equal to the line length if there are no tabs in the text.\r\n     */\r\n    private computeLineLength(text: string): number {\r\n        let length = 0;\r\n        for (const char of text) {\r\n            if (char === \"\\t\") {\r\n                // Round up column offset to next tab stop.\r\n                const offsetToNextTabStop = this.options.tabWidth! - (this.currentColumn % this.options.tabWidth!);\r\n                length += offsetToNextTabStop;\r\n            } else {\r\n                ++length;\r\n            }\r\n        }\r\n\r\n        return length;\r\n    }\r\n\r\n    /**\r\n     * Used only for real tokens (indices), e.g. in non-formatting mode.\r\n     * Inserts a range for the given start and end markers.\r\n     * No processing takes place, except for line/column updates.\r\n     *\r\n     * @param start The start index for the raw range.\r\n     * @param stop The end index for the raw range.\r\n     */\r\n    private addRaw(start: InsertMarker, stop: InsertMarker): void {\r\n        const interval = Interval.of(this.tokens[start].startIndex, this.tokens[stop].stopIndex);\r\n        const text = this.tokens[0].inputStream!.getText(interval);\r\n\r\n        if (text.indexOf(\"\\n\") >= 0) {\r\n            const parts = text.split(\"\\n\");\r\n            this.currentLine += parts.length - 1;\r\n            this.currentColumn = this.computeLineLength(parts[parts.length - 1]);\r\n        } else {\r\n            this.currentColumn += this.computeLineLength(text);\r\n        }\r\n        this.ranges.push([start, stop]);\r\n        this.outputPipeline.push(GrammarFormatter.Range - this.currentRangeIndex++);\r\n    }\r\n\r\n    private addSpace() {\r\n        if (this.outputPipeline.length > 0\r\n            && !this.lastEntryIs(GrammarFormatter.Space)\r\n            && !this.lastEntryIs(ANTLRv4Lexer.LINE_COMMENT)) {\r\n            this.add(GrammarFormatter.Space);\r\n        }\r\n    }\r\n\r\n    private addLineBreak(force = false) {\r\n        if (this.singleLineBlockNesting === 0 || force) {\r\n            // If the current line ends with tabs/spaces, remove them first.\r\n            while (this.lastEntryIs(GrammarFormatter.Space) || this.lastEntryIs(GrammarFormatter.Tab)) {\r\n                this.removeLastEntry();\r\n            }\r\n            this.add(GrammarFormatter.LineBreak);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ensure there are at least as many empty lines as specified in the options,\r\n     * but not more than max empty lines.\r\n     */\r\n    private ensureMinEmptyLines(): void {\r\n        if (this.formattingDisabled) {\r\n            return;\r\n        }\r\n\r\n        if (this.options.minEmptyLines! > 0) {\r\n            let lineBreakCount = Math.min(this.options.minEmptyLines!, this.options.maxEmptyLinesToKeep!) + 1;\r\n            for (let i = this.outputPipeline.length - 1; i > 0 && lineBreakCount > 0; --i) {\r\n                if (this.entryIs(i, GrammarFormatter.LineBreak)) {\r\n                    --lineBreakCount;\r\n                } else if (!this.entryIs(i, GrammarFormatter.Whitespace)) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            const lineBreaks: number[] = Array(lineBreakCount).fill(GrammarFormatter.LineBreak);\r\n            this.outputPipeline.push(...lineBreaks);\r\n            this.currentLine += lineBreakCount;\r\n            if (lineBreakCount > 0) {\r\n                this.currentColumn = 0;\r\n            }\r\n        } else if (!this.lastEntryIs(GrammarFormatter.LineBreak)) {\r\n            this.addLineBreak();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starting from position i this methods scans forward in the input token list to determine\r\n     * if the current block contains alternatives and how long it would be (in characters) if the block would be\r\n     * formatted on a single line.\r\n     * If there's a single line comment before the stoppers we cannot put the block on a single line.\r\n     * If there's one after the stopper account for that too.\r\n     *\r\n     * @param i The position to start scanning from. Should point to either a colon or an opening parenthesis.\r\n     * @param stoppers A set of token types that make the scan stop.\r\n     *\r\n     * @returns An object containing a flag the indicates if the given block contains alternatives and a number\r\n     *          that gives the length of the block if it was to be formatted all on a single line.\r\n     */\r\n    private getBlockInfo(i: number, stoppers: Set<number>): { containsAlts: boolean; singleLineLength: number; } {\r\n        let containsAlts = false;\r\n        let singleLineLength = 1;\r\n        let nestingLevel = 0;\r\n\r\n        let token = this.tokens[i];\r\n        if (token.type === ANTLRv4Lexer.COLON || token.type === ANTLRv4Lexer.OR) {\r\n            ++singleLineLength; // One for the space after these two.\r\n        }\r\n\r\n        const checkTrailingComment = () => {\r\n            while (this.tokens[++i].type === ANTLRv4Lexer.WS) {\r\n                if (this.tokens[i].text!.indexOf(\"\\n\") >= 0) {\r\n                    break;\r\n                }\r\n            }\r\n            if (this.tokens[i].type === ANTLRv4Lexer.LINE_COMMENT) {\r\n                singleLineLength += this.tokens[i].text!.length;\r\n            }\r\n        };\r\n\r\n        while (++i < this.tokens.length) {\r\n            token = this.tokens[i];\r\n            switch (token.type) {\r\n                case ANTLRv4Lexer.WS: {\r\n                    // Ignore whitespaces here. We pretend there is always a single space char\r\n                    // between tokens and we will add them below (except for certain tokens).\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.LPAREN: {\r\n                    ++nestingLevel;\r\n                    ++singleLineLength;\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.RPAREN: {\r\n                    // No need to add a space here (we have one from the previous token).\r\n                    ++singleLineLength;\r\n\r\n                    if (nestingLevel > 0) {\r\n                        --nestingLevel;\r\n                    } else {\r\n                        // No check here if RPAREN is in the list of stoppers.\r\n                        // If it is we return. If not and we got an RPAREN at nesting level 0\r\n                        // we found an unbalanced block and return also.\r\n                        checkTrailingComment();\r\n\r\n                        return { containsAlts, singleLineLength };\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.SEMI: {\r\n                    ++singleLineLength;\r\n                    if (stoppers.has(ANTLRv4Lexer.SEMI)) {\r\n                        checkTrailingComment();\r\n\r\n                        return { containsAlts, singleLineLength };\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.QUESTION:\r\n                case ANTLRv4Lexer.STAR:\r\n                case ANTLRv4Lexer.PLUS: {\r\n                    ++singleLineLength; // No addition for a space. That happened already.\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.LINE_COMMENT: {\r\n                    // Single line comments cannot be formatted on a single line (they would hide what follows).\r\n                    // Signal that by a large overall length.\r\n                    return { containsAlts, singleLineLength: 1e100 };\r\n                }\r\n\r\n                case ANTLRv4Lexer.BLOCK_COMMENT:\r\n                case ANTLRv4Lexer.DOC_COMMENT: {\r\n                    // If the comment contains a line break we cannot format the block as single line.\r\n                    if (token.text!.indexOf(\"\\n\") >= 0) {\r\n                        return { containsAlts, singleLineLength: 1e100 };\r\n                    } else {\r\n                        singleLineLength += token.text!.length + 1;\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.BEGIN_ACTION:\r\n                case ANTLRv4Lexer.ACTION_CONTENT:\r\n                case ANTLRv4Lexer.END_ACTION: {\r\n                    // No extra space. These are entire blocks we take over as they are.\r\n                    if (token.text === \"\\n\") {\r\n                        return { containsAlts, singleLineLength: 1e100 };\r\n                    } else {\r\n                        ++singleLineLength;\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.OR: {\r\n                    if (nestingLevel === 0) {\r\n                        if (stoppers.has(ANTLRv4Lexer.OR)) {\r\n                            checkTrailingComment();\r\n\r\n                            return { containsAlts, singleLineLength };\r\n                        }\r\n                        containsAlts = true;\r\n                    }\r\n                    singleLineLength += 2;\r\n                    break;\r\n                }\r\n\r\n                case ANTLRv4Lexer.NOT: {\r\n                    ++singleLineLength; // Unary NOT, no space after that.\r\n                    break;\r\n                }\r\n\r\n                default:\r\n                    if (token.text) {\r\n                        singleLineLength += token.text.length;\r\n                    }\r\n                    ++singleLineLength; // Add one for a space char which must follow this token.\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // We should never arrive here, since we bail out above when the block end was found.\r\n        return { containsAlts, singleLineLength };\r\n    }\r\n\r\n    /**\r\n     * Determines if there is an element after the given position which should go\r\n     * on the current line (line comment, lexer commands).\r\n     *\r\n     * @param i The position to start from.\r\n     *\r\n     * @returns True if there's something should be kept on the same line.\r\n     */\r\n    private nonBreakingTrailerAhead(i: number): boolean {\r\n        if (this.tokens[++i].type === ANTLRv4Lexer.WS) {\r\n            if (this.tokens[i].text!.indexOf(\"\\n\") >= 0) {\r\n                return false;\r\n            }\r\n            ++i;\r\n        }\r\n\r\n        return this.tokens[i].type === ANTLRv4Lexer.LINE_COMMENT\r\n            || this.tokens[i].type === ANTLRv4Lexer.RARROW\r\n            || this.tokens[i].type === ANTLRv4Lexer.LPAREN;\r\n    }\r\n\r\n    /**\r\n     * Scans the given comment for any of the formatter commands and parses them out.\r\n     *\r\n     * @param index The index of the comment token.\r\n     */\r\n    private processFormattingCommands(index: number): void {\r\n\r\n        const resetAlignmentStatus = (alignments: AlignmentType[]): void => {\r\n            for (const type of alignments) {\r\n                const status = this.alignments.get(type);\r\n                if (status) {\r\n                    status.lastLine = -1;\r\n                }\r\n            }\r\n        };\r\n\r\n        let text = this.tokens[index].text!;\r\n        text = text.substr(2, text.length - 2).trim();\r\n        if (text.startsWith(formatIntroducer)) {\r\n            const entries = text.substr(formatIntroducer.length + 1, text.length).split(\",\");\r\n            for (const entry of entries) {\r\n                const groups = /(\\w+)(?:(?:\\s*:)?\\s*)?(\\w+|[0-9]+)?/i.exec(entry.trim());\r\n                if (groups) {\r\n                    switch (groups[1]) {\r\n                        case \"reset\": {\r\n                            this.setDefaultOptions();\r\n                            break;\r\n                        }\r\n                        case \"on\":\r\n                        case \"true\": {\r\n                            this.formattingDisabled = false;\r\n                            if (this.rangeStart > -1) {\r\n                                this.addRaw(this.rangeStart, index - 1);\r\n                            }\r\n                            break;\r\n                        }\r\n                        case \"off\":\r\n                        case \"false\": {\r\n                            this.formattingDisabled = true;\r\n                            this.rangeStart = index;\r\n                            break;\r\n                        }\r\n\r\n                        case \"alignTrailingComments\":\r\n                        case \"allowShortBlocksOnASingleLine\":\r\n                        case \"breakBeforeBraces\":\r\n                        case \"keepEmptyLinesAtTheStartOfBlocks\":\r\n                        case \"reflowComments\":\r\n                        case \"spaceBeforeAssignmentOperators\":\r\n                        case \"useTab\":\r\n                        case \"allowShortRulesOnASingleLine\":\r\n                        case \"singleLineOverrulesHangingColon\":\r\n                        case \"breakBeforeParens\":\r\n                        case \"ruleInternalsOnSingleLine\":\r\n                        case \"groupedAlignments\":\r\n                        case \"alignFirstTokens\":\r\n                        case \"alignLexerCommands\":\r\n                        case \"alignActions\":\r\n                        case \"alignLabels\":\r\n                        case \"alignTrailers\": {\r\n                            if ((\r\n                                groups.length > 2 && (groups[2] === \"true\" || groups[2] === \"false\")\r\n                            )\r\n                                || groups[2] === \"on\"\r\n                                || groups[2] === \"off\") {\r\n                                this.options[groups[1]] = (groups[2] === \"true\" || groups[2] === \"on\");\r\n\r\n                                // Some additional handling for alignments. Switching an alignment means\r\n                                // that the alignment group for that alignment is finished.\r\n                                switch (groups[1]) {\r\n                                    case \"groupedAlignments\": {\r\n                                        resetAlignmentStatus(allAlignments);\r\n                                        break;\r\n                                    }\r\n                                    case \"alignTrailingComments\": {\r\n                                        resetAlignmentStatus([AlignmentType.TrailingComment]);\r\n                                        break;\r\n                                    }\r\n                                    case \"alignFirstTokens\": {\r\n                                        resetAlignmentStatus([AlignmentType.FirstToken]);\r\n                                        break;\r\n                                    }\r\n                                    case \"alignLexerCommands\": {\r\n                                        resetAlignmentStatus([AlignmentType.LexerCommand]);\r\n                                        break;\r\n                                    }\r\n                                    case \"alignActions\": {\r\n                                        resetAlignmentStatus([AlignmentType.Action]);\r\n                                        break;\r\n                                    }\r\n                                    case \"alignLabels\": {\r\n                                        resetAlignmentStatus([AlignmentType.Label]);\r\n                                        break;\r\n                                    }\r\n                                    case \"alignTrailers\": {\r\n                                        resetAlignmentStatus([AlignmentType.Trailers]);\r\n                                        break;\r\n                                    }\r\n                                    default: {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                this.add(GrammarFormatter.Error);\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        case \"columnLimit\":\r\n                        case \"continuationIndentWidth\":\r\n                        case \"indentWidth\":\r\n                        case \"maxEmptyLinesToKeep\":\r\n                        case \"tabWidth\":\r\n                        case \"minEmptyLines\": {\r\n                            if (groups.length > 2) {\r\n                                const value = parseInt(groups[2], 10);\r\n                                if (value !== undefined) {\r\n                                    this.options[groups[1]] = value;\r\n                                } else {\r\n                                    this.add(GrammarFormatter.Error);\r\n                                }\r\n                            } else {\r\n                                this.add(GrammarFormatter.Error);\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        case \"alignColons\": {\r\n                            if (groups.length > 2) {\r\n                                const value = groups[2];\r\n                                if (value === \"none\" || value === \"trailing\" || value === \"hanging\") {\r\n                                    this.options.alignColons = value;\r\n                                } else {\r\n                                    this.add(GrammarFormatter.Error);\r\n                                }\r\n                            } else {\r\n                                this.add(GrammarFormatter.Error);\r\n                            }\r\n                            break;\r\n                        }\r\n                        case \"alignSemicolons\": {\r\n                            if (groups.length > 2) {\r\n                                const value = groups[2];\r\n                                if (value === \"none\" || value === \"ownLine\" || value === \"hanging\") {\r\n                                    this.options.alignSemicolons = value;\r\n                                } else {\r\n                                    this.add(GrammarFormatter.Error);\r\n                                }\r\n                            } else {\r\n                                this.add(GrammarFormatter.Error);\r\n                            }\r\n                            break;\r\n                        }\r\n                        default: {\r\n                            this.add(GrammarFormatter.Error);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Inserts an alignment marker for the current alignment group for the given type.\r\n     * If there's currently no active group a new one is started. This happens also if the current\r\n     * position does not qualify for the current group.\r\n     *\r\n     * @param type The type of the alignment to add.\r\n     */\r\n    private addAlignmentEntry(type: AlignmentType): void {\r\n        if (!this.alignments.has(type)) {\r\n            this.alignments.set(type, { lastLine: -1, groups: [] });\r\n        }\r\n\r\n        const status = this.alignments.get(type)!;\r\n\r\n        // While we allow multiple different alignment types on a single line, we don't want the same type\r\n        // more than once on a line.\r\n        if (status.lastLine !== this.currentLine) {\r\n            if (this.lineHasNonWhitespaceContent()) {\r\n                // Don't remove any indentation.\r\n                this.removeTrailingTabsAndSpaces();\r\n            }\r\n\r\n            let startNewGroup = true;\r\n            if (status.lastLine > -1) {\r\n                // There's an active group. See if we can append the new entry to it.\r\n                if (!this.options.groupedAlignments || status.lastLine + 1 === this.currentLine) {\r\n                    // We can extend the active group.\r\n                    startNewGroup = false;\r\n\r\n                    // Groups consist of indices into the output pipeline.\r\n                    status.groups[status.groups.length - 1].push(this.outputPipeline.length);\r\n                }\r\n            }\r\n\r\n            if (startNewGroup) {\r\n                status.groups.push([this.outputPipeline.length]);\r\n            }\r\n            this.outputPipeline.push(GrammarFormatter.Alignment);\r\n\r\n            status.lastLine = this.currentLine;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Goes through the alignment groups for each alignment type. Each member is examined to find the column to\r\n     * align to. The alignment markers in the output pipeline are replaced by indices into our whitespace list, which\r\n     * gets the text to insert for a specific position. This way we don't change the output pipeline (which would\r\n     * invalidate group indices).\r\n     */\r\n    private computeAlignments(): void {\r\n        for (const type of allAlignments) {\r\n            const alignment = this.alignments.get(type);\r\n            if (alignment) {\r\n                for (const group of alignment.groups) {\r\n                    // If the group only consists of a single member then ignore it.\r\n                    if (group.length === 1) {\r\n                        if (group[0] < this.outputPipeline.length) {\r\n                            if (this.entryIs(group[0] - 1, GrammarFormatter.Whitespace)\r\n                                || this.entryIs(group[0] - 1, ANTLRv4Lexer.LPAREN)) {\r\n                                this.outputPipeline[group[0]] = GrammarFormatter.WhitespaceEraser;\r\n                            } else {\r\n                                this.outputPipeline[group[0]] = GrammarFormatter.Space;\r\n                            }\r\n                        }\r\n                        continue;\r\n                    }\r\n\r\n                    const columns: number[] = [];\r\n                    for (const member of group) {\r\n                        // For partial formatting it can happen we removed the last alignment entry\r\n                        // in the pipeline. However the associated alignment group still exists and\r\n                        // may here try to access a non-existing pipeline entry.\r\n                        if (member < this.outputPipeline.length) {\r\n                            console.assert(this.outputPipeline[member] <= GrammarFormatter.Alignment);\r\n                            columns.push(this.columnForEntry(member));\r\n                        }\r\n                    }\r\n\r\n                    // Determine the largest column and bring this up to the next tab stop (if we are using tabs)\r\n                    // or add a single space to the highest column value and align all others to this position.\r\n                    const useTabs = this.options.useTab;\r\n                    let maxColumn = Math.max(...columns);\r\n                    if (useTabs) {\r\n                        maxColumn += this.options.tabWidth! - (maxColumn % this.options.tabWidth!);\r\n                    } else {\r\n                        ++maxColumn;\r\n                    }\r\n\r\n                    // Compute required whitespace inserts and store them in the whitespace list.\r\n                    // Replace the alignment markers in the current group with the indices in that list.\r\n                    for (let i = 0; i < group.length; ++i) {\r\n                        const whitespaceIndex = GrammarFormatter.WhitespaceBlock - this.whitespaceList.length;\r\n                        this.outputPipeline[group[i]] = whitespaceIndex;\r\n\r\n                        let whitespaces;\r\n                        if (useTabs) {\r\n                            let tabCount = Math.floor((maxColumn - columns[i]) / this.options.tabWidth!);\r\n                            if ((maxColumn - columns[i]) % this.options.tabWidth! !== 0) {\r\n                                ++tabCount;\r\n                            }\r\n                            whitespaces = Array(tabCount).fill(\"\\t\").join(\"\");\r\n                        } else {\r\n                            whitespaces = Array(maxColumn - columns[i]).fill(\" \").join(\"\");\r\n                        }\r\n                        this.whitespaceList.push(whitespaces);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determines the column offset of the given entry in the output pipeline.\r\n     *\r\n     * @param offset The offset for which to return the column.\r\n     *\r\n     * @returns The computed column.\r\n     */\r\n    private columnForEntry(offset: number): number {\r\n        let result = 0;\r\n\r\n        // Scan back to last line break.\r\n        let run = offset;\r\n        while (--run > -1) {\r\n            if (this.outputPipeline[run] === GrammarFormatter.LineBreak) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Now sum up the individual entries. Need to collect text here since ranges\r\n        // as well as lexer tokens can contain tabs.\r\n        let text = \"\";\r\n        while (++run < offset) {\r\n            const entry = this.outputPipeline[run];\r\n            switch (entry) {\r\n                case GrammarFormatter.Space:\r\n                    text += \" \";\r\n                    break;\r\n                case GrammarFormatter.Tab:\r\n                    text += \"\\t\";\r\n                    break;\r\n                case GrammarFormatter.WhitespaceEraser: // Ignore.\r\n                case GrammarFormatter.Error:\r\n                    break;\r\n                default:\r\n                    // We cannot see alignment markers here (as we are currently processing one),\r\n                    // nor whitespace blocks (we are inserting them afterwards).\r\n                    if (entry < 0) {\r\n                        if (this.isRangeBlock(entry)) {\r\n                            // Copy an entire block.\r\n                            const rangeIndex = -(entry - GrammarFormatter.Range);\r\n                            const startIndex = this.ranges[rangeIndex][0];\r\n                            const endIndex = this.ranges[rangeIndex][1];\r\n                            const interval = Interval.of(this.tokens[startIndex].startIndex,\r\n                                this.tokens[endIndex].stopIndex);\r\n                            text += this.tokens[0].inputStream!.getText(interval);\r\n                        } else if (this.isWhitespaceBlock(entry)) {\r\n                            const whitespaceIndex = -(entry - GrammarFormatter.WhitespaceBlock);\r\n                            text += this.whitespaceList[whitespaceIndex];\r\n                        }\r\n                    } else {\r\n                        text += this.tokens[entry].text;\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n\r\n        for (const char of text) {\r\n            if (char === \"\\t\") {\r\n                result += this.options.tabWidth! - (result % this.options.tabWidth!);\r\n            } else {\r\n                ++result;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Reformats the given comment so that it does not go beyond the column limit, but fills the available space.\r\n     * It will fix indentation as well as leading * on block/doc comments. Lines starting with a dash will be kept\r\n     * on an own line, to avoid breaking lists/enumerations (but the column limit is still enforced).\r\n     *\r\n     * The function should only be called for comments spanning at least 2 lines.\r\n     *\r\n     * @param comment The comment to reformat.\r\n     * @param type Specifies what type of comment we have (a collection of single line comments or a block/doc comment).\r\n     * @returns The formatted comment.\r\n     */\r\n    private reflowComment(comment: string, type: number): string {\r\n        const result: string[] = [];\r\n        let lineIntroducer = (type === ANTLRv4Lexer.LINE_COMMENT) ? \"// \" : \" * \";\r\n        const lines = comment.split(\"\\n\");\r\n\r\n        let lineIndex = 0;\r\n        let pipeline = lines[lineIndex++].split(/ |\\t/).filter((entry: string) => {\r\n            return entry.length > 0;\r\n        });\r\n        let line: string;\r\n\r\n        // We use a leading star only if the second line has one. Otherwise they are all removed (if any).\r\n        if (type !== ANTLRv4Lexer.LINE_COMMENT) {\r\n            if (!lines[1].trim().startsWith(\"*\")) {\r\n                lineIntroducer = \" \";\r\n            }\r\n\r\n            const last = lines[lines.length - 1].trim().slice(0, -2);\r\n            if (last.length === 0) {\r\n                lines.pop();\r\n            } else {\r\n                lines[lines.length - 1] = last;\r\n            }\r\n        }\r\n\r\n        // Take over everything unchanged until the first space or line break.\r\n        // If there's only the comment introducer on the first line, keep it that way and start\r\n        // on the next line with the processing.\r\n        let isFirst = false;\r\n        if (pipeline.length === 1) {\r\n            result.push(pipeline[0]);\r\n            line = lineIntroducer;\r\n            isFirst = true;\r\n        } else {\r\n            line = pipeline[0] + \" \";\r\n        }\r\n\r\n        let index = 1;\r\n        let column = this.computeLineLength(line);\r\n        while (true) {\r\n            while (index < pipeline.length) {\r\n                if (this.currentColumn + column + pipeline[index].length > this.options.columnLimit!) {\r\n                    // Don't push the trailing space we added before.\r\n                    result.push(line.slice(0, -1));\r\n                    line = lineIntroducer;\r\n                    column = this.computeLineLength(line);\r\n                }\r\n                line += pipeline[index++] + \" \";\r\n                column = this.computeLineLength(line);\r\n            }\r\n\r\n            // Pipeline exhausted. Load next source line.\r\n            if (lineIndex === lines.length) {\r\n                break;\r\n            }\r\n\r\n            pipeline = lines[lineIndex++].split(/ |\\t/).filter((entry: string) => {\r\n                return entry.length > 0;\r\n            });\r\n            index = 0;\r\n\r\n            if (pipeline.length > 0) {\r\n                // Remove line introducer (if there's one). Can make the pipeline empty if it only consists of that.\r\n                const first = pipeline[0];\r\n                if (type === ANTLRv4Lexer.LINE_COMMENT) {\r\n                    if (first === \"//\") {\r\n                        pipeline = pipeline.slice(1);\r\n                    } else {\r\n                        pipeline[0] = first.substr(2);\r\n                    }\r\n                } else {\r\n                    if (first === \"*\") {\r\n                        pipeline = pipeline.slice(1);\r\n                    } else {\r\n                        if (first.startsWith(\"*\")) {\r\n                            pipeline[0] = first.substr(1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (pipeline.length === 0) {\r\n                // Keep empty lines. Push the current line only if this is not still the first line\r\n                // (because we already pushed it already).\r\n                if (!isFirst) {\r\n                    result.push(line.slice(0, -1));\r\n                }\r\n                result.push(lineIntroducer);\r\n                line = lineIntroducer;\r\n            }\r\n            isFirst = false;\r\n        }\r\n\r\n        if (line.length > 0) {\r\n            result.push(line.slice(0, -1));\r\n        }\r\n\r\n        if (type !== ANTLRv4Lexer.LINE_COMMENT) {\r\n            result.push(\" */\");\r\n        }\r\n\r\n        const indentation = (this.options.useTab)\r\n            ? \"\\t\".repeat(this.currentIndentation)\r\n            : \" \".repeat(this.currentIndentation * this.options.indentWidth!);\r\n\r\n        return result.join(\"\\n\" + indentation);\r\n    }\r\n\r\n    /**\r\n     * Tests if the marker belongs to the range block.\r\n     *\r\n     * @param marker The marker to test.\r\n     *\r\n     * @returns True if the marker is a range marker.\r\n     */\r\n    private isRangeBlock = (marker: InsertMarker): boolean => {\r\n        return (marker <= GrammarFormatter.Range) && (marker > GrammarFormatter.Alignment);\r\n    };\r\n\r\n    /**\r\n     * Tests if the marker belongs to the whitespace block.\r\n     *\r\n     * @param marker The marker to test.\r\n     *\r\n     * @returns True if the marker is a whitespace marker.\r\n     */\r\n    private isWhitespaceBlock = (marker: InsertMarker): boolean => {\r\n        return (marker <= GrammarFormatter.WhitespaceBlock);\r\n    };\r\n}\r\n"]}