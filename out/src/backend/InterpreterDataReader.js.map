{"version":3,"file":"InterpreterDataReader.js","sourceRoot":"","sources":["../../../src/backend/InterpreterDataReader.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,uCAAyB;AAGzB,uCAAsD;AACtD,2EAAwE;AAUxE,MAAa,qBAAqB;IAEvB,MAAM,CAAC,SAAS,CAAC,QAAgB;QACpC,MAAM,SAAS,GAAa,EAAE,CAAC;QAC/B,MAAM,QAAQ,GAAa,EAAE,CAAC;QAC9B,MAAM,KAAK,GAAa,EAAE,CAAC;QAE3B,MAAM,YAAY,GAAG,EAAE,CAAC;QACxB,MAAM,aAAa,GAAG,EAAE,CAAC;QACzB,MAAM,MAAM,GAAG,EAAE,CAAC,YAAY,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QACjD,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACjC,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,IAAI,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;QAC1B,IAAI,IAAI,KAAK,sBAAsB,EAAE;YACjC,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;SAC5C;QAED,GAAG;YACC,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;YACtB,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;gBACnB,MAAM;aACT;YACD,YAAY,CAAC,IAAI,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;SAClD,QAAQ,IAAI,EAAE;QAEf,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;QACtB,IAAI,IAAI,KAAK,uBAAuB,EAAE;YAClC,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;SAC5C;QAED,GAAG;YACC,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;YACtB,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;gBACnB,MAAM;aACT;YACD,aAAa,CAAC,IAAI,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;SACnD,QAAQ,IAAI,EAAE;QAEf,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;QACtB,IAAI,IAAI,KAAK,aAAa,EAAE;YACxB,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;SAC5C;QAED,GAAG;YACC,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;YACtB,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;gBACnB,MAAM;aACT;YACD,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACxB,QAAQ,IAAI,EAAE;QAEf,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;QACtB,IAAI,IAAI,KAAK,gBAAgB,EAAE;YAC3B,GAAG;gBACC,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;gBACtB,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;oBACnB,MAAM;iBACT;gBACD,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACvB,QAAQ,IAAI,EAAE;YAEf,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;YACtB,IAAI,IAAI,KAAK,aAAa,EAAE;gBACxB,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;aAC5C;YAED,GAAG;gBACC,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;gBACtB,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;oBACnB,MAAM;iBACT;gBACD,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACpB,QAAQ,IAAI,EAAE;SAClB;QAED,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;QACtB,IAAI,IAAI,KAAK,MAAM,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;SAC5C;QAED,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;QACtB,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACjC,IAAI,KAAK,CAAC;QACV,MAAM,aAAa,GAAG,IAAI,WAAW,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QACvD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YACtC,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAI,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;gBACzB,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;aAC/C;iBAAM,IAAI,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;gBAC9B,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;aACnE;iBAAM;gBACH,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;aAClC;YACD,aAAa,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;SAC5B;QAED,MAAM,YAAY,GAAG,IAAI,qDAAyB,EAAE,CAAC;QAErD,OAAO;YACH,GAAG,EAAE,YAAY,CAAC,WAAW,CAAC,aAAa,CAAC;YAC5C,UAAU,EAAE,IAAI,yBAAc,CAAC,YAAY,EAAE,aAAa,EAAE,EAAE,CAAC;YAC/D,SAAS;YACT,QAAQ;YACR,KAAK;SACR,CAAC;IACN,CAAC;CACJ;AA1GD,sDA0GC","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\nimport * as fs from \"fs\";\r\n\r\nimport { ATN } from \"antlr4ts/atn\";\r\nimport { Vocabulary, VocabularyImpl } from \"antlr4ts\";\r\nimport { CompatibleATNDeserializer } from \"./CompatibleATNDeserializer\";\r\n\r\nexport interface IInterpreterData {\r\n    atn: ATN;\r\n    vocabulary: Vocabulary;\r\n    ruleNames: string[];\r\n    channels: string[]; // Only valid for lexer grammars.\r\n    modes: string[]; // ditto\r\n}\r\n\r\nexport class InterpreterDataReader {\r\n\r\n    public static parseFile(fileName: string): IInterpreterData {\r\n        const ruleNames: string[] = [];\r\n        const channels: string[] = [];\r\n        const modes: string[] = [];\r\n\r\n        const literalNames = [];\r\n        const symbolicNames = [];\r\n        const source = fs.readFileSync(fileName, \"utf8\");\r\n        const lines = source.split(\"\\n\");\r\n        let index = 0;\r\n        let line = lines[index++];\r\n        if (line !== \"token literal names:\") {\r\n            throw new Error(\"Unexpected data entry\");\r\n        }\r\n\r\n        do {\r\n            line = lines[index++];\r\n            if (line.length === 0) {\r\n                break;\r\n            }\r\n            literalNames.push(line === \"null\" ? \"\" : line);\r\n        } while (true);\r\n\r\n        line = lines[index++];\r\n        if (line !== \"token symbolic names:\") {\r\n            throw new Error(\"Unexpected data entry\");\r\n        }\r\n\r\n        do {\r\n            line = lines[index++];\r\n            if (line.length === 0) {\r\n                break;\r\n            }\r\n            symbolicNames.push(line === \"null\" ? \"\" : line);\r\n        } while (true);\r\n\r\n        line = lines[index++];\r\n        if (line !== \"rule names:\") {\r\n            throw new Error(\"Unexpected data entry\");\r\n        }\r\n\r\n        do {\r\n            line = lines[index++];\r\n            if (line.length === 0) {\r\n                break;\r\n            }\r\n            ruleNames.push(line);\r\n        } while (true);\r\n\r\n        line = lines[index++];\r\n        if (line === \"channel names:\") { // Additional lexer data.\r\n            do {\r\n                line = lines[index++];\r\n                if (line.length === 0) {\r\n                    break;\r\n                }\r\n                channels.push(line);\r\n            } while (true);\r\n\r\n            line = lines[index++];\r\n            if (line !== \"mode names:\") {\r\n                throw new Error(\"Unexpected data entry\");\r\n            }\r\n\r\n            do {\r\n                line = lines[index++];\r\n                if (line.length === 0) {\r\n                    break;\r\n                }\r\n                modes.push(line);\r\n            } while (true);\r\n        }\r\n\r\n        line = lines[index++];\r\n        if (line !== \"atn:\") {\r\n            throw new Error(\"Unexpected data entry\");\r\n        }\r\n\r\n        line = lines[index++];\r\n        const elements = line.split(\",\");\r\n        let value;\r\n        const serializedATN = new Uint16Array(elements.length);\r\n        for (let i = 0; i < elements.length; ++i) {\r\n            const element = elements[i];\r\n            if (element.startsWith(\"[\")) {\r\n                value = Number(element.substring(1).trim());\r\n            } else if (element.endsWith(\"]\")) {\r\n                value = Number(element.substring(0, element.length - 1).trim());\r\n            } else {\r\n                value = Number(element.trim());\r\n            }\r\n            serializedATN[i] = value;\r\n        }\r\n\r\n        const deserializer = new CompatibleATNDeserializer();\r\n\r\n        return {\r\n            atn: deserializer.deserialize(serializedATN),\r\n            vocabulary: new VocabularyImpl(literalNames, symbolicNames, []),\r\n            ruleNames,\r\n            channels,\r\n            modes,\r\n        };\r\n    }\r\n}\r\n"]}