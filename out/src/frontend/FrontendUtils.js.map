{"version":3,"file":"FrontendUtils.js","sourceRoot":"","sources":["../../../src/frontend/FrontendUtils.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\nimport * as fs from \"fs-extra\";\r\nimport * as crypto from \"crypto\";\r\nimport * as path from \"path\";\r\n\r\nimport { ExtensionContext, Uri, window, Webview, commands, ProviderResult, TextDocument } from \"vscode\";\r\nimport { AntlrFacade } from \"../backend/facade\";\r\nimport { ILexicalRange, GrammarType } from \"../backend/types\";\r\n\r\nexport interface IRangeHolder {\r\n    range?: ILexicalRange;\r\n}\r\n\r\nexport class FrontendUtils {\r\n\r\n    /**\r\n     * Returns the absolute path to a file located in our misc folder.\r\n     *\r\n     * @param file The base file name.\r\n     * @param context The context of this extension to get its path regardless where it is installed.\r\n     * @param webview When given format the path for use in this webview.\r\n     *\r\n     * @returns The computed path.\r\n     */\r\n    public static getMiscPath(file: string, context: ExtensionContext, webview?: Webview): string {\r\n        if (webview) {\r\n            const uri = Uri.file(context.asAbsolutePath(path.join(\"misc\", file)));\r\n\r\n            return webview.asWebviewUri(uri).toString();\r\n        }\r\n\r\n        return context.asAbsolutePath(path.join(\"misc\", file));\r\n    }\r\n\r\n    /**\r\n     * Returns the absolute path to a file located in our out folder.\r\n     *\r\n     * @param file The base file name.\r\n     * @param context The context of this extension to get its path regardless where it is installed.\r\n     * @param webview When given format the path for use in this webview.\r\n     *\r\n     * @returns The computed path.\r\n     */\r\n    public static getOutPath(file: string, context: ExtensionContext, webview?: Webview): string {\r\n        if (webview) {\r\n            const uri = Uri.file(context.asAbsolutePath(path.join(\"out\", file)));\r\n\r\n            return webview.asWebviewUri(uri).toString();\r\n        }\r\n\r\n        return context.asAbsolutePath(path.join(\"out\", file));\r\n    }\r\n\r\n    /**\r\n     * Returns the absolute path to a file located in the node_modules folder.\r\n     *\r\n     * @param webview The webview for which to create the path.\r\n     * @param file The base file name.\r\n     * @param context The context of this extension to get its path regardless where it is installed.\r\n     *\r\n     * @returns The computed path.\r\n     */\r\n    public static getNodeModulesPath(webview: Webview, file: string, context: ExtensionContext): string {\r\n        const path = Uri.joinPath(context.extensionUri, \"node_modules\", file);\r\n\r\n        return webview.asWebviewUri(path).toString();\r\n    }\r\n\r\n    public static isAbsolute(p: string): boolean {\r\n        return path.normalize(p + \"/\") === path.normalize(path.resolve(p) + \"/\");\r\n    }\r\n\r\n    public static deleteFolderRecursive(target: string): void {\r\n        let files = [];\r\n        if (fs.existsSync(target)) {\r\n            files = fs.readdirSync(target);\r\n            files.forEach((file) => {\r\n                const curPath = path.join(target, file);\r\n                if (fs.lstatSync(curPath).isDirectory()) {\r\n                    FrontendUtils.deleteFolderRecursive(curPath);\r\n                } else {\r\n                    fs.unlinkSync(curPath);\r\n                }\r\n            });\r\n            fs.rmdirSync(target);\r\n        }\r\n    }\r\n\r\n    public static hashForPath(dataPath: string): string {\r\n        return crypto.createHash(\"md5\").update(dataPath).digest(\"hex\");\r\n    }\r\n\r\n    /**\r\n     * Copies all given files to the specified target folder if they don't already exist there\r\n     * or are older than the source files.\r\n     *\r\n     * @param files A list of paths for files to be copied.\r\n     * @param targetPath The target path of the copy operation.\r\n     */\r\n    public static copyFilesIfNewer(files: string[], targetPath: string): void {\r\n        try {\r\n            fs.ensureDirSync(targetPath);\r\n        } catch (error) {\r\n            void window.showErrorMessage(`Could not create target folder '${targetPath}'. ${String(error)}`);\r\n        }\r\n\r\n        for (const file of files) {\r\n            try {\r\n                let canCopy = true;\r\n                const targetFile = path.join(targetPath, path.basename(file));\r\n                if (fs.existsSync(targetFile)) {\r\n                    const sourceStat = fs.statSync(file);\r\n                    const targetStat = fs.statSync(targetFile);\r\n                    canCopy = targetStat.mtime < sourceStat.mtime;\r\n                }\r\n\r\n                if (canCopy) {\r\n                    void fs.copy(file, targetFile, { overwrite: true });\r\n                }\r\n            } catch (error) {\r\n                void window.showErrorMessage(`Could not copy file '${file}'. ${String(error)}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Asks the user for a file to store the given data in. Checks if the file already exists and ask for permission to\r\n     * overwrite it, if so. Also copies a number extra files to the target folder.\r\n     *\r\n     * @param fileName A default file name the user can change, if wanted.\r\n     * @param filters The file type filter as used in showSaveDialog.\r\n     * @param data The data to write.\r\n     * @param extraFiles Files to copy to the target folder (e.g. css).\r\n     */\r\n    public static exportDataWithConfirmation(fileName: string, filters: { [name: string]: string[]; }, data: string,\r\n        extraFiles: string[]): void {\r\n        void window.showSaveDialog({\r\n            defaultUri: Uri.file(fileName),\r\n            filters,\r\n        }).then((uri: Uri | undefined) => {\r\n            if (uri) {\r\n                const value = uri.fsPath;\r\n                fs.writeFile(value, data, (error) => {\r\n                    if (error) {\r\n                        void window.showErrorMessage(\"Could not write to file: \" + value + \": \" + error.message);\r\n                    } else {\r\n                        this.copyFilesIfNewer(extraFiles, path.dirname(value));\r\n                        void window.showInformationMessage(\"Diagram successfully written to file '\" + value + \"'.\");\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Given a list of objects which must have a `range` member, finds the entry which covers the given caret position\r\n     * and returns that (or undefined if not found).\r\n     *\r\n     * @param list The list to search through.\r\n     * @param column The position in the target line.\r\n     * @param row The line to search for.\r\n     *\r\n     * @returns The list entry at the given position or undefined if nothing could be found.\r\n     */\r\n    public static findInListFromPosition<T extends IRangeHolder>(list: T[], column: number,\r\n        row: number): T | undefined {\r\n        for (const entry of list) {\r\n            if (!entry.range) {\r\n                continue;\r\n            }\r\n\r\n            const start = entry.range.start;\r\n            const stop = entry.range.end;\r\n            let matched = start.row <= row && stop.row >= row;\r\n            if (matched) {\r\n                if (start.row === row) {\r\n                    matched = start.column <= column;\r\n                } else if (stop.row === row) {\r\n                    matched = stop.column >= column;\r\n                }\r\n            }\r\n            if (matched) {\r\n                return entry;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Dynamically switches a vscode context on or off. Such a context is used to enable/disable vscode commands,\r\n     * menus, views and others.\r\n     *\r\n     * @param key The name of the context value to switch.\r\n     * @param enable True or false to enabled/disable.\r\n     *\r\n     * @returns The result returned from the command execution.\r\n     */\r\n    public static switchVsCodeContext(key: string, enable: boolean): ProviderResult<unknown> {\r\n        return commands.executeCommand(\"setContext\", key, enable);\r\n    }\r\n\r\n    /**\r\n     * Checks if the given document is actually a grammar file.\r\n     *\r\n     * @param document The document to check.\r\n     *\r\n     * @returns True if this is indeed a grammar file.\r\n     */\r\n    public static isGrammarFile(document?: TextDocument | undefined): boolean {\r\n        return document ? (document.languageId === \"antlr\" && document.uri.scheme === \"file\") : false;\r\n    }\r\n\r\n    /**\r\n     * Enables/disables certain VS Code contexts depending on which file is currently active.\r\n     *\r\n     * @param backend The facade for details.\r\n     * @param document The source for the updates.\r\n     */\r\n    public static updateVsCodeContext(backend: AntlrFacade, document: TextDocument | undefined): void {\r\n        if (document && FrontendUtils.isGrammarFile(document)) {\r\n            const info = backend.getContextDetails(document.fileName); 1;\r\n            void FrontendUtils.switchVsCodeContext(\"antlr4.isLexer\", info.type === GrammarType.Lexer);\r\n            void FrontendUtils.switchVsCodeContext(\"antlr4.isParser\", info.type === GrammarType.Parser);\r\n            void FrontendUtils.switchVsCodeContext(\"antlr4.isCombined\", info.type === GrammarType.Combined);\r\n\r\n            void FrontendUtils.switchVsCodeContext(\"antlr4.hasImports\", info.imports.length > 0);\r\n        }\r\n    }\r\n}\r\n"]}