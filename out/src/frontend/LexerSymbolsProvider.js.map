{"version":3,"file":"LexerSymbolsProvider.js","sourceRoot":"","sources":["../../../src/frontend/LexerSymbolsProvider.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\n/* eslint-disable max-classes-per-file */\r\n\r\nimport { Vocabulary } from \"antlr4ts\";\r\nimport * as path from \"path\";\r\n\r\nimport { TreeItem, TreeItemCollapsibleState, Command, ProviderResult } from \"vscode\";\r\nimport { AntlrTreeDataProvider } from \"./AntlrTreeDataProvider\";\r\n\r\nexport class LexerSymbolItem extends TreeItem {\r\n\r\n    public override iconPath = {\r\n        light: path.join(__dirname, \"..\", \"..\", \"..\", \"misc\", \"token-light.svg\"),\r\n        dark: path.join(__dirname, \"..\", \"..\", \"..\", \"misc\", \"token-dark.svg\"),\r\n    };\r\n\r\n    public override contextValue = \"lexerSymbols\";\r\n\r\n    public constructor(\r\n        public override readonly label: string,\r\n        public override readonly collapsibleState: TreeItemCollapsibleState,\r\n        command?: Command,\r\n    ) {\r\n        super(label, collapsibleState);\r\n        this.command = command;\r\n    }\r\n}\r\n\r\nexport class LexerSymbolsProvider extends AntlrTreeDataProvider<LexerSymbolItem> {\r\n\r\n    public override getChildren(element?: LexerSymbolItem): ProviderResult<LexerSymbolItem[]> {\r\n        return new Promise((resolve) => {\r\n            if (!element) {\r\n                let vocabulary;\r\n                if (this.currentFile) {\r\n                    vocabulary = this.backend.getLexerVocabulary(this.currentFile);\r\n                }\r\n\r\n                if (vocabulary) {\r\n                    const items: LexerSymbolItem[] = [];\r\n                    items.push(new LexerSymbolItem(\"-1: EOF\", TreeItemCollapsibleState.None, {\r\n                        title: \"<unused>\",\r\n                        command: \"\",\r\n                        arguments: [],\r\n                    }));\r\n                    for (let i = 0; i <= vocabulary.maxTokenType; ++i) {\r\n                        items.push(this.generateTreeItem(i, vocabulary));\r\n                    }\r\n\r\n                    resolve(items);\r\n                } else {\r\n                    resolve(null);\r\n                }\r\n            } else {\r\n                resolve(null);\r\n            }\r\n        });\r\n    }\r\n\r\n    private generateTreeItem(index: number, vocabulary: Vocabulary): LexerSymbolItem {\r\n        const literal = vocabulary.getLiteralName(index);\r\n        const symbolic = vocabulary.getSymbolicName(index);\r\n        let caption = `${index}: `;\r\n        if (!literal && !symbolic) {\r\n            caption += \"<unused>\";\r\n        } else {\r\n            if (symbolic) {\r\n                caption += symbolic;\r\n            } else {\r\n                caption += \"<implicit token>\";\r\n            }\r\n\r\n            if (literal) {\r\n                caption += \" (\" + literal + \")\";\r\n            }\r\n        }\r\n\r\n        const alternative = literal ?? \"\";\r\n        const info = this.backend.infoForSymbol(this.currentFile ?? \"\",\r\n            symbolic ?? alternative.substring(1, alternative.length - 2));\r\n\r\n        const parameters: Command = { title: \"\", command: \"\" };\r\n        if (info && info.definition) {\r\n            parameters.title = \"\";\r\n            parameters.command = \"antlr.selectGrammarRange\";\r\n            parameters.arguments = [info.definition.range];\r\n        }\r\n\r\n        return new LexerSymbolItem(caption, TreeItemCollapsibleState.None, parameters);\r\n    }\r\n}\r\n"]}