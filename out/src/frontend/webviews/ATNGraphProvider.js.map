{"version":3,"file":"ATNGraphProvider.js","sourceRoot":"","sources":["../../../../src/frontend/webviews/ATNGraphProvider.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Mike Lischke. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\nimport * as fs from \"fs-extra\";\r\nimport * as path from \"path\";\r\n\r\nimport { WebviewProvider, IWebviewMessage } from \"./WebviewProvider\";\r\nimport { FrontendUtils } from \"../FrontendUtils\";\r\nimport { window, workspace, Uri, TextEditor, Webview } from \"vscode\";\r\nimport {\r\n    IATNGraphData, IATNGraphLayoutNode, IATNGraphRendererData, IATNStateSaveMessage,\r\n} from \"../../webview-scripts/types\";\r\nimport { ATNStateType } from \"antlr4ts/atn\";\r\n\r\ninterface IATNStatePosition {\r\n    fx?: number;\r\n    fy?: number;\r\n}\r\n\r\n// ATN graph state info for a single rule.\r\ninterface IATNStateEntry {\r\n    scale: number;\r\n    translation: { x: number | undefined; y: number | undefined; };\r\n    statePositions: {\r\n        [key: number]: IATNStatePosition;\r\n    };\r\n}\r\n\r\ninterface IATNStateMap {\r\n    [key: string]: IATNStateEntry;\r\n}\r\n\r\ninterface IATNFileStateMap {\r\n    [key: string]: IATNStateMap;\r\n}\r\n\r\nexport class ATNGraphProvider extends WebviewProvider {\r\n\r\n    // All ATN state entries per file, per rule. Initially filled from the extension code.\r\n    public static cachedATNTransformations: IATNFileStateMap = {};\r\n\r\n    public static addStatesForGrammar(root: string, grammar: string): void {\r\n        const hash = FrontendUtils.hashForPath(grammar);\r\n        const atnCacheFile = path.join(root, \"cache\", hash + \".atn\");\r\n        if (fs.existsSync(atnCacheFile)) {\r\n            const data = fs.readFileSync(atnCacheFile, { encoding: \"utf-8\" });\r\n            try {\r\n                const fileEntry = JSON.parse(data) as IATNStateMap;\r\n                ATNGraphProvider.cachedATNTransformations[hash] = fileEntry;\r\n            } catch (e) {\r\n                // Ignore cache loading errors.\r\n            }\r\n        }\r\n    }\r\n\r\n    public override generateContent(webview: Webview, uri: Uri): string {\r\n        const graphData = this.prepareRenderData(uri);\r\n\r\n        const rendererScriptPath = FrontendUtils.getOutPath(\"src/webview-scripts/ATNGraphRenderer.js\", this.context,\r\n            webview);\r\n        const exportScriptPath = FrontendUtils.getOutPath(\"src/webview-scripts/GraphExport.js\", this.context,\r\n            webview);\r\n        const graphLibPath = FrontendUtils.getNodeModulesPath(webview, \"d3/dist/d3.js\", this.context);\r\n\r\n        const name = graphData.ruleName ?? \"\";\r\n        const nonce = this.generateNonce();\r\n\r\n        return `<!DOCTYPE html>\r\n            <html style=\"width: 100%, height: 100%\">\r\n                <head>\r\n                    <meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\">\r\n                    ${this.generateContentSecurityPolicy(webview, nonce)}\r\n                    ${this.getStyles(webview)}\r\n                    <base target=\"_blank\">\r\n                    <script nonce=\"${nonce}\" src=\"${graphLibPath}\"></script>\r\n                    <script nonce=\"${nonce}\">\r\n                        let atnGraphRenderer;\r\n                        let graphExport;\r\n                    </script>\r\n                </head>\r\n                <body>\r\n                    <div class=\"header\">\r\n                        <span class=\"atn-graph-color\">\r\n                            <span class=\"graph-initial\">Ⓡ</span>ule&nbsp;&nbsp;</span>\r\n                            ${name}\r\n                            <span class=\"rule-index\">(rule index: ${this.currentRuleIndex ?? \"?\"})</span>\r\n                        <span class=\"action-box\">\r\n                            Reset display <a onClick=\"atnGraphRenderer.resetTransformation();\">\r\n                            <span class=\"atn-graph-color\" style=\"font-size: 120%; font-weight: 800; cursor: pointer;\r\n                                vertical-align: middle;\">↺</span></a>&nbsp;\r\n                            Save to file<a onClick=\"graphExport.exportToSVG('atn', '${name}');\">\r\n                                <span class=\"atn-graph-save-image\" />\r\n                            </a>\r\n                        </span>\r\n                    </div>\r\n\r\n                    <svg>\r\n                        <defs>\r\n                            <filter id=\"white-glow\" x=\"-150%\" y=\"-150%\" width=\"300%\" height=\"300%\">\r\n                                <feFlood result=\"flood\" flood-color=\"#ffffff\" flood-opacity=\"0.15\" />\r\n                                <feComposite in=\"flood\" result=\"mask\" in2=\"SourceGraphic\" operator=\"in\" />\r\n                                <feMorphology in=\"mask\" result=\"dilated\" operator=\"dilate\" radius=\"5\" />\r\n                                <feGaussianBlur in=\"dilated\" result=\"blurred\" stdDeviation=\"5\" />\r\n                                <feMerge>\r\n                                    <feMergeNode in=\"blurred\" />\r\n                                    <feMergeNode in=\"SourceGraphic\" />\r\n                                </feMerge>\r\n                            </filter>\r\n\r\n                            <filter id=\"black-glow\" x=\"-1000%\" y=\"-1000%\" width=\"2000%\" height=\"2000%\">\r\n                                <feFlood result=\"flood\" flood-color=\"#000000\" flood-opacity=\"0.15\" />\r\n                                <feComposite in=\"flood\" result=\"mask\" in2=\"SourceGraphic\" operator=\"in\" />\r\n                                <feMorphology in=\"mask\" result=\"dilated\" operator=\"dilate\" radius=\"4\" />\r\n                                <feGaussianBlur in=\"dilated\" result=\"blurred\" stdDeviation=\"5\" />\r\n                                <feMerge>\r\n                                    <feMergeNode in=\"blurred\" />\r\n                                    <feMergeNode in=\"SourceGraphic\" />\r\n                                </feMerge>\r\n                            </filter>\r\n\r\n                            <marker id=\"transitionEndCircle\" viewBox=\"0 -5 10 10\" refX=\"31\" refY=\"0\" markerWidth=\"7\"\r\n                                markerHeight=\"7\" orient=\"auto\" class=\"marker\">\r\n                                <path d=\"M0,-4L10,0L0,4\" />\r\n                            </marker>\r\n                            <marker id=\"transitionEndRect\" viewBox=\"0 -5 10 10\" refX=\"10\" refY=\"0\" markerWidth=\"7\"\r\n                                markerHeight=\"7\" orient=\"auto\" class=\"marker\">\r\n                                <path d=\"M0,-4L10,0L0,4\" />\r\n                            </marker>\r\n                        </defs>\r\n                    </svg>\r\n\r\n                    <script nonce=\"${nonce}\" type=\"module\">\r\n                        import { ATNGraphRenderer } from \"${rendererScriptPath}\";\r\n                        import { GraphExport, vscode } from \"${exportScriptPath}\";\r\n\r\n                        graphExport = new GraphExport();\r\n                        atnGraphRenderer = new ATNGraphRenderer(vscode);\r\n                        atnGraphRenderer.render(${JSON.stringify(graphData)});\r\n                    </script>\r\n                </body>\r\n            </html>\r\n        `;\r\n    }\r\n\r\n    /**\r\n     * Called when the webview must be updated. This can happen when:\r\n     * - The user switched to another editor, which holds an ANTLR4 grammar.\r\n     * - The user moved the caret in an editor holding a grammar.\r\n     * - New data was generated for the grammar in that editor.\r\n     *\r\n     * @param editor The editor that holds a grammar.\r\n     * @param forced If true update regardless of the selected rule (e.g. when new ATN data was generated).\r\n     */\r\n    public override update(editor: TextEditor, forced = false): void {\r\n        // Keep track of the currently selected rule in the given editor and trigger a visual update\r\n        // if the ATN graph is currently visible.\r\n        const caret = editor.selection.active;\r\n        const [selectedRule, selectedRuleIndex] =\r\n            this.backend.ruleFromPosition(editor.document.fileName, caret.character, caret.line + 1);\r\n\r\n        if (this.currentRule !== selectedRule || forced) {\r\n            this.currentRule = selectedRule;\r\n            this.currentRuleIndex = selectedRuleIndex;\r\n            super.update(editor);\r\n        }\r\n    }\r\n\r\n    protected override handleMessage(message: IWebviewMessage): boolean {\r\n        const saveMessage = message as IATNStateSaveMessage;\r\n\r\n        if (saveMessage.command === \"saveATNState\") {\r\n            // This is the bounce back from the script code for our call to `cacheATNLayout` triggered from\r\n            // the `update()` function.\r\n            const hash = FrontendUtils.hashForPath(saveMessage.uri.fsPath);\r\n            const basePath = path.dirname(saveMessage.uri.fsPath);\r\n            const atnCachePath = path.join(basePath, \".antlr/cache\");\r\n\r\n            let fileEntry = ATNGraphProvider.cachedATNTransformations[hash];\r\n            if (!fileEntry) {\r\n                fileEntry = {};\r\n            }\r\n\r\n            const { x: translateX, y: translateY, k: scale } = saveMessage.transform;\r\n\r\n            // Convert the given translation back to what it was before applying the scaling, as that is what we need\r\n            // to specify when we restore the translation.\r\n            const ruleEntry: IATNStateEntry = {\r\n                scale,\r\n                translation: { x: translateX / scale, y: translateY / scale },\r\n                statePositions: {},\r\n            };\r\n\r\n            for (const node of saveMessage.nodes) {\r\n                ruleEntry.statePositions[node.id] = {\r\n                    fx: node.fx === null ? undefined : node.fx,\r\n                    fy: node.fy === null ? undefined : node.fy,\r\n                };\r\n            }\r\n\r\n            fileEntry[saveMessage.rule] = ruleEntry;\r\n            ATNGraphProvider.cachedATNTransformations[hash] = fileEntry;\r\n\r\n            fs.ensureDirSync(atnCachePath);\r\n            try {\r\n                fs.writeFileSync(path.join(atnCachePath, hash + \".atn\"), JSON.stringify(fileEntry),\r\n                    { encoding: \"utf-8\" });\r\n            } catch (error) {\r\n                void window.showErrorMessage(`Couldn't write ATN state data for: ${saveMessage.uri.fsPath} (${hash})`);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    protected override updateContent(uri: Uri): boolean {\r\n        const graphData = this.prepareRenderData(uri);\r\n\r\n        this.sendMessage(uri, {\r\n            command: \"updateATNTreeData\",\r\n            graphData,\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    private prepareRenderData(uri: Uri): IATNGraphRendererData {\r\n        const ruleName = this.currentRule ? this.currentRule.replace(/\\$/g, \"$$\") : undefined;\r\n\r\n        const configuration = workspace.getConfiguration(\"antlr4.atn\");\r\n        const maxLabelCount = configuration.get<number>(\"maxLabelCount\", 3);\r\n\r\n        const hash = FrontendUtils.hashForPath(uri.fsPath);\r\n        const fileTransformations = ATNGraphProvider.cachedATNTransformations[hash] ?? {};\r\n\r\n        let initialScale = 0.5;\r\n        let initialTranslation = {};\r\n\r\n        const setPosition = (node: IATNGraphLayoutNode, position?: IATNStatePosition): void => {\r\n            // If no transformation data is available, give the start and end nodes a fixed vertical\r\n            // position and a horizontal initial position (which is not the same as a fixed position)\r\n            // to get the graph rendered near the svg center.\r\n            // The same positions are used when the user resets the transformation.\r\n            const fx = position?.fx;\r\n            const fy = position?.fy;\r\n            switch (node.type) {\r\n                case ATNStateType.RULE_START: {\r\n                    node.fy = fy ?? 0;\r\n                    if (fx !== undefined) {\r\n                        node.fx = fx;\r\n                    } else {\r\n                        node.x = -1000;\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ATNStateType.RULE_STOP: {\r\n                    node.fy = fy ?? 0;\r\n                    if (fx !== undefined) {\r\n                        node.fx = fx;\r\n                    } else {\r\n                        node.x = 1000;\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                default: {\r\n                    node.fx = position?.fx;\r\n                    node.fy = position?.fy;\r\n\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n        };\r\n\r\n        let graphData: IATNGraphData | undefined;\r\n        if (ruleName) {\r\n            try {\r\n                graphData = this.backend.getATNGraph(uri.fsPath, ruleName);\r\n\r\n                if (graphData) {\r\n                    const ruleTransformation = fileTransformations[ruleName];\r\n                    if (ruleTransformation) {\r\n                        initialScale = ruleTransformation.scale;\r\n\r\n                        initialTranslation = ruleTransformation.translation;\r\n\r\n                        for (const node of graphData.nodes as IATNGraphLayoutNode[]) {\r\n                            setPosition(node, ruleTransformation.statePositions[node.id]);\r\n                        }\r\n                    } else {\r\n                        for (const node of graphData.nodes as IATNGraphLayoutNode[]) {\r\n                            setPosition(node);\r\n                        }\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                // Ignore errors.\r\n            }\r\n        }\r\n\r\n        const result = {\r\n            uri,\r\n            ruleName,\r\n            maxLabelCount,\r\n            graphData,\r\n            initialScale,\r\n            initialTranslation,\r\n        };\r\n\r\n        return result;\r\n    }\r\n}\r\n"]}