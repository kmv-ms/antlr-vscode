//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.9.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from grammars/OracleAntlr.g4 by ANTLR 4.9.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.9.2")]
[System.CLSCompliant(false)]
public partial class OracleAntlrParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		A_=1, ACCOUNT=2, ADD=3, ADVANCED=4, AFTER=5, AGENT=6, AGGREGATE=7, ALL=8, 
		ALLOCATE=9, ALLOW=10, ALTER=11, ALWAYS=12, ANALYZE=13, AND=14, ANY=15, 
		ANYSCHEMA=16, ARCHIVE=17, ARRAY=18, AS=19, ASC=20, ASSOCIATE=21, AT=22, 
		ATTRIBUTE=23, ATTRIBUTES=24, AUDIT=25, AUTHENTICATION=26, AUTHID=27, AUTO=28, 
		AUTONOMOUS_TRANSACTION=29, BASIC=30, BASICFILE=31, BATCH=32, BEFORE=33, 
		BEGIN=34, BEGINNING=35, BETWEEN=36, BINARY=37, BITMAP=38, BLOCK=39, BODY=40, 
		BOTH=41, BREADTH=42, BUFFER_POOL=43, BUILD=44, BUILTIN=45, BULK=46, BULK_EXCEPTIONS=47, 
		BULK_ROWCOUNT=48, BY=49, BYTE=50, C_=51, CACHE=52, CALL=53, CASCADE=54, 
		CASE=55, CAST=56, CELL_FLASH_CACHE=57, CHAR=58, CHAR_CS=59, CHARACTER=60, 
		CHARSET=61, CHECK=62, CHR=63, CHUNK=64, CLOB=65, CLOSE=66, CLUSTER=67, 
		COALESCE=68, COLLATE=69, COLLATION=70, COLLECT=71, COLUMN=72, COLUMN_VALUE=73, 
		COLUMNS=74, COMMENT=75, COMMIT=76, COMMITTED=77, COMPACT=78, COMPILE=79, 
		COMPLETE=80, COMPOUND=81, COMPRESS=82, COMPUTATION=83, COMPUTE=84, CONDITIONAL=85, 
		CONNECT=86, CONNECT_BY_ROOT=87, CONSTANT=88, CONSTRAINT=89, CONSTRAINTS=90, 
		CONSTRUCTOR=91, CONTAINER=92, CONTENT=93, CONTEXT=94, CONTINUE=95, CONVERT=96, 
		COUNT=97, CREATE=98, CREATION=99, CROSS=100, CUBE=101, CURRENT=102, CURRENT_USER=103, 
		CURSOR=104, CYCLE=105, DATA=106, DATABASE=107, DATAFILE=108, DATE=109, 
		DAY=110, DBTIMEZONE=111, DDL=112, DEALLOCATE=113, DEBUG=114, DECLARE=115, 
		DECODE=116, DECRYPT=117, DEDUPLICATE=118, DEFAULT=119, DEFERRABLE=120, 
		DEFERRED=121, DEFINER=122, DELETE=123, DEMAND=124, DENSE_RANK=125, DEPTH=126, 
		DESC=127, DETERMINISTIC=128, DIRECT_LOAD=129, DIRECTIVE_ELSE=130, DIRECTIVE_ELSIF=131, 
		DIRECTIVE_END=132, DIRECTIVE_ERROR=133, DIRECTIVE_IF=134, DIRECTIVE_THEN=135, 
		DISABLE=136, DISALLOW=137, DISASSOCIATE=138, DISTINCT=139, DOUBLE=140, 
		DROP=141, DUPLICATED=142, EACH=143, EDITION=144, EDITIONABLE=145, EDITIONING=146, 
		EDITIONS=147, ELEMENT=148, ELSE=149, ELSIF=150, EMPTY_KEYWORD=151, ENABLE=152, 
		ENCRYPT=153, END=154, ENFORCED=155, ERROR_CODE=156, ERROR_INDEX=157, ERROR=158, 
		ERRORS=159, ESCAPE=160, EVALUATE=161, EXCEPT=162, EXCEPTION=163, EXCEPTION_INIT=164, 
		EXCEPTIONS=165, EXCLUDE=166, EXCLUSIVE=167, EXECUTE=168, EXISTS=169, EXIT=170, 
		EXPIRE=171, EXTEND=172, EXTENDED=173, EXTENT=174, EXTERNALLY=175, EXTRACT=176, 
		EXTRACTVALUE=177, FALSE=178, FAST=179, FETCH=180, FILESYSTEM_LIKE_LOGGING=181, 
		FINAL=182, FIPSFLAG=183, FIRST=184, FIRST_ROWS=185, FIXED=186, FOLLOWING=187, 
		FOR=188, FORALL=189, FORCE=190, FOREIGN=191, FORMAT=192, FOUND=193, FLASH_CACHE=194, 
		FREELIST=195, FREELISTS=196, FREEPOOLS=197, FROM=198, FULL=199, FUNCTION=200, 
		GENERATED=201, GLOBAL=202, GLOBALLY=203, GOTO=204, GRANT=205, GROUP=206, 
		GROUPING=207, GROUPS=208, HASH=209, HAVING=210, HEAP=211, HIGH=212, HOUR=213, 
		ID=214, IDENTIFIED=215, IDENTIFIER=216, IDENTITY=217, IF=218, IMMEDIATE=219, 
		IN=220, INCLUDE=221, INCLUDING=222, INCREMENT=223, INDEX=224, INDEXING=225, 
		INDEXTYPE=226, INDICATOR=227, INDICES=228, INITIAL=229, INITIALLY=230, 
		INITRANS=231, INNER=232, INSERT=233, INSTANCE=234, INSTANTIABLE=235, INSTEAD=236, 
		INTERFACE=237, INTERSECT=238, INTERVAL=239, INTO=240, INVALIDATE=241, 
		INVALIDATION=242, INVISIBLE=243, IS=244, ISOLATION=245, ISOPEN=246, JAVA=247, 
		JOIN=248, JSON=249, JSON_TABLE=250, KEEP=251, KEEP_DUPLICATES=252, KEY=253, 
		LANGUAGE=254, LAST=255, LEADING=256, LEFT=257, LESS=258, LEVEL=259, LEVELS=260, 
		LIBRARY=261, LIKE=262, LIKE2=263, LIKE4=264, LIKEC=265, LIMIT=266, LIST=267, 
		LOB=268, LOBS=269, LOCAL=270, LOCATOR=271, LOCK=272, LOCKED=273, LOCKING=274, 
		LOG=275, LOGGING=276, LOGOFF=277, LOGON=278, LONG=279, LOOP=280, LOW=281, 
		MAP=282, MAPPING=283, MASTER=284, MATCHED=285, MATERIALIZED=286, MAX=287, 
		MAXEXTENTS=288, MAXSIZE=289, MAXTRANS=290, MAXVALUE=291, MEDIUM=292, MEMBER=293, 
		MEMOPTIMIZE=294, MERGE=295, METADATA=296, MIN=297, MINEXTENTS=298, MINUS=299, 
		MINUTE=300, MINVALUE=301, MOD=302, MODE=303, MODIFY=304, MONITORING=305, 
		MONTH=306, MOVEMENT=307, MULTISET=308, NAME=309, NATIONAL=310, NATURAL=311, 
		NCHAR=312, NCHAR_CS=313, NCHR=314, NESTED=315, NEVER=316, NEW=317, NEW_NAMES=318, 
		NEXT=319, NO=320, NOAUDIT=321, NOCACHE=322, NOCOMPRESS=323, NOCOPY=324, 
		NOCYCLE=325, NOEXTEND=326, NOKEEP=327, NOLOGGING=328, NOMAPPING=329, NOMAXVALUE=330, 
		NOMINVALUE=331, NOMONITORING=332, NOORDER=333, NONE=334, NONEDITIONABLE=335, 
		NONSCHEMA=336, NOPARALLEL=337, NORELY=338, NOREVERSE=339, NOROWDEPENDENCIES=340, 
		NOSCALE=341, NOSHARD=342, NOSORT=343, NOT=344, NOTFOUND=345, NOVALIDATE=346, 
		NOWAIT=347, NULL=348, NULLS=349, NVARCHAR2=350, OBJECT=351, OF=352, OID=353, 
		OIDINDEX=354, OLD=355, ON=356, ONLY=357, ONLINE=358, OPAQUE=359, OPEN=360, 
		OPERATIONS=361, OPTIMAL=362, OPTION=363, OR=364, ORDER=365, ORDINALITY=366, 
		ORGANIZATION=367, OUT=368, OUTER=369, OVER=370, OVERFLOW=371, OVERLAPS=372, 
		OVERRIDING=373, PACKAGE=374, PARALLEL=375, PARALLEL_ENABLE=376, PARAMETERS=377, 
		PARENT=378, PARTIAL=379, PARTITION=380, PARTITIONS=381, PASSING=382, PASSWORD=383, 
		PATH=384, PCTFREE=385, PCTINCREASE=386, PCTTHRESHOLD=387, PCTUSED=388, 
		PCTVERSION=389, PERCENTILE_DISC=390, PERIOD=391, PIPE=392, PIPELINED=393, 
		PIVOT=394, POLYMORPHIC=395, PRAGMA=396, PREBUILT=397, PRECEDING=398, PRECISION=399, 
		PRESERVE=400, PRIMARY=401, PRIOR=402, PRIVATE=403, PROCEDURE=404, PROFILE=405, 
		PUBLIC=406, PURGE=407, QUERY=408, QUOTA=409, RAISE=410, RAISE_APPLICATION_ERROR=411, 
		RANGE=412, RAW=413, READ=414, READS=415, REBUILD=416, RECORD=417, RECYCLE=418, 
		REDUCED=419, REF=420, REFERENCES=421, REFERENCING=422, REFRESH=423, REJECT=424, 
		RELATIONAL=425, RELIES_ON=426, RELY=427, RENAME=428, REPLACE=429, RESTRICT_REFERENCES=430, 
		RESULT=431, RESULT_CACHE=432, RETENTION=433, RETURN=434, RETURNING=435, 
		REUSE=436, REVERSE=437, REVOKE=438, REWRITE=439, RIGHT=440, ROLLBACK=441, 
		ROLLUP=442, ROW=443, ROWCOUNT=444, ROWDEPENDENCIES=445, ROWID=446, ROWS=447, 
		ROWTYPE=448, SALT=449, SAMPLE=450, SAVE=451, SAVEPOINT=452, SCALE=453, 
		SCHEMA=454, SCN=455, SCOPE=456, SEARCH=457, SECOND=458, SECUREFILE=459, 
		SEED=460, SEGMENT=461, SELECT=462, SELF=463, SEQUENCE=464, SERIALIZABLE=465, 
		SERIALLY_REUSABLE=466, SERVERERROR=467, SESSION=468, SESSIONTIMEZONE=469, 
		SET=470, SETS=471, SETTINGS=472, SHARE=473, SHRINK=474, SHUTDOWN=475, 
		SIBLINGS=476, SIZE=477, SKIP_=478, SOME=479, SORT=480, SPACE=481, SPECIFICATION=482, 
		SPLIT=483, START=484, STARTUP=485, STATEMENT=486, STATIC=487, STATISTICS=488, 
		STORAGE=489, STORE=490, STRING=491, SHARD=492, SHARDED=493, SHARING=494, 
		SUBMULTISET=495, SUBPARTITION=496, SUBPARTITIONS=497, SUBSTITUTABLE=498, 
		SUBTYPE=499, SUPPLEMENTAL=500, SUSPEND=501, SYNONYM=502, SYS_CONNECT_BY_PATH=503, 
		SYSTEM=504, TABLE=505, TABLES=506, TABLESPACE=507, TEMPLATE=508, TEMPORARY=509, 
		THAN=510, THE=511, THEN=512, TIME=513, TIMESTAMP=514, TIMEZONE_ABBR=515, 
		TIMEZONE_HOUR=516, TIMEZONE_MINUTE=517, TIMEZONE_REGION=518, TO=519, TRAILING=520, 
		TRANSACTION=521, TRANSLATE=522, TREAT=523, TRIGGER=524, TRIM=525, TRUE=526, 
		TRUNCATE=527, TRUSTED=528, TYPE=529, UNBOUNDED=530, UNCONDITIONAL=531, 
		UNDER=532, UNION=533, UNIQUE=534, UNLIMITED=535, UNLOCK=536, UNPIVOT=537, 
		UNUSABLE=538, UNUSED=539, UPDATE=540, USABLE=541, USAGE=542, USE=543, 
		USER=544, USING=545, VALIDATE=546, VALUE=547, VALUES=548, VARCHAR=549, 
		VARCHAR2=550, VARRAY=551, VARRAYS=552, VARYING=553, VERSIONS=554, VIEW=555, 
		VIRTUAL=556, VISIBLE=557, WAIT=558, WHEN=559, WHERE=560, WHILE=561, WITH=562, 
		WITHIN=563, WITHOUT=564, WORK=565, WRAPPED=566, WRAPPER=567, WRITE=568, 
		XML=569, XMLAGG=570, XMLCAST=571, XMLNAMESPACES=572, XMLQUERY=573, XMLSCHEMA=574, 
		XMLTABLE=575, XMLTYPE=576, YEAR=577, ZONE=578, INTEGER_LITERAL=579, ASSIGN_OPERATOR=580, 
		ASSOC_OPERATOR=581, CONCAT_OPERATOR=582, POWER_OPERATOR=583, DOUBLE_DOT_OPERATOR=584, 
		LPAREN=585, RPAREN=586, COMMA=587, SEMI=588, FSLASH=589, BSLASH=590, GREATER_THAN=591, 
		LESS_THAN=592, EQUAL_SIGN=593, PERCENT_SIGN=594, AT_SIGN=595, PLUS_SIGN=596, 
		MINUS_SIGN=597, POUND_SIGN=598, QUESTION_MARK=599, BANG=600, ASTERISK=601, 
		DOT=602, CARET=603, TILDE=604, FLOATING_POINT_LITERAL=605, FLOATING_POINT_BINARY_LITERAL=606, 
		UNICODE_CHARACTER_STRING_LITERAL=607, BINARY_STRING_LITERAL=608, CHARACTER_STRING_LITERAL=609, 
		BYTE_SIZE_LITERAL=610, MONEY_LITERAL=611, REGULAR_IDENTIFIER=612, QUOTED_IDENTIFIER=613, 
		WHITESPACES=614, WHITESPACE=615, QUOTE_CHARACTER_STRING_LITERAL=616, INVALID_CHAR=617;
	public const int
		RULE_expressionInputFile = 0, RULE_conditionInputFile = 1, RULE_hintInputFile = 2, 
		RULE_plSqlCheckInputFile = 3, RULE_dynamicSqlInputFile = 4, RULE_computedColumnExpressionInputFile = 5, 
		RULE_expressionListInputFile = 6, RULE_hintsList = 7, RULE_hintItem = 8, 
		RULE_hintParams = 9, RULE_complexIndexHint = 10, RULE_queryBlock = 11, 
		RULE_sqlInputFile = 12, RULE_sqlStatementBatch = 13, RULE_sqlStatement = 14, 
		RULE_plSqlStatementBatch = 15, RULE_plSqlStatement = 16, RULE_routineSignature = 17, 
		RULE_procedureOrFunctionSignature = 18, RULE_literal = 19, RULE_quoteCharacterStringLiteral = 20, 
		RULE_characterStringLiteral = 21, RULE_unicodeCharacterStringLiteral = 22, 
		RULE_binaryStringLiteral = 23, RULE_booleanLiteral = 24, RULE_dateLiteral = 25, 
		RULE_timestampLiteral = 26, RULE_intervalLiteral = 27, RULE_intervalLiteralFieldClause = 28, 
		RULE_intervalLiteralFieldPrecision = 29, RULE_floatingPointBinaryLiteral = 30, 
		RULE_simpleIdentifierRegularIdentifier = 31, RULE_dotInIdentifier = 32, 
		RULE_identifier = 33, RULE_plainIdentifier = 34, RULE_plainRemoteIdentifier = 35, 
		RULE_multipartPlainIdentifier = 36, RULE_asterisk = 37, RULE_dbLink = 38, 
		RULE_simpleIdentifier = 39, RULE_nestedCollectionSimpleIdentifier = 40, 
		RULE_plainIdentifierAsStringLiteral = 41, RULE_typeReferenceOpaqueFixed = 42, 
		RULE_plainSimpleIdentifierAsStringLiteral = 43, RULE_simpleIdentifierParams = 44, 
		RULE_localSimpleIdentifierWithoutParentheses = 45, RULE_simpleIdentifierWithoutParentheses = 46, 
		RULE_bindParameter = 47, RULE_typeReference = 48, RULE_identifierTimestamp = 49, 
		RULE_identifierTime = 50, RULE_identifierWith = 51, RULE_identifierLocal = 52, 
		RULE_identifierZone = 53, RULE_identifierInterval = 54, RULE_identifierTo = 55, 
		RULE_identifierLong = 56, RULE_identifierRaw = 57, RULE_identifierLongRaw = 58, 
		RULE_identifierDoublePrecision = 59, RULE_identifierCharacter = 60, RULE_identifierNationalCharacter = 61, 
		RULE_identifierNChar = 62, RULE_identifierNVarChar2 = 63, RULE_identifierVarChar = 64, 
		RULE_identifierVarChar2 = 65, RULE_identifierString = 66, RULE_charIdentifierParams = 67, 
		RULE_typeReferenceTimestampCase = 68, RULE_typeReferenceIntervalCase = 69, 
		RULE_typeReferenceCharCase = 70, RULE_collationSpecClause = 71, RULE_typeReferenceLongAndRawCase = 72, 
		RULE_typeReferenceAttributes = 73, RULE_typeReferenceCharacterSetAttribute = 74, 
		RULE_typeReferenceCharacterSetModifier = 75, RULE_typeReferenceRangeAttribute = 76, 
		RULE_delimiterDoubleDot = 77, RULE_typeReferenceModifierAttribute = 78, 
		RULE_typeReferenceRefCase = 79, RULE_fullExpression = 80, RULE_fullOrCondition = 81, 
		RULE_fullAndCondition = 82, RULE_fullUnaryCondition = 83, RULE_fullAtomicCondition = 84, 
		RULE_delimiterCurrentOf = 85, RULE_delimiterExists = 86, RULE_fullAtomicCondition1 = 87, 
		RULE_inPureExpression = 88, RULE_delimiterAny = 89, RULE_delimiterSome = 90, 
		RULE_delimiterAll = 91, RULE_delimiterNot = 92, RULE_delimiterIs = 93, 
		RULE_delimiterIn = 94, RULE_delimiterLParen = 95, RULE_delimiterRParen = 96, 
		RULE_typesComparison = 97, RULE_typeComparisonNames = 98, RULE_pureExpression = 99, 
		RULE_bitwiseLevelExpression = 100, RULE_addLevelExpression = 101, RULE_addLevelOperator = 102, 
		RULE_divideLevelOperator = 103, RULE_unaryExpression = 104, RULE_xmlQuery = 105, 
		RULE_xmlQueryDelegate = 106, RULE_xmlPassingParameterList = 107, RULE_xmlPassingParameterListItem = 108, 
		RULE_xmlCast = 109, RULE_newExpression = 110, RULE_treatExpression = 111, 
		RULE_treatExpressionParameters = 112, RULE_treatExpressionAsClause = 113, 
		RULE_treatExpressionReturnValue = 114, RULE_multisetExpression = 115, 
		RULE_multisetOperator = 116, RULE_dateTimeAtClause = 117, RULE_dateTimeAtLocalClause = 118, 
		RULE_dateTimeAtTimeZoneClause = 119, RULE_keepExpression = 120, RULE_keepClause = 121, 
		RULE_withinExpression = 122, RULE_withinExpressionParams = 123, RULE_overExpression = 124, 
		RULE_overExpressionParams = 125, RULE_overExpressionPartitionClause = 126, 
		RULE_overExpressionWindowingClause = 127, RULE_overExpressionWindowingClauseBetween = 128, 
		RULE_overExpressionWindowingClauseSingle = 129, RULE_overExpressionWindowingClauseItem = 130, 
		RULE_overExpressionWindowingClauseItemExpression = 131, RULE_cursorAttributeExpression = 132, 
		RULE_bulkExpression = 133, RULE_bulkExceptionExpression = 134, RULE_bulkRowCountExpression = 135, 
		RULE_collectionIndex = 136, RULE_powerExpression = 137, RULE_delimiterNull = 138, 
		RULE_castExpression = 139, RULE_cursorExpression = 140, RULE_caseExpression = 141, 
		RULE_simpleCaseExpression = 142, RULE_simpleCaseWhenEntry = 143, RULE_caseElseEntry = 144, 
		RULE_searchedCaseExpression = 145, RULE_searchedCaseWhenEntry = 146, RULE_priorExpression = 147, 
		RULE_connectByRootExpression = 148, RULE_sysConnectByPathExpression = 149, 
		RULE_trimExpression = 150, RULE_trimExtClause = 151, RULE_decodeExpression = 152, 
		RULE_extractDatetimeExpression = 153, RULE_extractXMLExpression = 154, 
		RULE_xmlTypeInstance = 155, RULE_xpathString = 156, RULE_xmlNamespace = 157, 
		RULE_extractDatetimeFromClause = 158, RULE_delimiterDate = 159, RULE_multiColumnCondition = 160, 
		RULE_overlapsCondition = 161, RULE_comparisonList = 162, RULE_collectionsComparison = 163, 
		RULE_collectionsComparisonSubmultiset = 164, RULE_collectionsComparisonMemberOf = 165, 
		RULE_collectionsComparisonIsASet = 166, RULE_collectionsComparisonIsEmpty = 167, 
		RULE_likeOperator = 168, RULE_escapeClause = 169, RULE_betweenOperator = 170, 
		RULE_betweenAndOperator = 171, RULE_comparisonPairOperator = 172, RULE_flattenedQuery = 173, 
		RULE_asFlattenedQuery = 174, RULE_flattenedQueryNestedTable = 175, RULE_fullExpressionList = 176, 
		RULE_fullExpressionListItem = 177, RULE_expressionList = 178, RULE_multiItemExpressionList = 179, 
		RULE_defaultExpression = 180, RULE_expressionListItem = 181, RULE_xmlaggExpression = 182, 
		RULE_parameterName = 183, RULE_alias = 184, RULE_identifierList = 185, 
		RULE_columnListElementClause = 186, RULE_columnListItem = 187, RULE_complexColumnListItem = 188, 
		RULE_createStatement = 189, RULE_createStatementReplaceClause = 190, RULE_createUserStatement = 191, 
		RULE_createUserIdentificationClause = 192, RULE_createUserPasswordIdentificationClause = 193, 
		RULE_createUserExternalIdentificationClause = 194, RULE_createUserGlobalIdentificationClause = 195, 
		RULE_createUserNoAuthenticationClause = 196, RULE_createUserOption = 197, 
		RULE_defaultCollationOption = 198, RULE_createUserDefaultTablespaceOption = 199, 
		RULE_createUserTemporaryTablespaceOption = 200, RULE_createUserTablespaceQuotaOption = 201, 
		RULE_createUserProfileOption = 202, RULE_createUserPasswordExpireOption = 203, 
		RULE_createUserAccountOption = 204, RULE_createUserEnableEditionsOption = 205, 
		RULE_createUserContainerOption = 206, RULE_createIndexStatement = 207, 
		RULE_clusterIndexClause = 208, RULE_tableIndexClause = 209, RULE_tableIndexExpression = 210, 
		RULE_bitmapJoinIndexClause = 211, RULE_bitmapJoinIndexExpression = 212, 
		RULE_bitmapJoinIndexFromClauseItem = 213, RULE_indexProperties = 214, 
		RULE_globalPartitionedIndex = 215, RULE_localPartitionedIndex = 216, RULE_indexOnSimplePartitionedTableClause = 217, 
		RULE_indexOnSimplePartitionedTableClauseItem = 218, RULE_indexOnHashPartitionedTable = 219, 
		RULE_indexOnHashPartitionedTableClauseItem = 220, RULE_indexOnCompPartitionedTable = 221, 
		RULE_indexOnCompPartitionedTableClauseItem = 222, RULE_indexSubpartitionClause = 223, 
		RULE_indexSubpartitionClauseItem = 224, RULE_indexAttribute = 225, RULE_visibilityClause = 226, 
		RULE_partialIndexClause = 227, RULE_indexTypeClause = 228, RULE_localIndexClause = 229, 
		RULE_localIndexClauseItem = 230, RULE_unstructuredIndexParametersClause = 231, 
		RULE_simpleTablespaceClause = 232, RULE_createSequenceStatement = 233, 
		RULE_createSequenceSharingClause = 234, RULE_createEditionableBatchWideStatement = 235, 
		RULE_editionOptionClause = 236, RULE_packageStatement = 237, RULE_packageBodyStatement = 238, 
		RULE_packageDeclarationBlock = 239, RULE_procedureStatement = 240, RULE_procedureSignature = 241, 
		RULE_procedureImplementation = 242, RULE_procedureHeader = 243, RULE_routineBody = 244, 
		RULE_routineBodyAsIsClause = 245, RULE_invokerRightsClause = 246, RULE_procedureCallSpecClause = 247, 
		RULE_javaDeclarationClause = 248, RULE_cDeclarationClause = 249, RULE_cDeclarationNameClause = 250, 
		RULE_cDeclarationLibraryClause = 251, RULE_cDeclarationAgentClause = 252, 
		RULE_cDeclarationContextClause = 253, RULE_cDeclarationParametersClause = 254, 
		RULE_argumentList = 255, RULE_argument = 256, RULE_argumentNoCopyClause = 257, 
		RULE_argumentModeClause = 258, RULE_argumentDefaultValue = 259, RULE_functionStatement = 260, 
		RULE_functionSignature = 261, RULE_functionImplementation = 262, RULE_functionHeader = 263, 
		RULE_functionReturnClause = 264, RULE_functionDeterministicClause = 265, 
		RULE_functionParallelEnableClause = 266, RULE_parallelOnPartitionOption = 267, 
		RULE_parallelOnPartitionBy = 268, RULE_columnListItemInParen = 269, RULE_parallelOnPartitionStreamingClause = 270, 
		RULE_parallelOnPartitionStreamingClauseBy = 271, RULE_resultCacheClause = 272, 
		RULE_resultCacheReliesOnClause = 273, RULE_functionAggregateClause = 274, 
		RULE_functionPipelinedClause = 275, RULE_createTableStatement = 276, RULE_tableHeader = 277, 
		RULE_createObjectTableStatement = 278, RULE_memOptimizeClause = 279, RULE_parentClause = 280, 
		RULE_oidIndexClause = 281, RULE_oidIndexClauseList = 282, RULE_objectIdentifierIsClause = 283, 
		RULE_objectTableOfClause = 284, RULE_createRelationTableStatement = 285, 
		RULE_createXMLTypeTableStatement = 286, RULE_tablePropertiesClause = 287, 
		RULE_columnProperties = 288, RULE_xmlTypeColumnProperties = 289, RULE_xmlTypeStorageClause = 290, 
		RULE_xmlTypeStoreAsClause = 291, RULE_xmlTypeStoreAsObjectRelationalClause = 292, 
		RULE_xmlTypeStoreAsLobClause = 293, RULE_xmlTypeStoreAllClause = 294, 
		RULE_objectTypeColProperties = 295, RULE_varrayColProperties = 296, RULE_nestedTableColProperties = 297, 
		RULE_nestedTableObjectProperties = 298, RULE_returnAsClause = 299, RULE_objectPropertiesListClause = 300, 
		RULE_objectProperties = 301, RULE_storeAsClause = 302, RULE_nestedItemClause = 303, 
		RULE_asSubqueryClause = 304, RULE_rowMovementClause = 305, RULE_enableDisableConstraintClause = 306, 
		RULE_keepDropIndexClause = 307, RULE_cascadeClause = 308, RULE_monitoringClause = 309, 
		RULE_rowdependenciesClause = 310, RULE_parallelClause = 311, RULE_partitioningDefinitionClause = 312, 
		RULE_compositePartitioning = 313, RULE_subPartitionByHash = 314, RULE_subpartitionsStoreInClause = 315, 
		RULE_subPartitionByList = 316, RULE_subPartitionTemplate = 317, RULE_subPartitionDefinitionListClause = 318, 
		RULE_subPartitionDefinitionClause = 319, RULE_partitionByListClause = 320, 
		RULE_partitionByHashClause = 321, RULE_partitionsSimpleClause = 322, RULE_partitionSimpleListClause = 323, 
		RULE_partitionSimpleClause = 324, RULE_partitionByRangeClause = 325, RULE_partitionDefinitionListClause = 326, 
		RULE_partitionDefinitionClause = 327, RULE_tablePartitionDescription = 328, 
		RULE_partitionLevelSubpartitioningClause = 329, RULE_subpartitionSpecList = 330, 
		RULE_subpartitionSpec = 331, RULE_partitioningStorageClause = 332, RULE_listValuesClause = 333, 
		RULE_subpartitionsSimpleClause = 334, RULE_partitionsStoreInClause = 335, 
		RULE_tablespaceListClause = 336, RULE_varrayStorageClause = 337, RULE_substitutableColumnClause = 338, 
		RULE_notSubstitutableClause = 339, RULE_elementIsOfTypeClause = 340, RULE_delimiterOnly = 341, 
		RULE_storeAsLobClause = 342, RULE_lOBStorageClause = 343, RULE_lOBPropertiesListClause = 344, 
		RULE_lobPropertiesListElementClause = 345, RULE_lobStoreAsClause = 346, 
		RULE_rangeValuesClause = 347, RULE_valuesLessThanListClause = 348, RULE_valuesLessThanListItem = 349, 
		RULE_partitionByRangeColumnList = 350, RULE_physicalPropertiesClause = 351, 
		RULE_physicalPropertiesClusterClause = 352, RULE_physicalPropertiesOrganizationClause = 353, 
		RULE_deferredSegmentCreationClause = 354, RULE_heapOrganizedTableClauseElement = 355, 
		RULE_indexOrganizedTableClauseElement = 356, RULE_indexOrganizedOverflowClause = 357, 
		RULE_overflowClause = 358, RULE_includingOverflowClause = 359, RULE_pCTThresholdClause = 360, 
		RULE_mappingTableClause = 361, RULE_tableCompressionClause = 362, RULE_indexCompressionClause = 363, 
		RULE_compressionOperations = 364, RULE_segmentAttributesClause = 365, 
		RULE_segmentAttributesClauseElement = 366, RULE_onCommitClause = 367, 
		RULE_relationPropertiesListClause = 368, RULE_relationPropertiesClause = 369, 
		RULE_supplementalLoggingPropsClause = 370, RULE_supplementalLogGrpClause = 371, 
		RULE_supplementalIdKeyClause = 372, RULE_supplementalIdKeyClauseItem = 373, 
		RULE_columnDeclarationClause = 374, RULE_columnIdentityClause = 375, RULE_columnDefaultValueClause = 376, 
		RULE_virtualColumnDefinition = 377, RULE_computedColumnExpression = 378, 
		RULE_tableRefConstraintClause = 379, RULE_tableRefWithRowidClause = 380, 
		RULE_tableRefScopeForClause = 381, RULE_columnRefConstraintClause = 382, 
		RULE_withRowidClause = 383, RULE_scopeIsClause = 384, RULE_foreignKeyClause = 385, 
		RULE_tableRefForeignKeyClause = 386, RULE_materializedViewStatement = 387, 
		RULE_materializedViewHeader = 388, RULE_objectMaterializedViewClause = 389, 
		RULE_materializedViewPrebuiltTableClause = 390, RULE_materializedViewPhysicalClusterProperties = 391, 
		RULE_materializedViewPhysicalClusterColumnList = 392, RULE_materializedViewProperties = 393, 
		RULE_materializedViewPropertiesCacheClause = 394, RULE_materializedViewPropertiesBuildClause = 395, 
		RULE_materializedViewUsingIndexClause = 396, RULE_materializedViewUsingIndexAttributesListClause = 397, 
		RULE_materializedViewRefreshClause = 398, RULE_materializedViewRefreshOptions = 399, 
		RULE_materializedViewRefreshType = 400, RULE_materializedViewRefreshTrigger = 401, 
		RULE_materializedViewRefreshSchedule = 402, RULE_materializedViewRefreshRowIdentificationClause = 403, 
		RULE_materializedViewRefreshRollbackSegmentClause = 404, RULE_materializedViewRefreshUsingConstraints = 405, 
		RULE_evaluationEditionClause = 406, RULE_materializedViewQueryComputationClause = 407, 
		RULE_materializedViewQueryRewriteClause = 408, RULE_unusableEditionsBeforeClause = 409, 
		RULE_unusableEditionsBeginningWithClause = 410, RULE_viewStatement = 411, 
		RULE_viewHeader = 412, RULE_xmlTypeViewClause = 413, RULE_xmlSchemaSpec = 414, 
		RULE_xmlSchemaClause = 415, RULE_xmlSchemaElementClause = 416, RULE_xmlSchemaSpecNonschemaClause = 417, 
		RULE_xmlSchemaSpecAnyschemaClause = 418, RULE_objectViewClause = 419, 
		RULE_underClause = 420, RULE_withObjectIdentifierClause = 421, RULE_parenthesizedExpressionList = 422, 
		RULE_forceNoForceClause = 423, RULE_viewBody = 424, RULE_subqueryRestrictionClause = 425, 
		RULE_viewAliasOrConstraintList = 426, RULE_viewAliasOrTableConstraint = 427, 
		RULE_viewAlias = 428, RULE_attributeOrConstraintList = 429, RULE_attributeOrTableConstraint = 430, 
		RULE_attributeConstraintClause = 431, RULE_tableConstraintClause = 432, 
		RULE_columnListInParenElementClause = 433, RULE_columnConstraintClause = 434, 
		RULE_constraintStateClause = 435, RULE_deferrableConstraintClause = 436, 
		RULE_initiallyConstraintClause = 437, RULE_enableClause = 438, RULE_relyConstraintClause = 439, 
		RULE_usingIndexConstraintClause = 440, RULE_usingIndexAttributesListConstraintClause = 441, 
		RULE_loggingClause = 442, RULE_tablespaceClause = 443, RULE_sortNoSortClause = 444, 
		RULE_storageAttributesClause = 445, RULE_storageAttributeClause = 446, 
		RULE_maxSizeClause = 447, RULE_encryptClause = 448, RULE_nextInitialStorageClause = 449, 
		RULE_optimalStorageClause = 450, RULE_minextentsStorageClause = 451, RULE_maxextentsStorageClause = 452, 
		RULE_pctIncreaseStorageClause = 453, RULE_freeListsStorageClause = 454, 
		RULE_freeListGroupsStorageClause = 455, RULE_bufferPoolStorageClause = 456, 
		RULE_flashCacheStorageClause = 457, RULE_cellFlashCacheStorageClause = 458, 
		RULE_computeStatisticsClause = 459, RULE_validateClause = 460, RULE_exceptionsIntoConstraintClause = 461, 
		RULE_byteSizeLiteral = 462, RULE_constraintNameClause = 463, RULE_constraintNullNotNullClause = 464, 
		RULE_constraintUniqueClause = 465, RULE_constraintPrimaryKeyClause = 466, 
		RULE_constraintCheckClause = 467, RULE_conditionInParens = 468, RULE_constraintForeignKeyClause = 469, 
		RULE_constraintForeignKeyRefClause = 470, RULE_onDeleteActionClause = 471, 
		RULE_triggerStatement = 472, RULE_simpleDmlTrigger = 473, RULE_insteadOfDmlTrigger = 474, 
		RULE_compoundDmlTrigger = 475, RULE_systemTrigger = 476, RULE_compoundTriggerBlock = 477, 
		RULE_timingPointSection = 478, RULE_timingPoint = 479, RULE_callStatement = 480, 
		RULE_callStatementWithExpression = 481, RULE_callIntoClause = 482, RULE_indicatorClause = 483, 
		RULE_createTriggerWhenClause = 484, RULE_triggerStatementOnClause = 485, 
		RULE_ddlEventsListClause = 486, RULE_databaseEventsListClause = 487, RULE_ddlEvent = 488, 
		RULE_databaseEvent = 489, RULE_triggerCallTypeClause = 490, RULE_dmlTriggerEventClause = 491, 
		RULE_dmlTriggerEventsList = 492, RULE_dmlTriggerEvent = 493, RULE_ofColumnListClause = 494, 
		RULE_dmlTriggerEventOnClause = 495, RULE_nestedTableClause = 496, RULE_referencingClause = 497, 
		RULE_referencingItem = 498, RULE_forEachRowClause = 499, RULE_returningClause = 500, 
		RULE_onlyClause = 501, RULE_selectStatement = 502, RULE_selectStatementMember = 503, 
		RULE_unionOperator = 504, RULE_withCheckOption = 505, RULE_withReadOnly = 506, 
		RULE_overOrderByClause = 507, RULE_withinGroupOrderByClause = 508, RULE_orderByClause = 509, 
		RULE_orderByList = 510, RULE_orderByListItem = 511, RULE_ascDescSortAtrtributeClause = 512, 
		RULE_orderByNullsAttributeClause = 513, RULE_forUpdateClause = 514, RULE_delimiterOf = 515, 
		RULE_waitOrNowaitClause = 516, RULE_skipLockedClause = 517, RULE_subqueryFactoringClause = 518, 
		RULE_subqueryFactoringClauseItem = 519, RULE_subqueryFactoringColumnsList = 520, 
		RULE_searchClause = 521, RULE_subqueryFactoringSetClause = 522, RULE_cycleClause = 523, 
		RULE_toCycleClause = 524, RULE_defaultCycleClause = 525, RULE_basicSelectStatement = 526, 
		RULE_selectExpressionList = 527, RULE_intoClause = 528, RULE_whereClause = 529, 
		RULE_groupByClause = 530, RULE_groupByClauseExpressionList = 531, RULE_groupByComplexExpressionList = 532, 
		RULE_groupByComplexListExpressionItem = 533, RULE_groupByComplexExpressionListWithParenthesis = 534, 
		RULE_groupByClauseExpressionListItem = 535, RULE_grandTotal = 536, RULE_groupingSetsClause = 537, 
		RULE_groupingSetsList = 538, RULE_groupingSet = 539, RULE_groupingSetItem = 540, 
		RULE_groupingSetItemList = 541, RULE_rollupCubeClause = 542, RULE_groupingExpressionList = 543, 
		RULE_groupingExpressionListItem = 544, RULE_groupingExpressionNestedItem = 545, 
		RULE_connectByClause = 546, RULE_startWithClause = 547, RULE_havingClause = 548, 
		RULE_fromClause = 549, RULE_complexFromClauseItem = 550, RULE_complexFromClauseItemInner = 551, 
		RULE_crossOrNaturalJoin = 552, RULE_normalJoinType = 553, RULE_outerJoinType = 554, 
		RULE_onCondition = 555, RULE_usingCondition = 556, RULE_queryPartitionClause = 557, 
		RULE_fromClauseItemPartitionClause = 558, RULE_fromClauseItem = 559, RULE_jsonTable = 560, 
		RULE_jsonTableOnClause = 561, RULE_jsonTableOnCondition = 562, RULE_jsonExpression = 563, 
		RULE_jsonColumnsClause = 564, RULE_jsonColumnDefinition = 565, RULE_jsonExistsColumn = 566, 
		RULE_jsonExistsOnClause = 567, RULE_jsonExistsOnCondition = 568, RULE_jsonQueryColumn = 569, 
		RULE_jsonQueryWrapperClause = 570, RULE_jsonQueryOnClause = 571, RULE_jsonQueryOnCondition = 572, 
		RULE_jsonValueColumn = 573, RULE_jsonValueOnClause = 574, RULE_jsonValueOnCondition = 575, 
		RULE_jsonNestedPath = 576, RULE_ordinalityColumn = 577, RULE_flashbackAndPivotClauses = 578, 
		RULE_xmlTableItem = 579, RULE_xmlNamespacesClause = 580, RULE_xmlTableOptions = 581, 
		RULE_xmlParsingClause = 582, RULE_xmlTableColumn = 583, RULE_pivotUnpivotClause = 584, 
		RULE_pivotClause = 585, RULE_pivotBody = 586, RULE_pivotForClause = 587, 
		RULE_identifierOrIdentifierList = 588, RULE_pivotUnpivotIdentifierList = 589, 
		RULE_pivotInClause = 590, RULE_pivotInExpressionList = 591, RULE_pivotInExpressionListItem = 592, 
		RULE_pivotAny = 593, RULE_expressionOrExpressionList = 594, RULE_pivotExpressionList = 595, 
		RULE_unpivotClause = 596, RULE_unpivotBody = 597, RULE_unpivotInClause = 598, 
		RULE_unpivotInExpressionList = 599, RULE_unpivotInExpressionListItem = 600, 
		RULE_literalOrLiteralListAlias = 601, RULE_literalOrLiteralList = 602, 
		RULE_literalListWithParenthesis = 603, RULE_periodSpecification = 604, 
		RULE_periodAsOfClause = 605, RULE_periodBetweenClause = 606, RULE_periodForTimeColumn = 607, 
		RULE_flashBackType = 608, RULE_sampleClause = 609, RULE_sampleSeedClause = 610, 
		RULE_sampleClauseValues = 611, RULE_aliasIdentifier = 612, RULE_simpleAliasIdentifier = 613, 
		RULE_insertColumnListClause = 614, RULE_valuesClause = 615, RULE_insertExpressionList = 616, 
		RULE_insertStatement = 617, RULE_singleTableInsertStatement = 618, RULE_multiTableInsertStatement = 619, 
		RULE_multiTableInsertItem = 620, RULE_conditionalInsertStatement = 621, 
		RULE_conditionalInsertWhenEntry = 622, RULE_conditionalInsertThenClause = 623, 
		RULE_conditionalInsertElseClause = 624, RULE_setClause = 625, RULE_setClauseValueClause = 626, 
		RULE_setList = 627, RULE_setColumnListClause = 628, RULE_updateStatement = 629, 
		RULE_deleteStatement = 630, RULE_closeStatement = 631, RULE_fetchStatement = 632, 
		RULE_fetchTargetList = 633, RULE_bulkCollectIntoClause = 634, RULE_fetchLimitClause = 635, 
		RULE_openStatement = 636, RULE_openForClause = 637, RULE_usingList = 638, 
		RULE_usingListItem = 639, RULE_commitWorkStatement = 640, RULE_commitWorkCommentClause = 641, 
		RULE_commitWorkWriteClause = 642, RULE_commitWorkForceClause = 643, RULE_setTransactionStatement = 644, 
		RULE_setTransactionName = 645, RULE_setTransactionReadClause = 646, RULE_isolationLevelClause = 647, 
		RULE_useRollbackSegmentClause = 648, RULE_rollbackWorkStatement = 649, 
		RULE_toSavepointClause = 650, RULE_savepointStatement = 651, RULE_assignmentStatement = 652, 
		RULE_errorLoggingClause = 653, RULE_errorLoggingIntoClause = 654, RULE_errorLoggingTagExpression = 655, 
		RULE_errorLoggingRejectLimit = 656, RULE_mergeStatement = 657, RULE_mergeUpdateOrInsertClause = 658, 
		RULE_mergeUsingClause = 659, RULE_mergeConditionClause = 660, RULE_mergeUpdateClause = 661, 
		RULE_deleteWhereClause = 662, RULE_mergeInsertClause = 663, RULE_executeImmediateStatement = 664, 
		RULE_executeReturningClause = 665, RULE_pipeRowStatement = 666, RULE_raiseStatement = 667, 
		RULE_truncateTableStatement = 668, RULE_truncateTableLogClause = 669, 
		RULE_preservePurgeClause = 670, RULE_truncateClusterStatement = 671, RULE_truncateStatementStorageClause = 672, 
		RULE_lockTableStatement = 673, RULE_lockTableItemList = 674, RULE_lockTableModeClause = 675, 
		RULE_lockTableNowaitClause = 676, RULE_translateExpression = 677, RULE_charExpression = 678, 
		RULE_controlStructure = 679, RULE_forAllStatement = 680, RULE_forAllInClause = 681, 
		RULE_forAllIndicesClause = 682, RULE_forAllIndeciesBoundsClause = 683, 
		RULE_forAllValuesClause = 684, RULE_forAllLowerUpperBoundClause = 685, 
		RULE_forAllSaveExceptionsClause = 686, RULE_ifStatement = 687, RULE_thenBlock = 688, 
		RULE_elseBlock = 689, RULE_elsIfBlock = 690, RULE_ifDirectiveStatement = 691, 
		RULE_thenDirectiveBlock = 692, RULE_elseDirectiveBlock = 693, RULE_elsIfDirectiveBlock = 694, 
		RULE_errorDirectiveBlock = 695, RULE_loopStatement = 696, RULE_loopBlock = 697, 
		RULE_whileStatement = 698, RULE_endLoopClause = 699, RULE_forStatement = 700, 
		RULE_forStatementInClause = 701, RULE_continueStatement = 702, RULE_caseStatement = 703, 
		RULE_simpleCaseStatement = 704, RULE_searchedCaseStatement = 705, RULE_caseStatementWhenEntry = 706, 
		RULE_blockStatement = 707, RULE_blockBody = 708, RULE_endClause = 709, 
		RULE_exceptionBlock = 710, RULE_exceptionHandler = 711, RULE_exceptionNameList = 712, 
		RULE_gotoStatement = 713, RULE_label = 714, RULE_labelBody = 715, RULE_nullStatement = 716, 
		RULE_returnStatement = 717, RULE_procedureCall = 718, RULE_exitStatement = 719, 
		RULE_optionalLabelWhenCondition = 720, RULE_whenCondition = 721, RULE_declarationBlock = 722, 
		RULE_declarationBlockItem = 723, RULE_notNullClause = 724, RULE_nullClause = 725, 
		RULE_defaultValueClause = 726, RULE_cursorReturnClause = 727, RULE_exceptionDeclaration = 728, 
		RULE_typeDeclaration = 729, RULE_delimiterAs = 730, RULE_newType = 731, 
		RULE_recordTypeDeclaration = 732, RULE_recordFieldDeclaration = 733, RULE_objectTypeDeclaration = 734, 
		RULE_objectFieldDeclaration = 735, RULE_varrayTypeDeclaration = 736, RULE_varraySizeLimitClause = 737, 
		RULE_typeDeclararionElementTypeClause = 738, RULE_tableTypeDeclaration = 739, 
		RULE_tableTypeIndexByClause = 740, RULE_refCursorTypeDeclaration = 741, 
		RULE_subtypeDeclaration = 742, RULE_cursorDeclaration = 743, RULE_cursorHeader = 744, 
		RULE_cursorSelect = 745, RULE_declarationPragma = 746, RULE_exceptionInitPragma = 747, 
		RULE_autonomousTransactionPragma = 748, RULE_seriallyReusablePragma = 749, 
		RULE_restrictReferencesPragma = 750, RULE_builtinPragma = 751, RULE_fipsflagPragma = 752, 
		RULE_interfacePragma = 753, RULE_timestampPragma = 754, RULE_newNamesPragma = 755, 
		RULE_variableDeclaration = 756, RULE_variableConstantClause = 757, RULE_dropStatement = 758, 
		RULE_dropTypeStatement = 759, RULE_forceValidateClause = 760, RULE_dropTypeBodyStatement = 761, 
		RULE_dropTriggerStatement = 762, RULE_dropIndexStatement = 763, RULE_alterStatement = 764, 
		RULE_alterTypeStatement = 765, RULE_alterTypeSpecifications = 766, RULE_alterTriggerStatement = 767, 
		RULE_renameClause = 768, RULE_compileClause = 769, RULE_alterIndexStatement = 770, 
		RULE_indexOptions = 771, RULE_deallocateUnusedClause = 772, RULE_keepSizeClause = 773, 
		RULE_allocateExtentClause = 774, RULE_extentOptions = 775, RULE_extentOption = 776, 
		RULE_shrinkClause = 777, RULE_physicalAttribute = 778, RULE_rebuildClause = 779, 
		RULE_rebuildOptions = 780, RULE_keyCompression = 781, RULE_parametersClause = 782, 
		RULE_alterIndexPartitioning = 783, RULE_modifyIndexDefaultAttributes = 784, 
		RULE_modifyIndexAttributes = 785, RULE_addHashIndexPartition = 786, RULE_coalesceIndexPartition = 787, 
		RULE_modifyIndexPartition = 788, RULE_modifyIndexPartitionOptions = 789, 
		RULE_renameIndexPartition = 790, RULE_dropIndexPartition = 791, RULE_splitIndexPartition = 792, 
		RULE_splitIndexPartitionAtClause = 793, RULE_splitIndexPartitionIntoClause = 794, 
		RULE_indexPartitionDescription = 795, RULE_modifyIndexSubpartition = 796, 
		RULE_compileTypeClause = 797, RULE_compilerParametersClause = 798, RULE_replaceTypeClause = 799, 
		RULE_alterMethodSpecifications = 800, RULE_alterMethodSpecification = 801, 
		RULE_alterAttributeDefinition = 802, RULE_addOrModifyAttributeDefinition = 803, 
		RULE_alterTypeDeclaration = 804, RULE_alterTypeDeclarationInParen = 805, 
		RULE_dropAttributeDefinition = 806, RULE_alterCollectionClauses = 807, 
		RULE_dependentHandlingClause = 808, RULE_invalidateHandlingClause = 809, 
		RULE_cascadeHandlingClause = 810, RULE_dependentTypesClause = 811, RULE_includingTableData = 812, 
		RULE_convertToSubstitutable = 813, RULE_forceExceptionsClause = 814, RULE_alterSequenceStatement = 815, 
		RULE_sequenceOption = 816, RULE_identityOption = 817, RULE_sequenceIncrementClause = 818, 
		RULE_sequenceStartWithClause = 819, RULE_sequenceMaxValueClause = 820, 
		RULE_sequenceMinValueClause = 821, RULE_sequenceCycleClause = 822, RULE_sequenceCacheClause = 823, 
		RULE_sequenceOrderClause = 824, RULE_sequenceScaleClause = 825, RULE_sequenceKeepClause = 826, 
		RULE_sequenceShardClause = 827, RULE_sequenceScopeClause = 828, RULE_createTypeStatement = 829, 
		RULE_alterTypeEmbeddedStatement = 830, RULE_completeTypeStatement = 831, 
		RULE_objectTypeStatement = 832, RULE_topLevelObjectType = 833, RULE_subType = 834, 
		RULE_objectTypeDeclarationItems = 835, RULE_objectTypeDeclarationItem = 836, 
		RULE_objectTypeAttributeDeclaration = 837, RULE_varrayTypeStatement = 838, 
		RULE_nestedTableTypeStatement = 839, RULE_oidClause = 840, RULE_createTypeBodyStatement = 841, 
		RULE_objectTypeBodyDeclarationItems = 842, RULE_objectTypeRoutine = 843, 
		RULE_objectTypeMemberStaticRoutine = 844, RULE_objectTypeConstructor = 845, 
		RULE_constructorHeader = 846, RULE_constructorReturnClause = 847, RULE_objectTypeMapOrderFunction = 848, 
		RULE_inheritanceClause = 849, RULE_createSynonymStatement = 850, RULE_createSynonymSharingClause = 851;
	public static readonly string[] ruleNames = {
		"expressionInputFile", "conditionInputFile", "hintInputFile", "plSqlCheckInputFile", 
		"dynamicSqlInputFile", "computedColumnExpressionInputFile", "expressionListInputFile", 
		"hintsList", "hintItem", "hintParams", "complexIndexHint", "queryBlock", 
		"sqlInputFile", "sqlStatementBatch", "sqlStatement", "plSqlStatementBatch", 
		"plSqlStatement", "routineSignature", "procedureOrFunctionSignature", 
		"literal", "quoteCharacterStringLiteral", "characterStringLiteral", "unicodeCharacterStringLiteral", 
		"binaryStringLiteral", "booleanLiteral", "dateLiteral", "timestampLiteral", 
		"intervalLiteral", "intervalLiteralFieldClause", "intervalLiteralFieldPrecision", 
		"floatingPointBinaryLiteral", "simpleIdentifierRegularIdentifier", "dotInIdentifier", 
		"identifier", "plainIdentifier", "plainRemoteIdentifier", "multipartPlainIdentifier", 
		"asterisk", "dbLink", "simpleIdentifier", "nestedCollectionSimpleIdentifier", 
		"plainIdentifierAsStringLiteral", "typeReferenceOpaqueFixed", "plainSimpleIdentifierAsStringLiteral", 
		"simpleIdentifierParams", "localSimpleIdentifierWithoutParentheses", "simpleIdentifierWithoutParentheses", 
		"bindParameter", "typeReference", "identifierTimestamp", "identifierTime", 
		"identifierWith", "identifierLocal", "identifierZone", "identifierInterval", 
		"identifierTo", "identifierLong", "identifierRaw", "identifierLongRaw", 
		"identifierDoublePrecision", "identifierCharacter", "identifierNationalCharacter", 
		"identifierNChar", "identifierNVarChar2", "identifierVarChar", "identifierVarChar2", 
		"identifierString", "charIdentifierParams", "typeReferenceTimestampCase", 
		"typeReferenceIntervalCase", "typeReferenceCharCase", "collationSpecClause", 
		"typeReferenceLongAndRawCase", "typeReferenceAttributes", "typeReferenceCharacterSetAttribute", 
		"typeReferenceCharacterSetModifier", "typeReferenceRangeAttribute", "delimiterDoubleDot", 
		"typeReferenceModifierAttribute", "typeReferenceRefCase", "fullExpression", 
		"fullOrCondition", "fullAndCondition", "fullUnaryCondition", "fullAtomicCondition", 
		"delimiterCurrentOf", "delimiterExists", "fullAtomicCondition1", "inPureExpression", 
		"delimiterAny", "delimiterSome", "delimiterAll", "delimiterNot", "delimiterIs", 
		"delimiterIn", "delimiterLParen", "delimiterRParen", "typesComparison", 
		"typeComparisonNames", "pureExpression", "bitwiseLevelExpression", "addLevelExpression", 
		"addLevelOperator", "divideLevelOperator", "unaryExpression", "xmlQuery", 
		"xmlQueryDelegate", "xmlPassingParameterList", "xmlPassingParameterListItem", 
		"xmlCast", "newExpression", "treatExpression", "treatExpressionParameters", 
		"treatExpressionAsClause", "treatExpressionReturnValue", "multisetExpression", 
		"multisetOperator", "dateTimeAtClause", "dateTimeAtLocalClause", "dateTimeAtTimeZoneClause", 
		"keepExpression", "keepClause", "withinExpression", "withinExpressionParams", 
		"overExpression", "overExpressionParams", "overExpressionPartitionClause", 
		"overExpressionWindowingClause", "overExpressionWindowingClauseBetween", 
		"overExpressionWindowingClauseSingle", "overExpressionWindowingClauseItem", 
		"overExpressionWindowingClauseItemExpression", "cursorAttributeExpression", 
		"bulkExpression", "bulkExceptionExpression", "bulkRowCountExpression", 
		"collectionIndex", "powerExpression", "delimiterNull", "castExpression", 
		"cursorExpression", "caseExpression", "simpleCaseExpression", "simpleCaseWhenEntry", 
		"caseElseEntry", "searchedCaseExpression", "searchedCaseWhenEntry", "priorExpression", 
		"connectByRootExpression", "sysConnectByPathExpression", "trimExpression", 
		"trimExtClause", "decodeExpression", "extractDatetimeExpression", "extractXMLExpression", 
		"xmlTypeInstance", "xpathString", "xmlNamespace", "extractDatetimeFromClause", 
		"delimiterDate", "multiColumnCondition", "overlapsCondition", "comparisonList", 
		"collectionsComparison", "collectionsComparisonSubmultiset", "collectionsComparisonMemberOf", 
		"collectionsComparisonIsASet", "collectionsComparisonIsEmpty", "likeOperator", 
		"escapeClause", "betweenOperator", "betweenAndOperator", "comparisonPairOperator", 
		"flattenedQuery", "asFlattenedQuery", "flattenedQueryNestedTable", "fullExpressionList", 
		"fullExpressionListItem", "expressionList", "multiItemExpressionList", 
		"defaultExpression", "expressionListItem", "xmlaggExpression", "parameterName", 
		"alias", "identifierList", "columnListElementClause", "columnListItem", 
		"complexColumnListItem", "createStatement", "createStatementReplaceClause", 
		"createUserStatement", "createUserIdentificationClause", "createUserPasswordIdentificationClause", 
		"createUserExternalIdentificationClause", "createUserGlobalIdentificationClause", 
		"createUserNoAuthenticationClause", "createUserOption", "defaultCollationOption", 
		"createUserDefaultTablespaceOption", "createUserTemporaryTablespaceOption", 
		"createUserTablespaceQuotaOption", "createUserProfileOption", "createUserPasswordExpireOption", 
		"createUserAccountOption", "createUserEnableEditionsOption", "createUserContainerOption", 
		"createIndexStatement", "clusterIndexClause", "tableIndexClause", "tableIndexExpression", 
		"bitmapJoinIndexClause", "bitmapJoinIndexExpression", "bitmapJoinIndexFromClauseItem", 
		"indexProperties", "globalPartitionedIndex", "localPartitionedIndex", 
		"indexOnSimplePartitionedTableClause", "indexOnSimplePartitionedTableClauseItem", 
		"indexOnHashPartitionedTable", "indexOnHashPartitionedTableClauseItem", 
		"indexOnCompPartitionedTable", "indexOnCompPartitionedTableClauseItem", 
		"indexSubpartitionClause", "indexSubpartitionClauseItem", "indexAttribute", 
		"visibilityClause", "partialIndexClause", "indexTypeClause", "localIndexClause", 
		"localIndexClauseItem", "unstructuredIndexParametersClause", "simpleTablespaceClause", 
		"createSequenceStatement", "createSequenceSharingClause", "createEditionableBatchWideStatement", 
		"editionOptionClause", "packageStatement", "packageBodyStatement", "packageDeclarationBlock", 
		"procedureStatement", "procedureSignature", "procedureImplementation", 
		"procedureHeader", "routineBody", "routineBodyAsIsClause", "invokerRightsClause", 
		"procedureCallSpecClause", "javaDeclarationClause", "cDeclarationClause", 
		"cDeclarationNameClause", "cDeclarationLibraryClause", "cDeclarationAgentClause", 
		"cDeclarationContextClause", "cDeclarationParametersClause", "argumentList", 
		"argument", "argumentNoCopyClause", "argumentModeClause", "argumentDefaultValue", 
		"functionStatement", "functionSignature", "functionImplementation", "functionHeader", 
		"functionReturnClause", "functionDeterministicClause", "functionParallelEnableClause", 
		"parallelOnPartitionOption", "parallelOnPartitionBy", "columnListItemInParen", 
		"parallelOnPartitionStreamingClause", "parallelOnPartitionStreamingClauseBy", 
		"resultCacheClause", "resultCacheReliesOnClause", "functionAggregateClause", 
		"functionPipelinedClause", "createTableStatement", "tableHeader", "createObjectTableStatement", 
		"memOptimizeClause", "parentClause", "oidIndexClause", "oidIndexClauseList", 
		"objectIdentifierIsClause", "objectTableOfClause", "createRelationTableStatement", 
		"createXMLTypeTableStatement", "tablePropertiesClause", "columnProperties", 
		"xmlTypeColumnProperties", "xmlTypeStorageClause", "xmlTypeStoreAsClause", 
		"xmlTypeStoreAsObjectRelationalClause", "xmlTypeStoreAsLobClause", "xmlTypeStoreAllClause", 
		"objectTypeColProperties", "varrayColProperties", "nestedTableColProperties", 
		"nestedTableObjectProperties", "returnAsClause", "objectPropertiesListClause", 
		"objectProperties", "storeAsClause", "nestedItemClause", "asSubqueryClause", 
		"rowMovementClause", "enableDisableConstraintClause", "keepDropIndexClause", 
		"cascadeClause", "monitoringClause", "rowdependenciesClause", "parallelClause", 
		"partitioningDefinitionClause", "compositePartitioning", "subPartitionByHash", 
		"subpartitionsStoreInClause", "subPartitionByList", "subPartitionTemplate", 
		"subPartitionDefinitionListClause", "subPartitionDefinitionClause", "partitionByListClause", 
		"partitionByHashClause", "partitionsSimpleClause", "partitionSimpleListClause", 
		"partitionSimpleClause", "partitionByRangeClause", "partitionDefinitionListClause", 
		"partitionDefinitionClause", "tablePartitionDescription", "partitionLevelSubpartitioningClause", 
		"subpartitionSpecList", "subpartitionSpec", "partitioningStorageClause", 
		"listValuesClause", "subpartitionsSimpleClause", "partitionsStoreInClause", 
		"tablespaceListClause", "varrayStorageClause", "substitutableColumnClause", 
		"notSubstitutableClause", "elementIsOfTypeClause", "delimiterOnly", "storeAsLobClause", 
		"lOBStorageClause", "lOBPropertiesListClause", "lobPropertiesListElementClause", 
		"lobStoreAsClause", "rangeValuesClause", "valuesLessThanListClause", "valuesLessThanListItem", 
		"partitionByRangeColumnList", "physicalPropertiesClause", "physicalPropertiesClusterClause", 
		"physicalPropertiesOrganizationClause", "deferredSegmentCreationClause", 
		"heapOrganizedTableClauseElement", "indexOrganizedTableClauseElement", 
		"indexOrganizedOverflowClause", "overflowClause", "includingOverflowClause", 
		"pCTThresholdClause", "mappingTableClause", "tableCompressionClause", 
		"indexCompressionClause", "compressionOperations", "segmentAttributesClause", 
		"segmentAttributesClauseElement", "onCommitClause", "relationPropertiesListClause", 
		"relationPropertiesClause", "supplementalLoggingPropsClause", "supplementalLogGrpClause", 
		"supplementalIdKeyClause", "supplementalIdKeyClauseItem", "columnDeclarationClause", 
		"columnIdentityClause", "columnDefaultValueClause", "virtualColumnDefinition", 
		"computedColumnExpression", "tableRefConstraintClause", "tableRefWithRowidClause", 
		"tableRefScopeForClause", "columnRefConstraintClause", "withRowidClause", 
		"scopeIsClause", "foreignKeyClause", "tableRefForeignKeyClause", "materializedViewStatement", 
		"materializedViewHeader", "objectMaterializedViewClause", "materializedViewPrebuiltTableClause", 
		"materializedViewPhysicalClusterProperties", "materializedViewPhysicalClusterColumnList", 
		"materializedViewProperties", "materializedViewPropertiesCacheClause", 
		"materializedViewPropertiesBuildClause", "materializedViewUsingIndexClause", 
		"materializedViewUsingIndexAttributesListClause", "materializedViewRefreshClause", 
		"materializedViewRefreshOptions", "materializedViewRefreshType", "materializedViewRefreshTrigger", 
		"materializedViewRefreshSchedule", "materializedViewRefreshRowIdentificationClause", 
		"materializedViewRefreshRollbackSegmentClause", "materializedViewRefreshUsingConstraints", 
		"evaluationEditionClause", "materializedViewQueryComputationClause", "materializedViewQueryRewriteClause", 
		"unusableEditionsBeforeClause", "unusableEditionsBeginningWithClause", 
		"viewStatement", "viewHeader", "xmlTypeViewClause", "xmlSchemaSpec", "xmlSchemaClause", 
		"xmlSchemaElementClause", "xmlSchemaSpecNonschemaClause", "xmlSchemaSpecAnyschemaClause", 
		"objectViewClause", "underClause", "withObjectIdentifierClause", "parenthesizedExpressionList", 
		"forceNoForceClause", "viewBody", "subqueryRestrictionClause", "viewAliasOrConstraintList", 
		"viewAliasOrTableConstraint", "viewAlias", "attributeOrConstraintList", 
		"attributeOrTableConstraint", "attributeConstraintClause", "tableConstraintClause", 
		"columnListInParenElementClause", "columnConstraintClause", "constraintStateClause", 
		"deferrableConstraintClause", "initiallyConstraintClause", "enableClause", 
		"relyConstraintClause", "usingIndexConstraintClause", "usingIndexAttributesListConstraintClause", 
		"loggingClause", "tablespaceClause", "sortNoSortClause", "storageAttributesClause", 
		"storageAttributeClause", "maxSizeClause", "encryptClause", "nextInitialStorageClause", 
		"optimalStorageClause", "minextentsStorageClause", "maxextentsStorageClause", 
		"pctIncreaseStorageClause", "freeListsStorageClause", "freeListGroupsStorageClause", 
		"bufferPoolStorageClause", "flashCacheStorageClause", "cellFlashCacheStorageClause", 
		"computeStatisticsClause", "validateClause", "exceptionsIntoConstraintClause", 
		"byteSizeLiteral", "constraintNameClause", "constraintNullNotNullClause", 
		"constraintUniqueClause", "constraintPrimaryKeyClause", "constraintCheckClause", 
		"conditionInParens", "constraintForeignKeyClause", "constraintForeignKeyRefClause", 
		"onDeleteActionClause", "triggerStatement", "simpleDmlTrigger", "insteadOfDmlTrigger", 
		"compoundDmlTrigger", "systemTrigger", "compoundTriggerBlock", "timingPointSection", 
		"timingPoint", "callStatement", "callStatementWithExpression", "callIntoClause", 
		"indicatorClause", "createTriggerWhenClause", "triggerStatementOnClause", 
		"ddlEventsListClause", "databaseEventsListClause", "ddlEvent", "databaseEvent", 
		"triggerCallTypeClause", "dmlTriggerEventClause", "dmlTriggerEventsList", 
		"dmlTriggerEvent", "ofColumnListClause", "dmlTriggerEventOnClause", "nestedTableClause", 
		"referencingClause", "referencingItem", "forEachRowClause", "returningClause", 
		"onlyClause", "selectStatement", "selectStatementMember", "unionOperator", 
		"withCheckOption", "withReadOnly", "overOrderByClause", "withinGroupOrderByClause", 
		"orderByClause", "orderByList", "orderByListItem", "ascDescSortAtrtributeClause", 
		"orderByNullsAttributeClause", "forUpdateClause", "delimiterOf", "waitOrNowaitClause", 
		"skipLockedClause", "subqueryFactoringClause", "subqueryFactoringClauseItem", 
		"subqueryFactoringColumnsList", "searchClause", "subqueryFactoringSetClause", 
		"cycleClause", "toCycleClause", "defaultCycleClause", "basicSelectStatement", 
		"selectExpressionList", "intoClause", "whereClause", "groupByClause", 
		"groupByClauseExpressionList", "groupByComplexExpressionList", "groupByComplexListExpressionItem", 
		"groupByComplexExpressionListWithParenthesis", "groupByClauseExpressionListItem", 
		"grandTotal", "groupingSetsClause", "groupingSetsList", "groupingSet", 
		"groupingSetItem", "groupingSetItemList", "rollupCubeClause", "groupingExpressionList", 
		"groupingExpressionListItem", "groupingExpressionNestedItem", "connectByClause", 
		"startWithClause", "havingClause", "fromClause", "complexFromClauseItem", 
		"complexFromClauseItemInner", "crossOrNaturalJoin", "normalJoinType", 
		"outerJoinType", "onCondition", "usingCondition", "queryPartitionClause", 
		"fromClauseItemPartitionClause", "fromClauseItem", "jsonTable", "jsonTableOnClause", 
		"jsonTableOnCondition", "jsonExpression", "jsonColumnsClause", "jsonColumnDefinition", 
		"jsonExistsColumn", "jsonExistsOnClause", "jsonExistsOnCondition", "jsonQueryColumn", 
		"jsonQueryWrapperClause", "jsonQueryOnClause", "jsonQueryOnCondition", 
		"jsonValueColumn", "jsonValueOnClause", "jsonValueOnCondition", "jsonNestedPath", 
		"ordinalityColumn", "flashbackAndPivotClauses", "xmlTableItem", "xmlNamespacesClause", 
		"xmlTableOptions", "xmlParsingClause", "xmlTableColumn", "pivotUnpivotClause", 
		"pivotClause", "pivotBody", "pivotForClause", "identifierOrIdentifierList", 
		"pivotUnpivotIdentifierList", "pivotInClause", "pivotInExpressionList", 
		"pivotInExpressionListItem", "pivotAny", "expressionOrExpressionList", 
		"pivotExpressionList", "unpivotClause", "unpivotBody", "unpivotInClause", 
		"unpivotInExpressionList", "unpivotInExpressionListItem", "literalOrLiteralListAlias", 
		"literalOrLiteralList", "literalListWithParenthesis", "periodSpecification", 
		"periodAsOfClause", "periodBetweenClause", "periodForTimeColumn", "flashBackType", 
		"sampleClause", "sampleSeedClause", "sampleClauseValues", "aliasIdentifier", 
		"simpleAliasIdentifier", "insertColumnListClause", "valuesClause", "insertExpressionList", 
		"insertStatement", "singleTableInsertStatement", "multiTableInsertStatement", 
		"multiTableInsertItem", "conditionalInsertStatement", "conditionalInsertWhenEntry", 
		"conditionalInsertThenClause", "conditionalInsertElseClause", "setClause", 
		"setClauseValueClause", "setList", "setColumnListClause", "updateStatement", 
		"deleteStatement", "closeStatement", "fetchStatement", "fetchTargetList", 
		"bulkCollectIntoClause", "fetchLimitClause", "openStatement", "openForClause", 
		"usingList", "usingListItem", "commitWorkStatement", "commitWorkCommentClause", 
		"commitWorkWriteClause", "commitWorkForceClause", "setTransactionStatement", 
		"setTransactionName", "setTransactionReadClause", "isolationLevelClause", 
		"useRollbackSegmentClause", "rollbackWorkStatement", "toSavepointClause", 
		"savepointStatement", "assignmentStatement", "errorLoggingClause", "errorLoggingIntoClause", 
		"errorLoggingTagExpression", "errorLoggingRejectLimit", "mergeStatement", 
		"mergeUpdateOrInsertClause", "mergeUsingClause", "mergeConditionClause", 
		"mergeUpdateClause", "deleteWhereClause", "mergeInsertClause", "executeImmediateStatement", 
		"executeReturningClause", "pipeRowStatement", "raiseStatement", "truncateTableStatement", 
		"truncateTableLogClause", "preservePurgeClause", "truncateClusterStatement", 
		"truncateStatementStorageClause", "lockTableStatement", "lockTableItemList", 
		"lockTableModeClause", "lockTableNowaitClause", "translateExpression", 
		"charExpression", "controlStructure", "forAllStatement", "forAllInClause", 
		"forAllIndicesClause", "forAllIndeciesBoundsClause", "forAllValuesClause", 
		"forAllLowerUpperBoundClause", "forAllSaveExceptionsClause", "ifStatement", 
		"thenBlock", "elseBlock", "elsIfBlock", "ifDirectiveStatement", "thenDirectiveBlock", 
		"elseDirectiveBlock", "elsIfDirectiveBlock", "errorDirectiveBlock", "loopStatement", 
		"loopBlock", "whileStatement", "endLoopClause", "forStatement", "forStatementInClause", 
		"continueStatement", "caseStatement", "simpleCaseStatement", "searchedCaseStatement", 
		"caseStatementWhenEntry", "blockStatement", "blockBody", "endClause", 
		"exceptionBlock", "exceptionHandler", "exceptionNameList", "gotoStatement", 
		"label", "labelBody", "nullStatement", "returnStatement", "procedureCall", 
		"exitStatement", "optionalLabelWhenCondition", "whenCondition", "declarationBlock", 
		"declarationBlockItem", "notNullClause", "nullClause", "defaultValueClause", 
		"cursorReturnClause", "exceptionDeclaration", "typeDeclaration", "delimiterAs", 
		"newType", "recordTypeDeclaration", "recordFieldDeclaration", "objectTypeDeclaration", 
		"objectFieldDeclaration", "varrayTypeDeclaration", "varraySizeLimitClause", 
		"typeDeclararionElementTypeClause", "tableTypeDeclaration", "tableTypeIndexByClause", 
		"refCursorTypeDeclaration", "subtypeDeclaration", "cursorDeclaration", 
		"cursorHeader", "cursorSelect", "declarationPragma", "exceptionInitPragma", 
		"autonomousTransactionPragma", "seriallyReusablePragma", "restrictReferencesPragma", 
		"builtinPragma", "fipsflagPragma", "interfacePragma", "timestampPragma", 
		"newNamesPragma", "variableDeclaration", "variableConstantClause", "dropStatement", 
		"dropTypeStatement", "forceValidateClause", "dropTypeBodyStatement", "dropTriggerStatement", 
		"dropIndexStatement", "alterStatement", "alterTypeStatement", "alterTypeSpecifications", 
		"alterTriggerStatement", "renameClause", "compileClause", "alterIndexStatement", 
		"indexOptions", "deallocateUnusedClause", "keepSizeClause", "allocateExtentClause", 
		"extentOptions", "extentOption", "shrinkClause", "physicalAttribute", 
		"rebuildClause", "rebuildOptions", "keyCompression", "parametersClause", 
		"alterIndexPartitioning", "modifyIndexDefaultAttributes", "modifyIndexAttributes", 
		"addHashIndexPartition", "coalesceIndexPartition", "modifyIndexPartition", 
		"modifyIndexPartitionOptions", "renameIndexPartition", "dropIndexPartition", 
		"splitIndexPartition", "splitIndexPartitionAtClause", "splitIndexPartitionIntoClause", 
		"indexPartitionDescription", "modifyIndexSubpartition", "compileTypeClause", 
		"compilerParametersClause", "replaceTypeClause", "alterMethodSpecifications", 
		"alterMethodSpecification", "alterAttributeDefinition", "addOrModifyAttributeDefinition", 
		"alterTypeDeclaration", "alterTypeDeclarationInParen", "dropAttributeDefinition", 
		"alterCollectionClauses", "dependentHandlingClause", "invalidateHandlingClause", 
		"cascadeHandlingClause", "dependentTypesClause", "includingTableData", 
		"convertToSubstitutable", "forceExceptionsClause", "alterSequenceStatement", 
		"sequenceOption", "identityOption", "sequenceIncrementClause", "sequenceStartWithClause", 
		"sequenceMaxValueClause", "sequenceMinValueClause", "sequenceCycleClause", 
		"sequenceCacheClause", "sequenceOrderClause", "sequenceScaleClause", "sequenceKeepClause", 
		"sequenceShardClause", "sequenceScopeClause", "createTypeStatement", "alterTypeEmbeddedStatement", 
		"completeTypeStatement", "objectTypeStatement", "topLevelObjectType", 
		"subType", "objectTypeDeclarationItems", "objectTypeDeclarationItem", 
		"objectTypeAttributeDeclaration", "varrayTypeStatement", "nestedTableTypeStatement", 
		"oidClause", "createTypeBodyStatement", "objectTypeBodyDeclarationItems", 
		"objectTypeRoutine", "objectTypeMemberStaticRoutine", "objectTypeConstructor", 
		"constructorHeader", "constructorReturnClause", "objectTypeMapOrderFunction", 
		"inheritanceClause", "createSynonymStatement", "createSynonymSharingClause"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, "':='", "'=>'", "'||'", "'**'", "'..'", null, 
		null, null, "';'", "'/'", "'\\'", "'>'", "'<'", "'='", "'%'", "'@'", "'+'", 
		"'-'", "'#'", "'?'", null, "'*'", "'.'", "'^'", "'~'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "A_", "ACCOUNT", "ADD", "ADVANCED", "AFTER", "AGENT", "AGGREGATE", 
		"ALL", "ALLOCATE", "ALLOW", "ALTER", "ALWAYS", "ANALYZE", "AND", "ANY", 
		"ANYSCHEMA", "ARCHIVE", "ARRAY", "AS", "ASC", "ASSOCIATE", "AT", "ATTRIBUTE", 
		"ATTRIBUTES", "AUDIT", "AUTHENTICATION", "AUTHID", "AUTO", "AUTONOMOUS_TRANSACTION", 
		"BASIC", "BASICFILE", "BATCH", "BEFORE", "BEGIN", "BEGINNING", "BETWEEN", 
		"BINARY", "BITMAP", "BLOCK", "BODY", "BOTH", "BREADTH", "BUFFER_POOL", 
		"BUILD", "BUILTIN", "BULK", "BULK_EXCEPTIONS", "BULK_ROWCOUNT", "BY", 
		"BYTE", "C_", "CACHE", "CALL", "CASCADE", "CASE", "CAST", "CELL_FLASH_CACHE", 
		"CHAR", "CHAR_CS", "CHARACTER", "CHARSET", "CHECK", "CHR", "CHUNK", "CLOB", 
		"CLOSE", "CLUSTER", "COALESCE", "COLLATE", "COLLATION", "COLLECT", "COLUMN", 
		"COLUMN_VALUE", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "COMPACT", 
		"COMPILE", "COMPLETE", "COMPOUND", "COMPRESS", "COMPUTATION", "COMPUTE", 
		"CONDITIONAL", "CONNECT", "CONNECT_BY_ROOT", "CONSTANT", "CONSTRAINT", 
		"CONSTRAINTS", "CONSTRUCTOR", "CONTAINER", "CONTENT", "CONTEXT", "CONTINUE", 
		"CONVERT", "COUNT", "CREATE", "CREATION", "CROSS", "CUBE", "CURRENT", 
		"CURRENT_USER", "CURSOR", "CYCLE", "DATA", "DATABASE", "DATAFILE", "DATE", 
		"DAY", "DBTIMEZONE", "DDL", "DEALLOCATE", "DEBUG", "DECLARE", "DECODE", 
		"DECRYPT", "DEDUPLICATE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DEFINER", 
		"DELETE", "DEMAND", "DENSE_RANK", "DEPTH", "DESC", "DETERMINISTIC", "DIRECT_LOAD", 
		"DIRECTIVE_ELSE", "DIRECTIVE_ELSIF", "DIRECTIVE_END", "DIRECTIVE_ERROR", 
		"DIRECTIVE_IF", "DIRECTIVE_THEN", "DISABLE", "DISALLOW", "DISASSOCIATE", 
		"DISTINCT", "DOUBLE", "DROP", "DUPLICATED", "EACH", "EDITION", "EDITIONABLE", 
		"EDITIONING", "EDITIONS", "ELEMENT", "ELSE", "ELSIF", "EMPTY_KEYWORD", 
		"ENABLE", "ENCRYPT", "END", "ENFORCED", "ERROR_CODE", "ERROR_INDEX", "ERROR", 
		"ERRORS", "ESCAPE", "EVALUATE", "EXCEPT", "EXCEPTION", "EXCEPTION_INIT", 
		"EXCEPTIONS", "EXCLUDE", "EXCLUSIVE", "EXECUTE", "EXISTS", "EXIT", "EXPIRE", 
		"EXTEND", "EXTENDED", "EXTENT", "EXTERNALLY", "EXTRACT", "EXTRACTVALUE", 
		"FALSE", "FAST", "FETCH", "FILESYSTEM_LIKE_LOGGING", "FINAL", "FIPSFLAG", 
		"FIRST", "FIRST_ROWS", "FIXED", "FOLLOWING", "FOR", "FORALL", "FORCE", 
		"FOREIGN", "FORMAT", "FOUND", "FLASH_CACHE", "FREELIST", "FREELISTS", 
		"FREEPOOLS", "FROM", "FULL", "FUNCTION", "GENERATED", "GLOBAL", "GLOBALLY", 
		"GOTO", "GRANT", "GROUP", "GROUPING", "GROUPS", "HASH", "HAVING", "HEAP", 
		"HIGH", "HOUR", "ID", "IDENTIFIED", "IDENTIFIER", "IDENTITY", "IF", "IMMEDIATE", 
		"IN", "INCLUDE", "INCLUDING", "INCREMENT", "INDEX", "INDEXING", "INDEXTYPE", 
		"INDICATOR", "INDICES", "INITIAL", "INITIALLY", "INITRANS", "INNER", "INSERT", 
		"INSTANCE", "INSTANTIABLE", "INSTEAD", "INTERFACE", "INTERSECT", "INTERVAL", 
		"INTO", "INVALIDATE", "INVALIDATION", "INVISIBLE", "IS", "ISOLATION", 
		"ISOPEN", "JAVA", "JOIN", "JSON", "JSON_TABLE", "KEEP", "KEEP_DUPLICATES", 
		"KEY", "LANGUAGE", "LAST", "LEADING", "LEFT", "LESS", "LEVEL", "LEVELS", 
		"LIBRARY", "LIKE", "LIKE2", "LIKE4", "LIKEC", "LIMIT", "LIST", "LOB", 
		"LOBS", "LOCAL", "LOCATOR", "LOCK", "LOCKED", "LOCKING", "LOG", "LOGGING", 
		"LOGOFF", "LOGON", "LONG", "LOOP", "LOW", "MAP", "MAPPING", "MASTER", 
		"MATCHED", "MATERIALIZED", "MAX", "MAXEXTENTS", "MAXSIZE", "MAXTRANS", 
		"MAXVALUE", "MEDIUM", "MEMBER", "MEMOPTIMIZE", "MERGE", "METADATA", "MIN", 
		"MINEXTENTS", "MINUS", "MINUTE", "MINVALUE", "MOD", "MODE", "MODIFY", 
		"MONITORING", "MONTH", "MOVEMENT", "MULTISET", "NAME", "NATIONAL", "NATURAL", 
		"NCHAR", "NCHAR_CS", "NCHR", "NESTED", "NEVER", "NEW", "NEW_NAMES", "NEXT", 
		"NO", "NOAUDIT", "NOCACHE", "NOCOMPRESS", "NOCOPY", "NOCYCLE", "NOEXTEND", 
		"NOKEEP", "NOLOGGING", "NOMAPPING", "NOMAXVALUE", "NOMINVALUE", "NOMONITORING", 
		"NOORDER", "NONE", "NONEDITIONABLE", "NONSCHEMA", "NOPARALLEL", "NORELY", 
		"NOREVERSE", "NOROWDEPENDENCIES", "NOSCALE", "NOSHARD", "NOSORT", "NOT", 
		"NOTFOUND", "NOVALIDATE", "NOWAIT", "NULL", "NULLS", "NVARCHAR2", "OBJECT", 
		"OF", "OID", "OIDINDEX", "OLD", "ON", "ONLY", "ONLINE", "OPAQUE", "OPEN", 
		"OPERATIONS", "OPTIMAL", "OPTION", "OR", "ORDER", "ORDINALITY", "ORGANIZATION", 
		"OUT", "OUTER", "OVER", "OVERFLOW", "OVERLAPS", "OVERRIDING", "PACKAGE", 
		"PARALLEL", "PARALLEL_ENABLE", "PARAMETERS", "PARENT", "PARTIAL", "PARTITION", 
		"PARTITIONS", "PASSING", "PASSWORD", "PATH", "PCTFREE", "PCTINCREASE", 
		"PCTTHRESHOLD", "PCTUSED", "PCTVERSION", "PERCENTILE_DISC", "PERIOD", 
		"PIPE", "PIPELINED", "PIVOT", "POLYMORPHIC", "PRAGMA", "PREBUILT", "PRECEDING", 
		"PRECISION", "PRESERVE", "PRIMARY", "PRIOR", "PRIVATE", "PROCEDURE", "PROFILE", 
		"PUBLIC", "PURGE", "QUERY", "QUOTA", "RAISE", "RAISE_APPLICATION_ERROR", 
		"RANGE", "RAW", "READ", "READS", "REBUILD", "RECORD", "RECYCLE", "REDUCED", 
		"REF", "REFERENCES", "REFERENCING", "REFRESH", "REJECT", "RELATIONAL", 
		"RELIES_ON", "RELY", "RENAME", "REPLACE", "RESTRICT_REFERENCES", "RESULT", 
		"RESULT_CACHE", "RETENTION", "RETURN", "RETURNING", "REUSE", "REVERSE", 
		"REVOKE", "REWRITE", "RIGHT", "ROLLBACK", "ROLLUP", "ROW", "ROWCOUNT", 
		"ROWDEPENDENCIES", "ROWID", "ROWS", "ROWTYPE", "SALT", "SAMPLE", "SAVE", 
		"SAVEPOINT", "SCALE", "SCHEMA", "SCN", "SCOPE", "SEARCH", "SECOND", "SECUREFILE", 
		"SEED", "SEGMENT", "SELECT", "SELF", "SEQUENCE", "SERIALIZABLE", "SERIALLY_REUSABLE", 
		"SERVERERROR", "SESSION", "SESSIONTIMEZONE", "SET", "SETS", "SETTINGS", 
		"SHARE", "SHRINK", "SHUTDOWN", "SIBLINGS", "SIZE", "SKIP_", "SOME", "SORT", 
		"SPACE", "SPECIFICATION", "SPLIT", "START", "STARTUP", "STATEMENT", "STATIC", 
		"STATISTICS", "STORAGE", "STORE", "STRING", "SHARD", "SHARDED", "SHARING", 
		"SUBMULTISET", "SUBPARTITION", "SUBPARTITIONS", "SUBSTITUTABLE", "SUBTYPE", 
		"SUPPLEMENTAL", "SUSPEND", "SYNONYM", "SYS_CONNECT_BY_PATH", "SYSTEM", 
		"TABLE", "TABLES", "TABLESPACE", "TEMPLATE", "TEMPORARY", "THAN", "THE", 
		"THEN", "TIME", "TIMESTAMP", "TIMEZONE_ABBR", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", 
		"TIMEZONE_REGION", "TO", "TRAILING", "TRANSACTION", "TRANSLATE", "TREAT", 
		"TRIGGER", "TRIM", "TRUE", "TRUNCATE", "TRUSTED", "TYPE", "UNBOUNDED", 
		"UNCONDITIONAL", "UNDER", "UNION", "UNIQUE", "UNLIMITED", "UNLOCK", "UNPIVOT", 
		"UNUSABLE", "UNUSED", "UPDATE", "USABLE", "USAGE", "USE", "USER", "USING", 
		"VALIDATE", "VALUE", "VALUES", "VARCHAR", "VARCHAR2", "VARRAY", "VARRAYS", 
		"VARYING", "VERSIONS", "VIEW", "VIRTUAL", "VISIBLE", "WAIT", "WHEN", "WHERE", 
		"WHILE", "WITH", "WITHIN", "WITHOUT", "WORK", "WRAPPED", "WRAPPER", "WRITE", 
		"XML", "XMLAGG", "XMLCAST", "XMLNAMESPACES", "XMLQUERY", "XMLSCHEMA", 
		"XMLTABLE", "XMLTYPE", "YEAR", "ZONE", "INTEGER_LITERAL", "ASSIGN_OPERATOR", 
		"ASSOC_OPERATOR", "CONCAT_OPERATOR", "POWER_OPERATOR", "DOUBLE_DOT_OPERATOR", 
		"LPAREN", "RPAREN", "COMMA", "SEMI", "FSLASH", "BSLASH", "GREATER_THAN", 
		"LESS_THAN", "EQUAL_SIGN", "PERCENT_SIGN", "AT_SIGN", "PLUS_SIGN", "MINUS_SIGN", 
		"POUND_SIGN", "QUESTION_MARK", "BANG", "ASTERISK", "DOT", "CARET", "TILDE", 
		"FLOATING_POINT_LITERAL", "FLOATING_POINT_BINARY_LITERAL", "UNICODE_CHARACTER_STRING_LITERAL", 
		"BINARY_STRING_LITERAL", "CHARACTER_STRING_LITERAL", "BYTE_SIZE_LITERAL", 
		"MONEY_LITERAL", "REGULAR_IDENTIFIER", "QUOTED_IDENTIFIER", "WHITESPACES", 
		"WHITESPACE", "QUOTE_CHARACTER_STRING_LITERAL", "INVALID_CHAR"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "OracleAntlr.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static OracleAntlrParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public OracleAntlrParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public OracleAntlrParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ExpressionInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(OracleAntlrParser.Eof, 0); }
		public ExpressionInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExpressionInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExpressionInputFile(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionInputFileContext expressionInputFile() {
		ExpressionInputFileContext _localctx = new ExpressionInputFileContext(Context, State);
		EnterRule(_localctx, 0, RULE_expressionInputFile);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1704;
			fullExpression();
			State = 1705;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(OracleAntlrParser.Eof, 0); }
		public ConditionInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConditionInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConditionInputFile(this);
		}
	}

	[RuleVersion(0)]
	public ConditionInputFileContext conditionInputFile() {
		ConditionInputFileContext _localctx = new ConditionInputFileContext(Context, State);
		EnterRule(_localctx, 2, RULE_conditionInputFile);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1707;
			fullExpression();
			State = 1708;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HintInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public HintsListContext hintsList() {
			return GetRuleContext<HintsListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(OracleAntlrParser.Eof, 0); }
		public HintInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hintInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterHintInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitHintInputFile(this);
		}
	}

	[RuleVersion(0)]
	public HintInputFileContext hintInputFile() {
		HintInputFileContext _localctx = new HintInputFileContext(Context, State);
		EnterRule(_localctx, 4, RULE_hintInputFile);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1710;
			hintsList();
			State = 1711;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlSqlCheckInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Eof() { return GetTokens(OracleAntlrParser.Eof); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof(int i) {
			return GetToken(OracleAntlrParser.Eof, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECLARE() { return GetToken(OracleAntlrParser.DECLARE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEGIN() { return GetToken(OracleAntlrParser.BEGIN, 0); }
		public PlSqlCheckInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plSqlCheckInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPlSqlCheckInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPlSqlCheckInputFile(this);
		}
	}

	[RuleVersion(0)]
	public PlSqlCheckInputFileContext plSqlCheckInputFile() {
		PlSqlCheckInputFileContext _localctx = new PlSqlCheckInputFileContext(Context, State);
		EnterRule(_localctx, 6, RULE_plSqlCheckInputFile);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1713;
			_la = TokenStream.LA(1);
			if ( !(_la==BEGIN || _la==DECLARE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1717;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADD) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALTER) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUDIT) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BEGINNING) | (1L << BETWEEN) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BY) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHECK) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPRESS - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECLARE - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DIRECTIVE_ELSE - 128)) | (1L << (DIRECTIVE_ELSIF - 128)) | (1L << (DIRECTIVE_END - 128)) | (1L << (DIRECTIVE_ERROR - 128)) | (1L << (DIRECTIVE_IF - 128)) | (1L << (DIRECTIVE_THEN - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DISTINCT - 128)) | (1L << (DOUBLE - 128)) | (1L << (DROP - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSE - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (END - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FETCH - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FROM - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GOTO - 192)) | (1L << (GRANT - 192)) | (1L << (GROUP - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HAVING - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIED - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (IF - 192)) | (1L << (IMMEDIATE - 192)) | (1L << (IN - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INCREMENT - 192)) | (1L << (INDEX - 192)) | (1L << (INDEXING - 192)) | (1L << (INDEXTYPE - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIAL - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSERT - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERSECT - 192)) | (1L << (INTERVAL - 192)) | (1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCK - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOOP - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXEXTENTS - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MODE - 256)) | (1L << (MODIFY - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOAUDIT - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOMPRESS - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NOWAIT - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (NVARCHAR2 - 320)) | (1L << (OBJECT - 320)) | (1L << (OF - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ON - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (OPTION - 320)) | (1L << (OR - 320)) | (1L << (ORDER - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTFREE - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (PIVOT - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURN - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REVOKE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLBACK - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)) | (1L << (ROWS - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELECT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHARE - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (START - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLE - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)) | (1L << (THE - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THEN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TO - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIGGER - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNION - 512)) | (1L << (UNIQUE - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNPIVOT - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (UPDATE - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VALUES - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIEW - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WHERE - 512)) | (1L << (WHILE - 512)) | (1L << (WITH - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLAGG - 512)) | (1L << (XMLCAST - 512)) | (1L << (XMLNAMESPACES - 512)) | (1L << (XMLQUERY - 512)) | (1L << (XMLSCHEMA - 512)) | (1L << (XMLTABLE - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (INTEGER_LITERAL - 576)) | (1L << (ASSIGN_OPERATOR - 576)) | (1L << (ASSOC_OPERATOR - 576)) | (1L << (CONCAT_OPERATOR - 576)) | (1L << (POWER_OPERATOR - 576)) | (1L << (DOUBLE_DOT_OPERATOR - 576)) | (1L << (LPAREN - 576)) | (1L << (RPAREN - 576)) | (1L << (COMMA - 576)) | (1L << (SEMI - 576)) | (1L << (FSLASH - 576)) | (1L << (BSLASH - 576)) | (1L << (GREATER_THAN - 576)) | (1L << (LESS_THAN - 576)) | (1L << (EQUAL_SIGN - 576)) | (1L << (PERCENT_SIGN - 576)) | (1L << (AT_SIGN - 576)) | (1L << (PLUS_SIGN - 576)) | (1L << (MINUS_SIGN - 576)) | (1L << (POUND_SIGN - 576)) | (1L << (QUESTION_MARK - 576)) | (1L << (BANG - 576)) | (1L << (ASTERISK - 576)) | (1L << (DOT - 576)) | (1L << (CARET - 576)) | (1L << (TILDE - 576)) | (1L << (FLOATING_POINT_LITERAL - 576)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 576)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 576)) | (1L << (BINARY_STRING_LITERAL - 576)) | (1L << (CHARACTER_STRING_LITERAL - 576)) | (1L << (BYTE_SIZE_LITERAL - 576)) | (1L << (MONEY_LITERAL - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)) | (1L << (WHITESPACES - 576)) | (1L << (WHITESPACE - 576)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 576)) | (1L << (INVALID_CHAR - 576)))) != 0)) {
				{
				{
				State = 1714;
				_la = TokenStream.LA(1);
				if ( _la <= 0 || (_la==Eof) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				}
				State = 1719;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1720;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DynamicSqlInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(OracleAntlrParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SqlStatementContext sqlStatement() {
			return GetRuleContext<SqlStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PlSqlStatementContext plSqlStatement() {
			return GetRuleContext<PlSqlStatementContext>(0);
		}
		public DynamicSqlInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dynamicSqlInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDynamicSqlInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDynamicSqlInputFile(this);
		}
	}

	[RuleVersion(0)]
	public DynamicSqlInputFileContext dynamicSqlInputFile() {
		DynamicSqlInputFileContext _localctx = new DynamicSqlInputFileContext(Context, State);
		EnterRule(_localctx, 8, RULE_dynamicSqlInputFile);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1724;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
			case 1:
				{
				State = 1722;
				sqlStatement();
				}
				break;
			case 2:
				{
				State = 1723;
				plSqlStatement();
				}
				break;
			}
			State = 1726;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComputedColumnExpressionInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ComputedColumnExpressionContext computedColumnExpression() {
			return GetRuleContext<ComputedColumnExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(OracleAntlrParser.Eof, 0); }
		public ComputedColumnExpressionInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_computedColumnExpressionInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterComputedColumnExpressionInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitComputedColumnExpressionInputFile(this);
		}
	}

	[RuleVersion(0)]
	public ComputedColumnExpressionInputFileContext computedColumnExpressionInputFile() {
		ComputedColumnExpressionInputFileContext _localctx = new ComputedColumnExpressionInputFileContext(Context, State);
		EnterRule(_localctx, 10, RULE_computedColumnExpressionInputFile);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1728;
			computedColumnExpression();
			State = 1729;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionListInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionListContext fullExpressionList() {
			return GetRuleContext<FullExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(OracleAntlrParser.Eof, 0); }
		public ExpressionListInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionListInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExpressionListInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExpressionListInputFile(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListInputFileContext expressionListInputFile() {
		ExpressionListInputFileContext _localctx = new ExpressionListInputFileContext(Context, State);
		EnterRule(_localctx, 12, RULE_expressionListInputFile);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1731;
			fullExpressionList();
			State = 1732;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HintsListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(OracleAntlrParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public HintItemContext[] hintItem() {
			return GetRuleContexts<HintItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public HintItemContext hintItem(int i) {
			return GetRuleContext<HintItemContext>(i);
		}
		public HintsListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hintsList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterHintsList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitHintsList(this);
		}
	}

	[RuleVersion(0)]
	public HintsListContext hintsList() {
		HintsListContext _localctx = new HintsListContext(Context, State);
		EnterRule(_localctx, 14, RULE_hintsList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1737;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEX - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				{
				State = 1734;
				hintItem();
				}
				}
				State = 1739;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1740;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HintItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIRST_ROWS() { return GetToken(OracleAntlrParser.FIRST_ROWS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FULL() { return GetToken(OracleAntlrParser.FULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(OracleAntlrParser.HASH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MERGE() { return GetToken(OracleAntlrParser.MERGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARALLEL() { return GetToken(OracleAntlrParser.PARALLEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CACHE() { return GetToken(OracleAntlrParser.CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCACHE() { return GetToken(OracleAntlrParser.NOCACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public HintParamsContext hintParams() {
			return GetRuleContext<HintParamsContext>(0);
		}
		public HintItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hintItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterHintItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitHintItem(this);
		}
	}

	[RuleVersion(0)]
	public HintItemContext hintItem() {
		HintItemContext _localctx = new HintItemContext(Context, State);
		EnterRule(_localctx, 16, RULE_hintItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1751;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
			case 1:
				{
				State = 1742;
				Match(FIRST_ROWS);
				}
				break;
			case 2:
				{
				State = 1743;
				Match(INDEX);
				}
				break;
			case 3:
				{
				State = 1744;
				Match(FULL);
				}
				break;
			case 4:
				{
				State = 1745;
				Match(HASH);
				}
				break;
			case 5:
				{
				State = 1746;
				Match(MERGE);
				}
				break;
			case 6:
				{
				State = 1747;
				Match(PARALLEL);
				}
				break;
			case 7:
				{
				State = 1748;
				Match(CACHE);
				}
				break;
			case 8:
				{
				State = 1749;
				Match(NOCACHE);
				}
				break;
			case 9:
				{
				State = 1750;
				simpleIdentifier();
				}
				break;
			}
			State = 1754;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 1753;
				hintParams();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HintParamsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public QueryBlockContext queryBlock() {
			return GetRuleContext<QueryBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext[] literal() {
			return GetRuleContexts<LiteralContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal(int i) {
			return GetRuleContext<LiteralContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComplexIndexHintContext[] complexIndexHint() {
			return GetRuleContexts<ComplexIndexHintContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComplexIndexHintContext complexIndexHint(int i) {
			return GetRuleContext<ComplexIndexHintContext>(i);
		}
		public HintParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hintParams; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterHintParams(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitHintParams(this);
		}
	}

	[RuleVersion(0)]
	public HintParamsContext hintParams() {
		HintParamsContext _localctx = new HintParamsContext(Context, State);
		EnterRule(_localctx, 18, RULE_hintParams);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1756;
			Match(LPAREN);
			State = 1758;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AT_SIGN) {
				{
				State = 1757;
				queryBlock();
				}
			}

			State = 1765;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (INTEGER_LITERAL - 577)) | (1L << (LPAREN - 577)) | (1L << (FLOATING_POINT_LITERAL - 577)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 577)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 577)) | (1L << (BINARY_STRING_LITERAL - 577)) | (1L << (CHARACTER_STRING_LITERAL - 577)) | (1L << (MONEY_LITERAL - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 577)))) != 0)) {
				{
				State = 1763;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,6,Context) ) {
				case 1:
					{
					State = 1760;
					literal();
					}
					break;
				case 2:
					{
					State = 1761;
					identifier();
					}
					break;
				case 3:
					{
					State = 1762;
					complexIndexHint();
					}
					break;
				}
				}
				State = 1767;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1768;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComplexIndexHintContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ComplexIndexHintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_complexIndexHint; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterComplexIndexHint(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitComplexIndexHint(this);
		}
	}

	[RuleVersion(0)]
	public ComplexIndexHintContext complexIndexHint() {
		ComplexIndexHintContext _localctx = new ComplexIndexHintContext(Context, State);
		EnterRule(_localctx, 20, RULE_complexIndexHint);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1770;
			Match(LPAREN);
			State = 1774;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				{
				State = 1771;
				identifier();
				}
				}
				State = 1776;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1777;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT_SIGN() { return GetToken(OracleAntlrParser.AT_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public QueryBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterQueryBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitQueryBlock(this);
		}
	}

	[RuleVersion(0)]
	public QueryBlockContext queryBlock() {
		QueryBlockContext _localctx = new QueryBlockContext(Context, State);
		EnterRule(_localctx, 22, RULE_queryBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1779;
			Match(AT_SIGN);
			State = 1780;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SqlInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Eof() { return GetTokens(OracleAntlrParser.Eof); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof(int i) {
			return GetToken(OracleAntlrParser.Eof, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SqlStatementBatchContext[] sqlStatementBatch() {
			return GetRuleContexts<SqlStatementBatchContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SqlStatementBatchContext sqlStatementBatch(int i) {
			return GetRuleContext<SqlStatementBatchContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] FSLASH() { return GetTokens(OracleAntlrParser.FSLASH); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FSLASH(int i) {
			return GetToken(OracleAntlrParser.FSLASH, i);
		}
		public SqlInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSqlInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSqlInputFile(this);
		}
	}

	[RuleVersion(0)]
	public SqlInputFileContext sqlInputFile() {
		SqlInputFileContext _localctx = new SqlInputFileContext(Context, State);
		EnterRule(_localctx, 24, RULE_sqlInputFile);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1787;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALTER) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECLARE - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DIRECTIVE_IF - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DROP - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FETCH - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GOTO - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSERT - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLBACK - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELECT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (UPDATE - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITH - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (LPAREN - 577)) | (1L << (LESS_THAN - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				{
				State = 1782;
				sqlStatementBatch();
				State = 1783;
				_la = TokenStream.LA(1);
				if ( !(_la==Eof || _la==FSLASH) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				}
				State = 1789;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1790;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SqlStatementBatchContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SqlStatementContext sqlStatement() {
			return GetRuleContext<SqlStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI() { return GetToken(OracleAntlrParser.SEMI, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SqlStatementBatchContext sqlStatementBatch() {
			return GetRuleContext<SqlStatementBatchContext>(0);
		}
		public SqlStatementBatchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlStatementBatch; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSqlStatementBatch(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSqlStatementBatch(this);
		}
	}

	[RuleVersion(0)]
	public SqlStatementBatchContext sqlStatementBatch() {
		SqlStatementBatchContext _localctx = new SqlStatementBatchContext(Context, State);
		EnterRule(_localctx, 26, RULE_sqlStatementBatch);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1792;
			sqlStatement();
			State = 1797;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SEMI) {
				{
				State = 1793;
				Match(SEMI);
				State = 1795;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALTER) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECLARE - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DIRECTIVE_IF - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DROP - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FETCH - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GOTO - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSERT - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLBACK - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELECT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (UPDATE - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITH - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (LPAREN - 577)) | (1L << (LESS_THAN - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
					{
					State = 1794;
					sqlStatementBatch();
					}
				}

				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SqlStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CreateStatementContext createStatement() {
			return GetRuleContext<CreateStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterStatementContext alterStatement() {
			return GetRuleContext<AlterStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropStatementContext dropStatement() {
			return GetRuleContext<DropStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeleteStatementContext deleteStatement() {
			return GetRuleContext<DeleteStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CloseStatementContext closeStatement() {
			return GetRuleContext<CloseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpenStatementContext openStatement() {
			return GetRuleContext<OpenStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExecuteImmediateStatementContext executeImmediateStatement() {
			return GetRuleContext<ExecuteImmediateStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetTransactionStatementContext setTransactionStatement() {
			return GetRuleContext<SetTransactionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RaiseStatementContext raiseStatement() {
			return GetRuleContext<RaiseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TruncateTableStatementContext truncateTableStatement() {
			return GetRuleContext<TruncateTableStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TruncateClusterStatementContext truncateClusterStatement() {
			return GetRuleContext<TruncateClusterStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockStatementContext blockStatement() {
			return GetRuleContext<BlockStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertStatementContext insertStatement() {
			return GetRuleContext<InsertStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UpdateStatementContext updateStatement() {
			return GetRuleContext<UpdateStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GotoStatementContext gotoStatement() {
			return GetRuleContext<GotoStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FetchStatementContext fetchStatement() {
			return GetRuleContext<FetchStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommitWorkStatementContext commitWorkStatement() {
			return GetRuleContext<CommitWorkStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RollbackWorkStatementContext rollbackWorkStatement() {
			return GetRuleContext<RollbackWorkStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SavepointStatementContext savepointStatement() {
			return GetRuleContext<SavepointStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeStatementContext mergeStatement() {
			return GetRuleContext<MergeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelContext label() {
			return GetRuleContext<LabelContext>(0);
		}
		public SqlStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSqlStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSqlStatement(this);
		}
	}

	[RuleVersion(0)]
	public SqlStatementContext sqlStatement() {
		SqlStatementContext _localctx = new SqlStatementContext(Context, State);
		EnterRule(_localctx, 28, RULE_sqlStatement);
		int _la;
		try {
			State = 1825;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CREATE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1799;
				createStatement();
				}
				break;
			case ALTER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1800;
				alterStatement();
				}
				break;
			case DROP:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1801;
				dropStatement();
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECLARE:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DIRECTIVE_IF:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FETCH:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GOTO:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSERT:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case UPDATE:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITH:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case LPAREN:
			case LESS_THAN:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1803;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LESS_THAN) {
					{
					State = 1802;
					label();
					}
				}

				State = 1823;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,13,Context) ) {
				case 1:
					{
					State = 1805;
					deleteStatement();
					}
					break;
				case 2:
					{
					State = 1806;
					closeStatement();
					}
					break;
				case 3:
					{
					State = 1807;
					openStatement();
					}
					break;
				case 4:
					{
					State = 1808;
					executeImmediateStatement();
					}
					break;
				case 5:
					{
					State = 1809;
					setTransactionStatement();
					}
					break;
				case 6:
					{
					State = 1810;
					raiseStatement();
					}
					break;
				case 7:
					{
					State = 1811;
					truncateTableStatement();
					}
					break;
				case 8:
					{
					State = 1812;
					truncateClusterStatement();
					}
					break;
				case 9:
					{
					State = 1813;
					blockStatement();
					}
					break;
				case 10:
					{
					State = 1814;
					selectStatement();
					}
					break;
				case 11:
					{
					State = 1815;
					insertStatement();
					}
					break;
				case 12:
					{
					State = 1816;
					updateStatement();
					}
					break;
				case 13:
					{
					State = 1817;
					gotoStatement();
					}
					break;
				case 14:
					{
					State = 1818;
					fetchStatement();
					}
					break;
				case 15:
					{
					State = 1819;
					commitWorkStatement();
					}
					break;
				case 16:
					{
					State = 1820;
					rollbackWorkStatement();
					}
					break;
				case 17:
					{
					State = 1821;
					savepointStatement();
					}
					break;
				case 18:
					{
					State = 1822;
					mergeStatement();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlSqlStatementBatchContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlSqlStatementContext[] plSqlStatement() {
			return GetRuleContexts<PlSqlStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PlSqlStatementContext plSqlStatement(int i) {
			return GetRuleContext<PlSqlStatementContext>(i);
		}
		public PlSqlStatementBatchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plSqlStatementBatch; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPlSqlStatementBatch(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPlSqlStatementBatch(this);
		}
	}

	[RuleVersion(0)]
	public PlSqlStatementBatchContext plSqlStatementBatch() {
		PlSqlStatementBatchContext _localctx = new PlSqlStatementBatchContext(Context, State);
		EnterRule(_localctx, 30, RULE_plSqlStatementBatch);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1831;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,15,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1827;
					if (!(IsSqlStatement())) throw new FailedPredicateException(this, "IsSqlStatement()");
					State = 1828;
					plSqlStatement();
					}
					} 
				}
				State = 1833;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,15,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlSqlStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI() { return GetToken(OracleAntlrParser.SEMI, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ControlStructureContext controlStructure() {
			return GetRuleContext<ControlStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ContinueStatementContext continueStatement() {
			return GetRuleContext<ContinueStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeleteStatementContext deleteStatement() {
			return GetRuleContext<DeleteStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExecuteImmediateStatementContext executeImmediateStatement() {
			return GetRuleContext<ExecuteImmediateStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentStatementContext assignmentStatement() {
			return GetRuleContext<AssignmentStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RaiseStatementContext raiseStatement() {
			return GetRuleContext<RaiseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommitWorkStatementContext commitWorkStatement() {
			return GetRuleContext<CommitWorkStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExitStatementContext exitStatement() {
			return GetRuleContext<ExitStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureCallContext procedureCall() {
			return GetRuleContext<ProcedureCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CloseStatementContext closeStatement() {
			return GetRuleContext<CloseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpenStatementContext openStatement() {
			return GetRuleContext<OpenStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetTransactionStatementContext setTransactionStatement() {
			return GetRuleContext<SetTransactionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationPragmaContext declarationPragma() {
			return GetRuleContext<DeclarationPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockStatementContext blockStatement() {
			return GetRuleContext<BlockStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertStatementContext insertStatement() {
			return GetRuleContext<InsertStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UpdateStatementContext updateStatement() {
			return GetRuleContext<UpdateStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GotoStatementContext gotoStatement() {
			return GetRuleContext<GotoStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FetchStatementContext fetchStatement() {
			return GetRuleContext<FetchStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RollbackWorkStatementContext rollbackWorkStatement() {
			return GetRuleContext<RollbackWorkStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SavepointStatementContext savepointStatement() {
			return GetRuleContext<SavepointStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturnStatementContext returnStatement() {
			return GetRuleContext<ReturnStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullStatementContext nullStatement() {
			return GetRuleContext<NullStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LockTableStatementContext lockTableStatement() {
			return GetRuleContext<LockTableStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeStatementContext mergeStatement() {
			return GetRuleContext<MergeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PipeRowStatementContext pipeRowStatement() {
			return GetRuleContext<PipeRowStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelContext label() {
			return GetRuleContext<LabelContext>(0);
		}
		public PlSqlStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plSqlStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPlSqlStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPlSqlStatement(this);
		}
	}

	[RuleVersion(0)]
	public PlSqlStatementContext plSqlStatement() {
		PlSqlStatementContext _localctx = new PlSqlStatementContext(Context, State);
		EnterRule(_localctx, 32, RULE_plSqlStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1835;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LESS_THAN) {
				{
				State = 1834;
				label();
				}
			}

			State = 1863;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				{
				State = 1837;
				controlStructure();
				}
				break;
			case 2:
				{
				State = 1838;
				continueStatement();
				}
				break;
			case 3:
				{
				State = 1839;
				deleteStatement();
				}
				break;
			case 4:
				{
				State = 1840;
				executeImmediateStatement();
				}
				break;
			case 5:
				{
				State = 1841;
				assignmentStatement();
				}
				break;
			case 6:
				{
				State = 1842;
				raiseStatement();
				}
				break;
			case 7:
				{
				State = 1843;
				commitWorkStatement();
				}
				break;
			case 8:
				{
				State = 1844;
				exitStatement();
				}
				break;
			case 9:
				{
				State = 1845;
				procedureCall();
				}
				break;
			case 10:
				{
				State = 1846;
				closeStatement();
				}
				break;
			case 11:
				{
				State = 1847;
				openStatement();
				}
				break;
			case 12:
				{
				State = 1848;
				setTransactionStatement();
				}
				break;
			case 13:
				{
				State = 1849;
				declarationPragma();
				}
				break;
			case 14:
				{
				State = 1850;
				blockStatement();
				}
				break;
			case 15:
				{
				State = 1851;
				selectStatement();
				}
				break;
			case 16:
				{
				State = 1852;
				insertStatement();
				}
				break;
			case 17:
				{
				State = 1853;
				updateStatement();
				}
				break;
			case 18:
				{
				State = 1854;
				gotoStatement();
				}
				break;
			case 19:
				{
				State = 1855;
				fetchStatement();
				}
				break;
			case 20:
				{
				State = 1856;
				rollbackWorkStatement();
				}
				break;
			case 21:
				{
				State = 1857;
				savepointStatement();
				}
				break;
			case 22:
				{
				State = 1858;
				returnStatement();
				}
				break;
			case 23:
				{
				State = 1859;
				nullStatement();
				}
				break;
			case 24:
				{
				State = 1860;
				lockTableStatement();
				}
				break;
			case 25:
				{
				State = 1861;
				mergeStatement();
				}
				break;
			case 26:
				{
				State = 1862;
				pipeRowStatement();
				}
				break;
			}
			State = 1865;
			Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RoutineSignatureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATE() { return GetToken(OracleAntlrParser.CREATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureOrFunctionSignatureContext procedureOrFunctionSignature() {
			return GetRuleContext<ProcedureOrFunctionSignatureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(OracleAntlrParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CreateStatementReplaceClauseContext createStatementReplaceClause() {
			return GetRuleContext<CreateStatementReplaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EditionOptionClauseContext editionOptionClause() {
			return GetRuleContext<EditionOptionClauseContext>(0);
		}
		public RoutineSignatureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routineSignature; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRoutineSignature(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRoutineSignature(this);
		}
	}

	[RuleVersion(0)]
	public RoutineSignatureContext routineSignature() {
		RoutineSignatureContext _localctx = new RoutineSignatureContext(Context, State);
		EnterRule(_localctx, 34, RULE_routineSignature);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1867;
			Match(CREATE);
			State = 1869;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 1868;
				createStatementReplaceClause();
				}
			}

			State = 1872;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EDITIONABLE || _la==NONEDITIONABLE) {
				{
				State = 1871;
				editionOptionClause();
				}
			}

			State = 1874;
			procedureOrFunctionSignature();
			State = 1878;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			while ( _alt!=1 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1+1 ) {
					{
					{
					State = 1875;
					MatchWildcard();
					}
					} 
				}
				State = 1880;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			}
			State = 1881;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureOrFunctionSignatureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureSignatureContext procedureSignature() {
			return GetRuleContext<ProcedureSignatureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionSignatureContext functionSignature() {
			return GetRuleContext<FunctionSignatureContext>(0);
		}
		public ProcedureOrFunctionSignatureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureOrFunctionSignature; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterProcedureOrFunctionSignature(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitProcedureOrFunctionSignature(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureOrFunctionSignatureContext procedureOrFunctionSignature() {
		ProcedureOrFunctionSignatureContext _localctx = new ProcedureOrFunctionSignatureContext(Context, State);
		EnterRule(_localctx, 36, RULE_procedureOrFunctionSignature);
		try {
			State = 1885;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PROCEDURE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1883;
				procedureSignature();
				}
				break;
			case FUNCTION:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1884;
				functionSignature();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		public IToken numberLiteral;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOATING_POINT_LITERAL() { return GetToken(OracleAntlrParser.FLOATING_POINT_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MONEY_LITERAL() { return GetToken(OracleAntlrParser.MONEY_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharacterStringLiteralContext characterStringLiteral() {
			return GetRuleContext<CharacterStringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public QuoteCharacterStringLiteralContext quoteCharacterStringLiteral() {
			return GetRuleContext<QuoteCharacterStringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnicodeCharacterStringLiteralContext unicodeCharacterStringLiteral() {
			return GetRuleContext<UnicodeCharacterStringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BinaryStringLiteralContext binaryStringLiteral() {
			return GetRuleContext<BinaryStringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BooleanLiteralContext booleanLiteral() {
			return GetRuleContext<BooleanLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DateLiteralContext dateLiteral() {
			return GetRuleContext<DateLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TimestampLiteralContext timestampLiteral() {
			return GetRuleContext<TimestampLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntervalLiteralContext intervalLiteral() {
			return GetRuleContext<IntervalLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FloatingPointBinaryLiteralContext floatingPointBinaryLiteral() {
			return GetRuleContext<FloatingPointBinaryLiteralContext>(0);
		}
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 38, RULE_literal);
		int _la;
		try {
			State = 1897;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INTEGER_LITERAL:
			case FLOATING_POINT_LITERAL:
			case MONEY_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1887;
				_localctx.numberLiteral = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 579)) & ~0x3f) == 0 && ((1L << (_la - 579)) & ((1L << (INTEGER_LITERAL - 579)) | (1L << (FLOATING_POINT_LITERAL - 579)) | (1L << (MONEY_LITERAL - 579)))) != 0)) ) {
					_localctx.numberLiteral = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case CHARACTER_STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1888;
				characterStringLiteral();
				}
				break;
			case QUOTE_CHARACTER_STRING_LITERAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1889;
				quoteCharacterStringLiteral();
				}
				break;
			case UNICODE_CHARACTER_STRING_LITERAL:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1890;
				unicodeCharacterStringLiteral();
				}
				break;
			case BINARY_STRING_LITERAL:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1891;
				binaryStringLiteral();
				}
				break;
			case FALSE:
			case TRUE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1892;
				booleanLiteral();
				}
				break;
			case DATE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1893;
				dateLiteral();
				}
				break;
			case TIMESTAMP:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1894;
				timestampLiteral();
				}
				break;
			case INTERVAL:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1895;
				intervalLiteral();
				}
				break;
			case FLOATING_POINT_BINARY_LITERAL:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1896;
				floatingPointBinaryLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QuoteCharacterStringLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTE_CHARACTER_STRING_LITERAL() { return GetToken(OracleAntlrParser.QUOTE_CHARACTER_STRING_LITERAL, 0); }
		public QuoteCharacterStringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quoteCharacterStringLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterQuoteCharacterStringLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitQuoteCharacterStringLiteral(this);
		}
	}

	[RuleVersion(0)]
	public QuoteCharacterStringLiteralContext quoteCharacterStringLiteral() {
		QuoteCharacterStringLiteralContext _localctx = new QuoteCharacterStringLiteralContext(Context, State);
		EnterRule(_localctx, 40, RULE_quoteCharacterStringLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1899;
			Match(QUOTE_CHARACTER_STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CharacterStringLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER_STRING_LITERAL() { return GetToken(OracleAntlrParser.CHARACTER_STRING_LITERAL, 0); }
		public CharacterStringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_characterStringLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCharacterStringLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCharacterStringLiteral(this);
		}
	}

	[RuleVersion(0)]
	public CharacterStringLiteralContext characterStringLiteral() {
		CharacterStringLiteralContext _localctx = new CharacterStringLiteralContext(Context, State);
		EnterRule(_localctx, 42, RULE_characterStringLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1901;
			Match(CHARACTER_STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnicodeCharacterStringLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNICODE_CHARACTER_STRING_LITERAL() { return GetToken(OracleAntlrParser.UNICODE_CHARACTER_STRING_LITERAL, 0); }
		public UnicodeCharacterStringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unicodeCharacterStringLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUnicodeCharacterStringLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUnicodeCharacterStringLiteral(this);
		}
	}

	[RuleVersion(0)]
	public UnicodeCharacterStringLiteralContext unicodeCharacterStringLiteral() {
		UnicodeCharacterStringLiteralContext _localctx = new UnicodeCharacterStringLiteralContext(Context, State);
		EnterRule(_localctx, 44, RULE_unicodeCharacterStringLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1903;
			Match(UNICODE_CHARACTER_STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BinaryStringLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BINARY_STRING_LITERAL() { return GetToken(OracleAntlrParser.BINARY_STRING_LITERAL, 0); }
		public BinaryStringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_binaryStringLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBinaryStringLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBinaryStringLiteral(this);
		}
	}

	[RuleVersion(0)]
	public BinaryStringLiteralContext binaryStringLiteral() {
		BinaryStringLiteralContext _localctx = new BinaryStringLiteralContext(Context, State);
		EnterRule(_localctx, 46, RULE_binaryStringLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1905;
			Match(BINARY_STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooleanLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUE() { return GetToken(OracleAntlrParser.TRUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FALSE() { return GetToken(OracleAntlrParser.FALSE, 0); }
		public BooleanLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_booleanLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBooleanLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBooleanLiteral(this);
		}
	}

	[RuleVersion(0)]
	public BooleanLiteralContext booleanLiteral() {
		BooleanLiteralContext _localctx = new BooleanLiteralContext(Context, State);
		EnterRule(_localctx, 48, RULE_booleanLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1907;
			_la = TokenStream.LA(1);
			if ( !(_la==FALSE || _la==TRUE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DateLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATE() { return GetToken(OracleAntlrParser.DATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER_STRING_LITERAL() { return GetToken(OracleAntlrParser.CHARACTER_STRING_LITERAL, 0); }
		public DateLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dateLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDateLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDateLiteral(this);
		}
	}

	[RuleVersion(0)]
	public DateLiteralContext dateLiteral() {
		DateLiteralContext _localctx = new DateLiteralContext(Context, State);
		EnterRule(_localctx, 50, RULE_dateLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1909;
			Match(DATE);
			State = 1910;
			Match(CHARACTER_STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimestampLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMESTAMP() { return GetToken(OracleAntlrParser.TIMESTAMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER_STRING_LITERAL() { return GetToken(OracleAntlrParser.CHARACTER_STRING_LITERAL, 0); }
		public TimestampLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timestampLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTimestampLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTimestampLiteral(this);
		}
	}

	[RuleVersion(0)]
	public TimestampLiteralContext timestampLiteral() {
		TimestampLiteralContext _localctx = new TimestampLiteralContext(Context, State);
		EnterRule(_localctx, 52, RULE_timestampLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1912;
			Match(TIMESTAMP);
			State = 1913;
			Match(CHARACTER_STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERVAL() { return GetToken(OracleAntlrParser.INTERVAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER_STRING_LITERAL() { return GetToken(OracleAntlrParser.CHARACTER_STRING_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IntervalLiteralFieldClauseContext[] intervalLiteralFieldClause() {
			return GetRuleContexts<IntervalLiteralFieldClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntervalLiteralFieldClauseContext intervalLiteralFieldClause(int i) {
			return GetRuleContext<IntervalLiteralFieldClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(OracleAntlrParser.TO, 0); }
		public IntervalLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIntervalLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIntervalLiteral(this);
		}
	}

	[RuleVersion(0)]
	public IntervalLiteralContext intervalLiteral() {
		IntervalLiteralContext _localctx = new IntervalLiteralContext(Context, State);
		EnterRule(_localctx, 54, RULE_intervalLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1915;
			Match(INTERVAL);
			State = 1916;
			Match(CHARACTER_STRING_LITERAL);
			State = 1917;
			intervalLiteralFieldClause();
			State = 1920;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 1918;
				Match(TO);
				State = 1919;
				intervalLiteralFieldClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalLiteralFieldClauseContext : ParserRuleContext {
		public IToken interval;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode YEAR() { return GetToken(OracleAntlrParser.YEAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MONTH() { return GetToken(OracleAntlrParser.MONTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DAY() { return GetToken(OracleAntlrParser.DAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HOUR() { return GetToken(OracleAntlrParser.HOUR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUTE() { return GetToken(OracleAntlrParser.MINUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECOND() { return GetToken(OracleAntlrParser.SECOND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IntervalLiteralFieldPrecisionContext intervalLiteralFieldPrecision() {
			return GetRuleContext<IntervalLiteralFieldPrecisionContext>(0);
		}
		public IntervalLiteralFieldClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalLiteralFieldClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIntervalLiteralFieldClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIntervalLiteralFieldClause(this);
		}
	}

	[RuleVersion(0)]
	public IntervalLiteralFieldClauseContext intervalLiteralFieldClause() {
		IntervalLiteralFieldClauseContext _localctx = new IntervalLiteralFieldClauseContext(Context, State);
		EnterRule(_localctx, 56, RULE_intervalLiteralFieldClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1922;
			_localctx.interval = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DAY || _la==HOUR || _la==MINUTE || _la==MONTH || _la==SECOND || _la==YEAR) ) {
				_localctx.interval = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1924;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,24,Context) ) {
			case 1:
				{
				State = 1923;
				intervalLiteralFieldPrecision();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalLiteralFieldPrecisionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext[] literal() {
			return GetRuleContexts<LiteralContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal(int i) {
			return GetRuleContext<LiteralContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		public IntervalLiteralFieldPrecisionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalLiteralFieldPrecision; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIntervalLiteralFieldPrecision(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIntervalLiteralFieldPrecision(this);
		}
	}

	[RuleVersion(0)]
	public IntervalLiteralFieldPrecisionContext intervalLiteralFieldPrecision() {
		IntervalLiteralFieldPrecisionContext _localctx = new IntervalLiteralFieldPrecisionContext(Context, State);
		EnterRule(_localctx, 58, RULE_intervalLiteralFieldPrecision);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1926;
			Match(LPAREN);
			State = 1927;
			literal();
			State = 1930;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 1928;
				Match(COMMA);
				State = 1929;
				literal();
				}
			}

			State = 1932;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FloatingPointBinaryLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOATING_POINT_BINARY_LITERAL() { return GetToken(OracleAntlrParser.FLOATING_POINT_BINARY_LITERAL, 0); }
		public FloatingPointBinaryLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_floatingPointBinaryLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFloatingPointBinaryLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFloatingPointBinaryLiteral(this);
		}
	}

	[RuleVersion(0)]
	public FloatingPointBinaryLiteralContext floatingPointBinaryLiteral() {
		FloatingPointBinaryLiteralContext _localctx = new FloatingPointBinaryLiteralContext(Context, State);
		EnterRule(_localctx, 60, RULE_floatingPointBinaryLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1934;
			Match(FLOATING_POINT_BINARY_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleIdentifierRegularIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REGULAR_IDENTIFIER() { return GetToken(OracleAntlrParser.REGULAR_IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT() { return GetToken(OracleAntlrParser.AT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode A_() { return GetToken(OracleAntlrParser.A_, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ACCOUNT() { return GetToken(OracleAntlrParser.ACCOUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADVANCED() { return GetToken(OracleAntlrParser.ADVANCED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AFTER() { return GetToken(OracleAntlrParser.AFTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AGENT() { return GetToken(OracleAntlrParser.AGENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AGGREGATE() { return GetToken(OracleAntlrParser.AGGREGATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALLOCATE() { return GetToken(OracleAntlrParser.ALLOCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALLOW() { return GetToken(OracleAntlrParser.ALLOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALWAYS() { return GetToken(OracleAntlrParser.ALWAYS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANALYZE() { return GetToken(OracleAntlrParser.ANALYZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANYSCHEMA() { return GetToken(OracleAntlrParser.ANYSCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARCHIVE() { return GetToken(OracleAntlrParser.ARCHIVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARRAY() { return GetToken(OracleAntlrParser.ARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSOCIATE() { return GetToken(OracleAntlrParser.ASSOCIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ATTRIBUTE() { return GetToken(OracleAntlrParser.ATTRIBUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ATTRIBUTES() { return GetToken(OracleAntlrParser.ATTRIBUTES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTHENTICATION() { return GetToken(OracleAntlrParser.AUTHENTICATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTHID() { return GetToken(OracleAntlrParser.AUTHID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTO() { return GetToken(OracleAntlrParser.AUTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTONOMOUS_TRANSACTION() { return GetToken(OracleAntlrParser.AUTONOMOUS_TRANSACTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BASIC() { return GetToken(OracleAntlrParser.BASIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BASICFILE() { return GetToken(OracleAntlrParser.BASICFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BATCH() { return GetToken(OracleAntlrParser.BATCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEFORE() { return GetToken(OracleAntlrParser.BEFORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEGINNING() { return GetToken(OracleAntlrParser.BEGINNING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BINARY() { return GetToken(OracleAntlrParser.BINARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BITMAP() { return GetToken(OracleAntlrParser.BITMAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BLOCK() { return GetToken(OracleAntlrParser.BLOCK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BODY() { return GetToken(OracleAntlrParser.BODY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOTH() { return GetToken(OracleAntlrParser.BOTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BREADTH() { return GetToken(OracleAntlrParser.BREADTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUFFER_POOL() { return GetToken(OracleAntlrParser.BUFFER_POOL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUILD() { return GetToken(OracleAntlrParser.BUILD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUILTIN() { return GetToken(OracleAntlrParser.BUILTIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BULK() { return GetToken(OracleAntlrParser.BULK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BULK_EXCEPTIONS() { return GetToken(OracleAntlrParser.BULK_EXCEPTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BULK_ROWCOUNT() { return GetToken(OracleAntlrParser.BULK_ROWCOUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BYTE() { return GetToken(OracleAntlrParser.BYTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode C_() { return GetToken(OracleAntlrParser.C_, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CACHE() { return GetToken(OracleAntlrParser.CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CALL() { return GetToken(OracleAntlrParser.CALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASCADE() { return GetToken(OracleAntlrParser.CASCADE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CAST() { return GetToken(OracleAntlrParser.CAST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CELL_FLASH_CACHE() { return GetToken(OracleAntlrParser.CELL_FLASH_CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAR() { return GetToken(OracleAntlrParser.CHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAR_CS() { return GetToken(OracleAntlrParser.CHAR_CS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER() { return GetToken(OracleAntlrParser.CHARACTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARSET() { return GetToken(OracleAntlrParser.CHARSET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHR() { return GetToken(OracleAntlrParser.CHR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHUNK() { return GetToken(OracleAntlrParser.CHUNK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOB() { return GetToken(OracleAntlrParser.CLOB, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE() { return GetToken(OracleAntlrParser.CLOSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COALESCE() { return GetToken(OracleAntlrParser.COALESCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLLATION() { return GetToken(OracleAntlrParser.COLLATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLLECT() { return GetToken(OracleAntlrParser.COLLECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMN_VALUE() { return GetToken(OracleAntlrParser.COLUMN_VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMIT() { return GetToken(OracleAntlrParser.COMMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMITTED() { return GetToken(OracleAntlrParser.COMMITTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPACT() { return GetToken(OracleAntlrParser.COMPACT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPILE() { return GetToken(OracleAntlrParser.COMPILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPLETE() { return GetToken(OracleAntlrParser.COMPLETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPOUND() { return GetToken(OracleAntlrParser.COMPOUND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPUTATION() { return GetToken(OracleAntlrParser.COMPUTATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPUTE() { return GetToken(OracleAntlrParser.COMPUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONDITIONAL() { return GetToken(OracleAntlrParser.CONDITIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTAINER() { return GetToken(OracleAntlrParser.CONTAINER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTEXT() { return GetToken(OracleAntlrParser.CONTEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTINUE() { return GetToken(OracleAntlrParser.CONTINUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTANT() { return GetToken(OracleAntlrParser.CONSTANT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINT() { return GetToken(OracleAntlrParser.CONSTRAINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINTS() { return GetToken(OracleAntlrParser.CONSTRAINTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRUCTOR() { return GetToken(OracleAntlrParser.CONSTRUCTOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONVERT() { return GetToken(OracleAntlrParser.CONVERT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COUNT() { return GetToken(OracleAntlrParser.COUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATION() { return GetToken(OracleAntlrParser.CREATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CROSS() { return GetToken(OracleAntlrParser.CROSS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CUBE() { return GetToken(OracleAntlrParser.CUBE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT_USER() { return GetToken(OracleAntlrParser.CURRENT_USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CYCLE() { return GetToken(OracleAntlrParser.CYCLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATA() { return GetToken(OracleAntlrParser.DATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(OracleAntlrParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATAFILE() { return GetToken(OracleAntlrParser.DATAFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATE() { return GetToken(OracleAntlrParser.DATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DAY() { return GetToken(OracleAntlrParser.DAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DBTIMEZONE() { return GetToken(OracleAntlrParser.DBTIMEZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DDL() { return GetToken(OracleAntlrParser.DDL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEALLOCATE() { return GetToken(OracleAntlrParser.DEALLOCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEBUG() { return GetToken(OracleAntlrParser.DEBUG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECODE() { return GetToken(OracleAntlrParser.DECODE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECRYPT() { return GetToken(OracleAntlrParser.DECRYPT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEDUPLICATE() { return GetToken(OracleAntlrParser.DEDUPLICATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFERRABLE() { return GetToken(OracleAntlrParser.DEFERRABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFERRED() { return GetToken(OracleAntlrParser.DEFERRED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFINER() { return GetToken(OracleAntlrParser.DEFINER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(OracleAntlrParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEMAND() { return GetToken(OracleAntlrParser.DEMAND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DENSE_RANK() { return GetToken(OracleAntlrParser.DENSE_RANK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEPTH() { return GetToken(OracleAntlrParser.DEPTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DETERMINISTIC() { return GetToken(OracleAntlrParser.DETERMINISTIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECT_LOAD() { return GetToken(OracleAntlrParser.DIRECT_LOAD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISABLE() { return GetToken(OracleAntlrParser.DISABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISALLOW() { return GetToken(OracleAntlrParser.DISALLOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISASSOCIATE() { return GetToken(OracleAntlrParser.DISASSOCIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOUBLE() { return GetToken(OracleAntlrParser.DOUBLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DUPLICATED() { return GetToken(OracleAntlrParser.DUPLICATED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EACH() { return GetToken(OracleAntlrParser.EACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITION() { return GetToken(OracleAntlrParser.EDITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITIONABLE() { return GetToken(OracleAntlrParser.EDITIONABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITIONING() { return GetToken(OracleAntlrParser.EDITIONING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITIONS() { return GetToken(OracleAntlrParser.EDITIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELEMENT() { return GetToken(OracleAntlrParser.ELEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSIF() { return GetToken(OracleAntlrParser.ELSIF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EMPTY_KEYWORD() { return GetToken(OracleAntlrParser.EMPTY_KEYWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENCRYPT() { return GetToken(OracleAntlrParser.ENCRYPT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENFORCED() { return GetToken(OracleAntlrParser.ENFORCED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR_CODE() { return GetToken(OracleAntlrParser.ERROR_CODE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR_INDEX() { return GetToken(OracleAntlrParser.ERROR_INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERRORS() { return GetToken(OracleAntlrParser.ERRORS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ESCAPE() { return GetToken(OracleAntlrParser.ESCAPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EVALUATE() { return GetToken(OracleAntlrParser.EVALUATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPT() { return GetToken(OracleAntlrParser.EXCEPT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPTION_INIT() { return GetToken(OracleAntlrParser.EXCEPTION_INIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPTIONS() { return GetToken(OracleAntlrParser.EXCEPTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLUDE() { return GetToken(OracleAntlrParser.EXCLUDE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXECUTE() { return GetToken(OracleAntlrParser.EXECUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(OracleAntlrParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXIT() { return GetToken(OracleAntlrParser.EXIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXPIRE() { return GetToken(OracleAntlrParser.EXPIRE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTEND() { return GetToken(OracleAntlrParser.EXTEND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTENDED() { return GetToken(OracleAntlrParser.EXTENDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTENT() { return GetToken(OracleAntlrParser.EXTENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTERNALLY() { return GetToken(OracleAntlrParser.EXTERNALLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTRACT() { return GetToken(OracleAntlrParser.EXTRACT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FALSE() { return GetToken(OracleAntlrParser.FALSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FAST() { return GetToken(OracleAntlrParser.FAST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FILESYSTEM_LIKE_LOGGING() { return GetToken(OracleAntlrParser.FILESYSTEM_LIKE_LOGGING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FINAL() { return GetToken(OracleAntlrParser.FINAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIPSFLAG() { return GetToken(OracleAntlrParser.FIPSFLAG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIRST() { return GetToken(OracleAntlrParser.FIRST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIXED() { return GetToken(OracleAntlrParser.FIXED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIRST_ROWS() { return GetToken(OracleAntlrParser.FIRST_ROWS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLASH_CACHE() { return GetToken(OracleAntlrParser.FLASH_CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOLLOWING() { return GetToken(OracleAntlrParser.FOLLOWING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORALL() { return GetToken(OracleAntlrParser.FORALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORCE() { return GetToken(OracleAntlrParser.FORCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOREIGN() { return GetToken(OracleAntlrParser.FOREIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORMAT() { return GetToken(OracleAntlrParser.FORMAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOUND() { return GetToken(OracleAntlrParser.FOUND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FREELIST() { return GetToken(OracleAntlrParser.FREELIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FREELISTS() { return GetToken(OracleAntlrParser.FREELISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FREEPOOLS() { return GetToken(OracleAntlrParser.FREEPOOLS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FULL() { return GetToken(OracleAntlrParser.FULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTION() { return GetToken(OracleAntlrParser.FUNCTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GENERATED() { return GetToken(OracleAntlrParser.GENERATED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GLOBAL() { return GetToken(OracleAntlrParser.GLOBAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GLOBALLY() { return GetToken(OracleAntlrParser.GLOBALLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUPING() { return GetToken(OracleAntlrParser.GROUPING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUPS() { return GetToken(OracleAntlrParser.GROUPS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(OracleAntlrParser.HASH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HEAP() { return GetToken(OracleAntlrParser.HEAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HIGH() { return GetToken(OracleAntlrParser.HIGH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HOUR() { return GetToken(OracleAntlrParser.HOUR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(OracleAntlrParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(OracleAntlrParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTITY() { return GetToken(OracleAntlrParser.IDENTITY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDE() { return GetToken(OracleAntlrParser.INCLUDE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDING() { return GetToken(OracleAntlrParser.INCLUDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEXING() { return GetToken(OracleAntlrParser.INDEXING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDICATOR() { return GetToken(OracleAntlrParser.INDICATOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDICES() { return GetToken(OracleAntlrParser.INDICES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INITIALLY() { return GetToken(OracleAntlrParser.INITIALLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INITRANS() { return GetToken(OracleAntlrParser.INITRANS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INNER() { return GetToken(OracleAntlrParser.INNER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSTANCE() { return GetToken(OracleAntlrParser.INSTANCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSTANTIABLE() { return GetToken(OracleAntlrParser.INSTANTIABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSTEAD() { return GetToken(OracleAntlrParser.INSTEAD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERFACE() { return GetToken(OracleAntlrParser.INTERFACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERVAL() { return GetToken(OracleAntlrParser.INTERVAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALIDATE() { return GetToken(OracleAntlrParser.INVALIDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALIDATION() { return GetToken(OracleAntlrParser.INVALIDATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVISIBLE() { return GetToken(OracleAntlrParser.INVISIBLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ISOLATION() { return GetToken(OracleAntlrParser.ISOLATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ISOPEN() { return GetToken(OracleAntlrParser.ISOPEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JAVA() { return GetToken(OracleAntlrParser.JAVA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JOIN() { return GetToken(OracleAntlrParser.JOIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JSON() { return GetToken(OracleAntlrParser.JSON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JSON_TABLE() { return GetToken(OracleAntlrParser.JSON_TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP_DUPLICATES() { return GetToken(OracleAntlrParser.KEEP_DUPLICATES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(OracleAntlrParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LANGUAGE() { return GetToken(OracleAntlrParser.LANGUAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LAST() { return GetToken(OracleAntlrParser.LAST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEADING() { return GetToken(OracleAntlrParser.LEADING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEFT() { return GetToken(OracleAntlrParser.LEFT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS() { return GetToken(OracleAntlrParser.LESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEVEL() { return GetToken(OracleAntlrParser.LEVEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEVELS() { return GetToken(OracleAntlrParser.LEVELS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIBRARY() { return GetToken(OracleAntlrParser.LIBRARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKE2() { return GetToken(OracleAntlrParser.LIKE2, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKE4() { return GetToken(OracleAntlrParser.LIKE4, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKEC() { return GetToken(OracleAntlrParser.LIKEC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIMIT() { return GetToken(OracleAntlrParser.LIMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIST() { return GetToken(OracleAntlrParser.LIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOB() { return GetToken(OracleAntlrParser.LOB, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOBS() { return GetToken(OracleAntlrParser.LOBS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(OracleAntlrParser.LOCAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCATOR() { return GetToken(OracleAntlrParser.LOCATOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCKED() { return GetToken(OracleAntlrParser.LOCKED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCKING() { return GetToken(OracleAntlrParser.LOCKING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOG() { return GetToken(OracleAntlrParser.LOG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOGGING() { return GetToken(OracleAntlrParser.LOGGING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOGOFF() { return GetToken(OracleAntlrParser.LOGOFF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOGON() { return GetToken(OracleAntlrParser.LOGON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LONG() { return GetToken(OracleAntlrParser.LONG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOW() { return GetToken(OracleAntlrParser.LOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAP() { return GetToken(OracleAntlrParser.MAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAPPING() { return GetToken(OracleAntlrParser.MAPPING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MASTER() { return GetToken(OracleAntlrParser.MASTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATCHED() { return GetToken(OracleAntlrParser.MATCHED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATERIALIZED() { return GetToken(OracleAntlrParser.MATERIALIZED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAX() { return GetToken(OracleAntlrParser.MAX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXSIZE() { return GetToken(OracleAntlrParser.MAXSIZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXTRANS() { return GetToken(OracleAntlrParser.MAXTRANS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXVALUE() { return GetToken(OracleAntlrParser.MAXVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEDIUM() { return GetToken(OracleAntlrParser.MEDIUM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEMBER() { return GetToken(OracleAntlrParser.MEMBER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEMOPTIMIZE() { return GetToken(OracleAntlrParser.MEMOPTIMIZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MERGE() { return GetToken(OracleAntlrParser.MERGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode METADATA() { return GetToken(OracleAntlrParser.METADATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MIN() { return GetToken(OracleAntlrParser.MIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINEXTENTS() { return GetToken(OracleAntlrParser.MINEXTENTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUTE() { return GetToken(OracleAntlrParser.MINUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINVALUE() { return GetToken(OracleAntlrParser.MINVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MOD() { return GetToken(OracleAntlrParser.MOD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MONITORING() { return GetToken(OracleAntlrParser.MONITORING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MONTH() { return GetToken(OracleAntlrParser.MONTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MOVEMENT() { return GetToken(OracleAntlrParser.MOVEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MULTISET() { return GetToken(OracleAntlrParser.MULTISET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAME() { return GetToken(OracleAntlrParser.NAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NATIONAL() { return GetToken(OracleAntlrParser.NATIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NATURAL() { return GetToken(OracleAntlrParser.NATURAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NCHAR() { return GetToken(OracleAntlrParser.NCHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NCHAR_CS() { return GetToken(OracleAntlrParser.NCHAR_CS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NCHR() { return GetToken(OracleAntlrParser.NCHR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NESTED() { return GetToken(OracleAntlrParser.NESTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEVER() { return GetToken(OracleAntlrParser.NEVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(OracleAntlrParser.NEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW_NAMES() { return GetToken(OracleAntlrParser.NEW_NAMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEXT() { return GetToken(OracleAntlrParser.NEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NO() { return GetToken(OracleAntlrParser.NO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCACHE() { return GetToken(OracleAntlrParser.NOCACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCOPY() { return GetToken(OracleAntlrParser.NOCOPY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCYCLE() { return GetToken(OracleAntlrParser.NOCYCLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOEXTEND() { return GetToken(OracleAntlrParser.NOEXTEND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOKEEP() { return GetToken(OracleAntlrParser.NOKEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOLOGGING() { return GetToken(OracleAntlrParser.NOLOGGING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMAPPING() { return GetToken(OracleAntlrParser.NOMAPPING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMAXVALUE() { return GetToken(OracleAntlrParser.NOMAXVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMINVALUE() { return GetToken(OracleAntlrParser.NOMINVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMONITORING() { return GetToken(OracleAntlrParser.NOMONITORING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(OracleAntlrParser.NONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONEDITIONABLE() { return GetToken(OracleAntlrParser.NONEDITIONABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONSCHEMA() { return GetToken(OracleAntlrParser.NONSCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOORDER() { return GetToken(OracleAntlrParser.NOORDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOPARALLEL() { return GetToken(OracleAntlrParser.NOPARALLEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NORELY() { return GetToken(OracleAntlrParser.NORELY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOREVERSE() { return GetToken(OracleAntlrParser.NOREVERSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOROWDEPENDENCIES() { return GetToken(OracleAntlrParser.NOROWDEPENDENCIES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOSCALE() { return GetToken(OracleAntlrParser.NOSCALE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOSHARD() { return GetToken(OracleAntlrParser.NOSHARD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOSORT() { return GetToken(OracleAntlrParser.NOSORT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOTFOUND() { return GetToken(OracleAntlrParser.NOTFOUND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOVALIDATE() { return GetToken(OracleAntlrParser.NOVALIDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULLS() { return GetToken(OracleAntlrParser.NULLS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(OracleAntlrParser.OBJECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OID() { return GetToken(OracleAntlrParser.OID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OIDINDEX() { return GetToken(OracleAntlrParser.OIDINDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OLD() { return GetToken(OracleAntlrParser.OLD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLINE() { return GetToken(OracleAntlrParser.ONLINE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLY() { return GetToken(OracleAntlrParser.ONLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPAQUE() { return GetToken(OracleAntlrParser.OPAQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN() { return GetToken(OracleAntlrParser.OPEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPERATIONS() { return GetToken(OracleAntlrParser.OPERATIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTIMAL() { return GetToken(OracleAntlrParser.OPTIMAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDINALITY() { return GetToken(OracleAntlrParser.ORDINALITY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORGANIZATION() { return GetToken(OracleAntlrParser.ORGANIZATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OUT() { return GetToken(OracleAntlrParser.OUT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OUTER() { return GetToken(OracleAntlrParser.OUTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVER() { return GetToken(OracleAntlrParser.OVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVERFLOW() { return GetToken(OracleAntlrParser.OVERFLOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVERRIDING() { return GetToken(OracleAntlrParser.OVERRIDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVERLAPS() { return GetToken(OracleAntlrParser.OVERLAPS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PACKAGE() { return GetToken(OracleAntlrParser.PACKAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARALLEL() { return GetToken(OracleAntlrParser.PARALLEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARALLEL_ENABLE() { return GetToken(OracleAntlrParser.PARALLEL_ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARAMETERS() { return GetToken(OracleAntlrParser.PARAMETERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARENT() { return GetToken(OracleAntlrParser.PARENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTIAL() { return GetToken(OracleAntlrParser.PARTIAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITIONS() { return GetToken(OracleAntlrParser.PARTITIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSING() { return GetToken(OracleAntlrParser.PASSING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORD() { return GetToken(OracleAntlrParser.PASSWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(OracleAntlrParser.PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTINCREASE() { return GetToken(OracleAntlrParser.PCTINCREASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTTHRESHOLD() { return GetToken(OracleAntlrParser.PCTTHRESHOLD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTUSED() { return GetToken(OracleAntlrParser.PCTUSED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTVERSION() { return GetToken(OracleAntlrParser.PCTVERSION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENTILE_DISC() { return GetToken(OracleAntlrParser.PERCENTILE_DISC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERIOD() { return GetToken(OracleAntlrParser.PERIOD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PIPE() { return GetToken(OracleAntlrParser.PIPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PIPELINED() { return GetToken(OracleAntlrParser.PIPELINED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POLYMORPHIC() { return GetToken(OracleAntlrParser.POLYMORPHIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRAGMA() { return GetToken(OracleAntlrParser.PRAGMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PREBUILT() { return GetToken(OracleAntlrParser.PREBUILT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRECEDING() { return GetToken(OracleAntlrParser.PRECEDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRECISION() { return GetToken(OracleAntlrParser.PRECISION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRESERVE() { return GetToken(OracleAntlrParser.PRESERVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIMARY() { return GetToken(OracleAntlrParser.PRIMARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIOR() { return GetToken(OracleAntlrParser.PRIOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIVATE() { return GetToken(OracleAntlrParser.PRIVATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROCEDURE() { return GetToken(OracleAntlrParser.PROCEDURE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROFILE() { return GetToken(OracleAntlrParser.PROFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PUBLIC() { return GetToken(OracleAntlrParser.PUBLIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PURGE() { return GetToken(OracleAntlrParser.PURGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUERY() { return GetToken(OracleAntlrParser.QUERY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTA() { return GetToken(OracleAntlrParser.QUOTA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RAISE() { return GetToken(OracleAntlrParser.RAISE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RAISE_APPLICATION_ERROR() { return GetToken(OracleAntlrParser.RAISE_APPLICATION_ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(OracleAntlrParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RAW() { return GetToken(OracleAntlrParser.RAW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READ() { return GetToken(OracleAntlrParser.READ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READS() { return GetToken(OracleAntlrParser.READS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REBUILD() { return GetToken(OracleAntlrParser.REBUILD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RECORD() { return GetToken(OracleAntlrParser.RECORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RECYCLE() { return GetToken(OracleAntlrParser.RECYCLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REDUCED() { return GetToken(OracleAntlrParser.REDUCED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REF() { return GetToken(OracleAntlrParser.REF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFERENCES() { return GetToken(OracleAntlrParser.REFERENCES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFERENCING() { return GetToken(OracleAntlrParser.REFERENCING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFRESH() { return GetToken(OracleAntlrParser.REFRESH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REJECT() { return GetToken(OracleAntlrParser.REJECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONAL() { return GetToken(OracleAntlrParser.RELATIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELIES_ON() { return GetToken(OracleAntlrParser.RELIES_ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELY() { return GetToken(OracleAntlrParser.RELY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RENAME() { return GetToken(OracleAntlrParser.RENAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPLACE() { return GetToken(OracleAntlrParser.REPLACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RESTRICT_REFERENCES() { return GetToken(OracleAntlrParser.RESTRICT_REFERENCES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RESULT() { return GetToken(OracleAntlrParser.RESULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RESULT_CACHE() { return GetToken(OracleAntlrParser.RESULT_CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETENTION() { return GetToken(OracleAntlrParser.RETENTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURNING() { return GetToken(OracleAntlrParser.RETURNING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REUSE() { return GetToken(OracleAntlrParser.REUSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REVERSE() { return GetToken(OracleAntlrParser.REVERSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REWRITE() { return GetToken(OracleAntlrParser.REWRITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RIGHT() { return GetToken(OracleAntlrParser.RIGHT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLLUP() { return GetToken(OracleAntlrParser.ROLLUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWCOUNT() { return GetToken(OracleAntlrParser.ROWCOUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWDEPENDENCIES() { return GetToken(OracleAntlrParser.ROWDEPENDENCIES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWID() { return GetToken(OracleAntlrParser.ROWID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWTYPE() { return GetToken(OracleAntlrParser.ROWTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SALT() { return GetToken(OracleAntlrParser.SALT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SAMPLE() { return GetToken(OracleAntlrParser.SAMPLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SAVE() { return GetToken(OracleAntlrParser.SAVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SAVEPOINT() { return GetToken(OracleAntlrParser.SAVEPOINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCALE() { return GetToken(OracleAntlrParser.SCALE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCHEMA() { return GetToken(OracleAntlrParser.SCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCN() { return GetToken(OracleAntlrParser.SCN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCOPE() { return GetToken(OracleAntlrParser.SCOPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEARCH() { return GetToken(OracleAntlrParser.SEARCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECOND() { return GetToken(OracleAntlrParser.SECOND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECUREFILE() { return GetToken(OracleAntlrParser.SECUREFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEED() { return GetToken(OracleAntlrParser.SEED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEGMENT() { return GetToken(OracleAntlrParser.SEGMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SELF() { return GetToken(OracleAntlrParser.SELF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEQUENCE() { return GetToken(OracleAntlrParser.SEQUENCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERIALIZABLE() { return GetToken(OracleAntlrParser.SERIALIZABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERIALLY_REUSABLE() { return GetToken(OracleAntlrParser.SERIALLY_REUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVERERROR() { return GetToken(OracleAntlrParser.SERVERERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SESSION() { return GetToken(OracleAntlrParser.SESSION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SESSIONTIMEZONE() { return GetToken(OracleAntlrParser.SESSIONTIMEZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETS() { return GetToken(OracleAntlrParser.SETS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETTINGS() { return GetToken(OracleAntlrParser.SETTINGS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARD() { return GetToken(OracleAntlrParser.SHARD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARDED() { return GetToken(OracleAntlrParser.SHARDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARING() { return GetToken(OracleAntlrParser.SHARING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHRINK() { return GetToken(OracleAntlrParser.SHRINK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHUTDOWN() { return GetToken(OracleAntlrParser.SHUTDOWN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIBLINGS() { return GetToken(OracleAntlrParser.SIBLINGS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIZE() { return GetToken(OracleAntlrParser.SIZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SKIP_() { return GetToken(OracleAntlrParser.SKIP_, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SOME() { return GetToken(OracleAntlrParser.SOME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SORT() { return GetToken(OracleAntlrParser.SORT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SPACE() { return GetToken(OracleAntlrParser.SPACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SPECIFICATION() { return GetToken(OracleAntlrParser.SPECIFICATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SPLIT() { return GetToken(OracleAntlrParser.SPLIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STARTUP() { return GetToken(OracleAntlrParser.STARTUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATEMENT() { return GetToken(OracleAntlrParser.STATEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATIC() { return GetToken(OracleAntlrParser.STATIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATISTICS() { return GetToken(OracleAntlrParser.STATISTICS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORAGE() { return GetToken(OracleAntlrParser.STORAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING() { return GetToken(OracleAntlrParser.STRING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBMULTISET() { return GetToken(OracleAntlrParser.SUBMULTISET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITIONS() { return GetToken(OracleAntlrParser.SUBPARTITIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBSTITUTABLE() { return GetToken(OracleAntlrParser.SUBSTITUTABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBTYPE() { return GetToken(OracleAntlrParser.SUBTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUPPLEMENTAL() { return GetToken(OracleAntlrParser.SUPPLEMENTAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUSPEND() { return GetToken(OracleAntlrParser.SUSPEND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SYNONYM() { return GetToken(OracleAntlrParser.SYNONYM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SYSTEM() { return GetToken(OracleAntlrParser.SYSTEM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLES() { return GetToken(OracleAntlrParser.TABLES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLESPACE() { return GetToken(OracleAntlrParser.TABLESPACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEMPLATE() { return GetToken(OracleAntlrParser.TEMPLATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEMPORARY() { return GetToken(OracleAntlrParser.TEMPORARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THAN() { return GetToken(OracleAntlrParser.THAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIME() { return GetToken(OracleAntlrParser.TIME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMESTAMP() { return GetToken(OracleAntlrParser.TIMESTAMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_ABBR() { return GetToken(OracleAntlrParser.TIMEZONE_ABBR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_HOUR() { return GetToken(OracleAntlrParser.TIMEZONE_HOUR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_MINUTE() { return GetToken(OracleAntlrParser.TIMEZONE_MINUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_REGION() { return GetToken(OracleAntlrParser.TIMEZONE_REGION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRAILING() { return GetToken(OracleAntlrParser.TRAILING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRANSACTION() { return GetToken(OracleAntlrParser.TRANSACTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRANSLATE() { return GetToken(OracleAntlrParser.TRANSLATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TREAT() { return GetToken(OracleAntlrParser.TREAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIM() { return GetToken(OracleAntlrParser.TRIM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUE() { return GetToken(OracleAntlrParser.TRUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUNCATE() { return GetToken(OracleAntlrParser.TRUNCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUSTED() { return GetToken(OracleAntlrParser.TRUSTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNBOUNDED() { return GetToken(OracleAntlrParser.UNBOUNDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNCONDITIONAL() { return GetToken(OracleAntlrParser.UNCONDITIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNDER() { return GetToken(OracleAntlrParser.UNDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNLIMITED() { return GetToken(OracleAntlrParser.UNLIMITED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNLOCK() { return GetToken(OracleAntlrParser.UNLOCK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSED() { return GetToken(OracleAntlrParser.UNUSED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USABLE() { return GetToken(OracleAntlrParser.USABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USAGE() { return GetToken(OracleAntlrParser.USAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USE() { return GetToken(OracleAntlrParser.USE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(OracleAntlrParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALIDATE() { return GetToken(OracleAntlrParser.VALIDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(OracleAntlrParser.VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARCHAR() { return GetToken(OracleAntlrParser.VARCHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARCHAR2() { return GetToken(OracleAntlrParser.VARCHAR2, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARRAY() { return GetToken(OracleAntlrParser.VARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARRAYS() { return GetToken(OracleAntlrParser.VARRAYS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARYING() { return GetToken(OracleAntlrParser.VARYING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VERSIONS() { return GetToken(OracleAntlrParser.VERSIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VIRTUAL() { return GetToken(OracleAntlrParser.VIRTUAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VISIBLE() { return GetToken(OracleAntlrParser.VISIBLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WAIT() { return GetToken(OracleAntlrParser.WAIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITHIN() { return GetToken(OracleAntlrParser.WITHIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITHOUT() { return GetToken(OracleAntlrParser.WITHOUT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WORK() { return GetToken(OracleAntlrParser.WORK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRAPPED() { return GetToken(OracleAntlrParser.WRAPPED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRAPPER() { return GetToken(OracleAntlrParser.WRAPPER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRITE() { return GetToken(OracleAntlrParser.WRITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XML() { return GetToken(OracleAntlrParser.XML, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLNAMESPACES() { return GetToken(OracleAntlrParser.XMLNAMESPACES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLSCHEMA() { return GetToken(OracleAntlrParser.XMLSCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLTABLE() { return GetToken(OracleAntlrParser.XMLTABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLTYPE() { return GetToken(OracleAntlrParser.XMLTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode YEAR() { return GetToken(OracleAntlrParser.YEAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ZONE() { return GetToken(OracleAntlrParser.ZONE, 0); }
		public SimpleIdentifierRegularIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleIdentifierRegularIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSimpleIdentifierRegularIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSimpleIdentifierRegularIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier() {
		SimpleIdentifierRegularIdentifierContext _localctx = new SimpleIdentifierRegularIdentifierContext(Context, State);
		EnterRule(_localctx, 62, RULE_simpleIdentifierRegularIdentifier);
		int _la;
		try {
			State = 1938;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case REGULAR_IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1936;
				Match(REGULAR_IDENTIFIER);
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1937;
				_la = TokenStream.LA(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || _la==YEAR || _la==ZONE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DotInIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(OracleAntlrParser.DOT, 0); }
		public DotInIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dotInIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDotInIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDotInIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public DotInIdentifierContext dotInIdentifier() {
		DotInIdentifierContext _localctx = new DotInIdentifierContext(Context, State);
		EnterRule(_localctx, 64, RULE_dotInIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1940;
			Match(DOT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext[] simpleIdentifier() {
			return GetRuleContexts<SimpleIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier(int i) {
			return GetRuleContext<SimpleIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext[] dotInIdentifier() {
			return GetRuleContexts<DotInIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext dotInIdentifier(int i) {
			return GetRuleContext<DotInIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NestedCollectionSimpleIdentifierContext[] nestedCollectionSimpleIdentifier() {
			return GetRuleContexts<NestedCollectionSimpleIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NestedCollectionSimpleIdentifierContext nestedCollectionSimpleIdentifier(int i) {
			return GetRuleContext<NestedCollectionSimpleIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS_SIGN() { return GetToken(OracleAntlrParser.PLUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AsteriskContext[] asterisk() {
			return GetRuleContexts<AsteriskContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AsteriskContext asterisk(int i) {
			return GetRuleContext<AsteriskContext>(i);
		}
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(Context, State);
		EnterRule(_localctx, 66, RULE_identifier);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1942;
			simpleIdentifier();
			State = 1951;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,29,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 1949;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case DOT:
						{
						State = 1943;
						dotInIdentifier();
						State = 1946;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case A_:
						case ACCOUNT:
						case ADVANCED:
						case AFTER:
						case AGENT:
						case AGGREGATE:
						case ALLOCATE:
						case ALLOW:
						case ALWAYS:
						case ANALYZE:
						case ANYSCHEMA:
						case ARCHIVE:
						case ARRAY:
						case ASSOCIATE:
						case AT:
						case ATTRIBUTE:
						case ATTRIBUTES:
						case AUTHENTICATION:
						case AUTHID:
						case AUTO:
						case AUTONOMOUS_TRANSACTION:
						case BASIC:
						case BASICFILE:
						case BATCH:
						case BEFORE:
						case BEGINNING:
						case BINARY:
						case BITMAP:
						case BLOCK:
						case BODY:
						case BOTH:
						case BREADTH:
						case BUFFER_POOL:
						case BUILD:
						case BUILTIN:
						case BULK:
						case BULK_EXCEPTIONS:
						case BULK_ROWCOUNT:
						case BYTE:
						case C_:
						case CACHE:
						case CALL:
						case CASCADE:
						case CAST:
						case CELL_FLASH_CACHE:
						case CHAR:
						case CHAR_CS:
						case CHARACTER:
						case CHARSET:
						case CHR:
						case CHUNK:
						case CLOB:
						case CLOSE:
						case COALESCE:
						case COLLATION:
						case COLLECT:
						case COLUMN_VALUE:
						case COMMIT:
						case COMMITTED:
						case COMPACT:
						case COMPILE:
						case COMPLETE:
						case COMPOUND:
						case COMPUTATION:
						case COMPUTE:
						case CONDITIONAL:
						case CONSTANT:
						case CONSTRAINT:
						case CONSTRAINTS:
						case CONSTRUCTOR:
						case CONTAINER:
						case CONTEXT:
						case CONTINUE:
						case CONVERT:
						case COUNT:
						case CREATION:
						case CROSS:
						case CUBE:
						case CURRENT_USER:
						case CYCLE:
						case DATA:
						case DATABASE:
						case DATAFILE:
						case DATE:
						case DAY:
						case DBTIMEZONE:
						case DDL:
						case DEALLOCATE:
						case DEBUG:
						case DECODE:
						case DECRYPT:
						case DEDUPLICATE:
						case DEFERRABLE:
						case DEFERRED:
						case DEFINER:
						case DELETE:
						case DEMAND:
						case DENSE_RANK:
						case DEPTH:
						case DETERMINISTIC:
						case DIRECT_LOAD:
						case DISABLE:
						case DISALLOW:
						case DISASSOCIATE:
						case DOUBLE:
						case DUPLICATED:
						case EACH:
						case EDITION:
						case EDITIONABLE:
						case EDITIONING:
						case EDITIONS:
						case ELEMENT:
						case ELSIF:
						case EMPTY_KEYWORD:
						case ENABLE:
						case ENCRYPT:
						case ENFORCED:
						case ERROR_CODE:
						case ERROR_INDEX:
						case ERROR:
						case ERRORS:
						case ESCAPE:
						case EVALUATE:
						case EXCEPT:
						case EXCEPTION_INIT:
						case EXCEPTIONS:
						case EXCLUDE:
						case EXECUTE:
						case EXISTS:
						case EXIT:
						case EXPIRE:
						case EXTEND:
						case EXTENDED:
						case EXTENT:
						case EXTERNALLY:
						case EXTRACT:
						case FALSE:
						case FAST:
						case FILESYSTEM_LIKE_LOGGING:
						case FINAL:
						case FIPSFLAG:
						case FIRST:
						case FIRST_ROWS:
						case FIXED:
						case FOLLOWING:
						case FORALL:
						case FORCE:
						case FOREIGN:
						case FORMAT:
						case FOUND:
						case FLASH_CACHE:
						case FREELIST:
						case FREELISTS:
						case FREEPOOLS:
						case FULL:
						case FUNCTION:
						case GENERATED:
						case GLOBAL:
						case GLOBALLY:
						case GROUPING:
						case GROUPS:
						case HASH:
						case HEAP:
						case HIGH:
						case HOUR:
						case ID:
						case IDENTIFIER:
						case IDENTITY:
						case INCLUDE:
						case INCLUDING:
						case INDEXING:
						case INDICATOR:
						case INDICES:
						case INITIALLY:
						case INITRANS:
						case INNER:
						case INSTANCE:
						case INSTANTIABLE:
						case INSTEAD:
						case INTERFACE:
						case INTERVAL:
						case INVALIDATE:
						case INVALIDATION:
						case INVISIBLE:
						case ISOLATION:
						case ISOPEN:
						case JAVA:
						case JOIN:
						case JSON:
						case JSON_TABLE:
						case KEEP:
						case KEEP_DUPLICATES:
						case KEY:
						case LANGUAGE:
						case LAST:
						case LEADING:
						case LEFT:
						case LESS:
						case LEVEL:
						case LEVELS:
						case LIBRARY:
						case LIKE2:
						case LIKE4:
						case LIKEC:
						case LIMIT:
						case LIST:
						case LOB:
						case LOBS:
						case LOCAL:
						case LOCATOR:
						case LOCKED:
						case LOCKING:
						case LOG:
						case LOGGING:
						case LOGOFF:
						case LOGON:
						case LONG:
						case LOW:
						case MAP:
						case MAPPING:
						case MASTER:
						case MATCHED:
						case MATERIALIZED:
						case MAX:
						case MAXSIZE:
						case MAXTRANS:
						case MAXVALUE:
						case MEDIUM:
						case MEMBER:
						case MEMOPTIMIZE:
						case MERGE:
						case METADATA:
						case MIN:
						case MINEXTENTS:
						case MINUTE:
						case MINVALUE:
						case MOD:
						case MONITORING:
						case MONTH:
						case MOVEMENT:
						case MULTISET:
						case NAME:
						case NATIONAL:
						case NATURAL:
						case NCHAR:
						case NCHAR_CS:
						case NCHR:
						case NESTED:
						case NEVER:
						case NEW:
						case NEW_NAMES:
						case NEXT:
						case NO:
						case NOCACHE:
						case NOCOPY:
						case NOCYCLE:
						case NOEXTEND:
						case NOKEEP:
						case NOLOGGING:
						case NOMAPPING:
						case NOMAXVALUE:
						case NOMINVALUE:
						case NOMONITORING:
						case NOORDER:
						case NONE:
						case NONEDITIONABLE:
						case NONSCHEMA:
						case NOPARALLEL:
						case NORELY:
						case NOREVERSE:
						case NOROWDEPENDENCIES:
						case NOSCALE:
						case NOSHARD:
						case NOSORT:
						case NOTFOUND:
						case NOVALIDATE:
						case NULLS:
						case OBJECT:
						case OID:
						case OIDINDEX:
						case OLD:
						case ONLY:
						case ONLINE:
						case OPAQUE:
						case OPEN:
						case OPERATIONS:
						case OPTIMAL:
						case ORDINALITY:
						case ORGANIZATION:
						case OUT:
						case OUTER:
						case OVER:
						case OVERFLOW:
						case OVERLAPS:
						case OVERRIDING:
						case PACKAGE:
						case PARALLEL:
						case PARALLEL_ENABLE:
						case PARAMETERS:
						case PARENT:
						case PARTIAL:
						case PARTITION:
						case PARTITIONS:
						case PASSING:
						case PASSWORD:
						case PATH:
						case PCTINCREASE:
						case PCTTHRESHOLD:
						case PCTUSED:
						case PCTVERSION:
						case PERCENTILE_DISC:
						case PERIOD:
						case PIPE:
						case PIPELINED:
						case POLYMORPHIC:
						case PRAGMA:
						case PREBUILT:
						case PRECEDING:
						case PRECISION:
						case PRESERVE:
						case PRIMARY:
						case PRIOR:
						case PRIVATE:
						case PROCEDURE:
						case PROFILE:
						case PUBLIC:
						case PURGE:
						case QUERY:
						case QUOTA:
						case RAISE:
						case RAISE_APPLICATION_ERROR:
						case RANGE:
						case RAW:
						case READ:
						case READS:
						case REBUILD:
						case RECORD:
						case RECYCLE:
						case REDUCED:
						case REF:
						case REFERENCES:
						case REFERENCING:
						case REFRESH:
						case REJECT:
						case RELATIONAL:
						case RELIES_ON:
						case RELY:
						case RENAME:
						case REPLACE:
						case RESTRICT_REFERENCES:
						case RESULT:
						case RESULT_CACHE:
						case RETENTION:
						case RETURNING:
						case REUSE:
						case REVERSE:
						case REWRITE:
						case RIGHT:
						case ROLLUP:
						case ROW:
						case ROWCOUNT:
						case ROWDEPENDENCIES:
						case ROWID:
						case ROWTYPE:
						case SALT:
						case SAMPLE:
						case SAVE:
						case SAVEPOINT:
						case SCALE:
						case SCHEMA:
						case SCN:
						case SCOPE:
						case SEARCH:
						case SECOND:
						case SECUREFILE:
						case SEED:
						case SEGMENT:
						case SELF:
						case SEQUENCE:
						case SERIALIZABLE:
						case SERIALLY_REUSABLE:
						case SERVERERROR:
						case SESSION:
						case SESSIONTIMEZONE:
						case SET:
						case SETS:
						case SETTINGS:
						case SHRINK:
						case SHUTDOWN:
						case SIBLINGS:
						case SIZE:
						case SKIP_:
						case SOME:
						case SORT:
						case SPACE:
						case SPECIFICATION:
						case SPLIT:
						case STARTUP:
						case STATEMENT:
						case STATIC:
						case STATISTICS:
						case STORAGE:
						case STORE:
						case STRING:
						case SHARD:
						case SHARDED:
						case SHARING:
						case SUBMULTISET:
						case SUBPARTITION:
						case SUBPARTITIONS:
						case SUBSTITUTABLE:
						case SUBTYPE:
						case SUPPLEMENTAL:
						case SUSPEND:
						case SYNONYM:
						case SYSTEM:
						case TABLES:
						case TABLESPACE:
						case TEMPLATE:
						case TEMPORARY:
						case THAN:
						case TIME:
						case TIMESTAMP:
						case TIMEZONE_ABBR:
						case TIMEZONE_HOUR:
						case TIMEZONE_MINUTE:
						case TIMEZONE_REGION:
						case TRAILING:
						case TRANSACTION:
						case TRANSLATE:
						case TREAT:
						case TRIM:
						case TRUE:
						case TRUNCATE:
						case TRUSTED:
						case TYPE:
						case UNBOUNDED:
						case UNCONDITIONAL:
						case UNDER:
						case UNLIMITED:
						case UNLOCK:
						case UNUSABLE:
						case UNUSED:
						case USABLE:
						case USAGE:
						case USE:
						case USER:
						case USING:
						case VALIDATE:
						case VALUE:
						case VARCHAR:
						case VARCHAR2:
						case VARRAY:
						case VARRAYS:
						case VARYING:
						case VERSIONS:
						case VIRTUAL:
						case VISIBLE:
						case WAIT:
						case WHEN:
						case WITHIN:
						case WITHOUT:
						case WORK:
						case WRAPPED:
						case WRAPPER:
						case WRITE:
						case XML:
						case XMLNAMESPACES:
						case XMLSCHEMA:
						case XMLTABLE:
						case XMLTYPE:
						case YEAR:
						case ZONE:
						case REGULAR_IDENTIFIER:
						case QUOTED_IDENTIFIER:
							{
							State = 1944;
							simpleIdentifier();
							}
							break;
						case ASTERISK:
							{
							State = 1945;
							asterisk();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						break;
					case LPAREN:
						{
						State = 1948;
						nestedCollectionSimpleIdentifier();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 1953;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,29,Context);
			}
			State = 1957;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				{
				State = 1954;
				Match(LPAREN);
				State = 1955;
				Match(PLUS_SIGN);
				State = 1956;
				Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlainIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext[] simpleIdentifierWithoutParentheses() {
			return GetRuleContexts<SimpleIdentifierWithoutParenthesesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses(int i) {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext[] dotInIdentifier() {
			return GetRuleContexts<DotInIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext dotInIdentifier(int i) {
			return GetRuleContext<DotInIdentifierContext>(i);
		}
		public PlainIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plainIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPlainIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPlainIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public PlainIdentifierContext plainIdentifier() {
		PlainIdentifierContext _localctx = new PlainIdentifierContext(Context, State);
		EnterRule(_localctx, 68, RULE_plainIdentifier);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1959;
			simpleIdentifierWithoutParentheses();
			State = 1965;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,31,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1960;
					dotInIdentifier();
					State = 1961;
					simpleIdentifierWithoutParentheses();
					}
					} 
				}
				State = 1967;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,31,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlainRemoteIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext[] simpleIdentifierWithoutParentheses() {
			return GetRuleContexts<SimpleIdentifierWithoutParenthesesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses(int i) {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext[] dotInIdentifier() {
			return GetRuleContexts<DotInIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext dotInIdentifier(int i) {
			return GetRuleContext<DotInIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DbLinkContext dbLink() {
			return GetRuleContext<DbLinkContext>(0);
		}
		public PlainRemoteIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plainRemoteIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPlainRemoteIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPlainRemoteIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public PlainRemoteIdentifierContext plainRemoteIdentifier() {
		PlainRemoteIdentifierContext _localctx = new PlainRemoteIdentifierContext(Context, State);
		EnterRule(_localctx, 70, RULE_plainRemoteIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1968;
			simpleIdentifierWithoutParentheses();
			State = 1974;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DOT) {
				{
				{
				State = 1969;
				dotInIdentifier();
				State = 1970;
				simpleIdentifierWithoutParentheses();
				}
				}
				State = 1976;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1978;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AT_SIGN) {
				{
				State = 1977;
				dbLink();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultipartPlainIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext[] simpleIdentifierWithoutParentheses() {
			return GetRuleContexts<SimpleIdentifierWithoutParenthesesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses(int i) {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext[] dotInIdentifier() {
			return GetRuleContexts<DotInIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext dotInIdentifier(int i) {
			return GetRuleContext<DotInIdentifierContext>(i);
		}
		public MultipartPlainIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multipartPlainIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMultipartPlainIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMultipartPlainIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public MultipartPlainIdentifierContext multipartPlainIdentifier() {
		MultipartPlainIdentifierContext _localctx = new MultipartPlainIdentifierContext(Context, State);
		EnterRule(_localctx, 72, RULE_multipartPlainIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1980;
			simpleIdentifierWithoutParentheses();
			State = 1984;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 1981;
				dotInIdentifier();
				State = 1982;
				simpleIdentifierWithoutParentheses();
				}
				}
				State = 1986;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==DOT );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsteriskContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASTERISK() { return GetToken(OracleAntlrParser.ASTERISK, 0); }
		public AsteriskContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asterisk; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAsterisk(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAsterisk(this);
		}
	}

	[RuleVersion(0)]
	public AsteriskContext asterisk() {
		AsteriskContext _localctx = new AsteriskContext(Context, State);
		EnterRule(_localctx, 74, RULE_asterisk);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1988;
			Match(ASTERISK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DbLinkContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] AT_SIGN() { return GetTokens(OracleAntlrParser.AT_SIGN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT_SIGN(int i) {
			return GetToken(OracleAntlrParser.AT_SIGN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext[] simpleIdentifierRegularIdentifier() {
			return GetRuleContexts<SimpleIdentifierRegularIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier(int i) {
			return GetRuleContext<SimpleIdentifierRegularIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] QUOTED_IDENTIFIER() { return GetTokens(OracleAntlrParser.QUOTED_IDENTIFIER); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTED_IDENTIFIER(int i) {
			return GetToken(OracleAntlrParser.QUOTED_IDENTIFIER, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] DOT() { return GetTokens(OracleAntlrParser.DOT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT(int i) {
			return GetToken(OracleAntlrParser.DOT, i);
		}
		public DbLinkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dbLink; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDbLink(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDbLink(this);
		}
	}

	[RuleVersion(0)]
	public DbLinkContext dbLink() {
		DbLinkContext _localctx = new DbLinkContext(Context, State);
		EnterRule(_localctx, 76, RULE_dbLink);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1990;
			Match(AT_SIGN);
			State = 1993;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
				{
				State = 1991;
				simpleIdentifierRegularIdentifier();
				}
				break;
			case QUOTED_IDENTIFIER:
				{
				State = 1992;
				Match(QUOTED_IDENTIFIER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2002;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,37,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1995;
					_la = TokenStream.LA(1);
					if ( !(_la==AT_SIGN || _la==DOT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 1998;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case A_:
					case ACCOUNT:
					case ADVANCED:
					case AFTER:
					case AGENT:
					case AGGREGATE:
					case ALLOCATE:
					case ALLOW:
					case ALWAYS:
					case ANALYZE:
					case ANYSCHEMA:
					case ARCHIVE:
					case ARRAY:
					case ASSOCIATE:
					case AT:
					case ATTRIBUTE:
					case ATTRIBUTES:
					case AUTHENTICATION:
					case AUTHID:
					case AUTO:
					case AUTONOMOUS_TRANSACTION:
					case BASIC:
					case BASICFILE:
					case BATCH:
					case BEFORE:
					case BEGINNING:
					case BINARY:
					case BITMAP:
					case BLOCK:
					case BODY:
					case BOTH:
					case BREADTH:
					case BUFFER_POOL:
					case BUILD:
					case BUILTIN:
					case BULK:
					case BULK_EXCEPTIONS:
					case BULK_ROWCOUNT:
					case BYTE:
					case C_:
					case CACHE:
					case CALL:
					case CASCADE:
					case CAST:
					case CELL_FLASH_CACHE:
					case CHAR:
					case CHAR_CS:
					case CHARACTER:
					case CHARSET:
					case CHR:
					case CHUNK:
					case CLOB:
					case CLOSE:
					case COALESCE:
					case COLLATION:
					case COLLECT:
					case COLUMN_VALUE:
					case COMMIT:
					case COMMITTED:
					case COMPACT:
					case COMPILE:
					case COMPLETE:
					case COMPOUND:
					case COMPUTATION:
					case COMPUTE:
					case CONDITIONAL:
					case CONSTANT:
					case CONSTRAINT:
					case CONSTRAINTS:
					case CONSTRUCTOR:
					case CONTAINER:
					case CONTEXT:
					case CONTINUE:
					case CONVERT:
					case COUNT:
					case CREATION:
					case CROSS:
					case CUBE:
					case CURRENT_USER:
					case CYCLE:
					case DATA:
					case DATABASE:
					case DATAFILE:
					case DATE:
					case DAY:
					case DBTIMEZONE:
					case DDL:
					case DEALLOCATE:
					case DEBUG:
					case DECODE:
					case DECRYPT:
					case DEDUPLICATE:
					case DEFERRABLE:
					case DEFERRED:
					case DEFINER:
					case DELETE:
					case DEMAND:
					case DENSE_RANK:
					case DEPTH:
					case DETERMINISTIC:
					case DIRECT_LOAD:
					case DISABLE:
					case DISALLOW:
					case DISASSOCIATE:
					case DOUBLE:
					case DUPLICATED:
					case EACH:
					case EDITION:
					case EDITIONABLE:
					case EDITIONING:
					case EDITIONS:
					case ELEMENT:
					case ELSIF:
					case EMPTY_KEYWORD:
					case ENABLE:
					case ENCRYPT:
					case ENFORCED:
					case ERROR_CODE:
					case ERROR_INDEX:
					case ERROR:
					case ERRORS:
					case ESCAPE:
					case EVALUATE:
					case EXCEPT:
					case EXCEPTION_INIT:
					case EXCEPTIONS:
					case EXCLUDE:
					case EXECUTE:
					case EXISTS:
					case EXIT:
					case EXPIRE:
					case EXTEND:
					case EXTENDED:
					case EXTENT:
					case EXTERNALLY:
					case EXTRACT:
					case FALSE:
					case FAST:
					case FILESYSTEM_LIKE_LOGGING:
					case FINAL:
					case FIPSFLAG:
					case FIRST:
					case FIRST_ROWS:
					case FIXED:
					case FOLLOWING:
					case FORALL:
					case FORCE:
					case FOREIGN:
					case FORMAT:
					case FOUND:
					case FLASH_CACHE:
					case FREELIST:
					case FREELISTS:
					case FREEPOOLS:
					case FULL:
					case FUNCTION:
					case GENERATED:
					case GLOBAL:
					case GLOBALLY:
					case GROUPING:
					case GROUPS:
					case HASH:
					case HEAP:
					case HIGH:
					case HOUR:
					case ID:
					case IDENTIFIER:
					case IDENTITY:
					case INCLUDE:
					case INCLUDING:
					case INDEXING:
					case INDICATOR:
					case INDICES:
					case INITIALLY:
					case INITRANS:
					case INNER:
					case INSTANCE:
					case INSTANTIABLE:
					case INSTEAD:
					case INTERFACE:
					case INTERVAL:
					case INVALIDATE:
					case INVALIDATION:
					case INVISIBLE:
					case ISOLATION:
					case ISOPEN:
					case JAVA:
					case JOIN:
					case JSON:
					case JSON_TABLE:
					case KEEP:
					case KEEP_DUPLICATES:
					case KEY:
					case LANGUAGE:
					case LAST:
					case LEADING:
					case LEFT:
					case LESS:
					case LEVEL:
					case LEVELS:
					case LIBRARY:
					case LIKE2:
					case LIKE4:
					case LIKEC:
					case LIMIT:
					case LIST:
					case LOB:
					case LOBS:
					case LOCAL:
					case LOCATOR:
					case LOCKED:
					case LOCKING:
					case LOG:
					case LOGGING:
					case LOGOFF:
					case LOGON:
					case LONG:
					case LOW:
					case MAP:
					case MAPPING:
					case MASTER:
					case MATCHED:
					case MATERIALIZED:
					case MAX:
					case MAXSIZE:
					case MAXTRANS:
					case MAXVALUE:
					case MEDIUM:
					case MEMBER:
					case MEMOPTIMIZE:
					case MERGE:
					case METADATA:
					case MIN:
					case MINEXTENTS:
					case MINUTE:
					case MINVALUE:
					case MOD:
					case MONITORING:
					case MONTH:
					case MOVEMENT:
					case MULTISET:
					case NAME:
					case NATIONAL:
					case NATURAL:
					case NCHAR:
					case NCHAR_CS:
					case NCHR:
					case NESTED:
					case NEVER:
					case NEW:
					case NEW_NAMES:
					case NEXT:
					case NO:
					case NOCACHE:
					case NOCOPY:
					case NOCYCLE:
					case NOEXTEND:
					case NOKEEP:
					case NOLOGGING:
					case NOMAPPING:
					case NOMAXVALUE:
					case NOMINVALUE:
					case NOMONITORING:
					case NOORDER:
					case NONE:
					case NONEDITIONABLE:
					case NONSCHEMA:
					case NOPARALLEL:
					case NORELY:
					case NOREVERSE:
					case NOROWDEPENDENCIES:
					case NOSCALE:
					case NOSHARD:
					case NOSORT:
					case NOTFOUND:
					case NOVALIDATE:
					case NULLS:
					case OBJECT:
					case OID:
					case OIDINDEX:
					case OLD:
					case ONLY:
					case ONLINE:
					case OPAQUE:
					case OPEN:
					case OPERATIONS:
					case OPTIMAL:
					case ORDINALITY:
					case ORGANIZATION:
					case OUT:
					case OUTER:
					case OVER:
					case OVERFLOW:
					case OVERLAPS:
					case OVERRIDING:
					case PACKAGE:
					case PARALLEL:
					case PARALLEL_ENABLE:
					case PARAMETERS:
					case PARENT:
					case PARTIAL:
					case PARTITION:
					case PARTITIONS:
					case PASSING:
					case PASSWORD:
					case PATH:
					case PCTINCREASE:
					case PCTTHRESHOLD:
					case PCTUSED:
					case PCTVERSION:
					case PERCENTILE_DISC:
					case PERIOD:
					case PIPE:
					case PIPELINED:
					case POLYMORPHIC:
					case PRAGMA:
					case PREBUILT:
					case PRECEDING:
					case PRECISION:
					case PRESERVE:
					case PRIMARY:
					case PRIOR:
					case PRIVATE:
					case PROCEDURE:
					case PROFILE:
					case PUBLIC:
					case PURGE:
					case QUERY:
					case QUOTA:
					case RAISE:
					case RAISE_APPLICATION_ERROR:
					case RANGE:
					case RAW:
					case READ:
					case READS:
					case REBUILD:
					case RECORD:
					case RECYCLE:
					case REDUCED:
					case REF:
					case REFERENCES:
					case REFERENCING:
					case REFRESH:
					case REJECT:
					case RELATIONAL:
					case RELIES_ON:
					case RELY:
					case RENAME:
					case REPLACE:
					case RESTRICT_REFERENCES:
					case RESULT:
					case RESULT_CACHE:
					case RETENTION:
					case RETURNING:
					case REUSE:
					case REVERSE:
					case REWRITE:
					case RIGHT:
					case ROLLUP:
					case ROW:
					case ROWCOUNT:
					case ROWDEPENDENCIES:
					case ROWID:
					case ROWTYPE:
					case SALT:
					case SAMPLE:
					case SAVE:
					case SAVEPOINT:
					case SCALE:
					case SCHEMA:
					case SCN:
					case SCOPE:
					case SEARCH:
					case SECOND:
					case SECUREFILE:
					case SEED:
					case SEGMENT:
					case SELF:
					case SEQUENCE:
					case SERIALIZABLE:
					case SERIALLY_REUSABLE:
					case SERVERERROR:
					case SESSION:
					case SESSIONTIMEZONE:
					case SET:
					case SETS:
					case SETTINGS:
					case SHRINK:
					case SHUTDOWN:
					case SIBLINGS:
					case SIZE:
					case SKIP_:
					case SOME:
					case SORT:
					case SPACE:
					case SPECIFICATION:
					case SPLIT:
					case STARTUP:
					case STATEMENT:
					case STATIC:
					case STATISTICS:
					case STORAGE:
					case STORE:
					case STRING:
					case SHARD:
					case SHARDED:
					case SHARING:
					case SUBMULTISET:
					case SUBPARTITION:
					case SUBPARTITIONS:
					case SUBSTITUTABLE:
					case SUBTYPE:
					case SUPPLEMENTAL:
					case SUSPEND:
					case SYNONYM:
					case SYSTEM:
					case TABLES:
					case TABLESPACE:
					case TEMPLATE:
					case TEMPORARY:
					case THAN:
					case TIME:
					case TIMESTAMP:
					case TIMEZONE_ABBR:
					case TIMEZONE_HOUR:
					case TIMEZONE_MINUTE:
					case TIMEZONE_REGION:
					case TRAILING:
					case TRANSACTION:
					case TRANSLATE:
					case TREAT:
					case TRIM:
					case TRUE:
					case TRUNCATE:
					case TRUSTED:
					case TYPE:
					case UNBOUNDED:
					case UNCONDITIONAL:
					case UNDER:
					case UNLIMITED:
					case UNLOCK:
					case UNUSABLE:
					case UNUSED:
					case USABLE:
					case USAGE:
					case USE:
					case USER:
					case USING:
					case VALIDATE:
					case VALUE:
					case VARCHAR:
					case VARCHAR2:
					case VARRAY:
					case VARRAYS:
					case VARYING:
					case VERSIONS:
					case VIRTUAL:
					case VISIBLE:
					case WAIT:
					case WHEN:
					case WITHIN:
					case WITHOUT:
					case WORK:
					case WRAPPED:
					case WRAPPER:
					case WRITE:
					case XML:
					case XMLNAMESPACES:
					case XMLSCHEMA:
					case XMLTABLE:
					case XMLTYPE:
					case YEAR:
					case ZONE:
					case REGULAR_IDENTIFIER:
						{
						State = 1996;
						simpleIdentifierRegularIdentifier();
						}
						break;
					case QUOTED_IDENTIFIER:
						{
						State = 1997;
						Match(QUOTED_IDENTIFIER);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					} 
				}
				State = 2004;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,37,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier() {
			return GetRuleContext<SimpleIdentifierRegularIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTED_IDENTIFIER() { return GetToken(OracleAntlrParser.QUOTED_IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DbLinkContext dbLink() {
			return GetRuleContext<DbLinkContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public SimpleIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSimpleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSimpleIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public SimpleIdentifierContext simpleIdentifier() {
		SimpleIdentifierContext _localctx = new SimpleIdentifierContext(Context, State);
		EnterRule(_localctx, 78, RULE_simpleIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2007;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
				{
				State = 2005;
				simpleIdentifierRegularIdentifier();
				}
				break;
			case QUOTED_IDENTIFIER:
				{
				State = 2006;
				Match(QUOTED_IDENTIFIER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2010;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,39,Context) ) {
			case 1:
				{
				State = 2009;
				dbLink();
				}
				break;
			}
			State = 2013;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,40,Context) ) {
			case 1:
				{
				State = 2012;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NestedCollectionSimpleIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public NestedCollectionSimpleIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nestedCollectionSimpleIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNestedCollectionSimpleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNestedCollectionSimpleIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public NestedCollectionSimpleIdentifierContext nestedCollectionSimpleIdentifier() {
		NestedCollectionSimpleIdentifierContext _localctx = new NestedCollectionSimpleIdentifierContext(Context, State);
		EnterRule(_localctx, 80, RULE_nestedCollectionSimpleIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2015;
			simpleIdentifierParams();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlainIdentifierAsStringLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainSimpleIdentifierAsStringLiteralContext plainSimpleIdentifierAsStringLiteral() {
			return GetRuleContext<PlainSimpleIdentifierAsStringLiteralContext>(0);
		}
		public PlainIdentifierAsStringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plainIdentifierAsStringLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPlainIdentifierAsStringLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPlainIdentifierAsStringLiteral(this);
		}
	}

	[RuleVersion(0)]
	public PlainIdentifierAsStringLiteralContext plainIdentifierAsStringLiteral() {
		PlainIdentifierAsStringLiteralContext _localctx = new PlainIdentifierAsStringLiteralContext(Context, State);
		EnterRule(_localctx, 82, RULE_plainIdentifierAsStringLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2017;
			plainSimpleIdentifierAsStringLiteral();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceOpaqueFixedContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPAQUE() { return GetToken(OracleAntlrParser.OPAQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIXED() { return GetToken(OracleAntlrParser.FIXED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIBRARY() { return GetToken(OracleAntlrParser.LIBRARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SEMI() { return GetTokens(OracleAntlrParser.SEMI); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI(int i) {
			return GetToken(OracleAntlrParser.SEMI, i);
		}
		public TypeReferenceOpaqueFixedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceOpaqueFixed; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeReferenceOpaqueFixed(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeReferenceOpaqueFixed(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceOpaqueFixedContext typeReferenceOpaqueFixed() {
		TypeReferenceOpaqueFixedContext _localctx = new TypeReferenceOpaqueFixedContext(Context, State);
		EnterRule(_localctx, 84, RULE_typeReferenceOpaqueFixed);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2019;
			Match(OPAQUE);
			State = 2020;
			Match(FIXED);
			State = 2021;
			simpleIdentifierParams();
			State = 2022;
			Match(USING);
			State = 2023;
			Match(LIBRARY);
			State = 2024;
			identifier();
			State = 2028;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,41,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2025;
					_la = TokenStream.LA(1);
					if ( _la <= 0 || (_la==SEMI) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					} 
				}
				State = 2030;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,41,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlainSimpleIdentifierAsStringLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER_STRING_LITERAL() { return GetToken(OracleAntlrParser.CHARACTER_STRING_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public PlainSimpleIdentifierAsStringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plainSimpleIdentifierAsStringLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPlainSimpleIdentifierAsStringLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPlainSimpleIdentifierAsStringLiteral(this);
		}
	}

	[RuleVersion(0)]
	public PlainSimpleIdentifierAsStringLiteralContext plainSimpleIdentifierAsStringLiteral() {
		PlainSimpleIdentifierAsStringLiteralContext _localctx = new PlainSimpleIdentifierAsStringLiteralContext(Context, State);
		EnterRule(_localctx, 86, RULE_plainSimpleIdentifierAsStringLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2031;
			Match(CHARACTER_STRING_LITERAL);
			State = 2033;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,42,Context) ) {
			case 1:
				{
				State = 2032;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleIdentifierParamsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISTINCT() { return GetToken(OracleAntlrParser.DISTINCT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUE() { return GetToken(OracleAntlrParser.UNIQUE, 0); }
		public SimpleIdentifierParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleIdentifierParams; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSimpleIdentifierParams(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSimpleIdentifierParams(this);
		}
	}

	[RuleVersion(0)]
	public SimpleIdentifierParamsContext simpleIdentifierParams() {
		SimpleIdentifierParamsContext _localctx = new SimpleIdentifierParamsContext(Context, State);
		EnterRule(_localctx, 88, RULE_simpleIdentifierParams);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2035;
			Match(LPAREN);
			State = 2037;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==DISTINCT || _la==UNIQUE) {
				{
				State = 2036;
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==DISTINCT || _la==UNIQUE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2040;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLAGG - 513)) | (1L << (XMLCAST - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLQUERY - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (INTEGER_LITERAL - 577)) | (1L << (LPAREN - 577)) | (1L << (PLUS_SIGN - 577)) | (1L << (MINUS_SIGN - 577)) | (1L << (QUESTION_MARK - 577)) | (1L << (ASTERISK - 577)) | (1L << (FLOATING_POINT_LITERAL - 577)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 577)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 577)) | (1L << (BINARY_STRING_LITERAL - 577)) | (1L << (CHARACTER_STRING_LITERAL - 577)) | (1L << (MONEY_LITERAL - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 577)))) != 0)) {
				{
				State = 2039;
				expressionList();
				}
			}

			State = 2042;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LocalSimpleIdentifierWithoutParenthesesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier() {
			return GetRuleContext<SimpleIdentifierRegularIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTED_IDENTIFIER() { return GetToken(OracleAntlrParser.QUOTED_IDENTIFIER, 0); }
		public LocalSimpleIdentifierWithoutParenthesesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_localSimpleIdentifierWithoutParentheses; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLocalSimpleIdentifierWithoutParentheses(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLocalSimpleIdentifierWithoutParentheses(this);
		}
	}

	[RuleVersion(0)]
	public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
		LocalSimpleIdentifierWithoutParenthesesContext _localctx = new LocalSimpleIdentifierWithoutParenthesesContext(Context, State);
		EnterRule(_localctx, 90, RULE_localSimpleIdentifierWithoutParentheses);
		try {
			State = 2046;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2044;
				simpleIdentifierRegularIdentifier();
				}
				break;
			case QUOTED_IDENTIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2045;
				Match(QUOTED_IDENTIFIER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleIdentifierWithoutParenthesesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier() {
			return GetRuleContext<SimpleIdentifierRegularIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTED_IDENTIFIER() { return GetToken(OracleAntlrParser.QUOTED_IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DbLinkContext dbLink() {
			return GetRuleContext<DbLinkContext>(0);
		}
		public SimpleIdentifierWithoutParenthesesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleIdentifierWithoutParentheses; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSimpleIdentifierWithoutParentheses(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSimpleIdentifierWithoutParentheses(this);
		}
	}

	[RuleVersion(0)]
	public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
		SimpleIdentifierWithoutParenthesesContext _localctx = new SimpleIdentifierWithoutParenthesesContext(Context, State);
		EnterRule(_localctx, 92, RULE_simpleIdentifierWithoutParentheses);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2050;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
				{
				State = 2048;
				simpleIdentifierRegularIdentifier();
				}
				break;
			case QUOTED_IDENTIFIER:
				{
				State = 2049;
				Match(QUOTED_IDENTIFIER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2053;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,47,Context) ) {
			case 1:
				{
				State = 2052;
				dbLink();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BindParameterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUESTION_MARK() { return GetToken(OracleAntlrParser.QUESTION_MARK, 0); }
		public BindParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bindParameter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBindParameter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBindParameter(this);
		}
	}

	[RuleVersion(0)]
	public BindParameterContext bindParameter() {
		BindParameterContext _localctx = new BindParameterContext(Context, State);
		EnterRule(_localctx, 94, RULE_bindParameter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2055;
			Match(QUESTION_MARK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceTimestampCaseContext typeReferenceTimestampCase() {
			return GetRuleContext<TypeReferenceTimestampCaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceIntervalCaseContext typeReferenceIntervalCase() {
			return GetRuleContext<TypeReferenceIntervalCaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceCharCaseContext typeReferenceCharCase() {
			return GetRuleContext<TypeReferenceCharCaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceLongAndRawCaseContext typeReferenceLongAndRawCase() {
			return GetRuleContext<TypeReferenceLongAndRawCaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceRefCaseContext typeReferenceRefCase() {
			return GetRuleContext<TypeReferenceRefCaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BooleanLiteralContext[] booleanLiteral() {
			return GetRuleContexts<BooleanLiteralContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BooleanLiteralContext booleanLiteral(int i) {
			return GetRuleContext<BooleanLiteralContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceOpaqueFixedContext typeReferenceOpaqueFixed() {
			return GetRuleContext<TypeReferenceOpaqueFixedContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierDoublePrecisionContext identifierDoublePrecision() {
			return GetRuleContext<IdentifierDoublePrecisionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceAttributesContext typeReferenceAttributes() {
			return GetRuleContext<TypeReferenceAttributesContext>(0);
		}
		public TypeReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReference; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeReference(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeReference(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceContext typeReference() {
		TypeReferenceContext _localctx = new TypeReferenceContext(Context, State);
		EnterRule(_localctx, 96, RULE_typeReference);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2071;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,48,Context) ) {
			case 1:
				{
				State = 2057;
				typeReferenceTimestampCase();
				}
				break;
			case 2:
				{
				State = 2058;
				typeReferenceIntervalCase();
				}
				break;
			case 3:
				{
				State = 2059;
				typeReferenceCharCase();
				}
				break;
			case 4:
				{
				State = 2060;
				typeReferenceLongAndRawCase();
				}
				break;
			case 5:
				{
				State = 2061;
				typeReferenceRefCase();
				}
				break;
			case 6:
				{
				State = 2062;
				Match(LPAREN);
				State = 2063;
				booleanLiteral();
				State = 2064;
				Match(COMMA);
				State = 2065;
				booleanLiteral();
				State = 2066;
				Match(RPAREN);
				}
				break;
			case 7:
				{
				State = 2068;
				typeReferenceOpaqueFixed();
				}
				break;
			case 8:
				{
				State = 2069;
				identifierDoublePrecision();
				}
				break;
			case 9:
				{
				State = 2070;
				identifier();
				}
				break;
			}
			State = 2074;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,49,Context) ) {
			case 1:
				{
				State = 2073;
				typeReferenceAttributes();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierTimestampContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMESTAMP() { return GetToken(OracleAntlrParser.TIMESTAMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierTimestampContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierTimestamp; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierTimestamp(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierTimestamp(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierTimestampContext identifierTimestamp() {
		IdentifierTimestampContext _localctx = new IdentifierTimestampContext(Context, State);
		EnterRule(_localctx, 98, RULE_identifierTimestamp);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2076;
			Match(TIMESTAMP);
			State = 2078;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,50,Context) ) {
			case 1:
				{
				State = 2077;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierTimeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIME() { return GetToken(OracleAntlrParser.TIME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierTimeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierTime; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierTime(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierTime(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierTimeContext identifierTime() {
		IdentifierTimeContext _localctx = new IdentifierTimeContext(Context, State);
		EnterRule(_localctx, 100, RULE_identifierTime);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2080;
			Match(TIME);
			State = 2082;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,51,Context) ) {
			case 1:
				{
				State = 2081;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierWithContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierWithContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierWith; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierWith(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierWith(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierWithContext identifierWith() {
		IdentifierWithContext _localctx = new IdentifierWithContext(Context, State);
		EnterRule(_localctx, 102, RULE_identifierWith);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2084;
			Match(WITH);
			State = 2086;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 2085;
				simpleIdentifierParams();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierLocalContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(OracleAntlrParser.LOCAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierLocalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierLocal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierLocal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierLocal(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierLocalContext identifierLocal() {
		IdentifierLocalContext _localctx = new IdentifierLocalContext(Context, State);
		EnterRule(_localctx, 104, RULE_identifierLocal);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2088;
			Match(LOCAL);
			State = 2090;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 2089;
				simpleIdentifierParams();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierZoneContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ZONE() { return GetToken(OracleAntlrParser.ZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierZoneContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierZone; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierZone(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierZone(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierZoneContext identifierZone() {
		IdentifierZoneContext _localctx = new IdentifierZoneContext(Context, State);
		EnterRule(_localctx, 106, RULE_identifierZone);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2092;
			Match(ZONE);
			State = 2094;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,54,Context) ) {
			case 1:
				{
				State = 2093;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierIntervalContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERVAL() { return GetToken(OracleAntlrParser.INTERVAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierIntervalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierInterval; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierInterval(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierInterval(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierIntervalContext identifierInterval() {
		IdentifierIntervalContext _localctx = new IdentifierIntervalContext(Context, State);
		EnterRule(_localctx, 108, RULE_identifierInterval);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2096;
			Match(INTERVAL);
			State = 2098;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 2097;
				simpleIdentifierParams();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierToContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(OracleAntlrParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierToContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierTo; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierTo(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierTo(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierToContext identifierTo() {
		IdentifierToContext _localctx = new IdentifierToContext(Context, State);
		EnterRule(_localctx, 110, RULE_identifierTo);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2100;
			Match(TO);
			State = 2102;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 2101;
				simpleIdentifierParams();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierLongContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LONG() { return GetToken(OracleAntlrParser.LONG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierLongContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierLong; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierLong(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierLong(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierLongContext identifierLong() {
		IdentifierLongContext _localctx = new IdentifierLongContext(Context, State);
		EnterRule(_localctx, 112, RULE_identifierLong);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2104;
			Match(LONG);
			State = 2106;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,57,Context) ) {
			case 1:
				{
				State = 2105;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierRawContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RAW() { return GetToken(OracleAntlrParser.RAW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierRawContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierRaw; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierRaw(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierRaw(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierRawContext identifierRaw() {
		IdentifierRawContext _localctx = new IdentifierRawContext(Context, State);
		EnterRule(_localctx, 114, RULE_identifierRaw);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2108;
			Match(RAW);
			State = 2110;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,58,Context) ) {
			case 1:
				{
				State = 2109;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierLongRawContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LONG() { return GetToken(OracleAntlrParser.LONG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierRawContext identifierRaw() {
			return GetRuleContext<IdentifierRawContext>(0);
		}
		public IdentifierLongRawContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierLongRaw; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierLongRaw(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierLongRaw(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierLongRawContext identifierLongRaw() {
		IdentifierLongRawContext _localctx = new IdentifierLongRawContext(Context, State);
		EnterRule(_localctx, 116, RULE_identifierLongRaw);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2112;
			Match(LONG);
			State = 2113;
			identifierRaw();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierDoublePrecisionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOUBLE() { return GetToken(OracleAntlrParser.DOUBLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRECISION() { return GetToken(OracleAntlrParser.PRECISION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierDoublePrecisionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierDoublePrecision; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierDoublePrecision(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierDoublePrecision(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierDoublePrecisionContext identifierDoublePrecision() {
		IdentifierDoublePrecisionContext _localctx = new IdentifierDoublePrecisionContext(Context, State);
		EnterRule(_localctx, 118, RULE_identifierDoublePrecision);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2115;
			Match(DOUBLE);
			State = 2116;
			Match(PRECISION);
			State = 2118;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,59,Context) ) {
			case 1:
				{
				State = 2117;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierCharacterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAR() { return GetToken(OracleAntlrParser.CHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER() { return GetToken(OracleAntlrParser.CHARACTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARYING() { return GetToken(OracleAntlrParser.VARYING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharIdentifierParamsContext charIdentifierParams() {
			return GetRuleContext<CharIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollationSpecClauseContext collationSpecClause() {
			return GetRuleContext<CollationSpecClauseContext>(0);
		}
		public IdentifierCharacterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierCharacter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierCharacter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierCharacter(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierCharacterContext identifierCharacter() {
		IdentifierCharacterContext _localctx = new IdentifierCharacterContext(Context, State);
		EnterRule(_localctx, 120, RULE_identifierCharacter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2120;
			_la = TokenStream.LA(1);
			if ( !(_la==CHAR || _la==CHARACTER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2122;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,60,Context) ) {
			case 1:
				{
				State = 2121;
				Match(VARYING);
				}
				break;
			}
			State = 2125;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,61,Context) ) {
			case 1:
				{
				State = 2124;
				charIdentifierParams();
				}
				break;
			}
			State = 2128;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,62,Context) ) {
			case 1:
				{
				State = 2127;
				collationSpecClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierNationalCharacterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NATIONAL() { return GetToken(OracleAntlrParser.NATIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAR() { return GetToken(OracleAntlrParser.CHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER() { return GetToken(OracleAntlrParser.CHARACTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARYING() { return GetToken(OracleAntlrParser.VARYING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollationSpecClauseContext collationSpecClause() {
			return GetRuleContext<CollationSpecClauseContext>(0);
		}
		public IdentifierNationalCharacterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierNationalCharacter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierNationalCharacter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierNationalCharacter(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierNationalCharacterContext identifierNationalCharacter() {
		IdentifierNationalCharacterContext _localctx = new IdentifierNationalCharacterContext(Context, State);
		EnterRule(_localctx, 122, RULE_identifierNationalCharacter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2130;
			Match(NATIONAL);
			State = 2131;
			_la = TokenStream.LA(1);
			if ( !(_la==CHAR || _la==CHARACTER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2133;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,63,Context) ) {
			case 1:
				{
				State = 2132;
				Match(VARYING);
				}
				break;
			}
			State = 2136;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,64,Context) ) {
			case 1:
				{
				State = 2135;
				simpleIdentifierParams();
				}
				break;
			}
			State = 2139;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,65,Context) ) {
			case 1:
				{
				State = 2138;
				collationSpecClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierNCharContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NCHAR() { return GetToken(OracleAntlrParser.NCHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARYING() { return GetToken(OracleAntlrParser.VARYING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollationSpecClauseContext collationSpecClause() {
			return GetRuleContext<CollationSpecClauseContext>(0);
		}
		public IdentifierNCharContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierNChar; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierNChar(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierNChar(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierNCharContext identifierNChar() {
		IdentifierNCharContext _localctx = new IdentifierNCharContext(Context, State);
		EnterRule(_localctx, 124, RULE_identifierNChar);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2141;
			Match(NCHAR);
			State = 2143;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,66,Context) ) {
			case 1:
				{
				State = 2142;
				Match(VARYING);
				}
				break;
			}
			State = 2146;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,67,Context) ) {
			case 1:
				{
				State = 2145;
				simpleIdentifierParams();
				}
				break;
			}
			State = 2149;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,68,Context) ) {
			case 1:
				{
				State = 2148;
				collationSpecClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierNVarChar2Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NVARCHAR2() { return GetToken(OracleAntlrParser.NVARCHAR2, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollationSpecClauseContext collationSpecClause() {
			return GetRuleContext<CollationSpecClauseContext>(0);
		}
		public IdentifierNVarChar2Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierNVarChar2; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierNVarChar2(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierNVarChar2(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierNVarChar2Context identifierNVarChar2() {
		IdentifierNVarChar2Context _localctx = new IdentifierNVarChar2Context(Context, State);
		EnterRule(_localctx, 126, RULE_identifierNVarChar2);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2151;
			Match(NVARCHAR2);
			State = 2153;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,69,Context) ) {
			case 1:
				{
				State = 2152;
				simpleIdentifierParams();
				}
				break;
			}
			State = 2156;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,70,Context) ) {
			case 1:
				{
				State = 2155;
				collationSpecClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierVarCharContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARCHAR() { return GetToken(OracleAntlrParser.VARCHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharIdentifierParamsContext charIdentifierParams() {
			return GetRuleContext<CharIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollationSpecClauseContext collationSpecClause() {
			return GetRuleContext<CollationSpecClauseContext>(0);
		}
		public IdentifierVarCharContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierVarChar; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierVarChar(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierVarChar(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierVarCharContext identifierVarChar() {
		IdentifierVarCharContext _localctx = new IdentifierVarCharContext(Context, State);
		EnterRule(_localctx, 128, RULE_identifierVarChar);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2158;
			Match(VARCHAR);
			State = 2160;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,71,Context) ) {
			case 1:
				{
				State = 2159;
				charIdentifierParams();
				}
				break;
			}
			State = 2163;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,72,Context) ) {
			case 1:
				{
				State = 2162;
				collationSpecClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierVarChar2Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARCHAR2() { return GetToken(OracleAntlrParser.VARCHAR2, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharIdentifierParamsContext charIdentifierParams() {
			return GetRuleContext<CharIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollationSpecClauseContext collationSpecClause() {
			return GetRuleContext<CollationSpecClauseContext>(0);
		}
		public IdentifierVarChar2Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierVarChar2; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierVarChar2(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierVarChar2(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierVarChar2Context identifierVarChar2() {
		IdentifierVarChar2Context _localctx = new IdentifierVarChar2Context(Context, State);
		EnterRule(_localctx, 130, RULE_identifierVarChar2);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2165;
			Match(VARCHAR2);
			State = 2167;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,73,Context) ) {
			case 1:
				{
				State = 2166;
				charIdentifierParams();
				}
				break;
			}
			State = 2170;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,74,Context) ) {
			case 1:
				{
				State = 2169;
				collationSpecClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierStringContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING() { return GetToken(OracleAntlrParser.STRING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharIdentifierParamsContext charIdentifierParams() {
			return GetRuleContext<CharIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollationSpecClauseContext collationSpecClause() {
			return GetRuleContext<CollationSpecClauseContext>(0);
		}
		public IdentifierStringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierString; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierString(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierStringContext identifierString() {
		IdentifierStringContext _localctx = new IdentifierStringContext(Context, State);
		EnterRule(_localctx, 132, RULE_identifierString);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2172;
			Match(STRING);
			State = 2174;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,75,Context) ) {
			case 1:
				{
				State = 2173;
				charIdentifierParams();
				}
				break;
			}
			State = 2177;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,76,Context) ) {
			case 1:
				{
				State = 2176;
				collationSpecClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CharIdentifierParamsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BYTE() { return GetToken(OracleAntlrParser.BYTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAR() { return GetToken(OracleAntlrParser.CHAR, 0); }
		public CharIdentifierParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_charIdentifierParams; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCharIdentifierParams(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCharIdentifierParams(this);
		}
	}

	[RuleVersion(0)]
	public CharIdentifierParamsContext charIdentifierParams() {
		CharIdentifierParamsContext _localctx = new CharIdentifierParamsContext(Context, State);
		EnterRule(_localctx, 134, RULE_charIdentifierParams);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2179;
			Match(LPAREN);
			State = 2180;
			fullExpression();
			State = 2182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BYTE || _la==CHAR) {
				{
				State = 2181;
				_la = TokenStream.LA(1);
				if ( !(_la==BYTE || _la==CHAR) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2184;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceTimestampCaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierTimestampContext identifierTimestamp() {
			return GetRuleContext<IdentifierTimestampContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierTimeContext[] identifierTime() {
			return GetRuleContexts<IdentifierTimeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierTimeContext identifierTime(int i) {
			return GetRuleContext<IdentifierTimeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierWithContext identifierWith() {
			return GetRuleContext<IdentifierWithContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierZoneContext identifierZone() {
			return GetRuleContext<IdentifierZoneContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierLocalContext identifierLocal() {
			return GetRuleContext<IdentifierLocalContext>(0);
		}
		public TypeReferenceTimestampCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceTimestampCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeReferenceTimestampCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeReferenceTimestampCase(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceTimestampCaseContext typeReferenceTimestampCase() {
		TypeReferenceTimestampCaseContext _localctx = new TypeReferenceTimestampCaseContext(Context, State);
		EnterRule(_localctx, 136, RULE_typeReferenceTimestampCase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2188;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TIMESTAMP:
				{
				State = 2186;
				identifierTimestamp();
				}
				break;
			case TIME:
				{
				State = 2187;
				identifierTime();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,80,Context) ) {
			case 1:
				{
				State = 2190;
				identifierWith();
				State = 2192;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOCAL) {
					{
					State = 2191;
					identifierLocal();
					}
				}

				State = 2194;
				identifierTime();
				State = 2195;
				identifierZone();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceIntervalCaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierIntervalContext identifierInterval() {
			return GetRuleContext<IdentifierIntervalContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierToContext identifierTo() {
			return GetRuleContext<IdentifierToContext>(0);
		}
		public TypeReferenceIntervalCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceIntervalCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeReferenceIntervalCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeReferenceIntervalCase(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceIntervalCaseContext typeReferenceIntervalCase() {
		TypeReferenceIntervalCaseContext _localctx = new TypeReferenceIntervalCaseContext(Context, State);
		EnterRule(_localctx, 138, RULE_typeReferenceIntervalCase);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2199;
			identifierInterval();
			State = 2200;
			identifier();
			State = 2201;
			identifierTo();
			State = 2202;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceCharCaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierCharacterContext identifierCharacter() {
			return GetRuleContext<IdentifierCharacterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierVarCharContext identifierVarChar() {
			return GetRuleContext<IdentifierVarCharContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierVarChar2Context identifierVarChar2() {
			return GetRuleContext<IdentifierVarChar2Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierNCharContext identifierNChar() {
			return GetRuleContext<IdentifierNCharContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierNVarChar2Context identifierNVarChar2() {
			return GetRuleContext<IdentifierNVarChar2Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierStringContext identifierString() {
			return GetRuleContext<IdentifierStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierNationalCharacterContext identifierNationalCharacter() {
			return GetRuleContext<IdentifierNationalCharacterContext>(0);
		}
		public TypeReferenceCharCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceCharCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeReferenceCharCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeReferenceCharCase(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceCharCaseContext typeReferenceCharCase() {
		TypeReferenceCharCaseContext _localctx = new TypeReferenceCharCaseContext(Context, State);
		EnterRule(_localctx, 140, RULE_typeReferenceCharCase);
		try {
			State = 2211;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CHAR:
			case CHARACTER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2204;
				identifierCharacter();
				}
				break;
			case VARCHAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2205;
				identifierVarChar();
				}
				break;
			case VARCHAR2:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2206;
				identifierVarChar2();
				}
				break;
			case NCHAR:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2207;
				identifierNChar();
				}
				break;
			case NVARCHAR2:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2208;
				identifierNVarChar2();
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2209;
				identifierString();
				}
				break;
			case NATIONAL:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2210;
				identifierNationalCharacter();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollationSpecClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLLATE() { return GetToken(OracleAntlrParser.COLLATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public CollationSpecClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collationSpecClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCollationSpecClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCollationSpecClause(this);
		}
	}

	[RuleVersion(0)]
	public CollationSpecClauseContext collationSpecClause() {
		CollationSpecClauseContext _localctx = new CollationSpecClauseContext(Context, State);
		EnterRule(_localctx, 142, RULE_collationSpecClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2213;
			Match(COLLATE);
			State = 2214;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceLongAndRawCaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierRawContext identifierRaw() {
			return GetRuleContext<IdentifierRawContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierLongRawContext identifierLongRaw() {
			return GetRuleContext<IdentifierLongRawContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierLongContext identifierLong() {
			return GetRuleContext<IdentifierLongContext>(0);
		}
		public TypeReferenceLongAndRawCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceLongAndRawCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeReferenceLongAndRawCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeReferenceLongAndRawCase(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceLongAndRawCaseContext typeReferenceLongAndRawCase() {
		TypeReferenceLongAndRawCaseContext _localctx = new TypeReferenceLongAndRawCaseContext(Context, State);
		EnterRule(_localctx, 144, RULE_typeReferenceLongAndRawCase);
		try {
			State = 2219;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,82,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2216;
				identifierRaw();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2217;
				identifierLongRaw();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2218;
				identifierLong();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceAttributesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceCharacterSetAttributeContext typeReferenceCharacterSetAttribute() {
			return GetRuleContext<TypeReferenceCharacterSetAttributeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceRangeAttributeContext typeReferenceRangeAttribute() {
			return GetRuleContext<TypeReferenceRangeAttributeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceModifierAttributeContext typeReferenceModifierAttribute() {
			return GetRuleContext<TypeReferenceModifierAttributeContext>(0);
		}
		public TypeReferenceAttributesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceAttributes; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeReferenceAttributes(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeReferenceAttributes(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceAttributesContext typeReferenceAttributes() {
		TypeReferenceAttributesContext _localctx = new TypeReferenceAttributesContext(Context, State);
		EnterRule(_localctx, 146, RULE_typeReferenceAttributes);
		try {
			State = 2224;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CHARACTER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2221;
				typeReferenceCharacterSetAttribute();
				}
				break;
			case RANGE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2222;
				typeReferenceRangeAttribute();
				}
				break;
			case PERCENT_SIGN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2223;
				typeReferenceModifierAttribute();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceCharacterSetAttributeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER() { return GetToken(OracleAntlrParser.CHARACTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceCharacterSetModifierContext typeReferenceCharacterSetModifier() {
			return GetRuleContext<TypeReferenceCharacterSetModifierContext>(0);
		}
		public TypeReferenceCharacterSetAttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceCharacterSetAttribute; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeReferenceCharacterSetAttribute(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeReferenceCharacterSetAttribute(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceCharacterSetAttributeContext typeReferenceCharacterSetAttribute() {
		TypeReferenceCharacterSetAttributeContext _localctx = new TypeReferenceCharacterSetAttributeContext(Context, State);
		EnterRule(_localctx, 148, RULE_typeReferenceCharacterSetAttribute);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2226;
			Match(CHARACTER);
			State = 2227;
			Match(SET);
			State = 2228;
			fullExpression();
			State = 2230;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,84,Context) ) {
			case 1:
				{
				State = 2229;
				typeReferenceCharacterSetModifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceCharacterSetModifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT_SIGN() { return GetToken(OracleAntlrParser.PERCENT_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARSET() { return GetToken(OracleAntlrParser.CHARSET, 0); }
		public TypeReferenceCharacterSetModifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceCharacterSetModifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeReferenceCharacterSetModifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeReferenceCharacterSetModifier(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceCharacterSetModifierContext typeReferenceCharacterSetModifier() {
		TypeReferenceCharacterSetModifierContext _localctx = new TypeReferenceCharacterSetModifierContext(Context, State);
		EnterRule(_localctx, 150, RULE_typeReferenceCharacterSetModifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2232;
			Match(PERCENT_SIGN);
			State = 2233;
			Match(CHARSET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceRangeAttributeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(OracleAntlrParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterDoubleDotContext delimiterDoubleDot() {
			return GetRuleContext<DelimiterDoubleDotContext>(0);
		}
		public TypeReferenceRangeAttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceRangeAttribute; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeReferenceRangeAttribute(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeReferenceRangeAttribute(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceRangeAttributeContext typeReferenceRangeAttribute() {
		TypeReferenceRangeAttributeContext _localctx = new TypeReferenceRangeAttributeContext(Context, State);
		EnterRule(_localctx, 152, RULE_typeReferenceRangeAttribute);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2235;
			Match(RANGE);
			State = 2236;
			fullExpression();
			State = 2237;
			delimiterDoubleDot();
			State = 2238;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterDoubleDotContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOUBLE_DOT_OPERATOR() { return GetToken(OracleAntlrParser.DOUBLE_DOT_OPERATOR, 0); }
		public DelimiterDoubleDotContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterDoubleDot; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterDoubleDot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterDoubleDot(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterDoubleDotContext delimiterDoubleDot() {
		DelimiterDoubleDotContext _localctx = new DelimiterDoubleDotContext(Context, State);
		EnterRule(_localctx, 154, RULE_delimiterDoubleDot);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2240;
			Match(DOUBLE_DOT_OPERATOR);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceModifierAttributeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT_SIGN() { return GetToken(OracleAntlrParser.PERCENT_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWTYPE() { return GetToken(OracleAntlrParser.ROWTYPE, 0); }
		public TypeReferenceModifierAttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceModifierAttribute; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeReferenceModifierAttribute(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeReferenceModifierAttribute(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceModifierAttributeContext typeReferenceModifierAttribute() {
		TypeReferenceModifierAttributeContext _localctx = new TypeReferenceModifierAttributeContext(Context, State);
		EnterRule(_localctx, 156, RULE_typeReferenceModifierAttribute);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2242;
			Match(PERCENT_SIGN);
			State = 2243;
			_la = TokenStream.LA(1);
			if ( !(_la==ROWTYPE || _la==TYPE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceRefCaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REF() { return GetToken(OracleAntlrParser.REF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public TypeReferenceRefCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceRefCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeReferenceRefCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeReferenceRefCase(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceRefCaseContext typeReferenceRefCase() {
		TypeReferenceRefCaseContext _localctx = new TypeReferenceRefCaseContext(Context, State);
		EnterRule(_localctx, 158, RULE_typeReferenceRefCase);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2245;
			Match(REF);
			State = 2246;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullOrConditionContext fullOrCondition() {
			return GetRuleContext<FullOrConditionContext>(0);
		}
		public FullExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFullExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFullExpression(this);
		}
	}

	[RuleVersion(0)]
	public FullExpressionContext fullExpression() {
		FullExpressionContext _localctx = new FullExpressionContext(Context, State);
		EnterRule(_localctx, 160, RULE_fullExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2248;
			fullOrCondition();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullOrConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullAndConditionContext[] fullAndCondition() {
			return GetRuleContexts<FullAndConditionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullAndConditionContext fullAndCondition(int i) {
			return GetRuleContext<FullAndConditionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] OR() { return GetTokens(OracleAntlrParser.OR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR(int i) {
			return GetToken(OracleAntlrParser.OR, i);
		}
		public FullOrConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullOrCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFullOrCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFullOrCondition(this);
		}
	}

	[RuleVersion(0)]
	public FullOrConditionContext fullOrCondition() {
		FullOrConditionContext _localctx = new FullOrConditionContext(Context, State);
		EnterRule(_localctx, 162, RULE_fullOrCondition);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2250;
			fullAndCondition();
			State = 2255;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,85,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2251;
					Match(OR);
					State = 2252;
					fullAndCondition();
					}
					} 
				}
				State = 2257;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,85,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullAndConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullUnaryConditionContext[] fullUnaryCondition() {
			return GetRuleContexts<FullUnaryConditionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullUnaryConditionContext fullUnaryCondition(int i) {
			return GetRuleContext<FullUnaryConditionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] AND() { return GetTokens(OracleAntlrParser.AND); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND(int i) {
			return GetToken(OracleAntlrParser.AND, i);
		}
		public FullAndConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullAndCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFullAndCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFullAndCondition(this);
		}
	}

	[RuleVersion(0)]
	public FullAndConditionContext fullAndCondition() {
		FullAndConditionContext _localctx = new FullAndConditionContext(Context, State);
		EnterRule(_localctx, 164, RULE_fullAndCondition);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2258;
			fullUnaryCondition();
			State = 2263;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,86,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2259;
					Match(AND);
					State = 2260;
					fullUnaryCondition();
					}
					} 
				}
				State = 2265;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,86,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullUnaryConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullAtomicConditionContext fullAtomicCondition() {
			return GetRuleContext<FullAtomicConditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullAtomicCondition1Context fullAtomicCondition1() {
			return GetRuleContext<FullAtomicCondition1Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public FullUnaryConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullUnaryCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFullUnaryCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFullUnaryCondition(this);
		}
	}

	[RuleVersion(0)]
	public FullUnaryConditionContext fullUnaryCondition() {
		FullUnaryConditionContext _localctx = new FullUnaryConditionContext(Context, State);
		EnterRule(_localctx, 166, RULE_fullUnaryCondition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2267;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 2266;
				Match(NOT);
				}
			}

			State = 2271;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,88,Context) ) {
			case 1:
				{
				State = 2269;
				fullAtomicCondition();
				}
				break;
			case 2:
				{
				State = 2270;
				fullAtomicCondition1();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullAtomicConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterCurrentOfContext delimiterCurrentOf() {
			return GetRuleContext<DelimiterCurrentOfContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterExistsContext delimiterExists() {
			return GetRuleContext<DelimiterExistsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiColumnConditionContext multiColumnCondition() {
			return GetRuleContext<MultiColumnConditionContext>(0);
		}
		public FullAtomicConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullAtomicCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFullAtomicCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFullAtomicCondition(this);
		}
	}

	[RuleVersion(0)]
	public FullAtomicConditionContext fullAtomicCondition() {
		FullAtomicConditionContext _localctx = new FullAtomicConditionContext(Context, State);
		EnterRule(_localctx, 168, RULE_fullAtomicCondition);
		try {
			State = 2280;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2273;
				delimiterCurrentOf();
				State = 2274;
				identifier();
				}
				break;
			case EXISTS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2276;
				delimiterExists();
				State = 2277;
				flattenedQuery();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2279;
				multiColumnCondition();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterCurrentOfContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(OracleAntlrParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		public DelimiterCurrentOfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterCurrentOf; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterCurrentOf(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterCurrentOf(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterCurrentOfContext delimiterCurrentOf() {
		DelimiterCurrentOfContext _localctx = new DelimiterCurrentOfContext(Context, State);
		EnterRule(_localctx, 170, RULE_delimiterCurrentOf);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2282;
			Match(CURRENT);
			State = 2283;
			Match(OF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterExistsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(OracleAntlrParser.EXISTS, 0); }
		public DelimiterExistsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterExists; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterExists(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterExists(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterExistsContext delimiterExists() {
		DelimiterExistsContext _localctx = new DelimiterExistsContext(Context, State);
		EnterRule(_localctx, 172, RULE_delimiterExists);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2285;
			Match(EXISTS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullAtomicCondition1Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext[] pureExpression() {
			return GetRuleContexts<PureExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression(int i) {
			return GetRuleContext<PureExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonPairOperatorContext comparisonPairOperator() {
			return GetRuleContext<ComparisonPairOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollectionsComparisonContext collectionsComparison() {
			return GetRuleContext<CollectionsComparisonContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypesComparisonContext typesComparison() {
			return GetRuleContext<TypesComparisonContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BetweenOperatorContext betweenOperator() {
			return GetRuleContext<BetweenOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BetweenAndOperatorContext betweenAndOperator() {
			return GetRuleContext<BetweenAndOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterIsContext delimiterIs() {
			return GetRuleContext<DelimiterIsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterNullContext delimiterNull() {
			return GetRuleContext<DelimiterNullContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LikeOperatorContext likeOperator() {
			return GetRuleContext<LikeOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterInContext delimiterIn() {
			return GetRuleContext<DelimiterInContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InPureExpressionContext inPureExpression() {
			return GetRuleContext<InPureExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterLParenContext delimiterLParen() {
			return GetRuleContext<DelimiterLParenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterRParenContext delimiterRParen() {
			return GetRuleContext<DelimiterRParenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterNotContext delimiterNot() {
			return GetRuleContext<DelimiterNotContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EscapeClauseContext escapeClause() {
			return GetRuleContext<EscapeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterAnyContext delimiterAny() {
			return GetRuleContext<DelimiterAnyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterSomeContext delimiterSome() {
			return GetRuleContext<DelimiterSomeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterAllContext delimiterAll() {
			return GetRuleContext<DelimiterAllContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonListContext comparisonList() {
			return GetRuleContext<ComparisonListContext>(0);
		}
		public FullAtomicCondition1Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullAtomicCondition1; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFullAtomicCondition1(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFullAtomicCondition1(this);
		}
	}

	[RuleVersion(0)]
	public FullAtomicCondition1Context fullAtomicCondition1() {
		FullAtomicCondition1Context _localctx = new FullAtomicCondition1Context(Context, State);
		EnterRule(_localctx, 174, RULE_fullAtomicCondition1);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2287;
			pureExpression();
			State = 2337;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,99,Context) ) {
			case 1:
				{
				State = 2288;
				comparisonPairOperator();
				State = 2299;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,92,Context) ) {
				case 1:
					{
					State = 2292;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ANY:
						{
						State = 2289;
						delimiterAny();
						}
						break;
					case SOME:
						{
						State = 2290;
						delimiterSome();
						}
						break;
					case ALL:
						{
						State = 2291;
						delimiterAll();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2296;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,91,Context) ) {
					case 1:
						{
						State = 2294;
						flattenedQuery();
						}
						break;
					case 2:
						{
						State = 2295;
						comparisonList();
						}
						break;
					}
					}
					break;
				case 2:
					{
					State = 2298;
					pureExpression();
					}
					break;
				}
				}
				break;
			case 2:
				{
				State = 2301;
				collectionsComparison();
				}
				break;
			case 3:
				{
				State = 2302;
				typesComparison();
				}
				break;
			case 4:
				{
				State = 2304;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 2303;
					delimiterNot();
					}
				}

				State = 2306;
				betweenOperator();
				State = 2307;
				pureExpression();
				State = 2308;
				betweenAndOperator();
				State = 2309;
				pureExpression();
				}
				break;
			case 5:
				{
				State = 2311;
				delimiterIs();
				State = 2313;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 2312;
					delimiterNot();
					}
				}

				State = 2315;
				delimiterNull();
				}
				break;
			case 6:
				{
				State = 2318;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 2317;
					delimiterNot();
					}
				}

				State = 2320;
				likeOperator();
				State = 2321;
				pureExpression();
				State = 2323;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,96,Context) ) {
				case 1:
					{
					State = 2322;
					escapeClause();
					}
					break;
				}
				}
				break;
			case 7:
				{
				State = 2326;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 2325;
					delimiterNot();
					}
				}

				State = 2328;
				delimiterIn();
				State = 2335;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,98,Context) ) {
				case 1:
					{
					State = 2329;
					flattenedQuery();
					}
					break;
				case 2:
					{
					State = 2330;
					inPureExpression();
					}
					break;
				case 3:
					{
					State = 2331;
					delimiterLParen();
					State = 2332;
					expressionList();
					State = 2333;
					delimiterRParen();
					}
					break;
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InPureExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		public InPureExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inPureExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterInPureExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitInPureExpression(this);
		}
	}

	[RuleVersion(0)]
	public InPureExpressionContext inPureExpression() {
		InPureExpressionContext _localctx = new InPureExpressionContext(Context, State);
		EnterRule(_localctx, 176, RULE_inPureExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2339;
			pureExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterAnyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY() { return GetToken(OracleAntlrParser.ANY, 0); }
		public DelimiterAnyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterAny; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterAny(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterAny(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterAnyContext delimiterAny() {
		DelimiterAnyContext _localctx = new DelimiterAnyContext(Context, State);
		EnterRule(_localctx, 178, RULE_delimiterAny);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2341;
			Match(ANY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterSomeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SOME() { return GetToken(OracleAntlrParser.SOME, 0); }
		public DelimiterSomeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterSome; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterSome(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterSome(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterSomeContext delimiterSome() {
		DelimiterSomeContext _localctx = new DelimiterSomeContext(Context, State);
		EnterRule(_localctx, 180, RULE_delimiterSome);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2343;
			Match(SOME);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterAllContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		public DelimiterAllContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterAll; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterAll(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterAll(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterAllContext delimiterAll() {
		DelimiterAllContext _localctx = new DelimiterAllContext(Context, State);
		EnterRule(_localctx, 182, RULE_delimiterAll);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2345;
			Match(ALL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterNotContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public DelimiterNotContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterNot; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterNot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterNot(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterNotContext delimiterNot() {
		DelimiterNotContext _localctx = new DelimiterNotContext(Context, State);
		EnterRule(_localctx, 184, RULE_delimiterNot);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2347;
			Match(NOT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterIsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		public DelimiterIsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterIs; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterIs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterIs(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterIsContext delimiterIs() {
		DelimiterIsContext _localctx = new DelimiterIsContext(Context, State);
		EnterRule(_localctx, 186, RULE_delimiterIs);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2349;
			Match(IS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterInContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		public DelimiterInContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterIn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterIn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterIn(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterInContext delimiterIn() {
		DelimiterInContext _localctx = new DelimiterInContext(Context, State);
		EnterRule(_localctx, 188, RULE_delimiterIn);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2351;
			Match(IN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterLParenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		public DelimiterLParenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterLParen; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterLParen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterLParen(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterLParenContext delimiterLParen() {
		DelimiterLParenContext _localctx = new DelimiterLParenContext(Context, State);
		EnterRule(_localctx, 190, RULE_delimiterLParen);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2353;
			Match(LPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterRParenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public DelimiterRParenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterRParen; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterRParen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterRParen(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterRParenContext delimiterRParen() {
		DelimiterRParenContext _localctx = new DelimiterRParenContext(Context, State);
		EnterRule(_localctx, 192, RULE_delimiterRParen);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2355;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypesComparisonContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeComparisonNamesContext typeComparisonNames() {
			return GetRuleContext<TypeComparisonNamesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		public TypesComparisonContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typesComparison; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypesComparison(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypesComparison(this);
		}
	}

	[RuleVersion(0)]
	public TypesComparisonContext typesComparison() {
		TypesComparisonContext _localctx = new TypesComparisonContext(Context, State);
		EnterRule(_localctx, 194, RULE_typesComparison);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2357;
			Match(IS);
			State = 2359;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 2358;
				Match(NOT);
				}
			}

			State = 2361;
			Match(OF);
			State = 2363;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TYPE) {
				{
				State = 2362;
				Match(TYPE);
				}
			}

			State = 2365;
			typeComparisonNames();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeComparisonNamesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext[] plainIdentifier() {
			return GetRuleContexts<PlainIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier(int i) {
			return GetRuleContext<PlainIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLY() { return GetToken(OracleAntlrParser.ONLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public TypeComparisonNamesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeComparisonNames; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeComparisonNames(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeComparisonNames(this);
		}
	}

	[RuleVersion(0)]
	public TypeComparisonNamesContext typeComparisonNames() {
		TypeComparisonNamesContext _localctx = new TypeComparisonNamesContext(Context, State);
		EnterRule(_localctx, 196, RULE_typeComparisonNames);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2367;
			Match(LPAREN);
			State = 2369;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,102,Context) ) {
			case 1:
				{
				State = 2368;
				Match(ONLY);
				}
				break;
			}
			State = 2371;
			plainIdentifier();
			State = 2376;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2372;
				Match(COMMA);
				State = 2373;
				plainIdentifier();
				}
				}
				State = 2378;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2379;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PureExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BitwiseLevelExpressionContext bitwiseLevelExpression() {
			return GetRuleContext<BitwiseLevelExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AsteriskContext asterisk() {
			return GetRuleContext<AsteriskContext>(0);
		}
		public PureExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pureExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPureExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPureExpression(this);
		}
	}

	[RuleVersion(0)]
	public PureExpressionContext pureExpression() {
		PureExpressionContext _localctx = new PureExpressionContext(Context, State);
		EnterRule(_localctx, 198, RULE_pureExpression);
		try {
			State = 2383;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CASE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case EXTRACTVALUE:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULL:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYS_CONNECT_BY_PATH:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLCAST:
			case XMLNAMESPACES:
			case XMLQUERY:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case INTEGER_LITERAL:
			case LPAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case QUESTION_MARK:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
			case QUOTE_CHARACTER_STRING_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2381;
				bitwiseLevelExpression();
				}
				break;
			case ASTERISK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2382;
				asterisk();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BitwiseLevelExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AddLevelExpressionContext[] addLevelExpression() {
			return GetRuleContexts<AddLevelExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AddLevelExpressionContext addLevelExpression(int i) {
			return GetRuleContext<AddLevelExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AddLevelOperatorContext[] addLevelOperator() {
			return GetRuleContexts<AddLevelOperatorContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AddLevelOperatorContext addLevelOperator(int i) {
			return GetRuleContext<AddLevelOperatorContext>(i);
		}
		public BitwiseLevelExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitwiseLevelExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBitwiseLevelExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBitwiseLevelExpression(this);
		}
	}

	[RuleVersion(0)]
	public BitwiseLevelExpressionContext bitwiseLevelExpression() {
		BitwiseLevelExpressionContext _localctx = new BitwiseLevelExpressionContext(Context, State);
		EnterRule(_localctx, 200, RULE_bitwiseLevelExpression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2385;
			addLevelExpression();
			State = 2391;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,105,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2386;
					addLevelOperator();
					State = 2387;
					addLevelExpression();
					}
					} 
				}
				State = 2393;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,105,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddLevelExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PowerExpressionContext[] powerExpression() {
			return GetRuleContexts<PowerExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PowerExpressionContext powerExpression(int i) {
			return GetRuleContext<PowerExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DivideLevelOperatorContext[] divideLevelOperator() {
			return GetRuleContexts<DivideLevelOperatorContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DivideLevelOperatorContext divideLevelOperator(int i) {
			return GetRuleContext<DivideLevelOperatorContext>(i);
		}
		public AddLevelExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addLevelExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAddLevelExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAddLevelExpression(this);
		}
	}

	[RuleVersion(0)]
	public AddLevelExpressionContext addLevelExpression() {
		AddLevelExpressionContext _localctx = new AddLevelExpressionContext(Context, State);
		EnterRule(_localctx, 202, RULE_addLevelExpression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2394;
			powerExpression();
			State = 2400;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,106,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2395;
					divideLevelOperator();
					State = 2396;
					powerExpression();
					}
					} 
				}
				State = 2402;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,106,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddLevelOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS_SIGN() { return GetToken(OracleAntlrParser.PLUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_SIGN() { return GetToken(OracleAntlrParser.MINUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONCAT_OPERATOR() { return GetToken(OracleAntlrParser.CONCAT_OPERATOR, 0); }
		public AddLevelOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addLevelOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAddLevelOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAddLevelOperator(this);
		}
	}

	[RuleVersion(0)]
	public AddLevelOperatorContext addLevelOperator() {
		AddLevelOperatorContext _localctx = new AddLevelOperatorContext(Context, State);
		EnterRule(_localctx, 204, RULE_addLevelOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2403;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 582)) & ~0x3f) == 0 && ((1L << (_la - 582)) & ((1L << (CONCAT_OPERATOR - 582)) | (1L << (PLUS_SIGN - 582)) | (1L << (MINUS_SIGN - 582)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DivideLevelOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASTERISK() { return GetToken(OracleAntlrParser.ASTERISK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FSLASH() { return GetToken(OracleAntlrParser.FSLASH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MOD() { return GetToken(OracleAntlrParser.MOD, 0); }
		public DivideLevelOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_divideLevelOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDivideLevelOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDivideLevelOperator(this);
		}
	}

	[RuleVersion(0)]
	public DivideLevelOperatorContext divideLevelOperator() {
		DivideLevelOperatorContext _localctx = new DivideLevelOperatorContext(Context, State);
		EnterRule(_localctx, 206, RULE_divideLevelOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2405;
			_la = TokenStream.LA(1);
			if ( !(_la==MOD || _la==FSLASH || _la==ASTERISK) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterNullContext delimiterNull() {
			return GetRuleContext<DelimiterNullContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CastExpressionContext castExpression() {
			return GetRuleContext<CastExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CursorExpressionContext cursorExpression() {
			return GetRuleContext<CursorExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TrimExpressionContext trimExpression() {
			return GetRuleContext<TrimExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TreatExpressionContext treatExpression() {
			return GetRuleContext<TreatExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseExpressionContext caseExpression() {
			return GetRuleContext<CaseExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DecodeExpressionContext decodeExpression() {
			return GetRuleContext<DecodeExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtractDatetimeExpressionContext extractDatetimeExpression() {
			return GetRuleContext<ExtractDatetimeExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtractXMLExpressionContext extractXMLExpression() {
			return GetRuleContext<ExtractXMLExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NewExpressionContext newExpression() {
			return GetRuleContext<NewExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_SIGN() { return GetToken(OracleAntlrParser.MINUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS_SIGN() { return GetToken(OracleAntlrParser.PLUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PriorExpressionContext priorExpression() {
			return GetRuleContext<PriorExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConnectByRootExpressionContext connectByRootExpression() {
			return GetRuleContext<ConnectByRootExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SysConnectByPathExpressionContext sysConnectByPathExpression() {
			return GetRuleContext<SysConnectByPathExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TranslateExpressionContext translateExpression() {
			return GetRuleContext<TranslateExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CharExpressionContext charExpression() {
			return GetRuleContext<CharExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlaggExpressionContext xmlaggExpression() {
			return GetRuleContext<XmlaggExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CursorAttributeExpressionContext cursorAttributeExpression() {
			return GetRuleContext<CursorAttributeExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BulkExpressionContext bulkExpression() {
			return GetRuleContext<BulkExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionContext overExpression() {
			return GetRuleContext<OverExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WithinExpressionContext withinExpression() {
			return GetRuleContext<WithinExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeepExpressionContext keepExpression() {
			return GetRuleContext<KeepExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BindParameterContext bindParameter() {
			return GetRuleContext<BindParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlQueryContext xmlQuery() {
			return GetRuleContext<XmlQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlCastContext xmlCast() {
			return GetRuleContext<XmlCastContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DateTimeAtClauseContext dateTimeAtClause() {
			return GetRuleContext<DateTimeAtClauseContext>(0);
		}
		public UnaryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUnaryExpression(this);
		}
	}

	[RuleVersion(0)]
	public UnaryExpressionContext unaryExpression() {
		UnaryExpressionContext _localctx = new UnaryExpressionContext(Context, State);
		EnterRule(_localctx, 208, RULE_unaryExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2442;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,107,Context) ) {
			case 1:
				{
				State = 2407;
				delimiterNull();
				}
				break;
			case 2:
				{
				State = 2408;
				literal();
				}
				break;
			case 3:
				{
				State = 2409;
				castExpression();
				}
				break;
			case 4:
				{
				State = 2410;
				cursorExpression();
				}
				break;
			case 5:
				{
				State = 2411;
				trimExpression();
				}
				break;
			case 6:
				{
				State = 2412;
				treatExpression();
				}
				break;
			case 7:
				{
				State = 2413;
				caseExpression();
				}
				break;
			case 8:
				{
				State = 2414;
				decodeExpression();
				}
				break;
			case 9:
				{
				State = 2415;
				extractDatetimeExpression();
				}
				break;
			case 10:
				{
				State = 2416;
				extractXMLExpression();
				}
				break;
			case 11:
				{
				State = 2417;
				newExpression();
				}
				break;
			case 12:
				{
				State = 2418;
				Match(MINUS_SIGN);
				State = 2419;
				unaryExpression();
				}
				break;
			case 13:
				{
				State = 2420;
				Match(PLUS_SIGN);
				State = 2421;
				unaryExpression();
				}
				break;
			case 14:
				{
				State = 2422;
				priorExpression();
				}
				break;
			case 15:
				{
				State = 2423;
				connectByRootExpression();
				}
				break;
			case 16:
				{
				State = 2424;
				sysConnectByPathExpression();
				}
				break;
			case 17:
				{
				State = 2425;
				translateExpression();
				}
				break;
			case 18:
				{
				State = 2426;
				charExpression();
				}
				break;
			case 19:
				{
				State = 2427;
				flattenedQuery();
				}
				break;
			case 20:
				{
				State = 2428;
				Match(LPAREN);
				State = 2429;
				fullExpression();
				State = 2430;
				Match(RPAREN);
				}
				break;
			case 21:
				{
				State = 2432;
				xmlaggExpression();
				}
				break;
			case 22:
				{
				State = 2433;
				cursorAttributeExpression();
				}
				break;
			case 23:
				{
				State = 2434;
				bulkExpression();
				}
				break;
			case 24:
				{
				State = 2435;
				overExpression();
				}
				break;
			case 25:
				{
				State = 2436;
				withinExpression();
				}
				break;
			case 26:
				{
				State = 2437;
				keepExpression();
				}
				break;
			case 27:
				{
				State = 2438;
				identifier();
				}
				break;
			case 28:
				{
				State = 2439;
				bindParameter();
				}
				break;
			case 29:
				{
				State = 2440;
				xmlQuery();
				}
				break;
			case 30:
				{
				State = 2441;
				xmlCast();
				}
				break;
			}
			State = 2445;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,108,Context) ) {
			case 1:
				{
				State = 2444;
				dateTimeAtClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlQueryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public XmlQueryDelegateContext xmlQueryDelegate() {
			return GetRuleContext<XmlQueryDelegateContext>(0);
		}
		public XmlQueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlQuery; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlQuery(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlQuery(this);
		}
	}

	[RuleVersion(0)]
	public XmlQueryContext xmlQuery() {
		XmlQueryContext _localctx = new XmlQueryContext(Context, State);
		EnterRule(_localctx, 210, RULE_xmlQuery);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2447;
			xmlQueryDelegate();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlQueryDelegateContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLQUERY() { return GetToken(OracleAntlrParser.XMLQUERY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSING() { return GetToken(OracleAntlrParser.PASSING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlPassingParameterListContext xmlPassingParameterList() {
			return GetRuleContext<XmlPassingParameterListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURNING() { return GetToken(OracleAntlrParser.RETURNING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTENT() { return GetToken(OracleAntlrParser.CONTENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(OracleAntlrParser.VALUE, 0); }
		public XmlQueryDelegateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlQueryDelegate; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlQueryDelegate(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlQueryDelegate(this);
		}
	}

	[RuleVersion(0)]
	public XmlQueryDelegateContext xmlQueryDelegate() {
		XmlQueryDelegateContext _localctx = new XmlQueryDelegateContext(Context, State);
		EnterRule(_localctx, 212, RULE_xmlQueryDelegate);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2449;
			Match(XMLQUERY);
			State = 2450;
			Match(LPAREN);
			State = 2451;
			pureExpression();
			State = 2452;
			Match(PASSING);
			State = 2455;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BY) {
				{
				State = 2453;
				Match(BY);
				State = 2454;
				Match(VALUE);
				}
			}

			State = 2457;
			xmlPassingParameterList();
			State = 2458;
			Match(RETURNING);
			State = 2459;
			Match(CONTENT);
			State = 2460;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlPassingParameterListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public XmlPassingParameterListItemContext[] xmlPassingParameterListItem() {
			return GetRuleContexts<XmlPassingParameterListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlPassingParameterListItemContext xmlPassingParameterListItem(int i) {
			return GetRuleContext<XmlPassingParameterListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public XmlPassingParameterListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlPassingParameterList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlPassingParameterList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlPassingParameterList(this);
		}
	}

	[RuleVersion(0)]
	public XmlPassingParameterListContext xmlPassingParameterList() {
		XmlPassingParameterListContext _localctx = new XmlPassingParameterListContext(Context, State);
		EnterRule(_localctx, 214, RULE_xmlPassingParameterList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2462;
			xmlPassingParameterListItem();
			State = 2467;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2463;
				Match(COMMA);
				State = 2464;
				xmlPassingParameterListItem();
				}
				}
				State = 2469;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlPassingParameterListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public XmlPassingParameterListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlPassingParameterListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlPassingParameterListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlPassingParameterListItem(this);
		}
	}

	[RuleVersion(0)]
	public XmlPassingParameterListItemContext xmlPassingParameterListItem() {
		XmlPassingParameterListItemContext _localctx = new XmlPassingParameterListItemContext(Context, State);
		EnterRule(_localctx, 216, RULE_xmlPassingParameterListItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2470;
			pureExpression();
			State = 2473;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 2471;
				Match(AS);
				State = 2472;
				identifier();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlCastContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLCAST() { return GetToken(OracleAntlrParser.XMLCAST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MULTISET() { return GetToken(OracleAntlrParser.MULTISET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public XmlCastContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlCast; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlCast(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlCast(this);
		}
	}

	[RuleVersion(0)]
	public XmlCastContext xmlCast() {
		XmlCastContext _localctx = new XmlCastContext(Context, State);
		EnterRule(_localctx, 218, RULE_xmlCast);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2475;
			Match(XMLCAST);
			State = 2476;
			Match(LPAREN);
			State = 2480;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,112,Context) ) {
			case 1:
				{
				State = 2477;
				Match(MULTISET);
				State = 2478;
				flattenedQuery();
				}
				break;
			case 2:
				{
				State = 2479;
				fullExpression();
				}
				break;
			}
			State = 2482;
			Match(AS);
			State = 2483;
			typeReference();
			State = 2484;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(OracleAntlrParser.NEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public NewExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNewExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNewExpression(this);
		}
	}

	[RuleVersion(0)]
	public NewExpressionContext newExpression() {
		NewExpressionContext _localctx = new NewExpressionContext(Context, State);
		EnterRule(_localctx, 220, RULE_newExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2486;
			Match(NEW);
			State = 2487;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TreatExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TREAT() { return GetToken(OracleAntlrParser.TREAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TreatExpressionParametersContext treatExpressionParameters() {
			return GetRuleContext<TreatExpressionParametersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TreatExpressionReturnValueContext treatExpressionReturnValue() {
			return GetRuleContext<TreatExpressionReturnValueContext>(0);
		}
		public TreatExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_treatExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTreatExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTreatExpression(this);
		}
	}

	[RuleVersion(0)]
	public TreatExpressionContext treatExpression() {
		TreatExpressionContext _localctx = new TreatExpressionContext(Context, State);
		EnterRule(_localctx, 222, RULE_treatExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2489;
			Match(TREAT);
			State = 2490;
			treatExpressionParameters();
			State = 2492;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,113,Context) ) {
			case 1:
				{
				State = 2491;
				treatExpressionReturnValue();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TreatExpressionParametersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TreatExpressionAsClauseContext treatExpressionAsClause() {
			return GetRuleContext<TreatExpressionAsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public TreatExpressionParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_treatExpressionParameters; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTreatExpressionParameters(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTreatExpressionParameters(this);
		}
	}

	[RuleVersion(0)]
	public TreatExpressionParametersContext treatExpressionParameters() {
		TreatExpressionParametersContext _localctx = new TreatExpressionParametersContext(Context, State);
		EnterRule(_localctx, 224, RULE_treatExpressionParameters);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2494;
			Match(LPAREN);
			State = 2495;
			fullExpression();
			State = 2496;
			treatExpressionAsClause();
			State = 2497;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TreatExpressionAsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REF() { return GetToken(OracleAntlrParser.REF, 0); }
		public TreatExpressionAsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_treatExpressionAsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTreatExpressionAsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTreatExpressionAsClause(this);
		}
	}

	[RuleVersion(0)]
	public TreatExpressionAsClauseContext treatExpressionAsClause() {
		TreatExpressionAsClauseContext _localctx = new TreatExpressionAsClauseContext(Context, State);
		EnterRule(_localctx, 226, RULE_treatExpressionAsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2499;
			Match(AS);
			State = 2501;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,114,Context) ) {
			case 1:
				{
				State = 2500;
				Match(REF);
				}
				break;
			}
			State = 2503;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TreatExpressionReturnValueContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(OracleAntlrParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public TreatExpressionReturnValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_treatExpressionReturnValue; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTreatExpressionReturnValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTreatExpressionReturnValue(this);
		}
	}

	[RuleVersion(0)]
	public TreatExpressionReturnValueContext treatExpressionReturnValue() {
		TreatExpressionReturnValueContext _localctx = new TreatExpressionReturnValueContext(Context, State);
		EnterRule(_localctx, 228, RULE_treatExpressionReturnValue);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2505;
			Match(DOT);
			State = 2506;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultisetExpressionContext : ParserRuleContext {
		public MultisetOperatorContext operators;
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext[] unaryExpression() {
			return GetRuleContexts<UnaryExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression(int i) {
			return GetRuleContext<UnaryExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultisetOperatorContext[] multisetOperator() {
			return GetRuleContexts<MultisetOperatorContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultisetOperatorContext multisetOperator(int i) {
			return GetRuleContext<MultisetOperatorContext>(i);
		}
		public MultisetExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multisetExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMultisetExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMultisetExpression(this);
		}
	}

	[RuleVersion(0)]
	public MultisetExpressionContext multisetExpression() {
		MultisetExpressionContext _localctx = new MultisetExpressionContext(Context, State);
		EnterRule(_localctx, 230, RULE_multisetExpression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2508;
			unaryExpression();
			State = 2514;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,115,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2509;
					_localctx.operators = multisetOperator();
					State = 2510;
					unaryExpression();
					}
					} 
				}
				State = 2516;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,115,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultisetOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MULTISET() { return GetToken(OracleAntlrParser.MULTISET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPT() { return GetToken(OracleAntlrParser.EXCEPT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERSECT() { return GetToken(OracleAntlrParser.INTERSECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNION() { return GetToken(OracleAntlrParser.UNION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISTINCT() { return GetToken(OracleAntlrParser.DISTINCT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		public MultisetOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multisetOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMultisetOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMultisetOperator(this);
		}
	}

	[RuleVersion(0)]
	public MultisetOperatorContext multisetOperator() {
		MultisetOperatorContext _localctx = new MultisetOperatorContext(Context, State);
		EnterRule(_localctx, 232, RULE_multisetOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2517;
			Match(MULTISET);
			State = 2518;
			_la = TokenStream.LA(1);
			if ( !(_la==EXCEPT || _la==INTERSECT || _la==UNION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2520;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==DISTINCT) {
				{
				State = 2519;
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==DISTINCT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DateTimeAtClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT() { return GetToken(OracleAntlrParser.AT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DateTimeAtLocalClauseContext dateTimeAtLocalClause() {
			return GetRuleContext<DateTimeAtLocalClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DateTimeAtTimeZoneClauseContext dateTimeAtTimeZoneClause() {
			return GetRuleContext<DateTimeAtTimeZoneClauseContext>(0);
		}
		public DateTimeAtClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dateTimeAtClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDateTimeAtClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDateTimeAtClause(this);
		}
	}

	[RuleVersion(0)]
	public DateTimeAtClauseContext dateTimeAtClause() {
		DateTimeAtClauseContext _localctx = new DateTimeAtClauseContext(Context, State);
		EnterRule(_localctx, 234, RULE_dateTimeAtClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2522;
			Match(AT);
			State = 2525;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LOCAL:
				{
				State = 2523;
				dateTimeAtLocalClause();
				}
				break;
			case TIME:
				{
				State = 2524;
				dateTimeAtTimeZoneClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DateTimeAtLocalClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(OracleAntlrParser.LOCAL, 0); }
		public DateTimeAtLocalClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dateTimeAtLocalClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDateTimeAtLocalClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDateTimeAtLocalClause(this);
		}
	}

	[RuleVersion(0)]
	public DateTimeAtLocalClauseContext dateTimeAtLocalClause() {
		DateTimeAtLocalClauseContext _localctx = new DateTimeAtLocalClauseContext(Context, State);
		EnterRule(_localctx, 236, RULE_dateTimeAtLocalClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2527;
			Match(LOCAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DateTimeAtTimeZoneClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIME() { return GetToken(OracleAntlrParser.TIME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ZONE() { return GetToken(OracleAntlrParser.ZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DBTIMEZONE() { return GetToken(OracleAntlrParser.DBTIMEZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SESSIONTIMEZONE() { return GetToken(OracleAntlrParser.SESSIONTIMEZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		public DateTimeAtTimeZoneClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dateTimeAtTimeZoneClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDateTimeAtTimeZoneClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDateTimeAtTimeZoneClause(this);
		}
	}

	[RuleVersion(0)]
	public DateTimeAtTimeZoneClauseContext dateTimeAtTimeZoneClause() {
		DateTimeAtTimeZoneClauseContext _localctx = new DateTimeAtTimeZoneClauseContext(Context, State);
		EnterRule(_localctx, 238, RULE_dateTimeAtTimeZoneClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2529;
			Match(TIME);
			State = 2530;
			Match(ZONE);
			State = 2534;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,118,Context) ) {
			case 1:
				{
				State = 2531;
				Match(DBTIMEZONE);
				}
				break;
			case 2:
				{
				State = 2532;
				Match(SESSIONTIMEZONE);
				}
				break;
			case 3:
				{
				State = 2533;
				unaryExpression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeepExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeepClauseContext keepClause() {
			return GetRuleContext<KeepClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionParamsContext overExpressionParams() {
			return GetRuleContext<OverExpressionParamsContext>(0);
		}
		public KeepExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keepExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterKeepExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitKeepExpression(this);
		}
	}

	[RuleVersion(0)]
	public KeepExpressionContext keepExpression() {
		KeepExpressionContext _localctx = new KeepExpressionContext(Context, State);
		EnterRule(_localctx, 240, RULE_keepExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2536;
			identifier();
			State = 2537;
			keepClause();
			State = 2539;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,119,Context) ) {
			case 1:
				{
				State = 2538;
				overExpressionParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeepClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DENSE_RANK() { return GetToken(OracleAntlrParser.DENSE_RANK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIRST() { return GetToken(OracleAntlrParser.FIRST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LAST() { return GetToken(OracleAntlrParser.LAST, 0); }
		public KeepClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keepClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterKeepClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitKeepClause(this);
		}
	}

	[RuleVersion(0)]
	public KeepClauseContext keepClause() {
		KeepClauseContext _localctx = new KeepClauseContext(Context, State);
		EnterRule(_localctx, 242, RULE_keepClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2541;
			Match(KEEP);
			State = 2542;
			Match(LPAREN);
			State = 2543;
			Match(DENSE_RANK);
			State = 2544;
			_la = TokenStream.LA(1);
			if ( !(_la==FIRST || _la==LAST) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2545;
			orderByClause();
			State = 2546;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithinExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WithinExpressionParamsContext withinExpressionParams() {
			return GetRuleContext<WithinExpressionParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionParamsContext overExpressionParams() {
			return GetRuleContext<OverExpressionParamsContext>(0);
		}
		public WithinExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withinExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterWithinExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitWithinExpression(this);
		}
	}

	[RuleVersion(0)]
	public WithinExpressionContext withinExpression() {
		WithinExpressionContext _localctx = new WithinExpressionContext(Context, State);
		EnterRule(_localctx, 244, RULE_withinExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2548;
			identifier();
			State = 2549;
			withinExpressionParams();
			State = 2551;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,120,Context) ) {
			case 1:
				{
				State = 2550;
				overExpressionParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithinExpressionParamsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITHIN() { return GetToken(OracleAntlrParser.WITHIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUP() { return GetToken(OracleAntlrParser.GROUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public WithinGroupOrderByClauseContext withinGroupOrderByClause() {
			return GetRuleContext<WithinGroupOrderByClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public WithinExpressionParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withinExpressionParams; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterWithinExpressionParams(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitWithinExpressionParams(this);
		}
	}

	[RuleVersion(0)]
	public WithinExpressionParamsContext withinExpressionParams() {
		WithinExpressionParamsContext _localctx = new WithinExpressionParamsContext(Context, State);
		EnterRule(_localctx, 246, RULE_withinExpressionParams);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2553;
			Match(WITHIN);
			State = 2554;
			Match(GROUP);
			State = 2555;
			Match(LPAREN);
			State = 2556;
			withinGroupOrderByClause();
			State = 2557;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionParamsContext overExpressionParams() {
			return GetRuleContext<OverExpressionParamsContext>(0);
		}
		public OverExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOverExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOverExpression(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionContext overExpression() {
		OverExpressionContext _localctx = new OverExpressionContext(Context, State);
		EnterRule(_localctx, 248, RULE_overExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2559;
			identifier();
			State = 2560;
			overExpressionParams();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionParamsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVER() { return GetToken(OracleAntlrParser.OVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionPartitionClauseContext overExpressionPartitionClause() {
			return GetRuleContext<OverExpressionPartitionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverOrderByClauseContext overOrderByClause() {
			return GetRuleContext<OverOrderByClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionWindowingClauseContext overExpressionWindowingClause() {
			return GetRuleContext<OverExpressionWindowingClauseContext>(0);
		}
		public OverExpressionParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpressionParams; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOverExpressionParams(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOverExpressionParams(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionParamsContext overExpressionParams() {
		OverExpressionParamsContext _localctx = new OverExpressionParamsContext(Context, State);
		EnterRule(_localctx, 250, RULE_overExpressionParams);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2562;
			Match(OVER);
			State = 2563;
			Match(LPAREN);
			State = 2565;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 2564;
				overExpressionPartitionClause();
				}
			}

			State = 2571;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 2567;
				overOrderByClause();
				State = 2569;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==RANGE || _la==ROWS) {
					{
					State = 2568;
					overExpressionWindowingClause();
					}
				}

				}
			}

			State = 2573;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionPartitionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public OverExpressionPartitionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpressionPartitionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOverExpressionPartitionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOverExpressionPartitionClause(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionPartitionClauseContext overExpressionPartitionClause() {
		OverExpressionPartitionClauseContext _localctx = new OverExpressionPartitionClauseContext(Context, State);
		EnterRule(_localctx, 252, RULE_overExpressionPartitionClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2575;
			Match(PARTITION);
			State = 2576;
			Match(BY);
			State = 2577;
			expressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionWindowingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWS() { return GetToken(OracleAntlrParser.ROWS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(OracleAntlrParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionWindowingClauseBetweenContext overExpressionWindowingClauseBetween() {
			return GetRuleContext<OverExpressionWindowingClauseBetweenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionWindowingClauseSingleContext overExpressionWindowingClauseSingle() {
			return GetRuleContext<OverExpressionWindowingClauseSingleContext>(0);
		}
		public OverExpressionWindowingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpressionWindowingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOverExpressionWindowingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOverExpressionWindowingClause(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionWindowingClauseContext overExpressionWindowingClause() {
		OverExpressionWindowingClauseContext _localctx = new OverExpressionWindowingClauseContext(Context, State);
		EnterRule(_localctx, 254, RULE_overExpressionWindowingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2579;
			_la = TokenStream.LA(1);
			if ( !(_la==RANGE || _la==ROWS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2582;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BETWEEN:
				{
				State = 2580;
				overExpressionWindowingClauseBetween();
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CASE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case EXTRACTVALUE:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULL:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYS_CONNECT_BY_PATH:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLCAST:
			case XMLNAMESPACES:
			case XMLQUERY:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case INTEGER_LITERAL:
			case LPAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case QUESTION_MARK:
			case ASTERISK:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
			case QUOTE_CHARACTER_STRING_LITERAL:
				{
				State = 2581;
				overExpressionWindowingClauseSingle();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionWindowingClauseBetweenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BETWEEN() { return GetToken(OracleAntlrParser.BETWEEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionWindowingClauseItemContext[] overExpressionWindowingClauseItem() {
			return GetRuleContexts<OverExpressionWindowingClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionWindowingClauseItemContext overExpressionWindowingClauseItem(int i) {
			return GetRuleContext<OverExpressionWindowingClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(OracleAntlrParser.AND, 0); }
		public OverExpressionWindowingClauseBetweenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpressionWindowingClauseBetween; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOverExpressionWindowingClauseBetween(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOverExpressionWindowingClauseBetween(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionWindowingClauseBetweenContext overExpressionWindowingClauseBetween() {
		OverExpressionWindowingClauseBetweenContext _localctx = new OverExpressionWindowingClauseBetweenContext(Context, State);
		EnterRule(_localctx, 256, RULE_overExpressionWindowingClauseBetween);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2584;
			Match(BETWEEN);
			State = 2585;
			overExpressionWindowingClauseItem();
			State = 2586;
			Match(AND);
			State = 2587;
			overExpressionWindowingClauseItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionWindowingClauseSingleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionWindowingClauseItemContext overExpressionWindowingClauseItem() {
			return GetRuleContext<OverExpressionWindowingClauseItemContext>(0);
		}
		public OverExpressionWindowingClauseSingleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpressionWindowingClauseSingle; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOverExpressionWindowingClauseSingle(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOverExpressionWindowingClauseSingle(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionWindowingClauseSingleContext overExpressionWindowingClauseSingle() {
		OverExpressionWindowingClauseSingleContext _localctx = new OverExpressionWindowingClauseSingleContext(Context, State);
		EnterRule(_localctx, 258, RULE_overExpressionWindowingClauseSingle);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2589;
			overExpressionWindowingClauseItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionWindowingClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNBOUNDED() { return GetToken(OracleAntlrParser.UNBOUNDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRECEDING() { return GetToken(OracleAntlrParser.PRECEDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOLLOWING() { return GetToken(OracleAntlrParser.FOLLOWING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(OracleAntlrParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionWindowingClauseItemExpressionContext overExpressionWindowingClauseItemExpression() {
			return GetRuleContext<OverExpressionWindowingClauseItemExpressionContext>(0);
		}
		public OverExpressionWindowingClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpressionWindowingClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOverExpressionWindowingClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOverExpressionWindowingClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionWindowingClauseItemContext overExpressionWindowingClauseItem() {
		OverExpressionWindowingClauseItemContext _localctx = new OverExpressionWindowingClauseItemContext(Context, State);
		EnterRule(_localctx, 260, RULE_overExpressionWindowingClauseItem);
		int _la;
		try {
			State = 2598;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,125,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2591;
				Match(UNBOUNDED);
				State = 2592;
				_la = TokenStream.LA(1);
				if ( !(_la==FOLLOWING || _la==PRECEDING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2593;
				Match(CURRENT);
				State = 2594;
				Match(ROW);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2595;
				overExpressionWindowingClauseItemExpression();
				State = 2596;
				_la = TokenStream.LA(1);
				if ( !(_la==FOLLOWING || _la==PRECEDING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionWindowingClauseItemExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public OverExpressionWindowingClauseItemExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpressionWindowingClauseItemExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOverExpressionWindowingClauseItemExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOverExpressionWindowingClauseItemExpression(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionWindowingClauseItemExpressionContext overExpressionWindowingClauseItemExpression() {
		OverExpressionWindowingClauseItemExpressionContext _localctx = new OverExpressionWindowingClauseItemExpressionContext(Context, State);
		EnterRule(_localctx, 262, RULE_overExpressionWindowingClauseItemExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2600;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CursorAttributeExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT_SIGN() { return GetToken(OracleAntlrParser.PERCENT_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOUND() { return GetToken(OracleAntlrParser.FOUND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ISOPEN() { return GetToken(OracleAntlrParser.ISOPEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOTFOUND() { return GetToken(OracleAntlrParser.NOTFOUND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWCOUNT() { return GetToken(OracleAntlrParser.ROWCOUNT, 0); }
		public CursorAttributeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursorAttributeExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCursorAttributeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCursorAttributeExpression(this);
		}
	}

	[RuleVersion(0)]
	public CursorAttributeExpressionContext cursorAttributeExpression() {
		CursorAttributeExpressionContext _localctx = new CursorAttributeExpressionContext(Context, State);
		EnterRule(_localctx, 264, RULE_cursorAttributeExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2602;
			identifier();
			State = 2603;
			Match(PERCENT_SIGN);
			State = 2604;
			_la = TokenStream.LA(1);
			if ( !(_la==FOUND || _la==ISOPEN || _la==NOTFOUND || _la==ROWCOUNT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BulkExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT_SIGN() { return GetToken(OracleAntlrParser.PERCENT_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BulkExceptionExpressionContext bulkExceptionExpression() {
			return GetRuleContext<BulkExceptionExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BulkRowCountExpressionContext bulkRowCountExpression() {
			return GetRuleContext<BulkRowCountExpressionContext>(0);
		}
		public BulkExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bulkExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBulkExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBulkExpression(this);
		}
	}

	[RuleVersion(0)]
	public BulkExpressionContext bulkExpression() {
		BulkExpressionContext _localctx = new BulkExpressionContext(Context, State);
		EnterRule(_localctx, 266, RULE_bulkExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2606;
			identifier();
			State = 2607;
			Match(PERCENT_SIGN);
			State = 2610;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BULK_EXCEPTIONS:
				{
				State = 2608;
				bulkExceptionExpression();
				}
				break;
			case BULK_ROWCOUNT:
				{
				State = 2609;
				bulkRowCountExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BulkExceptionExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BULK_EXCEPTIONS() { return GetToken(OracleAntlrParser.BULK_EXCEPTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(OracleAntlrParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COUNT() { return GetToken(OracleAntlrParser.COUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CollectionIndexContext collectionIndex() {
			return GetRuleContext<CollectionIndexContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR_INDEX() { return GetToken(OracleAntlrParser.ERROR_INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR_CODE() { return GetToken(OracleAntlrParser.ERROR_CODE, 0); }
		public BulkExceptionExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bulkExceptionExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBulkExceptionExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBulkExceptionExpression(this);
		}
	}

	[RuleVersion(0)]
	public BulkExceptionExpressionContext bulkExceptionExpression() {
		BulkExceptionExpressionContext _localctx = new BulkExceptionExpressionContext(Context, State);
		EnterRule(_localctx, 268, RULE_bulkExceptionExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2612;
			Match(BULK_EXCEPTIONS);
			State = 2619;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DOT:
				{
				State = 2613;
				Match(DOT);
				State = 2614;
				Match(COUNT);
				}
				break;
			case LPAREN:
				{
				State = 2615;
				collectionIndex();
				State = 2616;
				Match(DOT);
				State = 2617;
				_la = TokenStream.LA(1);
				if ( !(_la==ERROR_CODE || _la==ERROR_INDEX) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BulkRowCountExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BULK_ROWCOUNT() { return GetToken(OracleAntlrParser.BULK_ROWCOUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CollectionIndexContext collectionIndex() {
			return GetRuleContext<CollectionIndexContext>(0);
		}
		public BulkRowCountExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bulkRowCountExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBulkRowCountExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBulkRowCountExpression(this);
		}
	}

	[RuleVersion(0)]
	public BulkRowCountExpressionContext bulkRowCountExpression() {
		BulkRowCountExpressionContext _localctx = new BulkRowCountExpressionContext(Context, State);
		EnterRule(_localctx, 270, RULE_bulkRowCountExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2621;
			Match(BULK_ROWCOUNT);
			State = 2622;
			collectionIndex();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectionIndexContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public CollectionIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectionIndex; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCollectionIndex(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCollectionIndex(this);
		}
	}

	[RuleVersion(0)]
	public CollectionIndexContext collectionIndex() {
		CollectionIndexContext _localctx = new CollectionIndexContext(Context, State);
		EnterRule(_localctx, 272, RULE_collectionIndex);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2624;
			Match(LPAREN);
			State = 2625;
			fullExpression();
			State = 2626;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PowerExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MultisetExpressionContext[] multisetExpression() {
			return GetRuleContexts<MultisetExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultisetExpressionContext multisetExpression(int i) {
			return GetRuleContext<MultisetExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POWER_OPERATOR() { return GetToken(OracleAntlrParser.POWER_OPERATOR, 0); }
		public PowerExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_powerExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPowerExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPowerExpression(this);
		}
	}

	[RuleVersion(0)]
	public PowerExpressionContext powerExpression() {
		PowerExpressionContext _localctx = new PowerExpressionContext(Context, State);
		EnterRule(_localctx, 274, RULE_powerExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2628;
			multisetExpression();
			State = 2631;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,128,Context) ) {
			case 1:
				{
				State = 2629;
				Match(POWER_OPERATOR);
				State = 2630;
				multisetExpression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterNullContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public DelimiterNullContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterNull; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterNull(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterNull(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterNullContext delimiterNull() {
		DelimiterNullContext _localctx = new DelimiterNullContext(Context, State);
		EnterRule(_localctx, 276, RULE_delimiterNull);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2633;
			Match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CastExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CAST() { return GetToken(OracleAntlrParser.CAST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MULTISET() { return GetToken(OracleAntlrParser.MULTISET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public CastExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_castExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCastExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCastExpression(this);
		}
	}

	[RuleVersion(0)]
	public CastExpressionContext castExpression() {
		CastExpressionContext _localctx = new CastExpressionContext(Context, State);
		EnterRule(_localctx, 278, RULE_castExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2635;
			Match(CAST);
			State = 2636;
			Match(LPAREN);
			State = 2640;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,129,Context) ) {
			case 1:
				{
				State = 2637;
				Match(MULTISET);
				State = 2638;
				flattenedQuery();
				}
				break;
			case 2:
				{
				State = 2639;
				fullExpression();
				}
				break;
			}
			State = 2642;
			Match(AS);
			State = 2643;
			typeReference();
			State = 2644;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CursorExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURSOR() { return GetToken(OracleAntlrParser.CURSOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public CursorExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursorExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCursorExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCursorExpression(this);
		}
	}

	[RuleVersion(0)]
	public CursorExpressionContext cursorExpression() {
		CursorExpressionContext _localctx = new CursorExpressionContext(Context, State);
		EnterRule(_localctx, 280, RULE_cursorExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2646;
			Match(CURSOR);
			State = 2647;
			Match(LPAREN);
			State = 2648;
			selectStatement();
			State = 2649;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASE() { return GetToken(OracleAntlrParser.CASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(OracleAntlrParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SearchedCaseExpressionContext searchedCaseExpression() {
			return GetRuleContext<SearchedCaseExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleCaseExpressionContext simpleCaseExpression() {
			return GetRuleContext<SimpleCaseExpressionContext>(0);
		}
		public CaseExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCaseExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCaseExpression(this);
		}
	}

	[RuleVersion(0)]
	public CaseExpressionContext caseExpression() {
		CaseExpressionContext _localctx = new CaseExpressionContext(Context, State);
		EnterRule(_localctx, 282, RULE_caseExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2651;
			Match(CASE);
			State = 2654;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,130,Context) ) {
			case 1:
				{
				State = 2652;
				searchedCaseExpression();
				}
				break;
			case 2:
				{
				State = 2653;
				simpleCaseExpression();
				}
				break;
			}
			State = 2656;
			Match(END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleCaseExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleCaseWhenEntryContext[] simpleCaseWhenEntry() {
			return GetRuleContexts<SimpleCaseWhenEntryContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleCaseWhenEntryContext simpleCaseWhenEntry(int i) {
			return GetRuleContext<SimpleCaseWhenEntryContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseElseEntryContext caseElseEntry() {
			return GetRuleContext<CaseElseEntryContext>(0);
		}
		public SimpleCaseExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleCaseExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSimpleCaseExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSimpleCaseExpression(this);
		}
	}

	[RuleVersion(0)]
	public SimpleCaseExpressionContext simpleCaseExpression() {
		SimpleCaseExpressionContext _localctx = new SimpleCaseExpressionContext(Context, State);
		EnterRule(_localctx, 284, RULE_simpleCaseExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2658;
			fullExpression();
			State = 2660;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2659;
				simpleCaseWhenEntry();
				}
				}
				State = 2662;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 2665;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 2664;
				caseElseEntry();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleCaseWhenEntryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(OracleAntlrParser.THEN, 0); }
		public SimpleCaseWhenEntryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleCaseWhenEntry; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSimpleCaseWhenEntry(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSimpleCaseWhenEntry(this);
		}
	}

	[RuleVersion(0)]
	public SimpleCaseWhenEntryContext simpleCaseWhenEntry() {
		SimpleCaseWhenEntryContext _localctx = new SimpleCaseWhenEntryContext(Context, State);
		EnterRule(_localctx, 286, RULE_simpleCaseWhenEntry);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2667;
			Match(WHEN);
			State = 2668;
			fullExpression();
			State = 2669;
			Match(THEN);
			State = 2670;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseElseEntryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(OracleAntlrParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public CaseElseEntryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseElseEntry; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCaseElseEntry(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCaseElseEntry(this);
		}
	}

	[RuleVersion(0)]
	public CaseElseEntryContext caseElseEntry() {
		CaseElseEntryContext _localctx = new CaseElseEntryContext(Context, State);
		EnterRule(_localctx, 288, RULE_caseElseEntry);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2672;
			Match(ELSE);
			State = 2673;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SearchedCaseExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SearchedCaseWhenEntryContext[] searchedCaseWhenEntry() {
			return GetRuleContexts<SearchedCaseWhenEntryContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SearchedCaseWhenEntryContext searchedCaseWhenEntry(int i) {
			return GetRuleContext<SearchedCaseWhenEntryContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseElseEntryContext caseElseEntry() {
			return GetRuleContext<CaseElseEntryContext>(0);
		}
		public SearchedCaseExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searchedCaseExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSearchedCaseExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSearchedCaseExpression(this);
		}
	}

	[RuleVersion(0)]
	public SearchedCaseExpressionContext searchedCaseExpression() {
		SearchedCaseExpressionContext _localctx = new SearchedCaseExpressionContext(Context, State);
		EnterRule(_localctx, 290, RULE_searchedCaseExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2676;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2675;
				searchedCaseWhenEntry();
				}
				}
				State = 2678;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 2681;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 2680;
				caseElseEntry();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SearchedCaseWhenEntryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(OracleAntlrParser.THEN, 0); }
		public SearchedCaseWhenEntryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searchedCaseWhenEntry; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSearchedCaseWhenEntry(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSearchedCaseWhenEntry(this);
		}
	}

	[RuleVersion(0)]
	public SearchedCaseWhenEntryContext searchedCaseWhenEntry() {
		SearchedCaseWhenEntryContext _localctx = new SearchedCaseWhenEntryContext(Context, State);
		EnterRule(_localctx, 292, RULE_searchedCaseWhenEntry);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2683;
			Match(WHEN);
			State = 2684;
			fullExpression();
			State = 2685;
			Match(THEN);
			State = 2686;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PriorExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIOR() { return GetToken(OracleAntlrParser.PRIOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		public PriorExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_priorExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPriorExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPriorExpression(this);
		}
	}

	[RuleVersion(0)]
	public PriorExpressionContext priorExpression() {
		PriorExpressionContext _localctx = new PriorExpressionContext(Context, State);
		EnterRule(_localctx, 294, RULE_priorExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2688;
			Match(PRIOR);
			State = 2689;
			unaryExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConnectByRootExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONNECT_BY_ROOT() { return GetToken(OracleAntlrParser.CONNECT_BY_ROOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		public ConnectByRootExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_connectByRootExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConnectByRootExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConnectByRootExpression(this);
		}
	}

	[RuleVersion(0)]
	public ConnectByRootExpressionContext connectByRootExpression() {
		ConnectByRootExpressionContext _localctx = new ConnectByRootExpressionContext(Context, State);
		EnterRule(_localctx, 296, RULE_connectByRootExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2691;
			Match(CONNECT_BY_ROOT);
			State = 2692;
			unaryExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SysConnectByPathExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SYS_CONNECT_BY_PATH() { return GetToken(OracleAntlrParser.SYS_CONNECT_BY_PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public SysConnectByPathExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sysConnectByPathExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSysConnectByPathExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSysConnectByPathExpression(this);
		}
	}

	[RuleVersion(0)]
	public SysConnectByPathExpressionContext sysConnectByPathExpression() {
		SysConnectByPathExpressionContext _localctx = new SysConnectByPathExpressionContext(Context, State);
		EnterRule(_localctx, 298, RULE_sysConnectByPathExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2694;
			Match(SYS_CONNECT_BY_PATH);
			State = 2695;
			simpleIdentifierParams();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TrimExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIM() { return GetToken(OracleAntlrParser.TRIM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TrimExtClauseContext trimExtClause() {
			return GetRuleContext<TrimExtClauseContext>(0);
		}
		public TrimExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trimExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTrimExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTrimExpression(this);
		}
	}

	[RuleVersion(0)]
	public TrimExpressionContext trimExpression() {
		TrimExpressionContext _localctx = new TrimExpressionContext(Context, State);
		EnterRule(_localctx, 300, RULE_trimExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2697;
			Match(TRIM);
			State = 2698;
			Match(LPAREN);
			State = 2700;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,135,Context) ) {
			case 1:
				{
				State = 2699;
				trimExtClause();
				}
				break;
			}
			State = 2702;
			fullExpression();
			State = 2703;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TrimExtClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(OracleAntlrParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEADING() { return GetToken(OracleAntlrParser.LEADING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRAILING() { return GetToken(OracleAntlrParser.TRAILING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOTH() { return GetToken(OracleAntlrParser.BOTH, 0); }
		public TrimExtClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trimExtClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTrimExtClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTrimExtClause(this);
		}
	}

	[RuleVersion(0)]
	public TrimExtClauseContext trimExtClause() {
		TrimExtClauseContext _localctx = new TrimExtClauseContext(Context, State);
		EnterRule(_localctx, 302, RULE_trimExtClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2710;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,137,Context) ) {
			case 1:
				{
				State = 2705;
				_la = TokenStream.LA(1);
				if ( !(_la==BOTH || _la==LEADING || _la==TRAILING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2707;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLAGG - 513)) | (1L << (XMLCAST - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLQUERY - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (INTEGER_LITERAL - 577)) | (1L << (LPAREN - 577)) | (1L << (PLUS_SIGN - 577)) | (1L << (MINUS_SIGN - 577)) | (1L << (QUESTION_MARK - 577)) | (1L << (ASTERISK - 577)) | (1L << (FLOATING_POINT_LITERAL - 577)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 577)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 577)) | (1L << (BINARY_STRING_LITERAL - 577)) | (1L << (CHARACTER_STRING_LITERAL - 577)) | (1L << (MONEY_LITERAL - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 577)))) != 0)) {
					{
					State = 2706;
					fullExpression();
					}
				}

				}
				break;
			case 2:
				{
				State = 2709;
				fullExpression();
				}
				break;
			}
			State = 2712;
			Match(FROM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DecodeExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECODE() { return GetToken(OracleAntlrParser.DECODE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public DecodeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_decodeExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDecodeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDecodeExpression(this);
		}
	}

	[RuleVersion(0)]
	public DecodeExpressionContext decodeExpression() {
		DecodeExpressionContext _localctx = new DecodeExpressionContext(Context, State);
		EnterRule(_localctx, 304, RULE_decodeExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2714;
			Match(DECODE);
			State = 2715;
			Match(LPAREN);
			State = 2716;
			fullExpression();
			State = 2721;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2717;
				Match(COMMA);
				State = 2718;
				fullExpression();
				}
				}
				State = 2723;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2724;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtractDatetimeExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTRACT() { return GetToken(OracleAntlrParser.EXTRACT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExtractDatetimeFromClauseContext extractDatetimeFromClause() {
			return GetRuleContext<ExtractDatetimeFromClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode YEAR() { return GetToken(OracleAntlrParser.YEAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MONTH() { return GetToken(OracleAntlrParser.MONTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DAY() { return GetToken(OracleAntlrParser.DAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HOUR() { return GetToken(OracleAntlrParser.HOUR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUTE() { return GetToken(OracleAntlrParser.MINUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECOND() { return GetToken(OracleAntlrParser.SECOND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_HOUR() { return GetToken(OracleAntlrParser.TIMEZONE_HOUR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_MINUTE() { return GetToken(OracleAntlrParser.TIMEZONE_MINUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_REGION() { return GetToken(OracleAntlrParser.TIMEZONE_REGION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_ABBR() { return GetToken(OracleAntlrParser.TIMEZONE_ABBR, 0); }
		public ExtractDatetimeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extractDatetimeExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExtractDatetimeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExtractDatetimeExpression(this);
		}
	}

	[RuleVersion(0)]
	public ExtractDatetimeExpressionContext extractDatetimeExpression() {
		ExtractDatetimeExpressionContext _localctx = new ExtractDatetimeExpressionContext(Context, State);
		EnterRule(_localctx, 306, RULE_extractDatetimeExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2726;
			Match(EXTRACT);
			State = 2727;
			Match(LPAREN);
			State = 2728;
			_la = TokenStream.LA(1);
			if ( !(_la==DAY || _la==HOUR || _la==MINUTE || _la==MONTH || ((((_la - 458)) & ~0x3f) == 0 && ((1L << (_la - 458)) & ((1L << (SECOND - 458)) | (1L << (TIMEZONE_ABBR - 458)) | (1L << (TIMEZONE_HOUR - 458)) | (1L << (TIMEZONE_MINUTE - 458)) | (1L << (TIMEZONE_REGION - 458)))) != 0) || _la==YEAR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2729;
			extractDatetimeFromClause();
			State = 2730;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtractXMLExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeInstanceContext xmlTypeInstance() {
			return GetRuleContext<XmlTypeInstanceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XpathStringContext xpathString() {
			return GetRuleContext<XpathStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTRACT() { return GetToken(OracleAntlrParser.EXTRACT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTRACTVALUE() { return GetToken(OracleAntlrParser.EXTRACTVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlNamespaceContext xmlNamespace() {
			return GetRuleContext<XmlNamespaceContext>(0);
		}
		public ExtractXMLExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extractXMLExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExtractXMLExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExtractXMLExpression(this);
		}
	}

	[RuleVersion(0)]
	public ExtractXMLExpressionContext extractXMLExpression() {
		ExtractXMLExpressionContext _localctx = new ExtractXMLExpressionContext(Context, State);
		EnterRule(_localctx, 308, RULE_extractXMLExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2732;
			_la = TokenStream.LA(1);
			if ( !(_la==EXTRACT || _la==EXTRACTVALUE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2733;
			Match(LPAREN);
			State = 2734;
			xmlTypeInstance();
			State = 2735;
			Match(COMMA);
			State = 2736;
			xpathString();
			State = 2739;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 2737;
				Match(COMMA);
				State = 2738;
				xmlNamespace();
				}
			}

			State = 2741;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeInstanceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListItemContext expressionListItem() {
			return GetRuleContext<ExpressionListItemContext>(0);
		}
		public XmlTypeInstanceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeInstance; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlTypeInstance(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlTypeInstance(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeInstanceContext xmlTypeInstance() {
		XmlTypeInstanceContext _localctx = new XmlTypeInstanceContext(Context, State);
		EnterRule(_localctx, 310, RULE_xmlTypeInstance);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2743;
			expressionListItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XpathStringContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		public XpathStringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xpathString; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXpathString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXpathString(this);
		}
	}

	[RuleVersion(0)]
	public XpathStringContext xpathString() {
		XpathStringContext _localctx = new XpathStringContext(Context, State);
		EnterRule(_localctx, 312, RULE_xpathString);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2745;
			pureExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlNamespaceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		public XmlNamespaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlNamespace; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlNamespace(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlNamespace(this);
		}
	}

	[RuleVersion(0)]
	public XmlNamespaceContext xmlNamespace() {
		XmlNamespaceContext _localctx = new XmlNamespaceContext(Context, State);
		EnterRule(_localctx, 314, RULE_xmlNamespace);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2747;
			pureExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtractDatetimeFromClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(OracleAntlrParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterDateContext delimiterDate() {
			return GetRuleContext<DelimiterDateContext>(0);
		}
		public ExtractDatetimeFromClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extractDatetimeFromClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExtractDatetimeFromClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExtractDatetimeFromClause(this);
		}
	}

	[RuleVersion(0)]
	public ExtractDatetimeFromClauseContext extractDatetimeFromClause() {
		ExtractDatetimeFromClauseContext _localctx = new ExtractDatetimeFromClauseContext(Context, State);
		EnterRule(_localctx, 316, RULE_extractDatetimeFromClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2749;
			Match(FROM);
			State = 2751;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,140,Context) ) {
			case 1:
				{
				State = 2750;
				delimiterDate();
				}
				break;
			}
			State = 2753;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterDateContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATE() { return GetToken(OracleAntlrParser.DATE, 0); }
		public DelimiterDateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterDate; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterDate(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterDate(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterDateContext delimiterDate() {
		DelimiterDateContext _localctx = new DelimiterDateContext(Context, State);
		EnterRule(_localctx, 318, RULE_delimiterDate);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2755;
			Match(DATE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiColumnConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public OverlapsConditionContext overlapsCondition() {
			return GetRuleContext<OverlapsConditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterLParenContext delimiterLParen() {
			return GetRuleContext<DelimiterLParenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiItemExpressionListContext multiItemExpressionList() {
			return GetRuleContext<MultiItemExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterRParenContext delimiterRParen() {
			return GetRuleContext<DelimiterRParenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterInContext delimiterIn() {
			return GetRuleContext<DelimiterInContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonPairOperatorContext comparisonPairOperator() {
			return GetRuleContext<ComparisonPairOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonListContext comparisonList() {
			return GetRuleContext<ComparisonListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterNotContext delimiterNot() {
			return GetRuleContext<DelimiterNotContext>(0);
		}
		public MultiColumnConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiColumnCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMultiColumnCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMultiColumnCondition(this);
		}
	}

	[RuleVersion(0)]
	public MultiColumnConditionContext multiColumnCondition() {
		MultiColumnConditionContext _localctx = new MultiColumnConditionContext(Context, State);
		EnterRule(_localctx, 320, RULE_multiColumnCondition);
		int _la;
		try {
			State = 2772;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,144,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2757;
				overlapsCondition();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2758;
				delimiterLParen();
				State = 2759;
				multiItemExpressionList();
				State = 2760;
				delimiterRParen();
				State = 2766;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case IN:
				case NOT:
					{
					State = 2762;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NOT) {
						{
						State = 2761;
						delimiterNot();
						}
					}

					State = 2764;
					delimiterIn();
					}
					break;
				case GREATER_THAN:
				case LESS_THAN:
				case EQUAL_SIGN:
				case BANG:
				case CARET:
				case TILDE:
					{
					State = 2765;
					comparisonPairOperator();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2770;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,143,Context) ) {
				case 1:
					{
					State = 2768;
					comparisonList();
					}
					break;
				case 2:
					{
					State = 2769;
					flattenedQuery();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverlapsConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ParenthesizedExpressionListContext[] parenthesizedExpressionList() {
			return GetRuleContexts<ParenthesizedExpressionListContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParenthesizedExpressionListContext parenthesizedExpressionList(int i) {
			return GetRuleContext<ParenthesizedExpressionListContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVERLAPS() { return GetToken(OracleAntlrParser.OVERLAPS, 0); }
		public OverlapsConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overlapsCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOverlapsCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOverlapsCondition(this);
		}
	}

	[RuleVersion(0)]
	public OverlapsConditionContext overlapsCondition() {
		OverlapsConditionContext _localctx = new OverlapsConditionContext(Context, State);
		EnterRule(_localctx, 322, RULE_overlapsCondition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2774;
			parenthesizedExpressionList();
			State = 2775;
			Match(OVERLAPS);
			State = 2776;
			parenthesizedExpressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComparisonListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonListContext[] comparisonList() {
			return GetRuleContexts<ComparisonListContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonListContext comparisonList(int i) {
			return GetRuleContext<ComparisonListContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ComparisonListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comparisonList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterComparisonList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitComparisonList(this);
		}
	}

	[RuleVersion(0)]
	public ComparisonListContext comparisonList() {
		ComparisonListContext _localctx = new ComparisonListContext(Context, State);
		EnterRule(_localctx, 324, RULE_comparisonList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2778;
			Match(LPAREN);
			State = 2788;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,146,Context) ) {
			case 1:
				{
				State = 2779;
				expressionList();
				}
				break;
			case 2:
				{
				State = 2780;
				comparisonList();
				State = 2785;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2781;
					Match(COMMA);
					State = 2782;
					comparisonList();
					}
					}
					State = 2787;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			State = 2790;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectionsComparisonContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CollectionsComparisonSubmultisetContext collectionsComparisonSubmultiset() {
			return GetRuleContext<CollectionsComparisonSubmultisetContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollectionsComparisonMemberOfContext collectionsComparisonMemberOf() {
			return GetRuleContext<CollectionsComparisonMemberOfContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollectionsComparisonIsASetContext collectionsComparisonIsASet() {
			return GetRuleContext<CollectionsComparisonIsASetContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollectionsComparisonIsEmptyContext collectionsComparisonIsEmpty() {
			return GetRuleContext<CollectionsComparisonIsEmptyContext>(0);
		}
		public CollectionsComparisonContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectionsComparison; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCollectionsComparison(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCollectionsComparison(this);
		}
	}

	[RuleVersion(0)]
	public CollectionsComparisonContext collectionsComparison() {
		CollectionsComparisonContext _localctx = new CollectionsComparisonContext(Context, State);
		EnterRule(_localctx, 326, RULE_collectionsComparison);
		try {
			State = 2796;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,147,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2792;
				collectionsComparisonSubmultiset();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2793;
				collectionsComparisonMemberOf();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2794;
				collectionsComparisonIsASet();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2795;
				collectionsComparisonIsEmpty();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectionsComparisonSubmultisetContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBMULTISET() { return GetToken(OracleAntlrParser.SUBMULTISET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public CollectionsComparisonSubmultisetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectionsComparisonSubmultiset; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCollectionsComparisonSubmultiset(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCollectionsComparisonSubmultiset(this);
		}
	}

	[RuleVersion(0)]
	public CollectionsComparisonSubmultisetContext collectionsComparisonSubmultiset() {
		CollectionsComparisonSubmultisetContext _localctx = new CollectionsComparisonSubmultisetContext(Context, State);
		EnterRule(_localctx, 328, RULE_collectionsComparisonSubmultiset);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2799;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 2798;
				Match(NOT);
				}
			}

			State = 2801;
			Match(SUBMULTISET);
			State = 2802;
			Match(OF);
			State = 2803;
			pureExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectionsComparisonMemberOfContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEMBER() { return GetToken(OracleAntlrParser.MEMBER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public CollectionsComparisonMemberOfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectionsComparisonMemberOf; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCollectionsComparisonMemberOf(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCollectionsComparisonMemberOf(this);
		}
	}

	[RuleVersion(0)]
	public CollectionsComparisonMemberOfContext collectionsComparisonMemberOf() {
		CollectionsComparisonMemberOfContext _localctx = new CollectionsComparisonMemberOfContext(Context, State);
		EnterRule(_localctx, 330, RULE_collectionsComparisonMemberOf);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2806;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 2805;
				Match(NOT);
				}
			}

			State = 2808;
			Match(MEMBER);
			State = 2809;
			Match(OF);
			State = 2810;
			pureExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectionsComparisonIsASetContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode A_() { return GetToken(OracleAntlrParser.A_, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public CollectionsComparisonIsASetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectionsComparisonIsASet; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCollectionsComparisonIsASet(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCollectionsComparisonIsASet(this);
		}
	}

	[RuleVersion(0)]
	public CollectionsComparisonIsASetContext collectionsComparisonIsASet() {
		CollectionsComparisonIsASetContext _localctx = new CollectionsComparisonIsASetContext(Context, State);
		EnterRule(_localctx, 332, RULE_collectionsComparisonIsASet);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2812;
			Match(IS);
			State = 2814;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 2813;
				Match(NOT);
				}
			}

			State = 2816;
			Match(A_);
			State = 2817;
			Match(SET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectionsComparisonIsEmptyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EMPTY_KEYWORD() { return GetToken(OracleAntlrParser.EMPTY_KEYWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public CollectionsComparisonIsEmptyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectionsComparisonIsEmpty; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCollectionsComparisonIsEmpty(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCollectionsComparisonIsEmpty(this);
		}
	}

	[RuleVersion(0)]
	public CollectionsComparisonIsEmptyContext collectionsComparisonIsEmpty() {
		CollectionsComparisonIsEmptyContext _localctx = new CollectionsComparisonIsEmptyContext(Context, State);
		EnterRule(_localctx, 334, RULE_collectionsComparisonIsEmpty);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2819;
			Match(IS);
			State = 2821;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 2820;
				Match(NOT);
				}
			}

			State = 2823;
			Match(EMPTY_KEYWORD);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LikeOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKE() { return GetToken(OracleAntlrParser.LIKE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKEC() { return GetToken(OracleAntlrParser.LIKEC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKE2() { return GetToken(OracleAntlrParser.LIKE2, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKE4() { return GetToken(OracleAntlrParser.LIKE4, 0); }
		public LikeOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_likeOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLikeOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLikeOperator(this);
		}
	}

	[RuleVersion(0)]
	public LikeOperatorContext likeOperator() {
		LikeOperatorContext _localctx = new LikeOperatorContext(Context, State);
		EnterRule(_localctx, 336, RULE_likeOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2825;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 262)) & ~0x3f) == 0 && ((1L << (_la - 262)) & ((1L << (LIKE - 262)) | (1L << (LIKE2 - 262)) | (1L << (LIKE4 - 262)) | (1L << (LIKEC - 262)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EscapeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ESCAPE() { return GetToken(OracleAntlrParser.ESCAPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public EscapeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_escapeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterEscapeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitEscapeClause(this);
		}
	}

	[RuleVersion(0)]
	public EscapeClauseContext escapeClause() {
		EscapeClauseContext _localctx = new EscapeClauseContext(Context, State);
		EnterRule(_localctx, 338, RULE_escapeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2827;
			Match(ESCAPE);
			State = 2828;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BetweenOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BETWEEN() { return GetToken(OracleAntlrParser.BETWEEN, 0); }
		public BetweenOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_betweenOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBetweenOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBetweenOperator(this);
		}
	}

	[RuleVersion(0)]
	public BetweenOperatorContext betweenOperator() {
		BetweenOperatorContext _localctx = new BetweenOperatorContext(Context, State);
		EnterRule(_localctx, 340, RULE_betweenOperator);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2830;
			Match(BETWEEN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BetweenAndOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(OracleAntlrParser.AND, 0); }
		public BetweenAndOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_betweenAndOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBetweenAndOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBetweenAndOperator(this);
		}
	}

	[RuleVersion(0)]
	public BetweenAndOperatorContext betweenAndOperator() {
		BetweenAndOperatorContext _localctx = new BetweenAndOperatorContext(Context, State);
		EnterRule(_localctx, 342, RULE_betweenAndOperator);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2832;
			Match(AND);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComparisonPairOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS_THAN() { return GetToken(OracleAntlrParser.LESS_THAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER_THAN() { return GetToken(OracleAntlrParser.GREATER_THAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BANG() { return GetToken(OracleAntlrParser.BANG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TILDE() { return GetToken(OracleAntlrParser.TILDE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CARET() { return GetToken(OracleAntlrParser.CARET, 0); }
		public ComparisonPairOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comparisonPairOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterComparisonPairOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitComparisonPairOperator(this);
		}
	}

	[RuleVersion(0)]
	public ComparisonPairOperatorContext comparisonPairOperator() {
		ComparisonPairOperatorContext _localctx = new ComparisonPairOperatorContext(Context, State);
		EnterRule(_localctx, 344, RULE_comparisonPairOperator);
		try {
			State = 2849;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,152,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2834;
				Match(LESS_THAN);
				State = 2835;
				Match(GREATER_THAN);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2836;
				Match(BANG);
				State = 2837;
				Match(EQUAL_SIGN);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2838;
				Match(TILDE);
				State = 2839;
				Match(EQUAL_SIGN);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2840;
				Match(GREATER_THAN);
				State = 2841;
				Match(EQUAL_SIGN);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2842;
				Match(LESS_THAN);
				State = 2843;
				Match(EQUAL_SIGN);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2844;
				Match(EQUAL_SIGN);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2845;
				Match(CARET);
				State = 2846;
				Match(EQUAL_SIGN);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2847;
				Match(GREATER_THAN);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2848;
				Match(LESS_THAN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlattenedQueryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public FlattenedQueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flattenedQuery; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFlattenedQuery(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFlattenedQuery(this);
		}
	}

	[RuleVersion(0)]
	public FlattenedQueryContext flattenedQuery() {
		FlattenedQueryContext _localctx = new FlattenedQueryContext(Context, State);
		EnterRule(_localctx, 346, RULE_flattenedQuery);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2851;
			Match(LPAREN);
			State = 2852;
			selectStatement();
			State = 2853;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsFlattenedQueryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public AsFlattenedQueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asFlattenedQuery; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAsFlattenedQuery(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAsFlattenedQuery(this);
		}
	}

	[RuleVersion(0)]
	public AsFlattenedQueryContext asFlattenedQuery() {
		AsFlattenedQueryContext _localctx = new AsFlattenedQueryContext(Context, State);
		EnterRule(_localctx, 348, RULE_asFlattenedQuery);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2855;
			Match(AS);
			State = 2856;
			Match(LPAREN);
			State = 2857;
			selectStatement();
			State = 2858;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlattenedQueryNestedTableContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THE() { return GetToken(OracleAntlrParser.THE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public FlattenedQueryNestedTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flattenedQueryNestedTable; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFlattenedQueryNestedTable(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFlattenedQueryNestedTable(this);
		}
	}

	[RuleVersion(0)]
	public FlattenedQueryNestedTableContext flattenedQueryNestedTable() {
		FlattenedQueryNestedTableContext _localctx = new FlattenedQueryNestedTableContext(Context, State);
		EnterRule(_localctx, 350, RULE_flattenedQueryNestedTable);
		try {
			State = 2873;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case THE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2860;
				Match(THE);
				State = 2861;
				Match(LPAREN);
				State = 2862;
				selectStatement();
				State = 2863;
				Match(RPAREN);
				}
				break;
			case TABLE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2865;
				Match(TABLE);
				State = 2866;
				Match(LPAREN);
				State = 2869;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,153,Context) ) {
				case 1:
					{
					State = 2867;
					selectStatement();
					}
					break;
				case 2:
					{
					State = 2868;
					fullExpression();
					}
					break;
				}
				State = 2871;
				Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionListItemContext[] fullExpressionListItem() {
			return GetRuleContexts<FullExpressionListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionListItemContext fullExpressionListItem(int i) {
			return GetRuleContext<FullExpressionListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public FullExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFullExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFullExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public FullExpressionListContext fullExpressionList() {
		FullExpressionListContext _localctx = new FullExpressionListContext(Context, State);
		EnterRule(_localctx, 352, RULE_fullExpressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2875;
			fullExpressionListItem();
			State = 2880;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2876;
				Match(COMMA);
				State = 2877;
				fullExpressionListItem();
				}
				}
				State = 2882;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullExpressionListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListItemContext expressionListItem() {
			return GetRuleContext<ExpressionListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionListContext fullExpressionList() {
			return GetRuleContext<FullExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public FullExpressionListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullExpressionListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFullExpressionListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFullExpressionListItem(this);
		}
	}

	[RuleVersion(0)]
	public FullExpressionListItemContext fullExpressionListItem() {
		FullExpressionListItemContext _localctx = new FullExpressionListItemContext(Context, State);
		EnterRule(_localctx, 354, RULE_fullExpressionListItem);
		try {
			State = 2888;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,156,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2883;
				expressionListItem();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2884;
				Match(LPAREN);
				State = 2885;
				fullExpressionList();
				State = 2886;
				Match(RPAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListItemContext[] expressionListItem() {
			return GetRuleContexts<ExpressionListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListItemContext expressionListItem(int i) {
			return GetRuleContext<ExpressionListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListContext expressionList() {
		ExpressionListContext _localctx = new ExpressionListContext(Context, State);
		EnterRule(_localctx, 356, RULE_expressionList);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2890;
			expressionListItem();
			State = 2895;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,157,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2891;
					Match(COMMA);
					State = 2892;
					expressionListItem();
					}
					} 
				}
				State = 2897;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,157,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiItemExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListItemContext[] expressionListItem() {
			return GetRuleContexts<ExpressionListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListItemContext expressionListItem(int i) {
			return GetRuleContext<ExpressionListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public MultiItemExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiItemExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMultiItemExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMultiItemExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public MultiItemExpressionListContext multiItemExpressionList() {
		MultiItemExpressionListContext _localctx = new MultiItemExpressionListContext(Context, State);
		EnterRule(_localctx, 358, RULE_multiItemExpressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2898;
			expressionListItem();
			State = 2901;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2899;
				Match(COMMA);
				State = 2900;
				expressionListItem();
				}
				}
				State = 2903;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COMMA );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefaultExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		public DefaultExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defaultExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDefaultExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDefaultExpression(this);
		}
	}

	[RuleVersion(0)]
	public DefaultExpressionContext defaultExpression() {
		DefaultExpressionContext _localctx = new DefaultExpressionContext(Context, State);
		EnterRule(_localctx, 360, RULE_defaultExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2905;
			Match(DEFAULT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultExpressionContext defaultExpression() {
			return GetRuleContext<DefaultExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterNameContext parameterName() {
			return GetRuleContext<ParameterNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AliasContext alias() {
			return GetRuleContext<AliasContext>(0);
		}
		public ExpressionListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExpressionListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExpressionListItem(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListItemContext expressionListItem() {
		ExpressionListItemContext _localctx = new ExpressionListItemContext(Context, State);
		EnterRule(_localctx, 362, RULE_expressionListItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2908;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,159,Context) ) {
			case 1:
				{
				State = 2907;
				parameterName();
				}
				break;
			}
			State = 2912;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CASE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case EXTRACTVALUE:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULL:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYS_CONNECT_BY_PATH:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLCAST:
			case XMLNAMESPACES:
			case XMLQUERY:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case INTEGER_LITERAL:
			case LPAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case QUESTION_MARK:
			case ASTERISK:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
			case QUOTE_CHARACTER_STRING_LITERAL:
				{
				State = 2910;
				fullExpression();
				}
				break;
			case DEFAULT:
				{
				State = 2911;
				defaultExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2915;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,161,Context) ) {
			case 1:
				{
				State = 2914;
				alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlaggExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLAGG() { return GetToken(OracleAntlrParser.XMLAGG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		public XmlaggExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlaggExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlaggExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlaggExpression(this);
		}
	}

	[RuleVersion(0)]
	public XmlaggExpressionContext xmlaggExpression() {
		XmlaggExpressionContext _localctx = new XmlaggExpressionContext(Context, State);
		EnterRule(_localctx, 364, RULE_xmlaggExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2917;
			Match(XMLAGG);
			State = 2918;
			Match(LPAREN);
			State = 2919;
			fullExpression();
			State = 2921;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 2920;
				orderByClause();
				}
			}

			State = 2923;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSOC_OPERATOR() { return GetToken(OracleAntlrParser.ASSOC_OPERATOR, 0); }
		public ParameterNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterParameterName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitParameterName(this);
		}
	}

	[RuleVersion(0)]
	public ParameterNameContext parameterName() {
		ParameterNameContext _localctx = new ParameterNameContext(Context, State);
		EnterRule(_localctx, 366, RULE_parameterName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2925;
			simpleIdentifier();
			State = 2926;
			Match(ASSOC_OPERATOR);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AliasContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		public AliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alias; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlias(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlias(this);
		}
	}

	[RuleVersion(0)]
	public AliasContext alias() {
		AliasContext _localctx = new AliasContext(Context, State);
		EnterRule(_localctx, 368, RULE_alias);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2929;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 2928;
				Match(AS);
				}
			}

			State = 2931;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public IdentifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierList(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierListContext identifierList() {
		IdentifierListContext _localctx = new IdentifierListContext(Context, State);
		EnterRule(_localctx, 370, RULE_identifierList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2933;
			identifier();
			State = 2938;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2934;
				Match(COMMA);
				State = 2935;
				identifier();
				}
				}
				State = 2940;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnListElementClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext[] columnListItem() {
			return GetRuleContexts<ColumnListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem(int i) {
			return GetRuleContext<ColumnListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ColumnListElementClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnListElementClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterColumnListElementClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitColumnListElementClause(this);
		}
	}

	[RuleVersion(0)]
	public ColumnListElementClauseContext columnListElementClause() {
		ColumnListElementClauseContext _localctx = new ColumnListElementClauseContext(Context, State);
		EnterRule(_localctx, 372, RULE_columnListElementClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2941;
			columnListItem();
			State = 2946;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2942;
				Match(COMMA);
				State = 2943;
				columnListItem();
				}
				}
				State = 2948;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public ColumnListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterColumnListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitColumnListItem(this);
		}
	}

	[RuleVersion(0)]
	public ColumnListItemContext columnListItem() {
		ColumnListItemContext _localctx = new ColumnListItemContext(Context, State);
		EnterRule(_localctx, 374, RULE_columnListItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2949;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComplexColumnListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MultipartPlainIdentifierContext multipartPlainIdentifier() {
			return GetRuleContext<MultipartPlainIdentifierContext>(0);
		}
		public ComplexColumnListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_complexColumnListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterComplexColumnListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitComplexColumnListItem(this);
		}
	}

	[RuleVersion(0)]
	public ComplexColumnListItemContext complexColumnListItem() {
		ComplexColumnListItemContext _localctx = new ComplexColumnListItemContext(Context, State);
		EnterRule(_localctx, 376, RULE_complexColumnListItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2951;
			multipartPlainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATE() { return GetToken(OracleAntlrParser.CREATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CreateTableStatementContext createTableStatement() {
			return GetRuleContext<CreateTableStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ViewStatementContext viewStatement() {
			return GetRuleContext<ViewStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewStatementContext materializedViewStatement() {
			return GetRuleContext<MaterializedViewStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateEditionableBatchWideStatementContext createEditionableBatchWideStatement() {
			return GetRuleContext<CreateEditionableBatchWideStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserStatementContext createUserStatement() {
			return GetRuleContext<CreateUserStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateIndexStatementContext createIndexStatement() {
			return GetRuleContext<CreateIndexStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateSequenceStatementContext createSequenceStatement() {
			return GetRuleContext<CreateSequenceStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateStatementReplaceClauseContext createStatementReplaceClause() {
			return GetRuleContext<CreateStatementReplaceClauseContext>(0);
		}
		public CreateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateStatementContext createStatement() {
		CreateStatementContext _localctx = new CreateStatementContext(Context, State);
		EnterRule(_localctx, 378, RULE_createStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2953;
			Match(CREATE);
			State = 2955;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 2954;
				createStatementReplaceClause();
				}
			}

			State = 2964;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,167,Context) ) {
			case 1:
				{
				State = 2957;
				createTableStatement();
				}
				break;
			case 2:
				{
				State = 2958;
				viewStatement();
				}
				break;
			case 3:
				{
				State = 2959;
				materializedViewStatement();
				}
				break;
			case 4:
				{
				State = 2960;
				createEditionableBatchWideStatement();
				}
				break;
			case 5:
				{
				State = 2961;
				createUserStatement();
				}
				break;
			case 6:
				{
				State = 2962;
				createIndexStatement();
				}
				break;
			case 7:
				{
				State = 2963;
				createSequenceStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateStatementReplaceClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(OracleAntlrParser.OR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPLACE() { return GetToken(OracleAntlrParser.REPLACE, 0); }
		public CreateStatementReplaceClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createStatementReplaceClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateStatementReplaceClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateStatementReplaceClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateStatementReplaceClauseContext createStatementReplaceClause() {
		CreateStatementReplaceClauseContext _localctx = new CreateStatementReplaceClauseContext(Context, State);
		EnterRule(_localctx, 380, RULE_createStatementReplaceClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2966;
			Match(OR);
			State = 2967;
			Match(REPLACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(OracleAntlrParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIED() { return GetToken(OracleAntlrParser.IDENTIFIED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserIdentificationClauseContext createUserIdentificationClause() {
			return GetRuleContext<CreateUserIdentificationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserOptionContext[] createUserOption() {
			return GetRuleContexts<CreateUserOptionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserOptionContext createUserOption(int i) {
			return GetRuleContext<CreateUserOptionContext>(i);
		}
		public CreateUserStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserStatementContext createUserStatement() {
		CreateUserStatementContext _localctx = new CreateUserStatementContext(Context, State);
		EnterRule(_localctx, 382, RULE_createUserStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2969;
			Match(USER);
			State = 2970;
			localSimpleIdentifierWithoutParentheses();
			State = 2971;
			Match(IDENTIFIED);
			State = 2972;
			createUserIdentificationClause();
			State = 2976;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ACCOUNT || ((((_la - 92)) & ~0x3f) == 0 && ((1L << (_la - 92)) & ((1L << (CONTAINER - 92)) | (1L << (DEFAULT - 92)) | (1L << (ENABLE - 92)))) != 0) || _la==LOCAL || ((((_la - 383)) & ~0x3f) == 0 && ((1L << (_la - 383)) & ((1L << (PASSWORD - 383)) | (1L << (PROFILE - 383)) | (1L << (QUOTA - 383)))) != 0) || _la==TEMPORARY) {
				{
				{
				State = 2973;
				createUserOption();
				}
				}
				State = 2978;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserIdentificationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserPasswordIdentificationClauseContext createUserPasswordIdentificationClause() {
			return GetRuleContext<CreateUserPasswordIdentificationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserExternalIdentificationClauseContext createUserExternalIdentificationClause() {
			return GetRuleContext<CreateUserExternalIdentificationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserGlobalIdentificationClauseContext createUserGlobalIdentificationClause() {
			return GetRuleContext<CreateUserGlobalIdentificationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserNoAuthenticationClauseContext createUserNoAuthenticationClause() {
			return GetRuleContext<CreateUserNoAuthenticationClauseContext>(0);
		}
		public CreateUserIdentificationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserIdentificationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserIdentificationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserIdentificationClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserIdentificationClauseContext createUserIdentificationClause() {
		CreateUserIdentificationClauseContext _localctx = new CreateUserIdentificationClauseContext(Context, State);
		EnterRule(_localctx, 384, RULE_createUserIdentificationClause);
		try {
			State = 2983;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2979;
				createUserPasswordIdentificationClause();
				}
				break;
			case EXTERNALLY:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2980;
				createUserExternalIdentificationClause();
				}
				break;
			case GLOBALLY:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2981;
				createUserGlobalIdentificationClause();
				}
				break;
			case NO:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2982;
				createUserNoAuthenticationClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserPasswordIdentificationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUES() { return GetToken(OracleAntlrParser.VALUES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharacterStringLiteralContext characterStringLiteral() {
			return GetRuleContext<CharacterStringLiteralContext>(0);
		}
		public CreateUserPasswordIdentificationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserPasswordIdentificationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserPasswordIdentificationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserPasswordIdentificationClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserPasswordIdentificationClauseContext createUserPasswordIdentificationClause() {
		CreateUserPasswordIdentificationClauseContext _localctx = new CreateUserPasswordIdentificationClauseContext(Context, State);
		EnterRule(_localctx, 386, RULE_createUserPasswordIdentificationClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2985;
			Match(BY);
			State = 2989;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 2986;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			case VALUES:
				{
				State = 2987;
				Match(VALUES);
				State = 2988;
				characterStringLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserExternalIdentificationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTERNALLY() { return GetToken(OracleAntlrParser.EXTERNALLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharacterStringLiteralContext characterStringLiteral() {
			return GetRuleContext<CharacterStringLiteralContext>(0);
		}
		public CreateUserExternalIdentificationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserExternalIdentificationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserExternalIdentificationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserExternalIdentificationClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserExternalIdentificationClauseContext createUserExternalIdentificationClause() {
		CreateUserExternalIdentificationClauseContext _localctx = new CreateUserExternalIdentificationClauseContext(Context, State);
		EnterRule(_localctx, 388, RULE_createUserExternalIdentificationClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2991;
			Match(EXTERNALLY);
			State = 2994;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 2992;
				Match(AS);
				State = 2993;
				characterStringLiteral();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserGlobalIdentificationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GLOBALLY() { return GetToken(OracleAntlrParser.GLOBALLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharacterStringLiteralContext characterStringLiteral() {
			return GetRuleContext<CharacterStringLiteralContext>(0);
		}
		public CreateUserGlobalIdentificationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserGlobalIdentificationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserGlobalIdentificationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserGlobalIdentificationClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserGlobalIdentificationClauseContext createUserGlobalIdentificationClause() {
		CreateUserGlobalIdentificationClauseContext _localctx = new CreateUserGlobalIdentificationClauseContext(Context, State);
		EnterRule(_localctx, 390, RULE_createUserGlobalIdentificationClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2996;
			Match(GLOBALLY);
			State = 2999;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 2997;
				Match(AS);
				State = 2998;
				characterStringLiteral();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserNoAuthenticationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NO() { return GetToken(OracleAntlrParser.NO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTHENTICATION() { return GetToken(OracleAntlrParser.AUTHENTICATION, 0); }
		public CreateUserNoAuthenticationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserNoAuthenticationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserNoAuthenticationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserNoAuthenticationClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserNoAuthenticationClauseContext createUserNoAuthenticationClause() {
		CreateUserNoAuthenticationClauseContext _localctx = new CreateUserNoAuthenticationClauseContext(Context, State);
		EnterRule(_localctx, 392, RULE_createUserNoAuthenticationClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3001;
			Match(NO);
			State = 3002;
			Match(AUTHENTICATION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DefaultCollationOptionContext defaultCollationOption() {
			return GetRuleContext<DefaultCollationOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserDefaultTablespaceOptionContext createUserDefaultTablespaceOption() {
			return GetRuleContext<CreateUserDefaultTablespaceOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserTemporaryTablespaceOptionContext createUserTemporaryTablespaceOption() {
			return GetRuleContext<CreateUserTemporaryTablespaceOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserTablespaceQuotaOptionContext createUserTablespaceQuotaOption() {
			return GetRuleContext<CreateUserTablespaceQuotaOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserProfileOptionContext createUserProfileOption() {
			return GetRuleContext<CreateUserProfileOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserPasswordExpireOptionContext createUserPasswordExpireOption() {
			return GetRuleContext<CreateUserPasswordExpireOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserAccountOptionContext createUserAccountOption() {
			return GetRuleContext<CreateUserAccountOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserEnableEditionsOptionContext createUserEnableEditionsOption() {
			return GetRuleContext<CreateUserEnableEditionsOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserContainerOptionContext createUserContainerOption() {
			return GetRuleContext<CreateUserContainerOptionContext>(0);
		}
		public CreateUserOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserOptionContext createUserOption() {
		CreateUserOptionContext _localctx = new CreateUserOptionContext(Context, State);
		EnterRule(_localctx, 394, RULE_createUserOption);
		try {
			State = 3013;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,173,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3004;
				defaultCollationOption();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3005;
				createUserDefaultTablespaceOption();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3006;
				createUserTemporaryTablespaceOption();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3007;
				createUserTablespaceQuotaOption();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3008;
				createUserProfileOption();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 3009;
				createUserPasswordExpireOption();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 3010;
				createUserAccountOption();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 3011;
				createUserEnableEditionsOption();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 3012;
				createUserContainerOption();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefaultCollationOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLLATION() { return GetToken(OracleAntlrParser.COLLATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public DefaultCollationOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defaultCollationOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDefaultCollationOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDefaultCollationOption(this);
		}
	}

	[RuleVersion(0)]
	public DefaultCollationOptionContext defaultCollationOption() {
		DefaultCollationOptionContext _localctx = new DefaultCollationOptionContext(Context, State);
		EnterRule(_localctx, 396, RULE_defaultCollationOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3015;
			Match(DEFAULT);
			State = 3016;
			Match(COLLATION);
			State = 3017;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserDefaultTablespaceOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLESPACE() { return GetToken(OracleAntlrParser.TABLESPACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public CreateUserDefaultTablespaceOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserDefaultTablespaceOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserDefaultTablespaceOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserDefaultTablespaceOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserDefaultTablespaceOptionContext createUserDefaultTablespaceOption() {
		CreateUserDefaultTablespaceOptionContext _localctx = new CreateUserDefaultTablespaceOptionContext(Context, State);
		EnterRule(_localctx, 398, RULE_createUserDefaultTablespaceOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3019;
			Match(DEFAULT);
			State = 3020;
			Match(TABLESPACE);
			State = 3021;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserTemporaryTablespaceOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEMPORARY() { return GetToken(OracleAntlrParser.TEMPORARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLESPACE() { return GetToken(OracleAntlrParser.TABLESPACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(OracleAntlrParser.LOCAL, 0); }
		public CreateUserTemporaryTablespaceOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserTemporaryTablespaceOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserTemporaryTablespaceOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserTemporaryTablespaceOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserTemporaryTablespaceOptionContext createUserTemporaryTablespaceOption() {
		CreateUserTemporaryTablespaceOptionContext _localctx = new CreateUserTemporaryTablespaceOptionContext(Context, State);
		EnterRule(_localctx, 400, RULE_createUserTemporaryTablespaceOption);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3024;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOCAL) {
				{
				State = 3023;
				Match(LOCAL);
				}
			}

			State = 3026;
			Match(TEMPORARY);
			State = 3027;
			Match(TABLESPACE);
			State = 3028;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserTablespaceQuotaOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTA() { return GetToken(OracleAntlrParser.QUOTA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNLIMITED() { return GetToken(OracleAntlrParser.UNLIMITED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ByteSizeLiteralContext byteSizeLiteral() {
			return GetRuleContext<ByteSizeLiteralContext>(0);
		}
		public CreateUserTablespaceQuotaOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserTablespaceQuotaOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserTablespaceQuotaOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserTablespaceQuotaOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserTablespaceQuotaOptionContext createUserTablespaceQuotaOption() {
		CreateUserTablespaceQuotaOptionContext _localctx = new CreateUserTablespaceQuotaOptionContext(Context, State);
		EnterRule(_localctx, 402, RULE_createUserTablespaceQuotaOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3030;
			Match(QUOTA);
			State = 3033;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNLIMITED:
				{
				State = 3031;
				Match(UNLIMITED);
				}
				break;
			case INTEGER_LITERAL:
			case BYTE_SIZE_LITERAL:
				{
				State = 3032;
				byteSizeLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3035;
			Match(ON);
			State = 3036;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserProfileOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROFILE() { return GetToken(OracleAntlrParser.PROFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public CreateUserProfileOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserProfileOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserProfileOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserProfileOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserProfileOptionContext createUserProfileOption() {
		CreateUserProfileOptionContext _localctx = new CreateUserProfileOptionContext(Context, State);
		EnterRule(_localctx, 404, RULE_createUserProfileOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3038;
			Match(PROFILE);
			State = 3039;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserPasswordExpireOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORD() { return GetToken(OracleAntlrParser.PASSWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXPIRE() { return GetToken(OracleAntlrParser.EXPIRE, 0); }
		public CreateUserPasswordExpireOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserPasswordExpireOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserPasswordExpireOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserPasswordExpireOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserPasswordExpireOptionContext createUserPasswordExpireOption() {
		CreateUserPasswordExpireOptionContext _localctx = new CreateUserPasswordExpireOptionContext(Context, State);
		EnterRule(_localctx, 406, RULE_createUserPasswordExpireOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3041;
			Match(PASSWORD);
			State = 3042;
			Match(EXPIRE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserAccountOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ACCOUNT() { return GetToken(OracleAntlrParser.ACCOUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCK() { return GetToken(OracleAntlrParser.LOCK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNLOCK() { return GetToken(OracleAntlrParser.UNLOCK, 0); }
		public CreateUserAccountOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserAccountOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserAccountOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserAccountOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserAccountOptionContext createUserAccountOption() {
		CreateUserAccountOptionContext _localctx = new CreateUserAccountOptionContext(Context, State);
		EnterRule(_localctx, 408, RULE_createUserAccountOption);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3044;
			Match(ACCOUNT);
			State = 3045;
			_la = TokenStream.LA(1);
			if ( !(_la==LOCK || _la==UNLOCK) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserEnableEditionsOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITIONS() { return GetToken(OracleAntlrParser.EDITIONS, 0); }
		public CreateUserEnableEditionsOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserEnableEditionsOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserEnableEditionsOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserEnableEditionsOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserEnableEditionsOptionContext createUserEnableEditionsOption() {
		CreateUserEnableEditionsOptionContext _localctx = new CreateUserEnableEditionsOptionContext(Context, State);
		EnterRule(_localctx, 410, RULE_createUserEnableEditionsOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3047;
			Match(ENABLE);
			State = 3048;
			Match(EDITIONS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserContainerOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTAINER() { return GetToken(OracleAntlrParser.CONTAINER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(OracleAntlrParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		public CreateUserContainerOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserContainerOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateUserContainerOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateUserContainerOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserContainerOptionContext createUserContainerOption() {
		CreateUserContainerOptionContext _localctx = new CreateUserContainerOptionContext(Context, State);
		EnterRule(_localctx, 412, RULE_createUserContainerOption);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3050;
			Match(CONTAINER);
			State = 3051;
			Match(EQUAL_SIGN);
			State = 3052;
			_la = TokenStream.LA(1);
			if ( !(_la==ALL || _la==CURRENT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateIndexStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ClusterIndexClauseContext clusterIndexClause() {
			return GetRuleContext<ClusterIndexClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableIndexClauseContext tableIndexClause() {
			return GetRuleContext<TableIndexClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BitmapJoinIndexClauseContext bitmapJoinIndexClause() {
			return GetRuleContext<BitmapJoinIndexClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALIDATION() { return GetToken(OracleAntlrParser.INVALIDATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUE() { return GetToken(OracleAntlrParser.UNIQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BITMAP() { return GetToken(OracleAntlrParser.BITMAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USABLE() { return GetToken(OracleAntlrParser.USABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFERRED() { return GetToken(OracleAntlrParser.DEFERRED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMEDIATE() { return GetToken(OracleAntlrParser.IMMEDIATE, 0); }
		public CreateIndexStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createIndexStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateIndexStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateIndexStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateIndexStatementContext createIndexStatement() {
		CreateIndexStatementContext _localctx = new CreateIndexStatementContext(Context, State);
		EnterRule(_localctx, 414, RULE_createIndexStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3055;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BITMAP || _la==UNIQUE) {
				{
				State = 3054;
				_la = TokenStream.LA(1);
				if ( !(_la==BITMAP || _la==UNIQUE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3057;
			Match(INDEX);
			State = 3058;
			plainIdentifier();
			State = 3059;
			Match(ON);
			State = 3063;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,177,Context) ) {
			case 1:
				{
				State = 3060;
				clusterIndexClause();
				}
				break;
			case 2:
				{
				State = 3061;
				tableIndexClause();
				}
				break;
			case 3:
				{
				State = 3062;
				bitmapJoinIndexClause();
				}
				break;
			}
			State = 3066;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNUSABLE || _la==USABLE) {
				{
				State = 3065;
				_la = TokenStream.LA(1);
				if ( !(_la==UNUSABLE || _la==USABLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3070;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFERRED || _la==IMMEDIATE) {
				{
				State = 3068;
				_la = TokenStream.LA(1);
				if ( !(_la==DEFERRED || _la==IMMEDIATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3069;
				Match(INVALIDATION);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ClusterIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLUSTER() { return GetToken(OracleAntlrParser.CLUSTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexAttributeContext[] indexAttribute() {
			return GetRuleContexts<IndexAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexAttributeContext indexAttribute(int i) {
			return GetRuleContext<IndexAttributeContext>(i);
		}
		public ClusterIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_clusterIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterClusterIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitClusterIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public ClusterIndexClauseContext clusterIndexClause() {
		ClusterIndexClauseContext _localctx = new ClusterIndexClauseContext(Context, State);
		EnterRule(_localctx, 416, RULE_clusterIndexClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3072;
			Match(CLUSTER);
			State = 3073;
			plainIdentifier();
			State = 3077;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMPRESS || _la==COMPUTE || ((((_la - 181)) & ~0x3f) == 0 && ((1L << (_la - 181)) & ((1L << (FILESYSTEM_LIKE_LOGGING - 181)) | (1L << (INDEXING - 181)) | (1L << (INITRANS - 181)) | (1L << (INVISIBLE - 181)))) != 0) || ((((_la - 276)) & ~0x3f) == 0 && ((1L << (_la - 276)) & ((1L << (LOGGING - 276)) | (1L << (MAXTRANS - 276)) | (1L << (NOCOMPRESS - 276)) | (1L << (NOLOGGING - 276)) | (1L << (NOPARALLEL - 276)))) != 0) || ((((_la - 343)) & ~0x3f) == 0 && ((1L << (_la - 343)) & ((1L << (NOSORT - 343)) | (1L << (ONLINE - 343)) | (1L << (PARALLEL - 343)) | (1L << (PCTFREE - 343)) | (1L << (PCTUSED - 343)))) != 0) || ((((_la - 437)) & ~0x3f) == 0 && ((1L << (_la - 437)) & ((1L << (REVERSE - 437)) | (1L << (SORT - 437)) | (1L << (STORAGE - 437)))) != 0) || _la==TABLESPACE || _la==VISIBLE) {
				{
				{
				State = 3074;
				indexAttribute();
				}
				}
				State = 3079;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TableIndexExpressionContext[] tableIndexExpression() {
			return GetRuleContexts<TableIndexExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableIndexExpressionContext tableIndexExpression(int i) {
			return GetRuleContext<TableIndexExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleAliasIdentifierContext simpleAliasIdentifier() {
			return GetRuleContext<SimpleAliasIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexPropertiesContext indexProperties() {
			return GetRuleContext<IndexPropertiesContext>(0);
		}
		public TableIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTableIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTableIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public TableIndexClauseContext tableIndexClause() {
		TableIndexClauseContext _localctx = new TableIndexClauseContext(Context, State);
		EnterRule(_localctx, 418, RULE_tableIndexClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3080;
			plainIdentifier();
			State = 3082;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 3081;
				simpleAliasIdentifier();
				}
			}

			State = 3084;
			Match(LPAREN);
			State = 3085;
			tableIndexExpression();
			State = 3090;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3086;
				Match(COMMA);
				State = 3087;
				tableIndexExpression();
				}
				}
				State = 3092;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3093;
			Match(RPAREN);
			State = 3095;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMPRESS || _la==COMPUTE || ((((_la - 181)) & ~0x3f) == 0 && ((1L << (_la - 181)) & ((1L << (FILESYSTEM_LIKE_LOGGING - 181)) | (1L << (GLOBAL - 181)) | (1L << (INDEXING - 181)) | (1L << (INDEXTYPE - 181)) | (1L << (INITRANS - 181)) | (1L << (INVISIBLE - 181)))) != 0) || ((((_la - 270)) & ~0x3f) == 0 && ((1L << (_la - 270)) & ((1L << (LOCAL - 270)) | (1L << (LOGGING - 270)) | (1L << (MAXTRANS - 270)) | (1L << (NOCOMPRESS - 270)) | (1L << (NOLOGGING - 270)))) != 0) || ((((_la - 337)) & ~0x3f) == 0 && ((1L << (_la - 337)) & ((1L << (NOPARALLEL - 337)) | (1L << (NOSORT - 337)) | (1L << (ONLINE - 337)) | (1L << (PARALLEL - 337)) | (1L << (PCTFREE - 337)) | (1L << (PCTUSED - 337)))) != 0) || ((((_la - 437)) & ~0x3f) == 0 && ((1L << (_la - 437)) & ((1L << (REVERSE - 437)) | (1L << (SORT - 437)) | (1L << (STORAGE - 437)) | (1L << (STORE - 437)))) != 0) || _la==TABLESPACE || _la==VISIBLE || _la==LPAREN) {
				{
				State = 3094;
				indexProperties();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableIndexExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASC() { return GetToken(OracleAntlrParser.ASC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DESC() { return GetToken(OracleAntlrParser.DESC, 0); }
		public TableIndexExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableIndexExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTableIndexExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTableIndexExpression(this);
		}
	}

	[RuleVersion(0)]
	public TableIndexExpressionContext tableIndexExpression() {
		TableIndexExpressionContext _localctx = new TableIndexExpressionContext(Context, State);
		EnterRule(_localctx, 420, RULE_tableIndexExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3097;
			fullExpression();
			State = 3099;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASC || _la==DESC) {
				{
				State = 3098;
				_la = TokenStream.LA(1);
				if ( !(_la==ASC || _la==DESC) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BitmapJoinIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BitmapJoinIndexExpressionContext bitmapJoinIndexExpression() {
			return GetRuleContext<BitmapJoinIndexExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(OracleAntlrParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BitmapJoinIndexFromClauseItemContext[] bitmapJoinIndexFromClauseItem() {
			return GetRuleContexts<BitmapJoinIndexFromClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BitmapJoinIndexFromClauseItemContext bitmapJoinIndexFromClauseItem(int i) {
			return GetRuleContext<BitmapJoinIndexFromClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LocalPartitionedIndexContext localPartitionedIndex() {
			return GetRuleContext<LocalPartitionedIndexContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexAttributeContext[] indexAttribute() {
			return GetRuleContexts<IndexAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexAttributeContext indexAttribute(int i) {
			return GetRuleContext<IndexAttributeContext>(i);
		}
		public BitmapJoinIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitmapJoinIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBitmapJoinIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBitmapJoinIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public BitmapJoinIndexClauseContext bitmapJoinIndexClause() {
		BitmapJoinIndexClauseContext _localctx = new BitmapJoinIndexClauseContext(Context, State);
		EnterRule(_localctx, 422, RULE_bitmapJoinIndexClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3101;
			plainIdentifier();
			State = 3102;
			Match(LPAREN);
			State = 3103;
			bitmapJoinIndexExpression();
			State = 3104;
			Match(RPAREN);
			State = 3105;
			Match(FROM);
			State = 3106;
			bitmapJoinIndexFromClauseItem();
			State = 3111;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3107;
				Match(COMMA);
				State = 3108;
				bitmapJoinIndexFromClauseItem();
				}
				}
				State = 3113;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3114;
			whereClause();
			State = 3116;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOCAL || _la==STORE || _la==LPAREN) {
				{
				State = 3115;
				localPartitionedIndex();
				}
			}

			State = 3121;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMPRESS || _la==COMPUTE || ((((_la - 181)) & ~0x3f) == 0 && ((1L << (_la - 181)) & ((1L << (FILESYSTEM_LIKE_LOGGING - 181)) | (1L << (INDEXING - 181)) | (1L << (INITRANS - 181)) | (1L << (INVISIBLE - 181)))) != 0) || ((((_la - 276)) & ~0x3f) == 0 && ((1L << (_la - 276)) & ((1L << (LOGGING - 276)) | (1L << (MAXTRANS - 276)) | (1L << (NOCOMPRESS - 276)) | (1L << (NOLOGGING - 276)) | (1L << (NOPARALLEL - 276)))) != 0) || ((((_la - 343)) & ~0x3f) == 0 && ((1L << (_la - 343)) & ((1L << (NOSORT - 343)) | (1L << (ONLINE - 343)) | (1L << (PARALLEL - 343)) | (1L << (PCTFREE - 343)) | (1L << (PCTUSED - 343)))) != 0) || ((((_la - 437)) & ~0x3f) == 0 && ((1L << (_la - 437)) & ((1L << (REVERSE - 437)) | (1L << (SORT - 437)) | (1L << (STORAGE - 437)))) != 0) || _la==TABLESPACE || _la==VISIBLE) {
				{
				{
				State = 3118;
				indexAttribute();
				}
				}
				State = 3123;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BitmapJoinIndexExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASC() { return GetToken(OracleAntlrParser.ASC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DESC() { return GetToken(OracleAntlrParser.DESC, 0); }
		public BitmapJoinIndexExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitmapJoinIndexExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBitmapJoinIndexExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBitmapJoinIndexExpression(this);
		}
	}

	[RuleVersion(0)]
	public BitmapJoinIndexExpressionContext bitmapJoinIndexExpression() {
		BitmapJoinIndexExpressionContext _localctx = new BitmapJoinIndexExpressionContext(Context, State);
		EnterRule(_localctx, 424, RULE_bitmapJoinIndexExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3124;
			plainIdentifier();
			State = 3126;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASC || _la==DESC) {
				{
				State = 3125;
				_la = TokenStream.LA(1);
				if ( !(_la==ASC || _la==DESC) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BitmapJoinIndexFromClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleAliasIdentifierContext simpleAliasIdentifier() {
			return GetRuleContext<SimpleAliasIdentifierContext>(0);
		}
		public BitmapJoinIndexFromClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitmapJoinIndexFromClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBitmapJoinIndexFromClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBitmapJoinIndexFromClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public BitmapJoinIndexFromClauseItemContext bitmapJoinIndexFromClauseItem() {
		BitmapJoinIndexFromClauseItemContext _localctx = new BitmapJoinIndexFromClauseItemContext(Context, State);
		EnterRule(_localctx, 426, RULE_bitmapJoinIndexFromClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3128;
			plainIdentifier();
			State = 3130;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 3129;
				simpleAliasIdentifier();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GlobalPartitionedIndexContext[] globalPartitionedIndex() {
			return GetRuleContexts<GlobalPartitionedIndexContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public GlobalPartitionedIndexContext globalPartitionedIndex(int i) {
			return GetRuleContext<GlobalPartitionedIndexContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LocalPartitionedIndexContext[] localPartitionedIndex() {
			return GetRuleContexts<LocalPartitionedIndexContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LocalPartitionedIndexContext localPartitionedIndex(int i) {
			return GetRuleContext<LocalPartitionedIndexContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexAttributeContext[] indexAttribute() {
			return GetRuleContexts<IndexAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexAttributeContext indexAttribute(int i) {
			return GetRuleContext<IndexAttributeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexTypeClauseContext indexTypeClause() {
			return GetRuleContext<IndexTypeClauseContext>(0);
		}
		public IndexPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexProperties(this);
		}
	}

	[RuleVersion(0)]
	public IndexPropertiesContext indexProperties() {
		IndexPropertiesContext _localctx = new IndexPropertiesContext(Context, State);
		EnterRule(_localctx, 428, RULE_indexProperties);
		int _la;
		try {
			State = 3140;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPRESS:
			case COMPUTE:
			case FILESYSTEM_LIKE_LOGGING:
			case GLOBAL:
			case INDEXING:
			case INITRANS:
			case INVISIBLE:
			case LOCAL:
			case LOGGING:
			case MAXTRANS:
			case NOCOMPRESS:
			case NOLOGGING:
			case NOPARALLEL:
			case NOSORT:
			case ONLINE:
			case PARALLEL:
			case PCTFREE:
			case PCTUSED:
			case REVERSE:
			case SORT:
			case STORAGE:
			case STORE:
			case TABLESPACE:
			case VISIBLE:
			case LPAREN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3135;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					State = 3135;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case GLOBAL:
						{
						State = 3132;
						globalPartitionedIndex();
						}
						break;
					case LOCAL:
					case STORE:
					case LPAREN:
						{
						State = 3133;
						localPartitionedIndex();
						}
						break;
					case COMPRESS:
					case COMPUTE:
					case FILESYSTEM_LIKE_LOGGING:
					case INDEXING:
					case INITRANS:
					case INVISIBLE:
					case LOGGING:
					case MAXTRANS:
					case NOCOMPRESS:
					case NOLOGGING:
					case NOPARALLEL:
					case NOSORT:
					case ONLINE:
					case PARALLEL:
					case PCTFREE:
					case PCTUSED:
					case REVERSE:
					case SORT:
					case STORAGE:
					case TABLESPACE:
					case VISIBLE:
						{
						State = 3134;
						indexAttribute();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 3137;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==COMPRESS || _la==COMPUTE || ((((_la - 181)) & ~0x3f) == 0 && ((1L << (_la - 181)) & ((1L << (FILESYSTEM_LIKE_LOGGING - 181)) | (1L << (GLOBAL - 181)) | (1L << (INDEXING - 181)) | (1L << (INITRANS - 181)) | (1L << (INVISIBLE - 181)))) != 0) || ((((_la - 270)) & ~0x3f) == 0 && ((1L << (_la - 270)) & ((1L << (LOCAL - 270)) | (1L << (LOGGING - 270)) | (1L << (MAXTRANS - 270)) | (1L << (NOCOMPRESS - 270)) | (1L << (NOLOGGING - 270)))) != 0) || ((((_la - 337)) & ~0x3f) == 0 && ((1L << (_la - 337)) & ((1L << (NOPARALLEL - 337)) | (1L << (NOSORT - 337)) | (1L << (ONLINE - 337)) | (1L << (PARALLEL - 337)) | (1L << (PCTFREE - 337)) | (1L << (PCTUSED - 337)))) != 0) || ((((_la - 437)) & ~0x3f) == 0 && ((1L << (_la - 437)) & ((1L << (REVERSE - 437)) | (1L << (SORT - 437)) | (1L << (STORAGE - 437)) | (1L << (STORE - 437)))) != 0) || _la==TABLESPACE || _la==VISIBLE || _la==LPAREN );
				}
				break;
			case INDEXTYPE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3139;
				indexTypeClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GlobalPartitionedIndexContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GLOBAL() { return GetToken(OracleAntlrParser.GLOBAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartitioningDefinitionClauseContext partitioningDefinitionClause() {
			return GetRuleContext<PartitioningDefinitionClauseContext>(0);
		}
		public GlobalPartitionedIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_globalPartitionedIndex; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGlobalPartitionedIndex(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGlobalPartitionedIndex(this);
		}
	}

	[RuleVersion(0)]
	public GlobalPartitionedIndexContext globalPartitionedIndex() {
		GlobalPartitionedIndexContext _localctx = new GlobalPartitionedIndexContext(Context, State);
		EnterRule(_localctx, 430, RULE_globalPartitionedIndex);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3142;
			Match(GLOBAL);
			State = 3143;
			partitioningDefinitionClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LocalPartitionedIndexContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(OracleAntlrParser.LOCAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnSimplePartitionedTableClauseContext indexOnSimplePartitionedTableClause() {
			return GetRuleContext<IndexOnSimplePartitionedTableClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnHashPartitionedTableContext indexOnHashPartitionedTable() {
			return GetRuleContext<IndexOnHashPartitionedTableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnCompPartitionedTableContext indexOnCompPartitionedTable() {
			return GetRuleContext<IndexOnCompPartitionedTableContext>(0);
		}
		public LocalPartitionedIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_localPartitionedIndex; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLocalPartitionedIndex(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLocalPartitionedIndex(this);
		}
	}

	[RuleVersion(0)]
	public LocalPartitionedIndexContext localPartitionedIndex() {
		LocalPartitionedIndexContext _localctx = new LocalPartitionedIndexContext(Context, State);
		EnterRule(_localctx, 432, RULE_localPartitionedIndex);
		try {
			State = 3149;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,193,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3145;
				Match(LOCAL);
				State = 3146;
				indexOnSimplePartitionedTableClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3147;
				indexOnHashPartitionedTable();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3148;
				indexOnCompPartitionedTable();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOnSimplePartitionedTableClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnSimplePartitionedTableClauseItemContext[] indexOnSimplePartitionedTableClauseItem() {
			return GetRuleContexts<IndexOnSimplePartitionedTableClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnSimplePartitionedTableClauseItemContext indexOnSimplePartitionedTableClauseItem(int i) {
			return GetRuleContext<IndexOnSimplePartitionedTableClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public IndexOnSimplePartitionedTableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOnSimplePartitionedTableClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexOnSimplePartitionedTableClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexOnSimplePartitionedTableClause(this);
		}
	}

	[RuleVersion(0)]
	public IndexOnSimplePartitionedTableClauseContext indexOnSimplePartitionedTableClause() {
		IndexOnSimplePartitionedTableClauseContext _localctx = new IndexOnSimplePartitionedTableClauseContext(Context, State);
		EnterRule(_localctx, 434, RULE_indexOnSimplePartitionedTableClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3151;
			Match(LPAREN);
			State = 3152;
			indexOnSimplePartitionedTableClauseItem();
			State = 3157;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3153;
				Match(COMMA);
				State = 3154;
				indexOnSimplePartitionedTableClauseItem();
				}
				}
				State = 3159;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3160;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOnSimplePartitionedTableClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseContext[] segmentAttributesClause() {
			return GetRuleContexts<SegmentAttributesClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseContext segmentAttributesClause(int i) {
			return GetRuleContext<SegmentAttributesClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionClauseContext[] indexCompressionClause() {
			return GetRuleContexts<IndexCompressionClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionClauseContext indexCompressionClause(int i) {
			return GetRuleContext<IndexCompressionClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USABLE() { return GetToken(OracleAntlrParser.USABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		public IndexOnSimplePartitionedTableClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOnSimplePartitionedTableClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexOnSimplePartitionedTableClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexOnSimplePartitionedTableClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public IndexOnSimplePartitionedTableClauseItemContext indexOnSimplePartitionedTableClauseItem() {
		IndexOnSimplePartitionedTableClauseItemContext _localctx = new IndexOnSimplePartitionedTableClauseItemContext(Context, State);
		EnterRule(_localctx, 436, RULE_indexOnSimplePartitionedTableClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3162;
			Match(PARTITION);
			State = 3164;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,195,Context) ) {
			case 1:
				{
				State = 3163;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			}
			State = 3170;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 276)) & ~0x3f) == 0 && ((1L << (_la - 276)) & ((1L << (LOGGING - 276)) | (1L << (MAXTRANS - 276)) | (1L << (NOCOMPRESS - 276)) | (1L << (NOLOGGING - 276)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
				{
				State = 3168;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case FILESYSTEM_LIKE_LOGGING:
				case INITRANS:
				case LOGGING:
				case MAXTRANS:
				case NOLOGGING:
				case PCTFREE:
				case PCTUSED:
				case STORAGE:
				case TABLESPACE:
					{
					State = 3166;
					segmentAttributesClause();
					}
					break;
				case COMPRESS:
				case NOCOMPRESS:
					{
					State = 3167;
					indexCompressionClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 3172;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3174;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNUSABLE || _la==USABLE) {
				{
				State = 3173;
				_la = TokenStream.LA(1);
				if ( !(_la==UNUSABLE || _la==USABLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOnHashPartitionedTableContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsStoreInClauseContext partitionsStoreInClause() {
			return GetRuleContext<PartitionsStoreInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnHashPartitionedTableClauseItemContext[] indexOnHashPartitionedTableClauseItem() {
			return GetRuleContexts<IndexOnHashPartitionedTableClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnHashPartitionedTableClauseItemContext indexOnHashPartitionedTableClauseItem(int i) {
			return GetRuleContext<IndexOnHashPartitionedTableClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public IndexOnHashPartitionedTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOnHashPartitionedTable; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexOnHashPartitionedTable(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexOnHashPartitionedTable(this);
		}
	}

	[RuleVersion(0)]
	public IndexOnHashPartitionedTableContext indexOnHashPartitionedTable() {
		IndexOnHashPartitionedTableContext _localctx = new IndexOnHashPartitionedTableContext(Context, State);
		EnterRule(_localctx, 438, RULE_indexOnHashPartitionedTable);
		int _la;
		try {
			State = 3188;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STORE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3176;
				partitionsStoreInClause();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3177;
				Match(LPAREN);
				State = 3178;
				indexOnHashPartitionedTableClauseItem();
				State = 3183;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3179;
					Match(COMMA);
					State = 3180;
					indexOnHashPartitionedTableClauseItem();
					}
					}
					State = 3185;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3186;
				Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOnHashPartitionedTableClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USABLE() { return GetToken(OracleAntlrParser.USABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleTablespaceClauseContext simpleTablespaceClause() {
			return GetRuleContext<SimpleTablespaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionClauseContext indexCompressionClause() {
			return GetRuleContext<IndexCompressionClauseContext>(0);
		}
		public IndexOnHashPartitionedTableClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOnHashPartitionedTableClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexOnHashPartitionedTableClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexOnHashPartitionedTableClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public IndexOnHashPartitionedTableClauseItemContext indexOnHashPartitionedTableClauseItem() {
		IndexOnHashPartitionedTableClauseItemContext _localctx = new IndexOnHashPartitionedTableClauseItemContext(Context, State);
		EnterRule(_localctx, 440, RULE_indexOnHashPartitionedTableClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3190;
			Match(PARTITION);
			State = 3192;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,201,Context) ) {
			case 1:
				{
				State = 3191;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			}
			State = 3195;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLESPACE) {
				{
				State = 3194;
				simpleTablespaceClause();
				}
			}

			State = 3198;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMPRESS || _la==NOCOMPRESS) {
				{
				State = 3197;
				indexCompressionClause();
				}
			}

			State = 3200;
			_la = TokenStream.LA(1);
			if ( !(_la==UNUSABLE || _la==USABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOnCompPartitionedTableContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnCompPartitionedTableClauseItemContext[] indexOnCompPartitionedTableClauseItem() {
			return GetRuleContexts<IndexOnCompPartitionedTableClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnCompPartitionedTableClauseItemContext indexOnCompPartitionedTableClauseItem(int i) {
			return GetRuleContext<IndexOnCompPartitionedTableClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsStoreInClauseContext partitionsStoreInClause() {
			return GetRuleContext<PartitionsStoreInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public IndexOnCompPartitionedTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOnCompPartitionedTable; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexOnCompPartitionedTable(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexOnCompPartitionedTable(this);
		}
	}

	[RuleVersion(0)]
	public IndexOnCompPartitionedTableContext indexOnCompPartitionedTable() {
		IndexOnCompPartitionedTableContext _localctx = new IndexOnCompPartitionedTableContext(Context, State);
		EnterRule(_localctx, 442, RULE_indexOnCompPartitionedTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3203;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STORE) {
				{
				State = 3202;
				partitionsStoreInClause();
				}
			}

			State = 3205;
			Match(LPAREN);
			State = 3206;
			indexOnCompPartitionedTableClauseItem();
			State = 3211;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3207;
				Match(COMMA);
				State = 3208;
				indexOnCompPartitionedTableClauseItem();
				}
				}
				State = 3213;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3214;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOnCompPartitionedTableClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnSimplePartitionedTableClauseItemContext indexOnSimplePartitionedTableClauseItem() {
			return GetRuleContext<IndexOnSimplePartitionedTableClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexSubpartitionClauseContext indexSubpartitionClause() {
			return GetRuleContext<IndexSubpartitionClauseContext>(0);
		}
		public IndexOnCompPartitionedTableClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOnCompPartitionedTableClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexOnCompPartitionedTableClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexOnCompPartitionedTableClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public IndexOnCompPartitionedTableClauseItemContext indexOnCompPartitionedTableClauseItem() {
		IndexOnCompPartitionedTableClauseItemContext _localctx = new IndexOnCompPartitionedTableClauseItemContext(Context, State);
		EnterRule(_localctx, 444, RULE_indexOnCompPartitionedTableClauseItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3216;
			indexOnSimplePartitionedTableClauseItem();
			State = 3217;
			indexSubpartitionClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexSubpartitionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsStoreInClauseContext partitionsStoreInClause() {
			return GetRuleContext<PartitionsStoreInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexSubpartitionClauseItemContext[] indexSubpartitionClauseItem() {
			return GetRuleContexts<IndexSubpartitionClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexSubpartitionClauseItemContext indexSubpartitionClauseItem(int i) {
			return GetRuleContext<IndexSubpartitionClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public IndexSubpartitionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexSubpartitionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexSubpartitionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexSubpartitionClause(this);
		}
	}

	[RuleVersion(0)]
	public IndexSubpartitionClauseContext indexSubpartitionClause() {
		IndexSubpartitionClauseContext _localctx = new IndexSubpartitionClauseContext(Context, State);
		EnterRule(_localctx, 446, RULE_indexSubpartitionClause);
		int _la;
		try {
			State = 3231;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STORE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3219;
				partitionsStoreInClause();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3220;
				Match(LPAREN);
				State = 3221;
				indexSubpartitionClauseItem();
				State = 3226;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3222;
					Match(COMMA);
					State = 3223;
					indexSubpartitionClauseItem();
					}
					}
					State = 3228;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3229;
				Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexSubpartitionClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USABLE() { return GetToken(OracleAntlrParser.USABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleTablespaceClauseContext simpleTablespaceClause() {
			return GetRuleContext<SimpleTablespaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionClauseContext indexCompressionClause() {
			return GetRuleContext<IndexCompressionClauseContext>(0);
		}
		public IndexSubpartitionClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexSubpartitionClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexSubpartitionClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexSubpartitionClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public IndexSubpartitionClauseItemContext indexSubpartitionClauseItem() {
		IndexSubpartitionClauseItemContext _localctx = new IndexSubpartitionClauseItemContext(Context, State);
		EnterRule(_localctx, 448, RULE_indexSubpartitionClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3233;
			Match(SUBPARTITION);
			State = 3235;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,208,Context) ) {
			case 1:
				{
				State = 3234;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			}
			State = 3238;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLESPACE) {
				{
				State = 3237;
				simpleTablespaceClause();
				}
			}

			State = 3241;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMPRESS || _la==NOCOMPRESS) {
				{
				State = 3240;
				indexCompressionClause();
				}
			}

			State = 3243;
			_la = TokenStream.LA(1);
			if ( !(_la==UNUSABLE || _la==USABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexAttributeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute() {
			return GetRuleContext<PhysicalAttributeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause() {
			return GetRuleContext<LoggingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLINE() { return GetToken(OracleAntlrParser.ONLINE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPUTE() { return GetToken(OracleAntlrParser.COMPUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATISTICS() { return GetToken(OracleAntlrParser.STATISTICS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause() {
			return GetRuleContext<TablespaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionClauseContext indexCompressionClause() {
			return GetRuleContext<IndexCompressionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SortNoSortClauseContext sortNoSortClause() {
			return GetRuleContext<SortNoSortClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REVERSE() { return GetToken(OracleAntlrParser.REVERSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VisibilityClauseContext visibilityClause() {
			return GetRuleContext<VisibilityClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartialIndexClauseContext partialIndexClause() {
			return GetRuleContext<PartialIndexClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		public IndexAttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexAttribute; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexAttribute(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexAttribute(this);
		}
	}

	[RuleVersion(0)]
	public IndexAttributeContext indexAttribute() {
		IndexAttributeContext _localctx = new IndexAttributeContext(Context, State);
		EnterRule(_localctx, 450, RULE_indexAttribute);
		try {
			State = 3257;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INITRANS:
			case MAXTRANS:
			case PCTFREE:
			case PCTUSED:
			case STORAGE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3245;
				physicalAttribute();
				}
				break;
			case FILESYSTEM_LIKE_LOGGING:
			case LOGGING:
			case NOLOGGING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3246;
				loggingClause();
				}
				break;
			case ONLINE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3247;
				Match(ONLINE);
				}
				break;
			case COMPUTE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3248;
				Match(COMPUTE);
				State = 3249;
				Match(STATISTICS);
				}
				break;
			case TABLESPACE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3250;
				tablespaceClause();
				}
				break;
			case COMPRESS:
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 6);
				{
				State = 3251;
				indexCompressionClause();
				}
				break;
			case NOSORT:
			case SORT:
				EnterOuterAlt(_localctx, 7);
				{
				State = 3252;
				sortNoSortClause();
				}
				break;
			case REVERSE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 3253;
				Match(REVERSE);
				}
				break;
			case INVISIBLE:
			case VISIBLE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 3254;
				visibilityClause();
				}
				break;
			case INDEXING:
				EnterOuterAlt(_localctx, 10);
				{
				State = 3255;
				partialIndexClause();
				}
				break;
			case NOPARALLEL:
			case PARALLEL:
				EnterOuterAlt(_localctx, 11);
				{
				State = 3256;
				parallelClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VisibilityClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VISIBLE() { return GetToken(OracleAntlrParser.VISIBLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVISIBLE() { return GetToken(OracleAntlrParser.INVISIBLE, 0); }
		public VisibilityClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_visibilityClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterVisibilityClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitVisibilityClause(this);
		}
	}

	[RuleVersion(0)]
	public VisibilityClauseContext visibilityClause() {
		VisibilityClauseContext _localctx = new VisibilityClauseContext(Context, State);
		EnterRule(_localctx, 452, RULE_visibilityClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3259;
			_la = TokenStream.LA(1);
			if ( !(_la==INVISIBLE || _la==VISIBLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartialIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEXING() { return GetToken(OracleAntlrParser.INDEXING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTIAL() { return GetToken(OracleAntlrParser.PARTIAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FULL() { return GetToken(OracleAntlrParser.FULL, 0); }
		public PartialIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partialIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPartialIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPartialIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public PartialIndexClauseContext partialIndexClause() {
		PartialIndexClauseContext _localctx = new PartialIndexClauseContext(Context, State);
		EnterRule(_localctx, 454, RULE_partialIndexClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3261;
			Match(INDEXING);
			State = 3262;
			_la = TokenStream.LA(1);
			if ( !(_la==FULL || _la==PARTIAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexTypeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEXTYPE() { return GetToken(OracleAntlrParser.INDEXTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LocalIndexClauseContext localIndexClause() {
			return GetRuleContext<LocalIndexClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnstructuredIndexParametersClauseContext unstructuredIndexParametersClause() {
			return GetRuleContext<UnstructuredIndexParametersClauseContext>(0);
		}
		public IndexTypeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexTypeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexTypeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexTypeClause(this);
		}
	}

	[RuleVersion(0)]
	public IndexTypeClauseContext indexTypeClause() {
		IndexTypeClauseContext _localctx = new IndexTypeClauseContext(Context, State);
		EnterRule(_localctx, 456, RULE_indexTypeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3264;
			Match(INDEXTYPE);
			State = 3265;
			Match(IS);
			State = 3266;
			plainIdentifier();
			State = 3268;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOCAL) {
				{
				State = 3267;
				localIndexClause();
				}
			}

			State = 3271;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOPARALLEL || _la==PARALLEL) {
				{
				State = 3270;
				parallelClause();
				}
			}

			State = 3274;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARAMETERS) {
				{
				State = 3273;
				unstructuredIndexParametersClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LocalIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(OracleAntlrParser.LOCAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalIndexClauseItemContext[] localIndexClauseItem() {
			return GetRuleContexts<LocalIndexClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LocalIndexClauseItemContext localIndexClauseItem(int i) {
			return GetRuleContext<LocalIndexClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		public LocalIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_localIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLocalIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLocalIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public LocalIndexClauseContext localIndexClause() {
		LocalIndexClauseContext _localctx = new LocalIndexClauseContext(Context, State);
		EnterRule(_localctx, 458, RULE_localIndexClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3276;
			Match(LOCAL);
			State = 3277;
			Match(LPAREN);
			State = 3278;
			localIndexClauseItem();
			{
			State = 3279;
			Match(COMMA);
			State = 3280;
			localIndexClauseItem();
			}
			State = 3282;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LocalIndexClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnstructuredIndexParametersClauseContext unstructuredIndexParametersClause() {
			return GetRuleContext<UnstructuredIndexParametersClauseContext>(0);
		}
		public LocalIndexClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_localIndexClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLocalIndexClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLocalIndexClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public LocalIndexClauseItemContext localIndexClauseItem() {
		LocalIndexClauseItemContext _localctx = new LocalIndexClauseItemContext(Context, State);
		EnterRule(_localctx, 460, RULE_localIndexClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3284;
			Match(PARTITION);
			State = 3285;
			localSimpleIdentifierWithoutParentheses();
			State = 3287;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARAMETERS) {
				{
				State = 3286;
				unstructuredIndexParametersClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnstructuredIndexParametersClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARAMETERS() { return GetToken(OracleAntlrParser.PARAMETERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharacterStringLiteralContext characterStringLiteral() {
			return GetRuleContext<CharacterStringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public UnstructuredIndexParametersClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unstructuredIndexParametersClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUnstructuredIndexParametersClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUnstructuredIndexParametersClause(this);
		}
	}

	[RuleVersion(0)]
	public UnstructuredIndexParametersClauseContext unstructuredIndexParametersClause() {
		UnstructuredIndexParametersClauseContext _localctx = new UnstructuredIndexParametersClauseContext(Context, State);
		EnterRule(_localctx, 462, RULE_unstructuredIndexParametersClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3289;
			Match(PARAMETERS);
			State = 3290;
			Match(LPAREN);
			State = 3291;
			characterStringLiteral();
			State = 3292;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleTablespaceClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLESPACE() { return GetToken(OracleAntlrParser.TABLESPACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public SimpleTablespaceClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleTablespaceClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSimpleTablespaceClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSimpleTablespaceClause(this);
		}
	}

	[RuleVersion(0)]
	public SimpleTablespaceClauseContext simpleTablespaceClause() {
		SimpleTablespaceClauseContext _localctx = new SimpleTablespaceClauseContext(Context, State);
		EnterRule(_localctx, 464, RULE_simpleTablespaceClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3294;
			Match(TABLESPACE);
			State = 3295;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSequenceStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEQUENCE() { return GetToken(OracleAntlrParser.SEQUENCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateSequenceSharingClauseContext createSequenceSharingClause() {
			return GetRuleContext<CreateSequenceSharingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceOptionContext[] sequenceOption() {
			return GetRuleContexts<SequenceOptionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceOptionContext sequenceOption(int i) {
			return GetRuleContext<SequenceOptionContext>(i);
		}
		public CreateSequenceStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSequenceStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateSequenceStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateSequenceStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateSequenceStatementContext createSequenceStatement() {
		CreateSequenceStatementContext _localctx = new CreateSequenceStatementContext(Context, State);
		EnterRule(_localctx, 466, RULE_createSequenceStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3297;
			Match(SEQUENCE);
			State = 3298;
			plainIdentifier();
			State = 3300;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SHARING) {
				{
				State = 3299;
				createSequenceSharingClause();
				}
			}

			State = 3305;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==CACHE || _la==CYCLE || ((((_la - 202)) & ~0x3f) == 0 && ((1L << (_la - 202)) & ((1L << (GLOBAL - 202)) | (1L << (INCREMENT - 202)) | (1L << (KEEP - 202)))) != 0) || ((((_la - 291)) & ~0x3f) == 0 && ((1L << (_la - 291)) & ((1L << (MAXVALUE - 291)) | (1L << (MINVALUE - 291)) | (1L << (NOCACHE - 291)) | (1L << (NOCYCLE - 291)) | (1L << (NOKEEP - 291)) | (1L << (NOMAXVALUE - 291)) | (1L << (NOMINVALUE - 291)) | (1L << (NOORDER - 291)) | (1L << (NOSCALE - 291)) | (1L << (NOSHARD - 291)))) != 0) || _la==ORDER || ((((_la - 453)) & ~0x3f) == 0 && ((1L << (_la - 453)) & ((1L << (SCALE - 453)) | (1L << (SESSION - 453)) | (1L << (START - 453)) | (1L << (SHARD - 453)))) != 0)) {
				{
				{
				State = 3302;
				sequenceOption();
				}
				}
				State = 3307;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSequenceSharingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARING() { return GetToken(OracleAntlrParser.SHARING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode METADATA() { return GetToken(OracleAntlrParser.METADATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATA() { return GetToken(OracleAntlrParser.DATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(OracleAntlrParser.NONE, 0); }
		public CreateSequenceSharingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSequenceSharingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateSequenceSharingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateSequenceSharingClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateSequenceSharingClauseContext createSequenceSharingClause() {
		CreateSequenceSharingClauseContext _localctx = new CreateSequenceSharingClauseContext(Context, State);
		EnterRule(_localctx, 468, RULE_createSequenceSharingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3308;
			Match(SHARING);
			State = 3309;
			Match(EQUAL_SIGN);
			State = 3310;
			_la = TokenStream.LA(1);
			if ( !(_la==DATA || _la==METADATA || _la==NONE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateEditionableBatchWideStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureStatementContext procedureStatement() {
			return GetRuleContext<ProcedureStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionStatementContext functionStatement() {
			return GetRuleContext<FunctionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TriggerStatementContext triggerStatement() {
			return GetRuleContext<TriggerStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PackageBodyStatementContext packageBodyStatement() {
			return GetRuleContext<PackageBodyStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PackageStatementContext packageStatement() {
			return GetRuleContext<PackageStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateTypeBodyStatementContext createTypeBodyStatement() {
			return GetRuleContext<CreateTypeBodyStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateTypeStatementContext createTypeStatement() {
			return GetRuleContext<CreateTypeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateSynonymStatementContext createSynonymStatement() {
			return GetRuleContext<CreateSynonymStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EditionOptionClauseContext editionOptionClause() {
			return GetRuleContext<EditionOptionClauseContext>(0);
		}
		public CreateEditionableBatchWideStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createEditionableBatchWideStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateEditionableBatchWideStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateEditionableBatchWideStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateEditionableBatchWideStatementContext createEditionableBatchWideStatement() {
		CreateEditionableBatchWideStatementContext _localctx = new CreateEditionableBatchWideStatementContext(Context, State);
		EnterRule(_localctx, 470, RULE_createEditionableBatchWideStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3313;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EDITIONABLE || _la==NONEDITIONABLE) {
				{
				State = 3312;
				editionOptionClause();
				}
			}

			State = 3323;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,219,Context) ) {
			case 1:
				{
				State = 3315;
				procedureStatement();
				}
				break;
			case 2:
				{
				State = 3316;
				functionStatement();
				}
				break;
			case 3:
				{
				State = 3317;
				triggerStatement();
				}
				break;
			case 4:
				{
				State = 3318;
				packageBodyStatement();
				}
				break;
			case 5:
				{
				State = 3319;
				packageStatement();
				}
				break;
			case 6:
				{
				State = 3320;
				createTypeBodyStatement();
				}
				break;
			case 7:
				{
				State = 3321;
				createTypeStatement();
				}
				break;
			case 8:
				{
				State = 3322;
				createSynonymStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EditionOptionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITIONABLE() { return GetToken(OracleAntlrParser.EDITIONABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONEDITIONABLE() { return GetToken(OracleAntlrParser.NONEDITIONABLE, 0); }
		public EditionOptionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_editionOptionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterEditionOptionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitEditionOptionClause(this);
		}
	}

	[RuleVersion(0)]
	public EditionOptionClauseContext editionOptionClause() {
		EditionOptionClauseContext _localctx = new EditionOptionClauseContext(Context, State);
		EnterRule(_localctx, 472, RULE_editionOptionClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3325;
			_la = TokenStream.LA(1);
			if ( !(_la==EDITIONABLE || _la==NONEDITIONABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PackageStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PACKAGE() { return GetToken(OracleAntlrParser.PACKAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRAPPED() { return GetToken(OracleAntlrParser.WRAPPED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
			return GetRuleContext<RoutineBodyAsIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PackageDeclarationBlockContext packageDeclarationBlock() {
			return GetRuleContext<PackageDeclarationBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndClauseContext endClause() {
			return GetRuleContext<EndClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InvokerRightsClauseContext invokerRightsClause() {
			return GetRuleContext<InvokerRightsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] FSLASH() { return GetTokens(OracleAntlrParser.FSLASH); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FSLASH(int i) {
			return GetToken(OracleAntlrParser.FSLASH, i);
		}
		public PackageStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_packageStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPackageStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPackageStatement(this);
		}
	}

	[RuleVersion(0)]
	public PackageStatementContext packageStatement() {
		PackageStatementContext _localctx = new PackageStatementContext(Context, State);
		EnterRule(_localctx, 474, RULE_packageStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3327;
			Match(PACKAGE);
			State = 3328;
			plainIdentifier();
			State = 3343;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WRAPPED:
				{
				State = 3329;
				Match(WRAPPED);
				State = 3333;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,220,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 3330;
						_la = TokenStream.LA(1);
						if ( _la <= 0 || (_la==FSLASH) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						} 
					}
					State = 3335;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,220,Context);
				}
				}
				break;
			case AS:
			case AUTHID:
			case IS:
				{
				State = 3337;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AUTHID) {
					{
					State = 3336;
					invokerRightsClause();
					}
				}

				State = 3339;
				routineBodyAsIsClause();
				State = 3340;
				packageDeclarationBlock();
				State = 3341;
				endClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PackageBodyStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PACKAGE() { return GetToken(OracleAntlrParser.PACKAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BODY() { return GetToken(OracleAntlrParser.BODY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRAPPED() { return GetToken(OracleAntlrParser.WRAPPED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
			return GetRuleContext<RoutineBodyAsIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PackageDeclarationBlockContext packageDeclarationBlock() {
			return GetRuleContext<PackageDeclarationBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockBodyContext blockBody() {
			return GetRuleContext<BlockBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndClauseContext endClause() {
			return GetRuleContext<EndClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] FSLASH() { return GetTokens(OracleAntlrParser.FSLASH); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FSLASH(int i) {
			return GetToken(OracleAntlrParser.FSLASH, i);
		}
		public PackageBodyStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_packageBodyStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPackageBodyStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPackageBodyStatement(this);
		}
	}

	[RuleVersion(0)]
	public PackageBodyStatementContext packageBodyStatement() {
		PackageBodyStatementContext _localctx = new PackageBodyStatementContext(Context, State);
		EnterRule(_localctx, 476, RULE_packageBodyStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3345;
			Match(PACKAGE);
			State = 3346;
			Match(BODY);
			State = 3347;
			plainIdentifier();
			State = 3361;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WRAPPED:
				{
				State = 3348;
				Match(WRAPPED);
				State = 3352;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,223,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 3349;
						_la = TokenStream.LA(1);
						if ( _la <= 0 || (_la==FSLASH) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						} 
					}
					State = 3354;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,223,Context);
				}
				}
				break;
			case AS:
			case IS:
				{
				State = 3355;
				routineBodyAsIsClause();
				State = 3356;
				packageDeclarationBlock();
				State = 3359;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case BEGIN:
					{
					State = 3357;
					blockBody();
					}
					break;
				case END:
					{
					State = 3358;
					endClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PackageDeclarationBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockContext declarationBlock() {
			return GetRuleContext<DeclarationBlockContext>(0);
		}
		public PackageDeclarationBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_packageDeclarationBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPackageDeclarationBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPackageDeclarationBlock(this);
		}
	}

	[RuleVersion(0)]
	public PackageDeclarationBlockContext packageDeclarationBlock() {
		PackageDeclarationBlockContext _localctx = new PackageDeclarationBlockContext(Context, State);
		EnterRule(_localctx, 478, RULE_packageDeclarationBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3364;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECLARE - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DIRECTIVE_IF - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 3363;
				declarationBlock();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureSignatureContext procedureSignature() {
			return GetRuleContext<ProcedureSignatureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureImplementationContext procedureImplementation() {
			return GetRuleContext<ProcedureImplementationContext>(0);
		}
		public ProcedureStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterProcedureStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitProcedureStatement(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureStatementContext procedureStatement() {
		ProcedureStatementContext _localctx = new ProcedureStatementContext(Context, State);
		EnterRule(_localctx, 480, RULE_procedureStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3366;
			procedureSignature();
			State = 3368;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS || _la==IS || _la==LANGUAGE) {
				{
				State = 3367;
				procedureImplementation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureSignatureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureHeaderContext procedureHeader() {
			return GetRuleContext<ProcedureHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InvokerRightsClauseContext invokerRightsClause() {
			return GetRuleContext<InvokerRightsClauseContext>(0);
		}
		public ProcedureSignatureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureSignature; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterProcedureSignature(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitProcedureSignature(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureSignatureContext procedureSignature() {
		ProcedureSignatureContext _localctx = new ProcedureSignatureContext(Context, State);
		EnterRule(_localctx, 482, RULE_procedureSignature);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3370;
			procedureHeader();
			State = 3372;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,228,Context) ) {
			case 1:
				{
				State = 3371;
				invokerRightsClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureImplementationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureCallSpecClauseContext procedureCallSpecClause() {
			return GetRuleContext<ProcedureCallSpecClauseContext>(0);
		}
		public ProcedureImplementationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureImplementation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterProcedureImplementation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitProcedureImplementation(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureImplementationContext procedureImplementation() {
		ProcedureImplementationContext _localctx = new ProcedureImplementationContext(Context, State);
		EnterRule(_localctx, 484, RULE_procedureImplementation);
		try {
			State = 3376;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
			case IS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3374;
				routineBody();
				}
				break;
			case LANGUAGE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3375;
				procedureCallSpecClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROCEDURE() { return GetToken(OracleAntlrParser.PROCEDURE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public ProcedureHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterProcedureHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitProcedureHeader(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureHeaderContext procedureHeader() {
		ProcedureHeaderContext _localctx = new ProcedureHeaderContext(Context, State);
		EnterRule(_localctx, 486, RULE_procedureHeader);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3378;
			Match(PROCEDURE);
			State = 3379;
			plainIdentifier();
			State = 3381;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,230,Context) ) {
			case 1:
				{
				State = 3380;
				argumentList();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RoutineBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
			return GetRuleContext<RoutineBodyAsIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockBodyContext blockBody() {
			return GetRuleContext<BlockBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockContext declarationBlock() {
			return GetRuleContext<DeclarationBlockContext>(0);
		}
		public RoutineBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routineBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRoutineBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRoutineBody(this);
		}
	}

	[RuleVersion(0)]
	public RoutineBodyContext routineBody() {
		RoutineBodyContext _localctx = new RoutineBodyContext(Context, State);
		EnterRule(_localctx, 488, RULE_routineBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3383;
			routineBodyAsIsClause();
			State = 3385;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECLARE - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DIRECTIVE_IF - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 3384;
				declarationBlock();
				}
			}

			State = 3387;
			blockBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RoutineBodyAsIsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		public RoutineBodyAsIsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routineBodyAsIsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRoutineBodyAsIsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRoutineBodyAsIsClause(this);
		}
	}

	[RuleVersion(0)]
	public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
		RoutineBodyAsIsClauseContext _localctx = new RoutineBodyAsIsClauseContext(Context, State);
		EnterRule(_localctx, 490, RULE_routineBodyAsIsClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3389;
			_la = TokenStream.LA(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InvokerRightsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTHID() { return GetToken(OracleAntlrParser.AUTHID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFINER() { return GetToken(OracleAntlrParser.DEFINER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT_USER() { return GetToken(OracleAntlrParser.CURRENT_USER, 0); }
		public InvokerRightsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_invokerRightsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterInvokerRightsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitInvokerRightsClause(this);
		}
	}

	[RuleVersion(0)]
	public InvokerRightsClauseContext invokerRightsClause() {
		InvokerRightsClauseContext _localctx = new InvokerRightsClauseContext(Context, State);
		EnterRule(_localctx, 492, RULE_invokerRightsClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3391;
			Match(AUTHID);
			State = 3392;
			_la = TokenStream.LA(1);
			if ( !(_la==CURRENT_USER || _la==DEFINER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureCallSpecClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LANGUAGE() { return GetToken(OracleAntlrParser.LANGUAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JavaDeclarationClauseContext javaDeclarationClause() {
			return GetRuleContext<JavaDeclarationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CDeclarationClauseContext cDeclarationClause() {
			return GetRuleContext<CDeclarationClauseContext>(0);
		}
		public ProcedureCallSpecClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureCallSpecClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterProcedureCallSpecClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitProcedureCallSpecClause(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureCallSpecClauseContext procedureCallSpecClause() {
		ProcedureCallSpecClauseContext _localctx = new ProcedureCallSpecClauseContext(Context, State);
		EnterRule(_localctx, 494, RULE_procedureCallSpecClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3394;
			Match(LANGUAGE);
			State = 3397;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case JAVA:
				{
				State = 3395;
				javaDeclarationClause();
				}
				break;
			case C_:
				{
				State = 3396;
				cDeclarationClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JavaDeclarationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JAVA() { return GetToken(OracleAntlrParser.JAVA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAME() { return GetToken(OracleAntlrParser.NAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public JavaDeclarationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_javaDeclarationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJavaDeclarationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJavaDeclarationClause(this);
		}
	}

	[RuleVersion(0)]
	public JavaDeclarationClauseContext javaDeclarationClause() {
		JavaDeclarationClauseContext _localctx = new JavaDeclarationClauseContext(Context, State);
		EnterRule(_localctx, 496, RULE_javaDeclarationClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3399;
			Match(JAVA);
			State = 3400;
			Match(NAME);
			State = 3401;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CDeclarationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode C_() { return GetToken(OracleAntlrParser.C_, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CDeclarationLibraryClauseContext cDeclarationLibraryClause() {
			return GetRuleContext<CDeclarationLibraryClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CDeclarationNameClauseContext cDeclarationNameClause() {
			return GetRuleContext<CDeclarationNameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CDeclarationAgentClauseContext cDeclarationAgentClause() {
			return GetRuleContext<CDeclarationAgentClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CDeclarationContextClauseContext cDeclarationContextClause() {
			return GetRuleContext<CDeclarationContextClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CDeclarationParametersClauseContext cDeclarationParametersClause() {
			return GetRuleContext<CDeclarationParametersClauseContext>(0);
		}
		public CDeclarationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cDeclarationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCDeclarationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCDeclarationClause(this);
		}
	}

	[RuleVersion(0)]
	public CDeclarationClauseContext cDeclarationClause() {
		CDeclarationClauseContext _localctx = new CDeclarationClauseContext(Context, State);
		EnterRule(_localctx, 498, RULE_cDeclarationClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3403;
			Match(C_);
			State = 3405;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NAME) {
				{
				State = 3404;
				cDeclarationNameClause();
				}
			}

			State = 3407;
			cDeclarationLibraryClause();
			State = 3409;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AGENT) {
				{
				State = 3408;
				cDeclarationAgentClause();
				}
			}

			State = 3412;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 3411;
				cDeclarationContextClause();
				}
			}

			State = 3415;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARAMETERS) {
				{
				State = 3414;
				cDeclarationParametersClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CDeclarationNameClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAME() { return GetToken(OracleAntlrParser.NAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public CDeclarationNameClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cDeclarationNameClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCDeclarationNameClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCDeclarationNameClause(this);
		}
	}

	[RuleVersion(0)]
	public CDeclarationNameClauseContext cDeclarationNameClause() {
		CDeclarationNameClauseContext _localctx = new CDeclarationNameClauseContext(Context, State);
		EnterRule(_localctx, 500, RULE_cDeclarationNameClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3417;
			Match(NAME);
			State = 3418;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CDeclarationLibraryClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIBRARY() { return GetToken(OracleAntlrParser.LIBRARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public CDeclarationLibraryClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cDeclarationLibraryClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCDeclarationLibraryClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCDeclarationLibraryClause(this);
		}
	}

	[RuleVersion(0)]
	public CDeclarationLibraryClauseContext cDeclarationLibraryClause() {
		CDeclarationLibraryClauseContext _localctx = new CDeclarationLibraryClauseContext(Context, State);
		EnterRule(_localctx, 502, RULE_cDeclarationLibraryClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3420;
			Match(LIBRARY);
			State = 3421;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CDeclarationAgentClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AGENT() { return GetToken(OracleAntlrParser.AGENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public CDeclarationAgentClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cDeclarationAgentClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCDeclarationAgentClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCDeclarationAgentClause(this);
		}
	}

	[RuleVersion(0)]
	public CDeclarationAgentClauseContext cDeclarationAgentClause() {
		CDeclarationAgentClauseContext _localctx = new CDeclarationAgentClauseContext(Context, State);
		EnterRule(_localctx, 504, RULE_cDeclarationAgentClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3423;
			Match(AGENT);
			State = 3424;
			Match(IN);
			State = 3425;
			argumentList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CDeclarationContextClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTEXT() { return GetToken(OracleAntlrParser.CONTEXT, 0); }
		public CDeclarationContextClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cDeclarationContextClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCDeclarationContextClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCDeclarationContextClause(this);
		}
	}

	[RuleVersion(0)]
	public CDeclarationContextClauseContext cDeclarationContextClause() {
		CDeclarationContextClauseContext _localctx = new CDeclarationContextClauseContext(Context, State);
		EnterRule(_localctx, 506, RULE_cDeclarationContextClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3427;
			Match(WITH);
			State = 3428;
			Match(CONTEXT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CDeclarationParametersClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARAMETERS() { return GetToken(OracleAntlrParser.PARAMETERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public CDeclarationParametersClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cDeclarationParametersClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCDeclarationParametersClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCDeclarationParametersClause(this);
		}
	}

	[RuleVersion(0)]
	public CDeclarationParametersClauseContext cDeclarationParametersClause() {
		CDeclarationParametersClauseContext _localctx = new CDeclarationParametersClauseContext(Context, State);
		EnterRule(_localctx, 508, RULE_cDeclarationParametersClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3430;
			Match(PARAMETERS);
			State = 3431;
			Match(LPAREN);
			State = 3432;
			identifierList();
			State = 3433;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentContext[] argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterArgumentList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitArgumentList(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentListContext argumentList() {
		ArgumentListContext _localctx = new ArgumentListContext(Context, State);
		EnterRule(_localctx, 510, RULE_argumentList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3435;
			Match(LPAREN);
			State = 3444;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 3436;
				argument();
				State = 3441;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3437;
					Match(COMMA);
					State = 3438;
					argument();
					}
					}
					State = 3443;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 3446;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentModeClauseContext argumentModeClause() {
			return GetRuleContext<ArgumentModeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentNoCopyClauseContext argumentNoCopyClause() {
			return GetRuleContext<ArgumentNoCopyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentDefaultValueContext argumentDefaultValue() {
			return GetRuleContext<ArgumentDefaultValueContext>(0);
		}
		public ArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterArgument(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitArgument(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentContext argument() {
		ArgumentContext _localctx = new ArgumentContext(Context, State);
		EnterRule(_localctx, 512, RULE_argument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3448;
			simpleIdentifier();
			State = 3450;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,239,Context) ) {
			case 1:
				{
				State = 3449;
				argumentModeClause();
				}
				break;
			}
			State = 3453;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,240,Context) ) {
			case 1:
				{
				State = 3452;
				argumentNoCopyClause();
				}
				break;
			}
			State = 3455;
			typeReference();
			State = 3457;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT || _la==ASSIGN_OPERATOR) {
				{
				State = 3456;
				argumentDefaultValue();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentNoCopyClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCOPY() { return GetToken(OracleAntlrParser.NOCOPY, 0); }
		public ArgumentNoCopyClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentNoCopyClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterArgumentNoCopyClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitArgumentNoCopyClause(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentNoCopyClauseContext argumentNoCopyClause() {
		ArgumentNoCopyClauseContext _localctx = new ArgumentNoCopyClauseContext(Context, State);
		EnterRule(_localctx, 514, RULE_argumentNoCopyClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3459;
			Match(NOCOPY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentModeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OUT() { return GetToken(OracleAntlrParser.OUT, 0); }
		public ArgumentModeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentModeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterArgumentModeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitArgumentModeClause(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentModeClauseContext argumentModeClause() {
		ArgumentModeClauseContext _localctx = new ArgumentModeClauseContext(Context, State);
		EnterRule(_localctx, 516, RULE_argumentModeClause);
		try {
			State = 3465;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,242,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3461;
				Match(IN);
				State = 3462;
				Match(OUT);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3463;
				Match(IN);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3464;
				Match(OUT);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentDefaultValueContext : ParserRuleContext {
		public IToken assignType;
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN_OPERATOR() { return GetToken(OracleAntlrParser.ASSIGN_OPERATOR, 0); }
		public ArgumentDefaultValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentDefaultValue; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterArgumentDefaultValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitArgumentDefaultValue(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentDefaultValueContext argumentDefaultValue() {
		ArgumentDefaultValueContext _localctx = new ArgumentDefaultValueContext(Context, State);
		EnterRule(_localctx, 518, RULE_argumentDefaultValue);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3467;
			_localctx.assignType = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DEFAULT || _la==ASSIGN_OPERATOR) ) {
				_localctx.assignType = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3468;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionSignatureContext functionSignature() {
			return GetRuleContext<FunctionSignatureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionImplementationContext functionImplementation() {
			return GetRuleContext<FunctionImplementationContext>(0);
		}
		public FunctionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFunctionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFunctionStatement(this);
		}
	}

	[RuleVersion(0)]
	public FunctionStatementContext functionStatement() {
		FunctionStatementContext _localctx = new FunctionStatementContext(Context, State);
		EnterRule(_localctx, 520, RULE_functionStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3470;
			functionSignature();
			State = 3472;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS || _la==IS || _la==LANGUAGE) {
				{
				State = 3471;
				functionImplementation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionSignatureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionReturnClauseContext functionReturnClause() {
			return GetRuleContext<FunctionReturnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InvokerRightsClauseContext[] invokerRightsClause() {
			return GetRuleContexts<InvokerRightsClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public InvokerRightsClauseContext invokerRightsClause(int i) {
			return GetRuleContext<InvokerRightsClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionDeterministicClauseContext[] functionDeterministicClause() {
			return GetRuleContexts<FunctionDeterministicClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionDeterministicClauseContext functionDeterministicClause(int i) {
			return GetRuleContext<FunctionDeterministicClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionParallelEnableClauseContext[] functionParallelEnableClause() {
			return GetRuleContexts<FunctionParallelEnableClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionParallelEnableClauseContext functionParallelEnableClause(int i) {
			return GetRuleContext<FunctionParallelEnableClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionAggregateClauseContext[] functionAggregateClause() {
			return GetRuleContexts<FunctionAggregateClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionAggregateClauseContext functionAggregateClause(int i) {
			return GetRuleContext<FunctionAggregateClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionPipelinedClauseContext[] functionPipelinedClause() {
			return GetRuleContexts<FunctionPipelinedClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionPipelinedClauseContext functionPipelinedClause(int i) {
			return GetRuleContext<FunctionPipelinedClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ResultCacheClauseContext[] resultCacheClause() {
			return GetRuleContexts<ResultCacheClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ResultCacheClauseContext resultCacheClause(int i) {
			return GetRuleContext<ResultCacheClauseContext>(i);
		}
		public FunctionSignatureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionSignature; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFunctionSignature(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFunctionSignature(this);
		}
	}

	[RuleVersion(0)]
	public FunctionSignatureContext functionSignature() {
		FunctionSignatureContext _localctx = new FunctionSignatureContext(Context, State);
		EnterRule(_localctx, 522, RULE_functionSignature);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3474;
			functionHeader();
			State = 3475;
			functionReturnClause();
			State = 3484;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,245,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 3482;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case AUTHID:
						{
						State = 3476;
						invokerRightsClause();
						}
						break;
					case DETERMINISTIC:
						{
						State = 3477;
						functionDeterministicClause();
						}
						break;
					case PARALLEL_ENABLE:
						{
						State = 3478;
						functionParallelEnableClause();
						}
						break;
					case AGGREGATE:
						{
						State = 3479;
						functionAggregateClause();
						}
						break;
					case PIPELINED:
						{
						State = 3480;
						functionPipelinedClause();
						}
						break;
					case RESULT_CACHE:
						{
						State = 3481;
						resultCacheClause();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 3486;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,245,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionImplementationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureCallSpecClauseContext procedureCallSpecClause() {
			return GetRuleContext<ProcedureCallSpecClauseContext>(0);
		}
		public FunctionImplementationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionImplementation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFunctionImplementation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFunctionImplementation(this);
		}
	}

	[RuleVersion(0)]
	public FunctionImplementationContext functionImplementation() {
		FunctionImplementationContext _localctx = new FunctionImplementationContext(Context, State);
		EnterRule(_localctx, 524, RULE_functionImplementation);
		try {
			State = 3489;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
			case IS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3487;
				routineBody();
				}
				break;
			case LANGUAGE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3488;
				procedureCallSpecClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTION() { return GetToken(OracleAntlrParser.FUNCTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierAsStringLiteralContext plainIdentifierAsStringLiteral() {
			return GetRuleContext<PlainIdentifierAsStringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public FunctionHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}
	}

	[RuleVersion(0)]
	public FunctionHeaderContext functionHeader() {
		FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State);
		EnterRule(_localctx, 526, RULE_functionHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3491;
			Match(FUNCTION);
			State = 3494;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 3492;
				plainIdentifier();
				}
				break;
			case CHARACTER_STRING_LITERAL:
				{
				State = 3493;
				plainIdentifierAsStringLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3497;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 3496;
				argumentList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionReturnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(OracleAntlrParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public FunctionReturnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionReturnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFunctionReturnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFunctionReturnClause(this);
		}
	}

	[RuleVersion(0)]
	public FunctionReturnClauseContext functionReturnClause() {
		FunctionReturnClauseContext _localctx = new FunctionReturnClauseContext(Context, State);
		EnterRule(_localctx, 528, RULE_functionReturnClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3499;
			Match(RETURN);
			State = 3500;
			typeReference();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionDeterministicClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DETERMINISTIC() { return GetToken(OracleAntlrParser.DETERMINISTIC, 0); }
		public FunctionDeterministicClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionDeterministicClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFunctionDeterministicClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFunctionDeterministicClause(this);
		}
	}

	[RuleVersion(0)]
	public FunctionDeterministicClauseContext functionDeterministicClause() {
		FunctionDeterministicClauseContext _localctx = new FunctionDeterministicClauseContext(Context, State);
		EnterRule(_localctx, 530, RULE_functionDeterministicClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3502;
			Match(DETERMINISTIC);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionParallelEnableClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARALLEL_ENABLE() { return GetToken(OracleAntlrParser.PARALLEL_ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParallelOnPartitionOptionContext parallelOnPartitionOption() {
			return GetRuleContext<ParallelOnPartitionOptionContext>(0);
		}
		public FunctionParallelEnableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionParallelEnableClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFunctionParallelEnableClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFunctionParallelEnableClause(this);
		}
	}

	[RuleVersion(0)]
	public FunctionParallelEnableClauseContext functionParallelEnableClause() {
		FunctionParallelEnableClauseContext _localctx = new FunctionParallelEnableClauseContext(Context, State);
		EnterRule(_localctx, 532, RULE_functionParallelEnableClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3504;
			Match(PARALLEL_ENABLE);
			State = 3506;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,249,Context) ) {
			case 1:
				{
				State = 3505;
				parallelOnPartitionOption();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParallelOnPartitionOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelOnPartitionByContext parallelOnPartitionBy() {
			return GetRuleContext<ParallelOnPartitionByContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public ParallelOnPartitionOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallelOnPartitionOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterParallelOnPartitionOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitParallelOnPartitionOption(this);
		}
	}

	[RuleVersion(0)]
	public ParallelOnPartitionOptionContext parallelOnPartitionOption() {
		ParallelOnPartitionOptionContext _localctx = new ParallelOnPartitionOptionContext(Context, State);
		EnterRule(_localctx, 534, RULE_parallelOnPartitionOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3508;
			Match(LPAREN);
			State = 3509;
			Match(PARTITION);
			State = 3510;
			simpleIdentifier();
			State = 3511;
			parallelOnPartitionBy();
			State = 3512;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParallelOnPartitionByContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY() { return GetToken(OracleAntlrParser.ANY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(OracleAntlrParser.VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemInParenContext columnListItemInParen() {
			return GetRuleContext<ColumnListItemInParenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(OracleAntlrParser.HASH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(OracleAntlrParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParallelOnPartitionStreamingClauseContext parallelOnPartitionStreamingClause() {
			return GetRuleContext<ParallelOnPartitionStreamingClauseContext>(0);
		}
		public ParallelOnPartitionByContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallelOnPartitionBy; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterParallelOnPartitionBy(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitParallelOnPartitionBy(this);
		}
	}

	[RuleVersion(0)]
	public ParallelOnPartitionByContext parallelOnPartitionBy() {
		ParallelOnPartitionByContext _localctx = new ParallelOnPartitionByContext(Context, State);
		EnterRule(_localctx, 536, RULE_parallelOnPartitionBy);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3514;
			Match(BY);
			State = 3523;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ANY:
				{
				State = 3515;
				Match(ANY);
				}
				break;
			case VALUE:
				{
				State = 3516;
				Match(VALUE);
				State = 3517;
				columnListItemInParen();
				}
				break;
			case HASH:
			case RANGE:
				{
				State = 3518;
				_la = TokenStream.LA(1);
				if ( !(_la==HASH || _la==RANGE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3519;
				columnListInParenElementClause();
				State = 3521;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CLUSTER || _la==ORDER) {
					{
					State = 3520;
					parallelOnPartitionStreamingClause();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnListItemInParenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem() {
			return GetRuleContext<ColumnListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public ColumnListItemInParenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnListItemInParen; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterColumnListItemInParen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitColumnListItemInParen(this);
		}
	}

	[RuleVersion(0)]
	public ColumnListItemInParenContext columnListItemInParen() {
		ColumnListItemInParenContext _localctx = new ColumnListItemInParenContext(Context, State);
		EnterRule(_localctx, 538, RULE_columnListItemInParen);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3525;
			Match(LPAREN);
			State = 3526;
			columnListItem();
			State = 3527;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParallelOnPartitionStreamingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelOnPartitionStreamingClauseByContext parallelOnPartitionStreamingClauseBy() {
			return GetRuleContext<ParallelOnPartitionStreamingClauseByContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDER() { return GetToken(OracleAntlrParser.ORDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLUSTER() { return GetToken(OracleAntlrParser.CLUSTER, 0); }
		public ParallelOnPartitionStreamingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallelOnPartitionStreamingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterParallelOnPartitionStreamingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitParallelOnPartitionStreamingClause(this);
		}
	}

	[RuleVersion(0)]
	public ParallelOnPartitionStreamingClauseContext parallelOnPartitionStreamingClause() {
		ParallelOnPartitionStreamingClauseContext _localctx = new ParallelOnPartitionStreamingClauseContext(Context, State);
		EnterRule(_localctx, 540, RULE_parallelOnPartitionStreamingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3529;
			_la = TokenStream.LA(1);
			if ( !(_la==CLUSTER || _la==ORDER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3530;
			pureExpression();
			State = 3531;
			parallelOnPartitionStreamingClauseBy();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParallelOnPartitionStreamingClauseByContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public ParallelOnPartitionStreamingClauseByContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallelOnPartitionStreamingClauseBy; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterParallelOnPartitionStreamingClauseBy(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitParallelOnPartitionStreamingClauseBy(this);
		}
	}

	[RuleVersion(0)]
	public ParallelOnPartitionStreamingClauseByContext parallelOnPartitionStreamingClauseBy() {
		ParallelOnPartitionStreamingClauseByContext _localctx = new ParallelOnPartitionStreamingClauseByContext(Context, State);
		EnterRule(_localctx, 542, RULE_parallelOnPartitionStreamingClauseBy);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3533;
			Match(BY);
			State = 3534;
			columnListInParenElementClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResultCacheClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RESULT_CACHE() { return GetToken(OracleAntlrParser.RESULT_CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ResultCacheReliesOnClauseContext resultCacheReliesOnClause() {
			return GetRuleContext<ResultCacheReliesOnClauseContext>(0);
		}
		public ResultCacheClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_resultCacheClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterResultCacheClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitResultCacheClause(this);
		}
	}

	[RuleVersion(0)]
	public ResultCacheClauseContext resultCacheClause() {
		ResultCacheClauseContext _localctx = new ResultCacheClauseContext(Context, State);
		EnterRule(_localctx, 544, RULE_resultCacheClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3536;
			Match(RESULT_CACHE);
			State = 3538;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,252,Context) ) {
			case 1:
				{
				State = 3537;
				resultCacheReliesOnClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResultCacheReliesOnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELIES_ON() { return GetToken(OracleAntlrParser.RELIES_ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ResultCacheReliesOnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_resultCacheReliesOnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterResultCacheReliesOnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitResultCacheReliesOnClause(this);
		}
	}

	[RuleVersion(0)]
	public ResultCacheReliesOnClauseContext resultCacheReliesOnClause() {
		ResultCacheReliesOnClauseContext _localctx = new ResultCacheReliesOnClauseContext(Context, State);
		EnterRule(_localctx, 546, RULE_resultCacheReliesOnClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3540;
			Match(RELIES_ON);
			State = 3541;
			Match(LPAREN);
			State = 3542;
			identifier();
			State = 3547;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3543;
				Match(COMMA);
				State = 3544;
				identifier();
				}
				}
				State = 3549;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3550;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionAggregateClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AGGREGATE() { return GetToken(OracleAntlrParser.AGGREGATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public FunctionAggregateClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionAggregateClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFunctionAggregateClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFunctionAggregateClause(this);
		}
	}

	[RuleVersion(0)]
	public FunctionAggregateClauseContext functionAggregateClause() {
		FunctionAggregateClauseContext _localctx = new FunctionAggregateClauseContext(Context, State);
		EnterRule(_localctx, 548, RULE_functionAggregateClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3552;
			Match(AGGREGATE);
			State = 3553;
			Match(USING);
			State = 3554;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionPipelinedClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PIPELINED() { return GetToken(OracleAntlrParser.PIPELINED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POLYMORPHIC() { return GetToken(OracleAntlrParser.POLYMORPHIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		public FunctionPipelinedClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionPipelinedClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFunctionPipelinedClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFunctionPipelinedClause(this);
		}
	}

	[RuleVersion(0)]
	public FunctionPipelinedClauseContext functionPipelinedClause() {
		FunctionPipelinedClauseContext _localctx = new FunctionPipelinedClauseContext(Context, State);
		EnterRule(_localctx, 550, RULE_functionPipelinedClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3556;
			Match(PIPELINED);
			State = 3559;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,254,Context) ) {
			case 1:
				{
				State = 3557;
				_la = TokenStream.LA(1);
				if ( !(_la==ROW || _la==TABLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3558;
				Match(POLYMORPHIC);
				}
				break;
			}
			State = 3563;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,255,Context) ) {
			case 1:
				{
				State = 3561;
				Match(USING);
				State = 3562;
				identifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTableStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TableHeaderContext tableHeader() {
			return GetRuleContext<TableHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateObjectTableStatementContext createObjectTableStatement() {
			return GetRuleContext<CreateObjectTableStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateRelationTableStatementContext createRelationTableStatement() {
			return GetRuleContext<CreateRelationTableStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateXMLTypeTableStatementContext createXMLTypeTableStatement() {
			return GetRuleContext<CreateXMLTypeTableStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MemOptimizeClauseContext memOptimizeClause() {
			return GetRuleContext<MemOptimizeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParentClauseContext parentClause() {
			return GetRuleContext<ParentClauseContext>(0);
		}
		public CreateTableStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTableStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateTableStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateTableStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateTableStatementContext createTableStatement() {
		CreateTableStatementContext _localctx = new CreateTableStatementContext(Context, State);
		EnterRule(_localctx, 552, RULE_createTableStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3565;
			tableHeader();
			State = 3569;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,256,Context) ) {
			case 1:
				{
				State = 3566;
				createObjectTableStatement();
				}
				break;
			case 2:
				{
				State = 3567;
				createRelationTableStatement();
				}
				break;
			case 3:
				{
				State = 3568;
				createXMLTypeTableStatement();
				}
				break;
			}
			State = 3572;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MEMOPTIMIZE) {
				{
				State = 3571;
				memOptimizeClause();
				}
			}

			State = 3575;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARENT) {
				{
				State = 3574;
				parentClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GLOBAL() { return GetToken(OracleAntlrParser.GLOBAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEMPORARY() { return GetToken(OracleAntlrParser.TEMPORARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIVATE() { return GetToken(OracleAntlrParser.PRIVATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARDED() { return GetToken(OracleAntlrParser.SHARDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DUPLICATED() { return GetToken(OracleAntlrParser.DUPLICATED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARING() { return GetToken(OracleAntlrParser.SHARING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode METADATA() { return GetToken(OracleAntlrParser.METADATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATA() { return GetToken(OracleAntlrParser.DATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTENDED() { return GetToken(OracleAntlrParser.EXTENDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(OracleAntlrParser.NONE, 0); }
		public TableHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTableHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTableHeader(this);
		}
	}

	[RuleVersion(0)]
	public TableHeaderContext tableHeader() {
		TableHeaderContext _localctx = new TableHeaderContext(Context, State);
		EnterRule(_localctx, 554, RULE_tableHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3583;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case GLOBAL:
				{
				State = 3577;
				Match(GLOBAL);
				State = 3578;
				Match(TEMPORARY);
				}
				break;
			case PRIVATE:
				{
				State = 3579;
				Match(PRIVATE);
				State = 3580;
				Match(TEMPORARY);
				}
				break;
			case SHARDED:
				{
				State = 3581;
				Match(SHARDED);
				}
				break;
			case DUPLICATED:
				{
				State = 3582;
				Match(DUPLICATED);
				}
				break;
			case TABLE:
				break;
			default:
				break;
			}
			State = 3585;
			Match(TABLE);
			State = 3586;
			plainIdentifier();
			State = 3596;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SHARING) {
				{
				State = 3587;
				Match(SHARING);
				State = 3588;
				Match(EQUAL_SIGN);
				State = 3594;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case METADATA:
					{
					State = 3589;
					Match(METADATA);
					}
					break;
				case DATA:
					{
					State = 3590;
					Match(DATA);
					}
					break;
				case EXTENDED:
					{
					State = 3591;
					Match(EXTENDED);
					State = 3592;
					Match(DATA);
					}
					break;
				case NONE:
					{
					State = 3593;
					Match(NONE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateObjectTableStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTableOfClauseContext objectTableOfClause() {
			return GetRuleContext<ObjectTableOfClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablePropertiesClauseContext tablePropertiesClause() {
			return GetRuleContext<TablePropertiesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectPropertiesListClauseContext objectPropertiesListClause() {
			return GetRuleContext<ObjectPropertiesListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnCommitClauseContext onCommitClause() {
			return GetRuleContext<OnCommitClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectIdentifierIsClauseContext objectIdentifierIsClause() {
			return GetRuleContext<ObjectIdentifierIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OidIndexClauseContext oidIndexClause() {
			return GetRuleContext<OidIndexClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalPropertiesClauseContext physicalPropertiesClause() {
			return GetRuleContext<PhysicalPropertiesClauseContext>(0);
		}
		public CreateObjectTableStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createObjectTableStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateObjectTableStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateObjectTableStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateObjectTableStatementContext createObjectTableStatement() {
		CreateObjectTableStatementContext _localctx = new CreateObjectTableStatementContext(Context, State);
		EnterRule(_localctx, 556, RULE_createObjectTableStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3598;
			objectTableOfClause();
			State = 3600;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 3599;
				objectPropertiesListClause();
				}
			}

			State = 3603;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 3602;
				onCommitClause();
				}
			}

			State = 3606;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OBJECT) {
				{
				State = 3605;
				objectIdentifierIsClause();
				}
			}

			State = 3609;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OIDINDEX) {
				{
				State = 3608;
				oidIndexClause();
				}
			}

			State = 3612;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,266,Context) ) {
			case 1:
				{
				State = 3611;
				physicalPropertiesClause();
				}
				break;
			}
			State = 3614;
			tablePropertiesClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MemOptimizeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] MEMOPTIMIZE() { return GetTokens(OracleAntlrParser.MEMOPTIMIZE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEMOPTIMIZE(int i) {
			return GetToken(OracleAntlrParser.MEMOPTIMIZE, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] FOR() { return GetTokens(OracleAntlrParser.FOR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR(int i) {
			return GetToken(OracleAntlrParser.FOR, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] READ() { return GetTokens(OracleAntlrParser.READ); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READ(int i) {
			return GetToken(OracleAntlrParser.READ, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] WRITE() { return GetTokens(OracleAntlrParser.WRITE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRITE(int i) {
			return GetToken(OracleAntlrParser.WRITE, i);
		}
		public MemOptimizeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_memOptimizeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMemOptimizeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMemOptimizeClause(this);
		}
	}

	[RuleVersion(0)]
	public MemOptimizeClauseContext memOptimizeClause() {
		MemOptimizeClauseContext _localctx = new MemOptimizeClauseContext(Context, State);
		EnterRule(_localctx, 558, RULE_memOptimizeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3619;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 3616;
				Match(MEMOPTIMIZE);
				State = 3617;
				Match(FOR);
				State = 3618;
				_la = TokenStream.LA(1);
				if ( !(_la==READ || _la==WRITE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				}
				State = 3621;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==MEMOPTIMIZE );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParentClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARENT() { return GetToken(OracleAntlrParser.PARENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public ParentClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parentClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterParentClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitParentClause(this);
		}
	}

	[RuleVersion(0)]
	public ParentClauseContext parentClause() {
		ParentClauseContext _localctx = new ParentClauseContext(Context, State);
		EnterRule(_localctx, 560, RULE_parentClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3623;
			Match(PARENT);
			State = 3624;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OidIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OIDINDEX() { return GetToken(OracleAntlrParser.OIDINDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OidIndexClauseListContext oidIndexClauseList() {
			return GetRuleContext<OidIndexClauseListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public OidIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_oidIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOidIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOidIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public OidIndexClauseContext oidIndexClause() {
		OidIndexClauseContext _localctx = new OidIndexClauseContext(Context, State);
		EnterRule(_localctx, 562, RULE_oidIndexClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3626;
			Match(OIDINDEX);
			State = 3628;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 3627;
				identifier();
				}
			}

			State = 3630;
			oidIndexClauseList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OidIndexClauseListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext[] physicalAttribute() {
			return GetRuleContexts<PhysicalAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute(int i) {
			return GetRuleContext<PhysicalAttributeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext[] tablespaceClause() {
			return GetRuleContexts<TablespaceClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause(int i) {
			return GetRuleContext<TablespaceClauseContext>(i);
		}
		public OidIndexClauseListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_oidIndexClauseList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOidIndexClauseList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOidIndexClauseList(this);
		}
	}

	[RuleVersion(0)]
	public OidIndexClauseListContext oidIndexClauseList() {
		OidIndexClauseListContext _localctx = new OidIndexClauseListContext(Context, State);
		EnterRule(_localctx, 564, RULE_oidIndexClauseList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3632;
			Match(LPAREN);
			State = 3635;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 3635;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case INITRANS:
				case MAXTRANS:
				case PCTFREE:
				case PCTUSED:
				case STORAGE:
					{
					State = 3633;
					physicalAttribute();
					}
					break;
				case TABLESPACE:
					{
					State = 3634;
					tablespaceClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 3637;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==INITRANS || _la==MAXTRANS || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE );
			State = 3639;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectIdentifierIsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(OracleAntlrParser.OBJECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(OracleAntlrParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SYSTEM() { return GetToken(OracleAntlrParser.SYSTEM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GENERATED() { return GetToken(OracleAntlrParser.GENERATED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIMARY() { return GetToken(OracleAntlrParser.PRIMARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(OracleAntlrParser.KEY, 0); }
		public ObjectIdentifierIsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectIdentifierIsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectIdentifierIsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectIdentifierIsClause(this);
		}
	}

	[RuleVersion(0)]
	public ObjectIdentifierIsClauseContext objectIdentifierIsClause() {
		ObjectIdentifierIsClauseContext _localctx = new ObjectIdentifierIsClauseContext(Context, State);
		EnterRule(_localctx, 566, RULE_objectIdentifierIsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3641;
			Match(OBJECT);
			State = 3642;
			Match(IDENTIFIER);
			State = 3643;
			Match(IS);
			State = 3648;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SYSTEM:
				{
				State = 3644;
				Match(SYSTEM);
				State = 3645;
				Match(GENERATED);
				}
				break;
			case PRIMARY:
				{
				State = 3646;
				Match(PRIMARY);
				State = 3647;
				Match(KEY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTableOfClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotSubstitutableClauseContext notSubstitutableClause() {
			return GetRuleContext<NotSubstitutableClauseContext>(0);
		}
		public ObjectTableOfClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTableOfClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectTableOfClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectTableOfClause(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTableOfClauseContext objectTableOfClause() {
		ObjectTableOfClauseContext _localctx = new ObjectTableOfClauseContext(Context, State);
		EnterRule(_localctx, 568, RULE_objectTableOfClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3650;
			Match(OF);
			State = 3651;
			plainIdentifier();
			State = 3653;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT || _la==SUBSTITUTABLE) {
				{
				State = 3652;
				notSubstitutableClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateRelationTableStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TablePropertiesClauseContext tablePropertiesClause() {
			return GetRuleContext<TablePropertiesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelationPropertiesListClauseContext relationPropertiesListClause() {
			return GetRuleContext<RelationPropertiesListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultCollationOptionContext defaultCollationOption() {
			return GetRuleContext<DefaultCollationOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnCommitClauseContext onCommitClause() {
			return GetRuleContext<OnCommitClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalPropertiesClauseContext physicalPropertiesClause() {
			return GetRuleContext<PhysicalPropertiesClauseContext>(0);
		}
		public CreateRelationTableStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createRelationTableStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateRelationTableStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateRelationTableStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateRelationTableStatementContext createRelationTableStatement() {
		CreateRelationTableStatementContext _localctx = new CreateRelationTableStatementContext(Context, State);
		EnterRule(_localctx, 570, RULE_createRelationTableStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3656;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 3655;
				relationPropertiesListClause();
				}
			}

			State = 3659;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT) {
				{
				State = 3658;
				defaultCollationOption();
				}
			}

			State = 3662;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 3661;
				onCommitClause();
				}
			}

			State = 3665;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,276,Context) ) {
			case 1:
				{
				State = 3664;
				physicalPropertiesClause();
				}
				break;
			}
			State = 3667;
			tablePropertiesClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateXMLTypeTableStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLTYPE() { return GetToken(OracleAntlrParser.XMLTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectPropertiesListClauseContext objectPropertiesListClause() {
			return GetRuleContext<ObjectPropertiesListClauseContext>(0);
		}
		public CreateXMLTypeTableStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createXMLTypeTableStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateXMLTypeTableStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateXMLTypeTableStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateXMLTypeTableStatementContext createXMLTypeTableStatement() {
		CreateXMLTypeTableStatementContext _localctx = new CreateXMLTypeTableStatementContext(Context, State);
		EnterRule(_localctx, 572, RULE_createXMLTypeTableStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3669;
			Match(OF);
			State = 3670;
			Match(XMLTYPE);
			State = 3672;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 3671;
				objectPropertiesListClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TablePropertiesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ColumnPropertiesContext columnProperties() {
			return GetRuleContext<ColumnPropertiesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitioningDefinitionClauseContext partitioningDefinitionClause() {
			return GetRuleContext<PartitioningDefinitionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LobPropertiesListElementClauseContext lobPropertiesListElementClause() {
			return GetRuleContext<LobPropertiesListElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RowdependenciesClauseContext rowdependenciesClause() {
			return GetRuleContext<RowdependenciesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MonitoringClauseContext monitoringClause() {
			return GetRuleContext<MonitoringClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnableDisableConstraintClauseContext[] enableDisableConstraintClause() {
			return GetRuleContexts<EnableDisableConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnableDisableConstraintClauseContext enableDisableConstraintClause(int i) {
			return GetRuleContext<EnableDisableConstraintClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RowMovementClauseContext rowMovementClause() {
			return GetRuleContext<RowMovementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AsSubqueryClauseContext asSubqueryClause() {
			return GetRuleContext<AsSubqueryClauseContext>(0);
		}
		public TablePropertiesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablePropertiesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTablePropertiesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTablePropertiesClause(this);
		}
	}

	[RuleVersion(0)]
	public TablePropertiesClauseContext tablePropertiesClause() {
		TablePropertiesClauseContext _localctx = new TablePropertiesClauseContext(Context, State);
		EnterRule(_localctx, 574, RULE_tablePropertiesClause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3675;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLUMN || _la==LOB || _la==NESTED || _la==VARRAY || _la==XMLTYPE) {
				{
				State = 3674;
				columnProperties();
				}
			}

			State = 3678;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 3677;
				partitioningDefinitionClause();
				}
			}

			State = 3681;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,280,Context) ) {
			case 1:
				{
				State = 3680;
				lobPropertiesListElementClause();
				}
				break;
			}
			State = 3684;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOPARALLEL || _la==PARALLEL) {
				{
				State = 3683;
				parallelClause();
				}
			}

			State = 3687;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOROWDEPENDENCIES || _la==ROWDEPENDENCIES) {
				{
				State = 3686;
				rowdependenciesClause();
				}
			}

			State = 3690;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MONITORING || _la==NOMONITORING) {
				{
				State = 3689;
				monitoringClause();
				}
			}

			State = 3695;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,284,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 3692;
					enableDisableConstraintClause();
					}
					} 
				}
				State = 3697;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,284,Context);
			}
			State = 3699;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DISABLE || _la==ENABLE) {
				{
				State = 3698;
				rowMovementClause();
				}
			}

			State = 3702;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 3701;
				asSubqueryClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NestedTableColPropertiesContext[] nestedTableColProperties() {
			return GetRuleContexts<NestedTableColPropertiesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NestedTableColPropertiesContext nestedTableColProperties(int i) {
			return GetRuleContext<NestedTableColPropertiesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeColPropertiesContext[] objectTypeColProperties() {
			return GetRuleContexts<ObjectTypeColPropertiesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeColPropertiesContext objectTypeColProperties(int i) {
			return GetRuleContext<ObjectTypeColPropertiesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeColumnPropertiesContext[] xmlTypeColumnProperties() {
			return GetRuleContexts<XmlTypeColumnPropertiesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeColumnPropertiesContext xmlTypeColumnProperties(int i) {
			return GetRuleContext<XmlTypeColumnPropertiesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayStorageClauseContext[] varrayStorageClause() {
			return GetRuleContexts<VarrayStorageClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayStorageClauseContext varrayStorageClause(int i) {
			return GetRuleContext<VarrayStorageClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBStorageClauseContext[] lOBStorageClause() {
			return GetRuleContexts<LOBStorageClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBStorageClauseContext lOBStorageClause(int i) {
			return GetRuleContext<LOBStorageClauseContext>(i);
		}
		public ColumnPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterColumnProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitColumnProperties(this);
		}
	}

	[RuleVersion(0)]
	public ColumnPropertiesContext columnProperties() {
		ColumnPropertiesContext _localctx = new ColumnPropertiesContext(Context, State);
		EnterRule(_localctx, 576, RULE_columnProperties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3711;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 3711;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case NESTED:
					{
					State = 3704;
					nestedTableColProperties();
					}
					break;
				case COLUMN:
					{
					State = 3705;
					objectTypeColProperties();
					}
					break;
				case LOB:
				case VARRAY:
					{
					State = 3708;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case VARRAY:
						{
						State = 3706;
						varrayStorageClause();
						}
						break;
					case LOB:
						{
						State = 3707;
						lOBStorageClause();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				case XMLTYPE:
					{
					State = 3710;
					xmlTypeColumnProperties();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 3713;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COLUMN || _la==LOB || _la==NESTED || _la==VARRAY || _la==XMLTYPE );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeColumnPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLTYPE() { return GetToken(OracleAntlrParser.XMLTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem() {
			return GetRuleContext<ColumnListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlSchemaSpecContext xmlSchemaSpec() {
			return GetRuleContext<XmlSchemaSpecContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMN() { return GetToken(OracleAntlrParser.COLUMN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeStorageClauseContext xmlTypeStorageClause() {
			return GetRuleContext<XmlTypeStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(OracleAntlrParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public XmlTypeColumnPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeColumnProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlTypeColumnProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlTypeColumnProperties(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeColumnPropertiesContext xmlTypeColumnProperties() {
		XmlTypeColumnPropertiesContext _localctx = new XmlTypeColumnPropertiesContext(Context, State);
		EnterRule(_localctx, 578, RULE_xmlTypeColumnProperties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3715;
			Match(XMLTYPE);
			State = 3717;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLUMN) {
				{
				State = 3716;
				Match(COLUMN);
				}
			}

			State = 3719;
			columnListItem();
			State = 3721;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,291,Context) ) {
			case 1:
				{
				State = 3720;
				xmlTypeStorageClause();
				}
				break;
			}
			State = 3723;
			xmlSchemaSpec();
			State = 3726;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ID) {
				{
				State = 3724;
				Match(ID);
				State = 3725;
				literal();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeStoreAsClauseContext xmlTypeStoreAsClause() {
			return GetRuleContext<XmlTypeStoreAsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeStoreAllClauseContext xmlTypeStoreAllClause() {
			return GetRuleContext<XmlTypeStoreAllClauseContext>(0);
		}
		public XmlTypeStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlTypeStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlTypeStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeStorageClauseContext xmlTypeStorageClause() {
		XmlTypeStorageClauseContext _localctx = new XmlTypeStorageClauseContext(Context, State);
		EnterRule(_localctx, 580, RULE_xmlTypeStorageClause);
		try {
			State = 3730;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,293,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3728;
				xmlTypeStoreAsClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3729;
				xmlTypeStoreAllClause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeStoreAsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeStoreAsObjectRelationalClauseContext xmlTypeStoreAsObjectRelationalClause() {
			return GetRuleContext<XmlTypeStoreAsObjectRelationalClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeStoreAsLobClauseContext xmlTypeStoreAsLobClause() {
			return GetRuleContext<XmlTypeStoreAsLobClauseContext>(0);
		}
		public XmlTypeStoreAsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeStoreAsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlTypeStoreAsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlTypeStoreAsClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeStoreAsClauseContext xmlTypeStoreAsClause() {
		XmlTypeStoreAsClauseContext _localctx = new XmlTypeStoreAsClauseContext(Context, State);
		EnterRule(_localctx, 582, RULE_xmlTypeStoreAsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3732;
			Match(STORE);
			State = 3733;
			Match(AS);
			State = 3736;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case OBJECT:
				{
				State = 3734;
				xmlTypeStoreAsObjectRelationalClause();
				}
				break;
			case BASICFILE:
			case BINARY:
			case CLOB:
			case SECUREFILE:
				{
				State = 3735;
				xmlTypeStoreAsLobClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeStoreAsObjectRelationalClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(OracleAntlrParser.OBJECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONAL() { return GetToken(OracleAntlrParser.RELATIONAL, 0); }
		public XmlTypeStoreAsObjectRelationalClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeStoreAsObjectRelationalClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlTypeStoreAsObjectRelationalClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlTypeStoreAsObjectRelationalClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeStoreAsObjectRelationalClauseContext xmlTypeStoreAsObjectRelationalClause() {
		XmlTypeStoreAsObjectRelationalClauseContext _localctx = new XmlTypeStoreAsObjectRelationalClauseContext(Context, State);
		EnterRule(_localctx, 584, RULE_xmlTypeStoreAsObjectRelationalClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3738;
			Match(OBJECT);
			State = 3739;
			Match(RELATIONAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeStoreAsLobClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOB() { return GetToken(OracleAntlrParser.CLOB, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BINARY() { return GetToken(OracleAntlrParser.BINARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XML() { return GetToken(OracleAntlrParser.XML, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBPropertiesListClauseContext lOBPropertiesListClause() {
			return GetRuleContext<LOBPropertiesListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECUREFILE() { return GetToken(OracleAntlrParser.SECUREFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BASICFILE() { return GetToken(OracleAntlrParser.BASICFILE, 0); }
		public XmlTypeStoreAsLobClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeStoreAsLobClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlTypeStoreAsLobClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlTypeStoreAsLobClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeStoreAsLobClauseContext xmlTypeStoreAsLobClause() {
		XmlTypeStoreAsLobClauseContext _localctx = new XmlTypeStoreAsLobClauseContext(Context, State);
		EnterRule(_localctx, 586, RULE_xmlTypeStoreAsLobClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3742;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BASICFILE || _la==SECUREFILE) {
				{
				State = 3741;
				_la = TokenStream.LA(1);
				if ( !(_la==BASICFILE || _la==SECUREFILE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3747;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CLOB:
				{
				State = 3744;
				Match(CLOB);
				}
				break;
			case BINARY:
				{
				State = 3745;
				Match(BINARY);
				State = 3746;
				Match(XML);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3750;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,297,Context) ) {
			case 1:
				{
				State = 3749;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			}
			State = 3753;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 3752;
				lOBPropertiesListClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeStoreAllClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARRAYS() { return GetToken(OracleAntlrParser.VARRAYS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOBS() { return GetToken(OracleAntlrParser.LOBS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLES() { return GetToken(OracleAntlrParser.TABLES, 0); }
		public XmlTypeStoreAllClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeStoreAllClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlTypeStoreAllClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlTypeStoreAllClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeStoreAllClauseContext xmlTypeStoreAllClause() {
		XmlTypeStoreAllClauseContext _localctx = new XmlTypeStoreAllClauseContext(Context, State);
		EnterRule(_localctx, 588, RULE_xmlTypeStoreAllClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3755;
			Match(STORE);
			State = 3756;
			Match(ALL);
			State = 3757;
			Match(VARRAYS);
			State = 3758;
			Match(AS);
			State = 3759;
			_la = TokenStream.LA(1);
			if ( !(_la==LOBS || _la==TABLES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeColPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMN() { return GetToken(OracleAntlrParser.COLUMN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem() {
			return GetRuleContext<ColumnListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubstitutableColumnClauseContext substitutableColumnClause() {
			return GetRuleContext<SubstitutableColumnClauseContext>(0);
		}
		public ObjectTypeColPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeColProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectTypeColProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectTypeColProperties(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeColPropertiesContext objectTypeColProperties() {
		ObjectTypeColPropertiesContext _localctx = new ObjectTypeColPropertiesContext(Context, State);
		EnterRule(_localctx, 590, RULE_objectTypeColProperties);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3761;
			Match(COLUMN);
			State = 3762;
			columnListItem();
			State = 3763;
			substitutableColumnClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarrayColPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARRAY() { return GetToken(OracleAntlrParser.VARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem() {
			return GetRuleContext<ColumnListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubstitutableColumnClauseContext substitutableColumnClause() {
			return GetRuleContext<SubstitutableColumnClauseContext>(0);
		}
		public VarrayColPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varrayColProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterVarrayColProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitVarrayColProperties(this);
		}
	}

	[RuleVersion(0)]
	public VarrayColPropertiesContext varrayColProperties() {
		VarrayColPropertiesContext _localctx = new VarrayColPropertiesContext(Context, State);
		EnterRule(_localctx, 592, RULE_varrayColProperties);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3765;
			Match(VARRAY);
			State = 3766;
			columnListItem();
			State = 3767;
			substitutableColumnClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NestedTableColPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NESTED() { return GetToken(OracleAntlrParser.NESTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NestedItemClauseContext nestedItemClause() {
			return GetRuleContext<NestedItemClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StoreAsClauseContext storeAsClause() {
			return GetRuleContext<StoreAsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubstitutableColumnClauseContext substitutableColumnClause() {
			return GetRuleContext<SubstitutableColumnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NestedTableObjectPropertiesContext nestedTableObjectProperties() {
			return GetRuleContext<NestedTableObjectPropertiesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturnAsClauseContext returnAsClause() {
			return GetRuleContext<ReturnAsClauseContext>(0);
		}
		public NestedTableColPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nestedTableColProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNestedTableColProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNestedTableColProperties(this);
		}
	}

	[RuleVersion(0)]
	public NestedTableColPropertiesContext nestedTableColProperties() {
		NestedTableColPropertiesContext _localctx = new NestedTableColPropertiesContext(Context, State);
		EnterRule(_localctx, 594, RULE_nestedTableColProperties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3769;
			Match(NESTED);
			State = 3770;
			Match(TABLE);
			State = 3771;
			nestedItemClause();
			State = 3773;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELEMENT || _la==IS || _la==NOT || _la==SUBSTITUTABLE) {
				{
				State = 3772;
				substitutableColumnClause();
				}
			}

			State = 3775;
			storeAsClause();
			State = 3777;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 3776;
				nestedTableObjectProperties();
				}
			}

			State = 3780;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURN) {
				{
				State = 3779;
				returnAsClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NestedTableObjectPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectPropertiesListClauseContext objectPropertiesListClause() {
			return GetRuleContext<ObjectPropertiesListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalPropertiesClauseContext physicalPropertiesClause() {
			return GetRuleContext<PhysicalPropertiesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnPropertiesContext columnProperties() {
			return GetRuleContext<ColumnPropertiesContext>(0);
		}
		public NestedTableObjectPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nestedTableObjectProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNestedTableObjectProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNestedTableObjectProperties(this);
		}
	}

	[RuleVersion(0)]
	public NestedTableObjectPropertiesContext nestedTableObjectProperties() {
		NestedTableObjectPropertiesContext _localctx = new NestedTableObjectPropertiesContext(Context, State);
		EnterRule(_localctx, 596, RULE_nestedTableObjectProperties);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3782;
			Match(LPAREN);
			State = 3786;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,302,Context) ) {
			case 1:
				{
				State = 3783;
				objectPropertiesListClause();
				}
				break;
			case 2:
				{
				State = 3784;
				physicalPropertiesClause();
				}
				break;
			case 3:
				{
				State = 3785;
				columnProperties();
				}
				break;
			}
			State = 3788;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnAsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(OracleAntlrParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCATOR() { return GetToken(OracleAntlrParser.LOCATOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(OracleAntlrParser.VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		public ReturnAsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnAsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterReturnAsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitReturnAsClause(this);
		}
	}

	[RuleVersion(0)]
	public ReturnAsClauseContext returnAsClause() {
		ReturnAsClauseContext _localctx = new ReturnAsClauseContext(Context, State);
		EnterRule(_localctx, 598, RULE_returnAsClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3790;
			Match(RETURN);
			State = 3792;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 3791;
				Match(AS);
				}
			}

			State = 3794;
			_la = TokenStream.LA(1);
			if ( !(_la==LOCATOR || _la==VALUE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectPropertiesListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectPropertiesContext[] objectProperties() {
			return GetRuleContexts<ObjectPropertiesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectPropertiesContext objectProperties(int i) {
			return GetRuleContext<ObjectPropertiesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ObjectPropertiesListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectPropertiesListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectPropertiesListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectPropertiesListClause(this);
		}
	}

	[RuleVersion(0)]
	public ObjectPropertiesListClauseContext objectPropertiesListClause() {
		ObjectPropertiesListClauseContext _localctx = new ObjectPropertiesListClauseContext(Context, State);
		EnterRule(_localctx, 600, RULE_objectPropertiesListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3796;
			Match(LPAREN);
			State = 3797;
			objectProperties();
			State = 3802;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3798;
				Match(COMMA);
				State = 3799;
				objectProperties();
				}
				}
				State = 3804;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3805;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TableRefConstraintClauseContext tableRefConstraintClause() {
			return GetRuleContext<TableRefConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableConstraintClauseContext tableConstraintClause() {
			return GetRuleContext<TableConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SupplementalLoggingPropsClauseContext supplementalLoggingPropsClause() {
			return GetRuleContext<SupplementalLoggingPropsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComplexColumnListItemContext complexColumnListItem() {
			return GetRuleContext<ComplexColumnListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem() {
			return GetRuleContext<ColumnListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultValueClauseContext defaultValueClause() {
			return GetRuleContext<DefaultValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnRefConstraintClauseContext columnRefConstraintClause() {
			return GetRuleContext<ColumnRefConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext[] columnConstraintClause() {
			return GetRuleContexts<ColumnConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext columnConstraintClause(int i) {
			return GetRuleContext<ColumnConstraintClauseContext>(i);
		}
		public ObjectPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectProperties(this);
		}
	}

	[RuleVersion(0)]
	public ObjectPropertiesContext objectProperties() {
		ObjectPropertiesContext _localctx = new ObjectPropertiesContext(Context, State);
		EnterRule(_localctx, 602, RULE_objectProperties);
		int _la;
		try {
			State = 3825;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,309,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3807;
				tableRefConstraintClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3808;
				tableConstraintClause();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3809;
				supplementalLoggingPropsClause();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3812;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,305,Context) ) {
				case 1:
					{
					State = 3810;
					complexColumnListItem();
					}
					break;
				case 2:
					{
					State = 3811;
					columnListItem();
					}
					break;
				}
				State = 3815;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT || _la==ASSIGN_OPERATOR) {
					{
					State = 3814;
					defaultValueClause();
					}
				}

				State = 3823;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,308,Context) ) {
				case 1:
					{
					State = 3817;
					columnRefConstraintClause();
					}
					break;
				case 2:
					{
					State = 3819;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 3818;
						columnConstraintClause();
						}
						}
						State = 3821;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( _la==CHECK || _la==CONSTRAINT || _la==FOREIGN || ((((_la - 344)) & ~0x3f) == 0 && ((1L << (_la - 344)) & ((1L << (NOT - 344)) | (1L << (NULL - 344)) | (1L << (PRIMARY - 344)))) != 0) || _la==REFERENCES || _la==UNIQUE || _la==LPAREN );
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StoreAsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public StoreAsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storeAsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterStoreAsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitStoreAsClause(this);
		}
	}

	[RuleVersion(0)]
	public StoreAsClauseContext storeAsClause() {
		StoreAsClauseContext _localctx = new StoreAsClauseContext(Context, State);
		EnterRule(_localctx, 604, RULE_storeAsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3827;
			Match(STORE);
			State = 3828;
			Match(AS);
			State = 3829;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NestedItemClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMN_VALUE() { return GetToken(OracleAntlrParser.COLUMN_VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ComplexColumnListItemContext complexColumnListItem() {
			return GetRuleContext<ComplexColumnListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem() {
			return GetRuleContext<ColumnListItemContext>(0);
		}
		public NestedItemClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nestedItemClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNestedItemClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNestedItemClause(this);
		}
	}

	[RuleVersion(0)]
	public NestedItemClauseContext nestedItemClause() {
		NestedItemClauseContext _localctx = new NestedItemClauseContext(Context, State);
		EnterRule(_localctx, 606, RULE_nestedItemClause);
		try {
			State = 3836;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,311,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3831;
				Match(COLUMN_VALUE);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3834;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,310,Context) ) {
				case 1:
					{
					State = 3832;
					complexColumnListItem();
					}
					break;
				case 2:
					{
					State = 3833;
					columnListItem();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsSubqueryClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public AsSubqueryClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asSubqueryClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAsSubqueryClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAsSubqueryClause(this);
		}
	}

	[RuleVersion(0)]
	public AsSubqueryClauseContext asSubqueryClause() {
		AsSubqueryClauseContext _localctx = new AsSubqueryClauseContext(Context, State);
		EnterRule(_localctx, 608, RULE_asSubqueryClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3838;
			Match(AS);
			State = 3839;
			selectStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RowMovementClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EnableClauseContext enableClause() {
			return GetRuleContext<EnableClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MOVEMENT() { return GetToken(OracleAntlrParser.MOVEMENT, 0); }
		public RowMovementClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rowMovementClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRowMovementClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRowMovementClause(this);
		}
	}

	[RuleVersion(0)]
	public RowMovementClauseContext rowMovementClause() {
		RowMovementClauseContext _localctx = new RowMovementClauseContext(Context, State);
		EnterRule(_localctx, 610, RULE_rowMovementClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3841;
			enableClause();
			State = 3842;
			Match(ROW);
			State = 3843;
			Match(MOVEMENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnableDisableConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EnableClauseContext enableClause() {
			return GetRuleContext<EnableClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintPrimaryKeyClauseContext constraintPrimaryKeyClause() {
			return GetRuleContext<ConstraintPrimaryKeyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintUniqueClauseContext constraintUniqueClause() {
			return GetRuleContext<ConstraintUniqueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintNameClauseContext constraintNameClause() {
			return GetRuleContext<ConstraintNameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ValidateClauseContext validateClause() {
			return GetRuleContext<ValidateClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingIndexConstraintClauseContext usingIndexConstraintClause() {
			return GetRuleContext<UsingIndexConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionsIntoConstraintClauseContext exceptionsIntoConstraintClause() {
			return GetRuleContext<ExceptionsIntoConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CascadeClauseContext cascadeClause() {
			return GetRuleContext<CascadeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeepDropIndexClauseContext keepDropIndexClause() {
			return GetRuleContext<KeepDropIndexClauseContext>(0);
		}
		public EnableDisableConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enableDisableConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterEnableDisableConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitEnableDisableConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public EnableDisableConstraintClauseContext enableDisableConstraintClause() {
		EnableDisableConstraintClauseContext _localctx = new EnableDisableConstraintClauseContext(Context, State);
		EnterRule(_localctx, 612, RULE_enableDisableConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3845;
			enableClause();
			State = 3847;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOVALIDATE || _la==VALIDATE) {
				{
				State = 3846;
				validateClause();
				}
			}

			State = 3852;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PRIMARY:
				{
				State = 3849;
				constraintPrimaryKeyClause();
				}
				break;
			case UNIQUE:
				{
				State = 3850;
				constraintUniqueClause();
				}
				break;
			case CONSTRAINT:
				{
				State = 3851;
				constraintNameClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3855;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 3854;
				usingIndexConstraintClause();
				}
			}

			State = 3858;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXCEPTIONS) {
				{
				State = 3857;
				exceptionsIntoConstraintClause();
				}
			}

			State = 3861;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CASCADE) {
				{
				State = 3860;
				cascadeClause();
				}
			}

			State = 3864;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DROP || _la==KEEP) {
				{
				State = 3863;
				keepDropIndexClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeepDropIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(OracleAntlrParser.DROP, 0); }
		public KeepDropIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keepDropIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterKeepDropIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitKeepDropIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public KeepDropIndexClauseContext keepDropIndexClause() {
		KeepDropIndexClauseContext _localctx = new KeepDropIndexClauseContext(Context, State);
		EnterRule(_localctx, 614, RULE_keepDropIndexClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3866;
			_la = TokenStream.LA(1);
			if ( !(_la==DROP || _la==KEEP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3867;
			Match(INDEX);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CascadeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASCADE() { return GetToken(OracleAntlrParser.CASCADE, 0); }
		public CascadeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cascadeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCascadeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCascadeClause(this);
		}
	}

	[RuleVersion(0)]
	public CascadeClauseContext cascadeClause() {
		CascadeClauseContext _localctx = new CascadeClauseContext(Context, State);
		EnterRule(_localctx, 616, RULE_cascadeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3869;
			Match(CASCADE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MonitoringClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MONITORING() { return GetToken(OracleAntlrParser.MONITORING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMONITORING() { return GetToken(OracleAntlrParser.NOMONITORING, 0); }
		public MonitoringClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_monitoringClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMonitoringClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMonitoringClause(this);
		}
	}

	[RuleVersion(0)]
	public MonitoringClauseContext monitoringClause() {
		MonitoringClauseContext _localctx = new MonitoringClauseContext(Context, State);
		EnterRule(_localctx, 618, RULE_monitoringClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3871;
			_la = TokenStream.LA(1);
			if ( !(_la==MONITORING || _la==NOMONITORING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RowdependenciesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWDEPENDENCIES() { return GetToken(OracleAntlrParser.ROWDEPENDENCIES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOROWDEPENDENCIES() { return GetToken(OracleAntlrParser.NOROWDEPENDENCIES, 0); }
		public RowdependenciesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rowdependenciesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRowdependenciesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRowdependenciesClause(this);
		}
	}

	[RuleVersion(0)]
	public RowdependenciesClauseContext rowdependenciesClause() {
		RowdependenciesClauseContext _localctx = new RowdependenciesClauseContext(Context, State);
		EnterRule(_localctx, 620, RULE_rowdependenciesClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3873;
			_la = TokenStream.LA(1);
			if ( !(_la==NOROWDEPENDENCIES || _la==ROWDEPENDENCIES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParallelClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARALLEL() { return GetToken(OracleAntlrParser.PARALLEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOPARALLEL() { return GetToken(OracleAntlrParser.NOPARALLEL, 0); }
		public ParallelClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallelClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterParallelClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitParallelClause(this);
		}
	}

	[RuleVersion(0)]
	public ParallelClauseContext parallelClause() {
		ParallelClauseContext _localctx = new ParallelClauseContext(Context, State);
		EnterRule(_localctx, 622, RULE_parallelClause);
		int _la;
		try {
			State = 3880;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PARALLEL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3875;
				Match(PARALLEL);
				State = 3877;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATE || _la==FALSE || _la==INTERVAL || _la==TIMESTAMP || _la==TRUE || ((((_la - 579)) & ~0x3f) == 0 && ((1L << (_la - 579)) & ((1L << (INTEGER_LITERAL - 579)) | (1L << (FLOATING_POINT_LITERAL - 579)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 579)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 579)) | (1L << (BINARY_STRING_LITERAL - 579)) | (1L << (CHARACTER_STRING_LITERAL - 579)) | (1L << (MONEY_LITERAL - 579)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 579)))) != 0)) {
					{
					State = 3876;
					literal();
					}
				}

				}
				break;
			case NOPARALLEL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3879;
				Match(NOPARALLEL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitioningDefinitionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartitionByHashClauseContext partitionByHashClause() {
			return GetRuleContext<PartitionByHashClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompositePartitioningContext compositePartitioning() {
			return GetRuleContext<CompositePartitioningContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionByRangeClauseContext partitionByRangeClause() {
			return GetRuleContext<PartitionByRangeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionByListClauseContext partitionByListClause() {
			return GetRuleContext<PartitionByListClauseContext>(0);
		}
		public PartitioningDefinitionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitioningDefinitionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPartitioningDefinitionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPartitioningDefinitionClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitioningDefinitionClauseContext partitioningDefinitionClause() {
		PartitioningDefinitionClauseContext _localctx = new PartitioningDefinitionClauseContext(Context, State);
		EnterRule(_localctx, 624, RULE_partitioningDefinitionClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3882;
			Match(PARTITION);
			State = 3883;
			Match(BY);
			State = 3888;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,320,Context) ) {
			case 1:
				{
				State = 3884;
				partitionByHashClause();
				}
				break;
			case 2:
				{
				State = 3885;
				compositePartitioning();
				}
				break;
			case 3:
				{
				State = 3886;
				partitionByRangeClause();
				}
				break;
			case 4:
				{
				State = 3887;
				partitionByListClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompositePartitioningContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(OracleAntlrParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionDefinitionListClauseContext partitionDefinitionListClause() {
			return GetRuleContext<PartitionDefinitionListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubPartitionByListContext subPartitionByList() {
			return GetRuleContext<SubPartitionByListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubPartitionByHashContext subPartitionByHash() {
			return GetRuleContext<SubPartitionByHashContext>(0);
		}
		public CompositePartitioningContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compositePartitioning; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCompositePartitioning(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCompositePartitioning(this);
		}
	}

	[RuleVersion(0)]
	public CompositePartitioningContext compositePartitioning() {
		CompositePartitioningContext _localctx = new CompositePartitioningContext(Context, State);
		EnterRule(_localctx, 626, RULE_compositePartitioning);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3890;
			Match(RANGE);
			State = 3891;
			columnListInParenElementClause();
			State = 3894;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,321,Context) ) {
			case 1:
				{
				State = 3892;
				subPartitionByList();
				}
				break;
			case 2:
				{
				State = 3893;
				subPartitionByHash();
				}
				break;
			}
			State = 3896;
			partitionDefinitionListClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubPartitionByHashContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(OracleAntlrParser.HASH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubpartitionsStoreInClauseContext subpartitionsStoreInClause() {
			return GetRuleContext<SubpartitionsStoreInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubPartitionTemplateContext subPartitionTemplate() {
			return GetRuleContext<SubPartitionTemplateContext>(0);
		}
		public SubPartitionByHashContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subPartitionByHash; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubPartitionByHash(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubPartitionByHash(this);
		}
	}

	[RuleVersion(0)]
	public SubPartitionByHashContext subPartitionByHash() {
		SubPartitionByHashContext _localctx = new SubPartitionByHashContext(Context, State);
		EnterRule(_localctx, 628, RULE_subPartitionByHash);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3898;
			Match(SUBPARTITION);
			State = 3899;
			Match(BY);
			State = 3900;
			Match(HASH);
			State = 3901;
			columnListInParenElementClause();
			State = 3904;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SUBPARTITIONS:
				{
				State = 3902;
				subpartitionsStoreInClause();
				}
				break;
			case SUBPARTITION:
				{
				State = 3903;
				subPartitionTemplate();
				}
				break;
			case LPAREN:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubpartitionsStoreInClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITIONS() { return GetToken(OracleAntlrParser.SUBPARTITIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsStoreInClauseContext partitionsStoreInClause() {
			return GetRuleContext<PartitionsStoreInClauseContext>(0);
		}
		public SubpartitionsStoreInClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartitionsStoreInClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubpartitionsStoreInClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubpartitionsStoreInClause(this);
		}
	}

	[RuleVersion(0)]
	public SubpartitionsStoreInClauseContext subpartitionsStoreInClause() {
		SubpartitionsStoreInClauseContext _localctx = new SubpartitionsStoreInClauseContext(Context, State);
		EnterRule(_localctx, 630, RULE_subpartitionsStoreInClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3906;
			Match(SUBPARTITIONS);
			State = 3907;
			literal();
			State = 3909;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STORE) {
				{
				State = 3908;
				partitionsStoreInClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubPartitionByListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIST() { return GetToken(OracleAntlrParser.LIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubPartitionTemplateContext subPartitionTemplate() {
			return GetRuleContext<SubPartitionTemplateContext>(0);
		}
		public SubPartitionByListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subPartitionByList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubPartitionByList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubPartitionByList(this);
		}
	}

	[RuleVersion(0)]
	public SubPartitionByListContext subPartitionByList() {
		SubPartitionByListContext _localctx = new SubPartitionByListContext(Context, State);
		EnterRule(_localctx, 632, RULE_subPartitionByList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3911;
			Match(SUBPARTITION);
			State = 3912;
			Match(BY);
			State = 3913;
			Match(LIST);
			State = 3914;
			columnListInParenElementClause();
			State = 3916;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SUBPARTITION) {
				{
				State = 3915;
				subPartitionTemplate();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubPartitionTemplateContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEMPLATE() { return GetToken(OracleAntlrParser.TEMPLATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SubPartitionDefinitionListClauseContext subPartitionDefinitionListClause() {
			return GetRuleContext<SubPartitionDefinitionListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public SubPartitionTemplateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subPartitionTemplate; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubPartitionTemplate(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubPartitionTemplate(this);
		}
	}

	[RuleVersion(0)]
	public SubPartitionTemplateContext subPartitionTemplate() {
		SubPartitionTemplateContext _localctx = new SubPartitionTemplateContext(Context, State);
		EnterRule(_localctx, 634, RULE_subPartitionTemplate);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3918;
			Match(SUBPARTITION);
			State = 3919;
			Match(TEMPLATE);
			State = 3922;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				{
				State = 3920;
				subPartitionDefinitionListClause();
				}
				break;
			case DATE:
			case FALSE:
			case INTERVAL:
			case TIMESTAMP:
			case TRUE:
			case INTEGER_LITERAL:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case QUOTE_CHARACTER_STRING_LITERAL:
				{
				State = 3921;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubPartitionDefinitionListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SubPartitionDefinitionClauseContext[] subPartitionDefinitionClause() {
			return GetRuleContexts<SubPartitionDefinitionClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubPartitionDefinitionClauseContext subPartitionDefinitionClause(int i) {
			return GetRuleContext<SubPartitionDefinitionClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public SubPartitionDefinitionListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subPartitionDefinitionListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubPartitionDefinitionListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubPartitionDefinitionListClause(this);
		}
	}

	[RuleVersion(0)]
	public SubPartitionDefinitionListClauseContext subPartitionDefinitionListClause() {
		SubPartitionDefinitionListClauseContext _localctx = new SubPartitionDefinitionListClauseContext(Context, State);
		EnterRule(_localctx, 636, RULE_subPartitionDefinitionListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3924;
			Match(LPAREN);
			State = 3925;
			subPartitionDefinitionClause();
			State = 3930;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3926;
				Match(COMMA);
				State = 3927;
				subPartitionDefinitionClause();
				}
				}
				State = 3932;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3933;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubPartitionDefinitionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListValuesClauseContext listValuesClause() {
			return GetRuleContext<ListValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitioningStorageClauseContext partitioningStorageClause() {
			return GetRuleContext<PartitioningStorageClauseContext>(0);
		}
		public SubPartitionDefinitionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subPartitionDefinitionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubPartitionDefinitionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubPartitionDefinitionClause(this);
		}
	}

	[RuleVersion(0)]
	public SubPartitionDefinitionClauseContext subPartitionDefinitionClause() {
		SubPartitionDefinitionClauseContext _localctx = new SubPartitionDefinitionClauseContext(Context, State);
		EnterRule(_localctx, 638, RULE_subPartitionDefinitionClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3935;
			Match(SUBPARTITION);
			State = 3936;
			simpleIdentifier();
			State = 3938;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==VALUES) {
				{
				State = 3937;
				listValuesClause();
				}
			}

			State = 3941;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOB || _la==OVERFLOW || _la==TABLESPACE || _la==VARRAY) {
				{
				State = 3940;
				partitioningStorageClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionByListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIST() { return GetToken(OracleAntlrParser.LIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionDefinitionListClauseContext partitionDefinitionListClause() {
			return GetRuleContext<PartitionDefinitionListClauseContext>(0);
		}
		public PartitionByListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionByListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPartitionByListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPartitionByListClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionByListClauseContext partitionByListClause() {
		PartitionByListClauseContext _localctx = new PartitionByListClauseContext(Context, State);
		EnterRule(_localctx, 640, RULE_partitionByListClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3943;
			Match(LIST);
			State = 3944;
			columnListInParenElementClause();
			State = 3945;
			partitionDefinitionListClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionByHashClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(OracleAntlrParser.HASH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsSimpleClauseContext partitionsSimpleClause() {
			return GetRuleContext<PartitionsSimpleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionSimpleListClauseContext partitionSimpleListClause() {
			return GetRuleContext<PartitionSimpleListClauseContext>(0);
		}
		public PartitionByHashClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionByHashClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPartitionByHashClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPartitionByHashClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionByHashClauseContext partitionByHashClause() {
		PartitionByHashClauseContext _localctx = new PartitionByHashClauseContext(Context, State);
		EnterRule(_localctx, 642, RULE_partitionByHashClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3947;
			Match(HASH);
			State = 3948;
			columnListInParenElementClause();
			State = 3951;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PARTITIONS:
				{
				State = 3949;
				partitionsSimpleClause();
				}
				break;
			case LPAREN:
				{
				State = 3950;
				partitionSimpleListClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionsSimpleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITIONS() { return GetToken(OracleAntlrParser.PARTITIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsStoreInClauseContext partitionsStoreInClause() {
			return GetRuleContext<PartitionsStoreInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverflowClauseContext overflowClause() {
			return GetRuleContext<OverflowClauseContext>(0);
		}
		public PartitionsSimpleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionsSimpleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPartitionsSimpleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPartitionsSimpleClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionsSimpleClauseContext partitionsSimpleClause() {
		PartitionsSimpleClauseContext _localctx = new PartitionsSimpleClauseContext(Context, State);
		EnterRule(_localctx, 644, RULE_partitionsSimpleClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3953;
			Match(PARTITIONS);
			State = 3954;
			literal();
			State = 3956;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,330,Context) ) {
			case 1:
				{
				State = 3955;
				partitionsStoreInClause();
				}
				break;
			}
			State = 3959;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OVERFLOW) {
				{
				State = 3958;
				overflowClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionSimpleListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartitionSimpleClauseContext[] partitionSimpleClause() {
			return GetRuleContexts<PartitionSimpleClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionSimpleClauseContext partitionSimpleClause(int i) {
			return GetRuleContext<PartitionSimpleClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public PartitionSimpleListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionSimpleListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPartitionSimpleListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPartitionSimpleListClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionSimpleListClauseContext partitionSimpleListClause() {
		PartitionSimpleListClauseContext _localctx = new PartitionSimpleListClauseContext(Context, State);
		EnterRule(_localctx, 646, RULE_partitionSimpleListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3961;
			Match(LPAREN);
			State = 3962;
			partitionSimpleClause();
			State = 3967;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3963;
				Match(COMMA);
				State = 3964;
				partitionSimpleClause();
				}
				}
				State = 3969;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3970;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionSimpleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartitioningStorageClauseContext partitioningStorageClause() {
			return GetRuleContext<PartitioningStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		public PartitionSimpleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionSimpleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPartitionSimpleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPartitionSimpleClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionSimpleClauseContext partitionSimpleClause() {
		PartitionSimpleClauseContext _localctx = new PartitionSimpleClauseContext(Context, State);
		EnterRule(_localctx, 648, RULE_partitionSimpleClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3972;
			Match(PARTITION);
			State = 3978;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,334,Context) ) {
			case 1:
				{
				State = 3973;
				partitioningStorageClause();
				}
				break;
			case 2:
				{
				State = 3974;
				simpleIdentifier();
				State = 3976;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOB || _la==OVERFLOW || _la==TABLESPACE || _la==VARRAY) {
					{
					State = 3975;
					partitioningStorageClause();
					}
				}

				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionByRangeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PartitionByRangeColumnListContext partitionByRangeColumnList() {
			return GetRuleContext<PartitionByRangeColumnListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionDefinitionListClauseContext partitionDefinitionListClause() {
			return GetRuleContext<PartitionDefinitionListClauseContext>(0);
		}
		public PartitionByRangeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionByRangeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPartitionByRangeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPartitionByRangeClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionByRangeClauseContext partitionByRangeClause() {
		PartitionByRangeClauseContext _localctx = new PartitionByRangeClauseContext(Context, State);
		EnterRule(_localctx, 650, RULE_partitionByRangeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3980;
			partitionByRangeColumnList();
			State = 3981;
			partitionDefinitionListClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionDefinitionListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartitionDefinitionClauseContext[] partitionDefinitionClause() {
			return GetRuleContexts<PartitionDefinitionClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionDefinitionClauseContext partitionDefinitionClause(int i) {
			return GetRuleContext<PartitionDefinitionClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public PartitionDefinitionListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionDefinitionListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPartitionDefinitionListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPartitionDefinitionListClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionDefinitionListClauseContext partitionDefinitionListClause() {
		PartitionDefinitionListClauseContext _localctx = new PartitionDefinitionListClauseContext(Context, State);
		EnterRule(_localctx, 652, RULE_partitionDefinitionListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3983;
			Match(LPAREN);
			State = 3984;
			partitionDefinitionClause();
			State = 3989;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3985;
				Match(COMMA);
				State = 3986;
				partitionDefinitionClause();
				}
				}
				State = 3991;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3992;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionDefinitionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TablePartitionDescriptionContext tablePartitionDescription() {
			return GetRuleContext<TablePartitionDescriptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RangeValuesClauseContext rangeValuesClause() {
			return GetRuleContext<RangeValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListValuesClauseContext listValuesClause() {
			return GetRuleContext<ListValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		public PartitionDefinitionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionDefinitionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPartitionDefinitionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPartitionDefinitionClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionDefinitionClauseContext partitionDefinitionClause() {
		PartitionDefinitionClauseContext _localctx = new PartitionDefinitionClauseContext(Context, State);
		EnterRule(_localctx, 654, RULE_partitionDefinitionClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3994;
			Match(PARTITION);
			State = 3996;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 3995;
				simpleIdentifier();
				}
			}

			State = 4000;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,337,Context) ) {
			case 1:
				{
				State = 3998;
				rangeValuesClause();
				}
				break;
			case 2:
				{
				State = 3999;
				listValuesClause();
				}
				break;
			}
			State = 4002;
			tablePartitionDescription();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TablePartitionDescriptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseContext segmentAttributesClause() {
			return GetRuleContext<SegmentAttributesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableCompressionClauseContext tableCompressionClause() {
			return GetRuleContext<TableCompressionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverflowClauseContext overflowClause() {
			return GetRuleContext<OverflowClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayStorageClauseContext[] varrayStorageClause() {
			return GetRuleContexts<VarrayStorageClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayStorageClauseContext varrayStorageClause(int i) {
			return GetRuleContext<VarrayStorageClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBStorageClauseContext[] lOBStorageClause() {
			return GetRuleContexts<LOBStorageClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBStorageClauseContext lOBStorageClause(int i) {
			return GetRuleContext<LOBStorageClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionLevelSubpartitioningClauseContext partitionLevelSubpartitioningClause() {
			return GetRuleContext<PartitionLevelSubpartitioningClauseContext>(0);
		}
		public TablePartitionDescriptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablePartitionDescription; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTablePartitionDescription(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTablePartitionDescription(this);
		}
	}

	[RuleVersion(0)]
	public TablePartitionDescriptionContext tablePartitionDescription() {
		TablePartitionDescriptionContext _localctx = new TablePartitionDescriptionContext(Context, State);
		EnterRule(_localctx, 656, RULE_tablePartitionDescription);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4005;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 276)) & ~0x3f) == 0 && ((1L << (_la - 276)) & ((1L << (LOGGING - 276)) | (1L << (MAXTRANS - 276)) | (1L << (NOLOGGING - 276)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
				{
				State = 4004;
				segmentAttributesClause();
				}
			}

			State = 4008;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLUMN || _la==COMPRESS || _la==NOCOMPRESS || _la==ROW) {
				{
				State = 4007;
				tableCompressionClause();
				}
			}

			State = 4011;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OVERFLOW) {
				{
				State = 4010;
				overflowClause();
				}
			}

			State = 4017;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==LOB || _la==VARRAY) {
				{
				State = 4015;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case VARRAY:
					{
					State = 4013;
					varrayStorageClause();
					}
					break;
				case LOB:
					{
					State = 4014;
					lOBStorageClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 4019;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4021;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SUBPARTITIONS || _la==LPAREN) {
				{
				State = 4020;
				partitionLevelSubpartitioningClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionLevelSubpartitioningClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SubpartitionsSimpleClauseContext subpartitionsSimpleClause() {
			return GetRuleContext<SubpartitionsSimpleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubpartitionSpecListContext subpartitionSpecList() {
			return GetRuleContext<SubpartitionSpecListContext>(0);
		}
		public PartitionLevelSubpartitioningClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionLevelSubpartitioningClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPartitionLevelSubpartitioningClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPartitionLevelSubpartitioningClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionLevelSubpartitioningClauseContext partitionLevelSubpartitioningClause() {
		PartitionLevelSubpartitioningClauseContext _localctx = new PartitionLevelSubpartitioningClauseContext(Context, State);
		EnterRule(_localctx, 658, RULE_partitionLevelSubpartitioningClause);
		try {
			State = 4025;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SUBPARTITIONS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4023;
				subpartitionsSimpleClause();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4024;
				subpartitionSpecList();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubpartitionSpecListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SubpartitionSpecContext[] subpartitionSpec() {
			return GetRuleContexts<SubpartitionSpecContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubpartitionSpecContext subpartitionSpec(int i) {
			return GetRuleContext<SubpartitionSpecContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public SubpartitionSpecListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartitionSpecList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubpartitionSpecList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubpartitionSpecList(this);
		}
	}

	[RuleVersion(0)]
	public SubpartitionSpecListContext subpartitionSpecList() {
		SubpartitionSpecListContext _localctx = new SubpartitionSpecListContext(Context, State);
		EnterRule(_localctx, 660, RULE_subpartitionSpecList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4027;
			Match(LPAREN);
			State = 4028;
			subpartitionSpec();
			State = 4033;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4029;
				Match(COMMA);
				State = 4030;
				subpartitionSpec();
				}
				}
				State = 4035;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4036;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubpartitionSpecContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartitioningStorageClauseContext partitioningStorageClause() {
			return GetRuleContext<PartitioningStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListValuesClauseContext listValuesClause() {
			return GetRuleContext<ListValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		public SubpartitionSpecContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartitionSpec; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubpartitionSpec(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubpartitionSpec(this);
		}
	}

	[RuleVersion(0)]
	public SubpartitionSpecContext subpartitionSpec() {
		SubpartitionSpecContext _localctx = new SubpartitionSpecContext(Context, State);
		EnterRule(_localctx, 662, RULE_subpartitionSpec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4038;
			Match(SUBPARTITION);
			State = 4051;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,349,Context) ) {
			case 1:
				{
				State = 4039;
				partitioningStorageClause();
				}
				break;
			case 2:
				{
				State = 4040;
				listValuesClause();
				State = 4042;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOB || _la==OVERFLOW || _la==TABLESPACE || _la==VARRAY) {
					{
					State = 4041;
					partitioningStorageClause();
					}
				}

				}
				break;
			case 3:
				{
				State = 4044;
				simpleIdentifier();
				State = 4046;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==VALUES) {
					{
					State = 4045;
					listValuesClause();
					}
				}

				State = 4049;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOB || _la==OVERFLOW || _la==TABLESPACE || _la==VARRAY) {
					{
					State = 4048;
					partitioningStorageClause();
					}
				}

				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitioningStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext[] tablespaceClause() {
			return GetRuleContexts<TablespaceClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause(int i) {
			return GetRuleContext<TablespaceClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverflowClauseContext[] overflowClause() {
			return GetRuleContexts<OverflowClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverflowClauseContext overflowClause(int i) {
			return GetRuleContext<OverflowClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayStorageClauseContext[] varrayStorageClause() {
			return GetRuleContexts<VarrayStorageClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayStorageClauseContext varrayStorageClause(int i) {
			return GetRuleContext<VarrayStorageClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBStorageClauseContext[] lOBStorageClause() {
			return GetRuleContexts<LOBStorageClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBStorageClauseContext lOBStorageClause(int i) {
			return GetRuleContext<LOBStorageClauseContext>(i);
		}
		public PartitioningStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitioningStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPartitioningStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPartitioningStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitioningStorageClauseContext partitioningStorageClause() {
		PartitioningStorageClauseContext _localctx = new PartitioningStorageClauseContext(Context, State);
		EnterRule(_localctx, 664, RULE_partitioningStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4057;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 4057;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TABLESPACE:
					{
					State = 4053;
					tablespaceClause();
					}
					break;
				case OVERFLOW:
					{
					State = 4054;
					overflowClause();
					}
					break;
				case VARRAY:
					{
					State = 4055;
					varrayStorageClause();
					}
					break;
				case LOB:
					{
					State = 4056;
					lOBStorageClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 4059;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==LOB || _la==OVERFLOW || _la==TABLESPACE || _la==VARRAY );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ListValuesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUES() { return GetToken(OracleAntlrParser.VALUES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParenthesizedExpressionListContext parenthesizedExpressionList() {
			return GetRuleContext<ParenthesizedExpressionListContext>(0);
		}
		public ListValuesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_listValuesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterListValuesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitListValuesClause(this);
		}
	}

	[RuleVersion(0)]
	public ListValuesClauseContext listValuesClause() {
		ListValuesClauseContext _localctx = new ListValuesClauseContext(Context, State);
		EnterRule(_localctx, 666, RULE_listValuesClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4061;
			Match(VALUES);
			State = 4062;
			parenthesizedExpressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubpartitionsSimpleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITIONS() { return GetToken(OracleAntlrParser.SUBPARTITIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsStoreInClauseContext partitionsStoreInClause() {
			return GetRuleContext<PartitionsStoreInClauseContext>(0);
		}
		public SubpartitionsSimpleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartitionsSimpleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubpartitionsSimpleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubpartitionsSimpleClause(this);
		}
	}

	[RuleVersion(0)]
	public SubpartitionsSimpleClauseContext subpartitionsSimpleClause() {
		SubpartitionsSimpleClauseContext _localctx = new SubpartitionsSimpleClauseContext(Context, State);
		EnterRule(_localctx, 668, RULE_subpartitionsSimpleClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4064;
			Match(SUBPARTITIONS);
			State = 4065;
			literal();
			State = 4067;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STORE) {
				{
				State = 4066;
				partitionsStoreInClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionsStoreInClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceListClauseContext tablespaceListClause() {
			return GetRuleContext<TablespaceListClauseContext>(0);
		}
		public PartitionsStoreInClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionsStoreInClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPartitionsStoreInClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPartitionsStoreInClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionsStoreInClauseContext partitionsStoreInClause() {
		PartitionsStoreInClauseContext _localctx = new PartitionsStoreInClauseContext(Context, State);
		EnterRule(_localctx, 670, RULE_partitionsStoreInClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4069;
			Match(STORE);
			State = 4070;
			Match(IN);
			State = 4071;
			tablespaceListClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TablespaceListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext[] simpleIdentifierWithoutParentheses() {
			return GetRuleContexts<SimpleIdentifierWithoutParenthesesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses(int i) {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public TablespaceListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablespaceListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTablespaceListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTablespaceListClause(this);
		}
	}

	[RuleVersion(0)]
	public TablespaceListClauseContext tablespaceListClause() {
		TablespaceListClauseContext _localctx = new TablespaceListClauseContext(Context, State);
		EnterRule(_localctx, 672, RULE_tablespaceListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4073;
			Match(LPAREN);
			State = 4074;
			simpleIdentifierWithoutParentheses();
			State = 4079;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4075;
				Match(COMMA);
				State = 4076;
				simpleIdentifierWithoutParentheses();
				}
				}
				State = 4081;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4082;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarrayStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARRAY() { return GetToken(OracleAntlrParser.VARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubstitutableColumnClauseContext substitutableColumnClause() {
			return GetRuleContext<SubstitutableColumnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StoreAsLobClauseContext storeAsLobClause() {
			return GetRuleContext<StoreAsLobClauseContext>(0);
		}
		public VarrayStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varrayStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterVarrayStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitVarrayStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public VarrayStorageClauseContext varrayStorageClause() {
		VarrayStorageClauseContext _localctx = new VarrayStorageClauseContext(Context, State);
		EnterRule(_localctx, 674, RULE_varrayStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4084;
			Match(VARRAY);
			State = 4085;
			simpleIdentifier();
			State = 4087;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELEMENT || _la==IS || _la==NOT || _la==SUBSTITUTABLE) {
				{
				State = 4086;
				substitutableColumnClause();
				}
			}

			State = 4090;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STORE) {
				{
				State = 4089;
				storeAsLobClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubstitutableColumnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ElementIsOfTypeClauseContext elementIsOfTypeClause() {
			return GetRuleContext<ElementIsOfTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotSubstitutableClauseContext notSubstitutableClause() {
			return GetRuleContext<NotSubstitutableClauseContext>(0);
		}
		public SubstitutableColumnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_substitutableColumnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubstitutableColumnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubstitutableColumnClause(this);
		}
	}

	[RuleVersion(0)]
	public SubstitutableColumnClauseContext substitutableColumnClause() {
		SubstitutableColumnClauseContext _localctx = new SubstitutableColumnClauseContext(Context, State);
		EnterRule(_localctx, 676, RULE_substitutableColumnClause);
		try {
			State = 4094;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ELEMENT:
			case IS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4092;
				elementIsOfTypeClause();
				}
				break;
			case NOT:
			case SUBSTITUTABLE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4093;
				notSubstitutableClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NotSubstitutableClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBSTITUTABLE() { return GetToken(OracleAntlrParser.SUBSTITUTABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT() { return GetToken(OracleAntlrParser.AT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEVELS() { return GetToken(OracleAntlrParser.LEVELS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public NotSubstitutableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_notSubstitutableClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNotSubstitutableClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNotSubstitutableClause(this);
		}
	}

	[RuleVersion(0)]
	public NotSubstitutableClauseContext notSubstitutableClause() {
		NotSubstitutableClauseContext _localctx = new NotSubstitutableClauseContext(Context, State);
		EnterRule(_localctx, 678, RULE_notSubstitutableClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4097;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 4096;
				Match(NOT);
				}
			}

			State = 4099;
			Match(SUBSTITUTABLE);
			State = 4100;
			Match(AT);
			State = 4101;
			Match(ALL);
			State = 4102;
			Match(LEVELS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementIsOfTypeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELEMENT() { return GetToken(OracleAntlrParser.ELEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterOnlyContext delimiterOnly() {
			return GetRuleContext<DelimiterOnlyContext>(0);
		}
		public ElementIsOfTypeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementIsOfTypeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterElementIsOfTypeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitElementIsOfTypeClause(this);
		}
	}

	[RuleVersion(0)]
	public ElementIsOfTypeClauseContext elementIsOfTypeClause() {
		ElementIsOfTypeClauseContext _localctx = new ElementIsOfTypeClauseContext(Context, State);
		EnterRule(_localctx, 680, RULE_elementIsOfTypeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4105;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELEMENT) {
				{
				State = 4104;
				Match(ELEMENT);
				}
			}

			State = 4107;
			Match(IS);
			State = 4108;
			Match(OF);
			State = 4110;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TYPE) {
				{
				State = 4109;
				Match(TYPE);
				}
			}

			State = 4112;
			Match(LPAREN);
			State = 4114;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,360,Context) ) {
			case 1:
				{
				State = 4113;
				delimiterOnly();
				}
				break;
			}
			State = 4116;
			typeReference();
			State = 4117;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterOnlyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLY() { return GetToken(OracleAntlrParser.ONLY, 0); }
		public DelimiterOnlyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterOnly; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterOnly(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterOnly(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterOnlyContext delimiterOnly() {
		DelimiterOnlyContext _localctx = new DelimiterOnlyContext(Context, State);
		EnterRule(_localctx, 682, RULE_delimiterOnly);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4119;
			Match(ONLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StoreAsLobClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOB() { return GetToken(OracleAntlrParser.LOB, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LOBPropertiesListClauseContext lOBPropertiesListClause() {
			return GetRuleContext<LOBPropertiesListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECUREFILE() { return GetToken(OracleAntlrParser.SECUREFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BASICFILE() { return GetToken(OracleAntlrParser.BASICFILE, 0); }
		public StoreAsLobClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storeAsLobClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterStoreAsLobClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitStoreAsLobClause(this);
		}
	}

	[RuleVersion(0)]
	public StoreAsLobClauseContext storeAsLobClause() {
		StoreAsLobClauseContext _localctx = new StoreAsLobClauseContext(Context, State);
		EnterRule(_localctx, 684, RULE_storeAsLobClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4121;
			Match(STORE);
			State = 4122;
			Match(AS);
			State = 4124;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BASICFILE || _la==SECUREFILE) {
				{
				State = 4123;
				_la = TokenStream.LA(1);
				if ( !(_la==BASICFILE || _la==SECUREFILE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 4126;
			Match(LOB);
			State = 4132;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				{
				State = 4127;
				lOBPropertiesListClause();
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 4128;
				simpleIdentifierWithoutParentheses();
				State = 4130;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,362,Context) ) {
				case 1:
					{
					State = 4129;
					lOBPropertiesListClause();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LOBStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LobStoreAsClauseContext lobStoreAsClause() {
			return GetRuleContext<LobStoreAsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBPropertiesListClauseContext lOBPropertiesListClause() {
			return GetRuleContext<LOBPropertiesListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public LOBStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lOBStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLOBStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLOBStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public LOBStorageClauseContext lOBStorageClause() {
		LOBStorageClauseContext _localctx = new LOBStorageClauseContext(Context, State);
		EnterRule(_localctx, 686, RULE_lOBStorageClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4134;
			lobStoreAsClause();
			State = 4140;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				{
				State = 4135;
				lOBPropertiesListClause();
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 4136;
				simpleIdentifierWithoutParentheses();
				State = 4138;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,364,Context) ) {
				case 1:
					{
					State = 4137;
					lOBPropertiesListClause();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LOBPropertiesListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext[] tablespaceClause() {
			return GetRuleContexts<TablespaceClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause(int i) {
			return GetRuleContext<TablespaceClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StorageAttributesClauseContext[] storageAttributesClause() {
			return GetRuleContexts<StorageAttributesClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StorageAttributesClauseContext storageAttributesClause(int i) {
			return GetRuleContext<StorageAttributesClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LobPropertiesListElementClauseContext[] lobPropertiesListElementClause() {
			return GetRuleContexts<LobPropertiesListElementClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LobPropertiesListElementClauseContext lobPropertiesListElementClause(int i) {
			return GetRuleContext<LobPropertiesListElementClauseContext>(i);
		}
		public LOBPropertiesListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lOBPropertiesListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLOBPropertiesListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLOBPropertiesListClause(this);
		}
	}

	[RuleVersion(0)]
	public LOBPropertiesListClauseContext lOBPropertiesListClause() {
		LOBPropertiesListClauseContext _localctx = new LOBPropertiesListClauseContext(Context, State);
		EnterRule(_localctx, 688, RULE_lOBPropertiesListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4142;
			Match(LPAREN);
			State = 4146;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 4146;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TABLESPACE:
					{
					State = 4143;
					tablespaceClause();
					}
					break;
				case STORAGE:
					{
					State = 4144;
					storageAttributesClause();
					}
					break;
				case CACHE:
				case CHUNK:
				case COMPRESS:
				case DECRYPT:
				case DEDUPLICATE:
				case DISABLE:
				case ENABLE:
				case ENCRYPT:
				case FREEPOOLS:
				case KEEP_DUPLICATES:
				case NOCACHE:
				case NOCOMPRESS:
				case PCTVERSION:
				case RETENTION:
					{
					State = 4145;
					lobPropertiesListElementClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 4148;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( ((((_la - 52)) & ~0x3f) == 0 && ((1L << (_la - 52)) & ((1L << (CACHE - 52)) | (1L << (CHUNK - 52)) | (1L << (COMPRESS - 52)))) != 0) || ((((_la - 117)) & ~0x3f) == 0 && ((1L << (_la - 117)) & ((1L << (DECRYPT - 117)) | (1L << (DEDUPLICATE - 117)) | (1L << (DISABLE - 117)) | (1L << (ENABLE - 117)) | (1L << (ENCRYPT - 117)))) != 0) || _la==FREEPOOLS || _la==KEEP_DUPLICATES || _la==NOCACHE || _la==NOCOMPRESS || _la==PCTVERSION || _la==RETENTION || _la==STORAGE || _la==TABLESPACE );
			State = 4150;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LobPropertiesListElementClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETENTION() { return GetToken(OracleAntlrParser.RETENTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAX() { return GetToken(OracleAntlrParser.MAX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MIN() { return GetToken(OracleAntlrParser.MIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTO() { return GetToken(OracleAntlrParser.AUTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(OracleAntlrParser.NONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENCRYPT() { return GetToken(OracleAntlrParser.ENCRYPT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharacterStringLiteralContext characterStringLiteral() {
			return GetRuleContext<CharacterStringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIED() { return GetToken(OracleAntlrParser.IDENTIFIED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SALT() { return GetToken(OracleAntlrParser.SALT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NO() { return GetToken(OracleAntlrParser.NO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CACHE() { return GetToken(OracleAntlrParser.CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READS() { return GetToken(OracleAntlrParser.READS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause() {
			return GetRuleContext<LoggingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPRESS() { return GetToken(OracleAntlrParser.COMPRESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HIGH() { return GetToken(OracleAntlrParser.HIGH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEDIUM() { return GetToken(OracleAntlrParser.MEDIUM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORAGE() { return GetToken(OracleAntlrParser.STORAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISABLE() { return GetToken(OracleAntlrParser.DISABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHUNK() { return GetToken(OracleAntlrParser.CHUNK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTVERSION() { return GetToken(OracleAntlrParser.PCTVERSION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FREEPOOLS() { return GetToken(OracleAntlrParser.FREEPOOLS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCACHE() { return GetToken(OracleAntlrParser.NOCACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEDUPLICATE() { return GetToken(OracleAntlrParser.DEDUPLICATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP_DUPLICATES() { return GetToken(OracleAntlrParser.KEEP_DUPLICATES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECRYPT() { return GetToken(OracleAntlrParser.DECRYPT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCOMPRESS() { return GetToken(OracleAntlrParser.NOCOMPRESS, 0); }
		public LobPropertiesListElementClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lobPropertiesListElementClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLobPropertiesListElementClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLobPropertiesListElementClause(this);
		}
	}

	[RuleVersion(0)]
	public LobPropertiesListElementClauseContext lobPropertiesListElementClause() {
		LobPropertiesListElementClauseContext _localctx = new LobPropertiesListElementClauseContext(Context, State);
		EnterRule(_localctx, 690, RULE_lobPropertiesListElementClause);
		int _la;
		try {
			State = 4207;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,370,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4152;
				Match(RETENTION);
				State = 4153;
				Match(MAX);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4154;
				Match(RETENTION);
				State = 4155;
				Match(MIN);
				State = 4156;
				literal();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4157;
				Match(RETENTION);
				State = 4158;
				Match(AUTO);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4159;
				Match(RETENTION);
				State = 4160;
				Match(NONE);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4161;
				Match(ENCRYPT);
				State = 4162;
				Match(USING);
				State = 4163;
				characterStringLiteral();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4164;
				Match(ENCRYPT);
				State = 4165;
				Match(IDENTIFIED);
				State = 4166;
				Match(BY);
				State = 4167;
				simpleIdentifier();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 4168;
				Match(ENCRYPT);
				State = 4169;
				Match(SALT);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 4170;
				Match(ENCRYPT);
				State = 4171;
				Match(NO);
				State = 4172;
				Match(SALT);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 4173;
				Match(CACHE);
				State = 4174;
				Match(READS);
				State = 4176;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FILESYSTEM_LIKE_LOGGING || _la==LOGGING || _la==NOLOGGING) {
					{
					State = 4175;
					loggingClause();
					}
				}

				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 4178;
				Match(COMPRESS);
				State = 4179;
				Match(HIGH);
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 4180;
				Match(COMPRESS);
				State = 4181;
				Match(MEDIUM);
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 4182;
				Match(ENABLE);
				State = 4183;
				Match(STORAGE);
				State = 4184;
				Match(IN);
				State = 4185;
				Match(ROW);
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 4186;
				Match(DISABLE);
				State = 4187;
				Match(STORAGE);
				State = 4188;
				Match(IN);
				State = 4189;
				Match(ROW);
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 4190;
				Match(CACHE);
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 4191;
				Match(CHUNK);
				State = 4192;
				literal();
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 4193;
				Match(PCTVERSION);
				State = 4194;
				literal();
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 4195;
				Match(RETENTION);
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 4196;
				Match(FREEPOOLS);
				State = 4197;
				literal();
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 4198;
				Match(NOCACHE);
				State = 4200;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FILESYSTEM_LIKE_LOGGING || _la==LOGGING || _la==NOLOGGING) {
					{
					State = 4199;
					loggingClause();
					}
				}

				}
				break;
			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 4202;
				Match(DEDUPLICATE);
				}
				break;
			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 4203;
				Match(KEEP_DUPLICATES);
				}
				break;
			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 4204;
				Match(DECRYPT);
				}
				break;
			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 4205;
				Match(COMPRESS);
				}
				break;
			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 4206;
				Match(NOCOMPRESS);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LobStoreAsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOB() { return GetToken(OracleAntlrParser.LOB, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext[] simpleIdentifier() {
			return GetRuleContexts<SimpleIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier(int i) {
			return GetRuleContext<SimpleIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public LobStoreAsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lobStoreAsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLobStoreAsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLobStoreAsClause(this);
		}
	}

	[RuleVersion(0)]
	public LobStoreAsClauseContext lobStoreAsClause() {
		LobStoreAsClauseContext _localctx = new LobStoreAsClauseContext(Context, State);
		EnterRule(_localctx, 692, RULE_lobStoreAsClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4209;
			Match(LOB);
			State = 4210;
			Match(LPAREN);
			State = 4211;
			simpleIdentifier();
			State = 4216;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4212;
				Match(COMMA);
				State = 4213;
				simpleIdentifier();
				}
				}
				State = 4218;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4219;
			Match(RPAREN);
			State = 4220;
			Match(STORE);
			State = 4221;
			Match(AS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RangeValuesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUES() { return GetToken(OracleAntlrParser.VALUES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS() { return GetToken(OracleAntlrParser.LESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THAN() { return GetToken(OracleAntlrParser.THAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ValuesLessThanListClauseContext valuesLessThanListClause() {
			return GetRuleContext<ValuesLessThanListClauseContext>(0);
		}
		public RangeValuesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rangeValuesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRangeValuesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRangeValuesClause(this);
		}
	}

	[RuleVersion(0)]
	public RangeValuesClauseContext rangeValuesClause() {
		RangeValuesClauseContext _localctx = new RangeValuesClauseContext(Context, State);
		EnterRule(_localctx, 694, RULE_rangeValuesClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4223;
			Match(VALUES);
			State = 4224;
			Match(LESS);
			State = 4225;
			Match(THAN);
			State = 4226;
			valuesLessThanListClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ValuesLessThanListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ValuesLessThanListItemContext[] valuesLessThanListItem() {
			return GetRuleContexts<ValuesLessThanListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ValuesLessThanListItemContext valuesLessThanListItem(int i) {
			return GetRuleContext<ValuesLessThanListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ValuesLessThanListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_valuesLessThanListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterValuesLessThanListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitValuesLessThanListClause(this);
		}
	}

	[RuleVersion(0)]
	public ValuesLessThanListClauseContext valuesLessThanListClause() {
		ValuesLessThanListClauseContext _localctx = new ValuesLessThanListClauseContext(Context, State);
		EnterRule(_localctx, 696, RULE_valuesLessThanListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4228;
			Match(LPAREN);
			State = 4229;
			valuesLessThanListItem();
			State = 4234;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4230;
				Match(COMMA);
				State = 4231;
				valuesLessThanListItem();
				}
				}
				State = 4236;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4237;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ValuesLessThanListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXVALUE() { return GetToken(OracleAntlrParser.MAXVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ValuesLessThanListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_valuesLessThanListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterValuesLessThanListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitValuesLessThanListItem(this);
		}
	}

	[RuleVersion(0)]
	public ValuesLessThanListItemContext valuesLessThanListItem() {
		ValuesLessThanListItemContext _localctx = new ValuesLessThanListItemContext(Context, State);
		EnterRule(_localctx, 698, RULE_valuesLessThanListItem);
		try {
			State = 4241;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MAXVALUE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4239;
				Match(MAXVALUE);
				}
				break;
			case DATE:
			case FALSE:
			case INTERVAL:
			case TIMESTAMP:
			case TRUE:
			case INTEGER_LITERAL:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case QUOTE_CHARACTER_STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4240;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionByRangeColumnListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(OracleAntlrParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public PartitionByRangeColumnListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionByRangeColumnList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPartitionByRangeColumnList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPartitionByRangeColumnList(this);
		}
	}

	[RuleVersion(0)]
	public PartitionByRangeColumnListContext partitionByRangeColumnList() {
		PartitionByRangeColumnListContext _localctx = new PartitionByRangeColumnListContext(Context, State);
		EnterRule(_localctx, 700, RULE_partitionByRangeColumnList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4243;
			Match(RANGE);
			State = 4244;
			columnListInParenElementClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PhysicalPropertiesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalPropertiesOrganizationClauseContext physicalPropertiesOrganizationClause() {
			return GetRuleContext<PhysicalPropertiesOrganizationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeferredSegmentCreationClauseContext deferredSegmentCreationClause() {
			return GetRuleContext<DeferredSegmentCreationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseElementContext[] segmentAttributesClauseElement() {
			return GetRuleContexts<SegmentAttributesClauseElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseElementContext segmentAttributesClauseElement(int i) {
			return GetRuleContext<SegmentAttributesClauseElementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableCompressionClauseContext[] tableCompressionClause() {
			return GetRuleContexts<TableCompressionClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableCompressionClauseContext tableCompressionClause(int i) {
			return GetRuleContext<TableCompressionClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalPropertiesClusterClauseContext physicalPropertiesClusterClause() {
			return GetRuleContext<PhysicalPropertiesClusterClauseContext>(0);
		}
		public PhysicalPropertiesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_physicalPropertiesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPhysicalPropertiesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPhysicalPropertiesClause(this);
		}
	}

	[RuleVersion(0)]
	public PhysicalPropertiesClauseContext physicalPropertiesClause() {
		PhysicalPropertiesClauseContext _localctx = new PhysicalPropertiesClauseContext(Context, State);
		EnterRule(_localctx, 702, RULE_physicalPropertiesClause);
		int _la;
		try {
			int _alt;
			State = 4260;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,378,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4247;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SEGMENT) {
					{
					State = 4246;
					deferredSegmentCreationClause();
					}
				}

				State = 4249;
				physicalPropertiesOrganizationClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4251;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SEGMENT) {
					{
					State = 4250;
					deferredSegmentCreationClause();
					}
				}

				State = 4255;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						State = 4255;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case FILESYSTEM_LIKE_LOGGING:
						case INITRANS:
						case LOGGING:
						case MAXTRANS:
						case NOLOGGING:
						case PCTFREE:
						case PCTUSED:
						case STORAGE:
						case TABLESPACE:
							{
							State = 4253;
							segmentAttributesClauseElement();
							}
							break;
						case COLUMN:
						case COMPRESS:
						case NOCOMPRESS:
						case ROW:
							{
							State = 4254;
							tableCompressionClause();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 4257;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,377,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4259;
				physicalPropertiesClusterClause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PhysicalPropertiesClusterClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLUSTER() { return GetToken(OracleAntlrParser.CLUSTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public PhysicalPropertiesClusterClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_physicalPropertiesClusterClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPhysicalPropertiesClusterClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPhysicalPropertiesClusterClause(this);
		}
	}

	[RuleVersion(0)]
	public PhysicalPropertiesClusterClauseContext physicalPropertiesClusterClause() {
		PhysicalPropertiesClusterClauseContext _localctx = new PhysicalPropertiesClusterClauseContext(Context, State);
		EnterRule(_localctx, 704, RULE_physicalPropertiesClusterClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4262;
			Match(CLUSTER);
			State = 4263;
			simpleIdentifierWithoutParentheses();
			State = 4264;
			columnListInParenElementClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PhysicalPropertiesOrganizationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORGANIZATION() { return GetToken(OracleAntlrParser.ORGANIZATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HEAP() { return GetToken(OracleAntlrParser.HEAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseElementContext[] segmentAttributesClauseElement() {
			return GetRuleContexts<SegmentAttributesClauseElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseElementContext segmentAttributesClauseElement(int i) {
			return GetRuleContext<SegmentAttributesClauseElementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public HeapOrganizedTableClauseElementContext[] heapOrganizedTableClauseElement() {
			return GetRuleContexts<HeapOrganizedTableClauseElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public HeapOrganizedTableClauseElementContext heapOrganizedTableClauseElement(int i) {
			return GetRuleContext<HeapOrganizedTableClauseElementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOrganizedTableClauseElementContext[] indexOrganizedTableClauseElement() {
			return GetRuleContexts<IndexOrganizedTableClauseElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOrganizedTableClauseElementContext indexOrganizedTableClauseElement(int i) {
			return GetRuleContext<IndexOrganizedTableClauseElementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOrganizedOverflowClauseContext indexOrganizedOverflowClause() {
			return GetRuleContext<IndexOrganizedOverflowClauseContext>(0);
		}
		public PhysicalPropertiesOrganizationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_physicalPropertiesOrganizationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPhysicalPropertiesOrganizationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPhysicalPropertiesOrganizationClause(this);
		}
	}

	[RuleVersion(0)]
	public PhysicalPropertiesOrganizationClauseContext physicalPropertiesOrganizationClause() {
		PhysicalPropertiesOrganizationClauseContext _localctx = new PhysicalPropertiesOrganizationClauseContext(Context, State);
		EnterRule(_localctx, 706, RULE_physicalPropertiesOrganizationClause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4266;
			Match(ORGANIZATION);
			State = 4284;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case HEAP:
				{
				State = 4267;
				Match(HEAP);
				State = 4270;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						State = 4270;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case FILESYSTEM_LIKE_LOGGING:
						case INITRANS:
						case LOGGING:
						case MAXTRANS:
						case NOLOGGING:
						case PCTFREE:
						case PCTUSED:
						case STORAGE:
						case TABLESPACE:
							{
							State = 4268;
							segmentAttributesClauseElement();
							}
							break;
						case COLUMN:
						case COMPRESS:
						case NOCOMPRESS:
						case ROW:
							{
							State = 4269;
							heapOrganizedTableClauseElement();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 4272;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,380,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case INDEX:
				{
				State = 4274;
				Match(INDEX);
				State = 4277;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						State = 4277;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case FILESYSTEM_LIKE_LOGGING:
						case INITRANS:
						case LOGGING:
						case MAXTRANS:
						case NOLOGGING:
						case PCTFREE:
						case PCTUSED:
						case STORAGE:
						case TABLESPACE:
							{
							State = 4275;
							segmentAttributesClauseElement();
							}
							break;
						case COMPRESS:
						case MAPPING:
						case NOCOMPRESS:
						case NOMAPPING:
						case PCTTHRESHOLD:
							{
							State = 4276;
							indexOrganizedTableClauseElement();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 4279;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,382,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				State = 4282;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INCLUDING || _la==OVERFLOW) {
					{
					State = 4281;
					indexOrganizedOverflowClause();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeferredSegmentCreationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEGMENT() { return GetToken(OracleAntlrParser.SEGMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATION() { return GetToken(OracleAntlrParser.CREATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMEDIATE() { return GetToken(OracleAntlrParser.IMMEDIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFERRED() { return GetToken(OracleAntlrParser.DEFERRED, 0); }
		public DeferredSegmentCreationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deferredSegmentCreationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDeferredSegmentCreationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDeferredSegmentCreationClause(this);
		}
	}

	[RuleVersion(0)]
	public DeferredSegmentCreationClauseContext deferredSegmentCreationClause() {
		DeferredSegmentCreationClauseContext _localctx = new DeferredSegmentCreationClauseContext(Context, State);
		EnterRule(_localctx, 708, RULE_deferredSegmentCreationClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4286;
			Match(SEGMENT);
			State = 4287;
			Match(CREATION);
			State = 4288;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFERRED || _la==IMMEDIATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HeapOrganizedTableClauseElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TableCompressionClauseContext tableCompressionClause() {
			return GetRuleContext<TableCompressionClauseContext>(0);
		}
		public HeapOrganizedTableClauseElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_heapOrganizedTableClauseElement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterHeapOrganizedTableClauseElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitHeapOrganizedTableClauseElement(this);
		}
	}

	[RuleVersion(0)]
	public HeapOrganizedTableClauseElementContext heapOrganizedTableClauseElement() {
		HeapOrganizedTableClauseElementContext _localctx = new HeapOrganizedTableClauseElementContext(Context, State);
		EnterRule(_localctx, 710, RULE_heapOrganizedTableClauseElement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4290;
			tableCompressionClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOrganizedTableClauseElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PCTThresholdClauseContext pCTThresholdClause() {
			return GetRuleContext<PCTThresholdClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionClauseContext indexCompressionClause() {
			return GetRuleContext<IndexCompressionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MappingTableClauseContext mappingTableClause() {
			return GetRuleContext<MappingTableClauseContext>(0);
		}
		public IndexOrganizedTableClauseElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOrganizedTableClauseElement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexOrganizedTableClauseElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexOrganizedTableClauseElement(this);
		}
	}

	[RuleVersion(0)]
	public IndexOrganizedTableClauseElementContext indexOrganizedTableClauseElement() {
		IndexOrganizedTableClauseElementContext _localctx = new IndexOrganizedTableClauseElementContext(Context, State);
		EnterRule(_localctx, 712, RULE_indexOrganizedTableClauseElement);
		try {
			State = 4295;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PCTTHRESHOLD:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4292;
				pCTThresholdClause();
				}
				break;
			case COMPRESS:
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4293;
				indexCompressionClause();
				}
				break;
			case MAPPING:
			case NOMAPPING:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4294;
				mappingTableClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOrganizedOverflowClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public OverflowClauseContext overflowClause() {
			return GetRuleContext<OverflowClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IncludingOverflowClauseContext includingOverflowClause() {
			return GetRuleContext<IncludingOverflowClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseContext segmentAttributesClause() {
			return GetRuleContext<SegmentAttributesClauseContext>(0);
		}
		public IndexOrganizedOverflowClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOrganizedOverflowClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexOrganizedOverflowClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexOrganizedOverflowClause(this);
		}
	}

	[RuleVersion(0)]
	public IndexOrganizedOverflowClauseContext indexOrganizedOverflowClause() {
		IndexOrganizedOverflowClauseContext _localctx = new IndexOrganizedOverflowClauseContext(Context, State);
		EnterRule(_localctx, 714, RULE_indexOrganizedOverflowClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4298;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INCLUDING) {
				{
				State = 4297;
				includingOverflowClause();
				}
			}

			State = 4300;
			overflowClause();
			State = 4302;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 276)) & ~0x3f) == 0 && ((1L << (_la - 276)) & ((1L << (LOGGING - 276)) | (1L << (MAXTRANS - 276)) | (1L << (NOLOGGING - 276)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
				{
				State = 4301;
				segmentAttributesClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverflowClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVERFLOW() { return GetToken(OracleAntlrParser.OVERFLOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseContext segmentAttributesClause() {
			return GetRuleContext<SegmentAttributesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsStoreInClauseContext partitionsStoreInClause() {
			return GetRuleContext<PartitionsStoreInClauseContext>(0);
		}
		public OverflowClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overflowClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOverflowClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOverflowClause(this);
		}
	}

	[RuleVersion(0)]
	public OverflowClauseContext overflowClause() {
		OverflowClauseContext _localctx = new OverflowClauseContext(Context, State);
		EnterRule(_localctx, 716, RULE_overflowClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4304;
			Match(OVERFLOW);
			State = 4306;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,388,Context) ) {
			case 1:
				{
				State = 4305;
				segmentAttributesClause();
				}
				break;
			}
			State = 4309;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,389,Context) ) {
			case 1:
				{
				State = 4308;
				partitionsStoreInClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IncludingOverflowClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDING() { return GetToken(OracleAntlrParser.INCLUDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public IncludingOverflowClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_includingOverflowClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIncludingOverflowClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIncludingOverflowClause(this);
		}
	}

	[RuleVersion(0)]
	public IncludingOverflowClauseContext includingOverflowClause() {
		IncludingOverflowClauseContext _localctx = new IncludingOverflowClauseContext(Context, State);
		EnterRule(_localctx, 718, RULE_includingOverflowClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4311;
			Match(INCLUDING);
			State = 4312;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PCTThresholdClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTTHRESHOLD() { return GetToken(OracleAntlrParser.PCTTHRESHOLD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public PCTThresholdClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pCTThresholdClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPCTThresholdClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPCTThresholdClause(this);
		}
	}

	[RuleVersion(0)]
	public PCTThresholdClauseContext pCTThresholdClause() {
		PCTThresholdClauseContext _localctx = new PCTThresholdClauseContext(Context, State);
		EnterRule(_localctx, 720, RULE_pCTThresholdClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4314;
			Match(PCTTHRESHOLD);
			State = 4315;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MappingTableClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAPPING() { return GetToken(OracleAntlrParser.MAPPING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMAPPING() { return GetToken(OracleAntlrParser.NOMAPPING, 0); }
		public MappingTableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mappingTableClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMappingTableClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMappingTableClause(this);
		}
	}

	[RuleVersion(0)]
	public MappingTableClauseContext mappingTableClause() {
		MappingTableClauseContext _localctx = new MappingTableClauseContext(Context, State);
		EnterRule(_localctx, 722, RULE_mappingTableClause);
		try {
			State = 4320;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MAPPING:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4317;
				Match(MAPPING);
				State = 4318;
				Match(TABLE);
				}
				break;
			case NOMAPPING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4319;
				Match(NOMAPPING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableCompressionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPRESS() { return GetToken(OracleAntlrParser.COMPRESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CompressionOperationsContext compressionOperations() {
			return GetRuleContext<CompressionOperationsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BASIC() { return GetToken(OracleAntlrParser.BASIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADVANCED() { return GetToken(OracleAntlrParser.ADVANCED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMN() { return GetToken(OracleAntlrParser.COLUMN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEVEL() { return GetToken(OracleAntlrParser.LEVEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCKING() { return GetToken(OracleAntlrParser.LOCKING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUERY() { return GetToken(OracleAntlrParser.QUERY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARCHIVE() { return GetToken(OracleAntlrParser.ARCHIVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NO() { return GetToken(OracleAntlrParser.NO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOW() { return GetToken(OracleAntlrParser.LOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HIGH() { return GetToken(OracleAntlrParser.HIGH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCOMPRESS() { return GetToken(OracleAntlrParser.NOCOMPRESS, 0); }
		public TableCompressionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableCompressionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTableCompressionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTableCompressionClause(this);
		}
	}

	[RuleVersion(0)]
	public TableCompressionClauseContext tableCompressionClause() {
		TableCompressionClauseContext _localctx = new TableCompressionClauseContext(Context, State);
		EnterRule(_localctx, 724, RULE_tableCompressionClause);
		int _la;
		try {
			State = 4354;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPRESS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4322;
				Match(COMPRESS);
				State = 4324;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 4323;
					compressionOperations();
					}
				}

				State = 4327;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATE || _la==FALSE || _la==INTERVAL || _la==TIMESTAMP || _la==TRUE || ((((_la - 579)) & ~0x3f) == 0 && ((1L << (_la - 579)) & ((1L << (INTEGER_LITERAL - 579)) | (1L << (FLOATING_POINT_LITERAL - 579)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 579)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 579)) | (1L << (BINARY_STRING_LITERAL - 579)) | (1L << (CHARACTER_STRING_LITERAL - 579)) | (1L << (MONEY_LITERAL - 579)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 579)))) != 0)) {
					{
					State = 4326;
					literal();
					}
				}

				}
				break;
			case ROW:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4329;
				Match(ROW);
				State = 4330;
				Match(STORE);
				State = 4331;
				Match(COMPRESS);
				State = 4333;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ADVANCED || _la==BASIC) {
					{
					State = 4332;
					_la = TokenStream.LA(1);
					if ( !(_la==ADVANCED || _la==BASIC) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			case COLUMN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4335;
				Match(COLUMN);
				State = 4336;
				Match(STORE);
				State = 4337;
				Match(COMPRESS);
				State = 4343;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 4338;
					Match(FOR);
					State = 4339;
					_la = TokenStream.LA(1);
					if ( !(_la==ARCHIVE || _la==QUERY) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 4341;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==HIGH || _la==LOW) {
						{
						State = 4340;
						_la = TokenStream.LA(1);
						if ( !(_la==HIGH || _la==LOW) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
					}

					}
				}

				State = 4351;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,397,Context) ) {
				case 1:
					{
					State = 4346;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NO) {
						{
						State = 4345;
						Match(NO);
						}
					}

					State = 4348;
					Match(ROW);
					State = 4349;
					Match(LEVEL);
					State = 4350;
					Match(LOCKING);
					}
					break;
				}
				}
				break;
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4353;
				Match(NOCOMPRESS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexCompressionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPRESS() { return GetToken(OracleAntlrParser.COMPRESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADVANCED() { return GetToken(OracleAntlrParser.ADVANCED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOW() { return GetToken(OracleAntlrParser.LOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HIGH() { return GetToken(OracleAntlrParser.HIGH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCOMPRESS() { return GetToken(OracleAntlrParser.NOCOMPRESS, 0); }
		public IndexCompressionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexCompressionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexCompressionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexCompressionClause(this);
		}
	}

	[RuleVersion(0)]
	public IndexCompressionClauseContext indexCompressionClause() {
		IndexCompressionClauseContext _localctx = new IndexCompressionClauseContext(Context, State);
		EnterRule(_localctx, 726, RULE_indexCompressionClause);
		int _la;
		try {
			State = 4365;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPRESS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4356;
				Match(COMPRESS);
				State = 4362;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ADVANCED:
					{
					State = 4357;
					Match(ADVANCED);
					State = 4358;
					_la = TokenStream.LA(1);
					if ( !(_la==HIGH || _la==LOW) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				case Eof:
				case AS:
				case BUILD:
				case CACHE:
				case CHUNK:
				case COLUMN:
				case COMPRESS:
				case COMPUTE:
				case DATE:
				case DECRYPT:
				case DEDUPLICATE:
				case DEFERRED:
				case DISABLE:
				case ENABLE:
				case ENCRYPT:
				case EVALUATE:
				case FALSE:
				case FILESYSTEM_LIKE_LOGGING:
				case FREEPOOLS:
				case GLOBAL:
				case IMMEDIATE:
				case INCLUDING:
				case INDEXING:
				case INITRANS:
				case INTERVAL:
				case INVISIBLE:
				case KEEP_DUPLICATES:
				case LOB:
				case LOCAL:
				case LOGGING:
				case MAPPING:
				case MAXTRANS:
				case MEMOPTIMIZE:
				case MONITORING:
				case NESTED:
				case NEVER:
				case NOCACHE:
				case NOCOMPRESS:
				case NOLOGGING:
				case NOMAPPING:
				case NOMONITORING:
				case NOPARALLEL:
				case NOROWDEPENDENCIES:
				case NOSORT:
				case ONLINE:
				case OVERFLOW:
				case PARALLEL:
				case PARENT:
				case PARTITION:
				case PCTFREE:
				case PCTTHRESHOLD:
				case PCTUSED:
				case PCTVERSION:
				case REFRESH:
				case RETENTION:
				case REVERSE:
				case ROWDEPENDENCIES:
				case SORT:
				case STORAGE:
				case STORE:
				case TABLESPACE:
				case TIMESTAMP:
				case TRUE:
				case UNUSABLE:
				case USABLE:
				case USING:
				case VARRAY:
				case VISIBLE:
				case XMLTYPE:
				case INTEGER_LITERAL:
				case LPAREN:
				case RPAREN:
				case COMMA:
				case SEMI:
				case FSLASH:
				case FLOATING_POINT_LITERAL:
				case FLOATING_POINT_BINARY_LITERAL:
				case UNICODE_CHARACTER_STRING_LITERAL:
				case BINARY_STRING_LITERAL:
				case CHARACTER_STRING_LITERAL:
				case MONEY_LITERAL:
				case QUOTE_CHARACTER_STRING_LITERAL:
					{
					State = 4360;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATE || _la==FALSE || _la==INTERVAL || _la==TIMESTAMP || _la==TRUE || ((((_la - 579)) & ~0x3f) == 0 && ((1L << (_la - 579)) & ((1L << (INTEGER_LITERAL - 579)) | (1L << (FLOATING_POINT_LITERAL - 579)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 579)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 579)) | (1L << (BINARY_STRING_LITERAL - 579)) | (1L << (CHARACTER_STRING_LITERAL - 579)) | (1L << (MONEY_LITERAL - 579)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 579)))) != 0)) {
						{
						State = 4359;
						literal();
						}
					}

					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4364;
				Match(NOCOMPRESS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompressionOperationsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPERATIONS() { return GetToken(OracleAntlrParser.OPERATIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECT_LOAD() { return GetToken(OracleAntlrParser.DIRECT_LOAD, 0); }
		public CompressionOperationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compressionOperations; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCompressionOperations(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCompressionOperations(this);
		}
	}

	[RuleVersion(0)]
	public CompressionOperationsContext compressionOperations() {
		CompressionOperationsContext _localctx = new CompressionOperationsContext(Context, State);
		EnterRule(_localctx, 728, RULE_compressionOperations);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4367;
			Match(FOR);
			State = 4368;
			_la = TokenStream.LA(1);
			if ( !(_la==ALL || _la==DIRECT_LOAD) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4369;
			Match(OPERATIONS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SegmentAttributesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseElementContext[] segmentAttributesClauseElement() {
			return GetRuleContexts<SegmentAttributesClauseElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseElementContext segmentAttributesClauseElement(int i) {
			return GetRuleContext<SegmentAttributesClauseElementContext>(i);
		}
		public SegmentAttributesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_segmentAttributesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSegmentAttributesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSegmentAttributesClause(this);
		}
	}

	[RuleVersion(0)]
	public SegmentAttributesClauseContext segmentAttributesClause() {
		SegmentAttributesClauseContext _localctx = new SegmentAttributesClauseContext(Context, State);
		EnterRule(_localctx, 730, RULE_segmentAttributesClause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4372;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 4371;
					segmentAttributesClauseElement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4374;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,402,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SegmentAttributesClauseElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause() {
			return GetRuleContext<TablespaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause() {
			return GetRuleContext<LoggingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute() {
			return GetRuleContext<PhysicalAttributeContext>(0);
		}
		public SegmentAttributesClauseElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_segmentAttributesClauseElement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSegmentAttributesClauseElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSegmentAttributesClauseElement(this);
		}
	}

	[RuleVersion(0)]
	public SegmentAttributesClauseElementContext segmentAttributesClauseElement() {
		SegmentAttributesClauseElementContext _localctx = new SegmentAttributesClauseElementContext(Context, State);
		EnterRule(_localctx, 732, RULE_segmentAttributesClauseElement);
		try {
			State = 4379;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TABLESPACE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4376;
				tablespaceClause();
				}
				break;
			case FILESYSTEM_LIKE_LOGGING:
			case LOGGING:
			case NOLOGGING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4377;
				loggingClause();
				}
				break;
			case INITRANS:
			case MAXTRANS:
			case PCTFREE:
			case PCTUSED:
			case STORAGE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4378;
				physicalAttribute();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnCommitClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMIT() { return GetToken(OracleAntlrParser.COMMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWS() { return GetToken(OracleAntlrParser.ROWS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(OracleAntlrParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRESERVE() { return GetToken(OracleAntlrParser.PRESERVE, 0); }
		public OnCommitClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onCommitClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOnCommitClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOnCommitClause(this);
		}
	}

	[RuleVersion(0)]
	public OnCommitClauseContext onCommitClause() {
		OnCommitClauseContext _localctx = new OnCommitClauseContext(Context, State);
		EnterRule(_localctx, 734, RULE_onCommitClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4381;
			Match(ON);
			State = 4382;
			Match(COMMIT);
			State = 4383;
			_la = TokenStream.LA(1);
			if ( !(_la==DELETE || _la==PRESERVE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4384;
			Match(ROWS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelationPropertiesListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RelationPropertiesClauseContext[] relationPropertiesClause() {
			return GetRuleContexts<RelationPropertiesClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelationPropertiesClauseContext relationPropertiesClause(int i) {
			return GetRuleContext<RelationPropertiesClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public RelationPropertiesListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relationPropertiesListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRelationPropertiesListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRelationPropertiesListClause(this);
		}
	}

	[RuleVersion(0)]
	public RelationPropertiesListClauseContext relationPropertiesListClause() {
		RelationPropertiesListClauseContext _localctx = new RelationPropertiesListClauseContext(Context, State);
		EnterRule(_localctx, 736, RULE_relationPropertiesListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4386;
			Match(LPAREN);
			State = 4387;
			relationPropertiesClause();
			State = 4392;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4388;
				Match(COMMA);
				State = 4389;
				relationPropertiesClause();
				}
				}
				State = 4394;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4395;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelationPropertiesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TableRefConstraintClauseContext tableRefConstraintClause() {
			return GetRuleContext<TableRefConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableConstraintClauseContext tableConstraintClause() {
			return GetRuleContext<TableConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SupplementalLoggingPropsClauseContext supplementalLoggingPropsClause() {
			return GetRuleContext<SupplementalLoggingPropsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnDeclarationClauseContext columnDeclarationClause() {
			return GetRuleContext<ColumnDeclarationClauseContext>(0);
		}
		public RelationPropertiesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relationPropertiesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRelationPropertiesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRelationPropertiesClause(this);
		}
	}

	[RuleVersion(0)]
	public RelationPropertiesClauseContext relationPropertiesClause() {
		RelationPropertiesClauseContext _localctx = new RelationPropertiesClauseContext(Context, State);
		EnterRule(_localctx, 738, RULE_relationPropertiesClause);
		try {
			State = 4401;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,405,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4397;
				tableRefConstraintClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4398;
				tableConstraintClause();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4399;
				supplementalLoggingPropsClause();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4400;
				columnDeclarationClause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SupplementalLoggingPropsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUPPLEMENTAL() { return GetToken(OracleAntlrParser.SUPPLEMENTAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOG() { return GetToken(OracleAntlrParser.LOG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SupplementalLogGrpClauseContext supplementalLogGrpClause() {
			return GetRuleContext<SupplementalLogGrpClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SupplementalIdKeyClauseContext supplementalIdKeyClause() {
			return GetRuleContext<SupplementalIdKeyClauseContext>(0);
		}
		public SupplementalLoggingPropsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_supplementalLoggingPropsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSupplementalLoggingPropsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSupplementalLoggingPropsClause(this);
		}
	}

	[RuleVersion(0)]
	public SupplementalLoggingPropsClauseContext supplementalLoggingPropsClause() {
		SupplementalLoggingPropsClauseContext _localctx = new SupplementalLoggingPropsClauseContext(Context, State);
		EnterRule(_localctx, 740, RULE_supplementalLoggingPropsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4403;
			Match(SUPPLEMENTAL);
			State = 4404;
			Match(LOG);
			State = 4407;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case GROUP:
				{
				State = 4405;
				supplementalLogGrpClause();
				}
				break;
			case DATA:
				{
				State = 4406;
				supplementalIdKeyClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SupplementalLogGrpClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUP() { return GetToken(OracleAntlrParser.GROUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALWAYS() { return GetToken(OracleAntlrParser.ALWAYS, 0); }
		public SupplementalLogGrpClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_supplementalLogGrpClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSupplementalLogGrpClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSupplementalLogGrpClause(this);
		}
	}

	[RuleVersion(0)]
	public SupplementalLogGrpClauseContext supplementalLogGrpClause() {
		SupplementalLogGrpClauseContext _localctx = new SupplementalLogGrpClauseContext(Context, State);
		EnterRule(_localctx, 742, RULE_supplementalLogGrpClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4409;
			Match(GROUP);
			State = 4410;
			simpleIdentifierWithoutParentheses();
			State = 4411;
			columnListInParenElementClause();
			State = 4413;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALWAYS) {
				{
				State = 4412;
				Match(ALWAYS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SupplementalIdKeyClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATA() { return GetToken(OracleAntlrParser.DATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SupplementalIdKeyClauseItemContext[] supplementalIdKeyClauseItem() {
			return GetRuleContexts<SupplementalIdKeyClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SupplementalIdKeyClauseItemContext supplementalIdKeyClauseItem(int i) {
			return GetRuleContext<SupplementalIdKeyClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMNS() { return GetToken(OracleAntlrParser.COLUMNS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public SupplementalIdKeyClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_supplementalIdKeyClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSupplementalIdKeyClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSupplementalIdKeyClause(this);
		}
	}

	[RuleVersion(0)]
	public SupplementalIdKeyClauseContext supplementalIdKeyClause() {
		SupplementalIdKeyClauseContext _localctx = new SupplementalIdKeyClauseContext(Context, State);
		EnterRule(_localctx, 744, RULE_supplementalIdKeyClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4415;
			Match(DATA);
			State = 4416;
			Match(LPAREN);
			State = 4417;
			supplementalIdKeyClauseItem();
			State = 4422;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4418;
				Match(COMMA);
				State = 4419;
				supplementalIdKeyClauseItem();
				}
				}
				State = 4424;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4425;
			Match(RPAREN);
			State = 4426;
			Match(COLUMNS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SupplementalIdKeyClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIMARY() { return GetToken(OracleAntlrParser.PRIMARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(OracleAntlrParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUE() { return GetToken(OracleAntlrParser.UNIQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOREIGN() { return GetToken(OracleAntlrParser.FOREIGN, 0); }
		public SupplementalIdKeyClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_supplementalIdKeyClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSupplementalIdKeyClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSupplementalIdKeyClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public SupplementalIdKeyClauseItemContext supplementalIdKeyClauseItem() {
		SupplementalIdKeyClauseItemContext _localctx = new SupplementalIdKeyClauseItemContext(Context, State);
		EnterRule(_localctx, 746, RULE_supplementalIdKeyClauseItem);
		try {
			State = 4434;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4428;
				Match(ALL);
				}
				break;
			case PRIMARY:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4429;
				Match(PRIMARY);
				State = 4430;
				Match(KEY);
				}
				break;
			case UNIQUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4431;
				Match(UNIQUE);
				}
				break;
			case FOREIGN:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4432;
				Match(FOREIGN);
				State = 4433;
				Match(KEY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnDeclarationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SortNoSortClauseContext sortNoSortClause() {
			return GetRuleContext<SortNoSortClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnDefaultValueClauseContext columnDefaultValueClause() {
			return GetRuleContext<ColumnDefaultValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnIdentityClauseContext columnIdentityClause() {
			return GetRuleContext<ColumnIdentityClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VirtualColumnDefinitionContext virtualColumnDefinition() {
			return GetRuleContext<VirtualColumnDefinitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnRefConstraintClauseContext columnRefConstraintClause() {
			return GetRuleContext<ColumnRefConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext[] columnConstraintClause() {
			return GetRuleContexts<ColumnConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext columnConstraintClause(int i) {
			return GetRuleContext<ColumnConstraintClauseContext>(i);
		}
		public ColumnDeclarationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnDeclarationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterColumnDeclarationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitColumnDeclarationClause(this);
		}
	}

	[RuleVersion(0)]
	public ColumnDeclarationClauseContext columnDeclarationClause() {
		ColumnDeclarationClauseContext _localctx = new ColumnDeclarationClauseContext(Context, State);
		EnterRule(_localctx, 748, RULE_columnDeclarationClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4436;
			simpleIdentifierWithoutParentheses();
			State = 4437;
			typeReference();
			State = 4439;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOSORT || _la==SORT) {
				{
				State = 4438;
				sortNoSortClause();
				}
			}

			State = 4444;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,411,Context) ) {
			case 1:
				{
				State = 4441;
				columnDefaultValueClause();
				}
				break;
			case 2:
				{
				State = 4442;
				columnIdentityClause();
				}
				break;
			case 3:
				{
				State = 4443;
				virtualColumnDefinition();
				}
				break;
			}
			State = 4452;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,413,Context) ) {
			case 1:
				{
				State = 4446;
				columnRefConstraintClause();
				}
				break;
			case 2:
				{
				State = 4448;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 4447;
					columnConstraintClause();
					}
					}
					State = 4450;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==CHECK || _la==CONSTRAINT || _la==FOREIGN || ((((_la - 344)) & ~0x3f) == 0 && ((1L << (_la - 344)) & ((1L << (NOT - 344)) | (1L << (NULL - 344)) | (1L << (PRIMARY - 344)))) != 0) || _la==REFERENCES || _la==UNIQUE || _la==LPAREN );
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnIdentityClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GENERATED() { return GetToken(OracleAntlrParser.GENERATED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTITY() { return GetToken(OracleAntlrParser.IDENTITY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALWAYS() { return GetToken(OracleAntlrParser.ALWAYS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentityOptionContext[] identityOption() {
			return GetRuleContexts<IdentityOptionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentityOptionContext identityOption(int i) {
			return GetRuleContext<IdentityOptionContext>(i);
		}
		public ColumnIdentityClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnIdentityClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterColumnIdentityClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitColumnIdentityClause(this);
		}
	}

	[RuleVersion(0)]
	public ColumnIdentityClauseContext columnIdentityClause() {
		ColumnIdentityClauseContext _localctx = new ColumnIdentityClauseContext(Context, State);
		EnterRule(_localctx, 750, RULE_columnIdentityClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4454;
			Match(GENERATED);
			State = 4462;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALWAYS:
				{
				State = 4455;
				Match(ALWAYS);
				}
				break;
			case BY:
				{
				State = 4456;
				Match(BY);
				State = 4457;
				Match(DEFAULT);
				State = 4460;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ON) {
					{
					State = 4458;
					Match(ON);
					State = 4459;
					Match(NULL);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 4464;
			Match(AS);
			State = 4465;
			Match(IDENTITY);
			State = 4480;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,418,Context) ) {
			case 1:
				{
				State = 4466;
				Match(LPAREN);
				State = 4468;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 4467;
					identityOption();
					}
					}
					State = 4470;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==CACHE || _la==CYCLE || _la==INCREMENT || _la==KEEP || ((((_la - 291)) & ~0x3f) == 0 && ((1L << (_la - 291)) & ((1L << (MAXVALUE - 291)) | (1L << (MINVALUE - 291)) | (1L << (NOCACHE - 291)) | (1L << (NOCYCLE - 291)) | (1L << (NOKEEP - 291)) | (1L << (NOMAXVALUE - 291)) | (1L << (NOMINVALUE - 291)) | (1L << (NOORDER - 291)) | (1L << (NOSCALE - 291)))) != 0) || _la==ORDER || _la==SCALE || _la==START );
				State = 4472;
				Match(RPAREN);
				}
				break;
			case 2:
				{
				State = 4477;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==CACHE || _la==CYCLE || _la==INCREMENT || _la==KEEP || ((((_la - 291)) & ~0x3f) == 0 && ((1L << (_la - 291)) & ((1L << (MAXVALUE - 291)) | (1L << (MINVALUE - 291)) | (1L << (NOCACHE - 291)) | (1L << (NOCYCLE - 291)) | (1L << (NOKEEP - 291)) | (1L << (NOMAXVALUE - 291)) | (1L << (NOMINVALUE - 291)) | (1L << (NOORDER - 291)) | (1L << (NOSCALE - 291)))) != 0) || _la==ORDER || _la==SCALE || _la==START) {
					{
					{
					State = 4474;
					identityOption();
					}
					}
					State = 4479;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnDefaultValueClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public ColumnDefaultValueClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnDefaultValueClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterColumnDefaultValueClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitColumnDefaultValueClause(this);
		}
	}

	[RuleVersion(0)]
	public ColumnDefaultValueClauseContext columnDefaultValueClause() {
		ColumnDefaultValueClauseContext _localctx = new ColumnDefaultValueClauseContext(Context, State);
		EnterRule(_localctx, 752, RULE_columnDefaultValueClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4482;
			Match(DEFAULT);
			State = 4485;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 4483;
				Match(ON);
				State = 4484;
				Match(NULL);
				}
			}

			State = 4487;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VirtualColumnDefinitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ComputedColumnExpressionContext computedColumnExpression() {
			return GetRuleContext<ComputedColumnExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GENERATED() { return GetToken(OracleAntlrParser.GENERATED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALWAYS() { return GetToken(OracleAntlrParser.ALWAYS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VIRTUAL() { return GetToken(OracleAntlrParser.VIRTUAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VisibilityClauseContext visibilityClause() {
			return GetRuleContext<VisibilityClauseContext>(0);
		}
		public VirtualColumnDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_virtualColumnDefinition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterVirtualColumnDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitVirtualColumnDefinition(this);
		}
	}

	[RuleVersion(0)]
	public VirtualColumnDefinitionContext virtualColumnDefinition() {
		VirtualColumnDefinitionContext _localctx = new VirtualColumnDefinitionContext(Context, State);
		EnterRule(_localctx, 754, RULE_virtualColumnDefinition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4491;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GENERATED) {
				{
				State = 4489;
				Match(GENERATED);
				State = 4490;
				Match(ALWAYS);
				}
			}

			State = 4493;
			Match(AS);
			State = 4494;
			Match(LPAREN);
			State = 4495;
			computedColumnExpression();
			State = 4496;
			Match(RPAREN);
			State = 4498;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==VIRTUAL) {
				{
				State = 4497;
				Match(VIRTUAL);
				}
			}

			State = 4501;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INVISIBLE || _la==VISIBLE) {
				{
				State = 4500;
				visibilityClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComputedColumnExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public ComputedColumnExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_computedColumnExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterComputedColumnExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitComputedColumnExpression(this);
		}
	}

	[RuleVersion(0)]
	public ComputedColumnExpressionContext computedColumnExpression() {
		ComputedColumnExpressionContext _localctx = new ComputedColumnExpressionContext(Context, State);
		EnterRule(_localctx, 756, RULE_computedColumnExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4503;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableRefConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TableRefWithRowidClauseContext tableRefWithRowidClause() {
			return GetRuleContext<TableRefWithRowidClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableRefForeignKeyClauseContext tableRefForeignKeyClause() {
			return GetRuleContext<TableRefForeignKeyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableRefScopeForClauseContext tableRefScopeForClause() {
			return GetRuleContext<TableRefScopeForClauseContext>(0);
		}
		public TableRefConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableRefConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTableRefConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTableRefConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public TableRefConstraintClauseContext tableRefConstraintClause() {
		TableRefConstraintClauseContext _localctx = new TableRefConstraintClauseContext(Context, State);
		EnterRule(_localctx, 758, RULE_tableRefConstraintClause);
		try {
			State = 4508;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case REF:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4505;
				tableRefWithRowidClause();
				}
				break;
			case CONSTRAINT:
			case FOREIGN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4506;
				tableRefForeignKeyClause();
				}
				break;
			case SCOPE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4507;
				tableRefScopeForClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableRefWithRowidClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REF() { return GetToken(OracleAntlrParser.REF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWID() { return GetToken(OracleAntlrParser.ROWID, 0); }
		public TableRefWithRowidClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableRefWithRowidClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTableRefWithRowidClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTableRefWithRowidClause(this);
		}
	}

	[RuleVersion(0)]
	public TableRefWithRowidClauseContext tableRefWithRowidClause() {
		TableRefWithRowidClauseContext _localctx = new TableRefWithRowidClauseContext(Context, State);
		EnterRule(_localctx, 760, RULE_tableRefWithRowidClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4510;
			Match(REF);
			State = 4511;
			columnListInParenElementClause();
			State = 4512;
			Match(WITH);
			State = 4513;
			Match(ROWID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableRefScopeForClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCOPE() { return GetToken(OracleAntlrParser.SCOPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public TableRefScopeForClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableRefScopeForClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTableRefScopeForClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTableRefScopeForClause(this);
		}
	}

	[RuleVersion(0)]
	public TableRefScopeForClauseContext tableRefScopeForClause() {
		TableRefScopeForClauseContext _localctx = new TableRefScopeForClauseContext(Context, State);
		EnterRule(_localctx, 762, RULE_tableRefScopeForClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4515;
			Match(SCOPE);
			State = 4516;
			Match(FOR);
			State = 4517;
			columnListInParenElementClause();
			State = 4518;
			Match(IS);
			State = 4519;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnRefConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintForeignKeyRefClauseContext constraintForeignKeyRefClause() {
			return GetRuleContext<ConstraintForeignKeyRefClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintNameClauseContext constraintNameClause() {
			return GetRuleContext<ConstraintNameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnDeleteActionClauseContext onDeleteActionClause() {
			return GetRuleContext<OnDeleteActionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintStateClauseContext constraintStateClause() {
			return GetRuleContext<ConstraintStateClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WithRowidClauseContext withRowidClause() {
			return GetRuleContext<WithRowidClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ScopeIsClauseContext scopeIsClause() {
			return GetRuleContext<ScopeIsClauseContext>(0);
		}
		public ColumnRefConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnRefConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterColumnRefConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitColumnRefConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public ColumnRefConstraintClauseContext columnRefConstraintClause() {
		ColumnRefConstraintClauseContext _localctx = new ColumnRefConstraintClauseContext(Context, State);
		EnterRule(_localctx, 764, RULE_columnRefConstraintClause);
		int _la;
		try {
			State = 4533;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CONSTRAINT:
			case REFERENCES:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4522;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 4521;
					constraintNameClause();
					}
				}

				State = 4524;
				constraintForeignKeyRefClause();
				State = 4526;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ON) {
					{
					State = 4525;
					onDeleteActionClause();
					}
				}

				State = 4529;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 120)) & ~0x3f) == 0 && ((1L << (_la - 120)) & ((1L << (DEFERRABLE - 120)) | (1L << (DISABLE - 120)) | (1L << (ENABLE - 120)) | (1L << (EXCEPTIONS - 120)))) != 0) || _la==INITIALLY || ((((_la - 338)) & ~0x3f) == 0 && ((1L << (_la - 338)) & ((1L << (NORELY - 338)) | (1L << (NOT - 338)) | (1L << (NOVALIDATE - 338)))) != 0) || _la==RELY || _la==USING || _la==VALIDATE) {
					{
					State = 4528;
					constraintStateClause();
					}
				}

				}
				break;
			case WITH:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4531;
				withRowidClause();
				}
				break;
			case SCOPE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4532;
				scopeIsClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithRowidClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWID() { return GetToken(OracleAntlrParser.ROWID, 0); }
		public WithRowidClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withRowidClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterWithRowidClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitWithRowidClause(this);
		}
	}

	[RuleVersion(0)]
	public WithRowidClauseContext withRowidClause() {
		WithRowidClauseContext _localctx = new WithRowidClauseContext(Context, State);
		EnterRule(_localctx, 766, RULE_withRowidClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4535;
			Match(WITH);
			State = 4536;
			Match(ROWID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScopeIsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCOPE() { return GetToken(OracleAntlrParser.SCOPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public ScopeIsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scopeIsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterScopeIsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitScopeIsClause(this);
		}
	}

	[RuleVersion(0)]
	public ScopeIsClauseContext scopeIsClause() {
		ScopeIsClauseContext _localctx = new ScopeIsClauseContext(Context, State);
		EnterRule(_localctx, 768, RULE_scopeIsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4538;
			Match(SCOPE);
			State = 4539;
			Match(IS);
			State = 4540;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForeignKeyClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOREIGN() { return GetToken(OracleAntlrParser.FOREIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(OracleAntlrParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public ForeignKeyClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_foreignKeyClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForeignKeyClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForeignKeyClause(this);
		}
	}

	[RuleVersion(0)]
	public ForeignKeyClauseContext foreignKeyClause() {
		ForeignKeyClauseContext _localctx = new ForeignKeyClauseContext(Context, State);
		EnterRule(_localctx, 770, RULE_foreignKeyClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4542;
			Match(FOREIGN);
			State = 4543;
			Match(KEY);
			State = 4544;
			columnListInParenElementClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableRefForeignKeyClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ForeignKeyClauseContext foreignKeyClause() {
			return GetRuleContext<ForeignKeyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintForeignKeyRefClauseContext constraintForeignKeyRefClause() {
			return GetRuleContext<ConstraintForeignKeyRefClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintNameClauseContext constraintNameClause() {
			return GetRuleContext<ConstraintNameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnDeleteActionClauseContext onDeleteActionClause() {
			return GetRuleContext<OnDeleteActionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintStateClauseContext constraintStateClause() {
			return GetRuleContext<ConstraintStateClauseContext>(0);
		}
		public TableRefForeignKeyClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableRefForeignKeyClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTableRefForeignKeyClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTableRefForeignKeyClause(this);
		}
	}

	[RuleVersion(0)]
	public TableRefForeignKeyClauseContext tableRefForeignKeyClause() {
		TableRefForeignKeyClauseContext _localctx = new TableRefForeignKeyClauseContext(Context, State);
		EnterRule(_localctx, 772, RULE_tableRefForeignKeyClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4547;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONSTRAINT) {
				{
				State = 4546;
				constraintNameClause();
				}
			}

			State = 4549;
			foreignKeyClause();
			State = 4550;
			constraintForeignKeyRefClause();
			State = 4552;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 4551;
				onDeleteActionClause();
				}
			}

			State = 4555;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 120)) & ~0x3f) == 0 && ((1L << (_la - 120)) & ((1L << (DEFERRABLE - 120)) | (1L << (DISABLE - 120)) | (1L << (ENABLE - 120)) | (1L << (EXCEPTIONS - 120)))) != 0) || _la==INITIALLY || ((((_la - 338)) & ~0x3f) == 0 && ((1L << (_la - 338)) & ((1L << (NORELY - 338)) | (1L << (NOT - 338)) | (1L << (NOVALIDATE - 338)))) != 0) || _la==RELY || _la==USING || _la==VALIDATE) {
				{
				State = 4554;
				constraintStateClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewHeaderContext materializedViewHeader() {
			return GetRuleContext<MaterializedViewHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ViewBodyContext viewBody() {
			return GetRuleContext<ViewBodyContext>(0);
		}
		public MaterializedViewStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewStatement(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewStatementContext materializedViewStatement() {
		MaterializedViewStatementContext _localctx = new MaterializedViewStatementContext(Context, State);
		EnterRule(_localctx, 774, RULE_materializedViewStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4557;
			materializedViewHeader();
			State = 4558;
			Match(AS);
			State = 4559;
			viewBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATERIALIZED() { return GetToken(OracleAntlrParser.MATERIALIZED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VIEW() { return GetToken(OracleAntlrParser.VIEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectMaterializedViewClauseContext objectMaterializedViewClause() {
			return GetRuleContext<ObjectMaterializedViewClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ViewAliasOrConstraintListContext viewAliasOrConstraintList() {
			return GetRuleContext<ViewAliasOrConstraintListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultCollationOptionContext defaultCollationOption() {
			return GetRuleContext<DefaultCollationOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewPrebuiltTableClauseContext materializedViewPrebuiltTableClause() {
			return GetRuleContext<MaterializedViewPrebuiltTableClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalPropertiesClauseContext physicalPropertiesClause() {
			return GetRuleContext<PhysicalPropertiesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewPropertiesContext materializedViewProperties() {
			return GetRuleContext<MaterializedViewPropertiesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewUsingIndexClauseContext materializedViewUsingIndexClause() {
			return GetRuleContext<MaterializedViewUsingIndexClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshClauseContext materializedViewRefreshClause() {
			return GetRuleContext<MaterializedViewRefreshClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EvaluationEditionClauseContext evaluationEditionClause() {
			return GetRuleContext<EvaluationEditionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewQueryComputationClauseContext materializedViewQueryComputationClause() {
			return GetRuleContext<MaterializedViewQueryComputationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewQueryRewriteClauseContext materializedViewQueryRewriteClause() {
			return GetRuleContext<MaterializedViewQueryRewriteClauseContext>(0);
		}
		public MaterializedViewHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewHeader(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewHeaderContext materializedViewHeader() {
		MaterializedViewHeaderContext _localctx = new MaterializedViewHeaderContext(Context, State);
		EnterRule(_localctx, 776, RULE_materializedViewHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4561;
			Match(MATERIALIZED);
			State = 4562;
			Match(VIEW);
			State = 4563;
			plainIdentifier();
			State = 4565;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OF) {
				{
				State = 4564;
				objectMaterializedViewClause();
				}
			}

			State = 4568;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 4567;
				viewAliasOrConstraintList();
				}
			}

			State = 4571;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT) {
				{
				State = 4570;
				defaultCollationOption();
				}
			}

			State = 4577;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ON:
				{
				State = 4573;
				materializedViewPrebuiltTableClause();
				}
				break;
			case CLUSTER:
			case COLUMN:
			case COMPRESS:
			case FILESYSTEM_LIKE_LOGGING:
			case INITRANS:
			case LOGGING:
			case MAXTRANS:
			case NOCOMPRESS:
			case NOLOGGING:
			case ORGANIZATION:
			case PCTFREE:
			case PCTUSED:
			case ROW:
			case SEGMENT:
			case STORAGE:
			case TABLESPACE:
				{
				State = 4574;
				physicalPropertiesClause();
				State = 4575;
				materializedViewProperties();
				}
				break;
			case AS:
			case DISABLE:
			case ENABLE:
			case EVALUATE:
			case NEVER:
			case REFRESH:
			case USING:
				break;
			default:
				break;
			}
			State = 4580;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 4579;
				materializedViewUsingIndexClause();
				}
			}

			State = 4583;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NEVER || _la==REFRESH) {
				{
				State = 4582;
				materializedViewRefreshClause();
				}
			}

			State = 4586;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EVALUATE) {
				{
				State = 4585;
				evaluationEditionClause();
				}
			}

			State = 4589;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,438,Context) ) {
			case 1:
				{
				State = 4588;
				materializedViewQueryComputationClause();
				}
				break;
			}
			State = 4592;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DISABLE || _la==ENABLE) {
				{
				State = 4591;
				materializedViewQueryRewriteClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectMaterializedViewClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public ObjectMaterializedViewClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectMaterializedViewClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectMaterializedViewClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectMaterializedViewClause(this);
		}
	}

	[RuleVersion(0)]
	public ObjectMaterializedViewClauseContext objectMaterializedViewClause() {
		ObjectMaterializedViewClauseContext _localctx = new ObjectMaterializedViewClauseContext(Context, State);
		EnterRule(_localctx, 778, RULE_objectMaterializedViewClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4594;
			Match(OF);
			State = 4595;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewPrebuiltTableClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PREBUILT() { return GetToken(OracleAntlrParser.PREBUILT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REDUCED() { return GetToken(OracleAntlrParser.REDUCED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRECISION() { return GetToken(OracleAntlrParser.PRECISION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITHOUT() { return GetToken(OracleAntlrParser.WITHOUT, 0); }
		public MaterializedViewPrebuiltTableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewPrebuiltTableClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewPrebuiltTableClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewPrebuiltTableClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewPrebuiltTableClauseContext materializedViewPrebuiltTableClause() {
		MaterializedViewPrebuiltTableClauseContext _localctx = new MaterializedViewPrebuiltTableClauseContext(Context, State);
		EnterRule(_localctx, 780, RULE_materializedViewPrebuiltTableClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4597;
			Match(ON);
			State = 4598;
			Match(PREBUILT);
			State = 4599;
			Match(TABLE);
			State = 4603;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH || _la==WITHOUT) {
				{
				State = 4600;
				_la = TokenStream.LA(1);
				if ( !(_la==WITH || _la==WITHOUT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4601;
				Match(REDUCED);
				State = 4602;
				Match(PRECISION);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewPhysicalClusterPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLUSTER() { return GetToken(OracleAntlrParser.CLUSTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewPhysicalClusterColumnListContext materializedViewPhysicalClusterColumnList() {
			return GetRuleContext<MaterializedViewPhysicalClusterColumnListContext>(0);
		}
		public MaterializedViewPhysicalClusterPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewPhysicalClusterProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewPhysicalClusterProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewPhysicalClusterProperties(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewPhysicalClusterPropertiesContext materializedViewPhysicalClusterProperties() {
		MaterializedViewPhysicalClusterPropertiesContext _localctx = new MaterializedViewPhysicalClusterPropertiesContext(Context, State);
		EnterRule(_localctx, 782, RULE_materializedViewPhysicalClusterProperties);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4605;
			Match(CLUSTER);
			State = 4606;
			localSimpleIdentifierWithoutParentheses();
			State = 4607;
			materializedViewPhysicalClusterColumnList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewPhysicalClusterColumnListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext[] localSimpleIdentifierWithoutParentheses() {
			return GetRuleContexts<LocalSimpleIdentifierWithoutParenthesesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses(int i) {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(i);
		}
		public MaterializedViewPhysicalClusterColumnListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewPhysicalClusterColumnList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewPhysicalClusterColumnList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewPhysicalClusterColumnList(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewPhysicalClusterColumnListContext materializedViewPhysicalClusterColumnList() {
		MaterializedViewPhysicalClusterColumnListContext _localctx = new MaterializedViewPhysicalClusterColumnListContext(Context, State);
		EnterRule(_localctx, 784, RULE_materializedViewPhysicalClusterColumnList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4609;
			Match(LPAREN);
			State = 4611;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 4610;
				localSimpleIdentifierWithoutParentheses();
				}
				}
				State = 4613;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0) );
			State = 4615;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ColumnPropertiesContext columnProperties() {
			return GetRuleContext<ColumnPropertiesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitioningDefinitionClauseContext partitioningDefinitionClause() {
			return GetRuleContext<PartitioningDefinitionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewPropertiesCacheClauseContext materializedViewPropertiesCacheClause() {
			return GetRuleContext<MaterializedViewPropertiesCacheClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewPropertiesBuildClauseContext materializedViewPropertiesBuildClause() {
			return GetRuleContext<MaterializedViewPropertiesBuildClauseContext>(0);
		}
		public MaterializedViewPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewProperties(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewPropertiesContext materializedViewProperties() {
		MaterializedViewPropertiesContext _localctx = new MaterializedViewPropertiesContext(Context, State);
		EnterRule(_localctx, 786, RULE_materializedViewProperties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4618;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLUMN || _la==LOB || _la==NESTED || _la==VARRAY || _la==XMLTYPE) {
				{
				State = 4617;
				columnProperties();
				}
			}

			State = 4621;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 4620;
				partitioningDefinitionClause();
				}
			}

			State = 4624;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CACHE || _la==NOCACHE) {
				{
				State = 4623;
				materializedViewPropertiesCacheClause();
				}
			}

			State = 4627;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOPARALLEL || _la==PARALLEL) {
				{
				State = 4626;
				parallelClause();
				}
			}

			State = 4630;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BUILD) {
				{
				State = 4629;
				materializedViewPropertiesBuildClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewPropertiesCacheClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CACHE() { return GetToken(OracleAntlrParser.CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCACHE() { return GetToken(OracleAntlrParser.NOCACHE, 0); }
		public MaterializedViewPropertiesCacheClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewPropertiesCacheClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewPropertiesCacheClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewPropertiesCacheClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewPropertiesCacheClauseContext materializedViewPropertiesCacheClause() {
		MaterializedViewPropertiesCacheClauseContext _localctx = new MaterializedViewPropertiesCacheClauseContext(Context, State);
		EnterRule(_localctx, 788, RULE_materializedViewPropertiesCacheClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4632;
			_la = TokenStream.LA(1);
			if ( !(_la==CACHE || _la==NOCACHE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewPropertiesBuildClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUILD() { return GetToken(OracleAntlrParser.BUILD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMEDIATE() { return GetToken(OracleAntlrParser.IMMEDIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFERRED() { return GetToken(OracleAntlrParser.DEFERRED, 0); }
		public MaterializedViewPropertiesBuildClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewPropertiesBuildClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewPropertiesBuildClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewPropertiesBuildClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewPropertiesBuildClauseContext materializedViewPropertiesBuildClause() {
		MaterializedViewPropertiesBuildClauseContext _localctx = new MaterializedViewPropertiesBuildClauseContext(Context, State);
		EnterRule(_localctx, 790, RULE_materializedViewPropertiesBuildClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4634;
			Match(BUILD);
			State = 4635;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFERRED || _la==IMMEDIATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewUsingIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NO() { return GetToken(OracleAntlrParser.NO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewUsingIndexAttributesListClauseContext materializedViewUsingIndexAttributesListClause() {
			return GetRuleContext<MaterializedViewUsingIndexAttributesListClauseContext>(0);
		}
		public MaterializedViewUsingIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewUsingIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewUsingIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewUsingIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewUsingIndexClauseContext materializedViewUsingIndexClause() {
		MaterializedViewUsingIndexClauseContext _localctx = new MaterializedViewUsingIndexClauseContext(Context, State);
		EnterRule(_localctx, 792, RULE_materializedViewUsingIndexClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4637;
			Match(USING);
			State = 4644;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NO:
				{
				State = 4638;
				Match(NO);
				State = 4639;
				Match(INDEX);
				}
				break;
			case INDEX:
				{
				State = 4640;
				Match(INDEX);
				State = 4642;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INITRANS || _la==MAXTRANS || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
					{
					State = 4641;
					materializedViewUsingIndexAttributesListClause();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewUsingIndexAttributesListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext[] tablespaceClause() {
			return GetRuleContexts<TablespaceClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause(int i) {
			return GetRuleContext<TablespaceClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext[] physicalAttribute() {
			return GetRuleContexts<PhysicalAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute(int i) {
			return GetRuleContext<PhysicalAttributeContext>(i);
		}
		public MaterializedViewUsingIndexAttributesListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewUsingIndexAttributesListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewUsingIndexAttributesListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewUsingIndexAttributesListClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewUsingIndexAttributesListClauseContext materializedViewUsingIndexAttributesListClause() {
		MaterializedViewUsingIndexAttributesListClauseContext _localctx = new MaterializedViewUsingIndexAttributesListClauseContext(Context, State);
		EnterRule(_localctx, 794, RULE_materializedViewUsingIndexAttributesListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4648;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 4648;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TABLESPACE:
					{
					State = 4646;
					tablespaceClause();
					}
					break;
				case INITRANS:
				case MAXTRANS:
				case PCTFREE:
				case PCTUSED:
				case STORAGE:
					{
					State = 4647;
					physicalAttribute();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 4650;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==INITRANS || _la==MAXTRANS || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFRESH() { return GetToken(OracleAntlrParser.REFRESH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshOptionsContext materializedViewRefreshOptions() {
			return GetRuleContext<MaterializedViewRefreshOptionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEVER() { return GetToken(OracleAntlrParser.NEVER, 0); }
		public MaterializedViewRefreshClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshClauseContext materializedViewRefreshClause() {
		MaterializedViewRefreshClauseContext _localctx = new MaterializedViewRefreshClauseContext(Context, State);
		EnterRule(_localctx, 796, RULE_materializedViewRefreshClause);
		try {
			State = 4656;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case REFRESH:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4652;
				Match(REFRESH);
				State = 4653;
				materializedViewRefreshOptions();
				}
				break;
			case NEVER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4654;
				Match(NEVER);
				State = 4655;
				Match(REFRESH);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshOptionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshTypeContext[] materializedViewRefreshType() {
			return GetRuleContexts<MaterializedViewRefreshTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshTypeContext materializedViewRefreshType(int i) {
			return GetRuleContext<MaterializedViewRefreshTypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshTriggerContext[] materializedViewRefreshTrigger() {
			return GetRuleContexts<MaterializedViewRefreshTriggerContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshTriggerContext materializedViewRefreshTrigger(int i) {
			return GetRuleContext<MaterializedViewRefreshTriggerContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshScheduleContext[] materializedViewRefreshSchedule() {
			return GetRuleContexts<MaterializedViewRefreshScheduleContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshScheduleContext materializedViewRefreshSchedule(int i) {
			return GetRuleContext<MaterializedViewRefreshScheduleContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshRowIdentificationClauseContext[] materializedViewRefreshRowIdentificationClause() {
			return GetRuleContexts<MaterializedViewRefreshRowIdentificationClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshRowIdentificationClauseContext materializedViewRefreshRowIdentificationClause(int i) {
			return GetRuleContext<MaterializedViewRefreshRowIdentificationClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshRollbackSegmentClauseContext[] materializedViewRefreshRollbackSegmentClause() {
			return GetRuleContexts<MaterializedViewRefreshRollbackSegmentClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshRollbackSegmentClauseContext materializedViewRefreshRollbackSegmentClause(int i) {
			return GetRuleContext<MaterializedViewRefreshRollbackSegmentClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshUsingConstraintsContext[] materializedViewRefreshUsingConstraints() {
			return GetRuleContexts<MaterializedViewRefreshUsingConstraintsContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshUsingConstraintsContext materializedViewRefreshUsingConstraints(int i) {
			return GetRuleContext<MaterializedViewRefreshUsingConstraintsContext>(i);
		}
		public MaterializedViewRefreshOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshOptions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshOptions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshOptions(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshOptionsContext materializedViewRefreshOptions() {
		MaterializedViewRefreshOptionsContext _localctx = new MaterializedViewRefreshOptionsContext(Context, State);
		EnterRule(_localctx, 798, RULE_materializedViewRefreshOptions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4664;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 4664;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,452,Context) ) {
				case 1:
					{
					State = 4658;
					materializedViewRefreshType();
					}
					break;
				case 2:
					{
					State = 4659;
					materializedViewRefreshTrigger();
					}
					break;
				case 3:
					{
					State = 4660;
					materializedViewRefreshSchedule();
					}
					break;
				case 4:
					{
					State = 4661;
					materializedViewRefreshRowIdentificationClause();
					}
					break;
				case 5:
					{
					State = 4662;
					materializedViewRefreshRollbackSegmentClause();
					}
					break;
				case 6:
					{
					State = 4663;
					materializedViewRefreshUsingConstraints();
					}
					break;
				}
				}
				State = 4666;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COMPLETE || _la==FAST || _la==FORCE || _la==NEXT || _la==ON || _la==START || _la==USING || _la==WITH );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FAST() { return GetToken(OracleAntlrParser.FAST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPLETE() { return GetToken(OracleAntlrParser.COMPLETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORCE() { return GetToken(OracleAntlrParser.FORCE, 0); }
		public MaterializedViewRefreshTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshType(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshTypeContext materializedViewRefreshType() {
		MaterializedViewRefreshTypeContext _localctx = new MaterializedViewRefreshTypeContext(Context, State);
		EnterRule(_localctx, 800, RULE_materializedViewRefreshType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4668;
			_la = TokenStream.LA(1);
			if ( !(_la==COMPLETE || _la==FAST || _la==FORCE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshTriggerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEMAND() { return GetToken(OracleAntlrParser.DEMAND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMIT() { return GetToken(OracleAntlrParser.COMMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATEMENT() { return GetToken(OracleAntlrParser.STATEMENT, 0); }
		public MaterializedViewRefreshTriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshTrigger; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshTrigger(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshTrigger(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshTriggerContext materializedViewRefreshTrigger() {
		MaterializedViewRefreshTriggerContext _localctx = new MaterializedViewRefreshTriggerContext(Context, State);
		EnterRule(_localctx, 802, RULE_materializedViewRefreshTrigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4670;
			Match(ON);
			State = 4671;
			_la = TokenStream.LA(1);
			if ( !(_la==COMMIT || _la==DEMAND || _la==STATEMENT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshScheduleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode START() { return GetToken(OracleAntlrParser.START, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEXT() { return GetToken(OracleAntlrParser.NEXT, 0); }
		public MaterializedViewRefreshScheduleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshSchedule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshSchedule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshSchedule(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshScheduleContext materializedViewRefreshSchedule() {
		MaterializedViewRefreshScheduleContext _localctx = new MaterializedViewRefreshScheduleContext(Context, State);
		EnterRule(_localctx, 804, RULE_materializedViewRefreshSchedule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4676;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case START:
				{
				State = 4673;
				Match(START);
				State = 4674;
				Match(WITH);
				}
				break;
			case NEXT:
				{
				State = 4675;
				Match(NEXT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 4678;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshRowIdentificationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIMARY() { return GetToken(OracleAntlrParser.PRIMARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(OracleAntlrParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWID() { return GetToken(OracleAntlrParser.ROWID, 0); }
		public MaterializedViewRefreshRowIdentificationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshRowIdentificationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshRowIdentificationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshRowIdentificationClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshRowIdentificationClauseContext materializedViewRefreshRowIdentificationClause() {
		MaterializedViewRefreshRowIdentificationClauseContext _localctx = new MaterializedViewRefreshRowIdentificationClauseContext(Context, State);
		EnterRule(_localctx, 806, RULE_materializedViewRefreshRowIdentificationClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4680;
			Match(WITH);
			State = 4684;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PRIMARY:
				{
				State = 4681;
				Match(PRIMARY);
				State = 4682;
				Match(KEY);
				}
				break;
			case ROWID:
				{
				State = 4683;
				Match(ROWID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshRollbackSegmentClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLLBACK() { return GetToken(OracleAntlrParser.ROLLBACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEGMENT() { return GetToken(OracleAntlrParser.SEGMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MASTER() { return GetToken(OracleAntlrParser.MASTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(OracleAntlrParser.LOCAL, 0); }
		public MaterializedViewRefreshRollbackSegmentClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshRollbackSegmentClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshRollbackSegmentClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshRollbackSegmentClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshRollbackSegmentClauseContext materializedViewRefreshRollbackSegmentClause() {
		MaterializedViewRefreshRollbackSegmentClauseContext _localctx = new MaterializedViewRefreshRollbackSegmentClauseContext(Context, State);
		EnterRule(_localctx, 808, RULE_materializedViewRefreshRollbackSegmentClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4686;
			Match(USING);
			State = 4699;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEFAULT:
				{
				State = 4687;
				Match(DEFAULT);
				State = 4689;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOCAL || _la==MASTER) {
					{
					State = 4688;
					_la = TokenStream.LA(1);
					if ( !(_la==LOCAL || _la==MASTER) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 4691;
				Match(ROLLBACK);
				State = 4692;
				Match(SEGMENT);
				}
				break;
			case LOCAL:
			case MASTER:
			case ROLLBACK:
				{
				State = 4694;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOCAL || _la==MASTER) {
					{
					State = 4693;
					_la = TokenStream.LA(1);
					if ( !(_la==LOCAL || _la==MASTER) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 4696;
				Match(ROLLBACK);
				State = 4697;
				Match(SEGMENT);
				State = 4698;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshUsingConstraintsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINTS() { return GetToken(OracleAntlrParser.CONSTRAINTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENFORCED() { return GetToken(OracleAntlrParser.ENFORCED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUSTED() { return GetToken(OracleAntlrParser.TRUSTED, 0); }
		public MaterializedViewRefreshUsingConstraintsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshUsingConstraints; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshUsingConstraints(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshUsingConstraints(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshUsingConstraintsContext materializedViewRefreshUsingConstraints() {
		MaterializedViewRefreshUsingConstraintsContext _localctx = new MaterializedViewRefreshUsingConstraintsContext(Context, State);
		EnterRule(_localctx, 810, RULE_materializedViewRefreshUsingConstraints);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4701;
			Match(USING);
			State = 4702;
			_la = TokenStream.LA(1);
			if ( !(_la==ENFORCED || _la==TRUSTED) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4703;
			Match(CONSTRAINTS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EvaluationEditionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EVALUATE() { return GetToken(OracleAntlrParser.EVALUATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(OracleAntlrParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITION() { return GetToken(OracleAntlrParser.EDITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public EvaluationEditionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_evaluationEditionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterEvaluationEditionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitEvaluationEditionClause(this);
		}
	}

	[RuleVersion(0)]
	public EvaluationEditionClauseContext evaluationEditionClause() {
		EvaluationEditionClauseContext _localctx = new EvaluationEditionClauseContext(Context, State);
		EnterRule(_localctx, 812, RULE_evaluationEditionClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4705;
			Match(EVALUATE);
			State = 4706;
			Match(USING);
			State = 4713;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT:
				{
				State = 4707;
				Match(CURRENT);
				State = 4708;
				Match(EDITION);
				}
				break;
			case EDITION:
				{
				State = 4709;
				Match(EDITION);
				State = 4710;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			case NULL:
				{
				State = 4711;
				Match(NULL);
				State = 4712;
				Match(EDITION);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewQueryComputationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUERY() { return GetToken(OracleAntlrParser.QUERY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPUTATION() { return GetToken(OracleAntlrParser.COMPUTATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISABLE() { return GetToken(OracleAntlrParser.DISABLE, 0); }
		public MaterializedViewQueryComputationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewQueryComputationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewQueryComputationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewQueryComputationClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewQueryComputationClauseContext materializedViewQueryComputationClause() {
		MaterializedViewQueryComputationClauseContext _localctx = new MaterializedViewQueryComputationClauseContext(Context, State);
		EnterRule(_localctx, 814, RULE_materializedViewQueryComputationClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4715;
			_la = TokenStream.LA(1);
			if ( !(_la==DISABLE || _la==ENABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4716;
			Match(ON);
			State = 4717;
			Match(QUERY);
			State = 4718;
			Match(COMPUTATION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewQueryRewriteClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUERY() { return GetToken(OracleAntlrParser.QUERY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REWRITE() { return GetToken(OracleAntlrParser.REWRITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISABLE() { return GetToken(OracleAntlrParser.DISABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnusableEditionsBeforeClauseContext unusableEditionsBeforeClause() {
			return GetRuleContext<UnusableEditionsBeforeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnusableEditionsBeginningWithClauseContext unusableEditionsBeginningWithClause() {
			return GetRuleContext<UnusableEditionsBeginningWithClauseContext>(0);
		}
		public MaterializedViewQueryRewriteClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewQueryRewriteClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaterializedViewQueryRewriteClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaterializedViewQueryRewriteClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewQueryRewriteClauseContext materializedViewQueryRewriteClause() {
		MaterializedViewQueryRewriteClauseContext _localctx = new MaterializedViewQueryRewriteClauseContext(Context, State);
		EnterRule(_localctx, 816, RULE_materializedViewQueryRewriteClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4720;
			_la = TokenStream.LA(1);
			if ( !(_la==DISABLE || _la==ENABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4721;
			Match(QUERY);
			State = 4722;
			Match(REWRITE);
			State = 4724;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,460,Context) ) {
			case 1:
				{
				State = 4723;
				unusableEditionsBeforeClause();
				}
				break;
			}
			State = 4727;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNUSABLE) {
				{
				State = 4726;
				unusableEditionsBeginningWithClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnusableEditionsBeforeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEFORE() { return GetToken(OracleAntlrParser.BEFORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(OracleAntlrParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITION() { return GetToken(OracleAntlrParser.EDITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public UnusableEditionsBeforeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unusableEditionsBeforeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUnusableEditionsBeforeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUnusableEditionsBeforeClause(this);
		}
	}

	[RuleVersion(0)]
	public UnusableEditionsBeforeClauseContext unusableEditionsBeforeClause() {
		UnusableEditionsBeforeClauseContext _localctx = new UnusableEditionsBeforeClauseContext(Context, State);
		EnterRule(_localctx, 818, RULE_unusableEditionsBeforeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4729;
			Match(UNUSABLE);
			State = 4730;
			Match(BEFORE);
			State = 4735;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT:
				{
				State = 4731;
				Match(CURRENT);
				State = 4732;
				Match(EDITION);
				}
				break;
			case EDITION:
				{
				State = 4733;
				Match(EDITION);
				State = 4734;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnusableEditionsBeginningWithClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEGINNING() { return GetToken(OracleAntlrParser.BEGINNING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(OracleAntlrParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITION() { return GetToken(OracleAntlrParser.EDITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public UnusableEditionsBeginningWithClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unusableEditionsBeginningWithClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUnusableEditionsBeginningWithClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUnusableEditionsBeginningWithClause(this);
		}
	}

	[RuleVersion(0)]
	public UnusableEditionsBeginningWithClauseContext unusableEditionsBeginningWithClause() {
		UnusableEditionsBeginningWithClauseContext _localctx = new UnusableEditionsBeginningWithClauseContext(Context, State);
		EnterRule(_localctx, 820, RULE_unusableEditionsBeginningWithClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4737;
			Match(UNUSABLE);
			State = 4738;
			Match(BEGINNING);
			State = 4739;
			Match(WITH);
			State = 4746;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT:
				{
				State = 4740;
				Match(CURRENT);
				State = 4741;
				Match(EDITION);
				}
				break;
			case EDITION:
				{
				State = 4742;
				Match(EDITION);
				State = 4743;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			case NULL:
				{
				State = 4744;
				Match(NULL);
				State = 4745;
				Match(EDITION);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ViewHeaderContext viewHeader() {
			return GetRuleContext<ViewHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ViewBodyContext viewBody() {
			return GetRuleContext<ViewBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForceNoForceClauseContext forceNoForceClause() {
			return GetRuleContext<ForceNoForceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EditionOptionClauseContext editionOptionClause() {
			return GetRuleContext<EditionOptionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITIONING() { return GetToken(OracleAntlrParser.EDITIONING, 0); }
		public ViewStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterViewStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitViewStatement(this);
		}
	}

	[RuleVersion(0)]
	public ViewStatementContext viewStatement() {
		ViewStatementContext _localctx = new ViewStatementContext(Context, State);
		EnterRule(_localctx, 822, RULE_viewStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4749;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FORCE || _la==NO) {
				{
				State = 4748;
				forceNoForceClause();
				}
			}

			State = 4752;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EDITIONABLE || _la==NONEDITIONABLE) {
				{
				State = 4751;
				editionOptionClause();
				}
			}

			State = 4755;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EDITIONING) {
				{
				State = 4754;
				Match(EDITIONING);
				}
			}

			State = 4757;
			viewHeader();
			State = 4758;
			viewBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VIEW() { return GetToken(OracleAntlrParser.VIEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ViewAliasOrConstraintListContext viewAliasOrConstraintList() {
			return GetRuleContext<ViewAliasOrConstraintListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeViewClauseContext xmlTypeViewClause() {
			return GetRuleContext<XmlTypeViewClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectViewClauseContext objectViewClause() {
			return GetRuleContext<ObjectViewClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultCollationOptionContext defaultCollationOption() {
			return GetRuleContext<DefaultCollationOptionContext>(0);
		}
		public ViewHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterViewHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitViewHeader(this);
		}
	}

	[RuleVersion(0)]
	public ViewHeaderContext viewHeader() {
		ViewHeaderContext _localctx = new ViewHeaderContext(Context, State);
		EnterRule(_localctx, 824, RULE_viewHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4760;
			Match(VIEW);
			State = 4761;
			plainIdentifier();
			State = 4765;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,467,Context) ) {
			case 1:
				{
				State = 4762;
				viewAliasOrConstraintList();
				}
				break;
			case 2:
				{
				State = 4763;
				xmlTypeViewClause();
				}
				break;
			case 3:
				{
				State = 4764;
				objectViewClause();
				}
				break;
			}
			State = 4768;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT) {
				{
				State = 4767;
				defaultCollationOption();
				}
			}

			State = 4770;
			Match(AS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeViewClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLTYPE() { return GetToken(OracleAntlrParser.XMLTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlSchemaSpecContext xmlSchemaSpec() {
			return GetRuleContext<XmlSchemaSpecContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WithObjectIdentifierClauseContext withObjectIdentifierClause() {
			return GetRuleContext<WithObjectIdentifierClauseContext>(0);
		}
		public XmlTypeViewClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeViewClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlTypeViewClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlTypeViewClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeViewClauseContext xmlTypeViewClause() {
		XmlTypeViewClauseContext _localctx = new XmlTypeViewClauseContext(Context, State);
		EnterRule(_localctx, 826, RULE_xmlTypeViewClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4772;
			Match(OF);
			State = 4773;
			Match(XMLTYPE);
			State = 4774;
			xmlSchemaSpec();
			State = 4775;
			withObjectIdentifierClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlSchemaSpecContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public XmlSchemaClauseContext xmlSchemaClause() {
			return GetRuleContext<XmlSchemaClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlSchemaElementClauseContext xmlSchemaElementClause() {
			return GetRuleContext<XmlSchemaElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeStoreAllClauseContext xmlTypeStoreAllClause() {
			return GetRuleContext<XmlTypeStoreAllClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlSchemaSpecNonschemaClauseContext xmlSchemaSpecNonschemaClause() {
			return GetRuleContext<XmlSchemaSpecNonschemaClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlSchemaSpecAnyschemaClauseContext xmlSchemaSpecAnyschemaClause() {
			return GetRuleContext<XmlSchemaSpecAnyschemaClauseContext>(0);
		}
		public XmlSchemaSpecContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlSchemaSpec; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlSchemaSpec(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlSchemaSpec(this);
		}
	}

	[RuleVersion(0)]
	public XmlSchemaSpecContext xmlSchemaSpec() {
		XmlSchemaSpecContext _localctx = new XmlSchemaSpecContext(Context, State);
		EnterRule(_localctx, 828, RULE_xmlSchemaSpec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4778;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==XMLSCHEMA) {
				{
				State = 4777;
				xmlSchemaClause();
				}
			}

			State = 4781;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELEMENT) {
				{
				State = 4780;
				xmlSchemaElementClause();
				}
			}

			State = 4784;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STORE) {
				{
				State = 4783;
				xmlTypeStoreAllClause();
				}
			}

			State = 4787;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,472,Context) ) {
			case 1:
				{
				State = 4786;
				xmlSchemaSpecNonschemaClause();
				}
				break;
			}
			State = 4790;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALLOW || _la==DISALLOW) {
				{
				State = 4789;
				xmlSchemaSpecAnyschemaClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlSchemaClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLSCHEMA() { return GetToken(OracleAntlrParser.XMLSCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public XmlSchemaClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlSchemaClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlSchemaClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlSchemaClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlSchemaClauseContext xmlSchemaClause() {
		XmlSchemaClauseContext _localctx = new XmlSchemaClauseContext(Context, State);
		EnterRule(_localctx, 830, RULE_xmlSchemaClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4792;
			Match(XMLSCHEMA);
			State = 4793;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlSchemaElementClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELEMENT() { return GetToken(OracleAntlrParser.ELEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext[] localSimpleIdentifierWithoutParentheses() {
			return GetRuleContexts<LocalSimpleIdentifierWithoutParenthesesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses(int i) {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POUND_SIGN() { return GetToken(OracleAntlrParser.POUND_SIGN, 0); }
		public XmlSchemaElementClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlSchemaElementClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlSchemaElementClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlSchemaElementClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlSchemaElementClauseContext xmlSchemaElementClause() {
		XmlSchemaElementClauseContext _localctx = new XmlSchemaElementClauseContext(Context, State);
		EnterRule(_localctx, 832, RULE_xmlSchemaElementClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4795;
			Match(ELEMENT);
			State = 4796;
			localSimpleIdentifierWithoutParentheses();
			State = 4799;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==POUND_SIGN) {
				{
				State = 4797;
				Match(POUND_SIGN);
				State = 4798;
				localSimpleIdentifierWithoutParentheses();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlSchemaSpecNonschemaClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONSCHEMA() { return GetToken(OracleAntlrParser.NONSCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALLOW() { return GetToken(OracleAntlrParser.ALLOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISALLOW() { return GetToken(OracleAntlrParser.DISALLOW, 0); }
		public XmlSchemaSpecNonschemaClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlSchemaSpecNonschemaClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlSchemaSpecNonschemaClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlSchemaSpecNonschemaClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlSchemaSpecNonschemaClauseContext xmlSchemaSpecNonschemaClause() {
		XmlSchemaSpecNonschemaClauseContext _localctx = new XmlSchemaSpecNonschemaClauseContext(Context, State);
		EnterRule(_localctx, 834, RULE_xmlSchemaSpecNonschemaClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4801;
			_la = TokenStream.LA(1);
			if ( !(_la==ALLOW || _la==DISALLOW) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4802;
			Match(NONSCHEMA);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlSchemaSpecAnyschemaClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANYSCHEMA() { return GetToken(OracleAntlrParser.ANYSCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALLOW() { return GetToken(OracleAntlrParser.ALLOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISALLOW() { return GetToken(OracleAntlrParser.DISALLOW, 0); }
		public XmlSchemaSpecAnyschemaClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlSchemaSpecAnyschemaClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlSchemaSpecAnyschemaClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlSchemaSpecAnyschemaClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlSchemaSpecAnyschemaClauseContext xmlSchemaSpecAnyschemaClause() {
		XmlSchemaSpecAnyschemaClauseContext _localctx = new XmlSchemaSpecAnyschemaClauseContext(Context, State);
		EnterRule(_localctx, 836, RULE_xmlSchemaSpecAnyschemaClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4804;
			_la = TokenStream.LA(1);
			if ( !(_la==ALLOW || _la==DISALLOW) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4805;
			Match(ANYSCHEMA);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectViewClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WithObjectIdentifierClauseContext withObjectIdentifierClause() {
			return GetRuleContext<WithObjectIdentifierClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnderClauseContext underClause() {
			return GetRuleContext<UnderClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AttributeOrConstraintListContext attributeOrConstraintList() {
			return GetRuleContext<AttributeOrConstraintListContext>(0);
		}
		public ObjectViewClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectViewClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectViewClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectViewClause(this);
		}
	}

	[RuleVersion(0)]
	public ObjectViewClauseContext objectViewClause() {
		ObjectViewClauseContext _localctx = new ObjectViewClauseContext(Context, State);
		EnterRule(_localctx, 838, RULE_objectViewClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4807;
			Match(OF);
			State = 4808;
			plainIdentifier();
			State = 4811;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WITH:
				{
				State = 4809;
				withObjectIdentifierClause();
				}
				break;
			case UNDER:
				{
				State = 4810;
				underClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 4814;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 4813;
				attributeOrConstraintList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnderClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNDER() { return GetToken(OracleAntlrParser.UNDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public UnderClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_underClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUnderClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUnderClause(this);
		}
	}

	[RuleVersion(0)]
	public UnderClauseContext underClause() {
		UnderClauseContext _localctx = new UnderClauseContext(Context, State);
		EnterRule(_localctx, 840, RULE_underClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4816;
			Match(UNDER);
			State = 4817;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithObjectIdentifierClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(OracleAntlrParser.OBJECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(OracleAntlrParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OID() { return GetToken(OracleAntlrParser.OID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParenthesizedExpressionListContext parenthesizedExpressionList() {
			return GetRuleContext<ParenthesizedExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		public WithObjectIdentifierClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withObjectIdentifierClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterWithObjectIdentifierClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitWithObjectIdentifierClause(this);
		}
	}

	[RuleVersion(0)]
	public WithObjectIdentifierClauseContext withObjectIdentifierClause() {
		WithObjectIdentifierClauseContext _localctx = new WithObjectIdentifierClauseContext(Context, State);
		EnterRule(_localctx, 842, RULE_withObjectIdentifierClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4819;
			Match(WITH);
			State = 4820;
			Match(OBJECT);
			State = 4821;
			_la = TokenStream.LA(1);
			if ( !(_la==IDENTIFIER || _la==OID) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4824;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				{
				State = 4822;
				parenthesizedExpressionList();
				}
				break;
			case DEFAULT:
				{
				State = 4823;
				Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParenthesizedExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public ParenthesizedExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parenthesizedExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterParenthesizedExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitParenthesizedExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public ParenthesizedExpressionListContext parenthesizedExpressionList() {
		ParenthesizedExpressionListContext _localctx = new ParenthesizedExpressionListContext(Context, State);
		EnterRule(_localctx, 844, RULE_parenthesizedExpressionList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4826;
			Match(LPAREN);
			State = 4827;
			expressionList();
			State = 4828;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForceNoForceClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORCE() { return GetToken(OracleAntlrParser.FORCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NO() { return GetToken(OracleAntlrParser.NO, 0); }
		public ForceNoForceClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forceNoForceClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForceNoForceClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForceNoForceClause(this);
		}
	}

	[RuleVersion(0)]
	public ForceNoForceClauseContext forceNoForceClause() {
		ForceNoForceClauseContext _localctx = new ForceNoForceClauseContext(Context, State);
		EnterRule(_localctx, 846, RULE_forceNoForceClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4831;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NO) {
				{
				State = 4830;
				Match(NO);
				}
			}

			State = 4833;
			Match(FORCE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ViewBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterViewBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitViewBody(this);
		}
	}

	[RuleVersion(0)]
	public ViewBodyContext viewBody() {
		ViewBodyContext _localctx = new ViewBodyContext(Context, State);
		EnterRule(_localctx, 848, RULE_viewBody);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4835;
			selectStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryRestrictionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public WithCheckOptionContext withCheckOption() {
			return GetRuleContext<WithCheckOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WithReadOnlyContext withReadOnly() {
			return GetRuleContext<WithReadOnlyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintNameClauseContext constraintNameClause() {
			return GetRuleContext<ConstraintNameClauseContext>(0);
		}
		public SubqueryRestrictionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryRestrictionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubqueryRestrictionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubqueryRestrictionClause(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryRestrictionClauseContext subqueryRestrictionClause() {
		SubqueryRestrictionClauseContext _localctx = new SubqueryRestrictionClauseContext(Context, State);
		EnterRule(_localctx, 850, RULE_subqueryRestrictionClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4837;
			Match(WITH);
			State = 4840;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CHECK:
				{
				State = 4838;
				withCheckOption();
				}
				break;
			case READ:
				{
				State = 4839;
				withReadOnly();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 4843;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONSTRAINT) {
				{
				State = 4842;
				constraintNameClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewAliasOrConstraintListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ViewAliasOrTableConstraintContext[] viewAliasOrTableConstraint() {
			return GetRuleContexts<ViewAliasOrTableConstraintContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ViewAliasOrTableConstraintContext viewAliasOrTableConstraint(int i) {
			return GetRuleContext<ViewAliasOrTableConstraintContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ViewAliasOrConstraintListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewAliasOrConstraintList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterViewAliasOrConstraintList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitViewAliasOrConstraintList(this);
		}
	}

	[RuleVersion(0)]
	public ViewAliasOrConstraintListContext viewAliasOrConstraintList() {
		ViewAliasOrConstraintListContext _localctx = new ViewAliasOrConstraintListContext(Context, State);
		EnterRule(_localctx, 852, RULE_viewAliasOrConstraintList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4845;
			Match(LPAREN);
			State = 4846;
			viewAliasOrTableConstraint();
			State = 4851;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4847;
				Match(COMMA);
				State = 4848;
				viewAliasOrTableConstraint();
				}
				}
				State = 4853;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4854;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewAliasOrTableConstraintContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ViewAliasContext viewAlias() {
			return GetRuleContext<ViewAliasContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableConstraintClauseContext tableConstraintClause() {
			return GetRuleContext<TableConstraintClauseContext>(0);
		}
		public ViewAliasOrTableConstraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewAliasOrTableConstraint; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterViewAliasOrTableConstraint(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitViewAliasOrTableConstraint(this);
		}
	}

	[RuleVersion(0)]
	public ViewAliasOrTableConstraintContext viewAliasOrTableConstraint() {
		ViewAliasOrTableConstraintContext _localctx = new ViewAliasOrTableConstraintContext(Context, State);
		EnterRule(_localctx, 854, RULE_viewAliasOrTableConstraint);
		try {
			State = 4858;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,482,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4856;
				viewAlias();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4857;
				tableConstraintClause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewAliasContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext[] columnConstraintClause() {
			return GetRuleContexts<ColumnConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext columnConstraintClause(int i) {
			return GetRuleContext<ColumnConstraintClauseContext>(i);
		}
		public ViewAliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewAlias; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterViewAlias(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitViewAlias(this);
		}
	}

	[RuleVersion(0)]
	public ViewAliasContext viewAlias() {
		ViewAliasContext _localctx = new ViewAliasContext(Context, State);
		EnterRule(_localctx, 856, RULE_viewAlias);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4860;
			plainIdentifier();
			State = 4864;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==CHECK || _la==CONSTRAINT || _la==FOREIGN || ((((_la - 344)) & ~0x3f) == 0 && ((1L << (_la - 344)) & ((1L << (NOT - 344)) | (1L << (NULL - 344)) | (1L << (PRIMARY - 344)))) != 0) || _la==REFERENCES || _la==UNIQUE || _la==LPAREN) {
				{
				{
				State = 4861;
				columnConstraintClause();
				}
				}
				State = 4866;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AttributeOrConstraintListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AttributeOrTableConstraintContext[] attributeOrTableConstraint() {
			return GetRuleContexts<AttributeOrTableConstraintContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AttributeOrTableConstraintContext attributeOrTableConstraint(int i) {
			return GetRuleContext<AttributeOrTableConstraintContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public AttributeOrConstraintListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attributeOrConstraintList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAttributeOrConstraintList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAttributeOrConstraintList(this);
		}
	}

	[RuleVersion(0)]
	public AttributeOrConstraintListContext attributeOrConstraintList() {
		AttributeOrConstraintListContext _localctx = new AttributeOrConstraintListContext(Context, State);
		EnterRule(_localctx, 858, RULE_attributeOrConstraintList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4867;
			Match(LPAREN);
			State = 4868;
			attributeOrTableConstraint();
			State = 4873;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4869;
				Match(COMMA);
				State = 4870;
				attributeOrTableConstraint();
				}
				}
				State = 4875;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4876;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AttributeOrTableConstraintContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AttributeConstraintClauseContext attributeConstraintClause() {
			return GetRuleContext<AttributeConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableConstraintClauseContext tableConstraintClause() {
			return GetRuleContext<TableConstraintClauseContext>(0);
		}
		public AttributeOrTableConstraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attributeOrTableConstraint; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAttributeOrTableConstraint(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAttributeOrTableConstraint(this);
		}
	}

	[RuleVersion(0)]
	public AttributeOrTableConstraintContext attributeOrTableConstraint() {
		AttributeOrTableConstraintContext _localctx = new AttributeOrTableConstraintContext(Context, State);
		EnterRule(_localctx, 860, RULE_attributeOrTableConstraint);
		try {
			State = 4880;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,485,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4878;
				attributeConstraintClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4879;
				tableConstraintClause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AttributeConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext[] columnConstraintClause() {
			return GetRuleContexts<ColumnConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext columnConstraintClause(int i) {
			return GetRuleContext<ColumnConstraintClauseContext>(i);
		}
		public AttributeConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attributeConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAttributeConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAttributeConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public AttributeConstraintClauseContext attributeConstraintClause() {
		AttributeConstraintClauseContext _localctx = new AttributeConstraintClauseContext(Context, State);
		EnterRule(_localctx, 862, RULE_attributeConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4882;
			identifier();
			State = 4884;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 4883;
				columnConstraintClause();
				}
				}
				State = 4886;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==CHECK || _la==CONSTRAINT || _la==FOREIGN || ((((_la - 344)) & ~0x3f) == 0 && ((1L << (_la - 344)) & ((1L << (NOT - 344)) | (1L << (NULL - 344)) | (1L << (PRIMARY - 344)))) != 0) || _la==REFERENCES || _la==UNIQUE || _la==LPAREN );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintUniqueClauseContext constraintUniqueClause() {
			return GetRuleContext<ConstraintUniqueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintPrimaryKeyClauseContext constraintPrimaryKeyClause() {
			return GetRuleContext<ConstraintPrimaryKeyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintForeignKeyClauseContext constraintForeignKeyClause() {
			return GetRuleContext<ConstraintForeignKeyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintCheckClauseContext constraintCheckClause() {
			return GetRuleContext<ConstraintCheckClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintNameClauseContext constraintNameClause() {
			return GetRuleContext<ConstraintNameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintStateClauseContext constraintStateClause() {
			return GetRuleContext<ConstraintStateClauseContext>(0);
		}
		public TableConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTableConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTableConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public TableConstraintClauseContext tableConstraintClause() {
		TableConstraintClauseContext _localctx = new TableConstraintClauseContext(Context, State);
		EnterRule(_localctx, 864, RULE_tableConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4889;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONSTRAINT) {
				{
				State = 4888;
				constraintNameClause();
				}
			}

			State = 4895;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNIQUE:
				{
				State = 4891;
				constraintUniqueClause();
				}
				break;
			case PRIMARY:
				{
				State = 4892;
				constraintPrimaryKeyClause();
				}
				break;
			case FOREIGN:
			case REFERENCES:
			case LPAREN:
				{
				State = 4893;
				constraintForeignKeyClause();
				}
				break;
			case CHECK:
				{
				State = 4894;
				constraintCheckClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 4898;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 120)) & ~0x3f) == 0 && ((1L << (_la - 120)) & ((1L << (DEFERRABLE - 120)) | (1L << (DISABLE - 120)) | (1L << (ENABLE - 120)) | (1L << (EXCEPTIONS - 120)))) != 0) || _la==INITIALLY || ((((_la - 338)) & ~0x3f) == 0 && ((1L << (_la - 338)) & ((1L << (NORELY - 338)) | (1L << (NOT - 338)) | (1L << (NOVALIDATE - 338)))) != 0) || _la==RELY || _la==USING || _la==VALIDATE) {
				{
				State = 4897;
				constraintStateClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnListInParenElementClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ComplexColumnListItemContext[] complexColumnListItem() {
			return GetRuleContexts<ComplexColumnListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComplexColumnListItemContext complexColumnListItem(int i) {
			return GetRuleContext<ComplexColumnListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext[] columnListItem() {
			return GetRuleContexts<ColumnListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem(int i) {
			return GetRuleContext<ColumnListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ColumnListInParenElementClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnListInParenElementClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterColumnListInParenElementClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitColumnListInParenElementClause(this);
		}
	}

	[RuleVersion(0)]
	public ColumnListInParenElementClauseContext columnListInParenElementClause() {
		ColumnListInParenElementClauseContext _localctx = new ColumnListInParenElementClauseContext(Context, State);
		EnterRule(_localctx, 866, RULE_columnListInParenElementClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4900;
			Match(LPAREN);
			State = 4903;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,490,Context) ) {
			case 1:
				{
				State = 4901;
				complexColumnListItem();
				}
				break;
			case 2:
				{
				State = 4902;
				columnListItem();
				}
				break;
			}
			State = 4912;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4905;
				Match(COMMA);
				State = 4908;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,491,Context) ) {
				case 1:
					{
					State = 4906;
					complexColumnListItem();
					}
					break;
				case 2:
					{
					State = 4907;
					columnListItem();
					}
					break;
				}
				}
				}
				State = 4914;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4915;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintNullNotNullClauseContext constraintNullNotNullClause() {
			return GetRuleContext<ConstraintNullNotNullClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintUniqueClauseContext constraintUniqueClause() {
			return GetRuleContext<ConstraintUniqueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintPrimaryKeyClauseContext constraintPrimaryKeyClause() {
			return GetRuleContext<ConstraintPrimaryKeyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintForeignKeyClauseContext constraintForeignKeyClause() {
			return GetRuleContext<ConstraintForeignKeyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintCheckClauseContext constraintCheckClause() {
			return GetRuleContext<ConstraintCheckClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintNameClauseContext constraintNameClause() {
			return GetRuleContext<ConstraintNameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintStateClauseContext constraintStateClause() {
			return GetRuleContext<ConstraintStateClauseContext>(0);
		}
		public ColumnConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterColumnConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitColumnConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public ColumnConstraintClauseContext columnConstraintClause() {
		ColumnConstraintClauseContext _localctx = new ColumnConstraintClauseContext(Context, State);
		EnterRule(_localctx, 868, RULE_columnConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4918;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONSTRAINT) {
				{
				State = 4917;
				constraintNameClause();
				}
			}

			State = 4925;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOT:
			case NULL:
				{
				State = 4920;
				constraintNullNotNullClause();
				}
				break;
			case UNIQUE:
				{
				State = 4921;
				constraintUniqueClause();
				}
				break;
			case PRIMARY:
				{
				State = 4922;
				constraintPrimaryKeyClause();
				}
				break;
			case FOREIGN:
			case REFERENCES:
			case LPAREN:
				{
				State = 4923;
				constraintForeignKeyClause();
				}
				break;
			case CHECK:
				{
				State = 4924;
				constraintCheckClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 4928;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,495,Context) ) {
			case 1:
				{
				State = 4927;
				constraintStateClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintStateClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeferrableConstraintClauseContext[] deferrableConstraintClause() {
			return GetRuleContexts<DeferrableConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeferrableConstraintClauseContext deferrableConstraintClause(int i) {
			return GetRuleContext<DeferrableConstraintClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InitiallyConstraintClauseContext[] initiallyConstraintClause() {
			return GetRuleContexts<InitiallyConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public InitiallyConstraintClauseContext initiallyConstraintClause(int i) {
			return GetRuleContext<InitiallyConstraintClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelyConstraintClauseContext[] relyConstraintClause() {
			return GetRuleContexts<RelyConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelyConstraintClauseContext relyConstraintClause(int i) {
			return GetRuleContext<RelyConstraintClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingIndexConstraintClauseContext[] usingIndexConstraintClause() {
			return GetRuleContexts<UsingIndexConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingIndexConstraintClauseContext usingIndexConstraintClause(int i) {
			return GetRuleContext<UsingIndexConstraintClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnableClauseContext[] enableClause() {
			return GetRuleContexts<EnableClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnableClauseContext enableClause(int i) {
			return GetRuleContext<EnableClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ValidateClauseContext[] validateClause() {
			return GetRuleContexts<ValidateClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ValidateClauseContext validateClause(int i) {
			return GetRuleContext<ValidateClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionsIntoConstraintClauseContext[] exceptionsIntoConstraintClause() {
			return GetRuleContexts<ExceptionsIntoConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionsIntoConstraintClauseContext exceptionsIntoConstraintClause(int i) {
			return GetRuleContext<ExceptionsIntoConstraintClauseContext>(i);
		}
		public ConstraintStateClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintStateClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConstraintStateClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConstraintStateClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintStateClauseContext constraintStateClause() {
		ConstraintStateClauseContext _localctx = new ConstraintStateClauseContext(Context, State);
		EnterRule(_localctx, 870, RULE_constraintStateClause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4937;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					State = 4937;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case DEFERRABLE:
					case NOT:
						{
						State = 4930;
						deferrableConstraintClause();
						}
						break;
					case INITIALLY:
						{
						State = 4931;
						initiallyConstraintClause();
						}
						break;
					case NORELY:
					case RELY:
						{
						State = 4932;
						relyConstraintClause();
						}
						break;
					case USING:
						{
						State = 4933;
						usingIndexConstraintClause();
						}
						break;
					case DISABLE:
					case ENABLE:
						{
						State = 4934;
						enableClause();
						}
						break;
					case NOVALIDATE:
					case VALIDATE:
						{
						State = 4935;
						validateClause();
						}
						break;
					case EXCEPTIONS:
						{
						State = 4936;
						exceptionsIntoConstraintClause();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4939;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,497,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeferrableConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFERRABLE() { return GetToken(OracleAntlrParser.DEFERRABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public DeferrableConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deferrableConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDeferrableConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDeferrableConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public DeferrableConstraintClauseContext deferrableConstraintClause() {
		DeferrableConstraintClauseContext _localctx = new DeferrableConstraintClauseContext(Context, State);
		EnterRule(_localctx, 872, RULE_deferrableConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4942;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 4941;
				Match(NOT);
				}
			}

			State = 4944;
			Match(DEFERRABLE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InitiallyConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INITIALLY() { return GetToken(OracleAntlrParser.INITIALLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMEDIATE() { return GetToken(OracleAntlrParser.IMMEDIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFERRED() { return GetToken(OracleAntlrParser.DEFERRED, 0); }
		public InitiallyConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initiallyConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterInitiallyConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitInitiallyConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public InitiallyConstraintClauseContext initiallyConstraintClause() {
		InitiallyConstraintClauseContext _localctx = new InitiallyConstraintClauseContext(Context, State);
		EnterRule(_localctx, 874, RULE_initiallyConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4946;
			Match(INITIALLY);
			State = 4947;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFERRED || _la==IMMEDIATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnableClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISABLE() { return GetToken(OracleAntlrParser.DISABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		public EnableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enableClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterEnableClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitEnableClause(this);
		}
	}

	[RuleVersion(0)]
	public EnableClauseContext enableClause() {
		EnableClauseContext _localctx = new EnableClauseContext(Context, State);
		EnterRule(_localctx, 876, RULE_enableClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4949;
			_la = TokenStream.LA(1);
			if ( !(_la==DISABLE || _la==ENABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelyConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NORELY() { return GetToken(OracleAntlrParser.NORELY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELY() { return GetToken(OracleAntlrParser.RELY, 0); }
		public RelyConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relyConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRelyConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRelyConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public RelyConstraintClauseContext relyConstraintClause() {
		RelyConstraintClauseContext _localctx = new RelyConstraintClauseContext(Context, State);
		EnterRule(_localctx, 878, RULE_relyConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4951;
			_la = TokenStream.LA(1);
			if ( !(_la==NORELY || _la==RELY) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingIndexConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UsingIndexAttributesListConstraintClauseContext usingIndexAttributesListConstraintClause() {
			return GetRuleContext<UsingIndexAttributesListConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public UsingIndexConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingIndexConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUsingIndexConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUsingIndexConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public UsingIndexConstraintClauseContext usingIndexConstraintClause() {
		UsingIndexConstraintClauseContext _localctx = new UsingIndexConstraintClauseContext(Context, State);
		EnterRule(_localctx, 880, RULE_usingIndexConstraintClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4953;
			Match(USING);
			State = 4954;
			Match(INDEX);
			State = 4957;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,499,Context) ) {
			case 1:
				{
				State = 4955;
				usingIndexAttributesListConstraintClause();
				}
				break;
			case 2:
				{
				State = 4956;
				plainIdentifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingIndexAttributesListConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext[] loggingClause() {
			return GetRuleContexts<LoggingClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause(int i) {
			return GetRuleContext<LoggingClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext[] tablespaceClause() {
			return GetRuleContexts<TablespaceClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause(int i) {
			return GetRuleContext<TablespaceClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SortNoSortClauseContext[] sortNoSortClause() {
			return GetRuleContexts<SortNoSortClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SortNoSortClauseContext sortNoSortClause(int i) {
			return GetRuleContext<SortNoSortClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext[] physicalAttribute() {
			return GetRuleContexts<PhysicalAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute(int i) {
			return GetRuleContext<PhysicalAttributeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComputeStatisticsClauseContext[] computeStatisticsClause() {
			return GetRuleContexts<ComputeStatisticsClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComputeStatisticsClauseContext computeStatisticsClause(int i) {
			return GetRuleContext<ComputeStatisticsClauseContext>(i);
		}
		public UsingIndexAttributesListConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingIndexAttributesListConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUsingIndexAttributesListConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUsingIndexAttributesListConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public UsingIndexAttributesListConstraintClauseContext usingIndexAttributesListConstraintClause() {
		UsingIndexAttributesListConstraintClauseContext _localctx = new UsingIndexAttributesListConstraintClauseContext(Context, State);
		EnterRule(_localctx, 882, RULE_usingIndexAttributesListConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4964;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 4964;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case FILESYSTEM_LIKE_LOGGING:
				case LOGGING:
				case NOLOGGING:
					{
					State = 4959;
					loggingClause();
					}
					break;
				case TABLESPACE:
					{
					State = 4960;
					tablespaceClause();
					}
					break;
				case NOSORT:
				case SORT:
					{
					State = 4961;
					sortNoSortClause();
					}
					break;
				case INITRANS:
				case MAXTRANS:
				case PCTFREE:
				case PCTUSED:
				case STORAGE:
					{
					State = 4962;
					physicalAttribute();
					}
					break;
				case COMPUTE:
					{
					State = 4963;
					computeStatisticsClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 4966;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COMPUTE || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 276)) & ~0x3f) == 0 && ((1L << (_la - 276)) & ((1L << (LOGGING - 276)) | (1L << (MAXTRANS - 276)) | (1L << (NOLOGGING - 276)))) != 0) || ((((_la - 343)) & ~0x3f) == 0 && ((1L << (_la - 343)) & ((1L << (NOSORT - 343)) | (1L << (PCTFREE - 343)) | (1L << (PCTUSED - 343)))) != 0) || ((((_la - 480)) & ~0x3f) == 0 && ((1L << (_la - 480)) & ((1L << (SORT - 480)) | (1L << (STORAGE - 480)) | (1L << (TABLESPACE - 480)))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoggingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOGGING() { return GetToken(OracleAntlrParser.LOGGING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOLOGGING() { return GetToken(OracleAntlrParser.NOLOGGING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FILESYSTEM_LIKE_LOGGING() { return GetToken(OracleAntlrParser.FILESYSTEM_LIKE_LOGGING, 0); }
		public LoggingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loggingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLoggingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLoggingClause(this);
		}
	}

	[RuleVersion(0)]
	public LoggingClauseContext loggingClause() {
		LoggingClauseContext _localctx = new LoggingClauseContext(Context, State);
		EnterRule(_localctx, 884, RULE_loggingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4968;
			_la = TokenStream.LA(1);
			if ( !(_la==FILESYSTEM_LIKE_LOGGING || _la==LOGGING || _la==NOLOGGING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TablespaceClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLESPACE() { return GetToken(OracleAntlrParser.TABLESPACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		public TablespaceClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablespaceClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTablespaceClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTablespaceClause(this);
		}
	}

	[RuleVersion(0)]
	public TablespaceClauseContext tablespaceClause() {
		TablespaceClauseContext _localctx = new TablespaceClauseContext(Context, State);
		EnterRule(_localctx, 886, RULE_tablespaceClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4970;
			Match(TABLESPACE);
			State = 4972;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,502,Context) ) {
			case 1:
				{
				State = 4971;
				Match(SET);
				}
				break;
			}
			State = 4976;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEFAULT:
				{
				State = 4974;
				Match(DEFAULT);
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 4975;
				simpleIdentifierWithoutParentheses();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SortNoSortClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOSORT() { return GetToken(OracleAntlrParser.NOSORT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SORT() { return GetToken(OracleAntlrParser.SORT, 0); }
		public SortNoSortClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sortNoSortClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSortNoSortClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSortNoSortClause(this);
		}
	}

	[RuleVersion(0)]
	public SortNoSortClauseContext sortNoSortClause() {
		SortNoSortClauseContext _localctx = new SortNoSortClauseContext(Context, State);
		EnterRule(_localctx, 888, RULE_sortNoSortClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4978;
			_la = TokenStream.LA(1);
			if ( !(_la==NOSORT || _la==SORT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StorageAttributesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORAGE() { return GetToken(OracleAntlrParser.STORAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StorageAttributeClauseContext[] storageAttributeClause() {
			return GetRuleContexts<StorageAttributeClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StorageAttributeClauseContext storageAttributeClause(int i) {
			return GetRuleContext<StorageAttributeClauseContext>(i);
		}
		public StorageAttributesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storageAttributesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterStorageAttributesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitStorageAttributesClause(this);
		}
	}

	[RuleVersion(0)]
	public StorageAttributesClauseContext storageAttributesClause() {
		StorageAttributesClauseContext _localctx = new StorageAttributesClauseContext(Context, State);
		EnterRule(_localctx, 890, RULE_storageAttributesClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4980;
			Match(STORAGE);
			State = 4981;
			Match(LPAREN);
			State = 4983;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 4982;
				storageAttributeClause();
				}
				}
				State = 4985;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==BUFFER_POOL || _la==CELL_FLASH_CACHE || ((((_la - 153)) & ~0x3f) == 0 && ((1L << (_la - 153)) & ((1L << (ENCRYPT - 153)) | (1L << (FLASH_CACHE - 153)) | (1L << (FREELIST - 153)) | (1L << (FREELISTS - 153)))) != 0) || ((((_la - 229)) & ~0x3f) == 0 && ((1L << (_la - 229)) & ((1L << (INITIAL - 229)) | (1L << (MAXEXTENTS - 229)) | (1L << (MAXSIZE - 229)))) != 0) || _la==MINEXTENTS || _la==NEXT || _la==OPTIMAL || _la==PCTINCREASE );
			State = 4987;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StorageAttributeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NextInitialStorageClauseContext nextInitialStorageClause() {
			return GetRuleContext<NextInitialStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MinextentsStorageClauseContext minextentsStorageClause() {
			return GetRuleContext<MinextentsStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PctIncreaseStorageClauseContext pctIncreaseStorageClause() {
			return GetRuleContext<PctIncreaseStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FreeListsStorageClauseContext freeListsStorageClause() {
			return GetRuleContext<FreeListsStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FreeListGroupsStorageClauseContext freeListGroupsStorageClause() {
			return GetRuleContext<FreeListGroupsStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OptimalStorageClauseContext optimalStorageClause() {
			return GetRuleContext<OptimalStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaxextentsStorageClauseContext maxextentsStorageClause() {
			return GetRuleContext<MaxextentsStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BufferPoolStorageClauseContext bufferPoolStorageClause() {
			return GetRuleContext<BufferPoolStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlashCacheStorageClauseContext flashCacheStorageClause() {
			return GetRuleContext<FlashCacheStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CellFlashCacheStorageClauseContext cellFlashCacheStorageClause() {
			return GetRuleContext<CellFlashCacheStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaxSizeClauseContext maxSizeClause() {
			return GetRuleContext<MaxSizeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EncryptClauseContext encryptClause() {
			return GetRuleContext<EncryptClauseContext>(0);
		}
		public StorageAttributeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storageAttributeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterStorageAttributeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitStorageAttributeClause(this);
		}
	}

	[RuleVersion(0)]
	public StorageAttributeClauseContext storageAttributeClause() {
		StorageAttributeClauseContext _localctx = new StorageAttributeClauseContext(Context, State);
		EnterRule(_localctx, 892, RULE_storageAttributeClause);
		try {
			State = 5001;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INITIAL:
			case NEXT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4989;
				nextInitialStorageClause();
				}
				break;
			case MINEXTENTS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4990;
				minextentsStorageClause();
				}
				break;
			case PCTINCREASE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4991;
				pctIncreaseStorageClause();
				}
				break;
			case FREELISTS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4992;
				freeListsStorageClause();
				}
				break;
			case FREELIST:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4993;
				freeListGroupsStorageClause();
				}
				break;
			case OPTIMAL:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4994;
				optimalStorageClause();
				}
				break;
			case MAXEXTENTS:
				EnterOuterAlt(_localctx, 7);
				{
				State = 4995;
				maxextentsStorageClause();
				}
				break;
			case BUFFER_POOL:
				EnterOuterAlt(_localctx, 8);
				{
				State = 4996;
				bufferPoolStorageClause();
				}
				break;
			case FLASH_CACHE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 4997;
				flashCacheStorageClause();
				}
				break;
			case CELL_FLASH_CACHE:
				EnterOuterAlt(_localctx, 10);
				{
				State = 4998;
				cellFlashCacheStorageClause();
				}
				break;
			case MAXSIZE:
				EnterOuterAlt(_localctx, 11);
				{
				State = 4999;
				maxSizeClause();
				}
				break;
			case ENCRYPT:
				EnterOuterAlt(_localctx, 12);
				{
				State = 5000;
				encryptClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaxSizeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXSIZE() { return GetToken(OracleAntlrParser.MAXSIZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNLIMITED() { return GetToken(OracleAntlrParser.UNLIMITED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ByteSizeLiteralContext byteSizeLiteral() {
			return GetRuleContext<ByteSizeLiteralContext>(0);
		}
		public MaxSizeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_maxSizeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaxSizeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaxSizeClause(this);
		}
	}

	[RuleVersion(0)]
	public MaxSizeClauseContext maxSizeClause() {
		MaxSizeClauseContext _localctx = new MaxSizeClauseContext(Context, State);
		EnterRule(_localctx, 894, RULE_maxSizeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5003;
			Match(MAXSIZE);
			State = 5006;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNLIMITED:
				{
				State = 5004;
				Match(UNLIMITED);
				}
				break;
			case INTEGER_LITERAL:
			case BYTE_SIZE_LITERAL:
				{
				State = 5005;
				byteSizeLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EncryptClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENCRYPT() { return GetToken(OracleAntlrParser.ENCRYPT, 0); }
		public EncryptClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_encryptClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterEncryptClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitEncryptClause(this);
		}
	}

	[RuleVersion(0)]
	public EncryptClauseContext encryptClause() {
		EncryptClauseContext _localctx = new EncryptClauseContext(Context, State);
		EnterRule(_localctx, 896, RULE_encryptClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5008;
			Match(ENCRYPT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NextInitialStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ByteSizeLiteralContext byteSizeLiteral() {
			return GetRuleContext<ByteSizeLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INITIAL() { return GetToken(OracleAntlrParser.INITIAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEXT() { return GetToken(OracleAntlrParser.NEXT, 0); }
		public NextInitialStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nextInitialStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNextInitialStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNextInitialStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public NextInitialStorageClauseContext nextInitialStorageClause() {
		NextInitialStorageClauseContext _localctx = new NextInitialStorageClauseContext(Context, State);
		EnterRule(_localctx, 898, RULE_nextInitialStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5010;
			_la = TokenStream.LA(1);
			if ( !(_la==INITIAL || _la==NEXT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5011;
			byteSizeLiteral();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptimalStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTIMAL() { return GetToken(OracleAntlrParser.OPTIMAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ByteSizeLiteralContext byteSizeLiteral() {
			return GetRuleContext<ByteSizeLiteralContext>(0);
		}
		public OptimalStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optimalStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOptimalStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOptimalStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public OptimalStorageClauseContext optimalStorageClause() {
		OptimalStorageClauseContext _localctx = new OptimalStorageClauseContext(Context, State);
		EnterRule(_localctx, 900, RULE_optimalStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5013;
			Match(OPTIMAL);
			State = 5018;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NULL:
				{
				State = 5014;
				Match(NULL);
				}
				break;
			case BUFFER_POOL:
			case CELL_FLASH_CACHE:
			case ENCRYPT:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case INITIAL:
			case MAXEXTENTS:
			case MAXSIZE:
			case MINEXTENTS:
			case NEXT:
			case OPTIMAL:
			case PCTINCREASE:
			case INTEGER_LITERAL:
			case RPAREN:
			case BYTE_SIZE_LITERAL:
				{
				State = 5016;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INTEGER_LITERAL || _la==BYTE_SIZE_LITERAL) {
					{
					State = 5015;
					byteSizeLiteral();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MinextentsStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINEXTENTS() { return GetToken(OracleAntlrParser.MINEXTENTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public MinextentsStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_minextentsStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMinextentsStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMinextentsStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public MinextentsStorageClauseContext minextentsStorageClause() {
		MinextentsStorageClauseContext _localctx = new MinextentsStorageClauseContext(Context, State);
		EnterRule(_localctx, 902, RULE_minextentsStorageClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5020;
			Match(MINEXTENTS);
			State = 5021;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaxextentsStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXEXTENTS() { return GetToken(OracleAntlrParser.MAXEXTENTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNLIMITED() { return GetToken(OracleAntlrParser.UNLIMITED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public MaxextentsStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_maxextentsStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMaxextentsStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMaxextentsStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public MaxextentsStorageClauseContext maxextentsStorageClause() {
		MaxextentsStorageClauseContext _localctx = new MaxextentsStorageClauseContext(Context, State);
		EnterRule(_localctx, 904, RULE_maxextentsStorageClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5023;
			Match(MAXEXTENTS);
			State = 5026;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNLIMITED:
				{
				State = 5024;
				Match(UNLIMITED);
				}
				break;
			case DATE:
			case FALSE:
			case INTERVAL:
			case TIMESTAMP:
			case TRUE:
			case INTEGER_LITERAL:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case QUOTE_CHARACTER_STRING_LITERAL:
				{
				State = 5025;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PctIncreaseStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTINCREASE() { return GetToken(OracleAntlrParser.PCTINCREASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public PctIncreaseStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pctIncreaseStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPctIncreaseStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPctIncreaseStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public PctIncreaseStorageClauseContext pctIncreaseStorageClause() {
		PctIncreaseStorageClauseContext _localctx = new PctIncreaseStorageClauseContext(Context, State);
		EnterRule(_localctx, 906, RULE_pctIncreaseStorageClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5028;
			Match(PCTINCREASE);
			State = 5029;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FreeListsStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FREELISTS() { return GetToken(OracleAntlrParser.FREELISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public FreeListsStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_freeListsStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFreeListsStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFreeListsStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public FreeListsStorageClauseContext freeListsStorageClause() {
		FreeListsStorageClauseContext _localctx = new FreeListsStorageClauseContext(Context, State);
		EnterRule(_localctx, 908, RULE_freeListsStorageClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5031;
			Match(FREELISTS);
			State = 5032;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FreeListGroupsStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FREELIST() { return GetToken(OracleAntlrParser.FREELIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUPS() { return GetToken(OracleAntlrParser.GROUPS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public FreeListGroupsStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_freeListGroupsStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFreeListGroupsStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFreeListGroupsStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public FreeListGroupsStorageClauseContext freeListGroupsStorageClause() {
		FreeListGroupsStorageClauseContext _localctx = new FreeListGroupsStorageClauseContext(Context, State);
		EnterRule(_localctx, 910, RULE_freeListGroupsStorageClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5034;
			Match(FREELIST);
			State = 5035;
			Match(GROUPS);
			State = 5036;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BufferPoolStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUFFER_POOL() { return GetToken(OracleAntlrParser.BUFFER_POOL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RECYCLE() { return GetToken(OracleAntlrParser.RECYCLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		public BufferPoolStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bufferPoolStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBufferPoolStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBufferPoolStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public BufferPoolStorageClauseContext bufferPoolStorageClause() {
		BufferPoolStorageClauseContext _localctx = new BufferPoolStorageClauseContext(Context, State);
		EnterRule(_localctx, 912, RULE_bufferPoolStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5038;
			Match(BUFFER_POOL);
			State = 5039;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFAULT || _la==KEEP || _la==RECYCLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlashCacheStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLASH_CACHE() { return GetToken(OracleAntlrParser.FLASH_CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(OracleAntlrParser.NONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		public FlashCacheStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flashCacheStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFlashCacheStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFlashCacheStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public FlashCacheStorageClauseContext flashCacheStorageClause() {
		FlashCacheStorageClauseContext _localctx = new FlashCacheStorageClauseContext(Context, State);
		EnterRule(_localctx, 914, RULE_flashCacheStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5041;
			Match(FLASH_CACHE);
			State = 5042;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFAULT || _la==KEEP || _la==NONE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CellFlashCacheStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CELL_FLASH_CACHE() { return GetToken(OracleAntlrParser.CELL_FLASH_CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(OracleAntlrParser.NONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		public CellFlashCacheStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cellFlashCacheStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCellFlashCacheStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCellFlashCacheStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public CellFlashCacheStorageClauseContext cellFlashCacheStorageClause() {
		CellFlashCacheStorageClauseContext _localctx = new CellFlashCacheStorageClauseContext(Context, State);
		EnterRule(_localctx, 916, RULE_cellFlashCacheStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5044;
			Match(CELL_FLASH_CACHE);
			State = 5045;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFAULT || _la==KEEP || _la==NONE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComputeStatisticsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPUTE() { return GetToken(OracleAntlrParser.COMPUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATISTICS() { return GetToken(OracleAntlrParser.STATISTICS, 0); }
		public ComputeStatisticsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_computeStatisticsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterComputeStatisticsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitComputeStatisticsClause(this);
		}
	}

	[RuleVersion(0)]
	public ComputeStatisticsClauseContext computeStatisticsClause() {
		ComputeStatisticsClauseContext _localctx = new ComputeStatisticsClauseContext(Context, State);
		EnterRule(_localctx, 918, RULE_computeStatisticsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5047;
			Match(COMPUTE);
			State = 5048;
			Match(STATISTICS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ValidateClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALIDATE() { return GetToken(OracleAntlrParser.VALIDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOVALIDATE() { return GetToken(OracleAntlrParser.NOVALIDATE, 0); }
		public ValidateClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_validateClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterValidateClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitValidateClause(this);
		}
	}

	[RuleVersion(0)]
	public ValidateClauseContext validateClause() {
		ValidateClauseContext _localctx = new ValidateClauseContext(Context, State);
		EnterRule(_localctx, 920, RULE_validateClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5050;
			_la = TokenStream.LA(1);
			if ( !(_la==NOVALIDATE || _la==VALIDATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExceptionsIntoConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPTIONS() { return GetToken(OracleAntlrParser.EXCEPTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public ExceptionsIntoConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exceptionsIntoConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExceptionsIntoConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExceptionsIntoConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public ExceptionsIntoConstraintClauseContext exceptionsIntoConstraintClause() {
		ExceptionsIntoConstraintClauseContext _localctx = new ExceptionsIntoConstraintClauseContext(Context, State);
		EnterRule(_localctx, 922, RULE_exceptionsIntoConstraintClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5052;
			Match(EXCEPTIONS);
			State = 5053;
			Match(INTO);
			State = 5054;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ByteSizeLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BYTE_SIZE_LITERAL() { return GetToken(OracleAntlrParser.BYTE_SIZE_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		public ByteSizeLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_byteSizeLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterByteSizeLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitByteSizeLiteral(this);
		}
	}

	[RuleVersion(0)]
	public ByteSizeLiteralContext byteSizeLiteral() {
		ByteSizeLiteralContext _localctx = new ByteSizeLiteralContext(Context, State);
		EnterRule(_localctx, 924, RULE_byteSizeLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5056;
			_la = TokenStream.LA(1);
			if ( !(_la==INTEGER_LITERAL || _la==BYTE_SIZE_LITERAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintNameClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINT() { return GetToken(OracleAntlrParser.CONSTRAINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		public ConstraintNameClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintNameClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConstraintNameClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConstraintNameClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintNameClauseContext constraintNameClause() {
		ConstraintNameClauseContext _localctx = new ConstraintNameClauseContext(Context, State);
		EnterRule(_localctx, 926, RULE_constraintNameClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5058;
			Match(CONSTRAINT);
			State = 5059;
			simpleIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintNullNotNullClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public ConstraintNullNotNullClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintNullNotNullClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConstraintNullNotNullClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConstraintNullNotNullClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintNullNotNullClauseContext constraintNullNotNullClause() {
		ConstraintNullNotNullClauseContext _localctx = new ConstraintNullNotNullClauseContext(Context, State);
		EnterRule(_localctx, 928, RULE_constraintNullNotNullClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5062;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 5061;
				Match(NOT);
				}
			}

			State = 5064;
			Match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintUniqueClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUE() { return GetToken(OracleAntlrParser.UNIQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public ConstraintUniqueClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintUniqueClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConstraintUniqueClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConstraintUniqueClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintUniqueClauseContext constraintUniqueClause() {
		ConstraintUniqueClauseContext _localctx = new ConstraintUniqueClauseContext(Context, State);
		EnterRule(_localctx, 930, RULE_constraintUniqueClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5066;
			Match(UNIQUE);
			State = 5068;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,511,Context) ) {
			case 1:
				{
				State = 5067;
				columnListInParenElementClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintPrimaryKeyClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIMARY() { return GetToken(OracleAntlrParser.PRIMARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(OracleAntlrParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public ConstraintPrimaryKeyClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintPrimaryKeyClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConstraintPrimaryKeyClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConstraintPrimaryKeyClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintPrimaryKeyClauseContext constraintPrimaryKeyClause() {
		ConstraintPrimaryKeyClauseContext _localctx = new ConstraintPrimaryKeyClauseContext(Context, State);
		EnterRule(_localctx, 932, RULE_constraintPrimaryKeyClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5070;
			Match(PRIMARY);
			State = 5071;
			Match(KEY);
			State = 5073;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,512,Context) ) {
			case 1:
				{
				State = 5072;
				columnListInParenElementClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintCheckClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHECK() { return GetToken(OracleAntlrParser.CHECK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConditionInParensContext conditionInParens() {
			return GetRuleContext<ConditionInParensContext>(0);
		}
		public ConstraintCheckClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintCheckClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConstraintCheckClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConstraintCheckClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintCheckClauseContext constraintCheckClause() {
		ConstraintCheckClauseContext _localctx = new ConstraintCheckClauseContext(Context, State);
		EnterRule(_localctx, 934, RULE_constraintCheckClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5075;
			Match(CHECK);
			State = 5076;
			conditionInParens();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionInParensContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public ConditionInParensContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionInParens; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConditionInParens(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConditionInParens(this);
		}
	}

	[RuleVersion(0)]
	public ConditionInParensContext conditionInParens() {
		ConditionInParensContext _localctx = new ConditionInParensContext(Context, State);
		EnterRule(_localctx, 936, RULE_conditionInParens);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5078;
			Match(LPAREN);
			State = 5079;
			fullExpression();
			State = 5080;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintForeignKeyClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintForeignKeyRefClauseContext constraintForeignKeyRefClause() {
			return GetRuleContext<ConstraintForeignKeyRefClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOREIGN() { return GetToken(OracleAntlrParser.FOREIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(OracleAntlrParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnDeleteActionClauseContext onDeleteActionClause() {
			return GetRuleContext<OnDeleteActionClauseContext>(0);
		}
		public ConstraintForeignKeyClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintForeignKeyClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConstraintForeignKeyClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConstraintForeignKeyClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintForeignKeyClauseContext constraintForeignKeyClause() {
		ConstraintForeignKeyClauseContext _localctx = new ConstraintForeignKeyClauseContext(Context, State);
		EnterRule(_localctx, 938, RULE_constraintForeignKeyClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5084;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOREIGN) {
				{
				State = 5082;
				Match(FOREIGN);
				State = 5083;
				Match(KEY);
				}
			}

			State = 5087;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 5086;
				columnListInParenElementClause();
				}
			}

			State = 5089;
			constraintForeignKeyRefClause();
			State = 5091;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 5090;
				onDeleteActionClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintForeignKeyRefClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFERENCES() { return GetToken(OracleAntlrParser.REFERENCES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public ConstraintForeignKeyRefClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintForeignKeyRefClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConstraintForeignKeyRefClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConstraintForeignKeyRefClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintForeignKeyRefClauseContext constraintForeignKeyRefClause() {
		ConstraintForeignKeyRefClauseContext _localctx = new ConstraintForeignKeyRefClauseContext(Context, State);
		EnterRule(_localctx, 940, RULE_constraintForeignKeyRefClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5093;
			Match(REFERENCES);
			State = 5094;
			plainIdentifier();
			State = 5096;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,516,Context) ) {
			case 1:
				{
				State = 5095;
				columnListInParenElementClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnDeleteActionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(OracleAntlrParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASCADE() { return GetToken(OracleAntlrParser.CASCADE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public OnDeleteActionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onDeleteActionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOnDeleteActionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOnDeleteActionClause(this);
		}
	}

	[RuleVersion(0)]
	public OnDeleteActionClauseContext onDeleteActionClause() {
		OnDeleteActionClauseContext _localctx = new OnDeleteActionClauseContext(Context, State);
		EnterRule(_localctx, 942, RULE_onDeleteActionClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5098;
			Match(ON);
			State = 5099;
			Match(DELETE);
			State = 5103;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CASCADE:
				{
				State = 5100;
				Match(CASCADE);
				}
				break;
			case SET:
				{
				State = 5101;
				Match(SET);
				State = 5102;
				Match(NULL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TriggerStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIGGER() { return GetToken(OracleAntlrParser.TRIGGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleDmlTriggerContext simpleDmlTrigger() {
			return GetRuleContext<SimpleDmlTriggerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsteadOfDmlTriggerContext insteadOfDmlTrigger() {
			return GetRuleContext<InsteadOfDmlTriggerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompoundDmlTriggerContext compoundDmlTrigger() {
			return GetRuleContext<CompoundDmlTriggerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SystemTriggerContext systemTrigger() {
			return GetRuleContext<SystemTriggerContext>(0);
		}
		public TriggerStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_triggerStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTriggerStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTriggerStatement(this);
		}
	}

	[RuleVersion(0)]
	public TriggerStatementContext triggerStatement() {
		TriggerStatementContext _localctx = new TriggerStatementContext(Context, State);
		EnterRule(_localctx, 944, RULE_triggerStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5105;
			Match(TRIGGER);
			State = 5106;
			plainIdentifier();
			State = 5111;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,518,Context) ) {
			case 1:
				{
				State = 5107;
				simpleDmlTrigger();
				}
				break;
			case 2:
				{
				State = 5108;
				insteadOfDmlTrigger();
				}
				break;
			case 3:
				{
				State = 5109;
				compoundDmlTrigger();
				}
				break;
			case 4:
				{
				State = 5110;
				systemTrigger();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleDmlTriggerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TriggerCallTypeClauseContext triggerCallTypeClause() {
			return GetRuleContext<TriggerCallTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DmlTriggerEventClauseContext dmlTriggerEventClause() {
			return GetRuleContext<DmlTriggerEventClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CallStatementContext callStatement() {
			return GetRuleContext<CallStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockStatementContext blockStatement() {
			return GetRuleContext<BlockStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateTriggerWhenClauseContext createTriggerWhenClause() {
			return GetRuleContext<CreateTriggerWhenClauseContext>(0);
		}
		public SimpleDmlTriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleDmlTrigger; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSimpleDmlTrigger(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSimpleDmlTrigger(this);
		}
	}

	[RuleVersion(0)]
	public SimpleDmlTriggerContext simpleDmlTrigger() {
		SimpleDmlTriggerContext _localctx = new SimpleDmlTriggerContext(Context, State);
		EnterRule(_localctx, 946, RULE_simpleDmlTrigger);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5113;
			triggerCallTypeClause();
			State = 5114;
			dmlTriggerEventClause();
			State = 5116;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,519,Context) ) {
			case 1:
				{
				State = 5115;
				createTriggerWhenClause();
				}
				break;
			}
			State = 5120;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,520,Context) ) {
			case 1:
				{
				State = 5118;
				callStatement();
				}
				break;
			case 2:
				{
				State = 5119;
				blockStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsteadOfDmlTriggerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TriggerCallTypeClauseContext triggerCallTypeClause() {
			return GetRuleContext<TriggerCallTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DmlTriggerEventClauseContext dmlTriggerEventClause() {
			return GetRuleContext<DmlTriggerEventClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CallStatementContext callStatement() {
			return GetRuleContext<CallStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockStatementContext blockStatement() {
			return GetRuleContext<BlockStatementContext>(0);
		}
		public InsteadOfDmlTriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insteadOfDmlTrigger; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterInsteadOfDmlTrigger(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitInsteadOfDmlTrigger(this);
		}
	}

	[RuleVersion(0)]
	public InsteadOfDmlTriggerContext insteadOfDmlTrigger() {
		InsteadOfDmlTriggerContext _localctx = new InsteadOfDmlTriggerContext(Context, State);
		EnterRule(_localctx, 948, RULE_insteadOfDmlTrigger);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5122;
			triggerCallTypeClause();
			State = 5123;
			dmlTriggerEventClause();
			State = 5126;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,521,Context) ) {
			case 1:
				{
				State = 5124;
				callStatement();
				}
				break;
			case 2:
				{
				State = 5125;
				blockStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompoundDmlTriggerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TriggerCallTypeClauseContext triggerCallTypeClause() {
			return GetRuleContext<TriggerCallTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DmlTriggerEventClauseContext dmlTriggerEventClause() {
			return GetRuleContext<DmlTriggerEventClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompoundTriggerBlockContext compoundTriggerBlock() {
			return GetRuleContext<CompoundTriggerBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateTriggerWhenClauseContext createTriggerWhenClause() {
			return GetRuleContext<CreateTriggerWhenClauseContext>(0);
		}
		public CompoundDmlTriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compoundDmlTrigger; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCompoundDmlTrigger(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCompoundDmlTrigger(this);
		}
	}

	[RuleVersion(0)]
	public CompoundDmlTriggerContext compoundDmlTrigger() {
		CompoundDmlTriggerContext _localctx = new CompoundDmlTriggerContext(Context, State);
		EnterRule(_localctx, 950, RULE_compoundDmlTrigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5128;
			triggerCallTypeClause();
			State = 5129;
			dmlTriggerEventClause();
			State = 5131;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHEN) {
				{
				State = 5130;
				createTriggerWhenClause();
				}
			}

			State = 5133;
			compoundTriggerBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SystemTriggerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TriggerCallTypeClauseContext triggerCallTypeClause() {
			return GetRuleContext<TriggerCallTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TriggerStatementOnClauseContext triggerStatementOnClause() {
			return GetRuleContext<TriggerStatementOnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DdlEventsListClauseContext ddlEventsListClause() {
			return GetRuleContext<DdlEventsListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DatabaseEventsListClauseContext databaseEventsListClause() {
			return GetRuleContext<DatabaseEventsListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CallStatementContext callStatement() {
			return GetRuleContext<CallStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockStatementContext blockStatement() {
			return GetRuleContext<BlockStatementContext>(0);
		}
		public SystemTriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_systemTrigger; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSystemTrigger(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSystemTrigger(this);
		}
	}

	[RuleVersion(0)]
	public SystemTriggerContext systemTrigger() {
		SystemTriggerContext _localctx = new SystemTriggerContext(Context, State);
		EnterRule(_localctx, 952, RULE_systemTrigger);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5135;
			triggerCallTypeClause();
			State = 5138;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALTER:
			case ANALYZE:
			case ASSOCIATE:
			case AUDIT:
			case COMMENT:
			case CREATE:
			case DDL:
			case DISASSOCIATE:
			case DROP:
			case GRANT:
			case NOAUDIT:
			case RENAME:
			case REVOKE:
			case TRUNCATE:
				{
				State = 5136;
				ddlEventsListClause();
				}
				break;
			case LOGOFF:
			case LOGON:
			case SERVERERROR:
			case SHUTDOWN:
			case STARTUP:
			case SUSPEND:
				{
				State = 5137;
				databaseEventsListClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5140;
			triggerStatementOnClause();
			State = 5143;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,524,Context) ) {
			case 1:
				{
				State = 5141;
				callStatement();
				}
				break;
			case 2:
				{
				State = 5142;
				blockStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompoundTriggerBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPOUND() { return GetToken(OracleAntlrParser.COMPOUND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIGGER() { return GetToken(OracleAntlrParser.TRIGGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndClauseContext endClause() {
			return GetRuleContext<EndClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockContext declarationBlock() {
			return GetRuleContext<DeclarationBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TimingPointSectionContext[] timingPointSection() {
			return GetRuleContexts<TimingPointSectionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TimingPointSectionContext timingPointSection(int i) {
			return GetRuleContext<TimingPointSectionContext>(i);
		}
		public CompoundTriggerBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compoundTriggerBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCompoundTriggerBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCompoundTriggerBlock(this);
		}
	}

	[RuleVersion(0)]
	public CompoundTriggerBlockContext compoundTriggerBlock() {
		CompoundTriggerBlockContext _localctx = new CompoundTriggerBlockContext(Context, State);
		EnterRule(_localctx, 954, RULE_compoundTriggerBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5145;
			Match(COMPOUND);
			State = 5146;
			Match(TRIGGER);
			State = 5148;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,525,Context) ) {
			case 1:
				{
				State = 5147;
				declarationBlock();
				}
				break;
			}
			State = 5151;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 5150;
				timingPointSection();
				}
				}
				State = 5153;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==AFTER || _la==BEFORE || _la==INSTEAD );
			State = 5155;
			endClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimingPointSectionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TimingPointContext[] timingPoint() {
			return GetRuleContexts<TimingPointContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TimingPointContext timingPoint(int i) {
			return GetRuleContext<TimingPointContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockBodyContext blockBody() {
			return GetRuleContext<BlockBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI() { return GetToken(OracleAntlrParser.SEMI, 0); }
		public TimingPointSectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timingPointSection; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTimingPointSection(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTimingPointSection(this);
		}
	}

	[RuleVersion(0)]
	public TimingPointSectionContext timingPointSection() {
		TimingPointSectionContext _localctx = new TimingPointSectionContext(Context, State);
		EnterRule(_localctx, 956, RULE_timingPointSection);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5157;
			timingPoint();
			State = 5158;
			Match(IS);
			State = 5159;
			blockBody();
			State = 5160;
			timingPoint();
			State = 5161;
			Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimingPointContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATEMENT() { return GetToken(OracleAntlrParser.STATEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEFORE() { return GetToken(OracleAntlrParser.BEFORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AFTER() { return GetToken(OracleAntlrParser.AFTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EACH() { return GetToken(OracleAntlrParser.EACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSTEAD() { return GetToken(OracleAntlrParser.INSTEAD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		public TimingPointContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timingPoint; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTimingPoint(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTimingPoint(this);
		}
	}

	[RuleVersion(0)]
	public TimingPointContext timingPoint() {
		TimingPointContext _localctx = new TimingPointContext(Context, State);
		EnterRule(_localctx, 958, RULE_timingPoint);
		int _la;
		try {
			State = 5173;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,528,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 5163;
				_la = TokenStream.LA(1);
				if ( !(_la==AFTER || _la==BEFORE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5164;
				Match(STATEMENT);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 5169;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case BEFORE:
					{
					State = 5165;
					Match(BEFORE);
					}
					break;
				case AFTER:
					{
					State = 5166;
					Match(AFTER);
					}
					break;
				case INSTEAD:
					{
					State = 5167;
					Match(INSTEAD);
					State = 5168;
					Match(OF);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5171;
				Match(EACH);
				State = 5172;
				Match(ROW);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CALL() { return GetToken(OracleAntlrParser.CALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CallIntoClauseContext callIntoClause() {
			return GetRuleContext<CallIntoClauseContext>(0);
		}
		public CallStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCallStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCallStatement(this);
		}
	}

	[RuleVersion(0)]
	public CallStatementContext callStatement() {
		CallStatementContext _localctx = new CallStatementContext(Context, State);
		EnterRule(_localctx, 960, RULE_callStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5175;
			Match(CALL);
			State = 5176;
			identifier();
			State = 5178;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTO) {
				{
				State = 5177;
				callIntoClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallStatementWithExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(OracleAntlrParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public CallStatementWithExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callStatementWithExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCallStatementWithExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCallStatementWithExpression(this);
		}
	}

	[RuleVersion(0)]
	public CallStatementWithExpressionContext callStatementWithExpression() {
		CallStatementWithExpressionContext _localctx = new CallStatementWithExpressionContext(Context, State);
		EnterRule(_localctx, 962, RULE_callStatementWithExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5180;
			fullExpression();
			State = 5181;
			Match(DOT);
			State = 5182;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallIntoClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndicatorClauseContext indicatorClause() {
			return GetRuleContext<IndicatorClauseContext>(0);
		}
		public CallIntoClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callIntoClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCallIntoClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCallIntoClause(this);
		}
	}

	[RuleVersion(0)]
	public CallIntoClauseContext callIntoClause() {
		CallIntoClauseContext _localctx = new CallIntoClauseContext(Context, State);
		EnterRule(_localctx, 964, RULE_callIntoClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5184;
			Match(INTO);
			State = 5185;
			simpleIdentifier();
			State = 5187;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 5186;
				indicatorClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndicatorClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDICATOR() { return GetToken(OracleAntlrParser.INDICATOR, 0); }
		public IndicatorClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indicatorClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndicatorClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndicatorClause(this);
		}
	}

	[RuleVersion(0)]
	public IndicatorClauseContext indicatorClause() {
		IndicatorClauseContext _localctx = new IndicatorClauseContext(Context, State);
		EnterRule(_localctx, 966, RULE_indicatorClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5190;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,531,Context) ) {
			case 1:
				{
				State = 5189;
				Match(INDICATOR);
				}
				break;
			}
			State = 5192;
			simpleIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTriggerWhenClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConditionInParensContext conditionInParens() {
			return GetRuleContext<ConditionInParensContext>(0);
		}
		public CreateTriggerWhenClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTriggerWhenClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateTriggerWhenClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateTriggerWhenClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateTriggerWhenClauseContext createTriggerWhenClause() {
		CreateTriggerWhenClauseContext _localctx = new CreateTriggerWhenClauseContext(Context, State);
		EnterRule(_localctx, 968, RULE_createTriggerWhenClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5194;
			Match(WHEN);
			State = 5195;
			conditionInParens();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TriggerStatementOnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCHEMA() { return GetToken(OracleAntlrParser.SCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(OracleAntlrParser.DATABASE, 0); }
		public TriggerStatementOnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_triggerStatementOnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTriggerStatementOnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTriggerStatementOnClause(this);
		}
	}

	[RuleVersion(0)]
	public TriggerStatementOnClauseContext triggerStatementOnClause() {
		TriggerStatementOnClauseContext _localctx = new TriggerStatementOnClauseContext(Context, State);
		EnterRule(_localctx, 970, RULE_triggerStatementOnClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5197;
			Match(ON);
			State = 5198;
			_la = TokenStream.LA(1);
			if ( !(_la==DATABASE || _la==SCHEMA) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DdlEventsListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DdlEventContext[] ddlEvent() {
			return GetRuleContexts<DdlEventContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DdlEventContext ddlEvent(int i) {
			return GetRuleContext<DdlEventContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] OR() { return GetTokens(OracleAntlrParser.OR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR(int i) {
			return GetToken(OracleAntlrParser.OR, i);
		}
		public DdlEventsListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ddlEventsListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDdlEventsListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDdlEventsListClause(this);
		}
	}

	[RuleVersion(0)]
	public DdlEventsListClauseContext ddlEventsListClause() {
		DdlEventsListClauseContext _localctx = new DdlEventsListClauseContext(Context, State);
		EnterRule(_localctx, 972, RULE_ddlEventsListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5200;
			ddlEvent();
			State = 5205;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR) {
				{
				{
				State = 5201;
				Match(OR);
				State = 5202;
				ddlEvent();
				}
				}
				State = 5207;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DatabaseEventsListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DatabaseEventContext[] databaseEvent() {
			return GetRuleContexts<DatabaseEventContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DatabaseEventContext databaseEvent(int i) {
			return GetRuleContext<DatabaseEventContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] OR() { return GetTokens(OracleAntlrParser.OR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR(int i) {
			return GetToken(OracleAntlrParser.OR, i);
		}
		public DatabaseEventsListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_databaseEventsListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDatabaseEventsListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDatabaseEventsListClause(this);
		}
	}

	[RuleVersion(0)]
	public DatabaseEventsListClauseContext databaseEventsListClause() {
		DatabaseEventsListClauseContext _localctx = new DatabaseEventsListClauseContext(Context, State);
		EnterRule(_localctx, 974, RULE_databaseEventsListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5208;
			databaseEvent();
			State = 5213;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR) {
				{
				{
				State = 5209;
				Match(OR);
				State = 5210;
				databaseEvent();
				}
				}
				State = 5215;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DdlEventContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALTER() { return GetToken(OracleAntlrParser.ALTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANALYZE() { return GetToken(OracleAntlrParser.ANALYZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSOCIATE() { return GetToken(OracleAntlrParser.ASSOCIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATISTICS() { return GetToken(OracleAntlrParser.STATISTICS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUDIT() { return GetToken(OracleAntlrParser.AUDIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMENT() { return GetToken(OracleAntlrParser.COMMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATE() { return GetToken(OracleAntlrParser.CREATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISASSOCIATE() { return GetToken(OracleAntlrParser.DISASSOCIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(OracleAntlrParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRANT() { return GetToken(OracleAntlrParser.GRANT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOAUDIT() { return GetToken(OracleAntlrParser.NOAUDIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RENAME() { return GetToken(OracleAntlrParser.RENAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REVOKE() { return GetToken(OracleAntlrParser.REVOKE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUNCATE() { return GetToken(OracleAntlrParser.TRUNCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DDL() { return GetToken(OracleAntlrParser.DDL, 0); }
		public DdlEventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ddlEvent; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDdlEvent(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDdlEvent(this);
		}
	}

	[RuleVersion(0)]
	public DdlEventContext ddlEvent() {
		DdlEventContext _localctx = new DdlEventContext(Context, State);
		EnterRule(_localctx, 976, RULE_ddlEvent);
		try {
			State = 5232;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALTER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5216;
				Match(ALTER);
				}
				break;
			case ANALYZE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5217;
				Match(ANALYZE);
				}
				break;
			case ASSOCIATE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5218;
				Match(ASSOCIATE);
				State = 5219;
				Match(STATISTICS);
				}
				break;
			case AUDIT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5220;
				Match(AUDIT);
				}
				break;
			case COMMENT:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5221;
				Match(COMMENT);
				}
				break;
			case CREATE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5222;
				Match(CREATE);
				}
				break;
			case DISASSOCIATE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5223;
				Match(DISASSOCIATE);
				State = 5224;
				Match(STATISTICS);
				}
				break;
			case DROP:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5225;
				Match(DROP);
				}
				break;
			case GRANT:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5226;
				Match(GRANT);
				}
				break;
			case NOAUDIT:
				EnterOuterAlt(_localctx, 10);
				{
				State = 5227;
				Match(NOAUDIT);
				}
				break;
			case RENAME:
				EnterOuterAlt(_localctx, 11);
				{
				State = 5228;
				Match(RENAME);
				}
				break;
			case REVOKE:
				EnterOuterAlt(_localctx, 12);
				{
				State = 5229;
				Match(REVOKE);
				}
				break;
			case TRUNCATE:
				EnterOuterAlt(_localctx, 13);
				{
				State = 5230;
				Match(TRUNCATE);
				}
				break;
			case DDL:
				EnterOuterAlt(_localctx, 14);
				{
				State = 5231;
				Match(DDL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DatabaseEventContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVERERROR() { return GetToken(OracleAntlrParser.SERVERERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOGON() { return GetToken(OracleAntlrParser.LOGON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOGOFF() { return GetToken(OracleAntlrParser.LOGOFF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STARTUP() { return GetToken(OracleAntlrParser.STARTUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHUTDOWN() { return GetToken(OracleAntlrParser.SHUTDOWN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUSPEND() { return GetToken(OracleAntlrParser.SUSPEND, 0); }
		public DatabaseEventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_databaseEvent; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDatabaseEvent(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDatabaseEvent(this);
		}
	}

	[RuleVersion(0)]
	public DatabaseEventContext databaseEvent() {
		DatabaseEventContext _localctx = new DatabaseEventContext(Context, State);
		EnterRule(_localctx, 978, RULE_databaseEvent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5234;
			_la = TokenStream.LA(1);
			if ( !(_la==LOGOFF || _la==LOGON || ((((_la - 467)) & ~0x3f) == 0 && ((1L << (_la - 467)) & ((1L << (SERVERERROR - 467)) | (1L << (SHUTDOWN - 467)) | (1L << (STARTUP - 467)) | (1L << (SUSPEND - 467)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TriggerCallTypeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEFORE() { return GetToken(OracleAntlrParser.BEFORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AFTER() { return GetToken(OracleAntlrParser.AFTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSTEAD() { return GetToken(OracleAntlrParser.INSTEAD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		public TriggerCallTypeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_triggerCallTypeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTriggerCallTypeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTriggerCallTypeClause(this);
		}
	}

	[RuleVersion(0)]
	public TriggerCallTypeClauseContext triggerCallTypeClause() {
		TriggerCallTypeClauseContext _localctx = new TriggerCallTypeClauseContext(Context, State);
		EnterRule(_localctx, 980, RULE_triggerCallTypeClause);
		try {
			State = 5241;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BEFORE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5236;
				Match(BEFORE);
				}
				break;
			case AFTER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5237;
				Match(AFTER);
				}
				break;
			case INSTEAD:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5238;
				Match(INSTEAD);
				State = 5239;
				Match(OF);
				}
				break;
			case FOR:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5240;
				Match(FOR);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DmlTriggerEventClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DmlTriggerEventsListContext dmlTriggerEventsList() {
			return GetRuleContext<DmlTriggerEventsListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DmlTriggerEventOnClauseContext dmlTriggerEventOnClause() {
			return GetRuleContext<DmlTriggerEventOnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReferencingClauseContext referencingClause() {
			return GetRuleContext<ReferencingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForEachRowClauseContext forEachRowClause() {
			return GetRuleContext<ForEachRowClauseContext>(0);
		}
		public DmlTriggerEventClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dmlTriggerEventClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDmlTriggerEventClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDmlTriggerEventClause(this);
		}
	}

	[RuleVersion(0)]
	public DmlTriggerEventClauseContext dmlTriggerEventClause() {
		DmlTriggerEventClauseContext _localctx = new DmlTriggerEventClauseContext(Context, State);
		EnterRule(_localctx, 982, RULE_dmlTriggerEventClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5243;
			dmlTriggerEventsList();
			State = 5244;
			dmlTriggerEventOnClause();
			State = 5246;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,536,Context) ) {
			case 1:
				{
				State = 5245;
				referencingClause();
				}
				break;
			}
			State = 5249;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 5248;
				forEachRowClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DmlTriggerEventsListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DmlTriggerEventContext[] dmlTriggerEvent() {
			return GetRuleContexts<DmlTriggerEventContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DmlTriggerEventContext dmlTriggerEvent(int i) {
			return GetRuleContext<DmlTriggerEventContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] OR() { return GetTokens(OracleAntlrParser.OR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR(int i) {
			return GetToken(OracleAntlrParser.OR, i);
		}
		public DmlTriggerEventsListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dmlTriggerEventsList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDmlTriggerEventsList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDmlTriggerEventsList(this);
		}
	}

	[RuleVersion(0)]
	public DmlTriggerEventsListContext dmlTriggerEventsList() {
		DmlTriggerEventsListContext _localctx = new DmlTriggerEventsListContext(Context, State);
		EnterRule(_localctx, 984, RULE_dmlTriggerEventsList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5251;
			dmlTriggerEvent();
			State = 5256;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR) {
				{
				{
				State = 5252;
				Match(OR);
				State = 5253;
				dmlTriggerEvent();
				}
				}
				State = 5258;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DmlTriggerEventContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSERT() { return GetToken(OracleAntlrParser.INSERT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(OracleAntlrParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UPDATE() { return GetToken(OracleAntlrParser.UPDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OfColumnListClauseContext ofColumnListClause() {
			return GetRuleContext<OfColumnListClauseContext>(0);
		}
		public DmlTriggerEventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dmlTriggerEvent; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDmlTriggerEvent(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDmlTriggerEvent(this);
		}
	}

	[RuleVersion(0)]
	public DmlTriggerEventContext dmlTriggerEvent() {
		DmlTriggerEventContext _localctx = new DmlTriggerEventContext(Context, State);
		EnterRule(_localctx, 986, RULE_dmlTriggerEvent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5259;
			_la = TokenStream.LA(1);
			if ( !(_la==DELETE || _la==INSERT || _la==UPDATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5261;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OF) {
				{
				State = 5260;
				ofColumnListClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OfColumnListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListElementClauseContext columnListElementClause() {
			return GetRuleContext<ColumnListElementClauseContext>(0);
		}
		public OfColumnListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ofColumnListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOfColumnListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOfColumnListClause(this);
		}
	}

	[RuleVersion(0)]
	public OfColumnListClauseContext ofColumnListClause() {
		OfColumnListClauseContext _localctx = new OfColumnListClauseContext(Context, State);
		EnterRule(_localctx, 988, RULE_ofColumnListClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5263;
			Match(OF);
			State = 5264;
			columnListElementClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DmlTriggerEventOnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NestedTableClauseContext nestedTableClause() {
			return GetRuleContext<NestedTableClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public DmlTriggerEventOnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dmlTriggerEventOnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDmlTriggerEventOnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDmlTriggerEventOnClause(this);
		}
	}

	[RuleVersion(0)]
	public DmlTriggerEventOnClauseContext dmlTriggerEventOnClause() {
		DmlTriggerEventOnClauseContext _localctx = new DmlTriggerEventOnClauseContext(Context, State);
		EnterRule(_localctx, 990, RULE_dmlTriggerEventOnClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5266;
			Match(ON);
			State = 5271;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,540,Context) ) {
			case 1:
				{
				State = 5267;
				nestedTableClause();
				State = 5268;
				plainIdentifier();
				}
				break;
			case 2:
				{
				State = 5270;
				plainIdentifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NestedTableClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NESTED() { return GetToken(OracleAntlrParser.NESTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		public NestedTableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nestedTableClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNestedTableClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNestedTableClause(this);
		}
	}

	[RuleVersion(0)]
	public NestedTableClauseContext nestedTableClause() {
		NestedTableClauseContext _localctx = new NestedTableClauseContext(Context, State);
		EnterRule(_localctx, 992, RULE_nestedTableClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5273;
			Match(NESTED);
			State = 5274;
			Match(TABLE);
			State = 5275;
			simpleIdentifierWithoutParentheses();
			State = 5276;
			Match(OF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReferencingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFERENCING() { return GetToken(OracleAntlrParser.REFERENCING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ReferencingItemContext[] referencingItem() {
			return GetRuleContexts<ReferencingItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReferencingItemContext referencingItem(int i) {
			return GetRuleContext<ReferencingItemContext>(i);
		}
		public ReferencingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referencingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterReferencingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitReferencingClause(this);
		}
	}

	[RuleVersion(0)]
	public ReferencingClauseContext referencingClause() {
		ReferencingClauseContext _localctx = new ReferencingClauseContext(Context, State);
		EnterRule(_localctx, 994, RULE_referencingClause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5278;
			Match(REFERENCING);
			State = 5280;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 5279;
					referencingItem();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5282;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,541,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReferencingItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(OracleAntlrParser.NEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OLD() { return GetToken(OracleAntlrParser.OLD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARENT() { return GetToken(OracleAntlrParser.PARENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		public ReferencingItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referencingItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterReferencingItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitReferencingItem(this);
		}
	}

	[RuleVersion(0)]
	public ReferencingItemContext referencingItem() {
		ReferencingItemContext _localctx = new ReferencingItemContext(Context, State);
		EnterRule(_localctx, 996, RULE_referencingItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5284;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (NEW - 317)) | (1L << (OLD - 317)) | (1L << (PARENT - 317)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5286;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 5285;
				Match(AS);
				}
			}

			State = 5288;
			simpleIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForEachRowClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EACH() { return GetToken(OracleAntlrParser.EACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		public ForEachRowClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forEachRowClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForEachRowClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForEachRowClause(this);
		}
	}

	[RuleVersion(0)]
	public ForEachRowClauseContext forEachRowClause() {
		ForEachRowClauseContext _localctx = new ForEachRowClauseContext(Context, State);
		EnterRule(_localctx, 998, RULE_forEachRowClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5290;
			Match(FOR);
			State = 5291;
			Match(EACH);
			State = 5292;
			Match(ROW);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturningClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURNING() { return GetToken(OracleAntlrParser.RETURNING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntoClauseContext intoClause() {
			return GetRuleContext<IntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BulkCollectIntoClauseContext bulkCollectIntoClause() {
			return GetRuleContext<BulkCollectIntoClauseContext>(0);
		}
		public ReturningClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returningClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterReturningClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitReturningClause(this);
		}
	}

	[RuleVersion(0)]
	public ReturningClauseContext returningClause() {
		ReturningClauseContext _localctx = new ReturningClauseContext(Context, State);
		EnterRule(_localctx, 1000, RULE_returningClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5294;
			Match(RETURNING);
			State = 5295;
			expressionList();
			State = 5298;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INTO:
				{
				State = 5296;
				intoClause();
				}
				break;
			case BULK:
				{
				State = 5297;
				bulkCollectIntoClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnlyClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLY() { return GetToken(OracleAntlrParser.ONLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public OnlyClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onlyClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOnlyClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOnlyClause(this);
		}
	}

	[RuleVersion(0)]
	public OnlyClauseContext onlyClause() {
		OnlyClauseContext _localctx = new OnlyClauseContext(Context, State);
		EnterRule(_localctx, 1002, RULE_onlyClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5300;
			Match(ONLY);
			State = 5301;
			Match(LPAREN);
			State = 5302;
			fromClauseItem();
			State = 5303;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementMemberContext[] selectStatementMember() {
			return GetRuleContexts<SelectStatementMemberContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementMemberContext selectStatementMember(int i) {
			return GetRuleContext<SelectStatementMemberContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryFactoringClauseContext subqueryFactoringClause() {
			return GetRuleContext<SubqueryFactoringClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnionOperatorContext[] unionOperator() {
			return GetRuleContexts<UnionOperatorContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnionOperatorContext unionOperator(int i) {
			return GetRuleContext<UnionOperatorContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForUpdateClauseContext forUpdateClause() {
			return GetRuleContext<ForUpdateClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryRestrictionClauseContext subqueryRestrictionClause() {
			return GetRuleContext<SubqueryRestrictionClauseContext>(0);
		}
		public SelectStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSelectStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSelectStatement(this);
		}
	}

	[RuleVersion(0)]
	public SelectStatementContext selectStatement() {
		SelectStatementContext _localctx = new SelectStatementContext(Context, State);
		EnterRule(_localctx, 1004, RULE_selectStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5306;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 5305;
				subqueryFactoringClause();
				}
			}

			State = 5308;
			selectStatementMember();
			State = 5314;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==INTERSECT || _la==MINUS || _la==UNION) {
				{
				{
				State = 5309;
				unionOperator();
				State = 5310;
				selectStatementMember();
				}
				}
				State = 5316;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5325;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ORDER:
				{
				State = 5317;
				orderByClause();
				State = 5319;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 5318;
					forUpdateClause();
					}
				}

				}
				break;
			case FOR:
				{
				State = 5321;
				forUpdateClause();
				State = 5323;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ORDER) {
					{
					State = 5322;
					orderByClause();
					}
				}

				}
				break;
			case Eof:
			case LOG:
			case MEMOPTIMIZE:
			case PARENT:
			case RETURNING:
			case WITH:
			case RPAREN:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			State = 5328;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 5327;
				subqueryRestrictionClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectStatementMemberContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BasicSelectStatementContext basicSelectStatement() {
			return GetRuleContext<BasicSelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public SelectStatementMemberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectStatementMember; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSelectStatementMember(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSelectStatementMember(this);
		}
	}

	[RuleVersion(0)]
	public SelectStatementMemberContext selectStatementMember() {
		SelectStatementMemberContext _localctx = new SelectStatementMemberContext(Context, State);
		EnterRule(_localctx, 1006, RULE_selectStatementMember);
		try {
			State = 5335;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5330;
				basicSelectStatement();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5331;
				Match(LPAREN);
				State = 5332;
				selectStatement();
				State = 5333;
				Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnionOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNION() { return GetToken(OracleAntlrParser.UNION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(OracleAntlrParser.MINUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERSECT() { return GetToken(OracleAntlrParser.INTERSECT, 0); }
		public UnionOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unionOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUnionOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUnionOperator(this);
		}
	}

	[RuleVersion(0)]
	public UnionOperatorContext unionOperator() {
		UnionOperatorContext _localctx = new UnionOperatorContext(Context, State);
		EnterRule(_localctx, 1008, RULE_unionOperator);
		try {
			State = 5342;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,551,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5337;
				Match(UNION);
				State = 5338;
				Match(ALL);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5339;
				Match(UNION);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5340;
				Match(MINUS);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5341;
				Match(INTERSECT);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithCheckOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHECK() { return GetToken(OracleAntlrParser.CHECK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTION() { return GetToken(OracleAntlrParser.OPTION, 0); }
		public WithCheckOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withCheckOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterWithCheckOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitWithCheckOption(this);
		}
	}

	[RuleVersion(0)]
	public WithCheckOptionContext withCheckOption() {
		WithCheckOptionContext _localctx = new WithCheckOptionContext(Context, State);
		EnterRule(_localctx, 1010, RULE_withCheckOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5344;
			Match(CHECK);
			State = 5345;
			Match(OPTION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithReadOnlyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READ() { return GetToken(OracleAntlrParser.READ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLY() { return GetToken(OracleAntlrParser.ONLY, 0); }
		public WithReadOnlyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withReadOnly; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterWithReadOnly(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitWithReadOnly(this);
		}
	}

	[RuleVersion(0)]
	public WithReadOnlyContext withReadOnly() {
		WithReadOnlyContext _localctx = new WithReadOnlyContext(Context, State);
		EnterRule(_localctx, 1012, RULE_withReadOnly);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5347;
			Match(READ);
			State = 5348;
			Match(ONLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverOrderByClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDER() { return GetToken(OracleAntlrParser.ORDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OrderByListContext orderByList() {
			return GetRuleContext<OrderByListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIBLINGS() { return GetToken(OracleAntlrParser.SIBLINGS, 0); }
		public OverOrderByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overOrderByClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOverOrderByClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOverOrderByClause(this);
		}
	}

	[RuleVersion(0)]
	public OverOrderByClauseContext overOrderByClause() {
		OverOrderByClauseContext _localctx = new OverOrderByClauseContext(Context, State);
		EnterRule(_localctx, 1014, RULE_overOrderByClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5350;
			Match(ORDER);
			State = 5352;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SIBLINGS) {
				{
				State = 5351;
				Match(SIBLINGS);
				}
			}

			State = 5354;
			Match(BY);
			State = 5355;
			orderByList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithinGroupOrderByClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDER() { return GetToken(OracleAntlrParser.ORDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OrderByListContext orderByList() {
			return GetRuleContext<OrderByListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIBLINGS() { return GetToken(OracleAntlrParser.SIBLINGS, 0); }
		public WithinGroupOrderByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withinGroupOrderByClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterWithinGroupOrderByClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitWithinGroupOrderByClause(this);
		}
	}

	[RuleVersion(0)]
	public WithinGroupOrderByClauseContext withinGroupOrderByClause() {
		WithinGroupOrderByClauseContext _localctx = new WithinGroupOrderByClauseContext(Context, State);
		EnterRule(_localctx, 1016, RULE_withinGroupOrderByClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5357;
			Match(ORDER);
			State = 5359;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SIBLINGS) {
				{
				State = 5358;
				Match(SIBLINGS);
				}
			}

			State = 5361;
			Match(BY);
			State = 5362;
			orderByList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDER() { return GetToken(OracleAntlrParser.ORDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OrderByListContext orderByList() {
			return GetRuleContext<OrderByListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIBLINGS() { return GetToken(OracleAntlrParser.SIBLINGS, 0); }
		public OrderByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOrderByClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOrderByClause(this);
		}
	}

	[RuleVersion(0)]
	public OrderByClauseContext orderByClause() {
		OrderByClauseContext _localctx = new OrderByClauseContext(Context, State);
		EnterRule(_localctx, 1018, RULE_orderByClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5364;
			Match(ORDER);
			State = 5366;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SIBLINGS) {
				{
				State = 5365;
				Match(SIBLINGS);
				}
			}

			State = 5368;
			Match(BY);
			State = 5369;
			orderByList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public OrderByListItemContext[] orderByListItem() {
			return GetRuleContexts<OrderByListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OrderByListItemContext orderByListItem(int i) {
			return GetRuleContext<OrderByListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public OrderByListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOrderByList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOrderByList(this);
		}
	}

	[RuleVersion(0)]
	public OrderByListContext orderByList() {
		OrderByListContext _localctx = new OrderByListContext(Context, State);
		EnterRule(_localctx, 1020, RULE_orderByList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5371;
			orderByListItem();
			State = 5376;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5372;
				Match(COMMA);
				State = 5373;
				orderByListItem();
				}
				}
				State = 5378;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AscDescSortAtrtributeClauseContext ascDescSortAtrtributeClause() {
			return GetRuleContext<AscDescSortAtrtributeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OrderByNullsAttributeClauseContext orderByNullsAttributeClause() {
			return GetRuleContext<OrderByNullsAttributeClauseContext>(0);
		}
		public OrderByListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOrderByListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOrderByListItem(this);
		}
	}

	[RuleVersion(0)]
	public OrderByListItemContext orderByListItem() {
		OrderByListItemContext _localctx = new OrderByListItemContext(Context, State);
		EnterRule(_localctx, 1022, RULE_orderByListItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5379;
			fullExpression();
			State = 5381;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASC || _la==DESC) {
				{
				State = 5380;
				ascDescSortAtrtributeClause();
				}
			}

			State = 5384;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NULLS) {
				{
				State = 5383;
				orderByNullsAttributeClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AscDescSortAtrtributeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASC() { return GetToken(OracleAntlrParser.ASC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DESC() { return GetToken(OracleAntlrParser.DESC, 0); }
		public AscDescSortAtrtributeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ascDescSortAtrtributeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAscDescSortAtrtributeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAscDescSortAtrtributeClause(this);
		}
	}

	[RuleVersion(0)]
	public AscDescSortAtrtributeClauseContext ascDescSortAtrtributeClause() {
		AscDescSortAtrtributeClauseContext _localctx = new AscDescSortAtrtributeClauseContext(Context, State);
		EnterRule(_localctx, 1024, RULE_ascDescSortAtrtributeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5386;
			_la = TokenStream.LA(1);
			if ( !(_la==ASC || _la==DESC) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByNullsAttributeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULLS() { return GetToken(OracleAntlrParser.NULLS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIRST() { return GetToken(OracleAntlrParser.FIRST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LAST() { return GetToken(OracleAntlrParser.LAST, 0); }
		public OrderByNullsAttributeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByNullsAttributeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOrderByNullsAttributeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOrderByNullsAttributeClause(this);
		}
	}

	[RuleVersion(0)]
	public OrderByNullsAttributeClauseContext orderByNullsAttributeClause() {
		OrderByNullsAttributeClauseContext _localctx = new OrderByNullsAttributeClauseContext(Context, State);
		EnterRule(_localctx, 1026, RULE_orderByNullsAttributeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5388;
			Match(NULLS);
			State = 5389;
			_la = TokenStream.LA(1);
			if ( !(_la==FIRST || _la==LAST) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForUpdateClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UPDATE() { return GetToken(OracleAntlrParser.UPDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterOfContext delimiterOf() {
			return GetRuleContext<DelimiterOfContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WaitOrNowaitClauseContext waitOrNowaitClause() {
			return GetRuleContext<WaitOrNowaitClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SkipLockedClauseContext skipLockedClause() {
			return GetRuleContext<SkipLockedClauseContext>(0);
		}
		public ForUpdateClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forUpdateClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForUpdateClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForUpdateClause(this);
		}
	}

	[RuleVersion(0)]
	public ForUpdateClauseContext forUpdateClause() {
		ForUpdateClauseContext _localctx = new ForUpdateClauseContext(Context, State);
		EnterRule(_localctx, 1028, RULE_forUpdateClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5391;
			Match(FOR);
			State = 5392;
			Match(UPDATE);
			State = 5396;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OF) {
				{
				State = 5393;
				delimiterOf();
				State = 5394;
				identifierList();
				}
			}

			State = 5400;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOWAIT:
			case WAIT:
				{
				State = 5398;
				waitOrNowaitClause();
				}
				break;
			case SKIP_:
				{
				State = 5399;
				skipLockedClause();
				}
				break;
			case Eof:
			case LOG:
			case MEMOPTIMIZE:
			case ORDER:
			case PARENT:
			case RETURNING:
			case WITH:
			case RPAREN:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterOfContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		public DelimiterOfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterOf; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterOf(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterOf(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterOfContext delimiterOf() {
		DelimiterOfContext _localctx = new DelimiterOfContext(Context, State);
		EnterRule(_localctx, 1030, RULE_delimiterOf);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5402;
			Match(OF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WaitOrNowaitClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOWAIT() { return GetToken(OracleAntlrParser.NOWAIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WAIT() { return GetToken(OracleAntlrParser.WAIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public WaitOrNowaitClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_waitOrNowaitClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterWaitOrNowaitClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitWaitOrNowaitClause(this);
		}
	}

	[RuleVersion(0)]
	public WaitOrNowaitClauseContext waitOrNowaitClause() {
		WaitOrNowaitClauseContext _localctx = new WaitOrNowaitClauseContext(Context, State);
		EnterRule(_localctx, 1032, RULE_waitOrNowaitClause);
		try {
			State = 5407;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOWAIT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5404;
				Match(NOWAIT);
				}
				break;
			case WAIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5405;
				Match(WAIT);
				State = 5406;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SkipLockedClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SKIP_() { return GetToken(OracleAntlrParser.SKIP_, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCKED() { return GetToken(OracleAntlrParser.LOCKED, 0); }
		public SkipLockedClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_skipLockedClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSkipLockedClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSkipLockedClause(this);
		}
	}

	[RuleVersion(0)]
	public SkipLockedClauseContext skipLockedClause() {
		SkipLockedClauseContext _localctx = new SkipLockedClauseContext(Context, State);
		EnterRule(_localctx, 1034, RULE_skipLockedClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5409;
			Match(SKIP_);
			State = 5410;
			Match(LOCKED);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryFactoringClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryFactoringClauseItemContext[] subqueryFactoringClauseItem() {
			return GetRuleContexts<SubqueryFactoringClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryFactoringClauseItemContext subqueryFactoringClauseItem(int i) {
			return GetRuleContext<SubqueryFactoringClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public SubqueryFactoringClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryFactoringClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubqueryFactoringClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubqueryFactoringClause(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryFactoringClauseContext subqueryFactoringClause() {
		SubqueryFactoringClauseContext _localctx = new SubqueryFactoringClauseContext(Context, State);
		EnterRule(_localctx, 1036, RULE_subqueryFactoringClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5412;
			Match(WITH);
			State = 5413;
			subqueryFactoringClauseItem();
			State = 5418;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5414;
				Match(COMMA);
				State = 5415;
				subqueryFactoringClauseItem();
				}
				}
				State = 5420;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryFactoringClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AsFlattenedQueryContext asFlattenedQuery() {
			return GetRuleContext<AsFlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryFactoringColumnsListContext subqueryFactoringColumnsList() {
			return GetRuleContext<SubqueryFactoringColumnsListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SearchClauseContext searchClause() {
			return GetRuleContext<SearchClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CycleClauseContext cycleClause() {
			return GetRuleContext<CycleClauseContext>(0);
		}
		public SubqueryFactoringClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryFactoringClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubqueryFactoringClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubqueryFactoringClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryFactoringClauseItemContext subqueryFactoringClauseItem() {
		SubqueryFactoringClauseItemContext _localctx = new SubqueryFactoringClauseItemContext(Context, State);
		EnterRule(_localctx, 1038, RULE_subqueryFactoringClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5421;
			plainIdentifier();
			State = 5423;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 5422;
				subqueryFactoringColumnsList();
				}
			}

			State = 5425;
			asFlattenedQuery();
			State = 5427;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SEARCH) {
				{
				State = 5426;
				searchClause();
				}
			}

			State = 5430;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CYCLE) {
				{
				State = 5429;
				cycleClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryFactoringColumnsListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public SubqueryFactoringColumnsListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryFactoringColumnsList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubqueryFactoringColumnsList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubqueryFactoringColumnsList(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryFactoringColumnsListContext subqueryFactoringColumnsList() {
		SubqueryFactoringColumnsListContext _localctx = new SubqueryFactoringColumnsListContext(Context, State);
		EnterRule(_localctx, 1040, RULE_subqueryFactoringColumnsList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5432;
			Match(LPAREN);
			State = 5433;
			identifierList();
			State = 5434;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SearchClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEARCH() { return GetToken(OracleAntlrParser.SEARCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIRST() { return GetToken(OracleAntlrParser.FIRST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OrderByListContext orderByList() {
			return GetRuleContext<OrderByListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryFactoringSetClauseContext subqueryFactoringSetClause() {
			return GetRuleContext<SubqueryFactoringSetClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEPTH() { return GetToken(OracleAntlrParser.DEPTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BREADTH() { return GetToken(OracleAntlrParser.BREADTH, 0); }
		public SearchClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searchClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSearchClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSearchClause(this);
		}
	}

	[RuleVersion(0)]
	public SearchClauseContext searchClause() {
		SearchClauseContext _localctx = new SearchClauseContext(Context, State);
		EnterRule(_localctx, 1042, RULE_searchClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5436;
			Match(SEARCH);
			State = 5437;
			_la = TokenStream.LA(1);
			if ( !(_la==BREADTH || _la==DEPTH) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5438;
			Match(FIRST);
			State = 5439;
			Match(BY);
			State = 5440;
			orderByList();
			State = 5441;
			subqueryFactoringSetClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryFactoringSetClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public SubqueryFactoringSetClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryFactoringSetClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubqueryFactoringSetClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubqueryFactoringSetClause(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryFactoringSetClauseContext subqueryFactoringSetClause() {
		SubqueryFactoringSetClauseContext _localctx = new SubqueryFactoringSetClauseContext(Context, State);
		EnterRule(_localctx, 1044, RULE_subqueryFactoringSetClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5443;
			Match(SET);
			State = 5444;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CycleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CYCLE() { return GetToken(OracleAntlrParser.CYCLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryFactoringSetClauseContext subqueryFactoringSetClause() {
			return GetRuleContext<SubqueryFactoringSetClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ToCycleClauseContext toCycleClause() {
			return GetRuleContext<ToCycleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultCycleClauseContext defaultCycleClause() {
			return GetRuleContext<DefaultCycleClauseContext>(0);
		}
		public CycleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cycleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCycleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCycleClause(this);
		}
	}

	[RuleVersion(0)]
	public CycleClauseContext cycleClause() {
		CycleClauseContext _localctx = new CycleClauseContext(Context, State);
		EnterRule(_localctx, 1046, RULE_cycleClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5446;
			Match(CYCLE);
			State = 5447;
			identifierList();
			State = 5448;
			subqueryFactoringSetClause();
			State = 5449;
			toCycleClause();
			State = 5450;
			defaultCycleClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ToCycleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(OracleAntlrParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ToCycleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_toCycleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterToCycleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitToCycleClause(this);
		}
	}

	[RuleVersion(0)]
	public ToCycleClauseContext toCycleClause() {
		ToCycleClauseContext _localctx = new ToCycleClauseContext(Context, State);
		EnterRule(_localctx, 1048, RULE_toCycleClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5452;
			Match(TO);
			State = 5453;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefaultCycleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public DefaultCycleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defaultCycleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDefaultCycleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDefaultCycleClause(this);
		}
	}

	[RuleVersion(0)]
	public DefaultCycleClauseContext defaultCycleClause() {
		DefaultCycleClauseContext _localctx = new DefaultCycleClauseContext(Context, State);
		EnterRule(_localctx, 1050, RULE_defaultCycleClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5455;
			Match(DEFAULT);
			State = 5456;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BasicSelectStatementContext : ParserRuleContext {
		public HavingClauseContext havingFirst;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SELECT() { return GetToken(OracleAntlrParser.SELECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectExpressionListContext selectExpressionList() {
			return GetRuleContext<SelectExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseContext fromClause() {
			return GetRuleContext<FromClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntoClauseContext intoClause() {
			return GetRuleContext<IntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BulkCollectIntoClauseContext bulkCollectIntoClause() {
			return GetRuleContext<BulkCollectIntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConnectByClauseContext connectByClause() {
			return GetRuleContext<ConnectByClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StartWithClauseContext startWithClause() {
			return GetRuleContext<StartWithClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupByClauseContext groupByClause() {
			return GetRuleContext<GroupByClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISTINCT() { return GetToken(OracleAntlrParser.DISTINCT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUE() { return GetToken(OracleAntlrParser.UNIQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public HavingClauseContext havingClause() {
			return GetRuleContext<HavingClauseContext>(0);
		}
		public BasicSelectStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_basicSelectStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBasicSelectStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBasicSelectStatement(this);
		}
	}

	[RuleVersion(0)]
	public BasicSelectStatementContext basicSelectStatement() {
		BasicSelectStatementContext _localctx = new BasicSelectStatementContext(Context, State);
		EnterRule(_localctx, 1052, RULE_basicSelectStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5458;
			Match(SELECT);
			State = 5460;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==DISTINCT || _la==UNIQUE) {
				{
				State = 5459;
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==DISTINCT || _la==UNIQUE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 5462;
			selectExpressionList();
			State = 5465;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INTO:
				{
				State = 5463;
				intoClause();
				}
				break;
			case BULK:
				{
				State = 5464;
				bulkCollectIntoClause();
				}
				break;
			case FROM:
				break;
			default:
				break;
			}
			State = 5467;
			fromClause();
			State = 5469;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 5468;
				whereClause();
				}
			}

			State = 5478;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CONNECT:
				{
				State = 5471;
				connectByClause();
				State = 5473;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==START) {
					{
					State = 5472;
					startWithClause();
					}
				}

				}
				break;
			case START:
				{
				State = 5475;
				startWithClause();
				State = 5476;
				connectByClause();
				}
				break;
			case Eof:
			case FOR:
			case GROUP:
			case HAVING:
			case INTERSECT:
			case LOG:
			case MEMOPTIMIZE:
			case MINUS:
			case ORDER:
			case PARENT:
			case RETURNING:
			case UNION:
			case WITH:
			case RPAREN:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			State = 5488;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case GROUP:
				{
				State = 5480;
				groupByClause();
				State = 5482;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==HAVING) {
					{
					State = 5481;
					havingClause();
					}
				}

				}
				break;
			case HAVING:
				{
				State = 5484;
				_localctx.havingFirst = havingClause();
				State = 5486;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==GROUP) {
					{
					State = 5485;
					groupByClause();
					}
				}

				}
				break;
			case Eof:
			case FOR:
			case INTERSECT:
			case LOG:
			case MEMOPTIMIZE:
			case MINUS:
			case ORDER:
			case PARENT:
			case RETURNING:
			case UNION:
			case WITH:
			case RPAREN:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public SelectExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSelectExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSelectExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public SelectExpressionListContext selectExpressionList() {
		SelectExpressionListContext _localctx = new SelectExpressionListContext(Context, State);
		EnterRule(_localctx, 1054, RULE_selectExpressionList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5490;
			expressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntoClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		public IntoClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intoClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIntoClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIntoClause(this);
		}
	}

	[RuleVersion(0)]
	public IntoClauseContext intoClause() {
		IntoClauseContext _localctx = new IntoClauseContext(Context, State);
		EnterRule(_localctx, 1056, RULE_intoClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5492;
			Match(INTO);
			State = 5493;
			identifierList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhereClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHERE() { return GetToken(OracleAntlrParser.WHERE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public WhereClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whereClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterWhereClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitWhereClause(this);
		}
	}

	[RuleVersion(0)]
	public WhereClauseContext whereClause() {
		WhereClauseContext _localctx = new WhereClauseContext(Context, State);
		EnterRule(_localctx, 1058, RULE_whereClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5495;
			Match(WHERE);
			State = 5496;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUP() { return GetToken(OracleAntlrParser.GROUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GroupByClauseExpressionListContext groupByClauseExpressionList() {
			return GetRuleContext<GroupByClauseExpressionListContext>(0);
		}
		public GroupByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGroupByClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGroupByClause(this);
		}
	}

	[RuleVersion(0)]
	public GroupByClauseContext groupByClause() {
		GroupByClauseContext _localctx = new GroupByClauseContext(Context, State);
		EnterRule(_localctx, 1060, RULE_groupByClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5498;
			Match(GROUP);
			State = 5499;
			Match(BY);
			State = 5500;
			groupByClauseExpressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByClauseExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GroupByComplexExpressionListContext groupByComplexExpressionList() {
			return GetRuleContext<GroupByComplexExpressionListContext>(0);
		}
		public GroupByClauseExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByClauseExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGroupByClauseExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGroupByClauseExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public GroupByClauseExpressionListContext groupByClauseExpressionList() {
		GroupByClauseExpressionListContext _localctx = new GroupByClauseExpressionListContext(Context, State);
		EnterRule(_localctx, 1062, RULE_groupByClauseExpressionList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5502;
			groupByComplexExpressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByComplexExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GroupByComplexListExpressionItemContext[] groupByComplexListExpressionItem() {
			return GetRuleContexts<GroupByComplexListExpressionItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupByComplexListExpressionItemContext groupByComplexListExpressionItem(int i) {
			return GetRuleContext<GroupByComplexListExpressionItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public GroupByComplexExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByComplexExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGroupByComplexExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGroupByComplexExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public GroupByComplexExpressionListContext groupByComplexExpressionList() {
		GroupByComplexExpressionListContext _localctx = new GroupByComplexExpressionListContext(Context, State);
		EnterRule(_localctx, 1064, RULE_groupByComplexExpressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5504;
			groupByComplexListExpressionItem();
			State = 5509;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5505;
				Match(COMMA);
				State = 5506;
				groupByComplexListExpressionItem();
				}
				}
				State = 5511;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByComplexListExpressionItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GroupByClauseExpressionListItemContext groupByClauseExpressionListItem() {
			return GetRuleContext<GroupByClauseExpressionListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupByComplexExpressionListWithParenthesisContext groupByComplexExpressionListWithParenthesis() {
			return GetRuleContext<GroupByComplexExpressionListWithParenthesisContext>(0);
		}
		public GroupByComplexListExpressionItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByComplexListExpressionItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGroupByComplexListExpressionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGroupByComplexListExpressionItem(this);
		}
	}

	[RuleVersion(0)]
	public GroupByComplexListExpressionItemContext groupByComplexListExpressionItem() {
		GroupByComplexListExpressionItemContext _localctx = new GroupByComplexListExpressionItemContext(Context, State);
		EnterRule(_localctx, 1066, RULE_groupByComplexListExpressionItem);
		try {
			State = 5514;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,574,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5512;
				groupByClauseExpressionListItem();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5513;
				groupByComplexExpressionListWithParenthesis();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByComplexExpressionListWithParenthesisContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GroupByComplexListExpressionItemContext[] groupByComplexListExpressionItem() {
			return GetRuleContexts<GroupByComplexListExpressionItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupByComplexListExpressionItemContext groupByComplexListExpressionItem(int i) {
			return GetRuleContext<GroupByComplexListExpressionItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public GroupByComplexExpressionListWithParenthesisContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByComplexExpressionListWithParenthesis; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGroupByComplexExpressionListWithParenthesis(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGroupByComplexExpressionListWithParenthesis(this);
		}
	}

	[RuleVersion(0)]
	public GroupByComplexExpressionListWithParenthesisContext groupByComplexExpressionListWithParenthesis() {
		GroupByComplexExpressionListWithParenthesisContext _localctx = new GroupByComplexExpressionListWithParenthesisContext(Context, State);
		EnterRule(_localctx, 1068, RULE_groupByComplexExpressionListWithParenthesis);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5516;
			Match(LPAREN);
			State = 5517;
			groupByComplexListExpressionItem();
			State = 5522;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5518;
				Match(COMMA);
				State = 5519;
				groupByComplexListExpressionItem();
				}
				}
				State = 5524;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5525;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByClauseExpressionListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RollupCubeClauseContext rollupCubeClause() {
			return GetRuleContext<RollupCubeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupingSetsClauseContext groupingSetsClause() {
			return GetRuleContext<GroupingSetsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GrandTotalContext grandTotal() {
			return GetRuleContext<GrandTotalContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public GroupByClauseExpressionListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByClauseExpressionListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGroupByClauseExpressionListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGroupByClauseExpressionListItem(this);
		}
	}

	[RuleVersion(0)]
	public GroupByClauseExpressionListItemContext groupByClauseExpressionListItem() {
		GroupByClauseExpressionListItemContext _localctx = new GroupByClauseExpressionListItemContext(Context, State);
		EnterRule(_localctx, 1070, RULE_groupByClauseExpressionListItem);
		try {
			State = 5531;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,576,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5527;
				rollupCubeClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5528;
				groupingSetsClause();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5529;
				grandTotal();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5530;
				fullExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GrandTotalContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public GrandTotalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grandTotal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGrandTotal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGrandTotal(this);
		}
	}

	[RuleVersion(0)]
	public GrandTotalContext grandTotal() {
		GrandTotalContext _localctx = new GrandTotalContext(Context, State);
		EnterRule(_localctx, 1072, RULE_grandTotal);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5533;
			Match(LPAREN);
			State = 5534;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingSetsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUPING() { return GetToken(OracleAntlrParser.GROUPING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETS() { return GetToken(OracleAntlrParser.SETS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GroupingSetsListContext groupingSetsList() {
			return GetRuleContext<GroupingSetsListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public GroupingSetsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingSetsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGroupingSetsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGroupingSetsClause(this);
		}
	}

	[RuleVersion(0)]
	public GroupingSetsClauseContext groupingSetsClause() {
		GroupingSetsClauseContext _localctx = new GroupingSetsClauseContext(Context, State);
		EnterRule(_localctx, 1074, RULE_groupingSetsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5536;
			Match(GROUPING);
			State = 5537;
			Match(SETS);
			State = 5538;
			Match(LPAREN);
			State = 5539;
			groupingSetsList();
			State = 5540;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingSetsListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GroupingSetContext[] groupingSet() {
			return GetRuleContexts<GroupingSetContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupingSetContext groupingSet(int i) {
			return GetRuleContext<GroupingSetContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public GroupingSetsListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingSetsList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGroupingSetsList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGroupingSetsList(this);
		}
	}

	[RuleVersion(0)]
	public GroupingSetsListContext groupingSetsList() {
		GroupingSetsListContext _localctx = new GroupingSetsListContext(Context, State);
		EnterRule(_localctx, 1076, RULE_groupingSetsList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5542;
			groupingSet();
			State = 5547;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5543;
				Match(COMMA);
				State = 5544;
				groupingSet();
				}
				}
				State = 5549;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingSetContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GrandTotalContext grandTotal() {
			return GetRuleContext<GrandTotalContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupingSetItemListContext groupingSetItemList() {
			return GetRuleContext<GroupingSetItemListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupingSetItemContext groupingSetItem() {
			return GetRuleContext<GroupingSetItemContext>(0);
		}
		public GroupingSetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingSet; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGroupingSet(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGroupingSet(this);
		}
	}

	[RuleVersion(0)]
	public GroupingSetContext groupingSet() {
		GroupingSetContext _localctx = new GroupingSetContext(Context, State);
		EnterRule(_localctx, 1078, RULE_groupingSet);
		try {
			State = 5553;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,578,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5550;
				grandTotal();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5551;
				groupingSetItemList();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5552;
				groupingSetItem();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingSetItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RollupCubeClauseContext rollupCubeClause() {
			return GetRuleContext<RollupCubeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public GroupingSetItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingSetItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGroupingSetItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGroupingSetItem(this);
		}
	}

	[RuleVersion(0)]
	public GroupingSetItemContext groupingSetItem() {
		GroupingSetItemContext _localctx = new GroupingSetItemContext(Context, State);
		EnterRule(_localctx, 1080, RULE_groupingSetItem);
		try {
			State = 5557;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,579,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5555;
				rollupCubeClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5556;
				fullExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingSetItemListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public GroupingSetItemListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingSetItemList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGroupingSetItemList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGroupingSetItemList(this);
		}
	}

	[RuleVersion(0)]
	public GroupingSetItemListContext groupingSetItemList() {
		GroupingSetItemListContext _localctx = new GroupingSetItemListContext(Context, State);
		EnterRule(_localctx, 1082, RULE_groupingSetItemList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5559;
			Match(LPAREN);
			State = 5560;
			fullExpression();
			State = 5565;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5561;
				Match(COMMA);
				State = 5562;
				fullExpression();
				}
				}
				State = 5567;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5568;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RollupCubeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GroupingExpressionListContext groupingExpressionList() {
			return GetRuleContext<GroupingExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLLUP() { return GetToken(OracleAntlrParser.ROLLUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CUBE() { return GetToken(OracleAntlrParser.CUBE, 0); }
		public RollupCubeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollupCubeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRollupCubeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRollupCubeClause(this);
		}
	}

	[RuleVersion(0)]
	public RollupCubeClauseContext rollupCubeClause() {
		RollupCubeClauseContext _localctx = new RollupCubeClauseContext(Context, State);
		EnterRule(_localctx, 1084, RULE_rollupCubeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5570;
			_la = TokenStream.LA(1);
			if ( !(_la==CUBE || _la==ROLLUP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5571;
			Match(LPAREN);
			State = 5572;
			groupingExpressionList();
			State = 5573;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GroupingExpressionListItemContext[] groupingExpressionListItem() {
			return GetRuleContexts<GroupingExpressionListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupingExpressionListItemContext groupingExpressionListItem(int i) {
			return GetRuleContext<GroupingExpressionListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public GroupingExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGroupingExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGroupingExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public GroupingExpressionListContext groupingExpressionList() {
		GroupingExpressionListContext _localctx = new GroupingExpressionListContext(Context, State);
		EnterRule(_localctx, 1086, RULE_groupingExpressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5575;
			groupingExpressionListItem();
			State = 5580;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5576;
				Match(COMMA);
				State = 5577;
				groupingExpressionListItem();
				}
				}
				State = 5582;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingExpressionListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GroupingExpressionNestedItemContext groupingExpressionNestedItem() {
			return GetRuleContext<GroupingExpressionNestedItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public GroupingExpressionListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingExpressionListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGroupingExpressionListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGroupingExpressionListItem(this);
		}
	}

	[RuleVersion(0)]
	public GroupingExpressionListItemContext groupingExpressionListItem() {
		GroupingExpressionListItemContext _localctx = new GroupingExpressionListItemContext(Context, State);
		EnterRule(_localctx, 1088, RULE_groupingExpressionListItem);
		try {
			State = 5585;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,582,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5583;
				groupingExpressionNestedItem();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5584;
				fullExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingExpressionNestedItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public GroupingExpressionNestedItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingExpressionNestedItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGroupingExpressionNestedItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGroupingExpressionNestedItem(this);
		}
	}

	[RuleVersion(0)]
	public GroupingExpressionNestedItemContext groupingExpressionNestedItem() {
		GroupingExpressionNestedItemContext _localctx = new GroupingExpressionNestedItemContext(Context, State);
		EnterRule(_localctx, 1090, RULE_groupingExpressionNestedItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5587;
			Match(LPAREN);
			State = 5588;
			fullExpression();
			State = 5593;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5589;
				Match(COMMA);
				State = 5590;
				fullExpression();
				}
				}
				State = 5595;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5596;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConnectByClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONNECT() { return GetToken(OracleAntlrParser.CONNECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCYCLE() { return GetToken(OracleAntlrParser.NOCYCLE, 0); }
		public ConnectByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_connectByClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConnectByClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConnectByClause(this);
		}
	}

	[RuleVersion(0)]
	public ConnectByClauseContext connectByClause() {
		ConnectByClauseContext _localctx = new ConnectByClauseContext(Context, State);
		EnterRule(_localctx, 1092, RULE_connectByClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5598;
			Match(CONNECT);
			State = 5599;
			Match(BY);
			State = 5601;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,584,Context) ) {
			case 1:
				{
				State = 5600;
				Match(NOCYCLE);
				}
				break;
			}
			State = 5603;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartWithClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode START() { return GetToken(OracleAntlrParser.START, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public StartWithClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startWithClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterStartWithClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitStartWithClause(this);
		}
	}

	[RuleVersion(0)]
	public StartWithClauseContext startWithClause() {
		StartWithClauseContext _localctx = new StartWithClauseContext(Context, State);
		EnterRule(_localctx, 1094, RULE_startWithClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5605;
			Match(START);
			State = 5606;
			Match(WITH);
			State = 5607;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HavingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HAVING() { return GetToken(OracleAntlrParser.HAVING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public HavingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_havingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterHavingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitHavingClause(this);
		}
	}

	[RuleVersion(0)]
	public HavingClauseContext havingClause() {
		HavingClauseContext _localctx = new HavingClauseContext(Context, State);
		EnterRule(_localctx, 1096, RULE_havingClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5609;
			Match(HAVING);
			State = 5610;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FromClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(OracleAntlrParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ComplexFromClauseItemContext[] complexFromClauseItem() {
			return GetRuleContexts<ComplexFromClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComplexFromClauseItemContext complexFromClauseItem(int i) {
			return GetRuleContext<ComplexFromClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public FromClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fromClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFromClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFromClause(this);
		}
	}

	[RuleVersion(0)]
	public FromClauseContext fromClause() {
		FromClauseContext _localctx = new FromClauseContext(Context, State);
		EnterRule(_localctx, 1098, RULE_fromClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5612;
			Match(FROM);
			State = 5613;
			complexFromClauseItem();
			State = 5618;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5614;
				Match(COMMA);
				State = 5615;
				complexFromClauseItem();
				}
				}
				State = 5620;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComplexFromClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ComplexFromClauseItemInnerContext complexFromClauseItemInner() {
			return GetRuleContext<ComplexFromClauseItemInnerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PivotUnpivotClauseContext pivotUnpivotClause() {
			return GetRuleContext<PivotUnpivotClauseContext>(0);
		}
		public ComplexFromClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_complexFromClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterComplexFromClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitComplexFromClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public ComplexFromClauseItemContext complexFromClauseItem() {
		ComplexFromClauseItemContext _localctx = new ComplexFromClauseItemContext(Context, State);
		EnterRule(_localctx, 1100, RULE_complexFromClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5621;
			complexFromClauseItemInner();
			State = 5623;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PIVOT || _la==UNPIVOT) {
				{
				State = 5622;
				pivotUnpivotClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComplexFromClauseItemInnerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public QueryPartitionClauseContext queryPartitionClause() {
			return GetRuleContext<QueryPartitionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NormalJoinTypeContext[] normalJoinType() {
			return GetRuleContexts<NormalJoinTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NormalJoinTypeContext normalJoinType(int i) {
			return GetRuleContext<NormalJoinTypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComplexFromClauseItemInnerContext[] complexFromClauseItemInner() {
			return GetRuleContexts<ComplexFromClauseItemInnerContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComplexFromClauseItemInnerContext complexFromClauseItemInner(int i) {
			return GetRuleContext<ComplexFromClauseItemInnerContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CrossOrNaturalJoinContext[] crossOrNaturalJoin() {
			return GetRuleContexts<CrossOrNaturalJoinContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CrossOrNaturalJoinContext crossOrNaturalJoin(int i) {
			return GetRuleContext<CrossOrNaturalJoinContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnConditionContext[] onCondition() {
			return GetRuleContexts<OnConditionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnConditionContext onCondition(int i) {
			return GetRuleContext<OnConditionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingConditionContext[] usingCondition() {
			return GetRuleContexts<UsingConditionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingConditionContext usingCondition(int i) {
			return GetRuleContext<UsingConditionContext>(i);
		}
		public ComplexFromClauseItemInnerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_complexFromClauseItemInner; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterComplexFromClauseItemInner(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitComplexFromClauseItemInner(this);
		}
	}

	[RuleVersion(0)]
	public ComplexFromClauseItemInnerContext complexFromClauseItemInner() {
		ComplexFromClauseItemInnerContext _localctx = new ComplexFromClauseItemInnerContext(Context, State);
		EnterRule(_localctx, 1102, RULE_complexFromClauseItemInner);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5625;
			fromClauseItem();
			State = 5627;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 5626;
				queryPartitionClause();
				}
			}

			State = 5640;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,590,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 5638;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case FULL:
					case INNER:
					case JOIN:
					case LEFT:
					case RIGHT:
						{
						State = 5629;
						normalJoinType();
						State = 5630;
						complexFromClauseItemInner();
						State = 5633;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,588,Context) ) {
						case 1:
							{
							State = 5631;
							onCondition();
							}
							break;
						case 2:
							{
							State = 5632;
							usingCondition();
							}
							break;
						}
						}
						break;
					case CROSS:
					case NATURAL:
						{
						State = 5635;
						crossOrNaturalJoin();
						State = 5636;
						complexFromClauseItemInner();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 5642;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,590,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CrossOrNaturalJoinContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CROSS() { return GetToken(OracleAntlrParser.CROSS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JOIN() { return GetToken(OracleAntlrParser.JOIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NATURAL() { return GetToken(OracleAntlrParser.NATURAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INNER() { return GetToken(OracleAntlrParser.INNER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OuterJoinTypeContext outerJoinType() {
			return GetRuleContext<OuterJoinTypeContext>(0);
		}
		public CrossOrNaturalJoinContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_crossOrNaturalJoin; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCrossOrNaturalJoin(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCrossOrNaturalJoin(this);
		}
	}

	[RuleVersion(0)]
	public CrossOrNaturalJoinContext crossOrNaturalJoin() {
		CrossOrNaturalJoinContext _localctx = new CrossOrNaturalJoinContext(Context, State);
		EnterRule(_localctx, 1104, RULE_crossOrNaturalJoin);
		try {
			State = 5651;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CROSS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5643;
				Match(CROSS);
				State = 5644;
				Match(JOIN);
				}
				break;
			case NATURAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5645;
				Match(NATURAL);
				State = 5648;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case INNER:
					{
					State = 5646;
					Match(INNER);
					}
					break;
				case FULL:
				case LEFT:
				case RIGHT:
					{
					State = 5647;
					outerJoinType();
					}
					break;
				case JOIN:
					break;
				default:
					break;
				}
				State = 5650;
				Match(JOIN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NormalJoinTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JOIN() { return GetToken(OracleAntlrParser.JOIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OuterJoinTypeContext outerJoinType() {
			return GetRuleContext<OuterJoinTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INNER() { return GetToken(OracleAntlrParser.INNER, 0); }
		public NormalJoinTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_normalJoinType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNormalJoinType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNormalJoinType(this);
		}
	}

	[RuleVersion(0)]
	public NormalJoinTypeContext normalJoinType() {
		NormalJoinTypeContext _localctx = new NormalJoinTypeContext(Context, State);
		EnterRule(_localctx, 1106, RULE_normalJoinType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5655;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FULL:
			case LEFT:
			case RIGHT:
				{
				State = 5653;
				outerJoinType();
				}
				break;
			case INNER:
				{
				State = 5654;
				Match(INNER);
				}
				break;
			case JOIN:
				break;
			default:
				break;
			}
			State = 5657;
			Match(JOIN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OuterJoinTypeContext : ParserRuleContext {
		public IToken type;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEFT() { return GetToken(OracleAntlrParser.LEFT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RIGHT() { return GetToken(OracleAntlrParser.RIGHT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FULL() { return GetToken(OracleAntlrParser.FULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OUTER() { return GetToken(OracleAntlrParser.OUTER, 0); }
		public OuterJoinTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outerJoinType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOuterJoinType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOuterJoinType(this);
		}
	}

	[RuleVersion(0)]
	public OuterJoinTypeContext outerJoinType() {
		OuterJoinTypeContext _localctx = new OuterJoinTypeContext(Context, State);
		EnterRule(_localctx, 1108, RULE_outerJoinType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5659;
			_localctx.type = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==FULL || _la==LEFT || _la==RIGHT) ) {
				_localctx.type = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5661;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OUTER) {
				{
				State = 5660;
				Match(OUTER);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public OnConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOnCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOnCondition(this);
		}
	}

	[RuleVersion(0)]
	public OnConditionContext onCondition() {
		OnConditionContext _localctx = new OnConditionContext(Context, State);
		EnterRule(_localctx, 1110, RULE_onCondition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5663;
			Match(ON);
			State = 5664;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public UsingConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUsingCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUsingCondition(this);
		}
	}

	[RuleVersion(0)]
	public UsingConditionContext usingCondition() {
		UsingConditionContext _localctx = new UsingConditionContext(Context, State);
		EnterRule(_localctx, 1112, RULE_usingCondition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5666;
			Match(USING);
			State = 5667;
			Match(LPAREN);
			State = 5668;
			identifier();
			State = 5673;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5669;
				Match(COMMA);
				State = 5670;
				identifier();
				}
				}
				State = 5675;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5676;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryPartitionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public QueryPartitionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryPartitionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterQueryPartitionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitQueryPartitionClause(this);
		}
	}

	[RuleVersion(0)]
	public QueryPartitionClauseContext queryPartitionClause() {
		QueryPartitionClauseContext _localctx = new QueryPartitionClauseContext(Context, State);
		EnterRule(_localctx, 1114, RULE_queryPartitionClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5678;
			Match(PARTITION);
			State = 5679;
			Match(BY);
			State = 5680;
			Match(LPAREN);
			State = 5681;
			expressionList();
			State = 5682;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FromClauseItemPartitionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		public FromClauseItemPartitionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fromClauseItemPartitionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFromClauseItemPartitionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFromClauseItemPartitionClause(this);
		}
	}

	[RuleVersion(0)]
	public FromClauseItemPartitionClauseContext fromClauseItemPartitionClause() {
		FromClauseItemPartitionClauseContext _localctx = new FromClauseItemPartitionClauseContext(Context, State);
		EnterRule(_localctx, 1116, RULE_fromClauseItemPartitionClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5684;
			_la = TokenStream.LA(1);
			if ( !(_la==PARTITION || _la==SUBPARTITION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5685;
			Match(LPAREN);
			State = 5686;
			identifier();
			State = 5687;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FromClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ComplexFromClauseItemContext complexFromClauseItem() {
			return GetRuleContext<ComplexFromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlTableItemContext xmlTableItem() {
			return GetRuleContext<XmlTableItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryNestedTableContext flattenedQueryNestedTable() {
			return GetRuleContext<FlattenedQueryNestedTableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonTableContext jsonTable() {
			return GetRuleContext<JsonTableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlashbackAndPivotClausesContext flashbackAndPivotClauses() {
			return GetRuleContext<FlashbackAndPivotClausesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemPartitionClauseContext fromClauseItemPartitionClause() {
			return GetRuleContext<FromClauseItemPartitionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SampleClauseContext sampleClause() {
			return GetRuleContext<SampleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AliasIdentifierContext aliasIdentifier() {
			return GetRuleContext<AliasIdentifierContext>(0);
		}
		public FromClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fromClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFromClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFromClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public FromClauseItemContext fromClauseItem() {
		FromClauseItemContext _localctx = new FromClauseItemContext(Context, State);
		EnterRule(_localctx, 1118, RULE_fromClauseItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5705;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,598,Context) ) {
			case 1:
				{
				State = 5689;
				plainIdentifier();
				State = 5695;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,597,Context) ) {
				case 1:
					{
					State = 5690;
					fromClauseItemPartitionClause();
					State = 5692;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,596,Context) ) {
					case 1:
						{
						State = 5691;
						sampleClause();
						}
						break;
					}
					}
					break;
				case 2:
					{
					State = 5694;
					sampleClause();
					}
					break;
				}
				}
				break;
			case 2:
				{
				State = 5697;
				Match(LPAREN);
				State = 5698;
				complexFromClauseItem();
				State = 5699;
				Match(RPAREN);
				}
				break;
			case 3:
				{
				State = 5701;
				xmlTableItem();
				}
				break;
			case 4:
				{
				State = 5702;
				flattenedQueryNestedTable();
				}
				break;
			case 5:
				{
				State = 5703;
				flattenedQuery();
				}
				break;
			case 6:
				{
				State = 5704;
				jsonTable();
				}
				break;
			}
			State = 5708;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,599,Context) ) {
			case 1:
				{
				State = 5707;
				flashbackAndPivotClauses();
				}
				break;
			}
			State = 5715;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,601,Context) ) {
			case 1:
				{
				State = 5710;
				if (!(IsAliasIdentifier())) throw new FailedPredicateException(this, "IsAliasIdentifier()");
				State = 5712;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,600,Context) ) {
				case 1:
					{
					State = 5711;
					aliasIdentifier();
					}
					break;
				}
				}
				break;
			case 2:
				{
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonTableContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JSON_TABLE() { return GetToken(OracleAntlrParser.JSON_TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonColumnsClauseContext jsonColumnsClause() {
			return GetRuleContext<JsonColumnsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORMAT() { return GetToken(OracleAntlrParser.FORMAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JSON() { return GetToken(OracleAntlrParser.JSON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonExpressionContext jsonExpression() {
			return GetRuleContext<JsonExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonTableOnClauseContext[] jsonTableOnClause() {
			return GetRuleContexts<JsonTableOnClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonTableOnClauseContext jsonTableOnClause(int i) {
			return GetRuleContext<JsonTableOnClauseContext>(i);
		}
		public JsonTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonTable; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonTable(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonTable(this);
		}
	}

	[RuleVersion(0)]
	public JsonTableContext jsonTable() {
		JsonTableContext _localctx = new JsonTableContext(Context, State);
		EnterRule(_localctx, 1120, RULE_jsonTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5717;
			Match(JSON_TABLE);
			State = 5718;
			Match(LPAREN);
			State = 5719;
			fullExpression();
			State = 5722;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FORMAT) {
				{
				State = 5720;
				Match(FORMAT);
				State = 5721;
				Match(JSON);
				}
			}

			State = 5726;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 5724;
				Match(COMMA);
				State = 5725;
				jsonExpression();
				}
			}

			State = 5731;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ERROR || _la==NULL) {
				{
				{
				State = 5728;
				jsonTableOnClause();
				}
				}
				State = 5733;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5734;
			jsonColumnsClause();
			State = 5735;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonTableOnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public JsonTableOnConditionContext jsonTableOnCondition() {
			return GetRuleContext<JsonTableOnConditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EMPTY_KEYWORD() { return GetToken(OracleAntlrParser.EMPTY_KEYWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		public JsonTableOnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonTableOnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonTableOnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonTableOnClause(this);
		}
	}

	[RuleVersion(0)]
	public JsonTableOnClauseContext jsonTableOnClause() {
		JsonTableOnClauseContext _localctx = new JsonTableOnClauseContext(Context, State);
		EnterRule(_localctx, 1122, RULE_jsonTableOnClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5737;
			jsonTableOnCondition();
			State = 5738;
			_la = TokenStream.LA(1);
			if ( !(_la==EMPTY_KEYWORD || _la==ERROR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonTableOnConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public JsonTableOnConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonTableOnCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonTableOnCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonTableOnCondition(this);
		}
	}

	[RuleVersion(0)]
	public JsonTableOnConditionContext jsonTableOnCondition() {
		JsonTableOnConditionContext _localctx = new JsonTableOnConditionContext(Context, State);
		EnterRule(_localctx, 1124, RULE_jsonTableOnCondition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5740;
			_la = TokenStream.LA(1);
			if ( !(_la==ERROR || _la==NULL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5741;
			Match(ON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public JsonExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonExpression(this);
		}
	}

	[RuleVersion(0)]
	public JsonExpressionContext jsonExpression() {
		JsonExpressionContext _localctx = new JsonExpressionContext(Context, State);
		EnterRule(_localctx, 1126, RULE_jsonExpression);
		try {
			State = 5745;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,605,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5743;
				plainIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5744;
				literal();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonColumnsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMNS() { return GetToken(OracleAntlrParser.COLUMNS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonColumnDefinitionContext[] jsonColumnDefinition() {
			return GetRuleContexts<JsonColumnDefinitionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonColumnDefinitionContext jsonColumnDefinition(int i) {
			return GetRuleContext<JsonColumnDefinitionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public JsonColumnsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonColumnsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonColumnsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonColumnsClause(this);
		}
	}

	[RuleVersion(0)]
	public JsonColumnsClauseContext jsonColumnsClause() {
		JsonColumnsClauseContext _localctx = new JsonColumnsClauseContext(Context, State);
		EnterRule(_localctx, 1128, RULE_jsonColumnsClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5747;
			Match(COLUMNS);
			State = 5748;
			Match(LPAREN);
			State = 5749;
			jsonColumnDefinition();
			State = 5754;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5750;
				Match(COMMA);
				State = 5751;
				jsonColumnDefinition();
				}
				}
				State = 5756;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5757;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonColumnDefinitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public JsonExistsColumnContext jsonExistsColumn() {
			return GetRuleContext<JsonExistsColumnContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonQueryColumnContext jsonQueryColumn() {
			return GetRuleContext<JsonQueryColumnContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonValueColumnContext jsonValueColumn() {
			return GetRuleContext<JsonValueColumnContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonNestedPathContext jsonNestedPath() {
			return GetRuleContext<JsonNestedPathContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OrdinalityColumnContext ordinalityColumn() {
			return GetRuleContext<OrdinalityColumnContext>(0);
		}
		public JsonColumnDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonColumnDefinition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonColumnDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonColumnDefinition(this);
		}
	}

	[RuleVersion(0)]
	public JsonColumnDefinitionContext jsonColumnDefinition() {
		JsonColumnDefinitionContext _localctx = new JsonColumnDefinitionContext(Context, State);
		EnterRule(_localctx, 1130, RULE_jsonColumnDefinition);
		try {
			State = 5764;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,607,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5759;
				jsonExistsColumn();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5760;
				jsonQueryColumn();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5761;
				jsonValueColumn();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5762;
				jsonNestedPath();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5763;
				ordinalityColumn();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonExistsColumnContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(OracleAntlrParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(OracleAntlrParser.PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonExpressionContext jsonExpression() {
			return GetRuleContext<JsonExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonExistsOnClauseContext[] jsonExistsOnClause() {
			return GetRuleContexts<JsonExistsOnClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonExistsOnClauseContext jsonExistsOnClause(int i) {
			return GetRuleContext<JsonExistsOnClauseContext>(i);
		}
		public JsonExistsColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonExistsColumn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonExistsColumn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonExistsColumn(this);
		}
	}

	[RuleVersion(0)]
	public JsonExistsColumnContext jsonExistsColumn() {
		JsonExistsColumnContext _localctx = new JsonExistsColumnContext(Context, State);
		EnterRule(_localctx, 1132, RULE_jsonExistsColumn);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5766;
			plainIdentifier();
			State = 5768;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,608,Context) ) {
			case 1:
				{
				State = 5767;
				typeReference();
				}
				break;
			}
			State = 5770;
			Match(EXISTS);
			State = 5773;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PATH) {
				{
				State = 5771;
				Match(PATH);
				State = 5772;
				jsonExpression();
				}
			}

			State = 5778;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ERROR || _la==FALSE || _la==TRUE) {
				{
				{
				State = 5775;
				jsonExistsOnClause();
				}
				}
				State = 5780;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonExistsOnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public JsonExistsOnConditionContext jsonExistsOnCondition() {
			return GetRuleContext<JsonExistsOnConditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EMPTY_KEYWORD() { return GetToken(OracleAntlrParser.EMPTY_KEYWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		public JsonExistsOnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonExistsOnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonExistsOnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonExistsOnClause(this);
		}
	}

	[RuleVersion(0)]
	public JsonExistsOnClauseContext jsonExistsOnClause() {
		JsonExistsOnClauseContext _localctx = new JsonExistsOnClauseContext(Context, State);
		EnterRule(_localctx, 1134, RULE_jsonExistsOnClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5781;
			jsonExistsOnCondition();
			State = 5782;
			_la = TokenStream.LA(1);
			if ( !(_la==EMPTY_KEYWORD || _la==ERROR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonExistsOnConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUE() { return GetToken(OracleAntlrParser.TRUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FALSE() { return GetToken(OracleAntlrParser.FALSE, 0); }
		public JsonExistsOnConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonExistsOnCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonExistsOnCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonExistsOnCondition(this);
		}
	}

	[RuleVersion(0)]
	public JsonExistsOnConditionContext jsonExistsOnCondition() {
		JsonExistsOnConditionContext _localctx = new JsonExistsOnConditionContext(Context, State);
		EnterRule(_localctx, 1136, RULE_jsonExistsOnCondition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5784;
			_la = TokenStream.LA(1);
			if ( !(_la==ERROR || _la==FALSE || _la==TRUE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5785;
			Match(ON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonQueryColumnContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORMAT() { return GetToken(OracleAntlrParser.FORMAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JSON() { return GetToken(OracleAntlrParser.JSON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUNCATE() { return GetToken(OracleAntlrParser.TRUNCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonQueryWrapperClauseContext jsonQueryWrapperClause() {
			return GetRuleContext<JsonQueryWrapperClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(OracleAntlrParser.PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonExpressionContext jsonExpression() {
			return GetRuleContext<JsonExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonQueryOnClauseContext[] jsonQueryOnClause() {
			return GetRuleContexts<JsonQueryOnClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonQueryOnClauseContext jsonQueryOnClause(int i) {
			return GetRuleContext<JsonQueryOnClauseContext>(i);
		}
		public JsonQueryColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonQueryColumn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonQueryColumn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonQueryColumn(this);
		}
	}

	[RuleVersion(0)]
	public JsonQueryColumnContext jsonQueryColumn() {
		JsonQueryColumnContext _localctx = new JsonQueryColumnContext(Context, State);
		EnterRule(_localctx, 1138, RULE_jsonQueryColumn);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5787;
			plainIdentifier();
			State = 5789;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,611,Context) ) {
			case 1:
				{
				State = 5788;
				typeReference();
				}
				break;
			}
			State = 5792;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TRUNCATE) {
				{
				State = 5791;
				Match(TRUNCATE);
				}
			}

			State = 5794;
			Match(FORMAT);
			State = 5795;
			Match(JSON);
			State = 5797;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH || _la==WITHOUT) {
				{
				State = 5796;
				jsonQueryWrapperClause();
				}
			}

			State = 5801;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PATH) {
				{
				State = 5799;
				Match(PATH);
				State = 5800;
				jsonExpression();
				}
			}

			State = 5806;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==EMPTY_KEYWORD || _la==ERROR || _la==NULL) {
				{
				{
				State = 5803;
				jsonQueryOnClause();
				}
				}
				State = 5808;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonQueryWrapperClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRAPPER() { return GetToken(OracleAntlrParser.WRAPPER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITHOUT() { return GetToken(OracleAntlrParser.WITHOUT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARRAY() { return GetToken(OracleAntlrParser.ARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONDITIONAL() { return GetToken(OracleAntlrParser.CONDITIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNCONDITIONAL() { return GetToken(OracleAntlrParser.UNCONDITIONAL, 0); }
		public JsonQueryWrapperClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonQueryWrapperClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonQueryWrapperClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonQueryWrapperClause(this);
		}
	}

	[RuleVersion(0)]
	public JsonQueryWrapperClauseContext jsonQueryWrapperClause() {
		JsonQueryWrapperClauseContext _localctx = new JsonQueryWrapperClauseContext(Context, State);
		EnterRule(_localctx, 1140, RULE_jsonQueryWrapperClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5814;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WITH:
				{
				State = 5809;
				Match(WITH);
				State = 5811;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONDITIONAL || _la==UNCONDITIONAL) {
					{
					State = 5810;
					_la = TokenStream.LA(1);
					if ( !(_la==CONDITIONAL || _la==UNCONDITIONAL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			case WITHOUT:
				{
				State = 5813;
				Match(WITHOUT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5817;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ARRAY) {
				{
				State = 5816;
				Match(ARRAY);
				}
			}

			State = 5819;
			Match(WRAPPER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonQueryOnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public JsonQueryOnConditionContext jsonQueryOnCondition() {
			return GetRuleContext<JsonQueryOnConditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EMPTY_KEYWORD() { return GetToken(OracleAntlrParser.EMPTY_KEYWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		public JsonQueryOnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonQueryOnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonQueryOnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonQueryOnClause(this);
		}
	}

	[RuleVersion(0)]
	public JsonQueryOnClauseContext jsonQueryOnClause() {
		JsonQueryOnClauseContext _localctx = new JsonQueryOnClauseContext(Context, State);
		EnterRule(_localctx, 1142, RULE_jsonQueryOnClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5821;
			jsonQueryOnCondition();
			State = 5822;
			_la = TokenStream.LA(1);
			if ( !(_la==EMPTY_KEYWORD || _la==ERROR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonQueryOnConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EMPTY_KEYWORD() { return GetToken(OracleAntlrParser.EMPTY_KEYWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARRAY() { return GetToken(OracleAntlrParser.ARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(OracleAntlrParser.OBJECT, 0); }
		public JsonQueryOnConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonQueryOnCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonQueryOnCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonQueryOnCondition(this);
		}
	}

	[RuleVersion(0)]
	public JsonQueryOnConditionContext jsonQueryOnCondition() {
		JsonQueryOnConditionContext _localctx = new JsonQueryOnConditionContext(Context, State);
		EnterRule(_localctx, 1144, RULE_jsonQueryOnCondition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5830;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ERROR:
				{
				State = 5824;
				Match(ERROR);
				}
				break;
			case NULL:
				{
				State = 5825;
				Match(NULL);
				}
				break;
			case EMPTY_KEYWORD:
				{
				State = 5826;
				Match(EMPTY_KEYWORD);
				State = 5828;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ARRAY || _la==OBJECT) {
					{
					State = 5827;
					_la = TokenStream.LA(1);
					if ( !(_la==ARRAY || _la==OBJECT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5832;
			Match(ON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonValueColumnContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUNCATE() { return GetToken(OracleAntlrParser.TRUNCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(OracleAntlrParser.PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonExpressionContext jsonExpression() {
			return GetRuleContext<JsonExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonValueOnClauseContext[] jsonValueOnClause() {
			return GetRuleContexts<JsonValueOnClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonValueOnClauseContext jsonValueOnClause(int i) {
			return GetRuleContext<JsonValueOnClauseContext>(i);
		}
		public JsonValueColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonValueColumn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonValueColumn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonValueColumn(this);
		}
	}

	[RuleVersion(0)]
	public JsonValueColumnContext jsonValueColumn() {
		JsonValueColumnContext _localctx = new JsonValueColumnContext(Context, State);
		EnterRule(_localctx, 1146, RULE_jsonValueColumn);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5834;
			plainIdentifier();
			State = 5836;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,621,Context) ) {
			case 1:
				{
				State = 5835;
				typeReference();
				}
				break;
			}
			State = 5839;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TRUNCATE) {
				{
				State = 5838;
				Match(TRUNCATE);
				}
			}

			State = 5843;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PATH) {
				{
				State = 5841;
				Match(PATH);
				State = 5842;
				jsonExpression();
				}
			}

			State = 5848;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DEFAULT || _la==ERROR || _la==NULL) {
				{
				{
				State = 5845;
				jsonValueOnClause();
				}
				}
				State = 5850;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonValueOnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public JsonValueOnConditionContext jsonValueOnCondition() {
			return GetRuleContext<JsonValueOnConditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EMPTY_KEYWORD() { return GetToken(OracleAntlrParser.EMPTY_KEYWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		public JsonValueOnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonValueOnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonValueOnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonValueOnClause(this);
		}
	}

	[RuleVersion(0)]
	public JsonValueOnClauseContext jsonValueOnClause() {
		JsonValueOnClauseContext _localctx = new JsonValueOnClauseContext(Context, State);
		EnterRule(_localctx, 1148, RULE_jsonValueOnClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5851;
			jsonValueOnCondition();
			State = 5852;
			_la = TokenStream.LA(1);
			if ( !(_la==EMPTY_KEYWORD || _la==ERROR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonValueOnConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public JsonValueOnConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonValueOnCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonValueOnCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonValueOnCondition(this);
		}
	}

	[RuleVersion(0)]
	public JsonValueOnConditionContext jsonValueOnCondition() {
		JsonValueOnConditionContext _localctx = new JsonValueOnConditionContext(Context, State);
		EnterRule(_localctx, 1150, RULE_jsonValueOnCondition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5858;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ERROR:
				{
				State = 5854;
				Match(ERROR);
				}
				break;
			case NULL:
				{
				State = 5855;
				Match(NULL);
				}
				break;
			case DEFAULT:
				{
				State = 5856;
				Match(DEFAULT);
				State = 5857;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5860;
			Match(ON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonNestedPathContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NESTED() { return GetToken(OracleAntlrParser.NESTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonExpressionContext jsonExpression() {
			return GetRuleContext<JsonExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonColumnsClauseContext jsonColumnsClause() {
			return GetRuleContext<JsonColumnsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(OracleAntlrParser.PATH, 0); }
		public JsonNestedPathContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonNestedPath; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterJsonNestedPath(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitJsonNestedPath(this);
		}
	}

	[RuleVersion(0)]
	public JsonNestedPathContext jsonNestedPath() {
		JsonNestedPathContext _localctx = new JsonNestedPathContext(Context, State);
		EnterRule(_localctx, 1152, RULE_jsonNestedPath);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5862;
			Match(NESTED);
			State = 5864;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,626,Context) ) {
			case 1:
				{
				State = 5863;
				Match(PATH);
				}
				break;
			}
			State = 5866;
			jsonExpression();
			State = 5867;
			jsonColumnsClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrdinalityColumnContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDINALITY() { return GetToken(OracleAntlrParser.ORDINALITY, 0); }
		public OrdinalityColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ordinalityColumn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOrdinalityColumn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOrdinalityColumn(this);
		}
	}

	[RuleVersion(0)]
	public OrdinalityColumnContext ordinalityColumn() {
		OrdinalityColumnContext _localctx = new OrdinalityColumnContext(Context, State);
		EnterRule(_localctx, 1154, RULE_ordinalityColumn);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5869;
			plainIdentifier();
			State = 5870;
			Match(FOR);
			State = 5871;
			Match(ORDINALITY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlashbackAndPivotClausesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PivotUnpivotClauseContext pivotUnpivotClause() {
			return GetRuleContext<PivotUnpivotClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PeriodSpecificationContext periodSpecification() {
			return GetRuleContext<PeriodSpecificationContext>(0);
		}
		public FlashbackAndPivotClausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flashbackAndPivotClauses; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFlashbackAndPivotClauses(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFlashbackAndPivotClauses(this);
		}
	}

	[RuleVersion(0)]
	public FlashbackAndPivotClausesContext flashbackAndPivotClauses() {
		FlashbackAndPivotClausesContext _localctx = new FlashbackAndPivotClausesContext(Context, State);
		EnterRule(_localctx, 1156, RULE_flashbackAndPivotClauses);
		try {
			State = 5881;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PIVOT:
			case UNPIVOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5873;
				pivotUnpivotClause();
				State = 5875;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,627,Context) ) {
				case 1:
					{
					State = 5874;
					periodSpecification();
					}
					break;
				}
				}
				break;
			case AS:
			case VERSIONS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5877;
				periodSpecification();
				State = 5879;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,628,Context) ) {
				case 1:
					{
					State = 5878;
					pivotUnpivotClause();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTableItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLTABLE() { return GetToken(OracleAntlrParser.XMLTABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTableOptionsContext xmlTableOptions() {
			return GetRuleContext<XmlTableOptionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlNamespacesClauseContext xmlNamespacesClause() {
			return GetRuleContext<XmlNamespacesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		public XmlTableItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTableItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlTableItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlTableItem(this);
		}
	}

	[RuleVersion(0)]
	public XmlTableItemContext xmlTableItem() {
		XmlTableItemContext _localctx = new XmlTableItemContext(Context, State);
		EnterRule(_localctx, 1158, RULE_xmlTableItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5883;
			Match(XMLTABLE);
			State = 5884;
			Match(LPAREN);
			State = 5888;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==XMLNAMESPACES) {
				{
				State = 5885;
				xmlNamespacesClause();
				State = 5886;
				Match(COMMA);
				}
			}

			State = 5890;
			literal();
			State = 5891;
			xmlTableOptions();
			State = 5892;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlNamespacesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLNAMESPACES() { return GetToken(OracleAntlrParser.XMLNAMESPACES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public XmlNamespacesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlNamespacesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlNamespacesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlNamespacesClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlNamespacesClauseContext xmlNamespacesClause() {
		XmlNamespacesClauseContext _localctx = new XmlNamespacesClauseContext(Context, State);
		EnterRule(_localctx, 1160, RULE_xmlNamespacesClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5894;
			Match(XMLNAMESPACES);
			State = 5895;
			Match(LPAREN);
			State = 5897;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,631,Context) ) {
			case 1:
				{
				State = 5896;
				expressionList();
				}
				break;
			}
			State = 5901;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT) {
				{
				State = 5899;
				Match(DEFAULT);
				State = 5900;
				literal();
				}
			}

			State = 5903;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTableOptionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public XmlParsingClauseContext xmlParsingClause() {
			return GetRuleContext<XmlParsingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMNS() { return GetToken(OracleAntlrParser.COLUMNS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlTableColumnContext[] xmlTableColumn() {
			return GetRuleContexts<XmlTableColumnContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTableColumnContext xmlTableColumn(int i) {
			return GetRuleContext<XmlTableColumnContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public XmlTableOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTableOptions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlTableOptions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlTableOptions(this);
		}
	}

	[RuleVersion(0)]
	public XmlTableOptionsContext xmlTableOptions() {
		XmlTableOptionsContext _localctx = new XmlTableOptionsContext(Context, State);
		EnterRule(_localctx, 1162, RULE_xmlTableOptions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5906;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PASSING) {
				{
				State = 5905;
				xmlParsingClause();
				}
			}

			State = 5917;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLUMNS) {
				{
				State = 5908;
				Match(COLUMNS);
				State = 5909;
				xmlTableColumn();
				State = 5914;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 5910;
					Match(COMMA);
					State = 5911;
					xmlTableColumn();
					}
					}
					State = 5916;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlParsingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSING() { return GetToken(OracleAntlrParser.PASSING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(OracleAntlrParser.VALUE, 0); }
		public XmlParsingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlParsingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlParsingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlParsingClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlParsingClauseContext xmlParsingClause() {
		XmlParsingClauseContext _localctx = new XmlParsingClauseContext(Context, State);
		EnterRule(_localctx, 1164, RULE_xmlParsingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5919;
			Match(PASSING);
			State = 5922;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BY) {
				{
				State = 5920;
				Match(BY);
				State = 5921;
				Match(VALUE);
				}
			}

			State = 5924;
			expressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTableColumnContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDINALITY() { return GetToken(OracleAntlrParser.ORDINALITY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(OracleAntlrParser.PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		public XmlTableColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTableColumn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterXmlTableColumn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitXmlTableColumn(this);
		}
	}

	[RuleVersion(0)]
	public XmlTableColumnContext xmlTableColumn() {
		XmlTableColumnContext _localctx = new XmlTableColumnContext(Context, State);
		EnterRule(_localctx, 1166, RULE_xmlTableColumn);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5926;
			fullExpression();
			State = 5938;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FOR:
				{
				State = 5927;
				Match(FOR);
				State = 5928;
				Match(ORDINALITY);
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case NVARCHAR2:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case LPAREN:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 5929;
				typeReference();
				State = 5932;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PATH) {
					{
					State = 5930;
					Match(PATH);
					State = 5931;
					literal();
					}
				}

				State = 5936;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 5934;
					Match(DEFAULT);
					State = 5935;
					fullExpression();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotUnpivotClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PivotClauseContext pivotClause() {
			return GetRuleContext<PivotClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnpivotClauseContext unpivotClause() {
			return GetRuleContext<UnpivotClauseContext>(0);
		}
		public PivotUnpivotClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotUnpivotClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPivotUnpivotClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPivotUnpivotClause(this);
		}
	}

	[RuleVersion(0)]
	public PivotUnpivotClauseContext pivotUnpivotClause() {
		PivotUnpivotClauseContext _localctx = new PivotUnpivotClauseContext(Context, State);
		EnterRule(_localctx, 1168, RULE_pivotUnpivotClause);
		try {
			State = 5942;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PIVOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5940;
				pivotClause();
				}
				break;
			case UNPIVOT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5941;
				unpivotClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PIVOT() { return GetToken(OracleAntlrParser.PIVOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PivotBodyContext pivotBody() {
			return GetRuleContext<PivotBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XML() { return GetToken(OracleAntlrParser.XML, 0); }
		public PivotClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPivotClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPivotClause(this);
		}
	}

	[RuleVersion(0)]
	public PivotClauseContext pivotClause() {
		PivotClauseContext _localctx = new PivotClauseContext(Context, State);
		EnterRule(_localctx, 1170, RULE_pivotClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5944;
			Match(PIVOT);
			State = 5946;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==XML) {
				{
				State = 5945;
				Match(XML);
				}
			}

			State = 5948;
			pivotBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PivotForClauseContext pivotForClause() {
			return GetRuleContext<PivotForClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PivotInClauseContext pivotInClause() {
			return GetRuleContext<PivotInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public PivotBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPivotBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPivotBody(this);
		}
	}

	[RuleVersion(0)]
	public PivotBodyContext pivotBody() {
		PivotBodyContext _localctx = new PivotBodyContext(Context, State);
		EnterRule(_localctx, 1172, RULE_pivotBody);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5950;
			Match(LPAREN);
			State = 5951;
			expressionList();
			State = 5952;
			pivotForClause();
			State = 5953;
			pivotInClause();
			State = 5954;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotForClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierOrIdentifierListContext identifierOrIdentifierList() {
			return GetRuleContext<IdentifierOrIdentifierListContext>(0);
		}
		public PivotForClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotForClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPivotForClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPivotForClause(this);
		}
	}

	[RuleVersion(0)]
	public PivotForClauseContext pivotForClause() {
		PivotForClauseContext _localctx = new PivotForClauseContext(Context, State);
		EnterRule(_localctx, 1174, RULE_pivotForClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5956;
			Match(FOR);
			State = 5957;
			identifierOrIdentifierList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierOrIdentifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PivotUnpivotIdentifierListContext pivotUnpivotIdentifierList() {
			return GetRuleContext<PivotUnpivotIdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public IdentifierOrIdentifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierOrIdentifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentifierOrIdentifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentifierOrIdentifierList(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierOrIdentifierListContext identifierOrIdentifierList() {
		IdentifierOrIdentifierListContext _localctx = new IdentifierOrIdentifierListContext(Context, State);
		EnterRule(_localctx, 1176, RULE_identifierOrIdentifierList);
		try {
			State = 5961;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5959;
				pivotUnpivotIdentifierList();
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5960;
				identifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotUnpivotIdentifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public PivotUnpivotIdentifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotUnpivotIdentifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPivotUnpivotIdentifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPivotUnpivotIdentifierList(this);
		}
	}

	[RuleVersion(0)]
	public PivotUnpivotIdentifierListContext pivotUnpivotIdentifierList() {
		PivotUnpivotIdentifierListContext _localctx = new PivotUnpivotIdentifierListContext(Context, State);
		EnterRule(_localctx, 1178, RULE_pivotUnpivotIdentifierList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5963;
			Match(LPAREN);
			State = 5964;
			identifierList();
			State = 5965;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotInClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PivotInExpressionListContext pivotInExpressionList() {
			return GetRuleContext<PivotInExpressionListContext>(0);
		}
		public PivotInClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotInClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPivotInClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPivotInClause(this);
		}
	}

	[RuleVersion(0)]
	public PivotInClauseContext pivotInClause() {
		PivotInClauseContext _localctx = new PivotInClauseContext(Context, State);
		EnterRule(_localctx, 1180, RULE_pivotInClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5967;
			Match(IN);
			State = 5970;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,643,Context) ) {
			case 1:
				{
				State = 5968;
				flattenedQuery();
				}
				break;
			case 2:
				{
				State = 5969;
				pivotInExpressionList();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotInExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PivotInExpressionListItemContext[] pivotInExpressionListItem() {
			return GetRuleContexts<PivotInExpressionListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PivotInExpressionListItemContext pivotInExpressionListItem(int i) {
			return GetRuleContext<PivotInExpressionListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public PivotInExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotInExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPivotInExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPivotInExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public PivotInExpressionListContext pivotInExpressionList() {
		PivotInExpressionListContext _localctx = new PivotInExpressionListContext(Context, State);
		EnterRule(_localctx, 1182, RULE_pivotInExpressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5972;
			Match(LPAREN);
			State = 5973;
			pivotInExpressionListItem();
			State = 5978;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5974;
				Match(COMMA);
				State = 5975;
				pivotInExpressionListItem();
				}
				}
				State = 5980;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5981;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotInExpressionListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PivotAnyContext pivotAny() {
			return GetRuleContext<PivotAnyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionOrExpressionListContext expressionOrExpressionList() {
			return GetRuleContext<ExpressionOrExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AliasContext alias() {
			return GetRuleContext<AliasContext>(0);
		}
		public PivotInExpressionListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotInExpressionListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPivotInExpressionListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPivotInExpressionListItem(this);
		}
	}

	[RuleVersion(0)]
	public PivotInExpressionListItemContext pivotInExpressionListItem() {
		PivotInExpressionListItemContext _localctx = new PivotInExpressionListItemContext(Context, State);
		EnterRule(_localctx, 1184, RULE_pivotInExpressionListItem);
		int _la;
		try {
			State = 5988;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ANY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5983;
				pivotAny();
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CASE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case EXTRACTVALUE:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULL:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYS_CONNECT_BY_PATH:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLCAST:
			case XMLNAMESPACES:
			case XMLQUERY:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case INTEGER_LITERAL:
			case LPAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case QUESTION_MARK:
			case ASTERISK:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
			case QUOTE_CHARACTER_STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5984;
				expressionOrExpressionList();
				State = 5986;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
					{
					State = 5985;
					alias();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotAnyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY() { return GetToken(OracleAntlrParser.ANY, 0); }
		public PivotAnyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotAny; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPivotAny(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPivotAny(this);
		}
	}

	[RuleVersion(0)]
	public PivotAnyContext pivotAny() {
		PivotAnyContext _localctx = new PivotAnyContext(Context, State);
		EnterRule(_localctx, 1186, RULE_pivotAny);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5990;
			Match(ANY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionOrExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PivotExpressionListContext pivotExpressionList() {
			return GetRuleContext<PivotExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public ExpressionOrExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionOrExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExpressionOrExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExpressionOrExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionOrExpressionListContext expressionOrExpressionList() {
		ExpressionOrExpressionListContext _localctx = new ExpressionOrExpressionListContext(Context, State);
		EnterRule(_localctx, 1188, RULE_expressionOrExpressionList);
		try {
			State = 5994;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,647,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5992;
				pivotExpressionList();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5993;
				fullExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public PivotExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPivotExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPivotExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public PivotExpressionListContext pivotExpressionList() {
		PivotExpressionListContext _localctx = new PivotExpressionListContext(Context, State);
		EnterRule(_localctx, 1190, RULE_pivotExpressionList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5996;
			Match(LPAREN);
			State = 5997;
			expressionList();
			State = 5998;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnpivotClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNPIVOT() { return GetToken(OracleAntlrParser.UNPIVOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnpivotBodyContext unpivotBody() {
			return GetRuleContext<UnpivotBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDE() { return GetToken(OracleAntlrParser.INCLUDE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULLS() { return GetToken(OracleAntlrParser.NULLS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLUDE() { return GetToken(OracleAntlrParser.EXCLUDE, 0); }
		public UnpivotClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivotClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUnpivotClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUnpivotClause(this);
		}
	}

	[RuleVersion(0)]
	public UnpivotClauseContext unpivotClause() {
		UnpivotClauseContext _localctx = new UnpivotClauseContext(Context, State);
		EnterRule(_localctx, 1192, RULE_unpivotClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6000;
			Match(UNPIVOT);
			State = 6005;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INCLUDE:
				{
				State = 6001;
				Match(INCLUDE);
				State = 6002;
				Match(NULLS);
				}
				break;
			case EXCLUDE:
				{
				State = 6003;
				Match(EXCLUDE);
				State = 6004;
				Match(NULLS);
				}
				break;
			case LPAREN:
				break;
			default:
				break;
			}
			State = 6007;
			unpivotBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnpivotBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierOrIdentifierListContext identifierOrIdentifierList() {
			return GetRuleContext<IdentifierOrIdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PivotForClauseContext pivotForClause() {
			return GetRuleContext<PivotForClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnpivotInClauseContext unpivotInClause() {
			return GetRuleContext<UnpivotInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public UnpivotBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivotBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUnpivotBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUnpivotBody(this);
		}
	}

	[RuleVersion(0)]
	public UnpivotBodyContext unpivotBody() {
		UnpivotBodyContext _localctx = new UnpivotBodyContext(Context, State);
		EnterRule(_localctx, 1194, RULE_unpivotBody);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6009;
			Match(LPAREN);
			State = 6010;
			identifierOrIdentifierList();
			State = 6011;
			pivotForClause();
			State = 6012;
			unpivotInClause();
			State = 6013;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnpivotInClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnpivotInExpressionListContext unpivotInExpressionList() {
			return GetRuleContext<UnpivotInExpressionListContext>(0);
		}
		public UnpivotInClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivotInClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUnpivotInClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUnpivotInClause(this);
		}
	}

	[RuleVersion(0)]
	public UnpivotInClauseContext unpivotInClause() {
		UnpivotInClauseContext _localctx = new UnpivotInClauseContext(Context, State);
		EnterRule(_localctx, 1196, RULE_unpivotInClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6015;
			Match(IN);
			State = 6016;
			unpivotInExpressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnpivotInExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnpivotInExpressionListItemContext[] unpivotInExpressionListItem() {
			return GetRuleContexts<UnpivotInExpressionListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnpivotInExpressionListItemContext unpivotInExpressionListItem(int i) {
			return GetRuleContext<UnpivotInExpressionListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public UnpivotInExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivotInExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUnpivotInExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUnpivotInExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public UnpivotInExpressionListContext unpivotInExpressionList() {
		UnpivotInExpressionListContext _localctx = new UnpivotInExpressionListContext(Context, State);
		EnterRule(_localctx, 1198, RULE_unpivotInExpressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6018;
			Match(LPAREN);
			State = 6019;
			unpivotInExpressionListItem();
			State = 6024;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 6020;
				Match(COMMA);
				State = 6021;
				unpivotInExpressionListItem();
				}
				}
				State = 6026;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6027;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnpivotInExpressionListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierOrIdentifierListContext identifierOrIdentifierList() {
			return GetRuleContext<IdentifierOrIdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralOrLiteralListAliasContext literalOrLiteralListAlias() {
			return GetRuleContext<LiteralOrLiteralListAliasContext>(0);
		}
		public UnpivotInExpressionListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivotInExpressionListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUnpivotInExpressionListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUnpivotInExpressionListItem(this);
		}
	}

	[RuleVersion(0)]
	public UnpivotInExpressionListItemContext unpivotInExpressionListItem() {
		UnpivotInExpressionListItemContext _localctx = new UnpivotInExpressionListItemContext(Context, State);
		EnterRule(_localctx, 1200, RULE_unpivotInExpressionListItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6029;
			identifierOrIdentifierList();
			State = 6031;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 6030;
				literalOrLiteralListAlias();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralOrLiteralListAliasContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralOrLiteralListContext literalOrLiteralList() {
			return GetRuleContext<LiteralOrLiteralListContext>(0);
		}
		public LiteralOrLiteralListAliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalOrLiteralListAlias; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLiteralOrLiteralListAlias(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLiteralOrLiteralListAlias(this);
		}
	}

	[RuleVersion(0)]
	public LiteralOrLiteralListAliasContext literalOrLiteralListAlias() {
		LiteralOrLiteralListAliasContext _localctx = new LiteralOrLiteralListAliasContext(Context, State);
		EnterRule(_localctx, 1202, RULE_literalOrLiteralListAlias);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6033;
			Match(AS);
			State = 6034;
			literalOrLiteralList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralOrLiteralListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LiteralListWithParenthesisContext literalListWithParenthesis() {
			return GetRuleContext<LiteralListWithParenthesisContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public LiteralOrLiteralListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalOrLiteralList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLiteralOrLiteralList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLiteralOrLiteralList(this);
		}
	}

	[RuleVersion(0)]
	public LiteralOrLiteralListContext literalOrLiteralList() {
		LiteralOrLiteralListContext _localctx = new LiteralOrLiteralListContext(Context, State);
		EnterRule(_localctx, 1204, RULE_literalOrLiteralList);
		try {
			State = 6038;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6036;
				literalListWithParenthesis();
				}
				break;
			case DATE:
			case FALSE:
			case INTERVAL:
			case TIMESTAMP:
			case TRUE:
			case INTEGER_LITERAL:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case QUOTE_CHARACTER_STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6037;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralListWithParenthesisContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext[] literal() {
			return GetRuleContexts<LiteralContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal(int i) {
			return GetRuleContext<LiteralContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public LiteralListWithParenthesisContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalListWithParenthesis; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLiteralListWithParenthesis(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLiteralListWithParenthesis(this);
		}
	}

	[RuleVersion(0)]
	public LiteralListWithParenthesisContext literalListWithParenthesis() {
		LiteralListWithParenthesisContext _localctx = new LiteralListWithParenthesisContext(Context, State);
		EnterRule(_localctx, 1206, RULE_literalListWithParenthesis);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6040;
			Match(LPAREN);
			State = 6041;
			literal();
			State = 6046;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 6042;
				Match(COMMA);
				State = 6043;
				literal();
				}
				}
				State = 6048;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6049;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PeriodSpecificationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PeriodAsOfClauseContext periodAsOfClause() {
			return GetRuleContext<PeriodAsOfClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PeriodBetweenClauseContext periodBetweenClause() {
			return GetRuleContext<PeriodBetweenClauseContext>(0);
		}
		public PeriodSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_periodSpecification; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPeriodSpecification(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPeriodSpecification(this);
		}
	}

	[RuleVersion(0)]
	public PeriodSpecificationContext periodSpecification() {
		PeriodSpecificationContext _localctx = new PeriodSpecificationContext(Context, State);
		EnterRule(_localctx, 1208, RULE_periodSpecification);
		try {
			State = 6053;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6051;
				periodAsOfClause();
				}
				break;
			case VERSIONS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6052;
				periodBetweenClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PeriodAsOfClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FlashBackTypeContext flashBackType() {
			return GetRuleContext<FlashBackTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PeriodForTimeColumnContext periodForTimeColumn() {
			return GetRuleContext<PeriodForTimeColumnContext>(0);
		}
		public PeriodAsOfClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_periodAsOfClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPeriodAsOfClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPeriodAsOfClause(this);
		}
	}

	[RuleVersion(0)]
	public PeriodAsOfClauseContext periodAsOfClause() {
		PeriodAsOfClauseContext _localctx = new PeriodAsOfClauseContext(Context, State);
		EnterRule(_localctx, 1210, RULE_periodAsOfClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6055;
			Match(AS);
			State = 6056;
			Match(OF);
			State = 6061;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SCN:
			case TIMESTAMP:
				{
				State = 6057;
				flashBackType();
				State = 6058;
				expressionList();
				}
				break;
			case PERIOD:
				{
				State = 6060;
				periodForTimeColumn();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PeriodBetweenClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VERSIONS() { return GetToken(OracleAntlrParser.VERSIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext[] pureExpression() {
			return GetRuleContexts<PureExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression(int i) {
			return GetRuleContext<PureExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(OracleAntlrParser.AND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BETWEEN() { return GetToken(OracleAntlrParser.BETWEEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FlashBackTypeContext flashBackType() {
			return GetRuleContext<FlashBackTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PeriodForTimeColumnContext periodForTimeColumn() {
			return GetRuleContext<PeriodForTimeColumnContext>(0);
		}
		public PeriodBetweenClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_periodBetweenClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPeriodBetweenClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPeriodBetweenClause(this);
		}
	}

	[RuleVersion(0)]
	public PeriodBetweenClauseContext periodBetweenClause() {
		PeriodBetweenClauseContext _localctx = new PeriodBetweenClauseContext(Context, State);
		EnterRule(_localctx, 1212, RULE_periodBetweenClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6063;
			Match(VERSIONS);
			State = 6067;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BETWEEN:
				{
				State = 6064;
				Match(BETWEEN);
				State = 6065;
				flashBackType();
				}
				break;
			case PERIOD:
				{
				State = 6066;
				periodForTimeColumn();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6069;
			pureExpression();
			State = 6070;
			Match(AND);
			State = 6071;
			pureExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PeriodForTimeColumnContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERIOD() { return GetToken(OracleAntlrParser.PERIOD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BETWEEN() { return GetToken(OracleAntlrParser.BETWEEN, 0); }
		public PeriodForTimeColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_periodForTimeColumn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPeriodForTimeColumn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPeriodForTimeColumn(this);
		}
	}

	[RuleVersion(0)]
	public PeriodForTimeColumnContext periodForTimeColumn() {
		PeriodForTimeColumnContext _localctx = new PeriodForTimeColumnContext(Context, State);
		EnterRule(_localctx, 1214, RULE_periodForTimeColumn);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6073;
			Match(PERIOD);
			State = 6074;
			Match(FOR);
			State = 6075;
			identifier();
			State = 6078;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CASE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case EXTRACTVALUE:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULL:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYS_CONNECT_BY_PATH:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLCAST:
			case XMLNAMESPACES:
			case XMLQUERY:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case INTEGER_LITERAL:
			case LPAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case QUESTION_MARK:
			case ASTERISK:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
			case QUOTE_CHARACTER_STRING_LITERAL:
				{
				State = 6076;
				fullExpression();
				}
				break;
			case BETWEEN:
				{
				State = 6077;
				Match(BETWEEN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlashBackTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMESTAMP() { return GetToken(OracleAntlrParser.TIMESTAMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCN() { return GetToken(OracleAntlrParser.SCN, 0); }
		public FlashBackTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flashBackType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFlashBackType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFlashBackType(this);
		}
	}

	[RuleVersion(0)]
	public FlashBackTypeContext flashBackType() {
		FlashBackTypeContext _localctx = new FlashBackTypeContext(Context, State);
		EnterRule(_localctx, 1216, RULE_flashBackType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6080;
			_la = TokenStream.LA(1);
			if ( !(_la==SCN || _la==TIMESTAMP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SampleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SAMPLE() { return GetToken(OracleAntlrParser.SAMPLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SampleClauseValuesContext sampleClauseValues() {
			return GetRuleContext<SampleClauseValuesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BLOCK() { return GetToken(OracleAntlrParser.BLOCK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SampleSeedClauseContext sampleSeedClause() {
			return GetRuleContext<SampleSeedClauseContext>(0);
		}
		public SampleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sampleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSampleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSampleClause(this);
		}
	}

	[RuleVersion(0)]
	public SampleClauseContext sampleClause() {
		SampleClauseContext _localctx = new SampleClauseContext(Context, State);
		EnterRule(_localctx, 1218, RULE_sampleClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6082;
			Match(SAMPLE);
			State = 6084;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BLOCK) {
				{
				State = 6083;
				Match(BLOCK);
				}
			}

			State = 6086;
			sampleClauseValues();
			State = 6088;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,658,Context) ) {
			case 1:
				{
				State = 6087;
				sampleSeedClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SampleSeedClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEED() { return GetToken(OracleAntlrParser.SEED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SampleClauseValuesContext sampleClauseValues() {
			return GetRuleContext<SampleClauseValuesContext>(0);
		}
		public SampleSeedClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sampleSeedClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSampleSeedClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSampleSeedClause(this);
		}
	}

	[RuleVersion(0)]
	public SampleSeedClauseContext sampleSeedClause() {
		SampleSeedClauseContext _localctx = new SampleSeedClauseContext(Context, State);
		EnterRule(_localctx, 1220, RULE_sampleSeedClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6090;
			Match(SEED);
			State = 6091;
			sampleClauseValues();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SampleClauseValuesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public SampleClauseValuesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sampleClauseValues; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSampleClauseValues(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSampleClauseValues(this);
		}
	}

	[RuleVersion(0)]
	public SampleClauseValuesContext sampleClauseValues() {
		SampleClauseValuesContext _localctx = new SampleClauseValuesContext(Context, State);
		EnterRule(_localctx, 1222, RULE_sampleClauseValues);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6093;
			Match(LPAREN);
			State = 6094;
			fullExpression();
			State = 6095;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AliasIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		public AliasIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aliasIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAliasIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAliasIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public AliasIdentifierContext aliasIdentifier() {
		AliasIdentifierContext _localctx = new AliasIdentifierContext(Context, State);
		EnterRule(_localctx, 1224, RULE_aliasIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6098;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 6097;
				Match(AS);
				}
			}

			State = 6100;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleAliasIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public SimpleAliasIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleAliasIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSimpleAliasIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSimpleAliasIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public SimpleAliasIdentifierContext simpleAliasIdentifier() {
		SimpleAliasIdentifierContext _localctx = new SimpleAliasIdentifierContext(Context, State);
		EnterRule(_localctx, 1226, RULE_simpleAliasIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6102;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertColumnListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public InsertColumnListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertColumnListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterInsertColumnListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitInsertColumnListClause(this);
		}
	}

	[RuleVersion(0)]
	public InsertColumnListClauseContext insertColumnListClause() {
		InsertColumnListClauseContext _localctx = new InsertColumnListClauseContext(Context, State);
		EnterRule(_localctx, 1228, RULE_insertColumnListClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6104;
			Match(LPAREN);
			State = 6105;
			identifierList();
			State = 6106;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ValuesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUES() { return GetToken(OracleAntlrParser.VALUES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InsertExpressionListContext insertExpressionList() {
			return GetRuleContext<InsertExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ValuesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_valuesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterValuesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitValuesClause(this);
		}
	}

	[RuleVersion(0)]
	public ValuesClauseContext valuesClause() {
		ValuesClauseContext _localctx = new ValuesClauseContext(Context, State);
		EnterRule(_localctx, 1230, RULE_valuesClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6108;
			Match(VALUES);
			State = 6114;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				{
				State = 6109;
				Match(LPAREN);
				State = 6110;
				insertExpressionList();
				State = 6111;
				Match(RPAREN);
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 6113;
				identifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public InsertExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterInsertExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitInsertExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public InsertExpressionListContext insertExpressionList() {
		InsertExpressionListContext _localctx = new InsertExpressionListContext(Context, State);
		EnterRule(_localctx, 1232, RULE_insertExpressionList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6116;
			expressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSERT() { return GetToken(OracleAntlrParser.INSERT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleTableInsertStatementContext singleTableInsertStatement() {
			return GetRuleContext<SingleTableInsertStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiTableInsertStatementContext multiTableInsertStatement() {
			return GetRuleContext<MultiTableInsertStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalInsertStatementContext conditionalInsertStatement() {
			return GetRuleContext<ConditionalInsertStatementContext>(0);
		}
		public InsertStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterInsertStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitInsertStatement(this);
		}
	}

	[RuleVersion(0)]
	public InsertStatementContext insertStatement() {
		InsertStatementContext _localctx = new InsertStatementContext(Context, State);
		EnterRule(_localctx, 1234, RULE_insertStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6118;
			Match(INSERT);
			State = 6122;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,661,Context) ) {
			case 1:
				{
				State = 6119;
				singleTableInsertStatement();
				}
				break;
			case 2:
				{
				State = 6120;
				multiTableInsertStatement();
				}
				break;
			case 3:
				{
				State = 6121;
				conditionalInsertStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SingleTableInsertStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ValuesClauseContext valuesClause() {
			return GetRuleContext<ValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertColumnListClauseContext insertColumnListClause() {
			return GetRuleContext<InsertColumnListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturningClauseContext returningClause() {
			return GetRuleContext<ReturningClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingClauseContext errorLoggingClause() {
			return GetRuleContext<ErrorLoggingClauseContext>(0);
		}
		public SingleTableInsertStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_singleTableInsertStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSingleTableInsertStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSingleTableInsertStatement(this);
		}
	}

	[RuleVersion(0)]
	public SingleTableInsertStatementContext singleTableInsertStatement() {
		SingleTableInsertStatementContext _localctx = new SingleTableInsertStatementContext(Context, State);
		EnterRule(_localctx, 1236, RULE_singleTableInsertStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6124;
			Match(INTO);
			State = 6125;
			fromClauseItem();
			State = 6127;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,662,Context) ) {
			case 1:
				{
				State = 6126;
				insertColumnListClause();
				}
				break;
			}
			State = 6131;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case VALUES:
				{
				State = 6129;
				valuesClause();
				}
				break;
			case SELECT:
			case WITH:
			case LPAREN:
				{
				State = 6130;
				selectStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6134;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURNING) {
				{
				State = 6133;
				returningClause();
				}
			}

			State = 6137;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOG) {
				{
				State = 6136;
				errorLoggingClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiTableInsertStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiTableInsertItemContext[] multiTableInsertItem() {
			return GetRuleContexts<MultiTableInsertItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiTableInsertItemContext multiTableInsertItem(int i) {
			return GetRuleContext<MultiTableInsertItemContext>(i);
		}
		public MultiTableInsertStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiTableInsertStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMultiTableInsertStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMultiTableInsertStatement(this);
		}
	}

	[RuleVersion(0)]
	public MultiTableInsertStatementContext multiTableInsertStatement() {
		MultiTableInsertStatementContext _localctx = new MultiTableInsertStatementContext(Context, State);
		EnterRule(_localctx, 1238, RULE_multiTableInsertStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6139;
			Match(ALL);
			State = 6141;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6140;
				multiTableInsertItem();
				}
				}
				State = 6143;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==INTO );
			State = 6145;
			selectStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiTableInsertItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertColumnListClauseContext insertColumnListClause() {
			return GetRuleContext<InsertColumnListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ValuesClauseContext valuesClause() {
			return GetRuleContext<ValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingClauseContext errorLoggingClause() {
			return GetRuleContext<ErrorLoggingClauseContext>(0);
		}
		public MultiTableInsertItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiTableInsertItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMultiTableInsertItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMultiTableInsertItem(this);
		}
	}

	[RuleVersion(0)]
	public MultiTableInsertItemContext multiTableInsertItem() {
		MultiTableInsertItemContext _localctx = new MultiTableInsertItemContext(Context, State);
		EnterRule(_localctx, 1240, RULE_multiTableInsertItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6147;
			Match(INTO);
			State = 6148;
			fromClauseItem();
			State = 6150;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,667,Context) ) {
			case 1:
				{
				State = 6149;
				insertColumnListClause();
				}
				break;
			}
			State = 6153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==VALUES) {
				{
				State = 6152;
				valuesClause();
				}
			}

			State = 6156;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOG) {
				{
				State = 6155;
				errorLoggingClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalInsertStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalInsertWhenEntryContext[] conditionalInsertWhenEntry() {
			return GetRuleContexts<ConditionalInsertWhenEntryContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalInsertWhenEntryContext conditionalInsertWhenEntry(int i) {
			return GetRuleContext<ConditionalInsertWhenEntryContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalInsertElseClauseContext conditionalInsertElseClause() {
			return GetRuleContext<ConditionalInsertElseClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIRST() { return GetToken(OracleAntlrParser.FIRST, 0); }
		public ConditionalInsertStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalInsertStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConditionalInsertStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConditionalInsertStatement(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalInsertStatementContext conditionalInsertStatement() {
		ConditionalInsertStatementContext _localctx = new ConditionalInsertStatementContext(Context, State);
		EnterRule(_localctx, 1242, RULE_conditionalInsertStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6159;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==FIRST) {
				{
				State = 6158;
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==FIRST) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 6162;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6161;
				conditionalInsertWhenEntry();
				}
				}
				State = 6164;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 6167;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 6166;
				conditionalInsertElseClause();
				}
			}

			State = 6169;
			selectStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalInsertWhenEntryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalInsertThenClauseContext conditionalInsertThenClause() {
			return GetRuleContext<ConditionalInsertThenClauseContext>(0);
		}
		public ConditionalInsertWhenEntryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalInsertWhenEntry; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConditionalInsertWhenEntry(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConditionalInsertWhenEntry(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalInsertWhenEntryContext conditionalInsertWhenEntry() {
		ConditionalInsertWhenEntryContext _localctx = new ConditionalInsertWhenEntryContext(Context, State);
		EnterRule(_localctx, 1244, RULE_conditionalInsertWhenEntry);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6171;
			Match(WHEN);
			State = 6172;
			fullExpression();
			State = 6173;
			conditionalInsertThenClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalInsertThenClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(OracleAntlrParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MultiTableInsertItemContext[] multiTableInsertItem() {
			return GetRuleContexts<MultiTableInsertItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiTableInsertItemContext multiTableInsertItem(int i) {
			return GetRuleContext<MultiTableInsertItemContext>(i);
		}
		public ConditionalInsertThenClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalInsertThenClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConditionalInsertThenClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConditionalInsertThenClause(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalInsertThenClauseContext conditionalInsertThenClause() {
		ConditionalInsertThenClauseContext _localctx = new ConditionalInsertThenClauseContext(Context, State);
		EnterRule(_localctx, 1246, RULE_conditionalInsertThenClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6175;
			Match(THEN);
			State = 6177;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6176;
				multiTableInsertItem();
				}
				}
				State = 6179;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==INTO );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalInsertElseClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(OracleAntlrParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MultiTableInsertItemContext[] multiTableInsertItem() {
			return GetRuleContexts<MultiTableInsertItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiTableInsertItemContext multiTableInsertItem(int i) {
			return GetRuleContext<MultiTableInsertItemContext>(i);
		}
		public ConditionalInsertElseClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalInsertElseClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConditionalInsertElseClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConditionalInsertElseClause(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalInsertElseClauseContext conditionalInsertElseClause() {
		ConditionalInsertElseClauseContext _localctx = new ConditionalInsertElseClauseContext(Context, State);
		EnterRule(_localctx, 1248, RULE_conditionalInsertElseClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6181;
			Match(ELSE);
			State = 6183;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6182;
				multiTableInsertItem();
				}
				}
				State = 6185;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==INTO );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SetClauseValueClauseContext setClauseValueClause() {
			return GetRuleContext<SetClauseValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetListContext[] setList() {
			return GetRuleContexts<SetListContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetListContext setList(int i) {
			return GetRuleContext<SetListContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public SetClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSetClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSetClause(this);
		}
	}

	[RuleVersion(0)]
	public SetClauseContext setClause() {
		SetClauseContext _localctx = new SetClauseContext(Context, State);
		EnterRule(_localctx, 1250, RULE_setClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6187;
			Match(SET);
			State = 6197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,676,Context) ) {
			case 1:
				{
				State = 6188;
				setClauseValueClause();
				}
				break;
			case 2:
				{
				State = 6189;
				setList();
				State = 6194;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 6190;
					Match(COMMA);
					State = 6191;
					setList();
					}
					}
					State = 6196;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetClauseValueClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(OracleAntlrParser.VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public SetClauseValueClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setClauseValueClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSetClauseValueClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSetClauseValueClause(this);
		}
	}

	[RuleVersion(0)]
	public SetClauseValueClauseContext setClauseValueClause() {
		SetClauseValueClauseContext _localctx = new SetClauseValueClauseContext(Context, State);
		EnterRule(_localctx, 1252, RULE_setClauseValueClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6199;
			Match(VALUE);
			State = 6200;
			Match(LPAREN);
			State = 6201;
			identifier();
			State = 6202;
			Match(RPAREN);
			State = 6203;
			Match(EQUAL_SIGN);
			State = 6204;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultExpressionContext defaultExpression() {
			return GetRuleContext<DefaultExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetColumnListClauseContext setColumnListClause() {
			return GetRuleContext<SetColumnListClauseContext>(0);
		}
		public SetListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSetList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSetList(this);
		}
	}

	[RuleVersion(0)]
	public SetListContext setList() {
		SetListContext _localctx = new SetListContext(Context, State);
		EnterRule(_localctx, 1254, RULE_setList);
		try {
			State = 6223;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,679,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6211;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case A_:
				case ACCOUNT:
				case ADVANCED:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ALLOCATE:
				case ALLOW:
				case ALWAYS:
				case ANALYZE:
				case ANYSCHEMA:
				case ARCHIVE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case ATTRIBUTES:
				case AUTHENTICATION:
				case AUTHID:
				case AUTO:
				case AUTONOMOUS_TRANSACTION:
				case BASIC:
				case BASICFILE:
				case BATCH:
				case BEFORE:
				case BEGINNING:
				case BINARY:
				case BITMAP:
				case BLOCK:
				case BODY:
				case BOTH:
				case BREADTH:
				case BUFFER_POOL:
				case BUILD:
				case BUILTIN:
				case BULK:
				case BULK_EXCEPTIONS:
				case BULK_ROWCOUNT:
				case BYTE:
				case C_:
				case CACHE:
				case CALL:
				case CASCADE:
				case CAST:
				case CELL_FLASH_CACHE:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHARSET:
				case CHR:
				case CHUNK:
				case CLOB:
				case CLOSE:
				case COALESCE:
				case COLLATION:
				case COLLECT:
				case COLUMN_VALUE:
				case COMMIT:
				case COMMITTED:
				case COMPACT:
				case COMPILE:
				case COMPLETE:
				case COMPOUND:
				case COMPUTATION:
				case COMPUTE:
				case CONDITIONAL:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTAINER:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case COUNT:
				case CREATION:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DATAFILE:
				case DATE:
				case DAY:
				case DBTIMEZONE:
				case DDL:
				case DEALLOCATE:
				case DEBUG:
				case DECODE:
				case DECRYPT:
				case DEDUPLICATE:
				case DEFERRABLE:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DEMAND:
				case DENSE_RANK:
				case DEPTH:
				case DETERMINISTIC:
				case DIRECT_LOAD:
				case DISABLE:
				case DISALLOW:
				case DISASSOCIATE:
				case DOUBLE:
				case DUPLICATED:
				case EACH:
				case EDITION:
				case EDITIONABLE:
				case EDITIONING:
				case EDITIONS:
				case ELEMENT:
				case ELSIF:
				case EMPTY_KEYWORD:
				case ENABLE:
				case ENCRYPT:
				case ENFORCED:
				case ERROR_CODE:
				case ERROR_INDEX:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVALUATE:
				case EXCEPT:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXISTS:
				case EXIT:
				case EXPIRE:
				case EXTEND:
				case EXTENDED:
				case EXTENT:
				case EXTERNALLY:
				case EXTRACT:
				case FALSE:
				case FAST:
				case FILESYSTEM_LIKE_LOGGING:
				case FINAL:
				case FIPSFLAG:
				case FIRST:
				case FIRST_ROWS:
				case FIXED:
				case FOLLOWING:
				case FORALL:
				case FORCE:
				case FOREIGN:
				case FORMAT:
				case FOUND:
				case FLASH_CACHE:
				case FREELIST:
				case FREELISTS:
				case FREEPOOLS:
				case FULL:
				case FUNCTION:
				case GENERATED:
				case GLOBAL:
				case GLOBALLY:
				case GROUPING:
				case GROUPS:
				case HASH:
				case HEAP:
				case HIGH:
				case HOUR:
				case ID:
				case IDENTIFIER:
				case IDENTITY:
				case INCLUDE:
				case INCLUDING:
				case INDEXING:
				case INDICATOR:
				case INDICES:
				case INITIALLY:
				case INITRANS:
				case INNER:
				case INSTANCE:
				case INSTANTIABLE:
				case INSTEAD:
				case INTERFACE:
				case INTERVAL:
				case INVALIDATE:
				case INVALIDATION:
				case INVISIBLE:
				case ISOLATION:
				case ISOPEN:
				case JAVA:
				case JOIN:
				case JSON:
				case JSON_TABLE:
				case KEEP:
				case KEEP_DUPLICATES:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LEADING:
				case LEFT:
				case LESS:
				case LEVEL:
				case LEVELS:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LIST:
				case LOB:
				case LOBS:
				case LOCAL:
				case LOCATOR:
				case LOCKED:
				case LOCKING:
				case LOG:
				case LOGGING:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOW:
				case MAP:
				case MAPPING:
				case MASTER:
				case MATCHED:
				case MATERIALIZED:
				case MAX:
				case MAXSIZE:
				case MAXTRANS:
				case MAXVALUE:
				case MEDIUM:
				case MEMBER:
				case MEMOPTIMIZE:
				case MERGE:
				case METADATA:
				case MIN:
				case MINEXTENTS:
				case MINUTE:
				case MINVALUE:
				case MOD:
				case MONITORING:
				case MONTH:
				case MOVEMENT:
				case MULTISET:
				case NAME:
				case NATIONAL:
				case NATURAL:
				case NCHAR:
				case NCHAR_CS:
				case NCHR:
				case NESTED:
				case NEVER:
				case NEW:
				case NEW_NAMES:
				case NEXT:
				case NO:
				case NOCACHE:
				case NOCOPY:
				case NOCYCLE:
				case NOEXTEND:
				case NOKEEP:
				case NOLOGGING:
				case NOMAPPING:
				case NOMAXVALUE:
				case NOMINVALUE:
				case NOMONITORING:
				case NOORDER:
				case NONE:
				case NONEDITIONABLE:
				case NONSCHEMA:
				case NOPARALLEL:
				case NORELY:
				case NOREVERSE:
				case NOROWDEPENDENCIES:
				case NOSCALE:
				case NOSHARD:
				case NOSORT:
				case NOTFOUND:
				case NOVALIDATE:
				case NULLS:
				case OBJECT:
				case OID:
				case OIDINDEX:
				case OLD:
				case ONLY:
				case ONLINE:
				case OPAQUE:
				case OPEN:
				case OPERATIONS:
				case OPTIMAL:
				case ORDINALITY:
				case ORGANIZATION:
				case OUT:
				case OUTER:
				case OVER:
				case OVERFLOW:
				case OVERLAPS:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTIAL:
				case PARTITION:
				case PARTITIONS:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PCTINCREASE:
				case PCTTHRESHOLD:
				case PCTUSED:
				case PCTVERSION:
				case PERCENTILE_DISC:
				case PERIOD:
				case PIPE:
				case PIPELINED:
				case POLYMORPHIC:
				case PRAGMA:
				case PREBUILT:
				case PRECEDING:
				case PRECISION:
				case PRESERVE:
				case PRIMARY:
				case PRIOR:
				case PRIVATE:
				case PROCEDURE:
				case PROFILE:
				case PUBLIC:
				case PURGE:
				case QUERY:
				case QUOTA:
				case RAISE:
				case RAISE_APPLICATION_ERROR:
				case RANGE:
				case RAW:
				case READ:
				case READS:
				case REBUILD:
				case RECORD:
				case RECYCLE:
				case REDUCED:
				case REF:
				case REFERENCES:
				case REFERENCING:
				case REFRESH:
				case REJECT:
				case RELATIONAL:
				case RELIES_ON:
				case RELY:
				case RENAME:
				case REPLACE:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETENTION:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case REWRITE:
				case RIGHT:
				case ROLLUP:
				case ROW:
				case ROWCOUNT:
				case ROWDEPENDENCIES:
				case ROWID:
				case ROWTYPE:
				case SALT:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCALE:
				case SCHEMA:
				case SCN:
				case SCOPE:
				case SEARCH:
				case SECOND:
				case SECUREFILE:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSION:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHRINK:
				case SHUTDOWN:
				case SIBLINGS:
				case SIZE:
				case SKIP_:
				case SOME:
				case SORT:
				case SPACE:
				case SPECIFICATION:
				case SPLIT:
				case STARTUP:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORAGE:
				case STORE:
				case STRING:
				case SHARD:
				case SHARDED:
				case SHARING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUPPLEMENTAL:
				case SUSPEND:
				case SYNONYM:
				case SYSTEM:
				case TABLES:
				case TABLESPACE:
				case TEMPLATE:
				case TEMPORARY:
				case THAN:
				case TIME:
				case TIMESTAMP:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIM:
				case TRUE:
				case TRUNCATE:
				case TRUSTED:
				case TYPE:
				case UNBOUNDED:
				case UNCONDITIONAL:
				case UNDER:
				case UNLIMITED:
				case UNLOCK:
				case UNUSABLE:
				case UNUSED:
				case USABLE:
				case USAGE:
				case USE:
				case USER:
				case USING:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARRAY:
				case VARRAYS:
				case VARYING:
				case VERSIONS:
				case VIRTUAL:
				case VISIBLE:
				case WAIT:
				case WHEN:
				case WITHIN:
				case WITHOUT:
				case WORK:
				case WRAPPED:
				case WRAPPER:
				case WRITE:
				case XML:
				case XMLNAMESPACES:
				case XMLSCHEMA:
				case XMLTABLE:
				case XMLTYPE:
				case YEAR:
				case ZONE:
				case REGULAR_IDENTIFIER:
				case QUOTED_IDENTIFIER:
					{
					State = 6206;
					identifier();
					}
					break;
				case LPAREN:
					{
					State = 6207;
					Match(LPAREN);
					State = 6208;
					identifier();
					State = 6209;
					Match(RPAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 6213;
				Match(EQUAL_SIGN);
				State = 6217;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,678,Context) ) {
				case 1:
					{
					State = 6214;
					flattenedQuery();
					}
					break;
				case 2:
					{
					State = 6215;
					fullExpression();
					}
					break;
				case 3:
					{
					State = 6216;
					defaultExpression();
					}
					break;
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6219;
				setColumnListClause();
				State = 6220;
				Match(EQUAL_SIGN);
				State = 6221;
				flattenedQuery();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetColumnListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public SetColumnListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setColumnListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSetColumnListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSetColumnListClause(this);
		}
	}

	[RuleVersion(0)]
	public SetColumnListClauseContext setColumnListClause() {
		SetColumnListClauseContext _localctx = new SetColumnListClauseContext(Context, State);
		EnterRule(_localctx, 1256, RULE_setColumnListClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6225;
			Match(LPAREN);
			State = 6226;
			identifierList();
			State = 6227;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UpdateStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UPDATE() { return GetToken(OracleAntlrParser.UPDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SetClauseContext setClause() {
			return GetRuleContext<SetClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnlyClauseContext onlyClause() {
			return GetRuleContext<OnlyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturningClauseContext returningClause() {
			return GetRuleContext<ReturningClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingClauseContext errorLoggingClause() {
			return GetRuleContext<ErrorLoggingClauseContext>(0);
		}
		public UpdateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_updateStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUpdateStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUpdateStatement(this);
		}
	}

	[RuleVersion(0)]
	public UpdateStatementContext updateStatement() {
		UpdateStatementContext _localctx = new UpdateStatementContext(Context, State);
		EnterRule(_localctx, 1258, RULE_updateStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6229;
			Match(UPDATE);
			State = 6232;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,680,Context) ) {
			case 1:
				{
				State = 6230;
				onlyClause();
				}
				break;
			case 2:
				{
				State = 6231;
				fromClauseItem();
				}
				break;
			}
			State = 6234;
			setClause();
			State = 6236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 6235;
				whereClause();
				}
			}

			State = 6239;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURNING) {
				{
				State = 6238;
				returningClause();
				}
			}

			State = 6242;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOG) {
				{
				State = 6241;
				errorLoggingClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeleteStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(OracleAntlrParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OnlyClauseContext onlyClause() {
			return GetRuleContext<OnlyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(OracleAntlrParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturningClauseContext returningClause() {
			return GetRuleContext<ReturningClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingClauseContext errorLoggingClause() {
			return GetRuleContext<ErrorLoggingClauseContext>(0);
		}
		public DeleteStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deleteStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDeleteStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDeleteStatement(this);
		}
	}

	[RuleVersion(0)]
	public DeleteStatementContext deleteStatement() {
		DeleteStatementContext _localctx = new DeleteStatementContext(Context, State);
		EnterRule(_localctx, 1260, RULE_deleteStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6244;
			Match(DELETE);
			State = 6246;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FROM) {
				{
				State = 6245;
				Match(FROM);
				}
			}

			State = 6250;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,685,Context) ) {
			case 1:
				{
				State = 6248;
				onlyClause();
				}
				break;
			case 2:
				{
				State = 6249;
				fromClauseItem();
				}
				break;
			}
			State = 6253;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 6252;
				whereClause();
				}
			}

			State = 6256;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURNING) {
				{
				State = 6255;
				returningClause();
				}
			}

			State = 6259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOG) {
				{
				State = 6258;
				errorLoggingClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CloseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE() { return GetToken(OracleAntlrParser.CLOSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public CloseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_closeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCloseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCloseStatement(this);
		}
	}

	[RuleVersion(0)]
	public CloseStatementContext closeStatement() {
		CloseStatementContext _localctx = new CloseStatementContext(Context, State);
		EnterRule(_localctx, 1262, RULE_closeStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6261;
			Match(CLOSE);
			State = 6262;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FetchStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FETCH() { return GetToken(OracleAntlrParser.FETCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FetchTargetListContext fetchTargetList() {
			return GetRuleContext<FetchTargetListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BulkCollectIntoClauseContext bulkCollectIntoClause() {
			return GetRuleContext<BulkCollectIntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FetchLimitClauseContext fetchLimitClause() {
			return GetRuleContext<FetchLimitClauseContext>(0);
		}
		public FetchStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fetchStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFetchStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFetchStatement(this);
		}
	}

	[RuleVersion(0)]
	public FetchStatementContext fetchStatement() {
		FetchStatementContext _localctx = new FetchStatementContext(Context, State);
		EnterRule(_localctx, 1264, RULE_fetchStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6264;
			Match(FETCH);
			State = 6265;
			identifier();
			State = 6268;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INTO:
				{
				State = 6266;
				fetchTargetList();
				}
				break;
			case BULK:
				{
				State = 6267;
				bulkCollectIntoClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6271;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LIMIT) {
				{
				State = 6270;
				fetchLimitClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FetchTargetListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		public FetchTargetListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fetchTargetList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFetchTargetList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFetchTargetList(this);
		}
	}

	[RuleVersion(0)]
	public FetchTargetListContext fetchTargetList() {
		FetchTargetListContext _localctx = new FetchTargetListContext(Context, State);
		EnterRule(_localctx, 1266, RULE_fetchTargetList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6273;
			Match(INTO);
			State = 6274;
			identifierList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BulkCollectIntoClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BULK() { return GetToken(OracleAntlrParser.BULK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLLECT() { return GetToken(OracleAntlrParser.COLLECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		public BulkCollectIntoClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bulkCollectIntoClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBulkCollectIntoClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBulkCollectIntoClause(this);
		}
	}

	[RuleVersion(0)]
	public BulkCollectIntoClauseContext bulkCollectIntoClause() {
		BulkCollectIntoClauseContext _localctx = new BulkCollectIntoClauseContext(Context, State);
		EnterRule(_localctx, 1268, RULE_bulkCollectIntoClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6276;
			Match(BULK);
			State = 6277;
			Match(COLLECT);
			State = 6278;
			Match(INTO);
			State = 6279;
			identifierList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FetchLimitClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIMIT() { return GetToken(OracleAntlrParser.LIMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public FetchLimitClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fetchLimitClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFetchLimitClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFetchLimitClause(this);
		}
	}

	[RuleVersion(0)]
	public FetchLimitClauseContext fetchLimitClause() {
		FetchLimitClauseContext _localctx = new FetchLimitClauseContext(Context, State);
		EnterRule(_localctx, 1270, RULE_fetchLimitClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6281;
			Match(LIMIT);
			State = 6282;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OpenStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN() { return GetToken(OracleAntlrParser.OPEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpenForClauseContext openForClause() {
			return GetRuleContext<OpenForClauseContext>(0);
		}
		public OpenStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_openStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOpenStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOpenStatement(this);
		}
	}

	[RuleVersion(0)]
	public OpenStatementContext openStatement() {
		OpenStatementContext _localctx = new OpenStatementContext(Context, State);
		EnterRule(_localctx, 1272, RULE_openStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6284;
			Match(OPEN);
			State = 6285;
			identifier();
			State = 6287;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 6286;
				openForClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OpenForClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingListContext usingList() {
			return GetRuleContext<UsingListContext>(0);
		}
		public OpenForClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_openForClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOpenForClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOpenForClause(this);
		}
	}

	[RuleVersion(0)]
	public OpenForClauseContext openForClause() {
		OpenForClauseContext _localctx = new OpenForClauseContext(Context, State);
		EnterRule(_localctx, 1274, RULE_openForClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6289;
			Match(FOR);
			State = 6295;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,693,Context) ) {
			case 1:
				{
				State = 6290;
				selectStatement();
				}
				break;
			case 2:
				{
				State = 6291;
				fullExpression();
				State = 6293;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 6292;
					usingList();
					}
				}

				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UsingListItemContext[] usingListItem() {
			return GetRuleContexts<UsingListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingListItemContext usingListItem(int i) {
			return GetRuleContext<UsingListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public UsingListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUsingList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUsingList(this);
		}
	}

	[RuleVersion(0)]
	public UsingListContext usingList() {
		UsingListContext _localctx = new UsingListContext(Context, State);
		EnterRule(_localctx, 1276, RULE_usingList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6297;
			Match(USING);
			State = 6298;
			usingListItem();
			State = 6303;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 6299;
				Match(COMMA);
				State = 6300;
				usingListItem();
				}
				}
				State = 6305;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OUT() { return GetToken(OracleAntlrParser.OUT, 0); }
		public UsingListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUsingListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUsingListItem(this);
		}
	}

	[RuleVersion(0)]
	public UsingListItemContext usingListItem() {
		UsingListItemContext _localctx = new UsingListItemContext(Context, State);
		EnterRule(_localctx, 1278, RULE_usingListItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6310;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,695,Context) ) {
			case 1:
				{
				State = 6306;
				Match(IN);
				State = 6307;
				Match(OUT);
				}
				break;
			case 2:
				{
				State = 6308;
				Match(IN);
				}
				break;
			case 3:
				{
				State = 6309;
				Match(OUT);
				}
				break;
			}
			State = 6312;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommitWorkStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMIT() { return GetToken(OracleAntlrParser.COMMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WORK() { return GetToken(OracleAntlrParser.WORK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommitWorkCommentClauseContext commitWorkCommentClause() {
			return GetRuleContext<CommitWorkCommentClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommitWorkWriteClauseContext commitWorkWriteClause() {
			return GetRuleContext<CommitWorkWriteClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommitWorkForceClauseContext commitWorkForceClause() {
			return GetRuleContext<CommitWorkForceClauseContext>(0);
		}
		public CommitWorkStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commitWorkStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCommitWorkStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCommitWorkStatement(this);
		}
	}

	[RuleVersion(0)]
	public CommitWorkStatementContext commitWorkStatement() {
		CommitWorkStatementContext _localctx = new CommitWorkStatementContext(Context, State);
		EnterRule(_localctx, 1280, RULE_commitWorkStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6314;
			Match(COMMIT);
			State = 6316;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WORK) {
				{
				State = 6315;
				Match(WORK);
				}
			}

			State = 6324;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMMENT:
				{
				State = 6318;
				commitWorkCommentClause();
				State = 6320;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WRITE) {
					{
					State = 6319;
					commitWorkWriteClause();
					}
				}

				}
				break;
			case WRITE:
				{
				State = 6322;
				commitWorkWriteClause();
				}
				break;
			case FORCE:
				{
				State = 6323;
				commitWorkForceClause();
				}
				break;
			case Eof:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommitWorkCommentClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMENT() { return GetToken(OracleAntlrParser.COMMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public CommitWorkCommentClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commitWorkCommentClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCommitWorkCommentClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCommitWorkCommentClause(this);
		}
	}

	[RuleVersion(0)]
	public CommitWorkCommentClauseContext commitWorkCommentClause() {
		CommitWorkCommentClauseContext _localctx = new CommitWorkCommentClauseContext(Context, State);
		EnterRule(_localctx, 1282, RULE_commitWorkCommentClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6326;
			Match(COMMENT);
			State = 6327;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommitWorkWriteClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRITE() { return GetToken(OracleAntlrParser.WRITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMEDIATE() { return GetToken(OracleAntlrParser.IMMEDIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BATCH() { return GetToken(OracleAntlrParser.BATCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WAIT() { return GetToken(OracleAntlrParser.WAIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOWAIT() { return GetToken(OracleAntlrParser.NOWAIT, 0); }
		public CommitWorkWriteClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commitWorkWriteClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCommitWorkWriteClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCommitWorkWriteClause(this);
		}
	}

	[RuleVersion(0)]
	public CommitWorkWriteClauseContext commitWorkWriteClause() {
		CommitWorkWriteClauseContext _localctx = new CommitWorkWriteClauseContext(Context, State);
		EnterRule(_localctx, 1284, RULE_commitWorkWriteClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6329;
			Match(WRITE);
			State = 6331;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BATCH || _la==IMMEDIATE) {
				{
				State = 6330;
				_la = TokenStream.LA(1);
				if ( !(_la==BATCH || _la==IMMEDIATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 6334;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOWAIT || _la==WAIT) {
				{
				State = 6333;
				_la = TokenStream.LA(1);
				if ( !(_la==NOWAIT || _la==WAIT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommitWorkForceClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORCE() { return GetToken(OracleAntlrParser.FORCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		public CommitWorkForceClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commitWorkForceClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCommitWorkForceClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCommitWorkForceClause(this);
		}
	}

	[RuleVersion(0)]
	public CommitWorkForceClauseContext commitWorkForceClause() {
		CommitWorkForceClauseContext _localctx = new CommitWorkForceClauseContext(Context, State);
		EnterRule(_localctx, 1286, RULE_commitWorkForceClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6336;
			Match(FORCE);
			State = 6337;
			literal();
			State = 6340;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 6338;
				Match(COMMA);
				State = 6339;
				Match(INTEGER_LITERAL);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetTransactionStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRANSACTION() { return GetToken(OracleAntlrParser.TRANSACTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SetTransactionNameContext setTransactionName() {
			return GetRuleContext<SetTransactionNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetTransactionReadClauseContext setTransactionReadClause() {
			return GetRuleContext<SetTransactionReadClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IsolationLevelClauseContext isolationLevelClause() {
			return GetRuleContext<IsolationLevelClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UseRollbackSegmentClauseContext useRollbackSegmentClause() {
			return GetRuleContext<UseRollbackSegmentClauseContext>(0);
		}
		public SetTransactionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setTransactionStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSetTransactionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSetTransactionStatement(this);
		}
	}

	[RuleVersion(0)]
	public SetTransactionStatementContext setTransactionStatement() {
		SetTransactionStatementContext _localctx = new SetTransactionStatementContext(Context, State);
		EnterRule(_localctx, 1288, RULE_setTransactionStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6342;
			Match(SET);
			State = 6343;
			Match(TRANSACTION);
			State = 6353;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ISOLATION:
			case READ:
			case USE:
				{
				State = 6347;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case READ:
					{
					State = 6344;
					setTransactionReadClause();
					}
					break;
				case ISOLATION:
					{
					State = 6345;
					isolationLevelClause();
					}
					break;
				case USE:
					{
					State = 6346;
					useRollbackSegmentClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 6350;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NAME) {
					{
					State = 6349;
					setTransactionName();
					}
				}

				}
				break;
			case NAME:
				{
				State = 6352;
				setTransactionName();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetTransactionNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAME() { return GetToken(OracleAntlrParser.NAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public SetTransactionNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setTransactionName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSetTransactionName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSetTransactionName(this);
		}
	}

	[RuleVersion(0)]
	public SetTransactionNameContext setTransactionName() {
		SetTransactionNameContext _localctx = new SetTransactionNameContext(Context, State);
		EnterRule(_localctx, 1290, RULE_setTransactionName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6355;
			Match(NAME);
			State = 6356;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetTransactionReadClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READ() { return GetToken(OracleAntlrParser.READ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLY() { return GetToken(OracleAntlrParser.ONLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRITE() { return GetToken(OracleAntlrParser.WRITE, 0); }
		public SetTransactionReadClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setTransactionReadClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSetTransactionReadClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSetTransactionReadClause(this);
		}
	}

	[RuleVersion(0)]
	public SetTransactionReadClauseContext setTransactionReadClause() {
		SetTransactionReadClauseContext _localctx = new SetTransactionReadClauseContext(Context, State);
		EnterRule(_localctx, 1292, RULE_setTransactionReadClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6358;
			Match(READ);
			State = 6360;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ONLY || _la==WRITE) {
				{
				State = 6359;
				_la = TokenStream.LA(1);
				if ( !(_la==ONLY || _la==WRITE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IsolationLevelClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ISOLATION() { return GetToken(OracleAntlrParser.ISOLATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEVEL() { return GetToken(OracleAntlrParser.LEVEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERIALIZABLE() { return GetToken(OracleAntlrParser.SERIALIZABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READ() { return GetToken(OracleAntlrParser.READ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMITTED() { return GetToken(OracleAntlrParser.COMMITTED, 0); }
		public IsolationLevelClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_isolationLevelClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIsolationLevelClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIsolationLevelClause(this);
		}
	}

	[RuleVersion(0)]
	public IsolationLevelClauseContext isolationLevelClause() {
		IsolationLevelClauseContext _localctx = new IsolationLevelClauseContext(Context, State);
		EnterRule(_localctx, 1294, RULE_isolationLevelClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6362;
			Match(ISOLATION);
			State = 6363;
			Match(LEVEL);
			State = 6367;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SERIALIZABLE:
				{
				State = 6364;
				Match(SERIALIZABLE);
				}
				break;
			case READ:
				{
				State = 6365;
				Match(READ);
				State = 6366;
				Match(COMMITTED);
				}
				break;
			case Eof:
			case NAME:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UseRollbackSegmentClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USE() { return GetToken(OracleAntlrParser.USE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLLBACK() { return GetToken(OracleAntlrParser.ROLLBACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEGMENT() { return GetToken(OracleAntlrParser.SEGMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public UseRollbackSegmentClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_useRollbackSegmentClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterUseRollbackSegmentClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitUseRollbackSegmentClause(this);
		}
	}

	[RuleVersion(0)]
	public UseRollbackSegmentClauseContext useRollbackSegmentClause() {
		UseRollbackSegmentClauseContext _localctx = new UseRollbackSegmentClauseContext(Context, State);
		EnterRule(_localctx, 1296, RULE_useRollbackSegmentClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6369;
			Match(USE);
			State = 6370;
			Match(ROLLBACK);
			State = 6371;
			Match(SEGMENT);
			State = 6372;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RollbackWorkStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLLBACK() { return GetToken(OracleAntlrParser.ROLLBACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WORK() { return GetToken(OracleAntlrParser.WORK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ToSavepointClauseContext toSavepointClause() {
			return GetRuleContext<ToSavepointClauseContext>(0);
		}
		public RollbackWorkStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollbackWorkStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRollbackWorkStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRollbackWorkStatement(this);
		}
	}

	[RuleVersion(0)]
	public RollbackWorkStatementContext rollbackWorkStatement() {
		RollbackWorkStatementContext _localctx = new RollbackWorkStatementContext(Context, State);
		EnterRule(_localctx, 1298, RULE_rollbackWorkStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6374;
			Match(ROLLBACK);
			State = 6376;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WORK) {
				{
				State = 6375;
				Match(WORK);
				}
			}

			State = 6379;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TO) {
				{
				State = 6378;
				toSavepointClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ToSavepointClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(OracleAntlrParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SAVEPOINT() { return GetToken(OracleAntlrParser.SAVEPOINT, 0); }
		public ToSavepointClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_toSavepointClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterToSavepointClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitToSavepointClause(this);
		}
	}

	[RuleVersion(0)]
	public ToSavepointClauseContext toSavepointClause() {
		ToSavepointClauseContext _localctx = new ToSavepointClauseContext(Context, State);
		EnterRule(_localctx, 1300, RULE_toSavepointClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6381;
			Match(TO);
			State = 6383;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,709,Context) ) {
			case 1:
				{
				State = 6382;
				Match(SAVEPOINT);
				}
				break;
			}
			State = 6385;
			simpleIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SavepointStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SAVEPOINT() { return GetToken(OracleAntlrParser.SAVEPOINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		public SavepointStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_savepointStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSavepointStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSavepointStatement(this);
		}
	}

	[RuleVersion(0)]
	public SavepointStatementContext savepointStatement() {
		SavepointStatementContext _localctx = new SavepointStatementContext(Context, State);
		EnterRule(_localctx, 1302, RULE_savepointStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6387;
			Match(SAVEPOINT);
			State = 6388;
			simpleIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN_OPERATOR() { return GetToken(OracleAntlrParser.ASSIGN_OPERATOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public AssignmentStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignmentStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAssignmentStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAssignmentStatement(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentStatementContext assignmentStatement() {
		AssignmentStatementContext _localctx = new AssignmentStatementContext(Context, State);
		EnterRule(_localctx, 1304, RULE_assignmentStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6390;
			identifier();
			State = 6391;
			Match(ASSIGN_OPERATOR);
			State = 6392;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ErrorLoggingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOG() { return GetToken(OracleAntlrParser.LOG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERRORS() { return GetToken(OracleAntlrParser.ERRORS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingIntoClauseContext errorLoggingIntoClause() {
			return GetRuleContext<ErrorLoggingIntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingTagExpressionContext errorLoggingTagExpression() {
			return GetRuleContext<ErrorLoggingTagExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingRejectLimitContext errorLoggingRejectLimit() {
			return GetRuleContext<ErrorLoggingRejectLimitContext>(0);
		}
		public ErrorLoggingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_errorLoggingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterErrorLoggingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitErrorLoggingClause(this);
		}
	}

	[RuleVersion(0)]
	public ErrorLoggingClauseContext errorLoggingClause() {
		ErrorLoggingClauseContext _localctx = new ErrorLoggingClauseContext(Context, State);
		EnterRule(_localctx, 1306, RULE_errorLoggingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6394;
			Match(LOG);
			State = 6395;
			Match(ERRORS);
			State = 6397;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,710,Context) ) {
			case 1:
				{
				State = 6396;
				errorLoggingIntoClause();
				}
				break;
			}
			State = 6400;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,711,Context) ) {
			case 1:
				{
				State = 6399;
				errorLoggingTagExpression();
				}
				break;
			}
			State = 6403;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REJECT) {
				{
				State = 6402;
				errorLoggingRejectLimit();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ErrorLoggingIntoClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ErrorLoggingIntoClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_errorLoggingIntoClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterErrorLoggingIntoClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitErrorLoggingIntoClause(this);
		}
	}

	[RuleVersion(0)]
	public ErrorLoggingIntoClauseContext errorLoggingIntoClause() {
		ErrorLoggingIntoClauseContext _localctx = new ErrorLoggingIntoClauseContext(Context, State);
		EnterRule(_localctx, 1308, RULE_errorLoggingIntoClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6405;
			Match(INTO);
			State = 6406;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ErrorLoggingTagExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public ErrorLoggingTagExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_errorLoggingTagExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterErrorLoggingTagExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitErrorLoggingTagExpression(this);
		}
	}

	[RuleVersion(0)]
	public ErrorLoggingTagExpressionContext errorLoggingTagExpression() {
		ErrorLoggingTagExpressionContext _localctx = new ErrorLoggingTagExpressionContext(Context, State);
		EnterRule(_localctx, 1310, RULE_errorLoggingTagExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6408;
			Match(LPAREN);
			State = 6409;
			fullExpression();
			State = 6410;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ErrorLoggingRejectLimitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REJECT() { return GetToken(OracleAntlrParser.REJECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIMIT() { return GetToken(OracleAntlrParser.LIMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNLIMITED() { return GetToken(OracleAntlrParser.UNLIMITED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ErrorLoggingRejectLimitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_errorLoggingRejectLimit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterErrorLoggingRejectLimit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitErrorLoggingRejectLimit(this);
		}
	}

	[RuleVersion(0)]
	public ErrorLoggingRejectLimitContext errorLoggingRejectLimit() {
		ErrorLoggingRejectLimitContext _localctx = new ErrorLoggingRejectLimitContext(Context, State);
		EnterRule(_localctx, 1312, RULE_errorLoggingRejectLimit);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6412;
			Match(REJECT);
			State = 6413;
			Match(LIMIT);
			State = 6416;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNLIMITED:
				{
				State = 6414;
				Match(UNLIMITED);
				}
				break;
			case DATE:
			case FALSE:
			case INTERVAL:
			case TIMESTAMP:
			case TRUE:
			case INTEGER_LITERAL:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case QUOTE_CHARACTER_STRING_LITERAL:
				{
				State = 6415;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MERGE() { return GetToken(OracleAntlrParser.MERGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeUsingClauseContext mergeUsingClause() {
			return GetRuleContext<MergeUsingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeConditionClauseContext mergeConditionClause() {
			return GetRuleContext<MergeConditionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeUpdateOrInsertClauseContext mergeUpdateOrInsertClause() {
			return GetRuleContext<MergeUpdateOrInsertClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingClauseContext errorLoggingClause() {
			return GetRuleContext<ErrorLoggingClauseContext>(0);
		}
		public MergeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMergeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMergeStatement(this);
		}
	}

	[RuleVersion(0)]
	public MergeStatementContext mergeStatement() {
		MergeStatementContext _localctx = new MergeStatementContext(Context, State);
		EnterRule(_localctx, 1314, RULE_mergeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6418;
			Match(MERGE);
			State = 6419;
			Match(INTO);
			State = 6420;
			fromClauseItem();
			State = 6421;
			mergeUsingClause();
			State = 6422;
			mergeConditionClause();
			State = 6424;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHEN) {
				{
				State = 6423;
				mergeUpdateOrInsertClause();
				}
			}

			State = 6427;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOG) {
				{
				State = 6426;
				errorLoggingClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeUpdateOrInsertClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MergeUpdateClauseContext mergeUpdateClause() {
			return GetRuleContext<MergeUpdateClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeInsertClauseContext mergeInsertClause() {
			return GetRuleContext<MergeInsertClauseContext>(0);
		}
		public MergeUpdateOrInsertClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeUpdateOrInsertClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMergeUpdateOrInsertClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMergeUpdateOrInsertClause(this);
		}
	}

	[RuleVersion(0)]
	public MergeUpdateOrInsertClauseContext mergeUpdateOrInsertClause() {
		MergeUpdateOrInsertClauseContext _localctx = new MergeUpdateOrInsertClauseContext(Context, State);
		EnterRule(_localctx, 1316, RULE_mergeUpdateOrInsertClause);
		int _la;
		try {
			State = 6437;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,718,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6429;
				mergeUpdateClause();
				State = 6431;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHEN) {
					{
					State = 6430;
					mergeInsertClause();
					}
				}

				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6433;
				mergeInsertClause();
				State = 6435;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHEN) {
					{
					State = 6434;
					mergeUpdateClause();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeUsingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		public MergeUsingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeUsingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMergeUsingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMergeUsingClause(this);
		}
	}

	[RuleVersion(0)]
	public MergeUsingClauseContext mergeUsingClause() {
		MergeUsingClauseContext _localctx = new MergeUsingClauseContext(Context, State);
		EnterRule(_localctx, 1318, RULE_mergeUsingClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6439;
			Match(USING);
			State = 6440;
			fromClauseItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeConditionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public MergeConditionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeConditionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMergeConditionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMergeConditionClause(this);
		}
	}

	[RuleVersion(0)]
	public MergeConditionClauseContext mergeConditionClause() {
		MergeConditionClauseContext _localctx = new MergeConditionClauseContext(Context, State);
		EnterRule(_localctx, 1320, RULE_mergeConditionClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6442;
			Match(ON);
			State = 6443;
			Match(LPAREN);
			State = 6444;
			fullExpression();
			State = 6445;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeUpdateClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATCHED() { return GetToken(OracleAntlrParser.MATCHED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(OracleAntlrParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UPDATE() { return GetToken(OracleAntlrParser.UPDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SetClauseContext setClause() {
			return GetRuleContext<SetClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeleteWhereClauseContext deleteWhereClause() {
			return GetRuleContext<DeleteWhereClauseContext>(0);
		}
		public MergeUpdateClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeUpdateClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMergeUpdateClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMergeUpdateClause(this);
		}
	}

	[RuleVersion(0)]
	public MergeUpdateClauseContext mergeUpdateClause() {
		MergeUpdateClauseContext _localctx = new MergeUpdateClauseContext(Context, State);
		EnterRule(_localctx, 1322, RULE_mergeUpdateClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6447;
			Match(WHEN);
			State = 6448;
			Match(MATCHED);
			State = 6449;
			Match(THEN);
			State = 6450;
			Match(UPDATE);
			State = 6451;
			setClause();
			State = 6453;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 6452;
				whereClause();
				}
			}

			State = 6456;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DELETE) {
				{
				State = 6455;
				deleteWhereClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeleteWhereClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(OracleAntlrParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public DeleteWhereClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deleteWhereClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDeleteWhereClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDeleteWhereClause(this);
		}
	}

	[RuleVersion(0)]
	public DeleteWhereClauseContext deleteWhereClause() {
		DeleteWhereClauseContext _localctx = new DeleteWhereClauseContext(Context, State);
		EnterRule(_localctx, 1324, RULE_deleteWhereClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6458;
			Match(DELETE);
			State = 6459;
			whereClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeInsertClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATCHED() { return GetToken(OracleAntlrParser.MATCHED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(OracleAntlrParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSERT() { return GetToken(OracleAntlrParser.INSERT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ValuesClauseContext valuesClause() {
			return GetRuleContext<ValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertColumnListClauseContext insertColumnListClause() {
			return GetRuleContext<InsertColumnListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public MergeInsertClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeInsertClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterMergeInsertClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitMergeInsertClause(this);
		}
	}

	[RuleVersion(0)]
	public MergeInsertClauseContext mergeInsertClause() {
		MergeInsertClauseContext _localctx = new MergeInsertClauseContext(Context, State);
		EnterRule(_localctx, 1326, RULE_mergeInsertClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6461;
			Match(WHEN);
			State = 6462;
			Match(NOT);
			State = 6463;
			Match(MATCHED);
			State = 6464;
			Match(THEN);
			State = 6465;
			Match(INSERT);
			State = 6467;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 6466;
				insertColumnListClause();
				}
			}

			State = 6469;
			valuesClause();
			State = 6471;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 6470;
				whereClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExecuteImmediateStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXECUTE() { return GetToken(OracleAntlrParser.EXECUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMEDIATE() { return GetToken(OracleAntlrParser.IMMEDIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntoClauseContext intoClause() {
			return GetRuleContext<IntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BulkCollectIntoClauseContext bulkCollectIntoClause() {
			return GetRuleContext<BulkCollectIntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingListContext usingList() {
			return GetRuleContext<UsingListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExecuteReturningClauseContext executeReturningClause() {
			return GetRuleContext<ExecuteReturningClauseContext>(0);
		}
		public ExecuteImmediateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_executeImmediateStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExecuteImmediateStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExecuteImmediateStatement(this);
		}
	}

	[RuleVersion(0)]
	public ExecuteImmediateStatementContext executeImmediateStatement() {
		ExecuteImmediateStatementContext _localctx = new ExecuteImmediateStatementContext(Context, State);
		EnterRule(_localctx, 1328, RULE_executeImmediateStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6473;
			Match(EXECUTE);
			State = 6474;
			Match(IMMEDIATE);
			State = 6475;
			fullExpression();
			State = 6478;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INTO:
				{
				State = 6476;
				intoClause();
				}
				break;
			case BULK:
				{
				State = 6477;
				bulkCollectIntoClause();
				}
				break;
			case Eof:
			case RETURN:
			case RETURNING:
			case USING:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			State = 6481;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 6480;
				usingList();
				}
			}

			State = 6484;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURN || _la==RETURNING) {
				{
				State = 6483;
				executeReturningClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExecuteReturningClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IntoClauseContext intoClause() {
			return GetRuleContext<IntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURNING() { return GetToken(OracleAntlrParser.RETURNING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(OracleAntlrParser.RETURN, 0); }
		public ExecuteReturningClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_executeReturningClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExecuteReturningClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExecuteReturningClause(this);
		}
	}

	[RuleVersion(0)]
	public ExecuteReturningClauseContext executeReturningClause() {
		ExecuteReturningClauseContext _localctx = new ExecuteReturningClauseContext(Context, State);
		EnterRule(_localctx, 1330, RULE_executeReturningClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6486;
			_la = TokenStream.LA(1);
			if ( !(_la==RETURN || _la==RETURNING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 6487;
			intoClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PipeRowStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PIPE() { return GetToken(OracleAntlrParser.PIPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public PipeRowStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pipeRowStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPipeRowStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPipeRowStatement(this);
		}
	}

	[RuleVersion(0)]
	public PipeRowStatementContext pipeRowStatement() {
		PipeRowStatementContext _localctx = new PipeRowStatementContext(Context, State);
		EnterRule(_localctx, 1332, RULE_pipeRowStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6489;
			Match(PIPE);
			State = 6490;
			Match(ROW);
			State = 6491;
			Match(LPAREN);
			State = 6492;
			pureExpression();
			State = 6493;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RaiseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RAISE() { return GetToken(OracleAntlrParser.RAISE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public RaiseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_raiseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRaiseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRaiseStatement(this);
		}
	}

	[RuleVersion(0)]
	public RaiseStatementContext raiseStatement() {
		RaiseStatementContext _localctx = new RaiseStatementContext(Context, State);
		EnterRule(_localctx, 1334, RULE_raiseStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6495;
			Match(RAISE);
			State = 6497;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 6496;
				identifier();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TruncateTableStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUNCATE() { return GetToken(OracleAntlrParser.TRUNCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TruncateTableLogClauseContext truncateTableLogClause() {
			return GetRuleContext<TruncateTableLogClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TruncateStatementStorageClauseContext truncateStatementStorageClause() {
			return GetRuleContext<TruncateStatementStorageClauseContext>(0);
		}
		public TruncateTableStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_truncateTableStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTruncateTableStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTruncateTableStatement(this);
		}
	}

	[RuleVersion(0)]
	public TruncateTableStatementContext truncateTableStatement() {
		TruncateTableStatementContext _localctx = new TruncateTableStatementContext(Context, State);
		EnterRule(_localctx, 1336, RULE_truncateTableStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6499;
			Match(TRUNCATE);
			State = 6500;
			Match(TABLE);
			State = 6501;
			identifier();
			State = 6503;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PRESERVE || _la==PURGE) {
				{
				State = 6502;
				truncateTableLogClause();
				}
			}

			State = 6506;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DROP || _la==REUSE) {
				{
				State = 6505;
				truncateStatementStorageClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TruncateTableLogClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PreservePurgeClauseContext preservePurgeClause() {
			return GetRuleContext<PreservePurgeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATERIALIZED() { return GetToken(OracleAntlrParser.MATERIALIZED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VIEW() { return GetToken(OracleAntlrParser.VIEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOG() { return GetToken(OracleAntlrParser.LOG, 0); }
		public TruncateTableLogClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_truncateTableLogClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTruncateTableLogClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTruncateTableLogClause(this);
		}
	}

	[RuleVersion(0)]
	public TruncateTableLogClauseContext truncateTableLogClause() {
		TruncateTableLogClauseContext _localctx = new TruncateTableLogClauseContext(Context, State);
		EnterRule(_localctx, 1338, RULE_truncateTableLogClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6508;
			preservePurgeClause();
			State = 6509;
			Match(MATERIALIZED);
			State = 6510;
			Match(VIEW);
			State = 6511;
			Match(LOG);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PreservePurgeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRESERVE() { return GetToken(OracleAntlrParser.PRESERVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PURGE() { return GetToken(OracleAntlrParser.PURGE, 0); }
		public PreservePurgeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_preservePurgeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPreservePurgeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPreservePurgeClause(this);
		}
	}

	[RuleVersion(0)]
	public PreservePurgeClauseContext preservePurgeClause() {
		PreservePurgeClauseContext _localctx = new PreservePurgeClauseContext(Context, State);
		EnterRule(_localctx, 1340, RULE_preservePurgeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6513;
			_la = TokenStream.LA(1);
			if ( !(_la==PRESERVE || _la==PURGE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TruncateClusterStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUNCATE() { return GetToken(OracleAntlrParser.TRUNCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLUSTER() { return GetToken(OracleAntlrParser.CLUSTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TruncateStatementStorageClauseContext truncateStatementStorageClause() {
			return GetRuleContext<TruncateStatementStorageClauseContext>(0);
		}
		public TruncateClusterStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_truncateClusterStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTruncateClusterStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTruncateClusterStatement(this);
		}
	}

	[RuleVersion(0)]
	public TruncateClusterStatementContext truncateClusterStatement() {
		TruncateClusterStatementContext _localctx = new TruncateClusterStatementContext(Context, State);
		EnterRule(_localctx, 1342, RULE_truncateClusterStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6515;
			Match(TRUNCATE);
			State = 6516;
			Match(CLUSTER);
			State = 6517;
			identifier();
			State = 6519;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DROP || _la==REUSE) {
				{
				State = 6518;
				truncateStatementStorageClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TruncateStatementStorageClauseContext : ParserRuleContext {
		public IToken clauseType;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORAGE() { return GetToken(OracleAntlrParser.STORAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(OracleAntlrParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REUSE() { return GetToken(OracleAntlrParser.REUSE, 0); }
		public TruncateStatementStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_truncateStatementStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTruncateStatementStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTruncateStatementStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public TruncateStatementStorageClauseContext truncateStatementStorageClause() {
		TruncateStatementStorageClauseContext _localctx = new TruncateStatementStorageClauseContext(Context, State);
		EnterRule(_localctx, 1344, RULE_truncateStatementStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6521;
			_localctx.clauseType = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DROP || _la==REUSE) ) {
				_localctx.clauseType = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 6522;
			Match(STORAGE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockTableStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCK() { return GetToken(OracleAntlrParser.LOCK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LockTableItemListContext lockTableItemList() {
			return GetRuleContext<LockTableItemListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LockTableModeClauseContext lockTableModeClause() {
			return GetRuleContext<LockTableModeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LockTableNowaitClauseContext lockTableNowaitClause() {
			return GetRuleContext<LockTableNowaitClauseContext>(0);
		}
		public LockTableStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockTableStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLockTableStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLockTableStatement(this);
		}
	}

	[RuleVersion(0)]
	public LockTableStatementContext lockTableStatement() {
		LockTableStatementContext _localctx = new LockTableStatementContext(Context, State);
		EnterRule(_localctx, 1346, RULE_lockTableStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6524;
			Match(LOCK);
			State = 6525;
			Match(TABLE);
			State = 6526;
			lockTableItemList();
			State = 6527;
			lockTableModeClause();
			State = 6529;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOWAIT) {
				{
				State = 6528;
				lockTableNowaitClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockTableItemListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext[] fromClauseItem() {
			return GetRuleContexts<FromClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem(int i) {
			return GetRuleContext<FromClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public LockTableItemListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockTableItemList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLockTableItemList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLockTableItemList(this);
		}
	}

	[RuleVersion(0)]
	public LockTableItemListContext lockTableItemList() {
		LockTableItemListContext _localctx = new LockTableItemListContext(Context, State);
		EnterRule(_localctx, 1348, RULE_lockTableItemList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6531;
			fromClauseItem();
			State = 6536;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 6532;
				Match(COMMA);
				State = 6533;
				fromClauseItem();
				}
				}
				State = 6538;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockTableModeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MODE() { return GetToken(OracleAntlrParser.MODE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARE() { return GetToken(OracleAntlrParser.SHARE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLUSIVE() { return GetToken(OracleAntlrParser.EXCLUSIVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UPDATE() { return GetToken(OracleAntlrParser.UPDATE, 0); }
		public LockTableModeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockTableModeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLockTableModeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLockTableModeClause(this);
		}
	}

	[RuleVersion(0)]
	public LockTableModeClauseContext lockTableModeClause() {
		LockTableModeClauseContext _localctx = new LockTableModeClauseContext(Context, State);
		EnterRule(_localctx, 1350, RULE_lockTableModeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6539;
			Match(IN);
			State = 6549;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ROW:
				{
				State = 6540;
				Match(ROW);
				State = 6541;
				_la = TokenStream.LA(1);
				if ( !(_la==EXCLUSIVE || _la==SHARE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case SHARE:
				{
				State = 6542;
				Match(SHARE);
				State = 6546;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case UPDATE:
					{
					State = 6543;
					Match(UPDATE);
					}
					break;
				case ROW:
					{
					State = 6544;
					Match(ROW);
					State = 6545;
					Match(EXCLUSIVE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case EXCLUSIVE:
				{
				State = 6548;
				Match(EXCLUSIVE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6551;
			Match(MODE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockTableNowaitClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOWAIT() { return GetToken(OracleAntlrParser.NOWAIT, 0); }
		public LockTableNowaitClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockTableNowaitClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLockTableNowaitClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLockTableNowaitClause(this);
		}
	}

	[RuleVersion(0)]
	public LockTableNowaitClauseContext lockTableNowaitClause() {
		LockTableNowaitClauseContext _localctx = new LockTableNowaitClauseContext(Context, State);
		EnterRule(_localctx, 1352, RULE_lockTableNowaitClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6553;
			Match(NOWAIT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TranslateExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRANSLATE() { return GetToken(OracleAntlrParser.TRANSLATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAR_CS() { return GetToken(OracleAntlrParser.CHAR_CS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NCHAR_CS() { return GetToken(OracleAntlrParser.NCHAR_CS, 0); }
		public TranslateExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_translateExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTranslateExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTranslateExpression(this);
		}
	}

	[RuleVersion(0)]
	public TranslateExpressionContext translateExpression() {
		TranslateExpressionContext _localctx = new TranslateExpressionContext(Context, State);
		EnterRule(_localctx, 1354, RULE_translateExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6555;
			Match(TRANSLATE);
			State = 6556;
			Match(LPAREN);
			State = 6557;
			fullExpression();
			State = 6558;
			Match(USING);
			State = 6559;
			_la = TokenStream.LA(1);
			if ( !(_la==CHAR_CS || _la==NCHAR_CS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 6560;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CharExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHR() { return GetToken(OracleAntlrParser.CHR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NCHAR_CS() { return GetToken(OracleAntlrParser.NCHAR_CS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NCHR() { return GetToken(OracleAntlrParser.NCHR, 0); }
		public CharExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_charExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCharExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCharExpression(this);
		}
	}

	[RuleVersion(0)]
	public CharExpressionContext charExpression() {
		CharExpressionContext _localctx = new CharExpressionContext(Context, State);
		EnterRule(_localctx, 1356, RULE_charExpression);
		try {
			State = 6574;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CHR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6562;
				Match(CHR);
				State = 6563;
				Match(LPAREN);
				State = 6564;
				fullExpression();
				State = 6565;
				Match(USING);
				State = 6566;
				Match(NCHAR_CS);
				State = 6567;
				Match(RPAREN);
				}
				break;
			case NCHR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6569;
				Match(NCHR);
				State = 6570;
				Match(LPAREN);
				State = 6571;
				fullExpression();
				State = 6572;
				Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ControlStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhileStatementContext whileStatement() {
			return GetRuleContext<WhileStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForStatementContext forStatement() {
			return GetRuleContext<ForStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseStatementContext caseStatement() {
			return GetRuleContext<CaseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoopStatementContext loopStatement() {
			return GetRuleContext<LoopStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForAllStatementContext forAllStatement() {
			return GetRuleContext<ForAllStatementContext>(0);
		}
		public ControlStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_controlStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterControlStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitControlStructure(this);
		}
	}

	[RuleVersion(0)]
	public ControlStructureContext controlStructure() {
		ControlStructureContext _localctx = new ControlStructureContext(Context, State);
		EnterRule(_localctx, 1358, RULE_controlStructure);
		try {
			State = 6582;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IF:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6576;
				ifStatement();
				}
				break;
			case WHILE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6577;
				whileStatement();
				}
				break;
			case FOR:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6578;
				forStatement();
				}
				break;
			case CASE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 6579;
				caseStatement();
				}
				break;
			case LOOP:
				EnterOuterAlt(_localctx, 5);
				{
				State = 6580;
				loopStatement();
				}
				break;
			case FORALL:
				EnterOuterAlt(_localctx, 6);
				{
				State = 6581;
				forAllStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForAllStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORALL() { return GetToken(OracleAntlrParser.FORALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForAllInClauseContext forAllInClause() {
			return GetRuleContext<ForAllInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertStatementContext insertStatement() {
			return GetRuleContext<InsertStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeleteStatementContext deleteStatement() {
			return GetRuleContext<DeleteStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UpdateStatementContext updateStatement() {
			return GetRuleContext<UpdateStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeStatementContext mergeStatement() {
			return GetRuleContext<MergeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExecuteImmediateStatementContext executeImmediateStatement() {
			return GetRuleContext<ExecuteImmediateStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForAllSaveExceptionsClauseContext forAllSaveExceptionsClause() {
			return GetRuleContext<ForAllSaveExceptionsClauseContext>(0);
		}
		public ForAllStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forAllStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForAllStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForAllStatement(this);
		}
	}

	[RuleVersion(0)]
	public ForAllStatementContext forAllStatement() {
		ForAllStatementContext _localctx = new ForAllStatementContext(Context, State);
		EnterRule(_localctx, 1360, RULE_forAllStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6584;
			Match(FORALL);
			State = 6585;
			simpleIdentifier();
			State = 6586;
			forAllInClause();
			State = 6588;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SAVE) {
				{
				State = 6587;
				forAllSaveExceptionsClause();
				}
			}

			State = 6595;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INSERT:
				{
				State = 6590;
				insertStatement();
				}
				break;
			case DELETE:
				{
				State = 6591;
				deleteStatement();
				}
				break;
			case UPDATE:
				{
				State = 6592;
				updateStatement();
				}
				break;
			case MERGE:
				{
				State = 6593;
				mergeStatement();
				}
				break;
			case EXECUTE:
				{
				State = 6594;
				executeImmediateStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForAllInClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ForAllIndicesClauseContext forAllIndicesClause() {
			return GetRuleContext<ForAllIndicesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForAllValuesClauseContext forAllValuesClause() {
			return GetRuleContext<ForAllValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForAllLowerUpperBoundClauseContext forAllLowerUpperBoundClause() {
			return GetRuleContext<ForAllLowerUpperBoundClauseContext>(0);
		}
		public ForAllInClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forAllInClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForAllInClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForAllInClause(this);
		}
	}

	[RuleVersion(0)]
	public ForAllInClauseContext forAllInClause() {
		ForAllInClauseContext _localctx = new ForAllInClauseContext(Context, State);
		EnterRule(_localctx, 1362, RULE_forAllInClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6597;
			Match(IN);
			State = 6601;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,738,Context) ) {
			case 1:
				{
				State = 6598;
				forAllIndicesClause();
				}
				break;
			case 2:
				{
				State = 6599;
				forAllValuesClause();
				}
				break;
			case 3:
				{
				State = 6600;
				forAllLowerUpperBoundClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForAllIndicesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDICES() { return GetToken(OracleAntlrParser.INDICES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForAllIndeciesBoundsClauseContext forAllIndeciesBoundsClause() {
			return GetRuleContext<ForAllIndeciesBoundsClauseContext>(0);
		}
		public ForAllIndicesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forAllIndicesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForAllIndicesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForAllIndicesClause(this);
		}
	}

	[RuleVersion(0)]
	public ForAllIndicesClauseContext forAllIndicesClause() {
		ForAllIndicesClauseContext _localctx = new ForAllIndicesClauseContext(Context, State);
		EnterRule(_localctx, 1364, RULE_forAllIndicesClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6603;
			Match(INDICES);
			State = 6604;
			Match(OF);
			State = 6605;
			identifier();
			State = 6607;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BETWEEN) {
				{
				State = 6606;
				forAllIndeciesBoundsClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForAllIndeciesBoundsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BETWEEN() { return GetToken(OracleAntlrParser.BETWEEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(OracleAntlrParser.AND, 0); }
		public ForAllIndeciesBoundsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forAllIndeciesBoundsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForAllIndeciesBoundsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForAllIndeciesBoundsClause(this);
		}
	}

	[RuleVersion(0)]
	public ForAllIndeciesBoundsClauseContext forAllIndeciesBoundsClause() {
		ForAllIndeciesBoundsClauseContext _localctx = new ForAllIndeciesBoundsClauseContext(Context, State);
		EnterRule(_localctx, 1366, RULE_forAllIndeciesBoundsClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6609;
			Match(BETWEEN);
			State = 6610;
			fullExpression();
			State = 6613;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AND) {
				{
				State = 6611;
				Match(AND);
				State = 6612;
				fullExpression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForAllValuesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUES() { return GetToken(OracleAntlrParser.VALUES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ForAllValuesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forAllValuesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForAllValuesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForAllValuesClause(this);
		}
	}

	[RuleVersion(0)]
	public ForAllValuesClauseContext forAllValuesClause() {
		ForAllValuesClauseContext _localctx = new ForAllValuesClauseContext(Context, State);
		EnterRule(_localctx, 1368, RULE_forAllValuesClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6615;
			Match(VALUES);
			State = 6616;
			Match(OF);
			State = 6617;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForAllLowerUpperBoundClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterDoubleDotContext delimiterDoubleDot() {
			return GetRuleContext<DelimiterDoubleDotContext>(0);
		}
		public ForAllLowerUpperBoundClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forAllLowerUpperBoundClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForAllLowerUpperBoundClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForAllLowerUpperBoundClause(this);
		}
	}

	[RuleVersion(0)]
	public ForAllLowerUpperBoundClauseContext forAllLowerUpperBoundClause() {
		ForAllLowerUpperBoundClauseContext _localctx = new ForAllLowerUpperBoundClauseContext(Context, State);
		EnterRule(_localctx, 1370, RULE_forAllLowerUpperBoundClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6619;
			fullExpression();
			State = 6620;
			delimiterDoubleDot();
			State = 6621;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForAllSaveExceptionsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SAVE() { return GetToken(OracleAntlrParser.SAVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPTIONS() { return GetToken(OracleAntlrParser.EXCEPTIONS, 0); }
		public ForAllSaveExceptionsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forAllSaveExceptionsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForAllSaveExceptionsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForAllSaveExceptionsClause(this);
		}
	}

	[RuleVersion(0)]
	public ForAllSaveExceptionsClauseContext forAllSaveExceptionsClause() {
		ForAllSaveExceptionsClauseContext _localctx = new ForAllSaveExceptionsClauseContext(Context, State);
		EnterRule(_localctx, 1372, RULE_forAllSaveExceptionsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6623;
			Match(SAVE);
			State = 6624;
			Match(EXCEPTIONS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] IF() { return GetTokens(OracleAntlrParser.IF); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF(int i) {
			return GetToken(OracleAntlrParser.IF, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ThenBlockContext thenBlock() {
			return GetRuleContext<ThenBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(OracleAntlrParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ElsIfBlockContext[] elsIfBlock() {
			return GetRuleContexts<ElsIfBlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElsIfBlockContext elsIfBlock(int i) {
			return GetRuleContext<ElsIfBlockContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseBlockContext elseBlock() {
			return GetRuleContext<ElseBlockContext>(0);
		}
		public IfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIfStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIfStatement(this);
		}
	}

	[RuleVersion(0)]
	public IfStatementContext ifStatement() {
		IfStatementContext _localctx = new IfStatementContext(Context, State);
		EnterRule(_localctx, 1374, RULE_ifStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6626;
			Match(IF);
			State = 6627;
			fullExpression();
			State = 6628;
			thenBlock();
			State = 6632;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ELSIF) {
				{
				{
				State = 6629;
				elsIfBlock();
				}
				}
				State = 6634;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6636;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 6635;
				elseBlock();
				}
			}

			State = 6638;
			Match(END);
			State = 6639;
			Match(IF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ThenBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(OracleAntlrParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlSqlStatementBatchContext plSqlStatementBatch() {
			return GetRuleContext<PlSqlStatementBatchContext>(0);
		}
		public ThenBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_thenBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterThenBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitThenBlock(this);
		}
	}

	[RuleVersion(0)]
	public ThenBlockContext thenBlock() {
		ThenBlockContext _localctx = new ThenBlockContext(Context, State);
		EnterRule(_localctx, 1376, RULE_thenBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6641;
			Match(THEN);
			State = 6642;
			plSqlStatementBatch();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(OracleAntlrParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlSqlStatementBatchContext plSqlStatementBatch() {
			return GetRuleContext<PlSqlStatementBatchContext>(0);
		}
		public ElseBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterElseBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitElseBlock(this);
		}
	}

	[RuleVersion(0)]
	public ElseBlockContext elseBlock() {
		ElseBlockContext _localctx = new ElseBlockContext(Context, State);
		EnterRule(_localctx, 1378, RULE_elseBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6644;
			Match(ELSE);
			State = 6645;
			plSqlStatementBatch();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElsIfBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSIF() { return GetToken(OracleAntlrParser.ELSIF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ThenBlockContext thenBlock() {
			return GetRuleContext<ThenBlockContext>(0);
		}
		public ElsIfBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elsIfBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterElsIfBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitElsIfBlock(this);
		}
	}

	[RuleVersion(0)]
	public ElsIfBlockContext elsIfBlock() {
		ElsIfBlockContext _localctx = new ElsIfBlockContext(Context, State);
		EnterRule(_localctx, 1380, RULE_elsIfBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6647;
			Match(ELSIF);
			State = 6648;
			fullExpression();
			State = 6649;
			thenBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfDirectiveStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE_IF() { return GetToken(OracleAntlrParser.DIRECTIVE_IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ThenDirectiveBlockContext thenDirectiveBlock() {
			return GetRuleContext<ThenDirectiveBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE_END() { return GetToken(OracleAntlrParser.DIRECTIVE_END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ElsIfDirectiveBlockContext[] elsIfDirectiveBlock() {
			return GetRuleContexts<ElsIfDirectiveBlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElsIfDirectiveBlockContext elsIfDirectiveBlock(int i) {
			return GetRuleContext<ElsIfDirectiveBlockContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseDirectiveBlockContext elseDirectiveBlock() {
			return GetRuleContext<ElseDirectiveBlockContext>(0);
		}
		public IfDirectiveStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifDirectiveStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIfDirectiveStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIfDirectiveStatement(this);
		}
	}

	[RuleVersion(0)]
	public IfDirectiveStatementContext ifDirectiveStatement() {
		IfDirectiveStatementContext _localctx = new IfDirectiveStatementContext(Context, State);
		EnterRule(_localctx, 1382, RULE_ifDirectiveStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6651;
			Match(DIRECTIVE_IF);
			State = 6652;
			fullExpression();
			State = 6653;
			thenDirectiveBlock();
			State = 6657;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DIRECTIVE_ELSIF) {
				{
				{
				State = 6654;
				elsIfDirectiveBlock();
				}
				}
				State = 6659;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6661;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DIRECTIVE_ELSE) {
				{
				State = 6660;
				elseDirectiveBlock();
				}
			}

			State = 6663;
			Match(DIRECTIVE_END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ThenDirectiveBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE_THEN() { return GetToken(OracleAntlrParser.DIRECTIVE_THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ErrorDirectiveBlockContext[] errorDirectiveBlock() {
			return GetRuleContexts<ErrorDirectiveBlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorDirectiveBlockContext errorDirectiveBlock(int i) {
			return GetRuleContext<ErrorDirectiveBlockContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockItemContext[] declarationBlockItem() {
			return GetRuleContexts<DeclarationBlockItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockItemContext declarationBlockItem(int i) {
			return GetRuleContext<DeclarationBlockItemContext>(i);
		}
		public ThenDirectiveBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_thenDirectiveBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterThenDirectiveBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitThenDirectiveBlock(this);
		}
	}

	[RuleVersion(0)]
	public ThenDirectiveBlockContext thenDirectiveBlock() {
		ThenDirectiveBlockContext _localctx = new ThenDirectiveBlockContext(Context, State);
		EnterRule(_localctx, 1384, RULE_thenDirectiveBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6665;
			Match(DIRECTIVE_THEN);
			State = 6670;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DIRECTIVE_ERROR - 128)) | (1L << (DIRECTIVE_IF - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 6668;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DIRECTIVE_ERROR:
					{
					State = 6666;
					errorDirectiveBlock();
					}
					break;
				case A_:
				case ACCOUNT:
				case ADVANCED:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ALLOCATE:
				case ALLOW:
				case ALWAYS:
				case ANALYZE:
				case ANYSCHEMA:
				case ARCHIVE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case ATTRIBUTES:
				case AUTHENTICATION:
				case AUTHID:
				case AUTO:
				case AUTONOMOUS_TRANSACTION:
				case BASIC:
				case BASICFILE:
				case BATCH:
				case BEFORE:
				case BEGINNING:
				case BINARY:
				case BITMAP:
				case BLOCK:
				case BODY:
				case BOTH:
				case BREADTH:
				case BUFFER_POOL:
				case BUILD:
				case BUILTIN:
				case BULK:
				case BULK_EXCEPTIONS:
				case BULK_ROWCOUNT:
				case BYTE:
				case C_:
				case CACHE:
				case CALL:
				case CASCADE:
				case CAST:
				case CELL_FLASH_CACHE:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHARSET:
				case CHR:
				case CHUNK:
				case CLOB:
				case CLOSE:
				case COALESCE:
				case COLLATION:
				case COLLECT:
				case COLUMN_VALUE:
				case COMMIT:
				case COMMITTED:
				case COMPACT:
				case COMPILE:
				case COMPLETE:
				case COMPOUND:
				case COMPUTATION:
				case COMPUTE:
				case CONDITIONAL:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTAINER:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case COUNT:
				case CREATION:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DATAFILE:
				case DATE:
				case DAY:
				case DBTIMEZONE:
				case DDL:
				case DEALLOCATE:
				case DEBUG:
				case DECODE:
				case DECRYPT:
				case DEDUPLICATE:
				case DEFERRABLE:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DEMAND:
				case DENSE_RANK:
				case DEPTH:
				case DETERMINISTIC:
				case DIRECT_LOAD:
				case DIRECTIVE_IF:
				case DISABLE:
				case DISALLOW:
				case DISASSOCIATE:
				case DOUBLE:
				case DUPLICATED:
				case EACH:
				case EDITION:
				case EDITIONABLE:
				case EDITIONING:
				case EDITIONS:
				case ELEMENT:
				case ELSIF:
				case EMPTY_KEYWORD:
				case ENABLE:
				case ENCRYPT:
				case ENFORCED:
				case ERROR_CODE:
				case ERROR_INDEX:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVALUATE:
				case EXCEPT:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXISTS:
				case EXIT:
				case EXPIRE:
				case EXTEND:
				case EXTENDED:
				case EXTENT:
				case EXTERNALLY:
				case EXTRACT:
				case FALSE:
				case FAST:
				case FILESYSTEM_LIKE_LOGGING:
				case FINAL:
				case FIPSFLAG:
				case FIRST:
				case FIRST_ROWS:
				case FIXED:
				case FOLLOWING:
				case FORALL:
				case FORCE:
				case FOREIGN:
				case FORMAT:
				case FOUND:
				case FLASH_CACHE:
				case FREELIST:
				case FREELISTS:
				case FREEPOOLS:
				case FULL:
				case FUNCTION:
				case GENERATED:
				case GLOBAL:
				case GLOBALLY:
				case GROUPING:
				case GROUPS:
				case HASH:
				case HEAP:
				case HIGH:
				case HOUR:
				case ID:
				case IDENTIFIER:
				case IDENTITY:
				case INCLUDE:
				case INCLUDING:
				case INDEXING:
				case INDICATOR:
				case INDICES:
				case INITIALLY:
				case INITRANS:
				case INNER:
				case INSTANCE:
				case INSTANTIABLE:
				case INSTEAD:
				case INTERFACE:
				case INTERVAL:
				case INVALIDATE:
				case INVALIDATION:
				case INVISIBLE:
				case ISOLATION:
				case ISOPEN:
				case JAVA:
				case JOIN:
				case JSON:
				case JSON_TABLE:
				case KEEP:
				case KEEP_DUPLICATES:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LEADING:
				case LEFT:
				case LESS:
				case LEVEL:
				case LEVELS:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LIST:
				case LOB:
				case LOBS:
				case LOCAL:
				case LOCATOR:
				case LOCKED:
				case LOCKING:
				case LOG:
				case LOGGING:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOW:
				case MAP:
				case MAPPING:
				case MASTER:
				case MATCHED:
				case MATERIALIZED:
				case MAX:
				case MAXSIZE:
				case MAXTRANS:
				case MAXVALUE:
				case MEDIUM:
				case MEMBER:
				case MEMOPTIMIZE:
				case MERGE:
				case METADATA:
				case MIN:
				case MINEXTENTS:
				case MINUTE:
				case MINVALUE:
				case MOD:
				case MONITORING:
				case MONTH:
				case MOVEMENT:
				case MULTISET:
				case NAME:
				case NATIONAL:
				case NATURAL:
				case NCHAR:
				case NCHAR_CS:
				case NCHR:
				case NESTED:
				case NEVER:
				case NEW:
				case NEW_NAMES:
				case NEXT:
				case NO:
				case NOCACHE:
				case NOCOPY:
				case NOCYCLE:
				case NOEXTEND:
				case NOKEEP:
				case NOLOGGING:
				case NOMAPPING:
				case NOMAXVALUE:
				case NOMINVALUE:
				case NOMONITORING:
				case NOORDER:
				case NONE:
				case NONEDITIONABLE:
				case NONSCHEMA:
				case NOPARALLEL:
				case NORELY:
				case NOREVERSE:
				case NOROWDEPENDENCIES:
				case NOSCALE:
				case NOSHARD:
				case NOSORT:
				case NOTFOUND:
				case NOVALIDATE:
				case NULLS:
				case OBJECT:
				case OID:
				case OIDINDEX:
				case OLD:
				case ONLY:
				case ONLINE:
				case OPAQUE:
				case OPEN:
				case OPERATIONS:
				case OPTIMAL:
				case ORDINALITY:
				case ORGANIZATION:
				case OUT:
				case OUTER:
				case OVER:
				case OVERFLOW:
				case OVERLAPS:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTIAL:
				case PARTITION:
				case PARTITIONS:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PCTINCREASE:
				case PCTTHRESHOLD:
				case PCTUSED:
				case PCTVERSION:
				case PERCENTILE_DISC:
				case PERIOD:
				case PIPE:
				case PIPELINED:
				case POLYMORPHIC:
				case PRAGMA:
				case PREBUILT:
				case PRECEDING:
				case PRECISION:
				case PRESERVE:
				case PRIMARY:
				case PRIOR:
				case PRIVATE:
				case PROCEDURE:
				case PROFILE:
				case PUBLIC:
				case PURGE:
				case QUERY:
				case QUOTA:
				case RAISE:
				case RAISE_APPLICATION_ERROR:
				case RANGE:
				case RAW:
				case READ:
				case READS:
				case REBUILD:
				case RECORD:
				case RECYCLE:
				case REDUCED:
				case REF:
				case REFERENCES:
				case REFERENCING:
				case REFRESH:
				case REJECT:
				case RELATIONAL:
				case RELIES_ON:
				case RELY:
				case RENAME:
				case REPLACE:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETENTION:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case REWRITE:
				case RIGHT:
				case ROLLUP:
				case ROW:
				case ROWCOUNT:
				case ROWDEPENDENCIES:
				case ROWID:
				case ROWTYPE:
				case SALT:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCALE:
				case SCHEMA:
				case SCN:
				case SCOPE:
				case SEARCH:
				case SECOND:
				case SECUREFILE:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSION:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHRINK:
				case SHUTDOWN:
				case SIBLINGS:
				case SIZE:
				case SKIP_:
				case SOME:
				case SORT:
				case SPACE:
				case SPECIFICATION:
				case SPLIT:
				case STARTUP:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORAGE:
				case STORE:
				case STRING:
				case SHARD:
				case SHARDED:
				case SHARING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUPPLEMENTAL:
				case SUSPEND:
				case SYNONYM:
				case SYSTEM:
				case TABLES:
				case TABLESPACE:
				case TEMPLATE:
				case TEMPORARY:
				case THAN:
				case TIME:
				case TIMESTAMP:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIM:
				case TRUE:
				case TRUNCATE:
				case TRUSTED:
				case TYPE:
				case UNBOUNDED:
				case UNCONDITIONAL:
				case UNDER:
				case UNLIMITED:
				case UNLOCK:
				case UNUSABLE:
				case UNUSED:
				case USABLE:
				case USAGE:
				case USE:
				case USER:
				case USING:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARRAY:
				case VARRAYS:
				case VARYING:
				case VERSIONS:
				case VIRTUAL:
				case VISIBLE:
				case WAIT:
				case WHEN:
				case WITHIN:
				case WITHOUT:
				case WORK:
				case WRAPPED:
				case WRAPPER:
				case WRITE:
				case XML:
				case XMLNAMESPACES:
				case XMLSCHEMA:
				case XMLTABLE:
				case XMLTYPE:
				case YEAR:
				case ZONE:
				case REGULAR_IDENTIFIER:
				case QUOTED_IDENTIFIER:
					{
					State = 6667;
					declarationBlockItem();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 6672;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseDirectiveBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE_ELSE() { return GetToken(OracleAntlrParser.DIRECTIVE_ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ErrorDirectiveBlockContext[] errorDirectiveBlock() {
			return GetRuleContexts<ErrorDirectiveBlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorDirectiveBlockContext errorDirectiveBlock(int i) {
			return GetRuleContext<ErrorDirectiveBlockContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockItemContext[] declarationBlockItem() {
			return GetRuleContexts<DeclarationBlockItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockItemContext declarationBlockItem(int i) {
			return GetRuleContext<DeclarationBlockItemContext>(i);
		}
		public ElseDirectiveBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseDirectiveBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterElseDirectiveBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitElseDirectiveBlock(this);
		}
	}

	[RuleVersion(0)]
	public ElseDirectiveBlockContext elseDirectiveBlock() {
		ElseDirectiveBlockContext _localctx = new ElseDirectiveBlockContext(Context, State);
		EnterRule(_localctx, 1386, RULE_elseDirectiveBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6673;
			Match(DIRECTIVE_ELSE);
			State = 6678;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DIRECTIVE_ERROR - 128)) | (1L << (DIRECTIVE_IF - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 6676;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DIRECTIVE_ERROR:
					{
					State = 6674;
					errorDirectiveBlock();
					}
					break;
				case A_:
				case ACCOUNT:
				case ADVANCED:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ALLOCATE:
				case ALLOW:
				case ALWAYS:
				case ANALYZE:
				case ANYSCHEMA:
				case ARCHIVE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case ATTRIBUTES:
				case AUTHENTICATION:
				case AUTHID:
				case AUTO:
				case AUTONOMOUS_TRANSACTION:
				case BASIC:
				case BASICFILE:
				case BATCH:
				case BEFORE:
				case BEGINNING:
				case BINARY:
				case BITMAP:
				case BLOCK:
				case BODY:
				case BOTH:
				case BREADTH:
				case BUFFER_POOL:
				case BUILD:
				case BUILTIN:
				case BULK:
				case BULK_EXCEPTIONS:
				case BULK_ROWCOUNT:
				case BYTE:
				case C_:
				case CACHE:
				case CALL:
				case CASCADE:
				case CAST:
				case CELL_FLASH_CACHE:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHARSET:
				case CHR:
				case CHUNK:
				case CLOB:
				case CLOSE:
				case COALESCE:
				case COLLATION:
				case COLLECT:
				case COLUMN_VALUE:
				case COMMIT:
				case COMMITTED:
				case COMPACT:
				case COMPILE:
				case COMPLETE:
				case COMPOUND:
				case COMPUTATION:
				case COMPUTE:
				case CONDITIONAL:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTAINER:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case COUNT:
				case CREATION:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DATAFILE:
				case DATE:
				case DAY:
				case DBTIMEZONE:
				case DDL:
				case DEALLOCATE:
				case DEBUG:
				case DECODE:
				case DECRYPT:
				case DEDUPLICATE:
				case DEFERRABLE:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DEMAND:
				case DENSE_RANK:
				case DEPTH:
				case DETERMINISTIC:
				case DIRECT_LOAD:
				case DIRECTIVE_IF:
				case DISABLE:
				case DISALLOW:
				case DISASSOCIATE:
				case DOUBLE:
				case DUPLICATED:
				case EACH:
				case EDITION:
				case EDITIONABLE:
				case EDITIONING:
				case EDITIONS:
				case ELEMENT:
				case ELSIF:
				case EMPTY_KEYWORD:
				case ENABLE:
				case ENCRYPT:
				case ENFORCED:
				case ERROR_CODE:
				case ERROR_INDEX:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVALUATE:
				case EXCEPT:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXISTS:
				case EXIT:
				case EXPIRE:
				case EXTEND:
				case EXTENDED:
				case EXTENT:
				case EXTERNALLY:
				case EXTRACT:
				case FALSE:
				case FAST:
				case FILESYSTEM_LIKE_LOGGING:
				case FINAL:
				case FIPSFLAG:
				case FIRST:
				case FIRST_ROWS:
				case FIXED:
				case FOLLOWING:
				case FORALL:
				case FORCE:
				case FOREIGN:
				case FORMAT:
				case FOUND:
				case FLASH_CACHE:
				case FREELIST:
				case FREELISTS:
				case FREEPOOLS:
				case FULL:
				case FUNCTION:
				case GENERATED:
				case GLOBAL:
				case GLOBALLY:
				case GROUPING:
				case GROUPS:
				case HASH:
				case HEAP:
				case HIGH:
				case HOUR:
				case ID:
				case IDENTIFIER:
				case IDENTITY:
				case INCLUDE:
				case INCLUDING:
				case INDEXING:
				case INDICATOR:
				case INDICES:
				case INITIALLY:
				case INITRANS:
				case INNER:
				case INSTANCE:
				case INSTANTIABLE:
				case INSTEAD:
				case INTERFACE:
				case INTERVAL:
				case INVALIDATE:
				case INVALIDATION:
				case INVISIBLE:
				case ISOLATION:
				case ISOPEN:
				case JAVA:
				case JOIN:
				case JSON:
				case JSON_TABLE:
				case KEEP:
				case KEEP_DUPLICATES:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LEADING:
				case LEFT:
				case LESS:
				case LEVEL:
				case LEVELS:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LIST:
				case LOB:
				case LOBS:
				case LOCAL:
				case LOCATOR:
				case LOCKED:
				case LOCKING:
				case LOG:
				case LOGGING:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOW:
				case MAP:
				case MAPPING:
				case MASTER:
				case MATCHED:
				case MATERIALIZED:
				case MAX:
				case MAXSIZE:
				case MAXTRANS:
				case MAXVALUE:
				case MEDIUM:
				case MEMBER:
				case MEMOPTIMIZE:
				case MERGE:
				case METADATA:
				case MIN:
				case MINEXTENTS:
				case MINUTE:
				case MINVALUE:
				case MOD:
				case MONITORING:
				case MONTH:
				case MOVEMENT:
				case MULTISET:
				case NAME:
				case NATIONAL:
				case NATURAL:
				case NCHAR:
				case NCHAR_CS:
				case NCHR:
				case NESTED:
				case NEVER:
				case NEW:
				case NEW_NAMES:
				case NEXT:
				case NO:
				case NOCACHE:
				case NOCOPY:
				case NOCYCLE:
				case NOEXTEND:
				case NOKEEP:
				case NOLOGGING:
				case NOMAPPING:
				case NOMAXVALUE:
				case NOMINVALUE:
				case NOMONITORING:
				case NOORDER:
				case NONE:
				case NONEDITIONABLE:
				case NONSCHEMA:
				case NOPARALLEL:
				case NORELY:
				case NOREVERSE:
				case NOROWDEPENDENCIES:
				case NOSCALE:
				case NOSHARD:
				case NOSORT:
				case NOTFOUND:
				case NOVALIDATE:
				case NULLS:
				case OBJECT:
				case OID:
				case OIDINDEX:
				case OLD:
				case ONLY:
				case ONLINE:
				case OPAQUE:
				case OPEN:
				case OPERATIONS:
				case OPTIMAL:
				case ORDINALITY:
				case ORGANIZATION:
				case OUT:
				case OUTER:
				case OVER:
				case OVERFLOW:
				case OVERLAPS:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTIAL:
				case PARTITION:
				case PARTITIONS:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PCTINCREASE:
				case PCTTHRESHOLD:
				case PCTUSED:
				case PCTVERSION:
				case PERCENTILE_DISC:
				case PERIOD:
				case PIPE:
				case PIPELINED:
				case POLYMORPHIC:
				case PRAGMA:
				case PREBUILT:
				case PRECEDING:
				case PRECISION:
				case PRESERVE:
				case PRIMARY:
				case PRIOR:
				case PRIVATE:
				case PROCEDURE:
				case PROFILE:
				case PUBLIC:
				case PURGE:
				case QUERY:
				case QUOTA:
				case RAISE:
				case RAISE_APPLICATION_ERROR:
				case RANGE:
				case RAW:
				case READ:
				case READS:
				case REBUILD:
				case RECORD:
				case RECYCLE:
				case REDUCED:
				case REF:
				case REFERENCES:
				case REFERENCING:
				case REFRESH:
				case REJECT:
				case RELATIONAL:
				case RELIES_ON:
				case RELY:
				case RENAME:
				case REPLACE:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETENTION:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case REWRITE:
				case RIGHT:
				case ROLLUP:
				case ROW:
				case ROWCOUNT:
				case ROWDEPENDENCIES:
				case ROWID:
				case ROWTYPE:
				case SALT:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCALE:
				case SCHEMA:
				case SCN:
				case SCOPE:
				case SEARCH:
				case SECOND:
				case SECUREFILE:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSION:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHRINK:
				case SHUTDOWN:
				case SIBLINGS:
				case SIZE:
				case SKIP_:
				case SOME:
				case SORT:
				case SPACE:
				case SPECIFICATION:
				case SPLIT:
				case STARTUP:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORAGE:
				case STORE:
				case STRING:
				case SHARD:
				case SHARDED:
				case SHARING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUPPLEMENTAL:
				case SUSPEND:
				case SYNONYM:
				case SYSTEM:
				case TABLES:
				case TABLESPACE:
				case TEMPLATE:
				case TEMPORARY:
				case THAN:
				case TIME:
				case TIMESTAMP:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIM:
				case TRUE:
				case TRUNCATE:
				case TRUSTED:
				case TYPE:
				case UNBOUNDED:
				case UNCONDITIONAL:
				case UNDER:
				case UNLIMITED:
				case UNLOCK:
				case UNUSABLE:
				case UNUSED:
				case USABLE:
				case USAGE:
				case USE:
				case USER:
				case USING:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARRAY:
				case VARRAYS:
				case VARYING:
				case VERSIONS:
				case VIRTUAL:
				case VISIBLE:
				case WAIT:
				case WHEN:
				case WITHIN:
				case WITHOUT:
				case WORK:
				case WRAPPED:
				case WRAPPER:
				case WRITE:
				case XML:
				case XMLNAMESPACES:
				case XMLSCHEMA:
				case XMLTABLE:
				case XMLTYPE:
				case YEAR:
				case ZONE:
				case REGULAR_IDENTIFIER:
				case QUOTED_IDENTIFIER:
					{
					State = 6675;
					declarationBlockItem();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 6680;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElsIfDirectiveBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE_ELSIF() { return GetToken(OracleAntlrParser.DIRECTIVE_ELSIF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ThenDirectiveBlockContext thenDirectiveBlock() {
			return GetRuleContext<ThenDirectiveBlockContext>(0);
		}
		public ElsIfDirectiveBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elsIfDirectiveBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterElsIfDirectiveBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitElsIfDirectiveBlock(this);
		}
	}

	[RuleVersion(0)]
	public ElsIfDirectiveBlockContext elsIfDirectiveBlock() {
		ElsIfDirectiveBlockContext _localctx = new ElsIfDirectiveBlockContext(Context, State);
		EnterRule(_localctx, 1388, RULE_elsIfDirectiveBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6681;
			Match(DIRECTIVE_ELSIF);
			State = 6682;
			fullExpression();
			State = 6683;
			thenDirectiveBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ErrorDirectiveBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE_ERROR() { return GetToken(OracleAntlrParser.DIRECTIVE_ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE_END() { return GetToken(OracleAntlrParser.DIRECTIVE_END, 0); }
		public ErrorDirectiveBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_errorDirectiveBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterErrorDirectiveBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitErrorDirectiveBlock(this);
		}
	}

	[RuleVersion(0)]
	public ErrorDirectiveBlockContext errorDirectiveBlock() {
		ErrorDirectiveBlockContext _localctx = new ErrorDirectiveBlockContext(Context, State);
		EnterRule(_localctx, 1390, RULE_errorDirectiveBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6685;
			Match(DIRECTIVE_ERROR);
			State = 6686;
			fullExpression();
			State = 6687;
			Match(DIRECTIVE_END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LoopBlockContext loopBlock() {
			return GetRuleContext<LoopBlockContext>(0);
		}
		public LoopStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLoopStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLoopStatement(this);
		}
	}

	[RuleVersion(0)]
	public LoopStatementContext loopStatement() {
		LoopStatementContext _localctx = new LoopStatementContext(Context, State);
		EnterRule(_localctx, 1392, RULE_loopStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6689;
			loopBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOOP() { return GetToken(OracleAntlrParser.LOOP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlSqlStatementBatchContext plSqlStatementBatch() {
			return GetRuleContext<PlSqlStatementBatchContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndLoopClauseContext endLoopClause() {
			return GetRuleContext<EndLoopClauseContext>(0);
		}
		public LoopBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLoopBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLoopBlock(this);
		}
	}

	[RuleVersion(0)]
	public LoopBlockContext loopBlock() {
		LoopBlockContext _localctx = new LoopBlockContext(Context, State);
		EnterRule(_localctx, 1394, RULE_loopBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6691;
			Match(LOOP);
			State = 6692;
			plSqlStatementBatch();
			State = 6693;
			endLoopClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHILE() { return GetToken(OracleAntlrParser.WHILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoopBlockContext loopBlock() {
			return GetRuleContext<LoopBlockContext>(0);
		}
		public WhileStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterWhileStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitWhileStatement(this);
		}
	}

	[RuleVersion(0)]
	public WhileStatementContext whileStatement() {
		WhileStatementContext _localctx = new WhileStatementContext(Context, State);
		EnterRule(_localctx, 1396, RULE_whileStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6695;
			Match(WHILE);
			State = 6696;
			fullExpression();
			State = 6697;
			loopBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EndLoopClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(OracleAntlrParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOOP() { return GetToken(OracleAntlrParser.LOOP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier() {
			return GetRuleContext<SimpleIdentifierRegularIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTED_IDENTIFIER() { return GetToken(OracleAntlrParser.QUOTED_IDENTIFIER, 0); }
		public EndLoopClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_endLoopClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterEndLoopClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitEndLoopClause(this);
		}
	}

	[RuleVersion(0)]
	public EndLoopClauseContext endLoopClause() {
		EndLoopClauseContext _localctx = new EndLoopClauseContext(Context, State);
		EnterRule(_localctx, 1398, RULE_endLoopClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6699;
			Match(END);
			State = 6700;
			Match(LOOP);
			State = 6703;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
				{
				State = 6701;
				simpleIdentifierRegularIdentifier();
				}
				break;
			case QUOTED_IDENTIFIER:
				{
				State = 6702;
				Match(QUOTED_IDENTIFIER);
				}
				break;
			case SEMI:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForStatementInClauseContext forStatementInClause() {
			return GetRuleContext<ForStatementInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoopBlockContext loopBlock() {
			return GetRuleContext<LoopBlockContext>(0);
		}
		public ForStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForStatement(this);
		}
	}

	[RuleVersion(0)]
	public ForStatementContext forStatement() {
		ForStatementContext _localctx = new ForStatementContext(Context, State);
		EnterRule(_localctx, 1400, RULE_forStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6705;
			Match(FOR);
			State = 6706;
			simpleIdentifier();
			State = 6707;
			forStatementInClause();
			State = 6708;
			loopBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForStatementInClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REVERSE() { return GetToken(OracleAntlrParser.REVERSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOUBLE_DOT_OPERATOR() { return GetToken(OracleAntlrParser.DOUBLE_DOT_OPERATOR, 0); }
		public ForStatementInClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forStatementInClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForStatementInClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForStatementInClause(this);
		}
	}

	[RuleVersion(0)]
	public ForStatementInClauseContext forStatementInClause() {
		ForStatementInClauseContext _localctx = new ForStatementInClauseContext(Context, State);
		EnterRule(_localctx, 1402, RULE_forStatementInClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6710;
			Match(IN);
			State = 6712;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,750,Context) ) {
			case 1:
				{
				State = 6711;
				Match(REVERSE);
				}
				break;
			}
			State = 6714;
			fullExpression();
			State = 6717;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DOUBLE_DOT_OPERATOR) {
				{
				State = 6715;
				Match(DOUBLE_DOT_OPERATOR);
				State = 6716;
				fullExpression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ContinueStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTINUE() { return GetToken(OracleAntlrParser.CONTINUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OptionalLabelWhenConditionContext optionalLabelWhenCondition() {
			return GetRuleContext<OptionalLabelWhenConditionContext>(0);
		}
		public ContinueStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_continueStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterContinueStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitContinueStatement(this);
		}
	}

	[RuleVersion(0)]
	public ContinueStatementContext continueStatement() {
		ContinueStatementContext _localctx = new ContinueStatementContext(Context, State);
		EnterRule(_localctx, 1404, RULE_continueStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6719;
			Match(CONTINUE);
			State = 6721;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 6720;
				optionalLabelWhenCondition();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] CASE() { return GetTokens(OracleAntlrParser.CASE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASE(int i) {
			return GetToken(OracleAntlrParser.CASE, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(OracleAntlrParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SearchedCaseStatementContext searchedCaseStatement() {
			return GetRuleContext<SearchedCaseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleCaseStatementContext simpleCaseStatement() {
			return GetRuleContext<SimpleCaseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier() {
			return GetRuleContext<SimpleIdentifierRegularIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTED_IDENTIFIER() { return GetToken(OracleAntlrParser.QUOTED_IDENTIFIER, 0); }
		public CaseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCaseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCaseStatement(this);
		}
	}

	[RuleVersion(0)]
	public CaseStatementContext caseStatement() {
		CaseStatementContext _localctx = new CaseStatementContext(Context, State);
		EnterRule(_localctx, 1406, RULE_caseStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6723;
			Match(CASE);
			State = 6726;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,753,Context) ) {
			case 1:
				{
				State = 6724;
				searchedCaseStatement();
				}
				break;
			case 2:
				{
				State = 6725;
				simpleCaseStatement();
				}
				break;
			}
			State = 6728;
			Match(END);
			State = 6729;
			Match(CASE);
			State = 6732;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
				{
				State = 6730;
				simpleIdentifierRegularIdentifier();
				}
				break;
			case QUOTED_IDENTIFIER:
				{
				State = 6731;
				Match(QUOTED_IDENTIFIER);
				}
				break;
			case SEMI:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleCaseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseStatementWhenEntryContext[] caseStatementWhenEntry() {
			return GetRuleContexts<CaseStatementWhenEntryContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseStatementWhenEntryContext caseStatementWhenEntry(int i) {
			return GetRuleContext<CaseStatementWhenEntryContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseBlockContext elseBlock() {
			return GetRuleContext<ElseBlockContext>(0);
		}
		public SimpleCaseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleCaseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSimpleCaseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSimpleCaseStatement(this);
		}
	}

	[RuleVersion(0)]
	public SimpleCaseStatementContext simpleCaseStatement() {
		SimpleCaseStatementContext _localctx = new SimpleCaseStatementContext(Context, State);
		EnterRule(_localctx, 1408, RULE_simpleCaseStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6734;
			fullExpression();
			State = 6736;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6735;
				caseStatementWhenEntry();
				}
				}
				State = 6738;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 6741;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 6740;
				elseBlock();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SearchedCaseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CaseStatementWhenEntryContext[] caseStatementWhenEntry() {
			return GetRuleContexts<CaseStatementWhenEntryContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseStatementWhenEntryContext caseStatementWhenEntry(int i) {
			return GetRuleContext<CaseStatementWhenEntryContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseBlockContext elseBlock() {
			return GetRuleContext<ElseBlockContext>(0);
		}
		public SearchedCaseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searchedCaseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSearchedCaseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSearchedCaseStatement(this);
		}
	}

	[RuleVersion(0)]
	public SearchedCaseStatementContext searchedCaseStatement() {
		SearchedCaseStatementContext _localctx = new SearchedCaseStatementContext(Context, State);
		EnterRule(_localctx, 1410, RULE_searchedCaseStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6744;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6743;
				caseStatementWhenEntry();
				}
				}
				State = 6746;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 6749;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 6748;
				elseBlock();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseStatementWhenEntryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ThenBlockContext thenBlock() {
			return GetRuleContext<ThenBlockContext>(0);
		}
		public CaseStatementWhenEntryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseStatementWhenEntry; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCaseStatementWhenEntry(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCaseStatementWhenEntry(this);
		}
	}

	[RuleVersion(0)]
	public CaseStatementWhenEntryContext caseStatementWhenEntry() {
		CaseStatementWhenEntryContext _localctx = new CaseStatementWhenEntryContext(Context, State);
		EnterRule(_localctx, 1412, RULE_caseStatementWhenEntry);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6751;
			Match(WHEN);
			State = 6752;
			fullExpression();
			State = 6753;
			thenBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockBodyContext blockBody() {
			return GetRuleContext<BlockBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockContext declarationBlock() {
			return GetRuleContext<DeclarationBlockContext>(0);
		}
		public BlockStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBlockStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBlockStatement(this);
		}
	}

	[RuleVersion(0)]
	public BlockStatementContext blockStatement() {
		BlockStatementContext _localctx = new BlockStatementContext(Context, State);
		EnterRule(_localctx, 1414, RULE_blockStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6756;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECLARE - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DIRECTIVE_IF - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 6755;
				declarationBlock();
				}
			}

			State = 6758;
			blockBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEGIN() { return GetToken(OracleAntlrParser.BEGIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlSqlStatementBatchContext plSqlStatementBatch() {
			return GetRuleContext<PlSqlStatementBatchContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndClauseContext endClause() {
			return GetRuleContext<EndClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionBlockContext exceptionBlock() {
			return GetRuleContext<ExceptionBlockContext>(0);
		}
		public BlockBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBlockBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBlockBody(this);
		}
	}

	[RuleVersion(0)]
	public BlockBodyContext blockBody() {
		BlockBodyContext _localctx = new BlockBodyContext(Context, State);
		EnterRule(_localctx, 1416, RULE_blockBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6760;
			Match(BEGIN);
			State = 6761;
			plSqlStatementBatch();
			State = 6763;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXCEPTION) {
				{
				State = 6762;
				exceptionBlock();
				}
			}

			State = 6765;
			endClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EndClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(OracleAntlrParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier() {
			return GetRuleContext<SimpleIdentifierRegularIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTED_IDENTIFIER() { return GetToken(OracleAntlrParser.QUOTED_IDENTIFIER, 0); }
		public EndClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_endClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterEndClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitEndClause(this);
		}
	}

	[RuleVersion(0)]
	public EndClauseContext endClause() {
		EndClauseContext _localctx = new EndClauseContext(Context, State);
		EnterRule(_localctx, 1418, RULE_endClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6767;
			Match(END);
			State = 6770;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,761,Context) ) {
			case 1:
				{
				State = 6768;
				simpleIdentifierRegularIdentifier();
				}
				break;
			case 2:
				{
				State = 6769;
				Match(QUOTED_IDENTIFIER);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExceptionBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPTION() { return GetToken(OracleAntlrParser.EXCEPTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionHandlerContext[] exceptionHandler() {
			return GetRuleContexts<ExceptionHandlerContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionHandlerContext exceptionHandler(int i) {
			return GetRuleContext<ExceptionHandlerContext>(i);
		}
		public ExceptionBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exceptionBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExceptionBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExceptionBlock(this);
		}
	}

	[RuleVersion(0)]
	public ExceptionBlockContext exceptionBlock() {
		ExceptionBlockContext _localctx = new ExceptionBlockContext(Context, State);
		EnterRule(_localctx, 1420, RULE_exceptionBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6772;
			Match(EXCEPTION);
			State = 6774;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6773;
				exceptionHandler();
				}
				}
				State = 6776;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExceptionHandlerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionNameListContext exceptionNameList() {
			return GetRuleContext<ExceptionNameListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ThenBlockContext thenBlock() {
			return GetRuleContext<ThenBlockContext>(0);
		}
		public ExceptionHandlerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exceptionHandler; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExceptionHandler(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExceptionHandler(this);
		}
	}

	[RuleVersion(0)]
	public ExceptionHandlerContext exceptionHandler() {
		ExceptionHandlerContext _localctx = new ExceptionHandlerContext(Context, State);
		EnterRule(_localctx, 1422, RULE_exceptionHandler);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6778;
			Match(WHEN);
			State = 6779;
			exceptionNameList();
			State = 6780;
			thenBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExceptionNameListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] OR() { return GetTokens(OracleAntlrParser.OR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR(int i) {
			return GetToken(OracleAntlrParser.OR, i);
		}
		public ExceptionNameListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exceptionNameList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExceptionNameList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExceptionNameList(this);
		}
	}

	[RuleVersion(0)]
	public ExceptionNameListContext exceptionNameList() {
		ExceptionNameListContext _localctx = new ExceptionNameListContext(Context, State);
		EnterRule(_localctx, 1424, RULE_exceptionNameList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6782;
			identifier();
			State = 6787;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR) {
				{
				{
				State = 6783;
				Match(OR);
				State = 6784;
				identifier();
				}
				}
				State = 6789;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GotoStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GOTO() { return GetToken(OracleAntlrParser.GOTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public GotoStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gotoStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterGotoStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitGotoStatement(this);
		}
	}

	[RuleVersion(0)]
	public GotoStatementContext gotoStatement() {
		GotoStatementContext _localctx = new GotoStatementContext(Context, State);
		EnterRule(_localctx, 1426, RULE_gotoStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6790;
			Match(GOTO);
			State = 6791;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LabelBodyContext labelBody() {
			return GetRuleContext<LabelBodyContext>(0);
		}
		public LabelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLabel(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLabel(this);
		}
	}

	[RuleVersion(0)]
	public LabelContext label() {
		LabelContext _localctx = new LabelContext(Context, State);
		EnterRule(_localctx, 1428, RULE_label);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6793;
			labelBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LESS_THAN() { return GetTokens(OracleAntlrParser.LESS_THAN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS_THAN(int i) {
			return GetToken(OracleAntlrParser.LESS_THAN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] GREATER_THAN() { return GetTokens(OracleAntlrParser.GREATER_THAN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER_THAN(int i) {
			return GetToken(OracleAntlrParser.GREATER_THAN, i);
		}
		public LabelBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labelBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterLabelBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitLabelBody(this);
		}
	}

	[RuleVersion(0)]
	public LabelBodyContext labelBody() {
		LabelBodyContext _localctx = new LabelBodyContext(Context, State);
		EnterRule(_localctx, 1430, RULE_labelBody);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6795;
			Match(LESS_THAN);
			State = 6796;
			Match(LESS_THAN);
			State = 6797;
			simpleIdentifierWithoutParentheses();
			State = 6798;
			Match(GREATER_THAN);
			State = 6799;
			Match(GREATER_THAN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NullStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public NullStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nullStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNullStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNullStatement(this);
		}
	}

	[RuleVersion(0)]
	public NullStatementContext nullStatement() {
		NullStatementContext _localctx = new NullStatementContext(Context, State);
		EnterRule(_localctx, 1432, RULE_nullStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6801;
			Match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(OracleAntlrParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public ReturnStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterReturnStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitReturnStatement(this);
		}
	}

	[RuleVersion(0)]
	public ReturnStatementContext returnStatement() {
		ReturnStatementContext _localctx = new ReturnStatementContext(Context, State);
		EnterRule(_localctx, 1434, RULE_returnStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6803;
			Match(RETURN);
			State = 6805;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLAGG - 513)) | (1L << (XMLCAST - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLQUERY - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (INTEGER_LITERAL - 577)) | (1L << (LPAREN - 577)) | (1L << (PLUS_SIGN - 577)) | (1L << (MINUS_SIGN - 577)) | (1L << (QUESTION_MARK - 577)) | (1L << (ASTERISK - 577)) | (1L << (FLOATING_POINT_LITERAL - 577)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 577)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 577)) | (1L << (BINARY_STRING_LITERAL - 577)) | (1L << (CHARACTER_STRING_LITERAL - 577)) | (1L << (MONEY_LITERAL - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 577)))) != 0)) {
				{
				State = 6804;
				fullExpression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ProcedureCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterProcedureCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitProcedureCall(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureCallContext procedureCall() {
		ProcedureCallContext _localctx = new ProcedureCallContext(Context, State);
		EnterRule(_localctx, 1436, RULE_procedureCall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6807;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExitStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXIT() { return GetToken(OracleAntlrParser.EXIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OptionalLabelWhenConditionContext optionalLabelWhenCondition() {
			return GetRuleContext<OptionalLabelWhenConditionContext>(0);
		}
		public ExitStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exitStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExitStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExitStatement(this);
		}
	}

	[RuleVersion(0)]
	public ExitStatementContext exitStatement() {
		ExitStatementContext _localctx = new ExitStatementContext(Context, State);
		EnterRule(_localctx, 1438, RULE_exitStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6809;
			Match(EXIT);
			State = 6811;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 6810;
				optionalLabelWhenCondition();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionalLabelWhenConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public WhenConditionContext whenCondition() {
			return GetRuleContext<WhenConditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		public OptionalLabelWhenConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optionalLabelWhenCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOptionalLabelWhenCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOptionalLabelWhenCondition(this);
		}
	}

	[RuleVersion(0)]
	public OptionalLabelWhenConditionContext optionalLabelWhenCondition() {
		OptionalLabelWhenConditionContext _localctx = new OptionalLabelWhenConditionContext(Context, State);
		EnterRule(_localctx, 1440, RULE_optionalLabelWhenCondition);
		int _la;
		try {
			State = 6818;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,767,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6813;
				whenCondition();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6814;
				simpleIdentifier();
				State = 6816;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHEN) {
					{
					State = 6815;
					whenCondition();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhenConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public WhenConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whenCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterWhenCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitWhenCondition(this);
		}
	}

	[RuleVersion(0)]
	public WhenConditionContext whenCondition() {
		WhenConditionContext _localctx = new WhenConditionContext(Context, State);
		EnterRule(_localctx, 1442, RULE_whenCondition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6820;
			Match(WHEN);
			State = 6821;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockItemContext[] declarationBlockItem() {
			return GetRuleContexts<DeclarationBlockItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockItemContext declarationBlockItem(int i) {
			return GetRuleContext<DeclarationBlockItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECLARE() { return GetToken(OracleAntlrParser.DECLARE, 0); }
		public DeclarationBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarationBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDeclarationBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDeclarationBlock(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationBlockContext declarationBlock() {
		DeclarationBlockContext _localctx = new DeclarationBlockContext(Context, State);
		EnterRule(_localctx, 1444, RULE_declarationBlock);
		try {
			int _alt;
			State = 6835;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DIRECTIVE_IF:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6824;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 6823;
						declarationBlockItem();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 6826;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,768,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case DECLARE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6828;
				Match(DECLARE);
				State = 6832;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,769,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 6829;
						declarationBlockItem();
						}
						} 
					}
					State = 6834;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,769,Context);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationBlockItemContext : ParserRuleContext {
		public IToken semi;
		[System.Diagnostics.DebuggerNonUserCode] public IfDirectiveStatementContext ifDirectiveStatement() {
			return GetRuleContext<IfDirectiveStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI() { return GetToken(OracleAntlrParser.SEMI, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionStatementContext functionStatement() {
			return GetRuleContext<FunctionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureStatementContext procedureStatement() {
			return GetRuleContext<ProcedureStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionDeclarationContext exceptionDeclaration() {
			return GetRuleContext<ExceptionDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeDeclarationContext typeDeclaration() {
			return GetRuleContext<TypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubtypeDeclarationContext subtypeDeclaration() {
			return GetRuleContext<SubtypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CursorDeclarationContext cursorDeclaration() {
			return GetRuleContext<CursorDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationPragmaContext declarationPragma() {
			return GetRuleContext<DeclarationPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableDeclarationContext variableDeclaration() {
			return GetRuleContext<VariableDeclarationContext>(0);
		}
		public DeclarationBlockItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarationBlockItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDeclarationBlockItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDeclarationBlockItem(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationBlockItemContext declarationBlockItem() {
		DeclarationBlockItemContext _localctx = new DeclarationBlockItemContext(Context, State);
		EnterRule(_localctx, 1446, RULE_declarationBlockItem);
		try {
			State = 6850;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DIRECTIVE_IF:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6837;
				ifDirectiveStatement();
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6846;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,771,Context) ) {
				case 1:
					{
					State = 6838;
					functionStatement();
					}
					break;
				case 2:
					{
					State = 6839;
					procedureStatement();
					}
					break;
				case 3:
					{
					State = 6840;
					exceptionDeclaration();
					}
					break;
				case 4:
					{
					State = 6841;
					typeDeclaration();
					}
					break;
				case 5:
					{
					State = 6842;
					subtypeDeclaration();
					}
					break;
				case 6:
					{
					State = 6843;
					cursorDeclaration();
					}
					break;
				case 7:
					{
					State = 6844;
					declarationPragma();
					}
					break;
				case 8:
					{
					State = 6845;
					variableDeclaration();
					}
					break;
				}
				State = 6848;
				_localctx.semi = Match(SEMI);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NotNullClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public NotNullClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_notNullClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNotNullClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNotNullClause(this);
		}
	}

	[RuleVersion(0)]
	public NotNullClauseContext notNullClause() {
		NotNullClauseContext _localctx = new NotNullClauseContext(Context, State);
		EnterRule(_localctx, 1448, RULE_notNullClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6852;
			Match(NOT);
			State = 6853;
			Match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NullClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public NullClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nullClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNullClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNullClause(this);
		}
	}

	[RuleVersion(0)]
	public NullClauseContext nullClause() {
		NullClauseContext _localctx = new NullClauseContext(Context, State);
		EnterRule(_localctx, 1450, RULE_nullClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6855;
			Match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefaultValueClauseContext : ParserRuleContext {
		public IToken clauseType;
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN_OPERATOR() { return GetToken(OracleAntlrParser.ASSIGN_OPERATOR, 0); }
		public DefaultValueClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defaultValueClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDefaultValueClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDefaultValueClause(this);
		}
	}

	[RuleVersion(0)]
	public DefaultValueClauseContext defaultValueClause() {
		DefaultValueClauseContext _localctx = new DefaultValueClauseContext(Context, State);
		EnterRule(_localctx, 1452, RULE_defaultValueClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6857;
			_localctx.clauseType = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DEFAULT || _la==ASSIGN_OPERATOR) ) {
				_localctx.clauseType = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 6858;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CursorReturnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(OracleAntlrParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public CursorReturnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursorReturnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCursorReturnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCursorReturnClause(this);
		}
	}

	[RuleVersion(0)]
	public CursorReturnClauseContext cursorReturnClause() {
		CursorReturnClauseContext _localctx = new CursorReturnClauseContext(Context, State);
		EnterRule(_localctx, 1454, RULE_cursorReturnClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6860;
			Match(RETURN);
			State = 6861;
			typeReference();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExceptionDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPTION() { return GetToken(OracleAntlrParser.EXCEPTION, 0); }
		public ExceptionDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exceptionDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExceptionDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExceptionDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public ExceptionDeclarationContext exceptionDeclaration() {
		ExceptionDeclarationContext _localctx = new ExceptionDeclarationContext(Context, State);
		EnterRule(_localctx, 1456, RULE_exceptionDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6863;
			simpleIdentifier();
			State = 6864;
			Match(EXCEPTION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterIsContext delimiterIs() {
			return GetRuleContext<DelimiterIsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterAsContext delimiterAs() {
			return GetRuleContext<DelimiterAsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RecordTypeDeclarationContext recordTypeDeclaration() {
			return GetRuleContext<RecordTypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayTypeDeclarationContext varrayTypeDeclaration() {
			return GetRuleContext<VarrayTypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableTypeDeclarationContext tableTypeDeclaration() {
			return GetRuleContext<TableTypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RefCursorTypeDeclarationContext refCursorTypeDeclaration() {
			return GetRuleContext<RefCursorTypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeDeclarationContext objectTypeDeclaration() {
			return GetRuleContext<ObjectTypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NewTypeContext newType() {
			return GetRuleContext<NewTypeContext>(0);
		}
		public TypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public TypeDeclarationContext typeDeclaration() {
		TypeDeclarationContext _localctx = new TypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1458, RULE_typeDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6866;
			Match(TYPE);
			State = 6867;
			simpleIdentifier();
			State = 6870;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IS:
				{
				State = 6868;
				delimiterIs();
				}
				break;
			case AS:
				{
				State = 6869;
				delimiterAs();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6873;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,774,Context) ) {
			case 1:
				{
				State = 6872;
				newType();
				}
				break;
			}
			State = 6881;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,775,Context) ) {
			case 1:
				{
				State = 6875;
				recordTypeDeclaration();
				}
				break;
			case 2:
				{
				State = 6876;
				varrayTypeDeclaration();
				}
				break;
			case 3:
				{
				State = 6877;
				tableTypeDeclaration();
				}
				break;
			case 4:
				{
				State = 6878;
				refCursorTypeDeclaration();
				}
				break;
			case 5:
				{
				State = 6879;
				objectTypeDeclaration();
				}
				break;
			case 6:
				{
				State = 6880;
				typeReference();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterAsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		public DelimiterAsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterAs; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDelimiterAs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDelimiterAs(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterAsContext delimiterAs() {
		DelimiterAsContext _localctx = new DelimiterAsContext(Context, State);
		EnterRule(_localctx, 1460, RULE_delimiterAs);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6883;
			Match(AS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(OracleAntlrParser.NEW, 0); }
		public NewTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNewType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNewType(this);
		}
	}

	[RuleVersion(0)]
	public NewTypeContext newType() {
		NewTypeContext _localctx = new NewTypeContext(Context, State);
		EnterRule(_localctx, 1462, RULE_newType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6885;
			Match(NEW);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RecordTypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RECORD() { return GetToken(OracleAntlrParser.RECORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RecordFieldDeclarationContext[] recordFieldDeclaration() {
			return GetRuleContexts<RecordFieldDeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RecordFieldDeclarationContext recordFieldDeclaration(int i) {
			return GetRuleContext<RecordFieldDeclarationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public RecordTypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_recordTypeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRecordTypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRecordTypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public RecordTypeDeclarationContext recordTypeDeclaration() {
		RecordTypeDeclarationContext _localctx = new RecordTypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1464, RULE_recordTypeDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6887;
			Match(RECORD);
			State = 6888;
			Match(LPAREN);
			State = 6889;
			recordFieldDeclaration();
			State = 6894;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 6890;
				Match(COMMA);
				State = 6891;
				recordFieldDeclaration();
				}
				}
				State = 6896;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6897;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RecordFieldDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultValueClauseContext defaultValueClause() {
			return GetRuleContext<DefaultValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullClauseContext nullClause() {
			return GetRuleContext<NullClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotNullClauseContext notNullClause() {
			return GetRuleContext<NotNullClauseContext>(0);
		}
		public RecordFieldDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_recordFieldDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRecordFieldDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRecordFieldDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public RecordFieldDeclarationContext recordFieldDeclaration() {
		RecordFieldDeclarationContext _localctx = new RecordFieldDeclarationContext(Context, State);
		EnterRule(_localctx, 1466, RULE_recordFieldDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6899;
			simpleIdentifier();
			State = 6900;
			typeReference();
			State = 6909;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEFAULT:
			case NOT:
			case ASSIGN_OPERATOR:
				{
				State = 6902;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 6901;
					notNullClause();
					}
				}

				State = 6904;
				defaultValueClause();
				}
				break;
			case NULL:
				{
				State = 6905;
				nullClause();
				State = 6907;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT || _la==ASSIGN_OPERATOR) {
					{
					State = 6906;
					defaultValueClause();
					}
				}

				}
				break;
			case RPAREN:
			case COMMA:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(OracleAntlrParser.OBJECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectFieldDeclarationContext objectFieldDeclaration() {
			return GetRuleContext<ObjectFieldDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RecordFieldDeclarationContext[] recordFieldDeclaration() {
			return GetRuleContexts<RecordFieldDeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RecordFieldDeclarationContext recordFieldDeclaration(int i) {
			return GetRuleContext<RecordFieldDeclarationContext>(i);
		}
		public ObjectTypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectTypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectTypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeDeclarationContext objectTypeDeclaration() {
		ObjectTypeDeclarationContext _localctx = new ObjectTypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1468, RULE_objectTypeDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6911;
			Match(OBJECT);
			State = 6912;
			Match(LPAREN);
			State = 6913;
			objectFieldDeclaration();
			State = 6918;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 6914;
				Match(COMMA);
				State = 6915;
				recordFieldDeclaration();
				}
				}
				State = 6920;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6921;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectFieldDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultValueClauseContext defaultValueClause() {
			return GetRuleContext<DefaultValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullClauseContext nullClause() {
			return GetRuleContext<NullClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotNullClauseContext notNullClause() {
			return GetRuleContext<NotNullClauseContext>(0);
		}
		public ObjectFieldDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectFieldDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectFieldDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectFieldDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public ObjectFieldDeclarationContext objectFieldDeclaration() {
		ObjectFieldDeclarationContext _localctx = new ObjectFieldDeclarationContext(Context, State);
		EnterRule(_localctx, 1470, RULE_objectFieldDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6923;
			simpleIdentifier();
			State = 6924;
			typeReference();
			State = 6933;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEFAULT:
			case NOT:
			case ASSIGN_OPERATOR:
				{
				State = 6926;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 6925;
					notNullClause();
					}
				}

				State = 6928;
				defaultValueClause();
				}
				break;
			case NULL:
				{
				State = 6929;
				nullClause();
				State = 6931;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT || _la==ASSIGN_OPERATOR) {
					{
					State = 6930;
					defaultValueClause();
					}
				}

				}
				break;
			case RPAREN:
			case COMMA:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarrayTypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public VarraySizeLimitClauseContext varraySizeLimitClause() {
			return GetRuleContext<VarraySizeLimitClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeDeclararionElementTypeClauseContext typeDeclararionElementTypeClause() {
			return GetRuleContext<TypeDeclararionElementTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARRAY() { return GetToken(OracleAntlrParser.VARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARYING() { return GetToken(OracleAntlrParser.VARYING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARRAY() { return GetToken(OracleAntlrParser.ARRAY, 0); }
		public VarrayTypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varrayTypeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterVarrayTypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitVarrayTypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public VarrayTypeDeclarationContext varrayTypeDeclaration() {
		VarrayTypeDeclarationContext _localctx = new VarrayTypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1472, RULE_varrayTypeDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6938;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case VARRAY:
				{
				State = 6935;
				Match(VARRAY);
				}
				break;
			case VARYING:
				{
				State = 6936;
				Match(VARYING);
				State = 6937;
				Match(ARRAY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6940;
			varraySizeLimitClause();
			State = 6941;
			typeDeclararionElementTypeClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarraySizeLimitClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public VarraySizeLimitClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varraySizeLimitClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterVarraySizeLimitClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitVarraySizeLimitClause(this);
		}
	}

	[RuleVersion(0)]
	public VarraySizeLimitClauseContext varraySizeLimitClause() {
		VarraySizeLimitClauseContext _localctx = new VarraySizeLimitClauseContext(Context, State);
		EnterRule(_localctx, 1474, RULE_varraySizeLimitClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6943;
			Match(LPAREN);
			State = 6944;
			literal();
			State = 6945;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeDeclararionElementTypeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotNullClauseContext notNullClause() {
			return GetRuleContext<NotNullClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullClauseContext nullClause() {
			return GetRuleContext<NullClauseContext>(0);
		}
		public TypeDeclararionElementTypeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeDeclararionElementTypeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTypeDeclararionElementTypeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTypeDeclararionElementTypeClause(this);
		}
	}

	[RuleVersion(0)]
	public TypeDeclararionElementTypeClauseContext typeDeclararionElementTypeClause() {
		TypeDeclararionElementTypeClauseContext _localctx = new TypeDeclararionElementTypeClauseContext(Context, State);
		EnterRule(_localctx, 1476, RULE_typeDeclararionElementTypeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6947;
			Match(OF);
			State = 6948;
			typeReference();
			State = 6951;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOT:
				{
				State = 6949;
				notNullClause();
				}
				break;
			case NULL:
				{
				State = 6950;
				nullClause();
				}
				break;
			case Eof:
			case ALTER:
			case INDEX:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableTypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeDeclararionElementTypeClauseContext typeDeclararionElementTypeClause() {
			return GetRuleContext<TypeDeclararionElementTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableTypeIndexByClauseContext tableTypeIndexByClause() {
			return GetRuleContext<TableTypeIndexByClauseContext>(0);
		}
		public TableTypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableTypeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTableTypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTableTypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public TableTypeDeclarationContext tableTypeDeclaration() {
		TableTypeDeclarationContext _localctx = new TableTypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1478, RULE_tableTypeDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6953;
			Match(TABLE);
			State = 6954;
			typeDeclararionElementTypeClause();
			State = 6956;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INDEX) {
				{
				State = 6955;
				tableTypeIndexByClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableTypeIndexByClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotNullClauseContext notNullClause() {
			return GetRuleContext<NotNullClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullClauseContext nullClause() {
			return GetRuleContext<NullClauseContext>(0);
		}
		public TableTypeIndexByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableTypeIndexByClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTableTypeIndexByClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTableTypeIndexByClause(this);
		}
	}

	[RuleVersion(0)]
	public TableTypeIndexByClauseContext tableTypeIndexByClause() {
		TableTypeIndexByClauseContext _localctx = new TableTypeIndexByClauseContext(Context, State);
		EnterRule(_localctx, 1480, RULE_tableTypeIndexByClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6958;
			Match(INDEX);
			State = 6959;
			Match(BY);
			State = 6960;
			typeReference();
			State = 6963;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOT:
				{
				State = 6961;
				notNullClause();
				}
				break;
			case NULL:
				{
				State = 6962;
				nullClause();
				}
				break;
			case Eof:
			case ALTER:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RefCursorTypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REF() { return GetToken(OracleAntlrParser.REF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURSOR() { return GetToken(OracleAntlrParser.CURSOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CursorReturnClauseContext cursorReturnClause() {
			return GetRuleContext<CursorReturnClauseContext>(0);
		}
		public RefCursorTypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_refCursorTypeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRefCursorTypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRefCursorTypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public RefCursorTypeDeclarationContext refCursorTypeDeclaration() {
		RefCursorTypeDeclarationContext _localctx = new RefCursorTypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1482, RULE_refCursorTypeDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6965;
			Match(REF);
			State = 6966;
			Match(CURSOR);
			State = 6968;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURN) {
				{
				State = 6967;
				cursorReturnClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubtypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBTYPE() { return GetToken(OracleAntlrParser.SUBTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterIsContext delimiterIs() {
			return GetRuleContext<DelimiterIsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotNullClauseContext notNullClause() {
			return GetRuleContext<NotNullClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullClauseContext nullClause() {
			return GetRuleContext<NullClauseContext>(0);
		}
		public SubtypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subtypeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubtypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubtypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public SubtypeDeclarationContext subtypeDeclaration() {
		SubtypeDeclarationContext _localctx = new SubtypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1484, RULE_subtypeDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6970;
			Match(SUBTYPE);
			State = 6971;
			simpleIdentifier();
			State = 6972;
			delimiterIs();
			State = 6973;
			typeReference();
			State = 6976;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOT:
				{
				State = 6974;
				notNullClause();
				}
				break;
			case NULL:
				{
				State = 6975;
				nullClause();
				}
				break;
			case SEMI:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CursorDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CursorHeaderContext cursorHeader() {
			return GetRuleContext<CursorHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CursorReturnClauseContext cursorReturnClause() {
			return GetRuleContext<CursorReturnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CursorSelectContext cursorSelect() {
			return GetRuleContext<CursorSelectContext>(0);
		}
		public CursorDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursorDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCursorDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCursorDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public CursorDeclarationContext cursorDeclaration() {
		CursorDeclarationContext _localctx = new CursorDeclarationContext(Context, State);
		EnterRule(_localctx, 1486, RULE_cursorDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6978;
			cursorHeader();
			State = 6980;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 6979;
				argumentList();
				}
			}

			State = 6983;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURN) {
				{
				State = 6982;
				cursorReturnClause();
				}
			}

			State = 6986;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IS) {
				{
				State = 6985;
				cursorSelect();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CursorHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURSOR() { return GetToken(OracleAntlrParser.CURSOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public CursorHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursorHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCursorHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCursorHeader(this);
		}
	}

	[RuleVersion(0)]
	public CursorHeaderContext cursorHeader() {
		CursorHeaderContext _localctx = new CursorHeaderContext(Context, State);
		EnterRule(_localctx, 1488, RULE_cursorHeader);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6988;
			Match(CURSOR);
			State = 6989;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CursorSelectContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public CursorSelectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursorSelect; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCursorSelect(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCursorSelect(this);
		}
	}

	[RuleVersion(0)]
	public CursorSelectContext cursorSelect() {
		CursorSelectContext _localctx = new CursorSelectContext(Context, State);
		EnterRule(_localctx, 1490, RULE_cursorSelect);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6991;
			Match(IS);
			State = 6992;
			selectStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRAGMA() { return GetToken(OracleAntlrParser.PRAGMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionInitPragmaContext exceptionInitPragma() {
			return GetRuleContext<ExceptionInitPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AutonomousTransactionPragmaContext autonomousTransactionPragma() {
			return GetRuleContext<AutonomousTransactionPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SeriallyReusablePragmaContext seriallyReusablePragma() {
			return GetRuleContext<SeriallyReusablePragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RestrictReferencesPragmaContext restrictReferencesPragma() {
			return GetRuleContext<RestrictReferencesPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BuiltinPragmaContext builtinPragma() {
			return GetRuleContext<BuiltinPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FipsflagPragmaContext fipsflagPragma() {
			return GetRuleContext<FipsflagPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InterfacePragmaContext interfacePragma() {
			return GetRuleContext<InterfacePragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TimestampPragmaContext timestampPragma() {
			return GetRuleContext<TimestampPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NewNamesPragmaContext newNamesPragma() {
			return GetRuleContext<NewNamesPragmaContext>(0);
		}
		public DeclarationPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarationPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDeclarationPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDeclarationPragma(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationPragmaContext declarationPragma() {
		DeclarationPragmaContext _localctx = new DeclarationPragmaContext(Context, State);
		EnterRule(_localctx, 1492, RULE_declarationPragma);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6994;
			Match(PRAGMA);
			State = 7004;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EXCEPTION_INIT:
				{
				State = 6995;
				exceptionInitPragma();
				}
				break;
			case AUTONOMOUS_TRANSACTION:
				{
				State = 6996;
				autonomousTransactionPragma();
				}
				break;
			case SERIALLY_REUSABLE:
				{
				State = 6997;
				seriallyReusablePragma();
				}
				break;
			case RESTRICT_REFERENCES:
				{
				State = 6998;
				restrictReferencesPragma();
				}
				break;
			case BUILTIN:
				{
				State = 6999;
				builtinPragma();
				}
				break;
			case FIPSFLAG:
				{
				State = 7000;
				fipsflagPragma();
				}
				break;
			case INTERFACE:
				{
				State = 7001;
				interfacePragma();
				}
				break;
			case TIMESTAMP:
				{
				State = 7002;
				timestampPragma();
				}
				break;
			case NEW_NAMES:
				{
				State = 7003;
				newNamesPragma();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExceptionInitPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPTION_INIT() { return GetToken(OracleAntlrParser.EXCEPTION_INIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public ExceptionInitPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exceptionInitPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExceptionInitPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExceptionInitPragma(this);
		}
	}

	[RuleVersion(0)]
	public ExceptionInitPragmaContext exceptionInitPragma() {
		ExceptionInitPragmaContext _localctx = new ExceptionInitPragmaContext(Context, State);
		EnterRule(_localctx, 1494, RULE_exceptionInitPragma);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7006;
			Match(EXCEPTION_INIT);
			State = 7007;
			Match(LPAREN);
			State = 7008;
			identifier();
			State = 7009;
			Match(COMMA);
			State = 7010;
			fullExpression();
			State = 7011;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AutonomousTransactionPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTONOMOUS_TRANSACTION() { return GetToken(OracleAntlrParser.AUTONOMOUS_TRANSACTION, 0); }
		public AutonomousTransactionPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_autonomousTransactionPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAutonomousTransactionPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAutonomousTransactionPragma(this);
		}
	}

	[RuleVersion(0)]
	public AutonomousTransactionPragmaContext autonomousTransactionPragma() {
		AutonomousTransactionPragmaContext _localctx = new AutonomousTransactionPragmaContext(Context, State);
		EnterRule(_localctx, 1496, RULE_autonomousTransactionPragma);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7013;
			Match(AUTONOMOUS_TRANSACTION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SeriallyReusablePragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERIALLY_REUSABLE() { return GetToken(OracleAntlrParser.SERIALLY_REUSABLE, 0); }
		public SeriallyReusablePragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_seriallyReusablePragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSeriallyReusablePragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSeriallyReusablePragma(this);
		}
	}

	[RuleVersion(0)]
	public SeriallyReusablePragmaContext seriallyReusablePragma() {
		SeriallyReusablePragmaContext _localctx = new SeriallyReusablePragmaContext(Context, State);
		EnterRule(_localctx, 1498, RULE_seriallyReusablePragma);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7015;
			Match(SERIALLY_REUSABLE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RestrictReferencesPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RESTRICT_REFERENCES() { return GetToken(OracleAntlrParser.RESTRICT_REFERENCES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		public RestrictReferencesPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_restrictReferencesPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRestrictReferencesPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRestrictReferencesPragma(this);
		}
	}

	[RuleVersion(0)]
	public RestrictReferencesPragmaContext restrictReferencesPragma() {
		RestrictReferencesPragmaContext _localctx = new RestrictReferencesPragmaContext(Context, State);
		EnterRule(_localctx, 1500, RULE_restrictReferencesPragma);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7017;
			Match(RESTRICT_REFERENCES);
			State = 7018;
			Match(LPAREN);
			State = 7020;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 7019;
				identifierList();
				}
			}

			State = 7022;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BuiltinPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUILTIN() { return GetToken(OracleAntlrParser.BUILTIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public BuiltinPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_builtinPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterBuiltinPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitBuiltinPragma(this);
		}
	}

	[RuleVersion(0)]
	public BuiltinPragmaContext builtinPragma() {
		BuiltinPragmaContext _localctx = new BuiltinPragmaContext(Context, State);
		EnterRule(_localctx, 1502, RULE_builtinPragma);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7024;
			Match(BUILTIN);
			State = 7025;
			Match(LPAREN);
			State = 7027;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLAGG - 513)) | (1L << (XMLCAST - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLQUERY - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (INTEGER_LITERAL - 577)) | (1L << (LPAREN - 577)) | (1L << (PLUS_SIGN - 577)) | (1L << (MINUS_SIGN - 577)) | (1L << (QUESTION_MARK - 577)) | (1L << (ASTERISK - 577)) | (1L << (FLOATING_POINT_LITERAL - 577)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 577)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 577)) | (1L << (BINARY_STRING_LITERAL - 577)) | (1L << (CHARACTER_STRING_LITERAL - 577)) | (1L << (MONEY_LITERAL - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 577)))) != 0)) {
				{
				State = 7026;
				expressionList();
				}
			}

			State = 7029;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FipsflagPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIPSFLAG() { return GetToken(OracleAntlrParser.FIPSFLAG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public FipsflagPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fipsflagPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterFipsflagPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitFipsflagPragma(this);
		}
	}

	[RuleVersion(0)]
	public FipsflagPragmaContext fipsflagPragma() {
		FipsflagPragmaContext _localctx = new FipsflagPragmaContext(Context, State);
		EnterRule(_localctx, 1504, RULE_fipsflagPragma);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7031;
			Match(FIPSFLAG);
			State = 7032;
			Match(LPAREN);
			State = 7034;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLAGG - 513)) | (1L << (XMLCAST - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLQUERY - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (INTEGER_LITERAL - 577)) | (1L << (LPAREN - 577)) | (1L << (PLUS_SIGN - 577)) | (1L << (MINUS_SIGN - 577)) | (1L << (QUESTION_MARK - 577)) | (1L << (ASTERISK - 577)) | (1L << (FLOATING_POINT_LITERAL - 577)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 577)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 577)) | (1L << (BINARY_STRING_LITERAL - 577)) | (1L << (CHARACTER_STRING_LITERAL - 577)) | (1L << (MONEY_LITERAL - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 577)))) != 0)) {
				{
				State = 7033;
				expressionList();
				}
			}

			State = 7036;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InterfacePragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERFACE() { return GetToken(OracleAntlrParser.INTERFACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public InterfacePragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_interfacePragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterInterfacePragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitInterfacePragma(this);
		}
	}

	[RuleVersion(0)]
	public InterfacePragmaContext interfacePragma() {
		InterfacePragmaContext _localctx = new InterfacePragmaContext(Context, State);
		EnterRule(_localctx, 1506, RULE_interfacePragma);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7038;
			Match(INTERFACE);
			State = 7039;
			Match(LPAREN);
			State = 7041;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLAGG - 513)) | (1L << (XMLCAST - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLQUERY - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (INTEGER_LITERAL - 577)) | (1L << (LPAREN - 577)) | (1L << (PLUS_SIGN - 577)) | (1L << (MINUS_SIGN - 577)) | (1L << (QUESTION_MARK - 577)) | (1L << (ASTERISK - 577)) | (1L << (FLOATING_POINT_LITERAL - 577)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 577)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 577)) | (1L << (BINARY_STRING_LITERAL - 577)) | (1L << (CHARACTER_STRING_LITERAL - 577)) | (1L << (MONEY_LITERAL - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 577)))) != 0)) {
				{
				State = 7040;
				expressionList();
				}
			}

			State = 7043;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimestampPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMESTAMP() { return GetToken(OracleAntlrParser.TIMESTAMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public TimestampPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timestampPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTimestampPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTimestampPragma(this);
		}
	}

	[RuleVersion(0)]
	public TimestampPragmaContext timestampPragma() {
		TimestampPragmaContext _localctx = new TimestampPragmaContext(Context, State);
		EnterRule(_localctx, 1508, RULE_timestampPragma);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7045;
			Match(TIMESTAMP);
			State = 7046;
			Match(LPAREN);
			State = 7048;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLAGG - 513)) | (1L << (XMLCAST - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLQUERY - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (INTEGER_LITERAL - 577)) | (1L << (LPAREN - 577)) | (1L << (PLUS_SIGN - 577)) | (1L << (MINUS_SIGN - 577)) | (1L << (QUESTION_MARK - 577)) | (1L << (ASTERISK - 577)) | (1L << (FLOATING_POINT_LITERAL - 577)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 577)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 577)) | (1L << (BINARY_STRING_LITERAL - 577)) | (1L << (CHARACTER_STRING_LITERAL - 577)) | (1L << (MONEY_LITERAL - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 577)))) != 0)) {
				{
				State = 7047;
				expressionList();
				}
			}

			State = 7050;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewNamesPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW_NAMES() { return GetToken(OracleAntlrParser.NEW_NAMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public NewNamesPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newNamesPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNewNamesPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNewNamesPragma(this);
		}
	}

	[RuleVersion(0)]
	public NewNamesPragmaContext newNamesPragma() {
		NewNamesPragmaContext _localctx = new NewNamesPragmaContext(Context, State);
		EnterRule(_localctx, 1510, RULE_newNamesPragma);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7052;
			Match(NEW_NAMES);
			State = 7053;
			Match(LPAREN);
			State = 7055;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLAGG - 513)) | (1L << (XMLCAST - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLQUERY - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (INTEGER_LITERAL - 577)) | (1L << (LPAREN - 577)) | (1L << (PLUS_SIGN - 577)) | (1L << (MINUS_SIGN - 577)) | (1L << (QUESTION_MARK - 577)) | (1L << (ASTERISK - 577)) | (1L << (FLOATING_POINT_LITERAL - 577)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 577)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 577)) | (1L << (BINARY_STRING_LITERAL - 577)) | (1L << (CHARACTER_STRING_LITERAL - 577)) | (1L << (MONEY_LITERAL - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 577)))) != 0)) {
				{
				State = 7054;
				expressionList();
				}
			}

			State = 7057;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableConstantClauseContext variableConstantClause() {
			return GetRuleContext<VariableConstantClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultValueClauseContext defaultValueClause() {
			return GetRuleContext<DefaultValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullClauseContext nullClause() {
			return GetRuleContext<NullClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotNullClauseContext notNullClause() {
			return GetRuleContext<NotNullClauseContext>(0);
		}
		public VariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitVariableDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public VariableDeclarationContext variableDeclaration() {
		VariableDeclarationContext _localctx = new VariableDeclarationContext(Context, State);
		EnterRule(_localctx, 1512, RULE_variableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7059;
			simpleIdentifier();
			State = 7061;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,800,Context) ) {
			case 1:
				{
				State = 7060;
				variableConstantClause();
				}
				break;
			}
			State = 7063;
			typeReference();
			State = 7072;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEFAULT:
			case NOT:
			case ASSIGN_OPERATOR:
				{
				State = 7065;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 7064;
					notNullClause();
					}
				}

				State = 7067;
				defaultValueClause();
				}
				break;
			case NULL:
				{
				State = 7068;
				nullClause();
				State = 7070;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT || _la==ASSIGN_OPERATOR) {
					{
					State = 7069;
					defaultValueClause();
					}
				}

				}
				break;
			case SEMI:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableConstantClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTANT() { return GetToken(OracleAntlrParser.CONSTANT, 0); }
		public VariableConstantClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableConstantClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterVariableConstantClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitVariableConstantClause(this);
		}
	}

	[RuleVersion(0)]
	public VariableConstantClauseContext variableConstantClause() {
		VariableConstantClauseContext _localctx = new VariableConstantClauseContext(Context, State);
		EnterRule(_localctx, 1514, RULE_variableConstantClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7074;
			Match(CONSTANT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(OracleAntlrParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DropTypeBodyStatementContext dropTypeBodyStatement() {
			return GetRuleContext<DropTypeBodyStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropTypeStatementContext dropTypeStatement() {
			return GetRuleContext<DropTypeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropTriggerStatementContext dropTriggerStatement() {
			return GetRuleContext<DropTriggerStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropIndexStatementContext dropIndexStatement() {
			return GetRuleContext<DropIndexStatementContext>(0);
		}
		public DropStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDropStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDropStatement(this);
		}
	}

	[RuleVersion(0)]
	public DropStatementContext dropStatement() {
		DropStatementContext _localctx = new DropStatementContext(Context, State);
		EnterRule(_localctx, 1516, RULE_dropStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7076;
			Match(DROP);
			State = 7081;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,804,Context) ) {
			case 1:
				{
				State = 7077;
				dropTypeBodyStatement();
				}
				break;
			case 2:
				{
				State = 7078;
				dropTypeStatement();
				}
				break;
			case 3:
				{
				State = 7079;
				dropTriggerStatement();
				}
				break;
			case 4:
				{
				State = 7080;
				dropIndexStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropTypeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForceValidateClauseContext forceValidateClause() {
			return GetRuleContext<ForceValidateClauseContext>(0);
		}
		public DropTypeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropTypeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDropTypeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDropTypeStatement(this);
		}
	}

	[RuleVersion(0)]
	public DropTypeStatementContext dropTypeStatement() {
		DropTypeStatementContext _localctx = new DropTypeStatementContext(Context, State);
		EnterRule(_localctx, 1518, RULE_dropTypeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7083;
			Match(TYPE);
			State = 7084;
			plainIdentifier();
			State = 7086;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FORCE || _la==VALIDATE) {
				{
				State = 7085;
				forceValidateClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForceValidateClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORCE() { return GetToken(OracleAntlrParser.FORCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALIDATE() { return GetToken(OracleAntlrParser.VALIDATE, 0); }
		public ForceValidateClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forceValidateClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForceValidateClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForceValidateClause(this);
		}
	}

	[RuleVersion(0)]
	public ForceValidateClauseContext forceValidateClause() {
		ForceValidateClauseContext _localctx = new ForceValidateClauseContext(Context, State);
		EnterRule(_localctx, 1520, RULE_forceValidateClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7088;
			_la = TokenStream.LA(1);
			if ( !(_la==FORCE || _la==VALIDATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropTypeBodyStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BODY() { return GetToken(OracleAntlrParser.BODY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public DropTypeBodyStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropTypeBodyStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDropTypeBodyStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDropTypeBodyStatement(this);
		}
	}

	[RuleVersion(0)]
	public DropTypeBodyStatementContext dropTypeBodyStatement() {
		DropTypeBodyStatementContext _localctx = new DropTypeBodyStatementContext(Context, State);
		EnterRule(_localctx, 1522, RULE_dropTypeBodyStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7090;
			Match(TYPE);
			State = 7091;
			Match(BODY);
			State = 7092;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropTriggerStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIGGER() { return GetToken(OracleAntlrParser.TRIGGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public DropTriggerStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropTriggerStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDropTriggerStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDropTriggerStatement(this);
		}
	}

	[RuleVersion(0)]
	public DropTriggerStatementContext dropTriggerStatement() {
		DropTriggerStatementContext _localctx = new DropTriggerStatementContext(Context, State);
		EnterRule(_localctx, 1524, RULE_dropTriggerStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7094;
			Match(TRIGGER);
			State = 7095;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropIndexStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORCE() { return GetToken(OracleAntlrParser.FORCE, 0); }
		public DropIndexStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropIndexStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDropIndexStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDropIndexStatement(this);
		}
	}

	[RuleVersion(0)]
	public DropIndexStatementContext dropIndexStatement() {
		DropIndexStatementContext _localctx = new DropIndexStatementContext(Context, State);
		EnterRule(_localctx, 1526, RULE_dropIndexStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7097;
			Match(INDEX);
			State = 7098;
			plainIdentifier();
			State = 7100;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FORCE) {
				{
				State = 7099;
				Match(FORCE);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALTER() { return GetToken(OracleAntlrParser.ALTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AlterTypeStatementContext alterTypeStatement() {
			return GetRuleContext<AlterTypeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterSequenceStatementContext alterSequenceStatement() {
			return GetRuleContext<AlterSequenceStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterTriggerStatementContext alterTriggerStatement() {
			return GetRuleContext<AlterTriggerStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterIndexStatementContext alterIndexStatement() {
			return GetRuleContext<AlterIndexStatementContext>(0);
		}
		public AlterStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlterStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlterStatement(this);
		}
	}

	[RuleVersion(0)]
	public AlterStatementContext alterStatement() {
		AlterStatementContext _localctx = new AlterStatementContext(Context, State);
		EnterRule(_localctx, 1528, RULE_alterStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7102;
			Match(ALTER);
			State = 7107;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TYPE:
				{
				State = 7103;
				alterTypeStatement();
				}
				break;
			case SEQUENCE:
				{
				State = 7104;
				alterSequenceStatement();
				}
				break;
			case TRIGGER:
				{
				State = 7105;
				alterTriggerStatement();
				}
				break;
			case INDEX:
				{
				State = 7106;
				alterIndexStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTypeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompileTypeClauseContext compileTypeClause() {
			return GetRuleContext<CompileTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReplaceTypeClauseContext replaceTypeClause() {
			return GetRuleContext<ReplaceTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterTypeSpecificationsContext alterTypeSpecifications() {
			return GetRuleContext<AlterTypeSpecificationsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DependentHandlingClauseContext dependentHandlingClause() {
			return GetRuleContext<DependentHandlingClauseContext>(0);
		}
		public AlterTypeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTypeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlterTypeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlterTypeStatement(this);
		}
	}

	[RuleVersion(0)]
	public AlterTypeStatementContext alterTypeStatement() {
		AlterTypeStatementContext _localctx = new AlterTypeStatementContext(Context, State);
		EnterRule(_localctx, 1530, RULE_alterTypeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7109;
			Match(TYPE);
			State = 7110;
			plainIdentifier();
			State = 7117;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPILE:
				{
				State = 7111;
				compileTypeClause();
				}
				break;
			case REPLACE:
				{
				State = 7112;
				replaceTypeClause();
				}
				break;
			case Eof:
			case ADD:
			case ALTER:
			case CASCADE:
			case DROP:
			case FINAL:
			case INSTANTIABLE:
			case INVALIDATE:
			case MODIFY:
			case NOT:
			case OVERRIDING:
			case SEMI:
			case FSLASH:
				{
				State = 7113;
				alterTypeSpecifications();
				State = 7115;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CASCADE || _la==INVALIDATE) {
					{
					State = 7114;
					dependentHandlingClause();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTypeSpecificationsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AlterMethodSpecificationsContext alterMethodSpecifications() {
			return GetRuleContext<AlterMethodSpecificationsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterCollectionClausesContext alterCollectionClauses() {
			return GetRuleContext<AlterCollectionClausesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterAttributeDefinitionContext alterAttributeDefinition() {
			return GetRuleContext<AlterAttributeDefinitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InheritanceClauseContext[] inheritanceClause() {
			return GetRuleContexts<InheritanceClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public InheritanceClauseContext inheritanceClause(int i) {
			return GetRuleContext<InheritanceClauseContext>(i);
		}
		public AlterTypeSpecificationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTypeSpecifications; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlterTypeSpecifications(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlterTypeSpecifications(this);
		}
	}

	[RuleVersion(0)]
	public AlterTypeSpecificationsContext alterTypeSpecifications() {
		AlterTypeSpecificationsContext _localctx = new AlterTypeSpecificationsContext(Context, State);
		EnterRule(_localctx, 1532, RULE_alterTypeSpecifications);
		int _la;
		try {
			State = 7128;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,811,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7119;
				alterMethodSpecifications();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7120;
				alterCollectionClauses();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7121;
				alterAttributeDefinition();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7125;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==FINAL || _la==INSTANTIABLE || _la==NOT || _la==OVERRIDING) {
					{
					{
					State = 7122;
					inheritanceClause();
					}
					}
					State = 7127;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTriggerStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIGGER() { return GetToken(OracleAntlrParser.TRIGGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISABLE() { return GetToken(OracleAntlrParser.DISABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RenameClauseContext renameClause() {
			return GetRuleContext<RenameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompileClauseContext compileClause() {
			return GetRuleContext<CompileClauseContext>(0);
		}
		public AlterTriggerStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTriggerStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlterTriggerStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlterTriggerStatement(this);
		}
	}

	[RuleVersion(0)]
	public AlterTriggerStatementContext alterTriggerStatement() {
		AlterTriggerStatementContext _localctx = new AlterTriggerStatementContext(Context, State);
		EnterRule(_localctx, 1534, RULE_alterTriggerStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7130;
			Match(TRIGGER);
			State = 7131;
			plainIdentifier();
			State = 7136;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ENABLE:
				{
				State = 7132;
				Match(ENABLE);
				}
				break;
			case DISABLE:
				{
				State = 7133;
				Match(DISABLE);
				}
				break;
			case RENAME:
				{
				State = 7134;
				renameClause();
				}
				break;
			case COMPILE:
				{
				State = 7135;
				compileClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RENAME() { return GetToken(OracleAntlrParser.RENAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(OracleAntlrParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public RenameClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRenameClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRenameClause(this);
		}
	}

	[RuleVersion(0)]
	public RenameClauseContext renameClause() {
		RenameClauseContext _localctx = new RenameClauseContext(Context, State);
		EnterRule(_localctx, 1536, RULE_renameClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7138;
			Match(RENAME);
			State = 7139;
			Match(TO);
			State = 7140;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompileClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPILE() { return GetToken(OracleAntlrParser.COMPILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEBUG() { return GetToken(OracleAntlrParser.DEBUG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CompilerParametersClauseContext compilerParametersClause() {
			return GetRuleContext<CompilerParametersClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REUSE() { return GetToken(OracleAntlrParser.REUSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETTINGS() { return GetToken(OracleAntlrParser.SETTINGS, 0); }
		public CompileClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compileClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCompileClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCompileClause(this);
		}
	}

	[RuleVersion(0)]
	public CompileClauseContext compileClause() {
		CompileClauseContext _localctx = new CompileClauseContext(Context, State);
		EnterRule(_localctx, 1538, RULE_compileClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7142;
			Match(COMPILE);
			State = 7144;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,813,Context) ) {
			case 1:
				{
				State = 7143;
				Match(DEBUG);
				}
				break;
			}
			State = 7147;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,814,Context) ) {
			case 1:
				{
				State = 7146;
				compilerParametersClause();
				}
				break;
			}
			State = 7151;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REUSE) {
				{
				State = 7149;
				Match(REUSE);
				State = 7150;
				Match(SETTINGS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterIndexStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISABLE() { return GetToken(OracleAntlrParser.DISABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COALESCE() { return GetToken(OracleAntlrParser.COALESCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USAGE() { return GetToken(OracleAntlrParser.USAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UPDATE() { return GetToken(OracleAntlrParser.UPDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BLOCK() { return GetToken(OracleAntlrParser.BLOCK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFERENCES() { return GetToken(OracleAntlrParser.REFERENCES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexOptionsContext indexOptions() {
			return GetRuleContext<IndexOptionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RebuildClauseContext rebuildClause() {
			return GetRuleContext<RebuildClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParametersClauseContext parametersClause() {
			return GetRuleContext<ParametersClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RenameClauseContext renameClause() {
			return GetRuleContext<RenameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterIndexPartitioningContext alterIndexPartitioning() {
			return GetRuleContext<AlterIndexPartitioningContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MONITORING() { return GetToken(OracleAntlrParser.MONITORING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMONITORING() { return GetToken(OracleAntlrParser.NOMONITORING, 0); }
		public AlterIndexStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterIndexStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlterIndexStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlterIndexStatement(this);
		}
	}

	[RuleVersion(0)]
	public AlterIndexStatementContext alterIndexStatement() {
		AlterIndexStatementContext _localctx = new AlterIndexStatementContext(Context, State);
		EnterRule(_localctx, 1540, RULE_alterIndexStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7153;
			Match(INDEX);
			State = 7154;
			plainIdentifier();
			State = 7169;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,816,Context) ) {
			case 1:
				{
				State = 7155;
				Match(ENABLE);
				}
				break;
			case 2:
				{
				State = 7156;
				Match(DISABLE);
				}
				break;
			case 3:
				{
				State = 7157;
				Match(UNUSABLE);
				}
				break;
			case 4:
				{
				State = 7158;
				Match(COALESCE);
				}
				break;
			case 5:
				{
				State = 7159;
				_la = TokenStream.LA(1);
				if ( !(_la==MONITORING || _la==NOMONITORING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 7160;
				Match(USAGE);
				}
				break;
			case 6:
				{
				State = 7161;
				Match(UPDATE);
				State = 7162;
				Match(BLOCK);
				State = 7163;
				Match(REFERENCES);
				}
				break;
			case 7:
				{
				State = 7164;
				indexOptions();
				}
				break;
			case 8:
				{
				State = 7165;
				rebuildClause();
				}
				break;
			case 9:
				{
				State = 7166;
				parametersClause();
				}
				break;
			case 10:
				{
				State = 7167;
				renameClause();
				}
				break;
			case 11:
				{
				State = 7168;
				alterIndexPartitioning();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOptionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeallocateUnusedClauseContext[] deallocateUnusedClause() {
			return GetRuleContexts<DeallocateUnusedClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeallocateUnusedClauseContext deallocateUnusedClause(int i) {
			return GetRuleContext<DeallocateUnusedClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AllocateExtentClauseContext[] allocateExtentClause() {
			return GetRuleContexts<AllocateExtentClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AllocateExtentClauseContext allocateExtentClause(int i) {
			return GetRuleContext<AllocateExtentClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShrinkClauseContext[] shrinkClause() {
			return GetRuleContexts<ShrinkClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShrinkClauseContext shrinkClause(int i) {
			return GetRuleContext<ShrinkClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext[] parallelClause() {
			return GetRuleContexts<ParallelClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause(int i) {
			return GetRuleContext<ParallelClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext[] physicalAttribute() {
			return GetRuleContexts<PhysicalAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute(int i) {
			return GetRuleContext<PhysicalAttributeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext[] loggingClause() {
			return GetRuleContexts<LoggingClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause(int i) {
			return GetRuleContext<LoggingClauseContext>(i);
		}
		public IndexOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOptions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexOptions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexOptions(this);
		}
	}

	[RuleVersion(0)]
	public IndexOptionsContext indexOptions() {
		IndexOptionsContext _localctx = new IndexOptionsContext(Context, State);
		EnterRule(_localctx, 1542, RULE_indexOptions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ALLOCATE || _la==DEALLOCATE || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 276)) & ~0x3f) == 0 && ((1L << (_la - 276)) & ((1L << (LOGGING - 276)) | (1L << (MAXTRANS - 276)) | (1L << (NOLOGGING - 276)) | (1L << (NOPARALLEL - 276)))) != 0) || ((((_la - 375)) & ~0x3f) == 0 && ((1L << (_la - 375)) & ((1L << (PARALLEL - 375)) | (1L << (PCTFREE - 375)) | (1L << (PCTUSED - 375)))) != 0) || _la==SHRINK || _la==STORAGE) {
				{
				State = 7177;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DEALLOCATE:
					{
					State = 7171;
					deallocateUnusedClause();
					}
					break;
				case ALLOCATE:
					{
					State = 7172;
					allocateExtentClause();
					}
					break;
				case SHRINK:
					{
					State = 7173;
					shrinkClause();
					}
					break;
				case NOPARALLEL:
				case PARALLEL:
					{
					State = 7174;
					parallelClause();
					}
					break;
				case INITRANS:
				case MAXTRANS:
				case PCTFREE:
				case PCTUSED:
				case STORAGE:
					{
					State = 7175;
					physicalAttribute();
					}
					break;
				case FILESYSTEM_LIKE_LOGGING:
				case LOGGING:
				case NOLOGGING:
					{
					State = 7176;
					loggingClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 7181;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeallocateUnusedClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEALLOCATE() { return GetToken(OracleAntlrParser.DEALLOCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSED() { return GetToken(OracleAntlrParser.UNUSED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public KeepSizeClauseContext keepSizeClause() {
			return GetRuleContext<KeepSizeClauseContext>(0);
		}
		public DeallocateUnusedClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deallocateUnusedClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDeallocateUnusedClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDeallocateUnusedClause(this);
		}
	}

	[RuleVersion(0)]
	public DeallocateUnusedClauseContext deallocateUnusedClause() {
		DeallocateUnusedClauseContext _localctx = new DeallocateUnusedClauseContext(Context, State);
		EnterRule(_localctx, 1544, RULE_deallocateUnusedClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7182;
			Match(DEALLOCATE);
			State = 7183;
			Match(UNUSED);
			State = 7185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KEEP) {
				{
				State = 7184;
				keepSizeClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeepSizeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ByteSizeLiteralContext byteSizeLiteral() {
			return GetRuleContext<ByteSizeLiteralContext>(0);
		}
		public KeepSizeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keepSizeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterKeepSizeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitKeepSizeClause(this);
		}
	}

	[RuleVersion(0)]
	public KeepSizeClauseContext keepSizeClause() {
		KeepSizeClauseContext _localctx = new KeepSizeClauseContext(Context, State);
		EnterRule(_localctx, 1546, RULE_keepSizeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7187;
			Match(KEEP);
			State = 7188;
			byteSizeLiteral();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AllocateExtentClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALLOCATE() { return GetToken(OracleAntlrParser.ALLOCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTENT() { return GetToken(OracleAntlrParser.EXTENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExtentOptionsContext extentOptions() {
			return GetRuleContext<ExtentOptionsContext>(0);
		}
		public AllocateExtentClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_allocateExtentClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAllocateExtentClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAllocateExtentClause(this);
		}
	}

	[RuleVersion(0)]
	public AllocateExtentClauseContext allocateExtentClause() {
		AllocateExtentClauseContext _localctx = new AllocateExtentClauseContext(Context, State);
		EnterRule(_localctx, 1548, RULE_allocateExtentClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7190;
			Match(ALLOCATE);
			State = 7191;
			Match(EXTENT);
			State = 7193;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 7192;
				extentOptions();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtentOptionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExtentOptionContext[] extentOption() {
			return GetRuleContexts<ExtentOptionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtentOptionContext extentOption(int i) {
			return GetRuleContext<ExtentOptionContext>(i);
		}
		public ExtentOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extentOptions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExtentOptions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExtentOptions(this);
		}
	}

	[RuleVersion(0)]
	public ExtentOptionsContext extentOptions() {
		ExtentOptionsContext _localctx = new ExtentOptionsContext(Context, State);
		EnterRule(_localctx, 1550, RULE_extentOptions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7195;
			Match(LPAREN);
			State = 7197;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 7196;
				extentOption();
				}
				}
				State = 7199;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==DATAFILE || _la==INSTANCE || _la==SIZE );
			State = 7201;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtentOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIZE() { return GetToken(OracleAntlrParser.SIZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ByteSizeLiteralContext byteSizeLiteral() {
			return GetRuleContext<ByteSizeLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATAFILE() { return GetToken(OracleAntlrParser.DATAFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSTANCE() { return GetToken(OracleAntlrParser.INSTANCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ExtentOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extentOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterExtentOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitExtentOption(this);
		}
	}

	[RuleVersion(0)]
	public ExtentOptionContext extentOption() {
		ExtentOptionContext _localctx = new ExtentOptionContext(Context, State);
		EnterRule(_localctx, 1552, RULE_extentOption);
		try {
			State = 7209;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SIZE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7203;
				Match(SIZE);
				State = 7204;
				byteSizeLiteral();
				}
				break;
			case DATAFILE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7205;
				Match(DATAFILE);
				State = 7206;
				fullExpression();
				}
				break;
			case INSTANCE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7207;
				Match(INSTANCE);
				State = 7208;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShrinkClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHRINK() { return GetToken(OracleAntlrParser.SHRINK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SPACE() { return GetToken(OracleAntlrParser.SPACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPACT() { return GetToken(OracleAntlrParser.COMPACT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASCADE() { return GetToken(OracleAntlrParser.CASCADE, 0); }
		public ShrinkClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shrinkClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterShrinkClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitShrinkClause(this);
		}
	}

	[RuleVersion(0)]
	public ShrinkClauseContext shrinkClause() {
		ShrinkClauseContext _localctx = new ShrinkClauseContext(Context, State);
		EnterRule(_localctx, 1554, RULE_shrinkClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7211;
			Match(SHRINK);
			State = 7212;
			Match(SPACE);
			State = 7214;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMPACT) {
				{
				State = 7213;
				Match(COMPACT);
				}
			}

			State = 7217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CASCADE) {
				{
				State = 7216;
				Match(CASCADE);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PhysicalAttributeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTFREE() { return GetToken(OracleAntlrParser.PCTFREE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTUSED() { return GetToken(OracleAntlrParser.PCTUSED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INITRANS() { return GetToken(OracleAntlrParser.INITRANS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXTRANS() { return GetToken(OracleAntlrParser.MAXTRANS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StorageAttributesClauseContext storageAttributesClause() {
			return GetRuleContext<StorageAttributesClauseContext>(0);
		}
		public PhysicalAttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_physicalAttribute; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterPhysicalAttribute(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitPhysicalAttribute(this);
		}
	}

	[RuleVersion(0)]
	public PhysicalAttributeContext physicalAttribute() {
		PhysicalAttributeContext _localctx = new PhysicalAttributeContext(Context, State);
		EnterRule(_localctx, 1556, RULE_physicalAttribute);
		try {
			State = 7228;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PCTFREE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7219;
				Match(PCTFREE);
				State = 7220;
				literal();
				}
				break;
			case PCTUSED:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7221;
				Match(PCTUSED);
				State = 7222;
				literal();
				}
				break;
			case INITRANS:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7223;
				Match(INITRANS);
				State = 7224;
				literal();
				}
				break;
			case MAXTRANS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7225;
				Match(MAXTRANS);
				State = 7226;
				literal();
				}
				break;
			case STORAGE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7227;
				storageAttributesClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RebuildClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REBUILD() { return GetToken(OracleAntlrParser.REBUILD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REVERSE() { return GetToken(OracleAntlrParser.REVERSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOREVERSE() { return GetToken(OracleAntlrParser.NOREVERSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RebuildOptionsContext[] rebuildOptions() {
			return GetRuleContexts<RebuildOptionsContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RebuildOptionsContext rebuildOptions(int i) {
			return GetRuleContext<RebuildOptionsContext>(i);
		}
		public RebuildClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rebuildClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRebuildClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRebuildClause(this);
		}
	}

	[RuleVersion(0)]
	public RebuildClauseContext rebuildClause() {
		RebuildClauseContext _localctx = new RebuildClauseContext(Context, State);
		EnterRule(_localctx, 1558, RULE_rebuildClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7230;
			Match(REBUILD);
			State = 7237;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PARTITION:
				{
				State = 7231;
				Match(PARTITION);
				State = 7232;
				simpleIdentifierWithoutParentheses();
				}
				break;
			case SUBPARTITION:
				{
				State = 7233;
				Match(SUBPARTITION);
				State = 7234;
				simpleIdentifierWithoutParentheses();
				}
				break;
			case REVERSE:
				{
				State = 7235;
				Match(REVERSE);
				}
				break;
			case NOREVERSE:
				{
				State = 7236;
				Match(NOREVERSE);
				}
				break;
			case Eof:
			case COMPRESS:
			case COMPUTE:
			case FILESYSTEM_LIKE_LOGGING:
			case INITRANS:
			case LOGGING:
			case MAXTRANS:
			case NOCOMPRESS:
			case NOLOGGING:
			case NOPARALLEL:
			case ONLINE:
			case PARALLEL:
			case PARAMETERS:
			case PCTFREE:
			case PCTUSED:
			case STORAGE:
			case TABLESPACE:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			State = 7242;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMPRESS || _la==COMPUTE || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 276)) & ~0x3f) == 0 && ((1L << (_la - 276)) & ((1L << (LOGGING - 276)) | (1L << (MAXTRANS - 276)) | (1L << (NOCOMPRESS - 276)) | (1L << (NOLOGGING - 276)) | (1L << (NOPARALLEL - 276)))) != 0) || ((((_la - 358)) & ~0x3f) == 0 && ((1L << (_la - 358)) & ((1L << (ONLINE - 358)) | (1L << (PARALLEL - 358)) | (1L << (PARAMETERS - 358)) | (1L << (PCTFREE - 358)) | (1L << (PCTUSED - 358)))) != 0) || _la==STORAGE || _la==TABLESPACE) {
				{
				{
				State = 7239;
				rebuildOptions();
				}
				}
				State = 7244;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RebuildOptionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause() {
			return GetRuleContext<TablespaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParametersClauseContext parametersClause() {
			return GetRuleContext<ParametersClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLINE() { return GetToken(OracleAntlrParser.ONLINE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPUTE() { return GetToken(OracleAntlrParser.COMPUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATISTICS() { return GetToken(OracleAntlrParser.STATISTICS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute() {
			return GetRuleContext<PhysicalAttributeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeyCompressionContext keyCompression() {
			return GetRuleContext<KeyCompressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause() {
			return GetRuleContext<LoggingClauseContext>(0);
		}
		public RebuildOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rebuildOptions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRebuildOptions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRebuildOptions(this);
		}
	}

	[RuleVersion(0)]
	public RebuildOptionsContext rebuildOptions() {
		RebuildOptionsContext _localctx = new RebuildOptionsContext(Context, State);
		EnterRule(_localctx, 1560, RULE_rebuildOptions);
		try {
			State = 7254;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOPARALLEL:
			case PARALLEL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7245;
				parallelClause();
				}
				break;
			case TABLESPACE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7246;
				tablespaceClause();
				}
				break;
			case PARAMETERS:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7247;
				parametersClause();
				}
				break;
			case ONLINE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7248;
				Match(ONLINE);
				}
				break;
			case COMPUTE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7249;
				Match(COMPUTE);
				State = 7250;
				Match(STATISTICS);
				}
				break;
			case INITRANS:
			case MAXTRANS:
			case PCTFREE:
			case PCTUSED:
			case STORAGE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 7251;
				physicalAttribute();
				}
				break;
			case COMPRESS:
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 7);
				{
				State = 7252;
				keyCompression();
				}
				break;
			case FILESYSTEM_LIKE_LOGGING:
			case LOGGING:
			case NOLOGGING:
				EnterOuterAlt(_localctx, 8);
				{
				State = 7253;
				loggingClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeyCompressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPRESS() { return GetToken(OracleAntlrParser.COMPRESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCOMPRESS() { return GetToken(OracleAntlrParser.NOCOMPRESS, 0); }
		public KeyCompressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keyCompression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterKeyCompression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitKeyCompression(this);
		}
	}

	[RuleVersion(0)]
	public KeyCompressionContext keyCompression() {
		KeyCompressionContext _localctx = new KeyCompressionContext(Context, State);
		EnterRule(_localctx, 1562, RULE_keyCompression);
		int _la;
		try {
			State = 7261;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPRESS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7256;
				Match(COMPRESS);
				State = 7258;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATE || _la==FALSE || _la==INTERVAL || _la==TIMESTAMP || _la==TRUE || ((((_la - 579)) & ~0x3f) == 0 && ((1L << (_la - 579)) & ((1L << (INTEGER_LITERAL - 579)) | (1L << (FLOATING_POINT_LITERAL - 579)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 579)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 579)) | (1L << (BINARY_STRING_LITERAL - 579)) | (1L << (CHARACTER_STRING_LITERAL - 579)) | (1L << (MONEY_LITERAL - 579)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 579)))) != 0)) {
					{
					State = 7257;
					literal();
					}
				}

				}
				break;
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7260;
				Match(NOCOMPRESS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParametersClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARAMETERS() { return GetToken(OracleAntlrParser.PARAMETERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public ParametersClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parametersClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterParametersClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitParametersClause(this);
		}
	}

	[RuleVersion(0)]
	public ParametersClauseContext parametersClause() {
		ParametersClauseContext _localctx = new ParametersClauseContext(Context, State);
		EnterRule(_localctx, 1564, RULE_parametersClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7263;
			Match(PARAMETERS);
			State = 7264;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterIndexPartitioningContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModifyIndexDefaultAttributesContext modifyIndexDefaultAttributes() {
			return GetRuleContext<ModifyIndexDefaultAttributesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AddHashIndexPartitionContext addHashIndexPartition() {
			return GetRuleContext<AddHashIndexPartitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModifyIndexPartitionContext modifyIndexPartition() {
			return GetRuleContext<ModifyIndexPartitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RenameIndexPartitionContext renameIndexPartition() {
			return GetRuleContext<RenameIndexPartitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropIndexPartitionContext dropIndexPartition() {
			return GetRuleContext<DropIndexPartitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SplitIndexPartitionContext splitIndexPartition() {
			return GetRuleContext<SplitIndexPartitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CoalesceIndexPartitionContext coalesceIndexPartition() {
			return GetRuleContext<CoalesceIndexPartitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModifyIndexSubpartitionContext modifyIndexSubpartition() {
			return GetRuleContext<ModifyIndexSubpartitionContext>(0);
		}
		public AlterIndexPartitioningContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterIndexPartitioning; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlterIndexPartitioning(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlterIndexPartitioning(this);
		}
	}

	[RuleVersion(0)]
	public AlterIndexPartitioningContext alterIndexPartitioning() {
		AlterIndexPartitioningContext _localctx = new AlterIndexPartitioningContext(Context, State);
		EnterRule(_localctx, 1566, RULE_alterIndexPartitioning);
		try {
			State = 7274;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,831,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7266;
				modifyIndexDefaultAttributes();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7267;
				addHashIndexPartition();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7268;
				modifyIndexPartition();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7269;
				renameIndexPartition();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7270;
				dropIndexPartition();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 7271;
				splitIndexPartition();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 7272;
				coalesceIndexPartition();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 7273;
				modifyIndexSubpartition();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModifyIndexDefaultAttributesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MODIFY() { return GetToken(OracleAntlrParser.MODIFY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ATTRIBUTES() { return GetToken(OracleAntlrParser.ATTRIBUTES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModifyIndexAttributesContext[] modifyIndexAttributes() {
			return GetRuleContexts<ModifyIndexAttributesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModifyIndexAttributesContext modifyIndexAttributes(int i) {
			return GetRuleContext<ModifyIndexAttributesContext>(i);
		}
		public ModifyIndexDefaultAttributesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifyIndexDefaultAttributes; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterModifyIndexDefaultAttributes(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitModifyIndexDefaultAttributes(this);
		}
	}

	[RuleVersion(0)]
	public ModifyIndexDefaultAttributesContext modifyIndexDefaultAttributes() {
		ModifyIndexDefaultAttributesContext _localctx = new ModifyIndexDefaultAttributesContext(Context, State);
		EnterRule(_localctx, 1568, RULE_modifyIndexDefaultAttributes);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7276;
			Match(MODIFY);
			State = 7277;
			Match(DEFAULT);
			State = 7278;
			Match(ATTRIBUTES);
			State = 7282;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 7279;
				Match(FOR);
				State = 7280;
				Match(PARTITION);
				State = 7281;
				simpleIdentifierWithoutParentheses();
				}
			}

			State = 7285;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 7284;
				modifyIndexAttributes();
				}
				}
				State = 7287;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 276)) & ~0x3f) == 0 && ((1L << (_la - 276)) & ((1L << (LOGGING - 276)) | (1L << (MAXTRANS - 276)) | (1L << (NOLOGGING - 276)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModifyIndexAttributesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute() {
			return GetRuleContext<PhysicalAttributeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause() {
			return GetRuleContext<TablespaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause() {
			return GetRuleContext<LoggingClauseContext>(0);
		}
		public ModifyIndexAttributesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifyIndexAttributes; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterModifyIndexAttributes(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitModifyIndexAttributes(this);
		}
	}

	[RuleVersion(0)]
	public ModifyIndexAttributesContext modifyIndexAttributes() {
		ModifyIndexAttributesContext _localctx = new ModifyIndexAttributesContext(Context, State);
		EnterRule(_localctx, 1570, RULE_modifyIndexAttributes);
		try {
			State = 7292;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INITRANS:
			case MAXTRANS:
			case PCTFREE:
			case PCTUSED:
			case STORAGE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7289;
				physicalAttribute();
				}
				break;
			case TABLESPACE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7290;
				tablespaceClause();
				}
				break;
			case FILESYSTEM_LIKE_LOGGING:
			case LOGGING:
			case NOLOGGING:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7291;
				loggingClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddHashIndexPartitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADD() { return GetToken(OracleAntlrParser.ADD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause() {
			return GetRuleContext<TablespaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		public AddHashIndexPartitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addHashIndexPartition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAddHashIndexPartition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAddHashIndexPartition(this);
		}
	}

	[RuleVersion(0)]
	public AddHashIndexPartitionContext addHashIndexPartition() {
		AddHashIndexPartitionContext _localctx = new AddHashIndexPartitionContext(Context, State);
		EnterRule(_localctx, 1572, RULE_addHashIndexPartition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7294;
			Match(ADD);
			State = 7295;
			Match(PARTITION);
			State = 7297;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,835,Context) ) {
			case 1:
				{
				State = 7296;
				simpleIdentifierWithoutParentheses();
				}
				break;
			}
			State = 7300;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLESPACE) {
				{
				State = 7299;
				tablespaceClause();
				}
			}

			State = 7303;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOPARALLEL || _la==PARALLEL) {
				{
				State = 7302;
				parallelClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CoalesceIndexPartitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COALESCE() { return GetToken(OracleAntlrParser.COALESCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		public CoalesceIndexPartitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_coalesceIndexPartition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCoalesceIndexPartition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCoalesceIndexPartition(this);
		}
	}

	[RuleVersion(0)]
	public CoalesceIndexPartitionContext coalesceIndexPartition() {
		CoalesceIndexPartitionContext _localctx = new CoalesceIndexPartitionContext(Context, State);
		EnterRule(_localctx, 1574, RULE_coalesceIndexPartition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7305;
			Match(COALESCE);
			State = 7306;
			Match(PARTITION);
			State = 7308;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOPARALLEL || _la==PARALLEL) {
				{
				State = 7307;
				parallelClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModifyIndexPartitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MODIFY() { return GetToken(OracleAntlrParser.MODIFY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModifyIndexPartitionOptionsContext modifyIndexPartitionOptions() {
			return GetRuleContext<ModifyIndexPartitionOptionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParametersClauseContext parametersClause() {
			return GetRuleContext<ParametersClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COALESCE() { return GetToken(OracleAntlrParser.COALESCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UPDATE() { return GetToken(OracleAntlrParser.UPDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BLOCK() { return GetToken(OracleAntlrParser.BLOCK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFERENCES() { return GetToken(OracleAntlrParser.REFERENCES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		public ModifyIndexPartitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifyIndexPartition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterModifyIndexPartition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitModifyIndexPartition(this);
		}
	}

	[RuleVersion(0)]
	public ModifyIndexPartitionContext modifyIndexPartition() {
		ModifyIndexPartitionContext _localctx = new ModifyIndexPartitionContext(Context, State);
		EnterRule(_localctx, 1576, RULE_modifyIndexPartition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7310;
			Match(MODIFY);
			State = 7311;
			Match(PARTITION);
			State = 7312;
			simpleIdentifierWithoutParentheses();
			State = 7320;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
			case ALLOCATE:
			case COMPRESS:
			case DEALLOCATE:
			case FILESYSTEM_LIKE_LOGGING:
			case INITRANS:
			case LOGGING:
			case MAXTRANS:
			case NOCOMPRESS:
			case NOLOGGING:
			case PCTFREE:
			case PCTUSED:
			case STORAGE:
			case SEMI:
			case FSLASH:
				{
				State = 7313;
				modifyIndexPartitionOptions();
				}
				break;
			case PARAMETERS:
				{
				State = 7314;
				parametersClause();
				}
				break;
			case COALESCE:
				{
				State = 7315;
				Match(COALESCE);
				}
				break;
			case UPDATE:
				{
				State = 7316;
				Match(UPDATE);
				State = 7317;
				Match(BLOCK);
				State = 7318;
				Match(REFERENCES);
				}
				break;
			case UNUSABLE:
				{
				State = 7319;
				Match(UNUSABLE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModifyIndexPartitionOptionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeallocateUnusedClauseContext[] deallocateUnusedClause() {
			return GetRuleContexts<DeallocateUnusedClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeallocateUnusedClauseContext deallocateUnusedClause(int i) {
			return GetRuleContext<DeallocateUnusedClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AllocateExtentClauseContext[] allocateExtentClause() {
			return GetRuleContexts<AllocateExtentClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AllocateExtentClauseContext allocateExtentClause(int i) {
			return GetRuleContext<AllocateExtentClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext[] physicalAttribute() {
			return GetRuleContexts<PhysicalAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute(int i) {
			return GetRuleContext<PhysicalAttributeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext[] loggingClause() {
			return GetRuleContexts<LoggingClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause(int i) {
			return GetRuleContext<LoggingClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeyCompressionContext[] keyCompression() {
			return GetRuleContexts<KeyCompressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeyCompressionContext keyCompression(int i) {
			return GetRuleContext<KeyCompressionContext>(i);
		}
		public ModifyIndexPartitionOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifyIndexPartitionOptions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterModifyIndexPartitionOptions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitModifyIndexPartitionOptions(this);
		}
	}

	[RuleVersion(0)]
	public ModifyIndexPartitionOptionsContext modifyIndexPartitionOptions() {
		ModifyIndexPartitionOptionsContext _localctx = new ModifyIndexPartitionOptionsContext(Context, State);
		EnterRule(_localctx, 1578, RULE_modifyIndexPartitionOptions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7329;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ALLOCATE || _la==COMPRESS || _la==DEALLOCATE || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 276)) & ~0x3f) == 0 && ((1L << (_la - 276)) & ((1L << (LOGGING - 276)) | (1L << (MAXTRANS - 276)) | (1L << (NOCOMPRESS - 276)) | (1L << (NOLOGGING - 276)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE) {
				{
				State = 7327;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DEALLOCATE:
					{
					State = 7322;
					deallocateUnusedClause();
					}
					break;
				case ALLOCATE:
					{
					State = 7323;
					allocateExtentClause();
					}
					break;
				case INITRANS:
				case MAXTRANS:
				case PCTFREE:
				case PCTUSED:
				case STORAGE:
					{
					State = 7324;
					physicalAttribute();
					}
					break;
				case FILESYSTEM_LIKE_LOGGING:
				case LOGGING:
				case NOLOGGING:
					{
					State = 7325;
					loggingClause();
					}
					break;
				case COMPRESS:
				case NOCOMPRESS:
					{
					State = 7326;
					keyCompression();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 7331;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameIndexPartitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RENAME() { return GetToken(OracleAntlrParser.RENAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext[] simpleIdentifierWithoutParentheses() {
			return GetRuleContexts<SimpleIdentifierWithoutParenthesesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses(int i) {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(OracleAntlrParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		public RenameIndexPartitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameIndexPartition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterRenameIndexPartition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitRenameIndexPartition(this);
		}
	}

	[RuleVersion(0)]
	public RenameIndexPartitionContext renameIndexPartition() {
		RenameIndexPartitionContext _localctx = new RenameIndexPartitionContext(Context, State);
		EnterRule(_localctx, 1580, RULE_renameIndexPartition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7332;
			Match(RENAME);
			State = 7333;
			_la = TokenStream.LA(1);
			if ( !(_la==PARTITION || _la==SUBPARTITION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 7334;
			simpleIdentifierWithoutParentheses();
			State = 7335;
			Match(TO);
			State = 7336;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropIndexPartitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(OracleAntlrParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public DropIndexPartitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropIndexPartition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDropIndexPartition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDropIndexPartition(this);
		}
	}

	[RuleVersion(0)]
	public DropIndexPartitionContext dropIndexPartition() {
		DropIndexPartitionContext _localctx = new DropIndexPartitionContext(Context, State);
		EnterRule(_localctx, 1582, RULE_dropIndexPartition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7338;
			Match(DROP);
			State = 7339;
			Match(PARTITION);
			State = 7340;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SplitIndexPartitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SPLIT() { return GetToken(OracleAntlrParser.SPLIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SplitIndexPartitionAtClauseContext splitIndexPartitionAtClause() {
			return GetRuleContext<SplitIndexPartitionAtClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SplitIndexPartitionIntoClauseContext splitIndexPartitionIntoClause() {
			return GetRuleContext<SplitIndexPartitionIntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		public SplitIndexPartitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_splitIndexPartition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSplitIndexPartition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSplitIndexPartition(this);
		}
	}

	[RuleVersion(0)]
	public SplitIndexPartitionContext splitIndexPartition() {
		SplitIndexPartitionContext _localctx = new SplitIndexPartitionContext(Context, State);
		EnterRule(_localctx, 1584, RULE_splitIndexPartition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7342;
			Match(SPLIT);
			State = 7343;
			Match(PARTITION);
			State = 7344;
			simpleIdentifierWithoutParentheses();
			State = 7345;
			splitIndexPartitionAtClause();
			State = 7347;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTO) {
				{
				State = 7346;
				splitIndexPartitionIntoClause();
				}
			}

			State = 7350;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOPARALLEL || _la==PARALLEL) {
				{
				State = 7349;
				parallelClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SplitIndexPartitionAtClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT() { return GetToken(OracleAntlrParser.AT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParenthesizedExpressionListContext parenthesizedExpressionList() {
			return GetRuleContext<ParenthesizedExpressionListContext>(0);
		}
		public SplitIndexPartitionAtClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_splitIndexPartitionAtClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSplitIndexPartitionAtClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSplitIndexPartitionAtClause(this);
		}
	}

	[RuleVersion(0)]
	public SplitIndexPartitionAtClauseContext splitIndexPartitionAtClause() {
		SplitIndexPartitionAtClauseContext _localctx = new SplitIndexPartitionAtClauseContext(Context, State);
		EnterRule(_localctx, 1586, RULE_splitIndexPartitionAtClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7352;
			Match(AT);
			State = 7353;
			parenthesizedExpressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SplitIndexPartitionIntoClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexPartitionDescriptionContext[] indexPartitionDescription() {
			return GetRuleContexts<IndexPartitionDescriptionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexPartitionDescriptionContext indexPartitionDescription(int i) {
			return GetRuleContext<IndexPartitionDescriptionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public SplitIndexPartitionIntoClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_splitIndexPartitionIntoClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSplitIndexPartitionIntoClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSplitIndexPartitionIntoClause(this);
		}
	}

	[RuleVersion(0)]
	public SplitIndexPartitionIntoClauseContext splitIndexPartitionIntoClause() {
		SplitIndexPartitionIntoClauseContext _localctx = new SplitIndexPartitionIntoClauseContext(Context, State);
		EnterRule(_localctx, 1588, RULE_splitIndexPartitionIntoClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7355;
			Match(INTO);
			State = 7356;
			Match(LPAREN);
			State = 7357;
			indexPartitionDescription();
			State = 7358;
			Match(COMMA);
			State = 7359;
			indexPartitionDescription();
			State = 7360;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexPartitionDescriptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseContext[] segmentAttributesClause() {
			return GetRuleContexts<SegmentAttributesClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseContext segmentAttributesClause(int i) {
			return GetRuleContext<SegmentAttributesClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeyCompressionContext[] keyCompression() {
			return GetRuleContexts<KeyCompressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeyCompressionContext keyCompression(int i) {
			return GetRuleContext<KeyCompressionContext>(i);
		}
		public IndexPartitionDescriptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexPartitionDescription; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIndexPartitionDescription(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIndexPartitionDescription(this);
		}
	}

	[RuleVersion(0)]
	public IndexPartitionDescriptionContext indexPartitionDescription() {
		IndexPartitionDescriptionContext _localctx = new IndexPartitionDescriptionContext(Context, State);
		EnterRule(_localctx, 1590, RULE_indexPartitionDescription);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7362;
			Match(PARTITION);
			State = 7371;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)) | (1L << (NEW_NAMES - 256)) | (1L << (NEXT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)) | (1L << (PASSING - 320)) | (1L << (PASSWORD - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)) | (1L << (ROWID - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)) | (1L << (THAN - 448)))) != 0) || ((((_la - 513)) & ~0x3f) == 0 && ((1L << (_la - 513)) & ((1L << (TIME - 513)) | (1L << (TIMESTAMP - 513)) | (1L << (TIMEZONE_ABBR - 513)) | (1L << (TIMEZONE_HOUR - 513)) | (1L << (TIMEZONE_MINUTE - 513)) | (1L << (TIMEZONE_REGION - 513)) | (1L << (TRAILING - 513)) | (1L << (TRANSACTION - 513)) | (1L << (TRANSLATE - 513)) | (1L << (TREAT - 513)) | (1L << (TRIM - 513)) | (1L << (TRUE - 513)) | (1L << (TRUNCATE - 513)) | (1L << (TRUSTED - 513)) | (1L << (TYPE - 513)) | (1L << (UNBOUNDED - 513)) | (1L << (UNCONDITIONAL - 513)) | (1L << (UNDER - 513)) | (1L << (UNLIMITED - 513)) | (1L << (UNLOCK - 513)) | (1L << (UNUSABLE - 513)) | (1L << (UNUSED - 513)) | (1L << (USABLE - 513)) | (1L << (USAGE - 513)) | (1L << (USE - 513)) | (1L << (USER - 513)) | (1L << (USING - 513)) | (1L << (VALIDATE - 513)) | (1L << (VALUE - 513)) | (1L << (VARCHAR - 513)) | (1L << (VARCHAR2 - 513)) | (1L << (VARRAY - 513)) | (1L << (VARRAYS - 513)) | (1L << (VARYING - 513)) | (1L << (VERSIONS - 513)) | (1L << (VIRTUAL - 513)) | (1L << (VISIBLE - 513)) | (1L << (WAIT - 513)) | (1L << (WHEN - 513)) | (1L << (WITHIN - 513)) | (1L << (WITHOUT - 513)) | (1L << (WORK - 513)) | (1L << (WRAPPED - 513)) | (1L << (WRAPPER - 513)) | (1L << (WRITE - 513)) | (1L << (XML - 513)) | (1L << (XMLNAMESPACES - 513)) | (1L << (XMLSCHEMA - 513)) | (1L << (XMLTABLE - 513)) | (1L << (XMLTYPE - 513)))) != 0) || ((((_la - 577)) & ~0x3f) == 0 && ((1L << (_la - 577)) & ((1L << (YEAR - 577)) | (1L << (ZONE - 577)) | (1L << (REGULAR_IDENTIFIER - 577)) | (1L << (QUOTED_IDENTIFIER - 577)))) != 0)) {
				{
				State = 7363;
				simpleIdentifierWithoutParentheses();
				State = 7368;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 276)) & ~0x3f) == 0 && ((1L << (_la - 276)) & ((1L << (LOGGING - 276)) | (1L << (MAXTRANS - 276)) | (1L << (NOCOMPRESS - 276)) | (1L << (NOLOGGING - 276)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
					{
					State = 7366;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case FILESYSTEM_LIKE_LOGGING:
					case INITRANS:
					case LOGGING:
					case MAXTRANS:
					case NOLOGGING:
					case PCTFREE:
					case PCTUSED:
					case STORAGE:
					case TABLESPACE:
						{
						State = 7364;
						segmentAttributesClause();
						}
						break;
					case COMPRESS:
					case NOCOMPRESS:
						{
						State = 7365;
						keyCompression();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 7370;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModifyIndexSubpartitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MODIFY() { return GetToken(OracleAntlrParser.MODIFY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AllocateExtentClauseContext allocateExtentClause() {
			return GetRuleContext<AllocateExtentClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeallocateUnusedClauseContext deallocateUnusedClause() {
			return GetRuleContext<DeallocateUnusedClauseContext>(0);
		}
		public ModifyIndexSubpartitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifyIndexSubpartition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterModifyIndexSubpartition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitModifyIndexSubpartition(this);
		}
	}

	[RuleVersion(0)]
	public ModifyIndexSubpartitionContext modifyIndexSubpartition() {
		ModifyIndexSubpartitionContext _localctx = new ModifyIndexSubpartitionContext(Context, State);
		EnterRule(_localctx, 1592, RULE_modifyIndexSubpartition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7373;
			Match(MODIFY);
			State = 7374;
			Match(SUBPARTITION);
			State = 7375;
			simpleIdentifierWithoutParentheses();
			State = 7379;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNUSABLE:
				{
				State = 7376;
				Match(UNUSABLE);
				}
				break;
			case ALLOCATE:
				{
				State = 7377;
				allocateExtentClause();
				}
				break;
			case DEALLOCATE:
				{
				State = 7378;
				deallocateUnusedClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompileTypeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPILE() { return GetToken(OracleAntlrParser.COMPILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEBUG() { return GetToken(OracleAntlrParser.DEBUG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CompilerParametersClauseContext compilerParametersClause() {
			return GetRuleContext<CompilerParametersClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REUSE() { return GetToken(OracleAntlrParser.REUSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETTINGS() { return GetToken(OracleAntlrParser.SETTINGS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SPECIFICATION() { return GetToken(OracleAntlrParser.SPECIFICATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BODY() { return GetToken(OracleAntlrParser.BODY, 0); }
		public CompileTypeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compileTypeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCompileTypeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCompileTypeClause(this);
		}
	}

	[RuleVersion(0)]
	public CompileTypeClauseContext compileTypeClause() {
		CompileTypeClauseContext _localctx = new CompileTypeClauseContext(Context, State);
		EnterRule(_localctx, 1594, RULE_compileTypeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7381;
			Match(COMPILE);
			State = 7383;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,848,Context) ) {
			case 1:
				{
				State = 7382;
				Match(DEBUG);
				}
				break;
			}
			State = 7386;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,849,Context) ) {
			case 1:
				{
				State = 7385;
				_la = TokenStream.LA(1);
				if ( !(_la==BODY || _la==SPECIFICATION) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 7389;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,850,Context) ) {
			case 1:
				{
				State = 7388;
				compilerParametersClause();
				}
				break;
			}
			State = 7393;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REUSE) {
				{
				State = 7391;
				Match(REUSE);
				State = 7392;
				Match(SETTINGS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompilerParametersClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public CompilerParametersClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compilerParametersClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCompilerParametersClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCompilerParametersClause(this);
		}
	}

	[RuleVersion(0)]
	public CompilerParametersClauseContext compilerParametersClause() {
		CompilerParametersClauseContext _localctx = new CompilerParametersClauseContext(Context, State);
		EnterRule(_localctx, 1596, RULE_compilerParametersClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7395;
			simpleIdentifierWithoutParentheses();
			State = 7396;
			Match(EQUAL_SIGN);
			State = 7397;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReplaceTypeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPLACE() { return GetToken(OracleAntlrParser.REPLACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeStatementContext objectTypeStatement() {
			return GetRuleContext<ObjectTypeStatementContext>(0);
		}
		public ReplaceTypeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_replaceTypeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterReplaceTypeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitReplaceTypeClause(this);
		}
	}

	[RuleVersion(0)]
	public ReplaceTypeClauseContext replaceTypeClause() {
		ReplaceTypeClauseContext _localctx = new ReplaceTypeClauseContext(Context, State);
		EnterRule(_localctx, 1598, RULE_replaceTypeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7399;
			Match(REPLACE);
			State = 7400;
			objectTypeStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterMethodSpecificationsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AlterMethodSpecificationContext[] alterMethodSpecification() {
			return GetRuleContexts<AlterMethodSpecificationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterMethodSpecificationContext alterMethodSpecification(int i) {
			return GetRuleContext<AlterMethodSpecificationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public AlterMethodSpecificationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterMethodSpecifications; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlterMethodSpecifications(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlterMethodSpecifications(this);
		}
	}

	[RuleVersion(0)]
	public AlterMethodSpecificationsContext alterMethodSpecifications() {
		AlterMethodSpecificationsContext _localctx = new AlterMethodSpecificationsContext(Context, State);
		EnterRule(_localctx, 1600, RULE_alterMethodSpecifications);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7402;
			alterMethodSpecification();
			State = 7407;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 7403;
				Match(COMMA);
				State = 7404;
				alterMethodSpecification();
				}
				}
				State = 7409;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterMethodSpecificationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADD() { return GetToken(OracleAntlrParser.ADD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(OracleAntlrParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeMapOrderFunctionContext objectTypeMapOrderFunction() {
			return GetRuleContext<ObjectTypeMapOrderFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeMemberStaticRoutineContext objectTypeMemberStaticRoutine() {
			return GetRuleContext<ObjectTypeMemberStaticRoutineContext>(0);
		}
		public AlterMethodSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterMethodSpecification; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlterMethodSpecification(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlterMethodSpecification(this);
		}
	}

	[RuleVersion(0)]
	public AlterMethodSpecificationContext alterMethodSpecification() {
		AlterMethodSpecificationContext _localctx = new AlterMethodSpecificationContext(Context, State);
		EnterRule(_localctx, 1602, RULE_alterMethodSpecification);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7410;
			_la = TokenStream.LA(1);
			if ( !(_la==ADD || _la==DROP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 7413;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MAP:
			case ORDER:
				{
				State = 7411;
				objectTypeMapOrderFunction();
				}
				break;
			case MEMBER:
			case STATIC:
				{
				State = 7412;
				objectTypeMemberStaticRoutine();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterAttributeDefinitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AddOrModifyAttributeDefinitionContext addOrModifyAttributeDefinition() {
			return GetRuleContext<AddOrModifyAttributeDefinitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropAttributeDefinitionContext dropAttributeDefinition() {
			return GetRuleContext<DropAttributeDefinitionContext>(0);
		}
		public AlterAttributeDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterAttributeDefinition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlterAttributeDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlterAttributeDefinition(this);
		}
	}

	[RuleVersion(0)]
	public AlterAttributeDefinitionContext alterAttributeDefinition() {
		AlterAttributeDefinitionContext _localctx = new AlterAttributeDefinitionContext(Context, State);
		EnterRule(_localctx, 1604, RULE_alterAttributeDefinition);
		try {
			State = 7417;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ADD:
			case MODIFY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7415;
				addOrModifyAttributeDefinition();
				}
				break;
			case DROP:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7416;
				dropAttributeDefinition();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddOrModifyAttributeDefinitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ATTRIBUTE() { return GetToken(OracleAntlrParser.ATTRIBUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADD() { return GetToken(OracleAntlrParser.ADD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MODIFY() { return GetToken(OracleAntlrParser.MODIFY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AlterTypeDeclarationContext alterTypeDeclaration() {
			return GetRuleContext<AlterTypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterTypeDeclarationInParenContext alterTypeDeclarationInParen() {
			return GetRuleContext<AlterTypeDeclarationInParenContext>(0);
		}
		public AddOrModifyAttributeDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addOrModifyAttributeDefinition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAddOrModifyAttributeDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAddOrModifyAttributeDefinition(this);
		}
	}

	[RuleVersion(0)]
	public AddOrModifyAttributeDefinitionContext addOrModifyAttributeDefinition() {
		AddOrModifyAttributeDefinitionContext _localctx = new AddOrModifyAttributeDefinitionContext(Context, State);
		EnterRule(_localctx, 1606, RULE_addOrModifyAttributeDefinition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7419;
			_la = TokenStream.LA(1);
			if ( !(_la==ADD || _la==MODIFY) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 7420;
			Match(ATTRIBUTE);
			State = 7423;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 7421;
				alterTypeDeclaration();
				}
				break;
			case LPAREN:
				{
				State = 7422;
				alterTypeDeclarationInParen();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public AlterTypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTypeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlterTypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlterTypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public AlterTypeDeclarationContext alterTypeDeclaration() {
		AlterTypeDeclarationContext _localctx = new AlterTypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1608, RULE_alterTypeDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7425;
			simpleIdentifier();
			State = 7427;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,856,Context) ) {
			case 1:
				{
				State = 7426;
				typeReference();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTypeDeclarationInParenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeAttributeDeclarationContext[] objectTypeAttributeDeclaration() {
			return GetRuleContexts<ObjectTypeAttributeDeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeAttributeDeclarationContext objectTypeAttributeDeclaration(int i) {
			return GetRuleContext<ObjectTypeAttributeDeclarationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public AlterTypeDeclarationInParenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTypeDeclarationInParen; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlterTypeDeclarationInParen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlterTypeDeclarationInParen(this);
		}
	}

	[RuleVersion(0)]
	public AlterTypeDeclarationInParenContext alterTypeDeclarationInParen() {
		AlterTypeDeclarationInParenContext _localctx = new AlterTypeDeclarationInParenContext(Context, State);
		EnterRule(_localctx, 1610, RULE_alterTypeDeclarationInParen);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7429;
			Match(LPAREN);
			State = 7430;
			objectTypeAttributeDeclaration();
			State = 7435;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 7431;
				Match(COMMA);
				State = 7432;
				objectTypeAttributeDeclaration();
				}
				}
				State = 7437;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 7438;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropAttributeDefinitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(OracleAntlrParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ATTRIBUTE() { return GetToken(OracleAntlrParser.ATTRIBUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public DropAttributeDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropAttributeDefinition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDropAttributeDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDropAttributeDefinition(this);
		}
	}

	[RuleVersion(0)]
	public DropAttributeDefinitionContext dropAttributeDefinition() {
		DropAttributeDefinitionContext _localctx = new DropAttributeDefinitionContext(Context, State);
		EnterRule(_localctx, 1612, RULE_dropAttributeDefinition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7440;
			Match(DROP);
			State = 7441;
			Match(ATTRIBUTE);
			State = 7442;
			simpleIdentifierWithoutParentheses();
			State = 7443;
			columnListInParenElementClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterCollectionClausesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MODIFY() { return GetToken(OracleAntlrParser.MODIFY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIMIT() { return GetToken(OracleAntlrParser.LIMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELEMENT() { return GetToken(OracleAntlrParser.ELEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public AlterCollectionClausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterCollectionClauses; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlterCollectionClauses(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlterCollectionClauses(this);
		}
	}

	[RuleVersion(0)]
	public AlterCollectionClausesContext alterCollectionClauses() {
		AlterCollectionClausesContext _localctx = new AlterCollectionClausesContext(Context, State);
		EnterRule(_localctx, 1614, RULE_alterCollectionClauses);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7445;
			Match(MODIFY);
			State = 7451;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LIMIT:
				{
				State = 7446;
				Match(LIMIT);
				State = 7447;
				literal();
				}
				break;
			case ELEMENT:
				{
				State = 7448;
				Match(ELEMENT);
				State = 7449;
				Match(TYPE);
				State = 7450;
				typeReference();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DependentHandlingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public InvalidateHandlingClauseContext invalidateHandlingClause() {
			return GetRuleContext<InvalidateHandlingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CascadeHandlingClauseContext cascadeHandlingClause() {
			return GetRuleContext<CascadeHandlingClauseContext>(0);
		}
		public DependentHandlingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dependentHandlingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDependentHandlingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDependentHandlingClause(this);
		}
	}

	[RuleVersion(0)]
	public DependentHandlingClauseContext dependentHandlingClause() {
		DependentHandlingClauseContext _localctx = new DependentHandlingClauseContext(Context, State);
		EnterRule(_localctx, 1616, RULE_dependentHandlingClause);
		try {
			State = 7455;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INVALIDATE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7453;
				invalidateHandlingClause();
				}
				break;
			case CASCADE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7454;
				cascadeHandlingClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InvalidateHandlingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALIDATE() { return GetToken(OracleAntlrParser.INVALIDATE, 0); }
		public InvalidateHandlingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_invalidateHandlingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterInvalidateHandlingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitInvalidateHandlingClause(this);
		}
	}

	[RuleVersion(0)]
	public InvalidateHandlingClauseContext invalidateHandlingClause() {
		InvalidateHandlingClauseContext _localctx = new InvalidateHandlingClauseContext(Context, State);
		EnterRule(_localctx, 1618, RULE_invalidateHandlingClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7457;
			Match(INVALIDATE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CascadeHandlingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASCADE() { return GetToken(OracleAntlrParser.CASCADE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DependentTypesClauseContext dependentTypesClause() {
			return GetRuleContext<DependentTypesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForceExceptionsClauseContext forceExceptionsClause() {
			return GetRuleContext<ForceExceptionsClauseContext>(0);
		}
		public CascadeHandlingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cascadeHandlingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCascadeHandlingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCascadeHandlingClause(this);
		}
	}

	[RuleVersion(0)]
	public CascadeHandlingClauseContext cascadeHandlingClause() {
		CascadeHandlingClauseContext _localctx = new CascadeHandlingClauseContext(Context, State);
		EnterRule(_localctx, 1620, RULE_cascadeHandlingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7459;
			Match(CASCADE);
			State = 7461;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONVERT || _la==INCLUDING || _la==NOT) {
				{
				State = 7460;
				dependentTypesClause();
				}
			}

			State = 7464;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXCEPTIONS || _la==FORCE) {
				{
				State = 7463;
				forceExceptionsClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DependentTypesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IncludingTableDataContext includingTableData() {
			return GetRuleContext<IncludingTableDataContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConvertToSubstitutableContext convertToSubstitutable() {
			return GetRuleContext<ConvertToSubstitutableContext>(0);
		}
		public DependentTypesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dependentTypesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterDependentTypesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitDependentTypesClause(this);
		}
	}

	[RuleVersion(0)]
	public DependentTypesClauseContext dependentTypesClause() {
		DependentTypesClauseContext _localctx = new DependentTypesClauseContext(Context, State);
		EnterRule(_localctx, 1622, RULE_dependentTypesClause);
		try {
			State = 7468;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INCLUDING:
			case NOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7466;
				includingTableData();
				}
				break;
			case CONVERT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7467;
				convertToSubstitutable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IncludingTableDataContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDING() { return GetToken(OracleAntlrParser.INCLUDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATA() { return GetToken(OracleAntlrParser.DATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public IncludingTableDataContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_includingTableData; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIncludingTableData(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIncludingTableData(this);
		}
	}

	[RuleVersion(0)]
	public IncludingTableDataContext includingTableData() {
		IncludingTableDataContext _localctx = new IncludingTableDataContext(Context, State);
		EnterRule(_localctx, 1624, RULE_includingTableData);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7471;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 7470;
				Match(NOT);
				}
			}

			State = 7473;
			Match(INCLUDING);
			State = 7474;
			Match(TABLE);
			State = 7475;
			Match(DATA);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConvertToSubstitutableContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONVERT() { return GetToken(OracleAntlrParser.CONVERT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(OracleAntlrParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBSTITUTABLE() { return GetToken(OracleAntlrParser.SUBSTITUTABLE, 0); }
		public ConvertToSubstitutableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_convertToSubstitutable; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConvertToSubstitutable(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConvertToSubstitutable(this);
		}
	}

	[RuleVersion(0)]
	public ConvertToSubstitutableContext convertToSubstitutable() {
		ConvertToSubstitutableContext _localctx = new ConvertToSubstitutableContext(Context, State);
		EnterRule(_localctx, 1626, RULE_convertToSubstitutable);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7477;
			Match(CONVERT);
			State = 7478;
			Match(TO);
			State = 7479;
			Match(SUBSTITUTABLE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForceExceptionsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionsIntoConstraintClauseContext exceptionsIntoConstraintClause() {
			return GetRuleContext<ExceptionsIntoConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORCE() { return GetToken(OracleAntlrParser.FORCE, 0); }
		public ForceExceptionsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forceExceptionsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterForceExceptionsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitForceExceptionsClause(this);
		}
	}

	[RuleVersion(0)]
	public ForceExceptionsClauseContext forceExceptionsClause() {
		ForceExceptionsClauseContext _localctx = new ForceExceptionsClauseContext(Context, State);
		EnterRule(_localctx, 1628, RULE_forceExceptionsClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7482;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FORCE) {
				{
				State = 7481;
				Match(FORCE);
				}
			}

			State = 7484;
			exceptionsIntoConstraintClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterSequenceStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEQUENCE() { return GetToken(OracleAntlrParser.SEQUENCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceOptionContext[] sequenceOption() {
			return GetRuleContexts<SequenceOptionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceOptionContext sequenceOption(int i) {
			return GetRuleContext<SequenceOptionContext>(i);
		}
		public AlterSequenceStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterSequenceStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlterSequenceStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlterSequenceStatement(this);
		}
	}

	[RuleVersion(0)]
	public AlterSequenceStatementContext alterSequenceStatement() {
		AlterSequenceStatementContext _localctx = new AlterSequenceStatementContext(Context, State);
		EnterRule(_localctx, 1630, RULE_alterSequenceStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7486;
			Match(SEQUENCE);
			State = 7487;
			plainIdentifier();
			State = 7489;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 7488;
				sequenceOption();
				}
				}
				State = 7491;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==CACHE || _la==CYCLE || ((((_la - 202)) & ~0x3f) == 0 && ((1L << (_la - 202)) & ((1L << (GLOBAL - 202)) | (1L << (INCREMENT - 202)) | (1L << (KEEP - 202)))) != 0) || ((((_la - 291)) & ~0x3f) == 0 && ((1L << (_la - 291)) & ((1L << (MAXVALUE - 291)) | (1L << (MINVALUE - 291)) | (1L << (NOCACHE - 291)) | (1L << (NOCYCLE - 291)) | (1L << (NOKEEP - 291)) | (1L << (NOMAXVALUE - 291)) | (1L << (NOMINVALUE - 291)) | (1L << (NOORDER - 291)) | (1L << (NOSCALE - 291)) | (1L << (NOSHARD - 291)))) != 0) || _la==ORDER || ((((_la - 453)) & ~0x3f) == 0 && ((1L << (_la - 453)) & ((1L << (SCALE - 453)) | (1L << (SESSION - 453)) | (1L << (START - 453)) | (1L << (SHARD - 453)))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SequenceIncrementClauseContext sequenceIncrementClause() {
			return GetRuleContext<SequenceIncrementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceStartWithClauseContext sequenceStartWithClause() {
			return GetRuleContext<SequenceStartWithClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceMaxValueClauseContext sequenceMaxValueClause() {
			return GetRuleContext<SequenceMaxValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceMinValueClauseContext sequenceMinValueClause() {
			return GetRuleContext<SequenceMinValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceCycleClauseContext sequenceCycleClause() {
			return GetRuleContext<SequenceCycleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceCacheClauseContext sequenceCacheClause() {
			return GetRuleContext<SequenceCacheClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceOrderClauseContext sequenceOrderClause() {
			return GetRuleContext<SequenceOrderClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceScaleClauseContext sequenceScaleClause() {
			return GetRuleContext<SequenceScaleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceKeepClauseContext sequenceKeepClause() {
			return GetRuleContext<SequenceKeepClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceShardClauseContext sequenceShardClause() {
			return GetRuleContext<SequenceShardClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceScopeClauseContext sequenceScopeClause() {
			return GetRuleContext<SequenceScopeClauseContext>(0);
		}
		public SequenceOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSequenceOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSequenceOption(this);
		}
	}

	[RuleVersion(0)]
	public SequenceOptionContext sequenceOption() {
		SequenceOptionContext _localctx = new SequenceOptionContext(Context, State);
		EnterRule(_localctx, 1632, RULE_sequenceOption);
		try {
			State = 7504;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INCREMENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7493;
				sequenceIncrementClause();
				}
				break;
			case START:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7494;
				sequenceStartWithClause();
				}
				break;
			case MAXVALUE:
			case NOMAXVALUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7495;
				sequenceMaxValueClause();
				}
				break;
			case MINVALUE:
			case NOMINVALUE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7496;
				sequenceMinValueClause();
				}
				break;
			case CYCLE:
			case NOCYCLE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7497;
				sequenceCycleClause();
				}
				break;
			case CACHE:
			case NOCACHE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 7498;
				sequenceCacheClause();
				}
				break;
			case NOORDER:
			case ORDER:
				EnterOuterAlt(_localctx, 7);
				{
				State = 7499;
				sequenceOrderClause();
				}
				break;
			case NOSCALE:
			case SCALE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 7500;
				sequenceScaleClause();
				}
				break;
			case KEEP:
			case NOKEEP:
				EnterOuterAlt(_localctx, 9);
				{
				State = 7501;
				sequenceKeepClause();
				}
				break;
			case NOSHARD:
			case SHARD:
				EnterOuterAlt(_localctx, 10);
				{
				State = 7502;
				sequenceShardClause();
				}
				break;
			case GLOBAL:
			case SESSION:
				EnterOuterAlt(_localctx, 11);
				{
				State = 7503;
				sequenceScopeClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentityOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SequenceIncrementClauseContext sequenceIncrementClause() {
			return GetRuleContext<SequenceIncrementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceStartWithClauseContext sequenceStartWithClause() {
			return GetRuleContext<SequenceStartWithClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceMaxValueClauseContext sequenceMaxValueClause() {
			return GetRuleContext<SequenceMaxValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceMinValueClauseContext sequenceMinValueClause() {
			return GetRuleContext<SequenceMinValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceCycleClauseContext sequenceCycleClause() {
			return GetRuleContext<SequenceCycleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceCacheClauseContext sequenceCacheClause() {
			return GetRuleContext<SequenceCacheClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceOrderClauseContext sequenceOrderClause() {
			return GetRuleContext<SequenceOrderClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceScaleClauseContext sequenceScaleClause() {
			return GetRuleContext<SequenceScaleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceKeepClauseContext sequenceKeepClause() {
			return GetRuleContext<SequenceKeepClauseContext>(0);
		}
		public IdentityOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identityOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterIdentityOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitIdentityOption(this);
		}
	}

	[RuleVersion(0)]
	public IdentityOptionContext identityOption() {
		IdentityOptionContext _localctx = new IdentityOptionContext(Context, State);
		EnterRule(_localctx, 1634, RULE_identityOption);
		try {
			State = 7515;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INCREMENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7506;
				sequenceIncrementClause();
				}
				break;
			case START:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7507;
				sequenceStartWithClause();
				}
				break;
			case MAXVALUE:
			case NOMAXVALUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7508;
				sequenceMaxValueClause();
				}
				break;
			case MINVALUE:
			case NOMINVALUE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7509;
				sequenceMinValueClause();
				}
				break;
			case CYCLE:
			case NOCYCLE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7510;
				sequenceCycleClause();
				}
				break;
			case CACHE:
			case NOCACHE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 7511;
				sequenceCacheClause();
				}
				break;
			case NOORDER:
			case ORDER:
				EnterOuterAlt(_localctx, 7);
				{
				State = 7512;
				sequenceOrderClause();
				}
				break;
			case NOSCALE:
			case SCALE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 7513;
				sequenceScaleClause();
				}
				break;
			case KEEP:
			case NOKEEP:
				EnterOuterAlt(_localctx, 9);
				{
				State = 7514;
				sequenceKeepClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceIncrementClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCREMENT() { return GetToken(OracleAntlrParser.INCREMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_SIGN() { return GetToken(OracleAntlrParser.MINUS_SIGN, 0); }
		public SequenceIncrementClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceIncrementClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSequenceIncrementClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSequenceIncrementClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceIncrementClauseContext sequenceIncrementClause() {
		SequenceIncrementClauseContext _localctx = new SequenceIncrementClauseContext(Context, State);
		EnterRule(_localctx, 1636, RULE_sequenceIncrementClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7517;
			Match(INCREMENT);
			State = 7518;
			Match(BY);
			State = 7520;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MINUS_SIGN) {
				{
				State = 7519;
				Match(MINUS_SIGN);
				}
			}

			State = 7522;
			Match(INTEGER_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceStartWithClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode START() { return GetToken(OracleAntlrParser.START, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIMIT() { return GetToken(OracleAntlrParser.LIMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(OracleAntlrParser.VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_SIGN() { return GetToken(OracleAntlrParser.MINUS_SIGN, 0); }
		public SequenceStartWithClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceStartWithClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSequenceStartWithClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSequenceStartWithClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceStartWithClauseContext sequenceStartWithClause() {
		SequenceStartWithClauseContext _localctx = new SequenceStartWithClauseContext(Context, State);
		EnterRule(_localctx, 1638, RULE_sequenceStartWithClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7524;
			Match(START);
			State = 7525;
			Match(WITH);
			State = 7532;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INTEGER_LITERAL:
			case MINUS_SIGN:
				{
				State = 7527;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MINUS_SIGN) {
					{
					State = 7526;
					Match(MINUS_SIGN);
					}
				}

				State = 7529;
				Match(INTEGER_LITERAL);
				}
				break;
			case LIMIT:
				{
				State = 7530;
				Match(LIMIT);
				State = 7531;
				Match(VALUE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceMaxValueClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXVALUE() { return GetToken(OracleAntlrParser.MAXVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_SIGN() { return GetToken(OracleAntlrParser.MINUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMAXVALUE() { return GetToken(OracleAntlrParser.NOMAXVALUE, 0); }
		public SequenceMaxValueClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceMaxValueClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSequenceMaxValueClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSequenceMaxValueClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceMaxValueClauseContext sequenceMaxValueClause() {
		SequenceMaxValueClauseContext _localctx = new SequenceMaxValueClauseContext(Context, State);
		EnterRule(_localctx, 1640, RULE_sequenceMaxValueClause);
		int _la;
		try {
			State = 7540;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MAXVALUE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7534;
				Match(MAXVALUE);
				State = 7536;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MINUS_SIGN) {
					{
					State = 7535;
					Match(MINUS_SIGN);
					}
				}

				State = 7538;
				Match(INTEGER_LITERAL);
				}
				break;
			case NOMAXVALUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7539;
				Match(NOMAXVALUE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceMinValueClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINVALUE() { return GetToken(OracleAntlrParser.MINVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_SIGN() { return GetToken(OracleAntlrParser.MINUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMINVALUE() { return GetToken(OracleAntlrParser.NOMINVALUE, 0); }
		public SequenceMinValueClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceMinValueClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSequenceMinValueClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSequenceMinValueClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceMinValueClauseContext sequenceMinValueClause() {
		SequenceMinValueClauseContext _localctx = new SequenceMinValueClauseContext(Context, State);
		EnterRule(_localctx, 1642, RULE_sequenceMinValueClause);
		int _la;
		try {
			State = 7548;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MINVALUE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7542;
				Match(MINVALUE);
				State = 7544;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MINUS_SIGN) {
					{
					State = 7543;
					Match(MINUS_SIGN);
					}
				}

				State = 7546;
				Match(INTEGER_LITERAL);
				}
				break;
			case NOMINVALUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7547;
				Match(NOMINVALUE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceCycleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CYCLE() { return GetToken(OracleAntlrParser.CYCLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCYCLE() { return GetToken(OracleAntlrParser.NOCYCLE, 0); }
		public SequenceCycleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceCycleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSequenceCycleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSequenceCycleClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceCycleClauseContext sequenceCycleClause() {
		SequenceCycleClauseContext _localctx = new SequenceCycleClauseContext(Context, State);
		EnterRule(_localctx, 1644, RULE_sequenceCycleClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7550;
			_la = TokenStream.LA(1);
			if ( !(_la==CYCLE || _la==NOCYCLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceCacheClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CACHE() { return GetToken(OracleAntlrParser.CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_SIGN() { return GetToken(OracleAntlrParser.MINUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCACHE() { return GetToken(OracleAntlrParser.NOCACHE, 0); }
		public SequenceCacheClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceCacheClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSequenceCacheClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSequenceCacheClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceCacheClauseContext sequenceCacheClause() {
		SequenceCacheClauseContext _localctx = new SequenceCacheClauseContext(Context, State);
		EnterRule(_localctx, 1646, RULE_sequenceCacheClause);
		int _la;
		try {
			State = 7558;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CACHE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7552;
				Match(CACHE);
				State = 7554;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MINUS_SIGN) {
					{
					State = 7553;
					Match(MINUS_SIGN);
					}
				}

				State = 7556;
				Match(INTEGER_LITERAL);
				}
				break;
			case NOCACHE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7557;
				Match(NOCACHE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceOrderClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDER() { return GetToken(OracleAntlrParser.ORDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOORDER() { return GetToken(OracleAntlrParser.NOORDER, 0); }
		public SequenceOrderClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceOrderClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSequenceOrderClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSequenceOrderClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceOrderClauseContext sequenceOrderClause() {
		SequenceOrderClauseContext _localctx = new SequenceOrderClauseContext(Context, State);
		EnterRule(_localctx, 1648, RULE_sequenceOrderClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7560;
			_la = TokenStream.LA(1);
			if ( !(_la==NOORDER || _la==ORDER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceScaleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCALE() { return GetToken(OracleAntlrParser.SCALE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTEND() { return GetToken(OracleAntlrParser.EXTEND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOEXTEND() { return GetToken(OracleAntlrParser.NOEXTEND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOSCALE() { return GetToken(OracleAntlrParser.NOSCALE, 0); }
		public SequenceScaleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceScaleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSequenceScaleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSequenceScaleClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceScaleClauseContext sequenceScaleClause() {
		SequenceScaleClauseContext _localctx = new SequenceScaleClauseContext(Context, State);
		EnterRule(_localctx, 1650, RULE_sequenceScaleClause);
		int _la;
		try {
			State = 7567;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SCALE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7562;
				Match(SCALE);
				State = 7564;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EXTEND || _la==NOEXTEND) {
					{
					State = 7563;
					_la = TokenStream.LA(1);
					if ( !(_la==EXTEND || _la==NOEXTEND) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			case NOSCALE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7566;
				Match(NOSCALE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceKeepClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOKEEP() { return GetToken(OracleAntlrParser.NOKEEP, 0); }
		public SequenceKeepClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceKeepClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSequenceKeepClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSequenceKeepClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceKeepClauseContext sequenceKeepClause() {
		SequenceKeepClauseContext _localctx = new SequenceKeepClauseContext(Context, State);
		EnterRule(_localctx, 1652, RULE_sequenceKeepClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7569;
			_la = TokenStream.LA(1);
			if ( !(_la==KEEP || _la==NOKEEP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceShardClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARD() { return GetToken(OracleAntlrParser.SHARD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTEND() { return GetToken(OracleAntlrParser.EXTEND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOEXTEND() { return GetToken(OracleAntlrParser.NOEXTEND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOSHARD() { return GetToken(OracleAntlrParser.NOSHARD, 0); }
		public SequenceShardClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceShardClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSequenceShardClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSequenceShardClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceShardClauseContext sequenceShardClause() {
		SequenceShardClauseContext _localctx = new SequenceShardClauseContext(Context, State);
		EnterRule(_localctx, 1654, RULE_sequenceShardClause);
		int _la;
		try {
			State = 7576;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SHARD:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7571;
				Match(SHARD);
				State = 7573;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EXTEND || _la==NOEXTEND) {
					{
					State = 7572;
					_la = TokenStream.LA(1);
					if ( !(_la==EXTEND || _la==NOEXTEND) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			case NOSHARD:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7575;
				Match(NOSHARD);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceScopeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SESSION() { return GetToken(OracleAntlrParser.SESSION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GLOBAL() { return GetToken(OracleAntlrParser.GLOBAL, 0); }
		public SequenceScopeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceScopeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSequenceScopeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSequenceScopeClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceScopeClauseContext sequenceScopeClause() {
		SequenceScopeClauseContext _localctx = new SequenceScopeClauseContext(Context, State);
		EnterRule(_localctx, 1656, RULE_sequenceScopeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7578;
			_la = TokenStream.LA(1);
			if ( !(_la==GLOBAL || _la==SESSION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTypeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OidClauseContext oidClause() {
			return GetRuleContext<OidClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompleteTypeStatementContext completeTypeStatement() {
			return GetRuleContext<CompleteTypeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterTypeEmbeddedStatementContext[] alterTypeEmbeddedStatement() {
			return GetRuleContexts<AlterTypeEmbeddedStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterTypeEmbeddedStatementContext alterTypeEmbeddedStatement(int i) {
			return GetRuleContext<AlterTypeEmbeddedStatementContext>(i);
		}
		public CreateTypeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTypeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateTypeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateTypeStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateTypeStatementContext createTypeStatement() {
		CreateTypeStatementContext _localctx = new CreateTypeStatementContext(Context, State);
		EnterRule(_localctx, 1658, RULE_createTypeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7580;
			Match(TYPE);
			State = 7581;
			plainIdentifier();
			State = 7583;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OID) {
				{
				State = 7582;
				oidClause();
				}
			}

			State = 7586;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS || _la==AUTHID || _la==IS || _la==UNDER) {
				{
				State = 7585;
				completeTypeStatement();
				}
			}

			State = 7591;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ALTER) {
				{
				{
				State = 7588;
				alterTypeEmbeddedStatement();
				}
				}
				State = 7593;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTypeEmbeddedStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALTER() { return GetToken(OracleAntlrParser.ALTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AlterTypeStatementContext alterTypeStatement() {
			return GetRuleContext<AlterTypeStatementContext>(0);
		}
		public AlterTypeEmbeddedStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTypeEmbeddedStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterAlterTypeEmbeddedStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitAlterTypeEmbeddedStatement(this);
		}
	}

	[RuleVersion(0)]
	public AlterTypeEmbeddedStatementContext alterTypeEmbeddedStatement() {
		AlterTypeEmbeddedStatementContext _localctx = new AlterTypeEmbeddedStatementContext(Context, State);
		EnterRule(_localctx, 1660, RULE_alterTypeEmbeddedStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7594;
			Match(ALTER);
			State = 7595;
			alterTypeStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompleteTypeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeStatementContext objectTypeStatement() {
			return GetRuleContext<ObjectTypeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayTypeStatementContext varrayTypeStatement() {
			return GetRuleContext<VarrayTypeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NestedTableTypeStatementContext nestedTableTypeStatement() {
			return GetRuleContext<NestedTableTypeStatementContext>(0);
		}
		public CompleteTypeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_completeTypeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCompleteTypeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCompleteTypeStatement(this);
		}
	}

	[RuleVersion(0)]
	public CompleteTypeStatementContext completeTypeStatement() {
		CompleteTypeStatementContext _localctx = new CompleteTypeStatementContext(Context, State);
		EnterRule(_localctx, 1662, RULE_completeTypeStatement);
		try {
			State = 7600;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,884,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7597;
				objectTypeStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7598;
				varrayTypeStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7599;
				nestedTableTypeStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TopLevelObjectTypeContext topLevelObjectType() {
			return GetRuleContext<TopLevelObjectTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubTypeContext subType() {
			return GetRuleContext<SubTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InvokerRightsClauseContext invokerRightsClause() {
			return GetRuleContext<InvokerRightsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeDeclarationItemsContext objectTypeDeclarationItems() {
			return GetRuleContext<ObjectTypeDeclarationItemsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InheritanceClauseContext[] inheritanceClause() {
			return GetRuleContexts<InheritanceClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public InheritanceClauseContext inheritanceClause(int i) {
			return GetRuleContext<InheritanceClauseContext>(i);
		}
		public ObjectTypeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectTypeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectTypeStatement(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeStatementContext objectTypeStatement() {
		ObjectTypeStatementContext _localctx = new ObjectTypeStatementContext(Context, State);
		EnterRule(_localctx, 1664, RULE_objectTypeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7603;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AUTHID) {
				{
				State = 7602;
				invokerRightsClause();
				}
			}

			State = 7607;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
			case IS:
				{
				State = 7605;
				topLevelObjectType();
				}
				break;
			case UNDER:
				{
				State = 7606;
				subType();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 7610;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 7609;
				objectTypeDeclarationItems();
				}
			}

			State = 7615;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==FINAL || _la==INSTANTIABLE || _la==NOT || _la==OVERRIDING) {
				{
				{
				State = 7612;
				inheritanceClause();
				}
				}
				State = 7617;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TopLevelObjectTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
			return GetRuleContext<RoutineBodyAsIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(OracleAntlrParser.OBJECT, 0); }
		public TopLevelObjectTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_topLevelObjectType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterTopLevelObjectType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitTopLevelObjectType(this);
		}
	}

	[RuleVersion(0)]
	public TopLevelObjectTypeContext topLevelObjectType() {
		TopLevelObjectTypeContext _localctx = new TopLevelObjectTypeContext(Context, State);
		EnterRule(_localctx, 1666, RULE_topLevelObjectType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7618;
			routineBodyAsIsClause();
			State = 7619;
			Match(OBJECT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UnderClauseContext underClause() {
			return GetRuleContext<UnderClauseContext>(0);
		}
		public SubTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterSubType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitSubType(this);
		}
	}

	[RuleVersion(0)]
	public SubTypeContext subType() {
		SubTypeContext _localctx = new SubTypeContext(Context, State);
		EnterRule(_localctx, 1668, RULE_subType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7621;
			underClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeDeclarationItemsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeDeclarationItemContext[] objectTypeDeclarationItem() {
			return GetRuleContexts<ObjectTypeDeclarationItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeDeclarationItemContext objectTypeDeclarationItem(int i) {
			return GetRuleContext<ObjectTypeDeclarationItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ObjectTypeDeclarationItemsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeDeclarationItems; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectTypeDeclarationItems(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectTypeDeclarationItems(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeDeclarationItemsContext objectTypeDeclarationItems() {
		ObjectTypeDeclarationItemsContext _localctx = new ObjectTypeDeclarationItemsContext(Context, State);
		EnterRule(_localctx, 1670, RULE_objectTypeDeclarationItems);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7623;
			Match(LPAREN);
			State = 7624;
			objectTypeDeclarationItem();
			State = 7629;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 7625;
				Match(COMMA);
				State = 7626;
				objectTypeDeclarationItem();
				}
				}
				State = 7631;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 7632;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeDeclarationItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeRoutineContext objectTypeRoutine() {
			return GetRuleContext<ObjectTypeRoutineContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeAttributeDeclarationContext objectTypeAttributeDeclaration() {
			return GetRuleContext<ObjectTypeAttributeDeclarationContext>(0);
		}
		public ObjectTypeDeclarationItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeDeclarationItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectTypeDeclarationItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectTypeDeclarationItem(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeDeclarationItemContext objectTypeDeclarationItem() {
		ObjectTypeDeclarationItemContext _localctx = new ObjectTypeDeclarationItemContext(Context, State);
		EnterRule(_localctx, 1672, RULE_objectTypeDeclarationItem);
		try {
			State = 7636;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,890,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7634;
				objectTypeRoutine();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7635;
				objectTypeAttributeDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeAttributeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public ObjectTypeAttributeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeAttributeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectTypeAttributeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectTypeAttributeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeAttributeDeclarationContext objectTypeAttributeDeclaration() {
		ObjectTypeAttributeDeclarationContext _localctx = new ObjectTypeAttributeDeclarationContext(Context, State);
		EnterRule(_localctx, 1674, RULE_objectTypeAttributeDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7638;
			simpleIdentifier();
			State = 7639;
			typeReference();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarrayTypeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
			return GetRuleContext<RoutineBodyAsIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayTypeDeclarationContext varrayTypeDeclaration() {
			return GetRuleContext<VarrayTypeDeclarationContext>(0);
		}
		public VarrayTypeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varrayTypeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterVarrayTypeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitVarrayTypeStatement(this);
		}
	}

	[RuleVersion(0)]
	public VarrayTypeStatementContext varrayTypeStatement() {
		VarrayTypeStatementContext _localctx = new VarrayTypeStatementContext(Context, State);
		EnterRule(_localctx, 1676, RULE_varrayTypeStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7641;
			routineBodyAsIsClause();
			State = 7642;
			varrayTypeDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NestedTableTypeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
			return GetRuleContext<RoutineBodyAsIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableTypeDeclarationContext tableTypeDeclaration() {
			return GetRuleContext<TableTypeDeclarationContext>(0);
		}
		public NestedTableTypeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nestedTableTypeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterNestedTableTypeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitNestedTableTypeStatement(this);
		}
	}

	[RuleVersion(0)]
	public NestedTableTypeStatementContext nestedTableTypeStatement() {
		NestedTableTypeStatementContext _localctx = new NestedTableTypeStatementContext(Context, State);
		EnterRule(_localctx, 1678, RULE_nestedTableTypeStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7644;
			routineBodyAsIsClause();
			State = 7645;
			tableTypeDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OidClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OID() { return GetToken(OracleAntlrParser.OID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharacterStringLiteralContext characterStringLiteral() {
			return GetRuleContext<CharacterStringLiteralContext>(0);
		}
		public OidClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_oidClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterOidClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitOidClause(this);
		}
	}

	[RuleVersion(0)]
	public OidClauseContext oidClause() {
		OidClauseContext _localctx = new OidClauseContext(Context, State);
		EnterRule(_localctx, 1680, RULE_oidClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7647;
			Match(OID);
			State = 7648;
			characterStringLiteral();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTypeBodyStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BODY() { return GetToken(OracleAntlrParser.BODY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
			return GetRuleContext<RoutineBodyAsIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeBodyDeclarationItemsContext objectTypeBodyDeclarationItems() {
			return GetRuleContext<ObjectTypeBodyDeclarationItemsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(OracleAntlrParser.END, 0); }
		public CreateTypeBodyStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTypeBodyStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateTypeBodyStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateTypeBodyStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateTypeBodyStatementContext createTypeBodyStatement() {
		CreateTypeBodyStatementContext _localctx = new CreateTypeBodyStatementContext(Context, State);
		EnterRule(_localctx, 1682, RULE_createTypeBodyStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7650;
			Match(TYPE);
			State = 7651;
			Match(BODY);
			State = 7652;
			plainIdentifier();
			State = 7653;
			routineBodyAsIsClause();
			State = 7654;
			objectTypeBodyDeclarationItems();
			State = 7655;
			Match(END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeBodyDeclarationItemsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeRoutineContext[] objectTypeRoutine() {
			return GetRuleContexts<ObjectTypeRoutineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeRoutineContext objectTypeRoutine(int i) {
			return GetRuleContext<ObjectTypeRoutineContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SEMI() { return GetTokens(OracleAntlrParser.SEMI); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI(int i) {
			return GetToken(OracleAntlrParser.SEMI, i);
		}
		public ObjectTypeBodyDeclarationItemsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeBodyDeclarationItems; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectTypeBodyDeclarationItems(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectTypeBodyDeclarationItems(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeBodyDeclarationItemsContext objectTypeBodyDeclarationItems() {
		ObjectTypeBodyDeclarationItemsContext _localctx = new ObjectTypeBodyDeclarationItemsContext(Context, State);
		EnterRule(_localctx, 1684, RULE_objectTypeBodyDeclarationItems);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7657;
			objectTypeRoutine();
			State = 7658;
			Match(SEMI);
			State = 7664;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==CONSTRUCTOR || _la==FINAL || _la==INSTANTIABLE || ((((_la - 282)) & ~0x3f) == 0 && ((1L << (_la - 282)) & ((1L << (MAP - 282)) | (1L << (MEMBER - 282)) | (1L << (NOT - 282)))) != 0) || _la==ORDER || _la==OVERRIDING || _la==STATIC) {
				{
				{
				State = 7659;
				objectTypeRoutine();
				State = 7660;
				Match(SEMI);
				}
				}
				State = 7666;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeRoutineContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeMemberStaticRoutineContext objectTypeMemberStaticRoutine() {
			return GetRuleContext<ObjectTypeMemberStaticRoutineContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeConstructorContext objectTypeConstructor() {
			return GetRuleContext<ObjectTypeConstructorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeMapOrderFunctionContext objectTypeMapOrderFunction() {
			return GetRuleContext<ObjectTypeMapOrderFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InheritanceClauseContext inheritanceClause() {
			return GetRuleContext<InheritanceClauseContext>(0);
		}
		public ObjectTypeRoutineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeRoutine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectTypeRoutine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectTypeRoutine(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeRoutineContext objectTypeRoutine() {
		ObjectTypeRoutineContext _localctx = new ObjectTypeRoutineContext(Context, State);
		EnterRule(_localctx, 1686, RULE_objectTypeRoutine);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7668;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FINAL || _la==INSTANTIABLE || _la==NOT || _la==OVERRIDING) {
				{
				State = 7667;
				inheritanceClause();
				}
			}

			State = 7673;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MEMBER:
			case STATIC:
				{
				State = 7670;
				objectTypeMemberStaticRoutine();
				}
				break;
			case CONSTRUCTOR:
				{
				State = 7671;
				objectTypeConstructor();
				}
				break;
			case MAP:
			case ORDER:
				{
				State = 7672;
				objectTypeMapOrderFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeMemberStaticRoutineContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEMBER() { return GetToken(OracleAntlrParser.MEMBER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATIC() { return GetToken(OracleAntlrParser.STATIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureStatementContext procedureStatement() {
			return GetRuleContext<ProcedureStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionStatementContext functionStatement() {
			return GetRuleContext<FunctionStatementContext>(0);
		}
		public ObjectTypeMemberStaticRoutineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeMemberStaticRoutine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectTypeMemberStaticRoutine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectTypeMemberStaticRoutine(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeMemberStaticRoutineContext objectTypeMemberStaticRoutine() {
		ObjectTypeMemberStaticRoutineContext _localctx = new ObjectTypeMemberStaticRoutineContext(Context, State);
		EnterRule(_localctx, 1688, RULE_objectTypeMemberStaticRoutine);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7675;
			_la = TokenStream.LA(1);
			if ( !(_la==MEMBER || _la==STATIC) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 7678;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PROCEDURE:
				{
				State = 7676;
				procedureStatement();
				}
				break;
			case FUNCTION:
				{
				State = 7677;
				functionStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeConstructorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstructorHeaderContext constructorHeader() {
			return GetRuleContext<ConstructorHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstructorReturnClauseContext constructorReturnClause() {
			return GetRuleContext<ConstructorReturnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureCallSpecClauseContext procedureCallSpecClause() {
			return GetRuleContext<ProcedureCallSpecClauseContext>(0);
		}
		public ObjectTypeConstructorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeConstructor; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectTypeConstructor(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectTypeConstructor(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeConstructorContext objectTypeConstructor() {
		ObjectTypeConstructorContext _localctx = new ObjectTypeConstructorContext(Context, State);
		EnterRule(_localctx, 1690, RULE_objectTypeConstructor);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7680;
			constructorHeader();
			State = 7681;
			constructorReturnClause();
			State = 7684;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
			case IS:
				{
				State = 7682;
				routineBody();
				}
				break;
			case LANGUAGE:
				{
				State = 7683;
				procedureCallSpecClause();
				}
				break;
			case RPAREN:
			case COMMA:
			case SEMI:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstructorHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRUCTOR() { return GetToken(OracleAntlrParser.CONSTRUCTOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTION() { return GetToken(OracleAntlrParser.FUNCTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public ConstructorHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constructorHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConstructorHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConstructorHeader(this);
		}
	}

	[RuleVersion(0)]
	public ConstructorHeaderContext constructorHeader() {
		ConstructorHeaderContext _localctx = new ConstructorHeaderContext(Context, State);
		EnterRule(_localctx, 1692, RULE_constructorHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7686;
			Match(CONSTRUCTOR);
			State = 7687;
			Match(FUNCTION);
			State = 7688;
			plainIdentifier();
			State = 7690;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 7689;
				argumentList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstructorReturnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(OracleAntlrParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SELF() { return GetToken(OracleAntlrParser.SELF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RESULT() { return GetToken(OracleAntlrParser.RESULT, 0); }
		public ConstructorReturnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constructorReturnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterConstructorReturnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitConstructorReturnClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstructorReturnClauseContext constructorReturnClause() {
		ConstructorReturnClauseContext _localctx = new ConstructorReturnClauseContext(Context, State);
		EnterRule(_localctx, 1694, RULE_constructorReturnClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7692;
			Match(RETURN);
			State = 7693;
			Match(SELF);
			State = 7694;
			Match(AS);
			State = 7695;
			Match(RESULT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeMapOrderFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEMBER() { return GetToken(OracleAntlrParser.MEMBER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionStatementContext functionStatement() {
			return GetRuleContext<FunctionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAP() { return GetToken(OracleAntlrParser.MAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDER() { return GetToken(OracleAntlrParser.ORDER, 0); }
		public ObjectTypeMapOrderFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeMapOrderFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterObjectTypeMapOrderFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitObjectTypeMapOrderFunction(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeMapOrderFunctionContext objectTypeMapOrderFunction() {
		ObjectTypeMapOrderFunctionContext _localctx = new ObjectTypeMapOrderFunctionContext(Context, State);
		EnterRule(_localctx, 1696, RULE_objectTypeMapOrderFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7697;
			_la = TokenStream.LA(1);
			if ( !(_la==MAP || _la==ORDER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 7698;
			Match(MEMBER);
			State = 7699;
			functionStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InheritanceClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVERRIDING() { return GetToken(OracleAntlrParser.OVERRIDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FINAL() { return GetToken(OracleAntlrParser.FINAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSTANTIABLE() { return GetToken(OracleAntlrParser.INSTANTIABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public InheritanceClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inheritanceClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterInheritanceClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitInheritanceClause(this);
		}
	}

	[RuleVersion(0)]
	public InheritanceClauseContext inheritanceClause() {
		InheritanceClauseContext _localctx = new InheritanceClauseContext(Context, State);
		EnterRule(_localctx, 1698, RULE_inheritanceClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7702;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 7701;
				Match(NOT);
				}
			}

			State = 7704;
			_la = TokenStream.LA(1);
			if ( !(_la==FINAL || _la==INSTANTIABLE || _la==OVERRIDING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSynonymStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SYNONYM() { return GetToken(OracleAntlrParser.SYNONYM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainRemoteIdentifierContext plainRemoteIdentifier() {
			return GetRuleContext<PlainRemoteIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PUBLIC() { return GetToken(OracleAntlrParser.PUBLIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CreateSynonymSharingClauseContext createSynonymSharingClause() {
			return GetRuleContext<CreateSynonymSharingClauseContext>(0);
		}
		public CreateSynonymStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSynonymStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateSynonymStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateSynonymStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateSynonymStatementContext createSynonymStatement() {
		CreateSynonymStatementContext _localctx = new CreateSynonymStatementContext(Context, State);
		EnterRule(_localctx, 1700, RULE_createSynonymStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7707;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PUBLIC) {
				{
				State = 7706;
				Match(PUBLIC);
				}
			}

			State = 7709;
			Match(SYNONYM);
			State = 7710;
			plainIdentifier();
			State = 7712;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SHARING) {
				{
				State = 7711;
				createSynonymSharingClause();
				}
			}

			State = 7714;
			Match(FOR);
			State = 7715;
			plainRemoteIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSynonymSharingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARING() { return GetToken(OracleAntlrParser.SHARING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode METADATA() { return GetToken(OracleAntlrParser.METADATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(OracleAntlrParser.NONE, 0); }
		public CreateSynonymSharingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSynonymSharingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.EnterCreateSynonymSharingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrListener typedListener = listener as IOracleAntlrListener;
			if (typedListener != null) typedListener.ExitCreateSynonymSharingClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateSynonymSharingClauseContext createSynonymSharingClause() {
		CreateSynonymSharingClauseContext _localctx = new CreateSynonymSharingClauseContext(Context, State);
		EnterRule(_localctx, 1702, RULE_createSynonymSharingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7717;
			Match(SHARING);
			State = 7718;
			Match(EQUAL_SIGN);
			State = 7719;
			_la = TokenStream.LA(1);
			if ( !(_la==METADATA || _la==NONE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 15: return plSqlStatementBatch_sempred((PlSqlStatementBatchContext)_localctx, predIndex);
		case 559: return fromClauseItem_sempred((FromClauseItemContext)_localctx, predIndex);
		}
		return true;
	}
	private bool plSqlStatementBatch_sempred(PlSqlStatementBatchContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return IsSqlStatement();
		}
		return true;
	}
	private bool fromClauseItem_sempred(FromClauseItemContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return IsAliasIdentifier();
		}
		return true;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '\x26B', '\x1E2C', '\x4', '\x2', '\t', '\x2', '\x4', 
		'\x3', '\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', 
		'\x4', '\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', 
		'\b', '\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', 
		'\v', '\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', 
		'\t', '\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4', 
		'\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t', 
		'\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x4', 
		'\x16', '\t', '\x16', '\x4', '\x17', '\t', '\x17', '\x4', '\x18', '\t', 
		'\x18', '\x4', '\x19', '\t', '\x19', '\x4', '\x1A', '\t', '\x1A', '\x4', 
		'\x1B', '\t', '\x1B', '\x4', '\x1C', '\t', '\x1C', '\x4', '\x1D', '\t', 
		'\x1D', '\x4', '\x1E', '\t', '\x1E', '\x4', '\x1F', '\t', '\x1F', '\x4', 
		' ', '\t', ' ', '\x4', '!', '\t', '!', '\x4', '\"', '\t', '\"', '\x4', 
		'#', '\t', '#', '\x4', '$', '\t', '$', '\x4', '%', '\t', '%', '\x4', '&', 
		'\t', '&', '\x4', '\'', '\t', '\'', '\x4', '(', '\t', '(', '\x4', ')', 
		'\t', ')', '\x4', '*', '\t', '*', '\x4', '+', '\t', '+', '\x4', ',', '\t', 
		',', '\x4', '-', '\t', '-', '\x4', '.', '\t', '.', '\x4', '/', '\t', '/', 
		'\x4', '\x30', '\t', '\x30', '\x4', '\x31', '\t', '\x31', '\x4', '\x32', 
		'\t', '\x32', '\x4', '\x33', '\t', '\x33', '\x4', '\x34', '\t', '\x34', 
		'\x4', '\x35', '\t', '\x35', '\x4', '\x36', '\t', '\x36', '\x4', '\x37', 
		'\t', '\x37', '\x4', '\x38', '\t', '\x38', '\x4', '\x39', '\t', '\x39', 
		'\x4', ':', '\t', ':', '\x4', ';', '\t', ';', '\x4', '<', '\t', '<', '\x4', 
		'=', '\t', '=', '\x4', '>', '\t', '>', '\x4', '?', '\t', '?', '\x4', '@', 
		'\t', '@', '\x4', '\x41', '\t', '\x41', '\x4', '\x42', '\t', '\x42', '\x4', 
		'\x43', '\t', '\x43', '\x4', '\x44', '\t', '\x44', '\x4', '\x45', '\t', 
		'\x45', '\x4', '\x46', '\t', '\x46', '\x4', 'G', '\t', 'G', '\x4', 'H', 
		'\t', 'H', '\x4', 'I', '\t', 'I', '\x4', 'J', '\t', 'J', '\x4', 'K', '\t', 
		'K', '\x4', 'L', '\t', 'L', '\x4', 'M', '\t', 'M', '\x4', 'N', '\t', 'N', 
		'\x4', 'O', '\t', 'O', '\x4', 'P', '\t', 'P', '\x4', 'Q', '\t', 'Q', '\x4', 
		'R', '\t', 'R', '\x4', 'S', '\t', 'S', '\x4', 'T', '\t', 'T', '\x4', 'U', 
		'\t', 'U', '\x4', 'V', '\t', 'V', '\x4', 'W', '\t', 'W', '\x4', 'X', '\t', 
		'X', '\x4', 'Y', '\t', 'Y', '\x4', 'Z', '\t', 'Z', '\x4', '[', '\t', '[', 
		'\x4', '\\', '\t', '\\', '\x4', ']', '\t', ']', '\x4', '^', '\t', '^', 
		'\x4', '_', '\t', '_', '\x4', '`', '\t', '`', '\x4', '\x61', '\t', '\x61', 
		'\x4', '\x62', '\t', '\x62', '\x4', '\x63', '\t', '\x63', '\x4', '\x64', 
		'\t', '\x64', '\x4', '\x65', '\t', '\x65', '\x4', '\x66', '\t', '\x66', 
		'\x4', 'g', '\t', 'g', '\x4', 'h', '\t', 'h', '\x4', 'i', '\t', 'i', '\x4', 
		'j', '\t', 'j', '\x4', 'k', '\t', 'k', '\x4', 'l', '\t', 'l', '\x4', 'm', 
		'\t', 'm', '\x4', 'n', '\t', 'n', '\x4', 'o', '\t', 'o', '\x4', 'p', '\t', 
		'p', '\x4', 'q', '\t', 'q', '\x4', 'r', '\t', 'r', '\x4', 's', '\t', 's', 
		'\x4', 't', '\t', 't', '\x4', 'u', '\t', 'u', '\x4', 'v', '\t', 'v', '\x4', 
		'w', '\t', 'w', '\x4', 'x', '\t', 'x', '\x4', 'y', '\t', 'y', '\x4', 'z', 
		'\t', 'z', '\x4', '{', '\t', '{', '\x4', '|', '\t', '|', '\x4', '}', '\t', 
		'}', '\x4', '~', '\t', '~', '\x4', '\x7F', '\t', '\x7F', '\x4', '\x80', 
		'\t', '\x80', '\x4', '\x81', '\t', '\x81', '\x4', '\x82', '\t', '\x82', 
		'\x4', '\x83', '\t', '\x83', '\x4', '\x84', '\t', '\x84', '\x4', '\x85', 
		'\t', '\x85', '\x4', '\x86', '\t', '\x86', '\x4', '\x87', '\t', '\x87', 
		'\x4', '\x88', '\t', '\x88', '\x4', '\x89', '\t', '\x89', '\x4', '\x8A', 
		'\t', '\x8A', '\x4', '\x8B', '\t', '\x8B', '\x4', '\x8C', '\t', '\x8C', 
		'\x4', '\x8D', '\t', '\x8D', '\x4', '\x8E', '\t', '\x8E', '\x4', '\x8F', 
		'\t', '\x8F', '\x4', '\x90', '\t', '\x90', '\x4', '\x91', '\t', '\x91', 
		'\x4', '\x92', '\t', '\x92', '\x4', '\x93', '\t', '\x93', '\x4', '\x94', 
		'\t', '\x94', '\x4', '\x95', '\t', '\x95', '\x4', '\x96', '\t', '\x96', 
		'\x4', '\x97', '\t', '\x97', '\x4', '\x98', '\t', '\x98', '\x4', '\x99', 
		'\t', '\x99', '\x4', '\x9A', '\t', '\x9A', '\x4', '\x9B', '\t', '\x9B', 
		'\x4', '\x9C', '\t', '\x9C', '\x4', '\x9D', '\t', '\x9D', '\x4', '\x9E', 
		'\t', '\x9E', '\x4', '\x9F', '\t', '\x9F', '\x4', '\xA0', '\t', '\xA0', 
		'\x4', '\xA1', '\t', '\xA1', '\x4', '\xA2', '\t', '\xA2', '\x4', '\xA3', 
		'\t', '\xA3', '\x4', '\xA4', '\t', '\xA4', '\x4', '\xA5', '\t', '\xA5', 
		'\x4', '\xA6', '\t', '\xA6', '\x4', '\xA7', '\t', '\xA7', '\x4', '\xA8', 
		'\t', '\xA8', '\x4', '\xA9', '\t', '\xA9', '\x4', '\xAA', '\t', '\xAA', 
		'\x4', '\xAB', '\t', '\xAB', '\x4', '\xAC', '\t', '\xAC', '\x4', '\xAD', 
		'\t', '\xAD', '\x4', '\xAE', '\t', '\xAE', '\x4', '\xAF', '\t', '\xAF', 
		'\x4', '\xB0', '\t', '\xB0', '\x4', '\xB1', '\t', '\xB1', '\x4', '\xB2', 
		'\t', '\xB2', '\x4', '\xB3', '\t', '\xB3', '\x4', '\xB4', '\t', '\xB4', 
		'\x4', '\xB5', '\t', '\xB5', '\x4', '\xB6', '\t', '\xB6', '\x4', '\xB7', 
		'\t', '\xB7', '\x4', '\xB8', '\t', '\xB8', '\x4', '\xB9', '\t', '\xB9', 
		'\x4', '\xBA', '\t', '\xBA', '\x4', '\xBB', '\t', '\xBB', '\x4', '\xBC', 
		'\t', '\xBC', '\x4', '\xBD', '\t', '\xBD', '\x4', '\xBE', '\t', '\xBE', 
		'\x4', '\xBF', '\t', '\xBF', '\x4', '\xC0', '\t', '\xC0', '\x4', '\xC1', 
		'\t', '\xC1', '\x4', '\xC2', '\t', '\xC2', '\x4', '\xC3', '\t', '\xC3', 
		'\x4', '\xC4', '\t', '\xC4', '\x4', '\xC5', '\t', '\xC5', '\x4', '\xC6', 
		'\t', '\xC6', '\x4', '\xC7', '\t', '\xC7', '\x4', '\xC8', '\t', '\xC8', 
		'\x4', '\xC9', '\t', '\xC9', '\x4', '\xCA', '\t', '\xCA', '\x4', '\xCB', 
		'\t', '\xCB', '\x4', '\xCC', '\t', '\xCC', '\x4', '\xCD', '\t', '\xCD', 
		'\x4', '\xCE', '\t', '\xCE', '\x4', '\xCF', '\t', '\xCF', '\x4', '\xD0', 
		'\t', '\xD0', '\x4', '\xD1', '\t', '\xD1', '\x4', '\xD2', '\t', '\xD2', 
		'\x4', '\xD3', '\t', '\xD3', '\x4', '\xD4', '\t', '\xD4', '\x4', '\xD5', 
		'\t', '\xD5', '\x4', '\xD6', '\t', '\xD6', '\x4', '\xD7', '\t', '\xD7', 
		'\x4', '\xD8', '\t', '\xD8', '\x4', '\xD9', '\t', '\xD9', '\x4', '\xDA', 
		'\t', '\xDA', '\x4', '\xDB', '\t', '\xDB', '\x4', '\xDC', '\t', '\xDC', 
		'\x4', '\xDD', '\t', '\xDD', '\x4', '\xDE', '\t', '\xDE', '\x4', '\xDF', 
		'\t', '\xDF', '\x4', '\xE0', '\t', '\xE0', '\x4', '\xE1', '\t', '\xE1', 
		'\x4', '\xE2', '\t', '\xE2', '\x4', '\xE3', '\t', '\xE3', '\x4', '\xE4', 
		'\t', '\xE4', '\x4', '\xE5', '\t', '\xE5', '\x4', '\xE6', '\t', '\xE6', 
		'\x4', '\xE7', '\t', '\xE7', '\x4', '\xE8', '\t', '\xE8', '\x4', '\xE9', 
		'\t', '\xE9', '\x4', '\xEA', '\t', '\xEA', '\x4', '\xEB', '\t', '\xEB', 
		'\x4', '\xEC', '\t', '\xEC', '\x4', '\xED', '\t', '\xED', '\x4', '\xEE', 
		'\t', '\xEE', '\x4', '\xEF', '\t', '\xEF', '\x4', '\xF0', '\t', '\xF0', 
		'\x4', '\xF1', '\t', '\xF1', '\x4', '\xF2', '\t', '\xF2', '\x4', '\xF3', 
		'\t', '\xF3', '\x4', '\xF4', '\t', '\xF4', '\x4', '\xF5', '\t', '\xF5', 
		'\x4', '\xF6', '\t', '\xF6', '\x4', '\xF7', '\t', '\xF7', '\x4', '\xF8', 
		'\t', '\xF8', '\x4', '\xF9', '\t', '\xF9', '\x4', '\xFA', '\t', '\xFA', 
		'\x4', '\xFB', '\t', '\xFB', '\x4', '\xFC', '\t', '\xFC', '\x4', '\xFD', 
		'\t', '\xFD', '\x4', '\xFE', '\t', '\xFE', '\x4', '\xFF', '\t', '\xFF', 
		'\x4', '\x100', '\t', '\x100', '\x4', '\x101', '\t', '\x101', '\x4', '\x102', 
		'\t', '\x102', '\x4', '\x103', '\t', '\x103', '\x4', '\x104', '\t', '\x104', 
		'\x4', '\x105', '\t', '\x105', '\x4', '\x106', '\t', '\x106', '\x4', '\x107', 
		'\t', '\x107', '\x4', '\x108', '\t', '\x108', '\x4', '\x109', '\t', '\x109', 
		'\x4', '\x10A', '\t', '\x10A', '\x4', '\x10B', '\t', '\x10B', '\x4', '\x10C', 
		'\t', '\x10C', '\x4', '\x10D', '\t', '\x10D', '\x4', '\x10E', '\t', '\x10E', 
		'\x4', '\x10F', '\t', '\x10F', '\x4', '\x110', '\t', '\x110', '\x4', '\x111', 
		'\t', '\x111', '\x4', '\x112', '\t', '\x112', '\x4', '\x113', '\t', '\x113', 
		'\x4', '\x114', '\t', '\x114', '\x4', '\x115', '\t', '\x115', '\x4', '\x116', 
		'\t', '\x116', '\x4', '\x117', '\t', '\x117', '\x4', '\x118', '\t', '\x118', 
		'\x4', '\x119', '\t', '\x119', '\x4', '\x11A', '\t', '\x11A', '\x4', '\x11B', 
		'\t', '\x11B', '\x4', '\x11C', '\t', '\x11C', '\x4', '\x11D', '\t', '\x11D', 
		'\x4', '\x11E', '\t', '\x11E', '\x4', '\x11F', '\t', '\x11F', '\x4', '\x120', 
		'\t', '\x120', '\x4', '\x121', '\t', '\x121', '\x4', '\x122', '\t', '\x122', 
		'\x4', '\x123', '\t', '\x123', '\x4', '\x124', '\t', '\x124', '\x4', '\x125', 
		'\t', '\x125', '\x4', '\x126', '\t', '\x126', '\x4', '\x127', '\t', '\x127', 
		'\x4', '\x128', '\t', '\x128', '\x4', '\x129', '\t', '\x129', '\x4', '\x12A', 
		'\t', '\x12A', '\x4', '\x12B', '\t', '\x12B', '\x4', '\x12C', '\t', '\x12C', 
		'\x4', '\x12D', '\t', '\x12D', '\x4', '\x12E', '\t', '\x12E', '\x4', '\x12F', 
		'\t', '\x12F', '\x4', '\x130', '\t', '\x130', '\x4', '\x131', '\t', '\x131', 
		'\x4', '\x132', '\t', '\x132', '\x4', '\x133', '\t', '\x133', '\x4', '\x134', 
		'\t', '\x134', '\x4', '\x135', '\t', '\x135', '\x4', '\x136', '\t', '\x136', 
		'\x4', '\x137', '\t', '\x137', '\x4', '\x138', '\t', '\x138', '\x4', '\x139', 
		'\t', '\x139', '\x4', '\x13A', '\t', '\x13A', '\x4', '\x13B', '\t', '\x13B', 
		'\x4', '\x13C', '\t', '\x13C', '\x4', '\x13D', '\t', '\x13D', '\x4', '\x13E', 
		'\t', '\x13E', '\x4', '\x13F', '\t', '\x13F', '\x4', '\x140', '\t', '\x140', 
		'\x4', '\x141', '\t', '\x141', '\x4', '\x142', '\t', '\x142', '\x4', '\x143', 
		'\t', '\x143', '\x4', '\x144', '\t', '\x144', '\x4', '\x145', '\t', '\x145', 
		'\x4', '\x146', '\t', '\x146', '\x4', '\x147', '\t', '\x147', '\x4', '\x148', 
		'\t', '\x148', '\x4', '\x149', '\t', '\x149', '\x4', '\x14A', '\t', '\x14A', 
		'\x4', '\x14B', '\t', '\x14B', '\x4', '\x14C', '\t', '\x14C', '\x4', '\x14D', 
		'\t', '\x14D', '\x4', '\x14E', '\t', '\x14E', '\x4', '\x14F', '\t', '\x14F', 
		'\x4', '\x150', '\t', '\x150', '\x4', '\x151', '\t', '\x151', '\x4', '\x152', 
		'\t', '\x152', '\x4', '\x153', '\t', '\x153', '\x4', '\x154', '\t', '\x154', 
		'\x4', '\x155', '\t', '\x155', '\x4', '\x156', '\t', '\x156', '\x4', '\x157', 
		'\t', '\x157', '\x4', '\x158', '\t', '\x158', '\x4', '\x159', '\t', '\x159', 
		'\x4', '\x15A', '\t', '\x15A', '\x4', '\x15B', '\t', '\x15B', '\x4', '\x15C', 
		'\t', '\x15C', '\x4', '\x15D', '\t', '\x15D', '\x4', '\x15E', '\t', '\x15E', 
		'\x4', '\x15F', '\t', '\x15F', '\x4', '\x160', '\t', '\x160', '\x4', '\x161', 
		'\t', '\x161', '\x4', '\x162', '\t', '\x162', '\x4', '\x163', '\t', '\x163', 
		'\x4', '\x164', '\t', '\x164', '\x4', '\x165', '\t', '\x165', '\x4', '\x166', 
		'\t', '\x166', '\x4', '\x167', '\t', '\x167', '\x4', '\x168', '\t', '\x168', 
		'\x4', '\x169', '\t', '\x169', '\x4', '\x16A', '\t', '\x16A', '\x4', '\x16B', 
		'\t', '\x16B', '\x4', '\x16C', '\t', '\x16C', '\x4', '\x16D', '\t', '\x16D', 
		'\x4', '\x16E', '\t', '\x16E', '\x4', '\x16F', '\t', '\x16F', '\x4', '\x170', 
		'\t', '\x170', '\x4', '\x171', '\t', '\x171', '\x4', '\x172', '\t', '\x172', 
		'\x4', '\x173', '\t', '\x173', '\x4', '\x174', '\t', '\x174', '\x4', '\x175', 
		'\t', '\x175', '\x4', '\x176', '\t', '\x176', '\x4', '\x177', '\t', '\x177', 
		'\x4', '\x178', '\t', '\x178', '\x4', '\x179', '\t', '\x179', '\x4', '\x17A', 
		'\t', '\x17A', '\x4', '\x17B', '\t', '\x17B', '\x4', '\x17C', '\t', '\x17C', 
		'\x4', '\x17D', '\t', '\x17D', '\x4', '\x17E', '\t', '\x17E', '\x4', '\x17F', 
		'\t', '\x17F', '\x4', '\x180', '\t', '\x180', '\x4', '\x181', '\t', '\x181', 
		'\x4', '\x182', '\t', '\x182', '\x4', '\x183', '\t', '\x183', '\x4', '\x184', 
		'\t', '\x184', '\x4', '\x185', '\t', '\x185', '\x4', '\x186', '\t', '\x186', 
		'\x4', '\x187', '\t', '\x187', '\x4', '\x188', '\t', '\x188', '\x4', '\x189', 
		'\t', '\x189', '\x4', '\x18A', '\t', '\x18A', '\x4', '\x18B', '\t', '\x18B', 
		'\x4', '\x18C', '\t', '\x18C', '\x4', '\x18D', '\t', '\x18D', '\x4', '\x18E', 
		'\t', '\x18E', '\x4', '\x18F', '\t', '\x18F', '\x4', '\x190', '\t', '\x190', 
		'\x4', '\x191', '\t', '\x191', '\x4', '\x192', '\t', '\x192', '\x4', '\x193', 
		'\t', '\x193', '\x4', '\x194', '\t', '\x194', '\x4', '\x195', '\t', '\x195', 
		'\x4', '\x196', '\t', '\x196', '\x4', '\x197', '\t', '\x197', '\x4', '\x198', 
		'\t', '\x198', '\x4', '\x199', '\t', '\x199', '\x4', '\x19A', '\t', '\x19A', 
		'\x4', '\x19B', '\t', '\x19B', '\x4', '\x19C', '\t', '\x19C', '\x4', '\x19D', 
		'\t', '\x19D', '\x4', '\x19E', '\t', '\x19E', '\x4', '\x19F', '\t', '\x19F', 
		'\x4', '\x1A0', '\t', '\x1A0', '\x4', '\x1A1', '\t', '\x1A1', '\x4', '\x1A2', 
		'\t', '\x1A2', '\x4', '\x1A3', '\t', '\x1A3', '\x4', '\x1A4', '\t', '\x1A4', 
		'\x4', '\x1A5', '\t', '\x1A5', '\x4', '\x1A6', '\t', '\x1A6', '\x4', '\x1A7', 
		'\t', '\x1A7', '\x4', '\x1A8', '\t', '\x1A8', '\x4', '\x1A9', '\t', '\x1A9', 
		'\x4', '\x1AA', '\t', '\x1AA', '\x4', '\x1AB', '\t', '\x1AB', '\x4', '\x1AC', 
		'\t', '\x1AC', '\x4', '\x1AD', '\t', '\x1AD', '\x4', '\x1AE', '\t', '\x1AE', 
		'\x4', '\x1AF', '\t', '\x1AF', '\x4', '\x1B0', '\t', '\x1B0', '\x4', '\x1B1', 
		'\t', '\x1B1', '\x4', '\x1B2', '\t', '\x1B2', '\x4', '\x1B3', '\t', '\x1B3', 
		'\x4', '\x1B4', '\t', '\x1B4', '\x4', '\x1B5', '\t', '\x1B5', '\x4', '\x1B6', 
		'\t', '\x1B6', '\x4', '\x1B7', '\t', '\x1B7', '\x4', '\x1B8', '\t', '\x1B8', 
		'\x4', '\x1B9', '\t', '\x1B9', '\x4', '\x1BA', '\t', '\x1BA', '\x4', '\x1BB', 
		'\t', '\x1BB', '\x4', '\x1BC', '\t', '\x1BC', '\x4', '\x1BD', '\t', '\x1BD', 
		'\x4', '\x1BE', '\t', '\x1BE', '\x4', '\x1BF', '\t', '\x1BF', '\x4', '\x1C0', 
		'\t', '\x1C0', '\x4', '\x1C1', '\t', '\x1C1', '\x4', '\x1C2', '\t', '\x1C2', 
		'\x4', '\x1C3', '\t', '\x1C3', '\x4', '\x1C4', '\t', '\x1C4', '\x4', '\x1C5', 
		'\t', '\x1C5', '\x4', '\x1C6', '\t', '\x1C6', '\x4', '\x1C7', '\t', '\x1C7', 
		'\x4', '\x1C8', '\t', '\x1C8', '\x4', '\x1C9', '\t', '\x1C9', '\x4', '\x1CA', 
		'\t', '\x1CA', '\x4', '\x1CB', '\t', '\x1CB', '\x4', '\x1CC', '\t', '\x1CC', 
		'\x4', '\x1CD', '\t', '\x1CD', '\x4', '\x1CE', '\t', '\x1CE', '\x4', '\x1CF', 
		'\t', '\x1CF', '\x4', '\x1D0', '\t', '\x1D0', '\x4', '\x1D1', '\t', '\x1D1', 
		'\x4', '\x1D2', '\t', '\x1D2', '\x4', '\x1D3', '\t', '\x1D3', '\x4', '\x1D4', 
		'\t', '\x1D4', '\x4', '\x1D5', '\t', '\x1D5', '\x4', '\x1D6', '\t', '\x1D6', 
		'\x4', '\x1D7', '\t', '\x1D7', '\x4', '\x1D8', '\t', '\x1D8', '\x4', '\x1D9', 
		'\t', '\x1D9', '\x4', '\x1DA', '\t', '\x1DA', '\x4', '\x1DB', '\t', '\x1DB', 
		'\x4', '\x1DC', '\t', '\x1DC', '\x4', '\x1DD', '\t', '\x1DD', '\x4', '\x1DE', 
		'\t', '\x1DE', '\x4', '\x1DF', '\t', '\x1DF', '\x4', '\x1E0', '\t', '\x1E0', 
		'\x4', '\x1E1', '\t', '\x1E1', '\x4', '\x1E2', '\t', '\x1E2', '\x4', '\x1E3', 
		'\t', '\x1E3', '\x4', '\x1E4', '\t', '\x1E4', '\x4', '\x1E5', '\t', '\x1E5', 
		'\x4', '\x1E6', '\t', '\x1E6', '\x4', '\x1E7', '\t', '\x1E7', '\x4', '\x1E8', 
		'\t', '\x1E8', '\x4', '\x1E9', '\t', '\x1E9', '\x4', '\x1EA', '\t', '\x1EA', 
		'\x4', '\x1EB', '\t', '\x1EB', '\x4', '\x1EC', '\t', '\x1EC', '\x4', '\x1ED', 
		'\t', '\x1ED', '\x4', '\x1EE', '\t', '\x1EE', '\x4', '\x1EF', '\t', '\x1EF', 
		'\x4', '\x1F0', '\t', '\x1F0', '\x4', '\x1F1', '\t', '\x1F1', '\x4', '\x1F2', 
		'\t', '\x1F2', '\x4', '\x1F3', '\t', '\x1F3', '\x4', '\x1F4', '\t', '\x1F4', 
		'\x4', '\x1F5', '\t', '\x1F5', '\x4', '\x1F6', '\t', '\x1F6', '\x4', '\x1F7', 
		'\t', '\x1F7', '\x4', '\x1F8', '\t', '\x1F8', '\x4', '\x1F9', '\t', '\x1F9', 
		'\x4', '\x1FA', '\t', '\x1FA', '\x4', '\x1FB', '\t', '\x1FB', '\x4', '\x1FC', 
		'\t', '\x1FC', '\x4', '\x1FD', '\t', '\x1FD', '\x4', '\x1FE', '\t', '\x1FE', 
		'\x4', '\x1FF', '\t', '\x1FF', '\x4', '\x200', '\t', '\x200', '\x4', '\x201', 
		'\t', '\x201', '\x4', '\x202', '\t', '\x202', '\x4', '\x203', '\t', '\x203', 
		'\x4', '\x204', '\t', '\x204', '\x4', '\x205', '\t', '\x205', '\x4', '\x206', 
		'\t', '\x206', '\x4', '\x207', '\t', '\x207', '\x4', '\x208', '\t', '\x208', 
		'\x4', '\x209', '\t', '\x209', '\x4', '\x20A', '\t', '\x20A', '\x4', '\x20B', 
		'\t', '\x20B', '\x4', '\x20C', '\t', '\x20C', '\x4', '\x20D', '\t', '\x20D', 
		'\x4', '\x20E', '\t', '\x20E', '\x4', '\x20F', '\t', '\x20F', '\x4', '\x210', 
		'\t', '\x210', '\x4', '\x211', '\t', '\x211', '\x4', '\x212', '\t', '\x212', 
		'\x4', '\x213', '\t', '\x213', '\x4', '\x214', '\t', '\x214', '\x4', '\x215', 
		'\t', '\x215', '\x4', '\x216', '\t', '\x216', '\x4', '\x217', '\t', '\x217', 
		'\x4', '\x218', '\t', '\x218', '\x4', '\x219', '\t', '\x219', '\x4', '\x21A', 
		'\t', '\x21A', '\x4', '\x21B', '\t', '\x21B', '\x4', '\x21C', '\t', '\x21C', 
		'\x4', '\x21D', '\t', '\x21D', '\x4', '\x21E', '\t', '\x21E', '\x4', '\x21F', 
		'\t', '\x21F', '\x4', '\x220', '\t', '\x220', '\x4', '\x221', '\t', '\x221', 
		'\x4', '\x222', '\t', '\x222', '\x4', '\x223', '\t', '\x223', '\x4', '\x224', 
		'\t', '\x224', '\x4', '\x225', '\t', '\x225', '\x4', '\x226', '\t', '\x226', 
		'\x4', '\x227', '\t', '\x227', '\x4', '\x228', '\t', '\x228', '\x4', '\x229', 
		'\t', '\x229', '\x4', '\x22A', '\t', '\x22A', '\x4', '\x22B', '\t', '\x22B', 
		'\x4', '\x22C', '\t', '\x22C', '\x4', '\x22D', '\t', '\x22D', '\x4', '\x22E', 
		'\t', '\x22E', '\x4', '\x22F', '\t', '\x22F', '\x4', '\x230', '\t', '\x230', 
		'\x4', '\x231', '\t', '\x231', '\x4', '\x232', '\t', '\x232', '\x4', '\x233', 
		'\t', '\x233', '\x4', '\x234', '\t', '\x234', '\x4', '\x235', '\t', '\x235', 
		'\x4', '\x236', '\t', '\x236', '\x4', '\x237', '\t', '\x237', '\x4', '\x238', 
		'\t', '\x238', '\x4', '\x239', '\t', '\x239', '\x4', '\x23A', '\t', '\x23A', 
		'\x4', '\x23B', '\t', '\x23B', '\x4', '\x23C', '\t', '\x23C', '\x4', '\x23D', 
		'\t', '\x23D', '\x4', '\x23E', '\t', '\x23E', '\x4', '\x23F', '\t', '\x23F', 
		'\x4', '\x240', '\t', '\x240', '\x4', '\x241', '\t', '\x241', '\x4', '\x242', 
		'\t', '\x242', '\x4', '\x243', '\t', '\x243', '\x4', '\x244', '\t', '\x244', 
		'\x4', '\x245', '\t', '\x245', '\x4', '\x246', '\t', '\x246', '\x4', '\x247', 
		'\t', '\x247', '\x4', '\x248', '\t', '\x248', '\x4', '\x249', '\t', '\x249', 
		'\x4', '\x24A', '\t', '\x24A', '\x4', '\x24B', '\t', '\x24B', '\x4', '\x24C', 
		'\t', '\x24C', '\x4', '\x24D', '\t', '\x24D', '\x4', '\x24E', '\t', '\x24E', 
		'\x4', '\x24F', '\t', '\x24F', '\x4', '\x250', '\t', '\x250', '\x4', '\x251', 
		'\t', '\x251', '\x4', '\x252', '\t', '\x252', '\x4', '\x253', '\t', '\x253', 
		'\x4', '\x254', '\t', '\x254', '\x4', '\x255', '\t', '\x255', '\x4', '\x256', 
		'\t', '\x256', '\x4', '\x257', '\t', '\x257', '\x4', '\x258', '\t', '\x258', 
		'\x4', '\x259', '\t', '\x259', '\x4', '\x25A', '\t', '\x25A', '\x4', '\x25B', 
		'\t', '\x25B', '\x4', '\x25C', '\t', '\x25C', '\x4', '\x25D', '\t', '\x25D', 
		'\x4', '\x25E', '\t', '\x25E', '\x4', '\x25F', '\t', '\x25F', '\x4', '\x260', 
		'\t', '\x260', '\x4', '\x261', '\t', '\x261', '\x4', '\x262', '\t', '\x262', 
		'\x4', '\x263', '\t', '\x263', '\x4', '\x264', '\t', '\x264', '\x4', '\x265', 
		'\t', '\x265', '\x4', '\x266', '\t', '\x266', '\x4', '\x267', '\t', '\x267', 
		'\x4', '\x268', '\t', '\x268', '\x4', '\x269', '\t', '\x269', '\x4', '\x26A', 
		'\t', '\x26A', '\x4', '\x26B', '\t', '\x26B', '\x4', '\x26C', '\t', '\x26C', 
		'\x4', '\x26D', '\t', '\x26D', '\x4', '\x26E', '\t', '\x26E', '\x4', '\x26F', 
		'\t', '\x26F', '\x4', '\x270', '\t', '\x270', '\x4', '\x271', '\t', '\x271', 
		'\x4', '\x272', '\t', '\x272', '\x4', '\x273', '\t', '\x273', '\x4', '\x274', 
		'\t', '\x274', '\x4', '\x275', '\t', '\x275', '\x4', '\x276', '\t', '\x276', 
		'\x4', '\x277', '\t', '\x277', '\x4', '\x278', '\t', '\x278', '\x4', '\x279', 
		'\t', '\x279', '\x4', '\x27A', '\t', '\x27A', '\x4', '\x27B', '\t', '\x27B', 
		'\x4', '\x27C', '\t', '\x27C', '\x4', '\x27D', '\t', '\x27D', '\x4', '\x27E', 
		'\t', '\x27E', '\x4', '\x27F', '\t', '\x27F', '\x4', '\x280', '\t', '\x280', 
		'\x4', '\x281', '\t', '\x281', '\x4', '\x282', '\t', '\x282', '\x4', '\x283', 
		'\t', '\x283', '\x4', '\x284', '\t', '\x284', '\x4', '\x285', '\t', '\x285', 
		'\x4', '\x286', '\t', '\x286', '\x4', '\x287', '\t', '\x287', '\x4', '\x288', 
		'\t', '\x288', '\x4', '\x289', '\t', '\x289', '\x4', '\x28A', '\t', '\x28A', 
		'\x4', '\x28B', '\t', '\x28B', '\x4', '\x28C', '\t', '\x28C', '\x4', '\x28D', 
		'\t', '\x28D', '\x4', '\x28E', '\t', '\x28E', '\x4', '\x28F', '\t', '\x28F', 
		'\x4', '\x290', '\t', '\x290', '\x4', '\x291', '\t', '\x291', '\x4', '\x292', 
		'\t', '\x292', '\x4', '\x293', '\t', '\x293', '\x4', '\x294', '\t', '\x294', 
		'\x4', '\x295', '\t', '\x295', '\x4', '\x296', '\t', '\x296', '\x4', '\x297', 
		'\t', '\x297', '\x4', '\x298', '\t', '\x298', '\x4', '\x299', '\t', '\x299', 
		'\x4', '\x29A', '\t', '\x29A', '\x4', '\x29B', '\t', '\x29B', '\x4', '\x29C', 
		'\t', '\x29C', '\x4', '\x29D', '\t', '\x29D', '\x4', '\x29E', '\t', '\x29E', 
		'\x4', '\x29F', '\t', '\x29F', '\x4', '\x2A0', '\t', '\x2A0', '\x4', '\x2A1', 
		'\t', '\x2A1', '\x4', '\x2A2', '\t', '\x2A2', '\x4', '\x2A3', '\t', '\x2A3', 
		'\x4', '\x2A4', '\t', '\x2A4', '\x4', '\x2A5', '\t', '\x2A5', '\x4', '\x2A6', 
		'\t', '\x2A6', '\x4', '\x2A7', '\t', '\x2A7', '\x4', '\x2A8', '\t', '\x2A8', 
		'\x4', '\x2A9', '\t', '\x2A9', '\x4', '\x2AA', '\t', '\x2AA', '\x4', '\x2AB', 
		'\t', '\x2AB', '\x4', '\x2AC', '\t', '\x2AC', '\x4', '\x2AD', '\t', '\x2AD', 
		'\x4', '\x2AE', '\t', '\x2AE', '\x4', '\x2AF', '\t', '\x2AF', '\x4', '\x2B0', 
		'\t', '\x2B0', '\x4', '\x2B1', '\t', '\x2B1', '\x4', '\x2B2', '\t', '\x2B2', 
		'\x4', '\x2B3', '\t', '\x2B3', '\x4', '\x2B4', '\t', '\x2B4', '\x4', '\x2B5', 
		'\t', '\x2B5', '\x4', '\x2B6', '\t', '\x2B6', '\x4', '\x2B7', '\t', '\x2B7', 
		'\x4', '\x2B8', '\t', '\x2B8', '\x4', '\x2B9', '\t', '\x2B9', '\x4', '\x2BA', 
		'\t', '\x2BA', '\x4', '\x2BB', '\t', '\x2BB', '\x4', '\x2BC', '\t', '\x2BC', 
		'\x4', '\x2BD', '\t', '\x2BD', '\x4', '\x2BE', '\t', '\x2BE', '\x4', '\x2BF', 
		'\t', '\x2BF', '\x4', '\x2C0', '\t', '\x2C0', '\x4', '\x2C1', '\t', '\x2C1', 
		'\x4', '\x2C2', '\t', '\x2C2', '\x4', '\x2C3', '\t', '\x2C3', '\x4', '\x2C4', 
		'\t', '\x2C4', '\x4', '\x2C5', '\t', '\x2C5', '\x4', '\x2C6', '\t', '\x2C6', 
		'\x4', '\x2C7', '\t', '\x2C7', '\x4', '\x2C8', '\t', '\x2C8', '\x4', '\x2C9', 
		'\t', '\x2C9', '\x4', '\x2CA', '\t', '\x2CA', '\x4', '\x2CB', '\t', '\x2CB', 
		'\x4', '\x2CC', '\t', '\x2CC', '\x4', '\x2CD', '\t', '\x2CD', '\x4', '\x2CE', 
		'\t', '\x2CE', '\x4', '\x2CF', '\t', '\x2CF', '\x4', '\x2D0', '\t', '\x2D0', 
		'\x4', '\x2D1', '\t', '\x2D1', '\x4', '\x2D2', '\t', '\x2D2', '\x4', '\x2D3', 
		'\t', '\x2D3', '\x4', '\x2D4', '\t', '\x2D4', '\x4', '\x2D5', '\t', '\x2D5', 
		'\x4', '\x2D6', '\t', '\x2D6', '\x4', '\x2D7', '\t', '\x2D7', '\x4', '\x2D8', 
		'\t', '\x2D8', '\x4', '\x2D9', '\t', '\x2D9', '\x4', '\x2DA', '\t', '\x2DA', 
		'\x4', '\x2DB', '\t', '\x2DB', '\x4', '\x2DC', '\t', '\x2DC', '\x4', '\x2DD', 
		'\t', '\x2DD', '\x4', '\x2DE', '\t', '\x2DE', '\x4', '\x2DF', '\t', '\x2DF', 
		'\x4', '\x2E0', '\t', '\x2E0', '\x4', '\x2E1', '\t', '\x2E1', '\x4', '\x2E2', 
		'\t', '\x2E2', '\x4', '\x2E3', '\t', '\x2E3', '\x4', '\x2E4', '\t', '\x2E4', 
		'\x4', '\x2E5', '\t', '\x2E5', '\x4', '\x2E6', '\t', '\x2E6', '\x4', '\x2E7', 
		'\t', '\x2E7', '\x4', '\x2E8', '\t', '\x2E8', '\x4', '\x2E9', '\t', '\x2E9', 
		'\x4', '\x2EA', '\t', '\x2EA', '\x4', '\x2EB', '\t', '\x2EB', '\x4', '\x2EC', 
		'\t', '\x2EC', '\x4', '\x2ED', '\t', '\x2ED', '\x4', '\x2EE', '\t', '\x2EE', 
		'\x4', '\x2EF', '\t', '\x2EF', '\x4', '\x2F0', '\t', '\x2F0', '\x4', '\x2F1', 
		'\t', '\x2F1', '\x4', '\x2F2', '\t', '\x2F2', '\x4', '\x2F3', '\t', '\x2F3', 
		'\x4', '\x2F4', '\t', '\x2F4', '\x4', '\x2F5', '\t', '\x2F5', '\x4', '\x2F6', 
		'\t', '\x2F6', '\x4', '\x2F7', '\t', '\x2F7', '\x4', '\x2F8', '\t', '\x2F8', 
		'\x4', '\x2F9', '\t', '\x2F9', '\x4', '\x2FA', '\t', '\x2FA', '\x4', '\x2FB', 
		'\t', '\x2FB', '\x4', '\x2FC', '\t', '\x2FC', '\x4', '\x2FD', '\t', '\x2FD', 
		'\x4', '\x2FE', '\t', '\x2FE', '\x4', '\x2FF', '\t', '\x2FF', '\x4', '\x300', 
		'\t', '\x300', '\x4', '\x301', '\t', '\x301', '\x4', '\x302', '\t', '\x302', 
		'\x4', '\x303', '\t', '\x303', '\x4', '\x304', '\t', '\x304', '\x4', '\x305', 
		'\t', '\x305', '\x4', '\x306', '\t', '\x306', '\x4', '\x307', '\t', '\x307', 
		'\x4', '\x308', '\t', '\x308', '\x4', '\x309', '\t', '\x309', '\x4', '\x30A', 
		'\t', '\x30A', '\x4', '\x30B', '\t', '\x30B', '\x4', '\x30C', '\t', '\x30C', 
		'\x4', '\x30D', '\t', '\x30D', '\x4', '\x30E', '\t', '\x30E', '\x4', '\x30F', 
		'\t', '\x30F', '\x4', '\x310', '\t', '\x310', '\x4', '\x311', '\t', '\x311', 
		'\x4', '\x312', '\t', '\x312', '\x4', '\x313', '\t', '\x313', '\x4', '\x314', 
		'\t', '\x314', '\x4', '\x315', '\t', '\x315', '\x4', '\x316', '\t', '\x316', 
		'\x4', '\x317', '\t', '\x317', '\x4', '\x318', '\t', '\x318', '\x4', '\x319', 
		'\t', '\x319', '\x4', '\x31A', '\t', '\x31A', '\x4', '\x31B', '\t', '\x31B', 
		'\x4', '\x31C', '\t', '\x31C', '\x4', '\x31D', '\t', '\x31D', '\x4', '\x31E', 
		'\t', '\x31E', '\x4', '\x31F', '\t', '\x31F', '\x4', '\x320', '\t', '\x320', 
		'\x4', '\x321', '\t', '\x321', '\x4', '\x322', '\t', '\x322', '\x4', '\x323', 
		'\t', '\x323', '\x4', '\x324', '\t', '\x324', '\x4', '\x325', '\t', '\x325', 
		'\x4', '\x326', '\t', '\x326', '\x4', '\x327', '\t', '\x327', '\x4', '\x328', 
		'\t', '\x328', '\x4', '\x329', '\t', '\x329', '\x4', '\x32A', '\t', '\x32A', 
		'\x4', '\x32B', '\t', '\x32B', '\x4', '\x32C', '\t', '\x32C', '\x4', '\x32D', 
		'\t', '\x32D', '\x4', '\x32E', '\t', '\x32E', '\x4', '\x32F', '\t', '\x32F', 
		'\x4', '\x330', '\t', '\x330', '\x4', '\x331', '\t', '\x331', '\x4', '\x332', 
		'\t', '\x332', '\x4', '\x333', '\t', '\x333', '\x4', '\x334', '\t', '\x334', 
		'\x4', '\x335', '\t', '\x335', '\x4', '\x336', '\t', '\x336', '\x4', '\x337', 
		'\t', '\x337', '\x4', '\x338', '\t', '\x338', '\x4', '\x339', '\t', '\x339', 
		'\x4', '\x33A', '\t', '\x33A', '\x4', '\x33B', '\t', '\x33B', '\x4', '\x33C', 
		'\t', '\x33C', '\x4', '\x33D', '\t', '\x33D', '\x4', '\x33E', '\t', '\x33E', 
		'\x4', '\x33F', '\t', '\x33F', '\x4', '\x340', '\t', '\x340', '\x4', '\x341', 
		'\t', '\x341', '\x4', '\x342', '\t', '\x342', '\x4', '\x343', '\t', '\x343', 
		'\x4', '\x344', '\t', '\x344', '\x4', '\x345', '\t', '\x345', '\x4', '\x346', 
		'\t', '\x346', '\x4', '\x347', '\t', '\x347', '\x4', '\x348', '\t', '\x348', 
		'\x4', '\x349', '\t', '\x349', '\x4', '\x34A', '\t', '\x34A', '\x4', '\x34B', 
		'\t', '\x34B', '\x4', '\x34C', '\t', '\x34C', '\x4', '\x34D', '\t', '\x34D', 
		'\x4', '\x34E', '\t', '\x34E', '\x4', '\x34F', '\t', '\x34F', '\x4', '\x350', 
		'\t', '\x350', '\x4', '\x351', '\t', '\x351', '\x4', '\x352', '\t', '\x352', 
		'\x4', '\x353', '\t', '\x353', '\x4', '\x354', '\t', '\x354', '\x4', '\x355', 
		'\t', '\x355', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x3', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', 
		'\x3', '\x5', '\x3', '\x5', '\a', '\x5', '\x6B6', '\n', '\x5', '\f', '\x5', 
		'\xE', '\x5', '\x6B9', '\v', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', 
		'\x6', '\x3', '\x6', '\x5', '\x6', '\x6BF', '\n', '\x6', '\x3', '\x6', 
		'\x3', '\x6', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\b', '\x3', 
		'\b', '\x3', '\b', '\x3', '\t', '\a', '\t', '\x6CA', '\n', '\t', '\f', 
		'\t', '\xE', '\t', '\x6CD', '\v', '\t', '\x3', '\t', '\x3', '\t', '\x3', 
		'\n', '\x3', '\n', '\x3', '\n', '\x3', '\n', '\x3', '\n', '\x3', '\n', 
		'\x3', '\n', '\x3', '\n', '\x3', '\n', '\x5', '\n', '\x6DA', '\n', '\n', 
		'\x3', '\n', '\x5', '\n', '\x6DD', '\n', '\n', '\x3', '\v', '\x3', '\v', 
		'\x5', '\v', '\x6E1', '\n', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\v', 
		'\a', '\v', '\x6E6', '\n', '\v', '\f', '\v', '\xE', '\v', '\x6E9', '\v', 
		'\v', '\x3', '\v', '\x3', '\v', '\x3', '\f', '\x3', '\f', '\a', '\f', 
		'\x6EF', '\n', '\f', '\f', '\f', '\xE', '\f', '\x6F2', '\v', '\f', '\x3', 
		'\f', '\x3', '\f', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\xE', 
		'\x3', '\xE', '\x3', '\xE', '\a', '\xE', '\x6FC', '\n', '\xE', '\f', '\xE', 
		'\xE', '\xE', '\x6FF', '\v', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', 
		'\xF', '\x3', '\xF', '\x3', '\xF', '\x5', '\xF', '\x706', '\n', '\xF', 
		'\x5', '\xF', '\x708', '\n', '\xF', '\x3', '\x10', '\x3', '\x10', '\x3', 
		'\x10', '\x3', '\x10', '\x5', '\x10', '\x70E', '\n', '\x10', '\x3', '\x10', 
		'\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', 
		'\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', 
		'\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', 
		'\x3', '\x10', '\x3', '\x10', '\x5', '\x10', '\x722', '\n', '\x10', '\x5', 
		'\x10', '\x724', '\n', '\x10', '\x3', '\x11', '\x3', '\x11', '\a', '\x11', 
		'\x728', '\n', '\x11', '\f', '\x11', '\xE', '\x11', '\x72B', '\v', '\x11', 
		'\x3', '\x12', '\x5', '\x12', '\x72E', '\n', '\x12', '\x3', '\x12', '\x3', 
		'\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', 
		'\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', 
		'\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', 
		'\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', 
		'\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x5', 
		'\x12', '\x74A', '\n', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x13', 
		'\x3', '\x13', '\x5', '\x13', '\x750', '\n', '\x13', '\x3', '\x13', '\x5', 
		'\x13', '\x753', '\n', '\x13', '\x3', '\x13', '\x3', '\x13', '\a', '\x13', 
		'\x757', '\n', '\x13', '\f', '\x13', '\xE', '\x13', '\x75A', '\v', '\x13', 
		'\x3', '\x13', '\x3', '\x13', '\x3', '\x14', '\x3', '\x14', '\x5', '\x14', 
		'\x760', '\n', '\x14', '\x3', '\x15', '\x3', '\x15', '\x3', '\x15', '\x3', 
		'\x15', '\x3', '\x15', '\x3', '\x15', '\x3', '\x15', '\x3', '\x15', '\x3', 
		'\x15', '\x3', '\x15', '\x5', '\x15', '\x76C', '\n', '\x15', '\x3', '\x16', 
		'\x3', '\x16', '\x3', '\x17', '\x3', '\x17', '\x3', '\x18', '\x3', '\x18', 
		'\x3', '\x19', '\x3', '\x19', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1B', 
		'\x3', '\x1B', '\x3', '\x1B', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', 
		'\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', 
		'\x5', '\x1D', '\x783', '\n', '\x1D', '\x3', '\x1E', '\x3', '\x1E', '\x5', 
		'\x1E', '\x787', '\n', '\x1E', '\x3', '\x1F', '\x3', '\x1F', '\x3', '\x1F', 
		'\x3', '\x1F', '\x5', '\x1F', '\x78D', '\n', '\x1F', '\x3', '\x1F', '\x3', 
		'\x1F', '\x3', ' ', '\x3', ' ', '\x3', '!', '\x3', '!', '\x5', '!', '\x795', 
		'\n', '!', '\x3', '\"', '\x3', '\"', '\x3', '#', '\x3', '#', '\x3', '#', 
		'\x3', '#', '\x5', '#', '\x79D', '\n', '#', '\x3', '#', '\a', '#', '\x7A0', 
		'\n', '#', '\f', '#', '\xE', '#', '\x7A3', '\v', '#', '\x3', '#', '\x3', 
		'#', '\x3', '#', '\x5', '#', '\x7A8', '\n', '#', '\x3', '$', '\x3', '$', 
		'\x3', '$', '\x3', '$', '\a', '$', '\x7AE', '\n', '$', '\f', '$', '\xE', 
		'$', '\x7B1', '\v', '$', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', 
		'\a', '%', '\x7B7', '\n', '%', '\f', '%', '\xE', '%', '\x7BA', '\v', '%', 
		'\x3', '%', '\x5', '%', '\x7BD', '\n', '%', '\x3', '&', '\x3', '&', '\x3', 
		'&', '\x3', '&', '\x6', '&', '\x7C3', '\n', '&', '\r', '&', '\xE', '&', 
		'\x7C4', '\x3', '\'', '\x3', '\'', '\x3', '(', '\x3', '(', '\x3', '(', 
		'\x5', '(', '\x7CC', '\n', '(', '\x3', '(', '\x3', '(', '\x3', '(', '\x5', 
		'(', '\x7D1', '\n', '(', '\a', '(', '\x7D3', '\n', '(', '\f', '(', '\xE', 
		'(', '\x7D6', '\v', '(', '\x3', ')', '\x3', ')', '\x5', ')', '\x7DA', 
		'\n', ')', '\x3', ')', '\x5', ')', '\x7DD', '\n', ')', '\x3', ')', '\x5', 
		')', '\x7E0', '\n', ')', '\x3', '*', '\x3', '*', '\x3', '+', '\x3', '+', 
		'\x3', ',', '\x3', ',', '\x3', ',', '\x3', ',', '\x3', ',', '\x3', ',', 
		'\x3', ',', '\a', ',', '\x7ED', '\n', ',', '\f', ',', '\xE', ',', '\x7F0', 
		'\v', ',', '\x3', '-', '\x3', '-', '\x5', '-', '\x7F4', '\n', '-', '\x3', 
		'.', '\x3', '.', '\x5', '.', '\x7F8', '\n', '.', '\x3', '.', '\x5', '.', 
		'\x7FB', '\n', '.', '\x3', '.', '\x3', '.', '\x3', '/', '\x3', '/', '\x5', 
		'/', '\x801', '\n', '/', '\x3', '\x30', '\x3', '\x30', '\x5', '\x30', 
		'\x805', '\n', '\x30', '\x3', '\x30', '\x5', '\x30', '\x808', '\n', '\x30', 
		'\x3', '\x31', '\x3', '\x31', '\x3', '\x32', '\x3', '\x32', '\x3', '\x32', 
		'\x3', '\x32', '\x3', '\x32', '\x3', '\x32', '\x3', '\x32', '\x3', '\x32', 
		'\x3', '\x32', '\x3', '\x32', '\x3', '\x32', '\x3', '\x32', '\x3', '\x32', 
		'\x3', '\x32', '\x5', '\x32', '\x81A', '\n', '\x32', '\x3', '\x32', '\x5', 
		'\x32', '\x81D', '\n', '\x32', '\x3', '\x33', '\x3', '\x33', '\x5', '\x33', 
		'\x821', '\n', '\x33', '\x3', '\x34', '\x3', '\x34', '\x5', '\x34', '\x825', 
		'\n', '\x34', '\x3', '\x35', '\x3', '\x35', '\x5', '\x35', '\x829', '\n', 
		'\x35', '\x3', '\x36', '\x3', '\x36', '\x5', '\x36', '\x82D', '\n', '\x36', 
		'\x3', '\x37', '\x3', '\x37', '\x5', '\x37', '\x831', '\n', '\x37', '\x3', 
		'\x38', '\x3', '\x38', '\x5', '\x38', '\x835', '\n', '\x38', '\x3', '\x39', 
		'\x3', '\x39', '\x5', '\x39', '\x839', '\n', '\x39', '\x3', ':', '\x3', 
		':', '\x5', ':', '\x83D', '\n', ':', '\x3', ';', '\x3', ';', '\x5', ';', 
		'\x841', '\n', ';', '\x3', '<', '\x3', '<', '\x3', '<', '\x3', '=', '\x3', 
		'=', '\x3', '=', '\x5', '=', '\x849', '\n', '=', '\x3', '>', '\x3', '>', 
		'\x5', '>', '\x84D', '\n', '>', '\x3', '>', '\x5', '>', '\x850', '\n', 
		'>', '\x3', '>', '\x5', '>', '\x853', '\n', '>', '\x3', '?', '\x3', '?', 
		'\x3', '?', '\x5', '?', '\x858', '\n', '?', '\x3', '?', '\x5', '?', '\x85B', 
		'\n', '?', '\x3', '?', '\x5', '?', '\x85E', '\n', '?', '\x3', '@', '\x3', 
		'@', '\x5', '@', '\x862', '\n', '@', '\x3', '@', '\x5', '@', '\x865', 
		'\n', '@', '\x3', '@', '\x5', '@', '\x868', '\n', '@', '\x3', '\x41', 
		'\x3', '\x41', '\x5', '\x41', '\x86C', '\n', '\x41', '\x3', '\x41', '\x5', 
		'\x41', '\x86F', '\n', '\x41', '\x3', '\x42', '\x3', '\x42', '\x5', '\x42', 
		'\x873', '\n', '\x42', '\x3', '\x42', '\x5', '\x42', '\x876', '\n', '\x42', 
		'\x3', '\x43', '\x3', '\x43', '\x5', '\x43', '\x87A', '\n', '\x43', '\x3', 
		'\x43', '\x5', '\x43', '\x87D', '\n', '\x43', '\x3', '\x44', '\x3', '\x44', 
		'\x5', '\x44', '\x881', '\n', '\x44', '\x3', '\x44', '\x5', '\x44', '\x884', 
		'\n', '\x44', '\x3', '\x45', '\x3', '\x45', '\x3', '\x45', '\x5', '\x45', 
		'\x889', '\n', '\x45', '\x3', '\x45', '\x3', '\x45', '\x3', '\x46', '\x3', 
		'\x46', '\x5', '\x46', '\x88F', '\n', '\x46', '\x3', '\x46', '\x3', '\x46', 
		'\x5', '\x46', '\x893', '\n', '\x46', '\x3', '\x46', '\x3', '\x46', '\x3', 
		'\x46', '\x5', '\x46', '\x898', '\n', '\x46', '\x3', 'G', '\x3', 'G', 
		'\x3', 'G', '\x3', 'G', '\x3', 'G', '\x3', 'H', '\x3', 'H', '\x3', 'H', 
		'\x3', 'H', '\x3', 'H', '\x3', 'H', '\x3', 'H', '\x5', 'H', '\x8A6', '\n', 
		'H', '\x3', 'I', '\x3', 'I', '\x3', 'I', '\x3', 'J', '\x3', 'J', '\x3', 
		'J', '\x5', 'J', '\x8AE', '\n', 'J', '\x3', 'K', '\x3', 'K', '\x3', 'K', 
		'\x5', 'K', '\x8B3', '\n', 'K', '\x3', 'L', '\x3', 'L', '\x3', 'L', '\x3', 
		'L', '\x5', 'L', '\x8B9', '\n', 'L', '\x3', 'M', '\x3', 'M', '\x3', 'M', 
		'\x3', 'N', '\x3', 'N', '\x3', 'N', '\x3', 'N', '\x3', 'N', '\x3', 'O', 
		'\x3', 'O', '\x3', 'P', '\x3', 'P', '\x3', 'P', '\x3', 'Q', '\x3', 'Q', 
		'\x3', 'Q', '\x3', 'R', '\x3', 'R', '\x3', 'S', '\x3', 'S', '\x3', 'S', 
		'\a', 'S', '\x8D0', '\n', 'S', '\f', 'S', '\xE', 'S', '\x8D3', '\v', 'S', 
		'\x3', 'T', '\x3', 'T', '\x3', 'T', '\a', 'T', '\x8D8', '\n', 'T', '\f', 
		'T', '\xE', 'T', '\x8DB', '\v', 'T', '\x3', 'U', '\x5', 'U', '\x8DE', 
		'\n', 'U', '\x3', 'U', '\x3', 'U', '\x5', 'U', '\x8E2', '\n', 'U', '\x3', 
		'V', '\x3', 'V', '\x3', 'V', '\x3', 'V', '\x3', 'V', '\x3', 'V', '\x3', 
		'V', '\x5', 'V', '\x8EB', '\n', 'V', '\x3', 'W', '\x3', 'W', '\x3', 'W', 
		'\x3', 'X', '\x3', 'X', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', 
		'\x3', 'Y', '\x5', 'Y', '\x8F7', '\n', 'Y', '\x3', 'Y', '\x3', 'Y', '\x5', 
		'Y', '\x8FB', '\n', 'Y', '\x3', 'Y', '\x5', 'Y', '\x8FE', '\n', 'Y', '\x3', 
		'Y', '\x3', 'Y', '\x3', 'Y', '\x5', 'Y', '\x903', '\n', 'Y', '\x3', 'Y', 
		'\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', 
		'\x5', 'Y', '\x90C', '\n', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x5', 
		'Y', '\x911', '\n', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x5', 'Y', 
		'\x916', '\n', 'Y', '\x3', 'Y', '\x5', 'Y', '\x919', '\n', 'Y', '\x3', 
		'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 
		'Y', '\x5', 'Y', '\x922', '\n', 'Y', '\x5', 'Y', '\x924', '\n', 'Y', '\x3', 
		'Z', '\x3', 'Z', '\x3', '[', '\x3', '[', '\x3', '\\', '\x3', '\\', '\x3', 
		']', '\x3', ']', '\x3', '^', '\x3', '^', '\x3', '_', '\x3', '_', '\x3', 
		'`', '\x3', '`', '\x3', '\x61', '\x3', '\x61', '\x3', '\x62', '\x3', '\x62', 
		'\x3', '\x63', '\x3', '\x63', '\x5', '\x63', '\x93A', '\n', '\x63', '\x3', 
		'\x63', '\x3', '\x63', '\x5', '\x63', '\x93E', '\n', '\x63', '\x3', '\x63', 
		'\x3', '\x63', '\x3', '\x64', '\x3', '\x64', '\x5', '\x64', '\x944', '\n', 
		'\x64', '\x3', '\x64', '\x3', '\x64', '\x3', '\x64', '\a', '\x64', '\x949', 
		'\n', '\x64', '\f', '\x64', '\xE', '\x64', '\x94C', '\v', '\x64', '\x3', 
		'\x64', '\x3', '\x64', '\x3', '\x65', '\x3', '\x65', '\x5', '\x65', '\x952', 
		'\n', '\x65', '\x3', '\x66', '\x3', '\x66', '\x3', '\x66', '\x3', '\x66', 
		'\a', '\x66', '\x958', '\n', '\x66', '\f', '\x66', '\xE', '\x66', '\x95B', 
		'\v', '\x66', '\x3', 'g', '\x3', 'g', '\x3', 'g', '\x3', 'g', '\a', 'g', 
		'\x961', '\n', 'g', '\f', 'g', '\xE', 'g', '\x964', '\v', 'g', '\x3', 
		'h', '\x3', 'h', '\x3', 'i', '\x3', 'i', '\x3', 'j', '\x3', 'j', '\x3', 
		'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 
		'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 
		'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 
		'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 
		'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 
		'j', '\x3', 'j', '\x3', 'j', '\x5', 'j', '\x98D', '\n', 'j', '\x3', 'j', 
		'\x5', 'j', '\x990', '\n', 'j', '\x3', 'k', '\x3', 'k', '\x3', 'l', '\x3', 
		'l', '\x3', 'l', '\x3', 'l', '\x3', 'l', '\x3', 'l', '\x5', 'l', '\x99A', 
		'\n', 'l', '\x3', 'l', '\x3', 'l', '\x3', 'l', '\x3', 'l', '\x3', 'l', 
		'\x3', 'm', '\x3', 'm', '\x3', 'm', '\a', 'm', '\x9A4', '\n', 'm', '\f', 
		'm', '\xE', 'm', '\x9A7', '\v', 'm', '\x3', 'n', '\x3', 'n', '\x3', 'n', 
		'\x5', 'n', '\x9AC', '\n', 'n', '\x3', 'o', '\x3', 'o', '\x3', 'o', '\x3', 
		'o', '\x3', 'o', '\x5', 'o', '\x9B3', '\n', 'o', '\x3', 'o', '\x3', 'o', 
		'\x3', 'o', '\x3', 'o', '\x3', 'p', '\x3', 'p', '\x3', 'p', '\x3', 'q', 
		'\x3', 'q', '\x3', 'q', '\x5', 'q', '\x9BF', '\n', 'q', '\x3', 'r', '\x3', 
		'r', '\x3', 'r', '\x3', 'r', '\x3', 'r', '\x3', 's', '\x3', 's', '\x5', 
		's', '\x9C8', '\n', 's', '\x3', 's', '\x3', 's', '\x3', 't', '\x3', 't', 
		'\x3', 't', '\x3', 'u', '\x3', 'u', '\x3', 'u', '\x3', 'u', '\a', 'u', 
		'\x9D3', '\n', 'u', '\f', 'u', '\xE', 'u', '\x9D6', '\v', 'u', '\x3', 
		'v', '\x3', 'v', '\x3', 'v', '\x5', 'v', '\x9DB', '\n', 'v', '\x3', 'w', 
		'\x3', 'w', '\x3', 'w', '\x5', 'w', '\x9E0', '\n', 'w', '\x3', 'x', '\x3', 
		'x', '\x3', 'y', '\x3', 'y', '\x3', 'y', '\x3', 'y', '\x3', 'y', '\x5', 
		'y', '\x9E9', '\n', 'y', '\x3', 'z', '\x3', 'z', '\x3', 'z', '\x5', 'z', 
		'\x9EE', '\n', 'z', '\x3', '{', '\x3', '{', '\x3', '{', '\x3', '{', '\x3', 
		'{', '\x3', '{', '\x3', '{', '\x3', '|', '\x3', '|', '\x3', '|', '\x5', 
		'|', '\x9FA', '\n', '|', '\x3', '}', '\x3', '}', '\x3', '}', '\x3', '}', 
		'\x3', '}', '\x3', '}', '\x3', '~', '\x3', '~', '\x3', '~', '\x3', '\x7F', 
		'\x3', '\x7F', '\x3', '\x7F', '\x5', '\x7F', '\xA08', '\n', '\x7F', '\x3', 
		'\x7F', '\x3', '\x7F', '\x5', '\x7F', '\xA0C', '\n', '\x7F', '\x5', '\x7F', 
		'\xA0E', '\n', '\x7F', '\x3', '\x7F', '\x3', '\x7F', '\x3', '\x80', '\x3', 
		'\x80', '\x3', '\x80', '\x3', '\x80', '\x3', '\x81', '\x3', '\x81', '\x3', 
		'\x81', '\x5', '\x81', '\xA19', '\n', '\x81', '\x3', '\x82', '\x3', '\x82', 
		'\x3', '\x82', '\x3', '\x82', '\x3', '\x82', '\x3', '\x83', '\x3', '\x83', 
		'\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', 
		'\x3', '\x84', '\x3', '\x84', '\x5', '\x84', '\xA29', '\n', '\x84', '\x3', 
		'\x85', '\x3', '\x85', '\x3', '\x86', '\x3', '\x86', '\x3', '\x86', '\x3', 
		'\x86', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', '\x5', 
		'\x87', '\xA35', '\n', '\x87', '\x3', '\x88', '\x3', '\x88', '\x3', '\x88', 
		'\x3', '\x88', '\x3', '\x88', '\x3', '\x88', '\x3', '\x88', '\x5', '\x88', 
		'\xA3E', '\n', '\x88', '\x3', '\x89', '\x3', '\x89', '\x3', '\x89', '\x3', 
		'\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8B', '\x3', 
		'\x8B', '\x3', '\x8B', '\x5', '\x8B', '\xA4A', '\n', '\x8B', '\x3', '\x8C', 
		'\x3', '\x8C', '\x3', '\x8D', '\x3', '\x8D', '\x3', '\x8D', '\x3', '\x8D', 
		'\x3', '\x8D', '\x5', '\x8D', '\xA53', '\n', '\x8D', '\x3', '\x8D', '\x3', 
		'\x8D', '\x3', '\x8D', '\x3', '\x8D', '\x3', '\x8E', '\x3', '\x8E', '\x3', 
		'\x8E', '\x3', '\x8E', '\x3', '\x8E', '\x3', '\x8F', '\x3', '\x8F', '\x3', 
		'\x8F', '\x5', '\x8F', '\xA61', '\n', '\x8F', '\x3', '\x8F', '\x3', '\x8F', 
		'\x3', '\x90', '\x3', '\x90', '\x6', '\x90', '\xA67', '\n', '\x90', '\r', 
		'\x90', '\xE', '\x90', '\xA68', '\x3', '\x90', '\x5', '\x90', '\xA6C', 
		'\n', '\x90', '\x3', '\x91', '\x3', '\x91', '\x3', '\x91', '\x3', '\x91', 
		'\x3', '\x91', '\x3', '\x92', '\x3', '\x92', '\x3', '\x92', '\x3', '\x93', 
		'\x6', '\x93', '\xA77', '\n', '\x93', '\r', '\x93', '\xE', '\x93', '\xA78', 
		'\x3', '\x93', '\x5', '\x93', '\xA7C', '\n', '\x93', '\x3', '\x94', '\x3', 
		'\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x95', '\x3', 
		'\x95', '\x3', '\x95', '\x3', '\x96', '\x3', '\x96', '\x3', '\x96', '\x3', 
		'\x97', '\x3', '\x97', '\x3', '\x97', '\x3', '\x98', '\x3', '\x98', '\x3', 
		'\x98', '\x5', '\x98', '\xA8F', '\n', '\x98', '\x3', '\x98', '\x3', '\x98', 
		'\x3', '\x98', '\x3', '\x99', '\x3', '\x99', '\x5', '\x99', '\xA96', '\n', 
		'\x99', '\x3', '\x99', '\x5', '\x99', '\xA99', '\n', '\x99', '\x3', '\x99', 
		'\x3', '\x99', '\x3', '\x9A', '\x3', '\x9A', '\x3', '\x9A', '\x3', '\x9A', 
		'\x3', '\x9A', '\a', '\x9A', '\xAA2', '\n', '\x9A', '\f', '\x9A', '\xE', 
		'\x9A', '\xAA5', '\v', '\x9A', '\x3', '\x9A', '\x3', '\x9A', '\x3', '\x9B', 
		'\x3', '\x9B', '\x3', '\x9B', '\x3', '\x9B', '\x3', '\x9B', '\x3', '\x9B', 
		'\x3', '\x9C', '\x3', '\x9C', '\x3', '\x9C', '\x3', '\x9C', '\x3', '\x9C', 
		'\x3', '\x9C', '\x3', '\x9C', '\x5', '\x9C', '\xAB6', '\n', '\x9C', '\x3', 
		'\x9C', '\x3', '\x9C', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9E', '\x3', 
		'\x9E', '\x3', '\x9F', '\x3', '\x9F', '\x3', '\xA0', '\x3', '\xA0', '\x5', 
		'\xA0', '\xAC2', '\n', '\xA0', '\x3', '\xA0', '\x3', '\xA0', '\x3', '\xA1', 
		'\x3', '\xA1', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', 
		'\x3', '\xA2', '\x5', '\xA2', '\xACD', '\n', '\xA2', '\x3', '\xA2', '\x3', 
		'\xA2', '\x5', '\xA2', '\xAD1', '\n', '\xA2', '\x3', '\xA2', '\x3', '\xA2', 
		'\x5', '\xA2', '\xAD5', '\n', '\xA2', '\x5', '\xA2', '\xAD7', '\n', '\xA2', 
		'\x3', '\xA3', '\x3', '\xA3', '\x3', '\xA3', '\x3', '\xA3', '\x3', '\xA4', 
		'\x3', '\xA4', '\x3', '\xA4', '\x3', '\xA4', '\x3', '\xA4', '\a', '\xA4', 
		'\xAE2', '\n', '\xA4', '\f', '\xA4', '\xE', '\xA4', '\xAE5', '\v', '\xA4', 
		'\x5', '\xA4', '\xAE7', '\n', '\xA4', '\x3', '\xA4', '\x3', '\xA4', '\x3', 
		'\xA5', '\x3', '\xA5', '\x3', '\xA5', '\x3', '\xA5', '\x5', '\xA5', '\xAEF', 
		'\n', '\xA5', '\x3', '\xA6', '\x5', '\xA6', '\xAF2', '\n', '\xA6', '\x3', 
		'\xA6', '\x3', '\xA6', '\x3', '\xA6', '\x3', '\xA6', '\x3', '\xA7', '\x5', 
		'\xA7', '\xAF9', '\n', '\xA7', '\x3', '\xA7', '\x3', '\xA7', '\x3', '\xA7', 
		'\x3', '\xA7', '\x3', '\xA8', '\x3', '\xA8', '\x5', '\xA8', '\xB01', '\n', 
		'\xA8', '\x3', '\xA8', '\x3', '\xA8', '\x3', '\xA8', '\x3', '\xA9', '\x3', 
		'\xA9', '\x5', '\xA9', '\xB08', '\n', '\xA9', '\x3', '\xA9', '\x3', '\xA9', 
		'\x3', '\xAA', '\x3', '\xAA', '\x3', '\xAB', '\x3', '\xAB', '\x3', '\xAB', 
		'\x3', '\xAC', '\x3', '\xAC', '\x3', '\xAD', '\x3', '\xAD', '\x3', '\xAE', 
		'\x3', '\xAE', '\x3', '\xAE', '\x3', '\xAE', '\x3', '\xAE', '\x3', '\xAE', 
		'\x3', '\xAE', '\x3', '\xAE', '\x3', '\xAE', '\x3', '\xAE', '\x3', '\xAE', 
		'\x3', '\xAE', '\x3', '\xAE', '\x3', '\xAE', '\x3', '\xAE', '\x5', '\xAE', 
		'\xB24', '\n', '\xAE', '\x3', '\xAF', '\x3', '\xAF', '\x3', '\xAF', '\x3', 
		'\xAF', '\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\x3', 
		'\xB0', '\x3', '\xB1', '\x3', '\xB1', '\x3', '\xB1', '\x3', '\xB1', '\x3', 
		'\xB1', '\x3', '\xB1', '\x3', '\xB1', '\x3', '\xB1', '\x3', '\xB1', '\x5', 
		'\xB1', '\xB38', '\n', '\xB1', '\x3', '\xB1', '\x3', '\xB1', '\x5', '\xB1', 
		'\xB3C', '\n', '\xB1', '\x3', '\xB2', '\x3', '\xB2', '\x3', '\xB2', '\a', 
		'\xB2', '\xB41', '\n', '\xB2', '\f', '\xB2', '\xE', '\xB2', '\xB44', '\v', 
		'\xB2', '\x3', '\xB3', '\x3', '\xB3', '\x3', '\xB3', '\x3', '\xB3', '\x3', 
		'\xB3', '\x5', '\xB3', '\xB4B', '\n', '\xB3', '\x3', '\xB4', '\x3', '\xB4', 
		'\x3', '\xB4', '\a', '\xB4', '\xB50', '\n', '\xB4', '\f', '\xB4', '\xE', 
		'\xB4', '\xB53', '\v', '\xB4', '\x3', '\xB5', '\x3', '\xB5', '\x3', '\xB5', 
		'\x6', '\xB5', '\xB58', '\n', '\xB5', '\r', '\xB5', '\xE', '\xB5', '\xB59', 
		'\x3', '\xB6', '\x3', '\xB6', '\x3', '\xB7', '\x5', '\xB7', '\xB5F', '\n', 
		'\xB7', '\x3', '\xB7', '\x3', '\xB7', '\x5', '\xB7', '\xB63', '\n', '\xB7', 
		'\x3', '\xB7', '\x5', '\xB7', '\xB66', '\n', '\xB7', '\x3', '\xB8', '\x3', 
		'\xB8', '\x3', '\xB8', '\x3', '\xB8', '\x5', '\xB8', '\xB6C', '\n', '\xB8', 
		'\x3', '\xB8', '\x3', '\xB8', '\x3', '\xB9', '\x3', '\xB9', '\x3', '\xB9', 
		'\x3', '\xBA', '\x5', '\xBA', '\xB74', '\n', '\xBA', '\x3', '\xBA', '\x3', 
		'\xBA', '\x3', '\xBB', '\x3', '\xBB', '\x3', '\xBB', '\a', '\xBB', '\xB7B', 
		'\n', '\xBB', '\f', '\xBB', '\xE', '\xBB', '\xB7E', '\v', '\xBB', '\x3', 
		'\xBC', '\x3', '\xBC', '\x3', '\xBC', '\a', '\xBC', '\xB83', '\n', '\xBC', 
		'\f', '\xBC', '\xE', '\xBC', '\xB86', '\v', '\xBC', '\x3', '\xBD', '\x3', 
		'\xBD', '\x3', '\xBE', '\x3', '\xBE', '\x3', '\xBF', '\x3', '\xBF', '\x5', 
		'\xBF', '\xB8E', '\n', '\xBF', '\x3', '\xBF', '\x3', '\xBF', '\x3', '\xBF', 
		'\x3', '\xBF', '\x3', '\xBF', '\x3', '\xBF', '\x3', '\xBF', '\x5', '\xBF', 
		'\xB97', '\n', '\xBF', '\x3', '\xC0', '\x3', '\xC0', '\x3', '\xC0', '\x3', 
		'\xC1', '\x3', '\xC1', '\x3', '\xC1', '\x3', '\xC1', '\x3', '\xC1', '\a', 
		'\xC1', '\xBA1', '\n', '\xC1', '\f', '\xC1', '\xE', '\xC1', '\xBA4', '\v', 
		'\xC1', '\x3', '\xC2', '\x3', '\xC2', '\x3', '\xC2', '\x3', '\xC2', '\x5', 
		'\xC2', '\xBAA', '\n', '\xC2', '\x3', '\xC3', '\x3', '\xC3', '\x3', '\xC3', 
		'\x3', '\xC3', '\x5', '\xC3', '\xBB0', '\n', '\xC3', '\x3', '\xC4', '\x3', 
		'\xC4', '\x3', '\xC4', '\x5', '\xC4', '\xBB5', '\n', '\xC4', '\x3', '\xC5', 
		'\x3', '\xC5', '\x3', '\xC5', '\x5', '\xC5', '\xBBA', '\n', '\xC5', '\x3', 
		'\xC6', '\x3', '\xC6', '\x3', '\xC6', '\x3', '\xC7', '\x3', '\xC7', '\x3', 
		'\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x3', 
		'\xC7', '\x3', '\xC7', '\x5', '\xC7', '\xBC8', '\n', '\xC7', '\x3', '\xC8', 
		'\x3', '\xC8', '\x3', '\xC8', '\x3', '\xC8', '\x3', '\xC9', '\x3', '\xC9', 
		'\x3', '\xC9', '\x3', '\xC9', '\x3', '\xCA', '\x5', '\xCA', '\xBD3', '\n', 
		'\xCA', '\x3', '\xCA', '\x3', '\xCA', '\x3', '\xCA', '\x3', '\xCA', '\x3', 
		'\xCB', '\x3', '\xCB', '\x3', '\xCB', '\x5', '\xCB', '\xBDC', '\n', '\xCB', 
		'\x3', '\xCB', '\x3', '\xCB', '\x3', '\xCB', '\x3', '\xCC', '\x3', '\xCC', 
		'\x3', '\xCC', '\x3', '\xCD', '\x3', '\xCD', '\x3', '\xCD', '\x3', '\xCE', 
		'\x3', '\xCE', '\x3', '\xCE', '\x3', '\xCF', '\x3', '\xCF', '\x3', '\xCF', 
		'\x3', '\xD0', '\x3', '\xD0', '\x3', '\xD0', '\x3', '\xD0', '\x3', '\xD1', 
		'\x5', '\xD1', '\xBF2', '\n', '\xD1', '\x3', '\xD1', '\x3', '\xD1', '\x3', 
		'\xD1', '\x3', '\xD1', '\x3', '\xD1', '\x3', '\xD1', '\x5', '\xD1', '\xBFA', 
		'\n', '\xD1', '\x3', '\xD1', '\x5', '\xD1', '\xBFD', '\n', '\xD1', '\x3', 
		'\xD1', '\x3', '\xD1', '\x5', '\xD1', '\xC01', '\n', '\xD1', '\x3', '\xD2', 
		'\x3', '\xD2', '\x3', '\xD2', '\a', '\xD2', '\xC06', '\n', '\xD2', '\f', 
		'\xD2', '\xE', '\xD2', '\xC09', '\v', '\xD2', '\x3', '\xD3', '\x3', '\xD3', 
		'\x5', '\xD3', '\xC0D', '\n', '\xD3', '\x3', '\xD3', '\x3', '\xD3', '\x3', 
		'\xD3', '\x3', '\xD3', '\a', '\xD3', '\xC13', '\n', '\xD3', '\f', '\xD3', 
		'\xE', '\xD3', '\xC16', '\v', '\xD3', '\x3', '\xD3', '\x3', '\xD3', '\x5', 
		'\xD3', '\xC1A', '\n', '\xD3', '\x3', '\xD4', '\x3', '\xD4', '\x5', '\xD4', 
		'\xC1E', '\n', '\xD4', '\x3', '\xD5', '\x3', '\xD5', '\x3', '\xD5', '\x3', 
		'\xD5', '\x3', '\xD5', '\x3', '\xD5', '\x3', '\xD5', '\x3', '\xD5', '\a', 
		'\xD5', '\xC28', '\n', '\xD5', '\f', '\xD5', '\xE', '\xD5', '\xC2B', '\v', 
		'\xD5', '\x3', '\xD5', '\x3', '\xD5', '\x5', '\xD5', '\xC2F', '\n', '\xD5', 
		'\x3', '\xD5', '\a', '\xD5', '\xC32', '\n', '\xD5', '\f', '\xD5', '\xE', 
		'\xD5', '\xC35', '\v', '\xD5', '\x3', '\xD6', '\x3', '\xD6', '\x5', '\xD6', 
		'\xC39', '\n', '\xD6', '\x3', '\xD7', '\x3', '\xD7', '\x5', '\xD7', '\xC3D', 
		'\n', '\xD7', '\x3', '\xD8', '\x3', '\xD8', '\x3', '\xD8', '\x6', '\xD8', 
		'\xC42', '\n', '\xD8', '\r', '\xD8', '\xE', '\xD8', '\xC43', '\x3', '\xD8', 
		'\x5', '\xD8', '\xC47', '\n', '\xD8', '\x3', '\xD9', '\x3', '\xD9', '\x3', 
		'\xD9', '\x3', '\xDA', '\x3', '\xDA', '\x3', '\xDA', '\x3', '\xDA', '\x5', 
		'\xDA', '\xC50', '\n', '\xDA', '\x3', '\xDB', '\x3', '\xDB', '\x3', '\xDB', 
		'\x3', '\xDB', '\a', '\xDB', '\xC56', '\n', '\xDB', '\f', '\xDB', '\xE', 
		'\xDB', '\xC59', '\v', '\xDB', '\x3', '\xDB', '\x3', '\xDB', '\x3', '\xDC', 
		'\x3', '\xDC', '\x5', '\xDC', '\xC5F', '\n', '\xDC', '\x3', '\xDC', '\x3', 
		'\xDC', '\a', '\xDC', '\xC63', '\n', '\xDC', '\f', '\xDC', '\xE', '\xDC', 
		'\xC66', '\v', '\xDC', '\x3', '\xDC', '\x5', '\xDC', '\xC69', '\n', '\xDC', 
		'\x3', '\xDD', '\x3', '\xDD', '\x3', '\xDD', '\x3', '\xDD', '\x3', '\xDD', 
		'\a', '\xDD', '\xC70', '\n', '\xDD', '\f', '\xDD', '\xE', '\xDD', '\xC73', 
		'\v', '\xDD', '\x3', '\xDD', '\x3', '\xDD', '\x5', '\xDD', '\xC77', '\n', 
		'\xDD', '\x3', '\xDE', '\x3', '\xDE', '\x5', '\xDE', '\xC7B', '\n', '\xDE', 
		'\x3', '\xDE', '\x5', '\xDE', '\xC7E', '\n', '\xDE', '\x3', '\xDE', '\x5', 
		'\xDE', '\xC81', '\n', '\xDE', '\x3', '\xDE', '\x3', '\xDE', '\x3', '\xDF', 
		'\x5', '\xDF', '\xC86', '\n', '\xDF', '\x3', '\xDF', '\x3', '\xDF', '\x3', 
		'\xDF', '\x3', '\xDF', '\a', '\xDF', '\xC8C', '\n', '\xDF', '\f', '\xDF', 
		'\xE', '\xDF', '\xC8F', '\v', '\xDF', '\x3', '\xDF', '\x3', '\xDF', '\x3', 
		'\xE0', '\x3', '\xE0', '\x3', '\xE0', '\x3', '\xE1', '\x3', '\xE1', '\x3', 
		'\xE1', '\x3', '\xE1', '\x3', '\xE1', '\a', '\xE1', '\xC9B', '\n', '\xE1', 
		'\f', '\xE1', '\xE', '\xE1', '\xC9E', '\v', '\xE1', '\x3', '\xE1', '\x3', 
		'\xE1', '\x5', '\xE1', '\xCA2', '\n', '\xE1', '\x3', '\xE2', '\x3', '\xE2', 
		'\x5', '\xE2', '\xCA6', '\n', '\xE2', '\x3', '\xE2', '\x5', '\xE2', '\xCA9', 
		'\n', '\xE2', '\x3', '\xE2', '\x5', '\xE2', '\xCAC', '\n', '\xE2', '\x3', 
		'\xE2', '\x3', '\xE2', '\x3', '\xE3', '\x3', '\xE3', '\x3', '\xE3', '\x3', 
		'\xE3', '\x3', '\xE3', '\x3', '\xE3', '\x3', '\xE3', '\x3', '\xE3', '\x3', 
		'\xE3', '\x3', '\xE3', '\x3', '\xE3', '\x3', '\xE3', '\x5', '\xE3', '\xCBC', 
		'\n', '\xE3', '\x3', '\xE4', '\x3', '\xE4', '\x3', '\xE5', '\x3', '\xE5', 
		'\x3', '\xE5', '\x3', '\xE6', '\x3', '\xE6', '\x3', '\xE6', '\x3', '\xE6', 
		'\x5', '\xE6', '\xCC7', '\n', '\xE6', '\x3', '\xE6', '\x5', '\xE6', '\xCCA', 
		'\n', '\xE6', '\x3', '\xE6', '\x5', '\xE6', '\xCCD', '\n', '\xE6', '\x3', 
		'\xE7', '\x3', '\xE7', '\x3', '\xE7', '\x3', '\xE7', '\x3', '\xE7', '\x3', 
		'\xE7', '\x3', '\xE7', '\x3', '\xE7', '\x3', '\xE8', '\x3', '\xE8', '\x3', 
		'\xE8', '\x5', '\xE8', '\xCDA', '\n', '\xE8', '\x3', '\xE9', '\x3', '\xE9', 
		'\x3', '\xE9', '\x3', '\xE9', '\x3', '\xE9', '\x3', '\xEA', '\x3', '\xEA', 
		'\x3', '\xEA', '\x3', '\xEB', '\x3', '\xEB', '\x3', '\xEB', '\x5', '\xEB', 
		'\xCE7', '\n', '\xEB', '\x3', '\xEB', '\a', '\xEB', '\xCEA', '\n', '\xEB', 
		'\f', '\xEB', '\xE', '\xEB', '\xCED', '\v', '\xEB', '\x3', '\xEC', '\x3', 
		'\xEC', '\x3', '\xEC', '\x3', '\xEC', '\x3', '\xED', '\x5', '\xED', '\xCF4', 
		'\n', '\xED', '\x3', '\xED', '\x3', '\xED', '\x3', '\xED', '\x3', '\xED', 
		'\x3', '\xED', '\x3', '\xED', '\x3', '\xED', '\x3', '\xED', '\x5', '\xED', 
		'\xCFE', '\n', '\xED', '\x3', '\xEE', '\x3', '\xEE', '\x3', '\xEF', '\x3', 
		'\xEF', '\x3', '\xEF', '\x3', '\xEF', '\a', '\xEF', '\xD06', '\n', '\xEF', 
		'\f', '\xEF', '\xE', '\xEF', '\xD09', '\v', '\xEF', '\x3', '\xEF', '\x5', 
		'\xEF', '\xD0C', '\n', '\xEF', '\x3', '\xEF', '\x3', '\xEF', '\x3', '\xEF', 
		'\x3', '\xEF', '\x5', '\xEF', '\xD12', '\n', '\xEF', '\x3', '\xF0', '\x3', 
		'\xF0', '\x3', '\xF0', '\x3', '\xF0', '\x3', '\xF0', '\a', '\xF0', '\xD19', 
		'\n', '\xF0', '\f', '\xF0', '\xE', '\xF0', '\xD1C', '\v', '\xF0', '\x3', 
		'\xF0', '\x3', '\xF0', '\x3', '\xF0', '\x3', '\xF0', '\x5', '\xF0', '\xD22', 
		'\n', '\xF0', '\x5', '\xF0', '\xD24', '\n', '\xF0', '\x3', '\xF1', '\x5', 
		'\xF1', '\xD27', '\n', '\xF1', '\x3', '\xF2', '\x3', '\xF2', '\x5', '\xF2', 
		'\xD2B', '\n', '\xF2', '\x3', '\xF3', '\x3', '\xF3', '\x5', '\xF3', '\xD2F', 
		'\n', '\xF3', '\x3', '\xF4', '\x3', '\xF4', '\x5', '\xF4', '\xD33', '\n', 
		'\xF4', '\x3', '\xF5', '\x3', '\xF5', '\x3', '\xF5', '\x5', '\xF5', '\xD38', 
		'\n', '\xF5', '\x3', '\xF6', '\x3', '\xF6', '\x5', '\xF6', '\xD3C', '\n', 
		'\xF6', '\x3', '\xF6', '\x3', '\xF6', '\x3', '\xF7', '\x3', '\xF7', '\x3', 
		'\xF8', '\x3', '\xF8', '\x3', '\xF8', '\x3', '\xF9', '\x3', '\xF9', '\x3', 
		'\xF9', '\x5', '\xF9', '\xD48', '\n', '\xF9', '\x3', '\xFA', '\x3', '\xFA', 
		'\x3', '\xFA', '\x3', '\xFA', '\x3', '\xFB', '\x3', '\xFB', '\x5', '\xFB', 
		'\xD50', '\n', '\xFB', '\x3', '\xFB', '\x3', '\xFB', '\x5', '\xFB', '\xD54', 
		'\n', '\xFB', '\x3', '\xFB', '\x5', '\xFB', '\xD57', '\n', '\xFB', '\x3', 
		'\xFB', '\x5', '\xFB', '\xD5A', '\n', '\xFB', '\x3', '\xFC', '\x3', '\xFC', 
		'\x3', '\xFC', '\x3', '\xFD', '\x3', '\xFD', '\x3', '\xFD', '\x3', '\xFE', 
		'\x3', '\xFE', '\x3', '\xFE', '\x3', '\xFE', '\x3', '\xFF', '\x3', '\xFF', 
		'\x3', '\xFF', '\x3', '\x100', '\x3', '\x100', '\x3', '\x100', '\x3', 
		'\x100', '\x3', '\x100', '\x3', '\x101', '\x3', '\x101', '\x3', '\x101', 
		'\x3', '\x101', '\a', '\x101', '\xD72', '\n', '\x101', '\f', '\x101', 
		'\xE', '\x101', '\xD75', '\v', '\x101', '\x5', '\x101', '\xD77', '\n', 
		'\x101', '\x3', '\x101', '\x3', '\x101', '\x3', '\x102', '\x3', '\x102', 
		'\x5', '\x102', '\xD7D', '\n', '\x102', '\x3', '\x102', '\x5', '\x102', 
		'\xD80', '\n', '\x102', '\x3', '\x102', '\x3', '\x102', '\x5', '\x102', 
		'\xD84', '\n', '\x102', '\x3', '\x103', '\x3', '\x103', '\x3', '\x104', 
		'\x3', '\x104', '\x3', '\x104', '\x3', '\x104', '\x5', '\x104', '\xD8C', 
		'\n', '\x104', '\x3', '\x105', '\x3', '\x105', '\x3', '\x105', '\x3', 
		'\x106', '\x3', '\x106', '\x5', '\x106', '\xD93', '\n', '\x106', '\x3', 
		'\x107', '\x3', '\x107', '\x3', '\x107', '\x3', '\x107', '\x3', '\x107', 
		'\x3', '\x107', '\x3', '\x107', '\x3', '\x107', '\a', '\x107', '\xD9D', 
		'\n', '\x107', '\f', '\x107', '\xE', '\x107', '\xDA0', '\v', '\x107', 
		'\x3', '\x108', '\x3', '\x108', '\x5', '\x108', '\xDA4', '\n', '\x108', 
		'\x3', '\x109', '\x3', '\x109', '\x3', '\x109', '\x5', '\x109', '\xDA9', 
		'\n', '\x109', '\x3', '\x109', '\x5', '\x109', '\xDAC', '\n', '\x109', 
		'\x3', '\x10A', '\x3', '\x10A', '\x3', '\x10A', '\x3', '\x10B', '\x3', 
		'\x10B', '\x3', '\x10C', '\x3', '\x10C', '\x5', '\x10C', '\xDB5', '\n', 
		'\x10C', '\x3', '\x10D', '\x3', '\x10D', '\x3', '\x10D', '\x3', '\x10D', 
		'\x3', '\x10D', '\x3', '\x10D', '\x3', '\x10E', '\x3', '\x10E', '\x3', 
		'\x10E', '\x3', '\x10E', '\x3', '\x10E', '\x3', '\x10E', '\x3', '\x10E', 
		'\x5', '\x10E', '\xDC4', '\n', '\x10E', '\x5', '\x10E', '\xDC6', '\n', 
		'\x10E', '\x3', '\x10F', '\x3', '\x10F', '\x3', '\x10F', '\x3', '\x10F', 
		'\x3', '\x110', '\x3', '\x110', '\x3', '\x110', '\x3', '\x110', '\x3', 
		'\x111', '\x3', '\x111', '\x3', '\x111', '\x3', '\x112', '\x3', '\x112', 
		'\x5', '\x112', '\xDD5', '\n', '\x112', '\x3', '\x113', '\x3', '\x113', 
		'\x3', '\x113', '\x3', '\x113', '\x3', '\x113', '\a', '\x113', '\xDDC', 
		'\n', '\x113', '\f', '\x113', '\xE', '\x113', '\xDDF', '\v', '\x113', 
		'\x3', '\x113', '\x3', '\x113', '\x3', '\x114', '\x3', '\x114', '\x3', 
		'\x114', '\x3', '\x114', '\x3', '\x115', '\x3', '\x115', '\x3', '\x115', 
		'\x5', '\x115', '\xDEA', '\n', '\x115', '\x3', '\x115', '\x3', '\x115', 
		'\x5', '\x115', '\xDEE', '\n', '\x115', '\x3', '\x116', '\x3', '\x116', 
		'\x3', '\x116', '\x3', '\x116', '\x5', '\x116', '\xDF4', '\n', '\x116', 
		'\x3', '\x116', '\x5', '\x116', '\xDF7', '\n', '\x116', '\x3', '\x116', 
		'\x5', '\x116', '\xDFA', '\n', '\x116', '\x3', '\x117', '\x3', '\x117', 
		'\x3', '\x117', '\x3', '\x117', '\x3', '\x117', '\x3', '\x117', '\x5', 
		'\x117', '\xE02', '\n', '\x117', '\x3', '\x117', '\x3', '\x117', '\x3', 
		'\x117', '\x3', '\x117', '\x3', '\x117', '\x3', '\x117', '\x3', '\x117', 
		'\x3', '\x117', '\x3', '\x117', '\x5', '\x117', '\xE0D', '\n', '\x117', 
		'\x5', '\x117', '\xE0F', '\n', '\x117', '\x3', '\x118', '\x3', '\x118', 
		'\x5', '\x118', '\xE13', '\n', '\x118', '\x3', '\x118', '\x5', '\x118', 
		'\xE16', '\n', '\x118', '\x3', '\x118', '\x5', '\x118', '\xE19', '\n', 
		'\x118', '\x3', '\x118', '\x5', '\x118', '\xE1C', '\n', '\x118', '\x3', 
		'\x118', '\x5', '\x118', '\xE1F', '\n', '\x118', '\x3', '\x118', '\x3', 
		'\x118', '\x3', '\x119', '\x3', '\x119', '\x3', '\x119', '\x6', '\x119', 
		'\xE26', '\n', '\x119', '\r', '\x119', '\xE', '\x119', '\xE27', '\x3', 
		'\x11A', '\x3', '\x11A', '\x3', '\x11A', '\x3', '\x11B', '\x3', '\x11B', 
		'\x5', '\x11B', '\xE2F', '\n', '\x11B', '\x3', '\x11B', '\x3', '\x11B', 
		'\x3', '\x11C', '\x3', '\x11C', '\x3', '\x11C', '\x6', '\x11C', '\xE36', 
		'\n', '\x11C', '\r', '\x11C', '\xE', '\x11C', '\xE37', '\x3', '\x11C', 
		'\x3', '\x11C', '\x3', '\x11D', '\x3', '\x11D', '\x3', '\x11D', '\x3', 
		'\x11D', '\x3', '\x11D', '\x3', '\x11D', '\x3', '\x11D', '\x5', '\x11D', 
		'\xE43', '\n', '\x11D', '\x3', '\x11E', '\x3', '\x11E', '\x3', '\x11E', 
		'\x5', '\x11E', '\xE48', '\n', '\x11E', '\x3', '\x11F', '\x5', '\x11F', 
		'\xE4B', '\n', '\x11F', '\x3', '\x11F', '\x5', '\x11F', '\xE4E', '\n', 
		'\x11F', '\x3', '\x11F', '\x5', '\x11F', '\xE51', '\n', '\x11F', '\x3', 
		'\x11F', '\x5', '\x11F', '\xE54', '\n', '\x11F', '\x3', '\x11F', '\x3', 
		'\x11F', '\x3', '\x120', '\x3', '\x120', '\x3', '\x120', '\x5', '\x120', 
		'\xE5B', '\n', '\x120', '\x3', '\x121', '\x5', '\x121', '\xE5E', '\n', 
		'\x121', '\x3', '\x121', '\x5', '\x121', '\xE61', '\n', '\x121', '\x3', 
		'\x121', '\x5', '\x121', '\xE64', '\n', '\x121', '\x3', '\x121', '\x5', 
		'\x121', '\xE67', '\n', '\x121', '\x3', '\x121', '\x5', '\x121', '\xE6A', 
		'\n', '\x121', '\x3', '\x121', '\x5', '\x121', '\xE6D', '\n', '\x121', 
		'\x3', '\x121', '\a', '\x121', '\xE70', '\n', '\x121', '\f', '\x121', 
		'\xE', '\x121', '\xE73', '\v', '\x121', '\x3', '\x121', '\x5', '\x121', 
		'\xE76', '\n', '\x121', '\x3', '\x121', '\x5', '\x121', '\xE79', '\n', 
		'\x121', '\x3', '\x122', '\x3', '\x122', '\x3', '\x122', '\x3', '\x122', 
		'\x5', '\x122', '\xE7F', '\n', '\x122', '\x3', '\x122', '\x6', '\x122', 
		'\xE82', '\n', '\x122', '\r', '\x122', '\xE', '\x122', '\xE83', '\x3', 
		'\x123', '\x3', '\x123', '\x5', '\x123', '\xE88', '\n', '\x123', '\x3', 
		'\x123', '\x3', '\x123', '\x5', '\x123', '\xE8C', '\n', '\x123', '\x3', 
		'\x123', '\x3', '\x123', '\x3', '\x123', '\x5', '\x123', '\xE91', '\n', 
		'\x123', '\x3', '\x124', '\x3', '\x124', '\x5', '\x124', '\xE95', '\n', 
		'\x124', '\x3', '\x125', '\x3', '\x125', '\x3', '\x125', '\x3', '\x125', 
		'\x5', '\x125', '\xE9B', '\n', '\x125', '\x3', '\x126', '\x3', '\x126', 
		'\x3', '\x126', '\x3', '\x127', '\x5', '\x127', '\xEA1', '\n', '\x127', 
		'\x3', '\x127', '\x3', '\x127', '\x3', '\x127', '\x5', '\x127', '\xEA6', 
		'\n', '\x127', '\x3', '\x127', '\x5', '\x127', '\xEA9', '\n', '\x127', 
		'\x3', '\x127', '\x5', '\x127', '\xEAC', '\n', '\x127', '\x3', '\x128', 
		'\x3', '\x128', '\x3', '\x128', '\x3', '\x128', '\x3', '\x128', '\x3', 
		'\x128', '\x3', '\x129', '\x3', '\x129', '\x3', '\x129', '\x3', '\x129', 
		'\x3', '\x12A', '\x3', '\x12A', '\x3', '\x12A', '\x3', '\x12A', '\x3', 
		'\x12B', '\x3', '\x12B', '\x3', '\x12B', '\x3', '\x12B', '\x5', '\x12B', 
		'\xEC0', '\n', '\x12B', '\x3', '\x12B', '\x3', '\x12B', '\x5', '\x12B', 
		'\xEC4', '\n', '\x12B', '\x3', '\x12B', '\x5', '\x12B', '\xEC7', '\n', 
		'\x12B', '\x3', '\x12C', '\x3', '\x12C', '\x3', '\x12C', '\x3', '\x12C', 
		'\x5', '\x12C', '\xECD', '\n', '\x12C', '\x3', '\x12C', '\x3', '\x12C', 
		'\x3', '\x12D', '\x3', '\x12D', '\x5', '\x12D', '\xED3', '\n', '\x12D', 
		'\x3', '\x12D', '\x3', '\x12D', '\x3', '\x12E', '\x3', '\x12E', '\x3', 
		'\x12E', '\x3', '\x12E', '\a', '\x12E', '\xEDB', '\n', '\x12E', '\f', 
		'\x12E', '\xE', '\x12E', '\xEDE', '\v', '\x12E', '\x3', '\x12E', '\x3', 
		'\x12E', '\x3', '\x12F', '\x3', '\x12F', '\x3', '\x12F', '\x3', '\x12F', 
		'\x3', '\x12F', '\x5', '\x12F', '\xEE7', '\n', '\x12F', '\x3', '\x12F', 
		'\x5', '\x12F', '\xEEA', '\n', '\x12F', '\x3', '\x12F', '\x3', '\x12F', 
		'\x6', '\x12F', '\xEEE', '\n', '\x12F', '\r', '\x12F', '\xE', '\x12F', 
		'\xEEF', '\x5', '\x12F', '\xEF2', '\n', '\x12F', '\x5', '\x12F', '\xEF4', 
		'\n', '\x12F', '\x3', '\x130', '\x3', '\x130', '\x3', '\x130', '\x3', 
		'\x130', '\x3', '\x131', '\x3', '\x131', '\x3', '\x131', '\x5', '\x131', 
		'\xEFD', '\n', '\x131', '\x5', '\x131', '\xEFF', '\n', '\x131', '\x3', 
		'\x132', '\x3', '\x132', '\x3', '\x132', '\x3', '\x133', '\x3', '\x133', 
		'\x3', '\x133', '\x3', '\x133', '\x3', '\x134', '\x3', '\x134', '\x5', 
		'\x134', '\xF0A', '\n', '\x134', '\x3', '\x134', '\x3', '\x134', '\x3', 
		'\x134', '\x5', '\x134', '\xF0F', '\n', '\x134', '\x3', '\x134', '\x5', 
		'\x134', '\xF12', '\n', '\x134', '\x3', '\x134', '\x5', '\x134', '\xF15', 
		'\n', '\x134', '\x3', '\x134', '\x5', '\x134', '\xF18', '\n', '\x134', 
		'\x3', '\x134', '\x5', '\x134', '\xF1B', '\n', '\x134', '\x3', '\x135', 
		'\x3', '\x135', '\x3', '\x135', '\x3', '\x136', '\x3', '\x136', '\x3', 
		'\x137', '\x3', '\x137', '\x3', '\x138', '\x3', '\x138', '\x3', '\x139', 
		'\x3', '\x139', '\x5', '\x139', '\xF28', '\n', '\x139', '\x3', '\x139', 
		'\x5', '\x139', '\xF2B', '\n', '\x139', '\x3', '\x13A', '\x3', '\x13A', 
		'\x3', '\x13A', '\x3', '\x13A', '\x3', '\x13A', '\x3', '\x13A', '\x5', 
		'\x13A', '\xF33', '\n', '\x13A', '\x3', '\x13B', '\x3', '\x13B', '\x3', 
		'\x13B', '\x3', '\x13B', '\x5', '\x13B', '\xF39', '\n', '\x13B', '\x3', 
		'\x13B', '\x3', '\x13B', '\x3', '\x13C', '\x3', '\x13C', '\x3', '\x13C', 
		'\x3', '\x13C', '\x3', '\x13C', '\x3', '\x13C', '\x5', '\x13C', '\xF43', 
		'\n', '\x13C', '\x3', '\x13D', '\x3', '\x13D', '\x3', '\x13D', '\x5', 
		'\x13D', '\xF48', '\n', '\x13D', '\x3', '\x13E', '\x3', '\x13E', '\x3', 
		'\x13E', '\x3', '\x13E', '\x3', '\x13E', '\x5', '\x13E', '\xF4F', '\n', 
		'\x13E', '\x3', '\x13F', '\x3', '\x13F', '\x3', '\x13F', '\x3', '\x13F', 
		'\x5', '\x13F', '\xF55', '\n', '\x13F', '\x3', '\x140', '\x3', '\x140', 
		'\x3', '\x140', '\x3', '\x140', '\a', '\x140', '\xF5B', '\n', '\x140', 
		'\f', '\x140', '\xE', '\x140', '\xF5E', '\v', '\x140', '\x3', '\x140', 
		'\x3', '\x140', '\x3', '\x141', '\x3', '\x141', '\x3', '\x141', '\x5', 
		'\x141', '\xF65', '\n', '\x141', '\x3', '\x141', '\x5', '\x141', '\xF68', 
		'\n', '\x141', '\x3', '\x142', '\x3', '\x142', '\x3', '\x142', '\x3', 
		'\x142', '\x3', '\x143', '\x3', '\x143', '\x3', '\x143', '\x3', '\x143', 
		'\x5', '\x143', '\xF72', '\n', '\x143', '\x3', '\x144', '\x3', '\x144', 
		'\x3', '\x144', '\x5', '\x144', '\xF77', '\n', '\x144', '\x3', '\x144', 
		'\x5', '\x144', '\xF7A', '\n', '\x144', '\x3', '\x145', '\x3', '\x145', 
		'\x3', '\x145', '\x3', '\x145', '\a', '\x145', '\xF80', '\n', '\x145', 
		'\f', '\x145', '\xE', '\x145', '\xF83', '\v', '\x145', '\x3', '\x145', 
		'\x3', '\x145', '\x3', '\x146', '\x3', '\x146', '\x3', '\x146', '\x3', 
		'\x146', '\x5', '\x146', '\xF8B', '\n', '\x146', '\x5', '\x146', '\xF8D', 
		'\n', '\x146', '\x3', '\x147', '\x3', '\x147', '\x3', '\x147', '\x3', 
		'\x148', '\x3', '\x148', '\x3', '\x148', '\x3', '\x148', '\a', '\x148', 
		'\xF96', '\n', '\x148', '\f', '\x148', '\xE', '\x148', '\xF99', '\v', 
		'\x148', '\x3', '\x148', '\x3', '\x148', '\x3', '\x149', '\x3', '\x149', 
		'\x5', '\x149', '\xF9F', '\n', '\x149', '\x3', '\x149', '\x3', '\x149', 
		'\x5', '\x149', '\xFA3', '\n', '\x149', '\x3', '\x149', '\x3', '\x149', 
		'\x3', '\x14A', '\x5', '\x14A', '\xFA8', '\n', '\x14A', '\x3', '\x14A', 
		'\x5', '\x14A', '\xFAB', '\n', '\x14A', '\x3', '\x14A', '\x5', '\x14A', 
		'\xFAE', '\n', '\x14A', '\x3', '\x14A', '\x3', '\x14A', '\a', '\x14A', 
		'\xFB2', '\n', '\x14A', '\f', '\x14A', '\xE', '\x14A', '\xFB5', '\v', 
		'\x14A', '\x3', '\x14A', '\x5', '\x14A', '\xFB8', '\n', '\x14A', '\x3', 
		'\x14B', '\x3', '\x14B', '\x5', '\x14B', '\xFBC', '\n', '\x14B', '\x3', 
		'\x14C', '\x3', '\x14C', '\x3', '\x14C', '\x3', '\x14C', '\a', '\x14C', 
		'\xFC2', '\n', '\x14C', '\f', '\x14C', '\xE', '\x14C', '\xFC5', '\v', 
		'\x14C', '\x3', '\x14C', '\x3', '\x14C', '\x3', '\x14D', '\x3', '\x14D', 
		'\x3', '\x14D', '\x3', '\x14D', '\x5', '\x14D', '\xFCD', '\n', '\x14D', 
		'\x3', '\x14D', '\x3', '\x14D', '\x5', '\x14D', '\xFD1', '\n', '\x14D', 
		'\x3', '\x14D', '\x5', '\x14D', '\xFD4', '\n', '\x14D', '\x5', '\x14D', 
		'\xFD6', '\n', '\x14D', '\x3', '\x14E', '\x3', '\x14E', '\x3', '\x14E', 
		'\x3', '\x14E', '\x6', '\x14E', '\xFDC', '\n', '\x14E', '\r', '\x14E', 
		'\xE', '\x14E', '\xFDD', '\x3', '\x14F', '\x3', '\x14F', '\x3', '\x14F', 
		'\x3', '\x150', '\x3', '\x150', '\x3', '\x150', '\x5', '\x150', '\xFE6', 
		'\n', '\x150', '\x3', '\x151', '\x3', '\x151', '\x3', '\x151', '\x3', 
		'\x151', '\x3', '\x152', '\x3', '\x152', '\x3', '\x152', '\x3', '\x152', 
		'\a', '\x152', '\xFF0', '\n', '\x152', '\f', '\x152', '\xE', '\x152', 
		'\xFF3', '\v', '\x152', '\x3', '\x152', '\x3', '\x152', '\x3', '\x153', 
		'\x3', '\x153', '\x3', '\x153', '\x5', '\x153', '\xFFA', '\n', '\x153', 
		'\x3', '\x153', '\x5', '\x153', '\xFFD', '\n', '\x153', '\x3', '\x154', 
		'\x3', '\x154', '\x5', '\x154', '\x1001', '\n', '\x154', '\x3', '\x155', 
		'\x5', '\x155', '\x1004', '\n', '\x155', '\x3', '\x155', '\x3', '\x155', 
		'\x3', '\x155', '\x3', '\x155', '\x3', '\x155', '\x3', '\x156', '\x5', 
		'\x156', '\x100C', '\n', '\x156', '\x3', '\x156', '\x3', '\x156', '\x3', 
		'\x156', '\x5', '\x156', '\x1011', '\n', '\x156', '\x3', '\x156', '\x3', 
		'\x156', '\x5', '\x156', '\x1015', '\n', '\x156', '\x3', '\x156', '\x3', 
		'\x156', '\x3', '\x156', '\x3', '\x157', '\x3', '\x157', '\x3', '\x158', 
		'\x3', '\x158', '\x3', '\x158', '\x5', '\x158', '\x101F', '\n', '\x158', 
		'\x3', '\x158', '\x3', '\x158', '\x3', '\x158', '\x3', '\x158', '\x5', 
		'\x158', '\x1025', '\n', '\x158', '\x5', '\x158', '\x1027', '\n', '\x158', 
		'\x3', '\x159', '\x3', '\x159', '\x3', '\x159', '\x3', '\x159', '\x5', 
		'\x159', '\x102D', '\n', '\x159', '\x5', '\x159', '\x102F', '\n', '\x159', 
		'\x3', '\x15A', '\x3', '\x15A', '\x3', '\x15A', '\x3', '\x15A', '\x6', 
		'\x15A', '\x1035', '\n', '\x15A', '\r', '\x15A', '\xE', '\x15A', '\x1036', 
		'\x3', '\x15A', '\x3', '\x15A', '\x3', '\x15B', '\x3', '\x15B', '\x3', 
		'\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', 
		'\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', 
		'\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', 
		'\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', 
		'\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x5', '\x15B', 
		'\x1053', '\n', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', 
		'\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', 
		'\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', 
		'\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', 
		'\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', 
		'\x3', '\x15B', '\x5', '\x15B', '\x106B', '\n', '\x15B', '\x3', '\x15B', 
		'\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x5', 
		'\x15B', '\x1072', '\n', '\x15B', '\x3', '\x15C', '\x3', '\x15C', '\x3', 
		'\x15C', '\x3', '\x15C', '\x3', '\x15C', '\a', '\x15C', '\x1079', '\n', 
		'\x15C', '\f', '\x15C', '\xE', '\x15C', '\x107C', '\v', '\x15C', '\x3', 
		'\x15C', '\x3', '\x15C', '\x3', '\x15C', '\x3', '\x15C', '\x3', '\x15D', 
		'\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', 
		'\x15E', '\x3', '\x15E', '\x3', '\x15E', '\x3', '\x15E', '\a', '\x15E', 
		'\x108B', '\n', '\x15E', '\f', '\x15E', '\xE', '\x15E', '\x108E', '\v', 
		'\x15E', '\x3', '\x15E', '\x3', '\x15E', '\x3', '\x15F', '\x3', '\x15F', 
		'\x5', '\x15F', '\x1094', '\n', '\x15F', '\x3', '\x160', '\x3', '\x160', 
		'\x3', '\x160', '\x3', '\x161', '\x5', '\x161', '\x109A', '\n', '\x161', 
		'\x3', '\x161', '\x3', '\x161', '\x5', '\x161', '\x109E', '\n', '\x161', 
		'\x3', '\x161', '\x3', '\x161', '\x6', '\x161', '\x10A2', '\n', '\x161', 
		'\r', '\x161', '\xE', '\x161', '\x10A3', '\x3', '\x161', '\x5', '\x161', 
		'\x10A7', '\n', '\x161', '\x3', '\x162', '\x3', '\x162', '\x3', '\x162', 
		'\x3', '\x162', '\x3', '\x163', '\x3', '\x163', '\x3', '\x163', '\x3', 
		'\x163', '\x6', '\x163', '\x10B1', '\n', '\x163', '\r', '\x163', '\xE', 
		'\x163', '\x10B2', '\x3', '\x163', '\x3', '\x163', '\x3', '\x163', '\x6', 
		'\x163', '\x10B8', '\n', '\x163', '\r', '\x163', '\xE', '\x163', '\x10B9', 
		'\x3', '\x163', '\x5', '\x163', '\x10BD', '\n', '\x163', '\x5', '\x163', 
		'\x10BF', '\n', '\x163', '\x3', '\x164', '\x3', '\x164', '\x3', '\x164', 
		'\x3', '\x164', '\x3', '\x165', '\x3', '\x165', '\x3', '\x166', '\x3', 
		'\x166', '\x3', '\x166', '\x5', '\x166', '\x10CA', '\n', '\x166', '\x3', 
		'\x167', '\x5', '\x167', '\x10CD', '\n', '\x167', '\x3', '\x167', '\x3', 
		'\x167', '\x5', '\x167', '\x10D1', '\n', '\x167', '\x3', '\x168', '\x3', 
		'\x168', '\x5', '\x168', '\x10D5', '\n', '\x168', '\x3', '\x168', '\x5', 
		'\x168', '\x10D8', '\n', '\x168', '\x3', '\x169', '\x3', '\x169', '\x3', 
		'\x169', '\x3', '\x16A', '\x3', '\x16A', '\x3', '\x16A', '\x3', '\x16B', 
		'\x3', '\x16B', '\x3', '\x16B', '\x5', '\x16B', '\x10E3', '\n', '\x16B', 
		'\x3', '\x16C', '\x3', '\x16C', '\x5', '\x16C', '\x10E7', '\n', '\x16C', 
		'\x3', '\x16C', '\x5', '\x16C', '\x10EA', '\n', '\x16C', '\x3', '\x16C', 
		'\x3', '\x16C', '\x3', '\x16C', '\x3', '\x16C', '\x5', '\x16C', '\x10F0', 
		'\n', '\x16C', '\x3', '\x16C', '\x3', '\x16C', '\x3', '\x16C', '\x3', 
		'\x16C', '\x3', '\x16C', '\x3', '\x16C', '\x5', '\x16C', '\x10F8', '\n', 
		'\x16C', '\x5', '\x16C', '\x10FA', '\n', '\x16C', '\x3', '\x16C', '\x5', 
		'\x16C', '\x10FD', '\n', '\x16C', '\x3', '\x16C', '\x3', '\x16C', '\x3', 
		'\x16C', '\x5', '\x16C', '\x1102', '\n', '\x16C', '\x3', '\x16C', '\x5', 
		'\x16C', '\x1105', '\n', '\x16C', '\x3', '\x16D', '\x3', '\x16D', '\x3', 
		'\x16D', '\x3', '\x16D', '\x5', '\x16D', '\x110B', '\n', '\x16D', '\x5', 
		'\x16D', '\x110D', '\n', '\x16D', '\x3', '\x16D', '\x5', '\x16D', '\x1110', 
		'\n', '\x16D', '\x3', '\x16E', '\x3', '\x16E', '\x3', '\x16E', '\x3', 
		'\x16E', '\x3', '\x16F', '\x6', '\x16F', '\x1117', '\n', '\x16F', '\r', 
		'\x16F', '\xE', '\x16F', '\x1118', '\x3', '\x170', '\x3', '\x170', '\x3', 
		'\x170', '\x5', '\x170', '\x111E', '\n', '\x170', '\x3', '\x171', '\x3', 
		'\x171', '\x3', '\x171', '\x3', '\x171', '\x3', '\x171', '\x3', '\x172', 
		'\x3', '\x172', '\x3', '\x172', '\x3', '\x172', '\a', '\x172', '\x1129', 
		'\n', '\x172', '\f', '\x172', '\xE', '\x172', '\x112C', '\v', '\x172', 
		'\x3', '\x172', '\x3', '\x172', '\x3', '\x173', '\x3', '\x173', '\x3', 
		'\x173', '\x3', '\x173', '\x5', '\x173', '\x1134', '\n', '\x173', '\x3', 
		'\x174', '\x3', '\x174', '\x3', '\x174', '\x3', '\x174', '\x5', '\x174', 
		'\x113A', '\n', '\x174', '\x3', '\x175', '\x3', '\x175', '\x3', '\x175', 
		'\x3', '\x175', '\x5', '\x175', '\x1140', '\n', '\x175', '\x3', '\x176', 
		'\x3', '\x176', '\x3', '\x176', '\x3', '\x176', '\x3', '\x176', '\a', 
		'\x176', '\x1147', '\n', '\x176', '\f', '\x176', '\xE', '\x176', '\x114A', 
		'\v', '\x176', '\x3', '\x176', '\x3', '\x176', '\x3', '\x176', '\x3', 
		'\x177', '\x3', '\x177', '\x3', '\x177', '\x3', '\x177', '\x3', '\x177', 
		'\x3', '\x177', '\x5', '\x177', '\x1155', '\n', '\x177', '\x3', '\x178', 
		'\x3', '\x178', '\x3', '\x178', '\x5', '\x178', '\x115A', '\n', '\x178', 
		'\x3', '\x178', '\x3', '\x178', '\x3', '\x178', '\x5', '\x178', '\x115F', 
		'\n', '\x178', '\x3', '\x178', '\x3', '\x178', '\x6', '\x178', '\x1163', 
		'\n', '\x178', '\r', '\x178', '\xE', '\x178', '\x1164', '\x5', '\x178', 
		'\x1167', '\n', '\x178', '\x3', '\x179', '\x3', '\x179', '\x3', '\x179', 
		'\x3', '\x179', '\x3', '\x179', '\x3', '\x179', '\x5', '\x179', '\x116F', 
		'\n', '\x179', '\x5', '\x179', '\x1171', '\n', '\x179', '\x3', '\x179', 
		'\x3', '\x179', '\x3', '\x179', '\x3', '\x179', '\x6', '\x179', '\x1177', 
		'\n', '\x179', '\r', '\x179', '\xE', '\x179', '\x1178', '\x3', '\x179', 
		'\x3', '\x179', '\x3', '\x179', '\a', '\x179', '\x117E', '\n', '\x179', 
		'\f', '\x179', '\xE', '\x179', '\x1181', '\v', '\x179', '\x5', '\x179', 
		'\x1183', '\n', '\x179', '\x3', '\x17A', '\x3', '\x17A', '\x3', '\x17A', 
		'\x5', '\x17A', '\x1188', '\n', '\x17A', '\x3', '\x17A', '\x3', '\x17A', 
		'\x3', '\x17B', '\x3', '\x17B', '\x5', '\x17B', '\x118E', '\n', '\x17B', 
		'\x3', '\x17B', '\x3', '\x17B', '\x3', '\x17B', '\x3', '\x17B', '\x3', 
		'\x17B', '\x5', '\x17B', '\x1195', '\n', '\x17B', '\x3', '\x17B', '\x5', 
		'\x17B', '\x1198', '\n', '\x17B', '\x3', '\x17C', '\x3', '\x17C', '\x3', 
		'\x17D', '\x3', '\x17D', '\x3', '\x17D', '\x5', '\x17D', '\x119F', '\n', 
		'\x17D', '\x3', '\x17E', '\x3', '\x17E', '\x3', '\x17E', '\x3', '\x17E', 
		'\x3', '\x17E', '\x3', '\x17F', '\x3', '\x17F', '\x3', '\x17F', '\x3', 
		'\x17F', '\x3', '\x17F', '\x3', '\x17F', '\x3', '\x180', '\x5', '\x180', 
		'\x11AD', '\n', '\x180', '\x3', '\x180', '\x3', '\x180', '\x5', '\x180', 
		'\x11B1', '\n', '\x180', '\x3', '\x180', '\x5', '\x180', '\x11B4', '\n', 
		'\x180', '\x3', '\x180', '\x3', '\x180', '\x5', '\x180', '\x11B8', '\n', 
		'\x180', '\x3', '\x181', '\x3', '\x181', '\x3', '\x181', '\x3', '\x182', 
		'\x3', '\x182', '\x3', '\x182', '\x3', '\x182', '\x3', '\x183', '\x3', 
		'\x183', '\x3', '\x183', '\x3', '\x183', '\x3', '\x184', '\x5', '\x184', 
		'\x11C6', '\n', '\x184', '\x3', '\x184', '\x3', '\x184', '\x3', '\x184', 
		'\x5', '\x184', '\x11CB', '\n', '\x184', '\x3', '\x184', '\x5', '\x184', 
		'\x11CE', '\n', '\x184', '\x3', '\x185', '\x3', '\x185', '\x3', '\x185', 
		'\x3', '\x185', '\x3', '\x186', '\x3', '\x186', '\x3', '\x186', '\x3', 
		'\x186', '\x5', '\x186', '\x11D8', '\n', '\x186', '\x3', '\x186', '\x5', 
		'\x186', '\x11DB', '\n', '\x186', '\x3', '\x186', '\x5', '\x186', '\x11DE', 
		'\n', '\x186', '\x3', '\x186', '\x3', '\x186', '\x3', '\x186', '\x3', 
		'\x186', '\x5', '\x186', '\x11E4', '\n', '\x186', '\x3', '\x186', '\x5', 
		'\x186', '\x11E7', '\n', '\x186', '\x3', '\x186', '\x5', '\x186', '\x11EA', 
		'\n', '\x186', '\x3', '\x186', '\x5', '\x186', '\x11ED', '\n', '\x186', 
		'\x3', '\x186', '\x5', '\x186', '\x11F0', '\n', '\x186', '\x3', '\x186', 
		'\x5', '\x186', '\x11F3', '\n', '\x186', '\x3', '\x187', '\x3', '\x187', 
		'\x3', '\x187', '\x3', '\x188', '\x3', '\x188', '\x3', '\x188', '\x3', 
		'\x188', '\x3', '\x188', '\x3', '\x188', '\x5', '\x188', '\x11FE', '\n', 
		'\x188', '\x3', '\x189', '\x3', '\x189', '\x3', '\x189', '\x3', '\x189', 
		'\x3', '\x18A', '\x3', '\x18A', '\x6', '\x18A', '\x1206', '\n', '\x18A', 
		'\r', '\x18A', '\xE', '\x18A', '\x1207', '\x3', '\x18A', '\x3', '\x18A', 
		'\x3', '\x18B', '\x5', '\x18B', '\x120D', '\n', '\x18B', '\x3', '\x18B', 
		'\x5', '\x18B', '\x1210', '\n', '\x18B', '\x3', '\x18B', '\x5', '\x18B', 
		'\x1213', '\n', '\x18B', '\x3', '\x18B', '\x5', '\x18B', '\x1216', '\n', 
		'\x18B', '\x3', '\x18B', '\x5', '\x18B', '\x1219', '\n', '\x18B', '\x3', 
		'\x18C', '\x3', '\x18C', '\x3', '\x18D', '\x3', '\x18D', '\x3', '\x18D', 
		'\x3', '\x18E', '\x3', '\x18E', '\x3', '\x18E', '\x3', '\x18E', '\x3', 
		'\x18E', '\x5', '\x18E', '\x1225', '\n', '\x18E', '\x5', '\x18E', '\x1227', 
		'\n', '\x18E', '\x3', '\x18F', '\x3', '\x18F', '\x6', '\x18F', '\x122B', 
		'\n', '\x18F', '\r', '\x18F', '\xE', '\x18F', '\x122C', '\x3', '\x190', 
		'\x3', '\x190', '\x3', '\x190', '\x3', '\x190', '\x5', '\x190', '\x1233', 
		'\n', '\x190', '\x3', '\x191', '\x3', '\x191', '\x3', '\x191', '\x3', 
		'\x191', '\x3', '\x191', '\x3', '\x191', '\x6', '\x191', '\x123B', '\n', 
		'\x191', '\r', '\x191', '\xE', '\x191', '\x123C', '\x3', '\x192', '\x3', 
		'\x192', '\x3', '\x193', '\x3', '\x193', '\x3', '\x193', '\x3', '\x194', 
		'\x3', '\x194', '\x3', '\x194', '\x5', '\x194', '\x1247', '\n', '\x194', 
		'\x3', '\x194', '\x3', '\x194', '\x3', '\x195', '\x3', '\x195', '\x3', 
		'\x195', '\x3', '\x195', '\x5', '\x195', '\x124F', '\n', '\x195', '\x3', 
		'\x196', '\x3', '\x196', '\x3', '\x196', '\x5', '\x196', '\x1254', '\n', 
		'\x196', '\x3', '\x196', '\x3', '\x196', '\x3', '\x196', '\x5', '\x196', 
		'\x1259', '\n', '\x196', '\x3', '\x196', '\x3', '\x196', '\x3', '\x196', 
		'\x5', '\x196', '\x125E', '\n', '\x196', '\x3', '\x197', '\x3', '\x197', 
		'\x3', '\x197', '\x3', '\x197', '\x3', '\x198', '\x3', '\x198', '\x3', 
		'\x198', '\x3', '\x198', '\x3', '\x198', '\x3', '\x198', '\x3', '\x198', 
		'\x3', '\x198', '\x5', '\x198', '\x126C', '\n', '\x198', '\x3', '\x199', 
		'\x3', '\x199', '\x3', '\x199', '\x3', '\x199', '\x3', '\x199', '\x3', 
		'\x19A', '\x3', '\x19A', '\x3', '\x19A', '\x3', '\x19A', '\x5', '\x19A', 
		'\x1277', '\n', '\x19A', '\x3', '\x19A', '\x5', '\x19A', '\x127A', '\n', 
		'\x19A', '\x3', '\x19B', '\x3', '\x19B', '\x3', '\x19B', '\x3', '\x19B', 
		'\x3', '\x19B', '\x3', '\x19B', '\x5', '\x19B', '\x1282', '\n', '\x19B', 
		'\x3', '\x19C', '\x3', '\x19C', '\x3', '\x19C', '\x3', '\x19C', '\x3', 
		'\x19C', '\x3', '\x19C', '\x3', '\x19C', '\x3', '\x19C', '\x3', '\x19C', 
		'\x5', '\x19C', '\x128D', '\n', '\x19C', '\x3', '\x19D', '\x5', '\x19D', 
		'\x1290', '\n', '\x19D', '\x3', '\x19D', '\x5', '\x19D', '\x1293', '\n', 
		'\x19D', '\x3', '\x19D', '\x5', '\x19D', '\x1296', '\n', '\x19D', '\x3', 
		'\x19D', '\x3', '\x19D', '\x3', '\x19D', '\x3', '\x19E', '\x3', '\x19E', 
		'\x3', '\x19E', '\x3', '\x19E', '\x3', '\x19E', '\x5', '\x19E', '\x12A0', 
		'\n', '\x19E', '\x3', '\x19E', '\x5', '\x19E', '\x12A3', '\n', '\x19E', 
		'\x3', '\x19E', '\x3', '\x19E', '\x3', '\x19F', '\x3', '\x19F', '\x3', 
		'\x19F', '\x3', '\x19F', '\x3', '\x19F', '\x3', '\x1A0', '\x5', '\x1A0', 
		'\x12AD', '\n', '\x1A0', '\x3', '\x1A0', '\x5', '\x1A0', '\x12B0', '\n', 
		'\x1A0', '\x3', '\x1A0', '\x5', '\x1A0', '\x12B3', '\n', '\x1A0', '\x3', 
		'\x1A0', '\x5', '\x1A0', '\x12B6', '\n', '\x1A0', '\x3', '\x1A0', '\x5', 
		'\x1A0', '\x12B9', '\n', '\x1A0', '\x3', '\x1A1', '\x3', '\x1A1', '\x3', 
		'\x1A1', '\x3', '\x1A2', '\x3', '\x1A2', '\x3', '\x1A2', '\x3', '\x1A2', 
		'\x5', '\x1A2', '\x12C2', '\n', '\x1A2', '\x3', '\x1A3', '\x3', '\x1A3', 
		'\x3', '\x1A3', '\x3', '\x1A4', '\x3', '\x1A4', '\x3', '\x1A4', '\x3', 
		'\x1A5', '\x3', '\x1A5', '\x3', '\x1A5', '\x3', '\x1A5', '\x5', '\x1A5', 
		'\x12CE', '\n', '\x1A5', '\x3', '\x1A5', '\x5', '\x1A5', '\x12D1', '\n', 
		'\x1A5', '\x3', '\x1A6', '\x3', '\x1A6', '\x3', '\x1A6', '\x3', '\x1A7', 
		'\x3', '\x1A7', '\x3', '\x1A7', '\x3', '\x1A7', '\x3', '\x1A7', '\x5', 
		'\x1A7', '\x12DB', '\n', '\x1A7', '\x3', '\x1A8', '\x3', '\x1A8', '\x3', 
		'\x1A8', '\x3', '\x1A8', '\x3', '\x1A9', '\x5', '\x1A9', '\x12E2', '\n', 
		'\x1A9', '\x3', '\x1A9', '\x3', '\x1A9', '\x3', '\x1AA', '\x3', '\x1AA', 
		'\x3', '\x1AB', '\x3', '\x1AB', '\x3', '\x1AB', '\x5', '\x1AB', '\x12EB', 
		'\n', '\x1AB', '\x3', '\x1AB', '\x5', '\x1AB', '\x12EE', '\n', '\x1AB', 
		'\x3', '\x1AC', '\x3', '\x1AC', '\x3', '\x1AC', '\x3', '\x1AC', '\a', 
		'\x1AC', '\x12F4', '\n', '\x1AC', '\f', '\x1AC', '\xE', '\x1AC', '\x12F7', 
		'\v', '\x1AC', '\x3', '\x1AC', '\x3', '\x1AC', '\x3', '\x1AD', '\x3', 
		'\x1AD', '\x5', '\x1AD', '\x12FD', '\n', '\x1AD', '\x3', '\x1AE', '\x3', 
		'\x1AE', '\a', '\x1AE', '\x1301', '\n', '\x1AE', '\f', '\x1AE', '\xE', 
		'\x1AE', '\x1304', '\v', '\x1AE', '\x3', '\x1AF', '\x3', '\x1AF', '\x3', 
		'\x1AF', '\x3', '\x1AF', '\a', '\x1AF', '\x130A', '\n', '\x1AF', '\f', 
		'\x1AF', '\xE', '\x1AF', '\x130D', '\v', '\x1AF', '\x3', '\x1AF', '\x3', 
		'\x1AF', '\x3', '\x1B0', '\x3', '\x1B0', '\x5', '\x1B0', '\x1313', '\n', 
		'\x1B0', '\x3', '\x1B1', '\x3', '\x1B1', '\x6', '\x1B1', '\x1317', '\n', 
		'\x1B1', '\r', '\x1B1', '\xE', '\x1B1', '\x1318', '\x3', '\x1B2', '\x5', 
		'\x1B2', '\x131C', '\n', '\x1B2', '\x3', '\x1B2', '\x3', '\x1B2', '\x3', 
		'\x1B2', '\x3', '\x1B2', '\x5', '\x1B2', '\x1322', '\n', '\x1B2', '\x3', 
		'\x1B2', '\x5', '\x1B2', '\x1325', '\n', '\x1B2', '\x3', '\x1B3', '\x3', 
		'\x1B3', '\x3', '\x1B3', '\x5', '\x1B3', '\x132A', '\n', '\x1B3', '\x3', 
		'\x1B3', '\x3', '\x1B3', '\x3', '\x1B3', '\x5', '\x1B3', '\x132F', '\n', 
		'\x1B3', '\a', '\x1B3', '\x1331', '\n', '\x1B3', '\f', '\x1B3', '\xE', 
		'\x1B3', '\x1334', '\v', '\x1B3', '\x3', '\x1B3', '\x3', '\x1B3', '\x3', 
		'\x1B4', '\x5', '\x1B4', '\x1339', '\n', '\x1B4', '\x3', '\x1B4', '\x3', 
		'\x1B4', '\x3', '\x1B4', '\x3', '\x1B4', '\x3', '\x1B4', '\x5', '\x1B4', 
		'\x1340', '\n', '\x1B4', '\x3', '\x1B4', '\x5', '\x1B4', '\x1343', '\n', 
		'\x1B4', '\x3', '\x1B5', '\x3', '\x1B5', '\x3', '\x1B5', '\x3', '\x1B5', 
		'\x3', '\x1B5', '\x3', '\x1B5', '\x3', '\x1B5', '\x6', '\x1B5', '\x134C', 
		'\n', '\x1B5', '\r', '\x1B5', '\xE', '\x1B5', '\x134D', '\x3', '\x1B6', 
		'\x5', '\x1B6', '\x1351', '\n', '\x1B6', '\x3', '\x1B6', '\x3', '\x1B6', 
		'\x3', '\x1B7', '\x3', '\x1B7', '\x3', '\x1B7', '\x3', '\x1B8', '\x3', 
		'\x1B8', '\x3', '\x1B9', '\x3', '\x1B9', '\x3', '\x1BA', '\x3', '\x1BA', 
		'\x3', '\x1BA', '\x3', '\x1BA', '\x5', '\x1BA', '\x1360', '\n', '\x1BA', 
		'\x3', '\x1BB', '\x3', '\x1BB', '\x3', '\x1BB', '\x3', '\x1BB', '\x3', 
		'\x1BB', '\x6', '\x1BB', '\x1367', '\n', '\x1BB', '\r', '\x1BB', '\xE', 
		'\x1BB', '\x1368', '\x3', '\x1BC', '\x3', '\x1BC', '\x3', '\x1BD', '\x3', 
		'\x1BD', '\x5', '\x1BD', '\x136F', '\n', '\x1BD', '\x3', '\x1BD', '\x3', 
		'\x1BD', '\x5', '\x1BD', '\x1373', '\n', '\x1BD', '\x3', '\x1BE', '\x3', 
		'\x1BE', '\x3', '\x1BF', '\x3', '\x1BF', '\x3', '\x1BF', '\x6', '\x1BF', 
		'\x137A', '\n', '\x1BF', '\r', '\x1BF', '\xE', '\x1BF', '\x137B', '\x3', 
		'\x1BF', '\x3', '\x1BF', '\x3', '\x1C0', '\x3', '\x1C0', '\x3', '\x1C0', 
		'\x3', '\x1C0', '\x3', '\x1C0', '\x3', '\x1C0', '\x3', '\x1C0', '\x3', 
		'\x1C0', '\x3', '\x1C0', '\x3', '\x1C0', '\x3', '\x1C0', '\x3', '\x1C0', 
		'\x5', '\x1C0', '\x138C', '\n', '\x1C0', '\x3', '\x1C1', '\x3', '\x1C1', 
		'\x3', '\x1C1', '\x5', '\x1C1', '\x1391', '\n', '\x1C1', '\x3', '\x1C2', 
		'\x3', '\x1C2', '\x3', '\x1C3', '\x3', '\x1C3', '\x3', '\x1C3', '\x3', 
		'\x1C4', '\x3', '\x1C4', '\x3', '\x1C4', '\x5', '\x1C4', '\x139B', '\n', 
		'\x1C4', '\x5', '\x1C4', '\x139D', '\n', '\x1C4', '\x3', '\x1C5', '\x3', 
		'\x1C5', '\x3', '\x1C5', '\x3', '\x1C6', '\x3', '\x1C6', '\x3', '\x1C6', 
		'\x5', '\x1C6', '\x13A5', '\n', '\x1C6', '\x3', '\x1C7', '\x3', '\x1C7', 
		'\x3', '\x1C7', '\x3', '\x1C8', '\x3', '\x1C8', '\x3', '\x1C8', '\x3', 
		'\x1C9', '\x3', '\x1C9', '\x3', '\x1C9', '\x3', '\x1C9', '\x3', '\x1CA', 
		'\x3', '\x1CA', '\x3', '\x1CA', '\x3', '\x1CB', '\x3', '\x1CB', '\x3', 
		'\x1CB', '\x3', '\x1CC', '\x3', '\x1CC', '\x3', '\x1CC', '\x3', '\x1CD', 
		'\x3', '\x1CD', '\x3', '\x1CD', '\x3', '\x1CE', '\x3', '\x1CE', '\x3', 
		'\x1CF', '\x3', '\x1CF', '\x3', '\x1CF', '\x3', '\x1CF', '\x3', '\x1D0', 
		'\x3', '\x1D0', '\x3', '\x1D1', '\x3', '\x1D1', '\x3', '\x1D1', '\x3', 
		'\x1D2', '\x5', '\x1D2', '\x13C9', '\n', '\x1D2', '\x3', '\x1D2', '\x3', 
		'\x1D2', '\x3', '\x1D3', '\x3', '\x1D3', '\x5', '\x1D3', '\x13CF', '\n', 
		'\x1D3', '\x3', '\x1D4', '\x3', '\x1D4', '\x3', '\x1D4', '\x5', '\x1D4', 
		'\x13D4', '\n', '\x1D4', '\x3', '\x1D5', '\x3', '\x1D5', '\x3', '\x1D5', 
		'\x3', '\x1D6', '\x3', '\x1D6', '\x3', '\x1D6', '\x3', '\x1D6', '\x3', 
		'\x1D7', '\x3', '\x1D7', '\x5', '\x1D7', '\x13DF', '\n', '\x1D7', '\x3', 
		'\x1D7', '\x5', '\x1D7', '\x13E2', '\n', '\x1D7', '\x3', '\x1D7', '\x3', 
		'\x1D7', '\x5', '\x1D7', '\x13E6', '\n', '\x1D7', '\x3', '\x1D8', '\x3', 
		'\x1D8', '\x3', '\x1D8', '\x5', '\x1D8', '\x13EB', '\n', '\x1D8', '\x3', 
		'\x1D9', '\x3', '\x1D9', '\x3', '\x1D9', '\x3', '\x1D9', '\x3', '\x1D9', 
		'\x5', '\x1D9', '\x13F2', '\n', '\x1D9', '\x3', '\x1DA', '\x3', '\x1DA', 
		'\x3', '\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x5', 
		'\x1DA', '\x13FA', '\n', '\x1DA', '\x3', '\x1DB', '\x3', '\x1DB', '\x3', 
		'\x1DB', '\x5', '\x1DB', '\x13FF', '\n', '\x1DB', '\x3', '\x1DB', '\x3', 
		'\x1DB', '\x5', '\x1DB', '\x1403', '\n', '\x1DB', '\x3', '\x1DC', '\x3', 
		'\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x5', '\x1DC', '\x1409', '\n', 
		'\x1DC', '\x3', '\x1DD', '\x3', '\x1DD', '\x3', '\x1DD', '\x5', '\x1DD', 
		'\x140E', '\n', '\x1DD', '\x3', '\x1DD', '\x3', '\x1DD', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1415', '\n', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x141A', 
		'\n', '\x1DE', '\x3', '\x1DF', '\x3', '\x1DF', '\x3', '\x1DF', '\x5', 
		'\x1DF', '\x141F', '\n', '\x1DF', '\x3', '\x1DF', '\x6', '\x1DF', '\x1422', 
		'\n', '\x1DF', '\r', '\x1DF', '\xE', '\x1DF', '\x1423', '\x3', '\x1DF', 
		'\x3', '\x1DF', '\x3', '\x1E0', '\x3', '\x1E0', '\x3', '\x1E0', '\x3', 
		'\x1E0', '\x3', '\x1E0', '\x3', '\x1E0', '\x3', '\x1E1', '\x3', '\x1E1', 
		'\x3', '\x1E1', '\x3', '\x1E1', '\x3', '\x1E1', '\x3', '\x1E1', '\x5', 
		'\x1E1', '\x1434', '\n', '\x1E1', '\x3', '\x1E1', '\x3', '\x1E1', '\x5', 
		'\x1E1', '\x1438', '\n', '\x1E1', '\x3', '\x1E2', '\x3', '\x1E2', '\x3', 
		'\x1E2', '\x5', '\x1E2', '\x143D', '\n', '\x1E2', '\x3', '\x1E3', '\x3', 
		'\x1E3', '\x3', '\x1E3', '\x3', '\x1E3', '\x3', '\x1E4', '\x3', '\x1E4', 
		'\x3', '\x1E4', '\x5', '\x1E4', '\x1446', '\n', '\x1E4', '\x3', '\x1E5', 
		'\x5', '\x1E5', '\x1449', '\n', '\x1E5', '\x3', '\x1E5', '\x3', '\x1E5', 
		'\x3', '\x1E6', '\x3', '\x1E6', '\x3', '\x1E6', '\x3', '\x1E7', '\x3', 
		'\x1E7', '\x3', '\x1E7', '\x3', '\x1E8', '\x3', '\x1E8', '\x3', '\x1E8', 
		'\a', '\x1E8', '\x1456', '\n', '\x1E8', '\f', '\x1E8', '\xE', '\x1E8', 
		'\x1459', '\v', '\x1E8', '\x3', '\x1E9', '\x3', '\x1E9', '\x3', '\x1E9', 
		'\a', '\x1E9', '\x145E', '\n', '\x1E9', '\f', '\x1E9', '\xE', '\x1E9', 
		'\x1461', '\v', '\x1E9', '\x3', '\x1EA', '\x3', '\x1EA', '\x3', '\x1EA', 
		'\x3', '\x1EA', '\x3', '\x1EA', '\x3', '\x1EA', '\x3', '\x1EA', '\x3', 
		'\x1EA', '\x3', '\x1EA', '\x3', '\x1EA', '\x3', '\x1EA', '\x3', '\x1EA', 
		'\x3', '\x1EA', '\x3', '\x1EA', '\x3', '\x1EA', '\x3', '\x1EA', '\x5', 
		'\x1EA', '\x1473', '\n', '\x1EA', '\x3', '\x1EB', '\x3', '\x1EB', '\x3', 
		'\x1EC', '\x3', '\x1EC', '\x3', '\x1EC', '\x3', '\x1EC', '\x3', '\x1EC', 
		'\x5', '\x1EC', '\x147C', '\n', '\x1EC', '\x3', '\x1ED', '\x3', '\x1ED', 
		'\x3', '\x1ED', '\x5', '\x1ED', '\x1481', '\n', '\x1ED', '\x3', '\x1ED', 
		'\x5', '\x1ED', '\x1484', '\n', '\x1ED', '\x3', '\x1EE', '\x3', '\x1EE', 
		'\x3', '\x1EE', '\a', '\x1EE', '\x1489', '\n', '\x1EE', '\f', '\x1EE', 
		'\xE', '\x1EE', '\x148C', '\v', '\x1EE', '\x3', '\x1EF', '\x3', '\x1EF', 
		'\x5', '\x1EF', '\x1490', '\n', '\x1EF', '\x3', '\x1F0', '\x3', '\x1F0', 
		'\x3', '\x1F0', '\x3', '\x1F1', '\x3', '\x1F1', '\x3', '\x1F1', '\x3', 
		'\x1F1', '\x3', '\x1F1', '\x5', '\x1F1', '\x149A', '\n', '\x1F1', '\x3', 
		'\x1F2', '\x3', '\x1F2', '\x3', '\x1F2', '\x3', '\x1F2', '\x3', '\x1F2', 
		'\x3', '\x1F3', '\x3', '\x1F3', '\x6', '\x1F3', '\x14A3', '\n', '\x1F3', 
		'\r', '\x1F3', '\xE', '\x1F3', '\x14A4', '\x3', '\x1F4', '\x3', '\x1F4', 
		'\x5', '\x1F4', '\x14A9', '\n', '\x1F4', '\x3', '\x1F4', '\x3', '\x1F4', 
		'\x3', '\x1F5', '\x3', '\x1F5', '\x3', '\x1F5', '\x3', '\x1F5', '\x3', 
		'\x1F6', '\x3', '\x1F6', '\x3', '\x1F6', '\x3', '\x1F6', '\x5', '\x1F6', 
		'\x14B5', '\n', '\x1F6', '\x3', '\x1F7', '\x3', '\x1F7', '\x3', '\x1F7', 
		'\x3', '\x1F7', '\x3', '\x1F7', '\x3', '\x1F8', '\x5', '\x1F8', '\x14BD', 
		'\n', '\x1F8', '\x3', '\x1F8', '\x3', '\x1F8', '\x3', '\x1F8', '\x3', 
		'\x1F8', '\a', '\x1F8', '\x14C3', '\n', '\x1F8', '\f', '\x1F8', '\xE', 
		'\x1F8', '\x14C6', '\v', '\x1F8', '\x3', '\x1F8', '\x3', '\x1F8', '\x5', 
		'\x1F8', '\x14CA', '\n', '\x1F8', '\x3', '\x1F8', '\x3', '\x1F8', '\x5', 
		'\x1F8', '\x14CE', '\n', '\x1F8', '\x5', '\x1F8', '\x14D0', '\n', '\x1F8', 
		'\x3', '\x1F8', '\x5', '\x1F8', '\x14D3', '\n', '\x1F8', '\x3', '\x1F9', 
		'\x3', '\x1F9', '\x3', '\x1F9', '\x3', '\x1F9', '\x3', '\x1F9', '\x5', 
		'\x1F9', '\x14DA', '\n', '\x1F9', '\x3', '\x1FA', '\x3', '\x1FA', '\x3', 
		'\x1FA', '\x3', '\x1FA', '\x3', '\x1FA', '\x5', '\x1FA', '\x14E1', '\n', 
		'\x1FA', '\x3', '\x1FB', '\x3', '\x1FB', '\x3', '\x1FB', '\x3', '\x1FC', 
		'\x3', '\x1FC', '\x3', '\x1FC', '\x3', '\x1FD', '\x3', '\x1FD', '\x5', 
		'\x1FD', '\x14EB', '\n', '\x1FD', '\x3', '\x1FD', '\x3', '\x1FD', '\x3', 
		'\x1FD', '\x3', '\x1FE', '\x3', '\x1FE', '\x5', '\x1FE', '\x14F2', '\n', 
		'\x1FE', '\x3', '\x1FE', '\x3', '\x1FE', '\x3', '\x1FE', '\x3', '\x1FF', 
		'\x3', '\x1FF', '\x5', '\x1FF', '\x14F9', '\n', '\x1FF', '\x3', '\x1FF', 
		'\x3', '\x1FF', '\x3', '\x1FF', '\x3', '\x200', '\x3', '\x200', '\x3', 
		'\x200', '\a', '\x200', '\x1501', '\n', '\x200', '\f', '\x200', '\xE', 
		'\x200', '\x1504', '\v', '\x200', '\x3', '\x201', '\x3', '\x201', '\x5', 
		'\x201', '\x1508', '\n', '\x201', '\x3', '\x201', '\x5', '\x201', '\x150B', 
		'\n', '\x201', '\x3', '\x202', '\x3', '\x202', '\x3', '\x203', '\x3', 
		'\x203', '\x3', '\x203', '\x3', '\x204', '\x3', '\x204', '\x3', '\x204', 
		'\x3', '\x204', '\x3', '\x204', '\x5', '\x204', '\x1517', '\n', '\x204', 
		'\x3', '\x204', '\x3', '\x204', '\x5', '\x204', '\x151B', '\n', '\x204', 
		'\x3', '\x205', '\x3', '\x205', '\x3', '\x206', '\x3', '\x206', '\x3', 
		'\x206', '\x5', '\x206', '\x1522', '\n', '\x206', '\x3', '\x207', '\x3', 
		'\x207', '\x3', '\x207', '\x3', '\x208', '\x3', '\x208', '\x3', '\x208', 
		'\x3', '\x208', '\a', '\x208', '\x152B', '\n', '\x208', '\f', '\x208', 
		'\xE', '\x208', '\x152E', '\v', '\x208', '\x3', '\x209', '\x3', '\x209', 
		'\x5', '\x209', '\x1532', '\n', '\x209', '\x3', '\x209', '\x3', '\x209', 
		'\x5', '\x209', '\x1536', '\n', '\x209', '\x3', '\x209', '\x5', '\x209', 
		'\x1539', '\n', '\x209', '\x3', '\x20A', '\x3', '\x20A', '\x3', '\x20A', 
		'\x3', '\x20A', '\x3', '\x20B', '\x3', '\x20B', '\x3', '\x20B', '\x3', 
		'\x20B', '\x3', '\x20B', '\x3', '\x20B', '\x3', '\x20B', '\x3', '\x20C', 
		'\x3', '\x20C', '\x3', '\x20C', '\x3', '\x20D', '\x3', '\x20D', '\x3', 
		'\x20D', '\x3', '\x20D', '\x3', '\x20D', '\x3', '\x20D', '\x3', '\x20E', 
		'\x3', '\x20E', '\x3', '\x20E', '\x3', '\x20F', '\x3', '\x20F', '\x3', 
		'\x20F', '\x3', '\x210', '\x3', '\x210', '\x5', '\x210', '\x1557', '\n', 
		'\x210', '\x3', '\x210', '\x3', '\x210', '\x3', '\x210', '\x5', '\x210', 
		'\x155C', '\n', '\x210', '\x3', '\x210', '\x3', '\x210', '\x5', '\x210', 
		'\x1560', '\n', '\x210', '\x3', '\x210', '\x3', '\x210', '\x5', '\x210', 
		'\x1564', '\n', '\x210', '\x3', '\x210', '\x3', '\x210', '\x3', '\x210', 
		'\x5', '\x210', '\x1569', '\n', '\x210', '\x3', '\x210', '\x3', '\x210', 
		'\x5', '\x210', '\x156D', '\n', '\x210', '\x3', '\x210', '\x3', '\x210', 
		'\x5', '\x210', '\x1571', '\n', '\x210', '\x5', '\x210', '\x1573', '\n', 
		'\x210', '\x3', '\x211', '\x3', '\x211', '\x3', '\x212', '\x3', '\x212', 
		'\x3', '\x212', '\x3', '\x213', '\x3', '\x213', '\x3', '\x213', '\x3', 
		'\x214', '\x3', '\x214', '\x3', '\x214', '\x3', '\x214', '\x3', '\x215', 
		'\x3', '\x215', '\x3', '\x216', '\x3', '\x216', '\x3', '\x216', '\a', 
		'\x216', '\x1586', '\n', '\x216', '\f', '\x216', '\xE', '\x216', '\x1589', 
		'\v', '\x216', '\x3', '\x217', '\x3', '\x217', '\x5', '\x217', '\x158D', 
		'\n', '\x217', '\x3', '\x218', '\x3', '\x218', '\x3', '\x218', '\x3', 
		'\x218', '\a', '\x218', '\x1593', '\n', '\x218', '\f', '\x218', '\xE', 
		'\x218', '\x1596', '\v', '\x218', '\x3', '\x218', '\x3', '\x218', '\x3', 
		'\x219', '\x3', '\x219', '\x3', '\x219', '\x3', '\x219', '\x5', '\x219', 
		'\x159E', '\n', '\x219', '\x3', '\x21A', '\x3', '\x21A', '\x3', '\x21A', 
		'\x3', '\x21B', '\x3', '\x21B', '\x3', '\x21B', '\x3', '\x21B', '\x3', 
		'\x21B', '\x3', '\x21B', '\x3', '\x21C', '\x3', '\x21C', '\x3', '\x21C', 
		'\a', '\x21C', '\x15AC', '\n', '\x21C', '\f', '\x21C', '\xE', '\x21C', 
		'\x15AF', '\v', '\x21C', '\x3', '\x21D', '\x3', '\x21D', '\x3', '\x21D', 
		'\x5', '\x21D', '\x15B4', '\n', '\x21D', '\x3', '\x21E', '\x3', '\x21E', 
		'\x5', '\x21E', '\x15B8', '\n', '\x21E', '\x3', '\x21F', '\x3', '\x21F', 
		'\x3', '\x21F', '\x3', '\x21F', '\a', '\x21F', '\x15BE', '\n', '\x21F', 
		'\f', '\x21F', '\xE', '\x21F', '\x15C1', '\v', '\x21F', '\x3', '\x21F', 
		'\x3', '\x21F', '\x3', '\x220', '\x3', '\x220', '\x3', '\x220', '\x3', 
		'\x220', '\x3', '\x220', '\x3', '\x221', '\x3', '\x221', '\x3', '\x221', 
		'\a', '\x221', '\x15CD', '\n', '\x221', '\f', '\x221', '\xE', '\x221', 
		'\x15D0', '\v', '\x221', '\x3', '\x222', '\x3', '\x222', '\x5', '\x222', 
		'\x15D4', '\n', '\x222', '\x3', '\x223', '\x3', '\x223', '\x3', '\x223', 
		'\x3', '\x223', '\a', '\x223', '\x15DA', '\n', '\x223', '\f', '\x223', 
		'\xE', '\x223', '\x15DD', '\v', '\x223', '\x3', '\x223', '\x3', '\x223', 
		'\x3', '\x224', '\x3', '\x224', '\x3', '\x224', '\x5', '\x224', '\x15E4', 
		'\n', '\x224', '\x3', '\x224', '\x3', '\x224', '\x3', '\x225', '\x3', 
		'\x225', '\x3', '\x225', '\x3', '\x225', '\x3', '\x226', '\x3', '\x226', 
		'\x3', '\x226', '\x3', '\x227', '\x3', '\x227', '\x3', '\x227', '\x3', 
		'\x227', '\a', '\x227', '\x15F3', '\n', '\x227', '\f', '\x227', '\xE', 
		'\x227', '\x15F6', '\v', '\x227', '\x3', '\x228', '\x3', '\x228', '\x5', 
		'\x228', '\x15FA', '\n', '\x228', '\x3', '\x229', '\x3', '\x229', '\x5', 
		'\x229', '\x15FE', '\n', '\x229', '\x3', '\x229', '\x3', '\x229', '\x3', 
		'\x229', '\x3', '\x229', '\x5', '\x229', '\x1604', '\n', '\x229', '\x3', 
		'\x229', '\x3', '\x229', '\x3', '\x229', '\a', '\x229', '\x1609', '\n', 
		'\x229', '\f', '\x229', '\xE', '\x229', '\x160C', '\v', '\x229', '\x3', 
		'\x22A', '\x3', '\x22A', '\x3', '\x22A', '\x3', '\x22A', '\x3', '\x22A', 
		'\x5', '\x22A', '\x1613', '\n', '\x22A', '\x3', '\x22A', '\x5', '\x22A', 
		'\x1616', '\n', '\x22A', '\x3', '\x22B', '\x3', '\x22B', '\x5', '\x22B', 
		'\x161A', '\n', '\x22B', '\x3', '\x22B', '\x3', '\x22B', '\x3', '\x22C', 
		'\x3', '\x22C', '\x5', '\x22C', '\x1620', '\n', '\x22C', '\x3', '\x22D', 
		'\x3', '\x22D', '\x3', '\x22D', '\x3', '\x22E', '\x3', '\x22E', '\x3', 
		'\x22E', '\x3', '\x22E', '\x3', '\x22E', '\a', '\x22E', '\x162A', '\n', 
		'\x22E', '\f', '\x22E', '\xE', '\x22E', '\x162D', '\v', '\x22E', '\x3', 
		'\x22E', '\x3', '\x22E', '\x3', '\x22F', '\x3', '\x22F', '\x3', '\x22F', 
		'\x3', '\x22F', '\x3', '\x22F', '\x3', '\x22F', '\x3', '\x230', '\x3', 
		'\x230', '\x3', '\x230', '\x3', '\x230', '\x3', '\x230', '\x3', '\x231', 
		'\x3', '\x231', '\x3', '\x231', '\x5', '\x231', '\x163F', '\n', '\x231', 
		'\x3', '\x231', '\x5', '\x231', '\x1642', '\n', '\x231', '\x3', '\x231', 
		'\x3', '\x231', '\x3', '\x231', '\x3', '\x231', '\x3', '\x231', '\x3', 
		'\x231', '\x3', '\x231', '\x3', '\x231', '\x5', '\x231', '\x164C', '\n', 
		'\x231', '\x3', '\x231', '\x5', '\x231', '\x164F', '\n', '\x231', '\x3', 
		'\x231', '\x3', '\x231', '\x5', '\x231', '\x1653', '\n', '\x231', '\x3', 
		'\x231', '\x5', '\x231', '\x1656', '\n', '\x231', '\x3', '\x232', '\x3', 
		'\x232', '\x3', '\x232', '\x3', '\x232', '\x3', '\x232', '\x5', '\x232', 
		'\x165D', '\n', '\x232', '\x3', '\x232', '\x3', '\x232', '\x5', '\x232', 
		'\x1661', '\n', '\x232', '\x3', '\x232', '\a', '\x232', '\x1664', '\n', 
		'\x232', '\f', '\x232', '\xE', '\x232', '\x1667', '\v', '\x232', '\x3', 
		'\x232', '\x3', '\x232', '\x3', '\x232', '\x3', '\x233', '\x3', '\x233', 
		'\x3', '\x233', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x235', '\x3', '\x235', '\x5', '\x235', '\x1674', '\n', '\x235', '\x3', 
		'\x236', '\x3', '\x236', '\x3', '\x236', '\x3', '\x236', '\x3', '\x236', 
		'\a', '\x236', '\x167B', '\n', '\x236', '\f', '\x236', '\xE', '\x236', 
		'\x167E', '\v', '\x236', '\x3', '\x236', '\x3', '\x236', '\x3', '\x237', 
		'\x3', '\x237', '\x3', '\x237', '\x3', '\x237', '\x3', '\x237', '\x5', 
		'\x237', '\x1687', '\n', '\x237', '\x3', '\x238', '\x3', '\x238', '\x5', 
		'\x238', '\x168B', '\n', '\x238', '\x3', '\x238', '\x3', '\x238', '\x3', 
		'\x238', '\x5', '\x238', '\x1690', '\n', '\x238', '\x3', '\x238', '\a', 
		'\x238', '\x1693', '\n', '\x238', '\f', '\x238', '\xE', '\x238', '\x1696', 
		'\v', '\x238', '\x3', '\x239', '\x3', '\x239', '\x3', '\x239', '\x3', 
		'\x23A', '\x3', '\x23A', '\x3', '\x23A', '\x3', '\x23B', '\x3', '\x23B', 
		'\x5', '\x23B', '\x16A0', '\n', '\x23B', '\x3', '\x23B', '\x5', '\x23B', 
		'\x16A3', '\n', '\x23B', '\x3', '\x23B', '\x3', '\x23B', '\x3', '\x23B', 
		'\x5', '\x23B', '\x16A8', '\n', '\x23B', '\x3', '\x23B', '\x3', '\x23B', 
		'\x5', '\x23B', '\x16AC', '\n', '\x23B', '\x3', '\x23B', '\a', '\x23B', 
		'\x16AF', '\n', '\x23B', '\f', '\x23B', '\xE', '\x23B', '\x16B2', '\v', 
		'\x23B', '\x3', '\x23C', '\x3', '\x23C', '\x5', '\x23C', '\x16B6', '\n', 
		'\x23C', '\x3', '\x23C', '\x5', '\x23C', '\x16B9', '\n', '\x23C', '\x3', 
		'\x23C', '\x5', '\x23C', '\x16BC', '\n', '\x23C', '\x3', '\x23C', '\x3', 
		'\x23C', '\x3', '\x23D', '\x3', '\x23D', '\x3', '\x23D', '\x3', '\x23E', 
		'\x3', '\x23E', '\x3', '\x23E', '\x3', '\x23E', '\x5', '\x23E', '\x16C7', 
		'\n', '\x23E', '\x5', '\x23E', '\x16C9', '\n', '\x23E', '\x3', '\x23E', 
		'\x3', '\x23E', '\x3', '\x23F', '\x3', '\x23F', '\x5', '\x23F', '\x16CF', 
		'\n', '\x23F', '\x3', '\x23F', '\x5', '\x23F', '\x16D2', '\n', '\x23F', 
		'\x3', '\x23F', '\x3', '\x23F', '\x5', '\x23F', '\x16D6', '\n', '\x23F', 
		'\x3', '\x23F', '\a', '\x23F', '\x16D9', '\n', '\x23F', '\f', '\x23F', 
		'\xE', '\x23F', '\x16DC', '\v', '\x23F', '\x3', '\x240', '\x3', '\x240', 
		'\x3', '\x240', '\x3', '\x241', '\x3', '\x241', '\x3', '\x241', '\x3', 
		'\x241', '\x5', '\x241', '\x16E5', '\n', '\x241', '\x3', '\x241', '\x3', 
		'\x241', '\x3', '\x242', '\x3', '\x242', '\x5', '\x242', '\x16EB', '\n', 
		'\x242', '\x3', '\x242', '\x3', '\x242', '\x3', '\x242', '\x3', '\x243', 
		'\x3', '\x243', '\x3', '\x243', '\x3', '\x243', '\x3', '\x244', '\x3', 
		'\x244', '\x5', '\x244', '\x16F6', '\n', '\x244', '\x3', '\x244', '\x3', 
		'\x244', '\x5', '\x244', '\x16FA', '\n', '\x244', '\x5', '\x244', '\x16FC', 
		'\n', '\x244', '\x3', '\x245', '\x3', '\x245', '\x3', '\x245', '\x3', 
		'\x245', '\x3', '\x245', '\x5', '\x245', '\x1703', '\n', '\x245', '\x3', 
		'\x245', '\x3', '\x245', '\x3', '\x245', '\x3', '\x245', '\x3', '\x246', 
		'\x3', '\x246', '\x3', '\x246', '\x5', '\x246', '\x170C', '\n', '\x246', 
		'\x3', '\x246', '\x3', '\x246', '\x5', '\x246', '\x1710', '\n', '\x246', 
		'\x3', '\x246', '\x3', '\x246', '\x3', '\x247', '\x5', '\x247', '\x1715', 
		'\n', '\x247', '\x3', '\x247', '\x3', '\x247', '\x3', '\x247', '\x3', 
		'\x247', '\a', '\x247', '\x171B', '\n', '\x247', '\f', '\x247', '\xE', 
		'\x247', '\x171E', '\v', '\x247', '\x5', '\x247', '\x1720', '\n', '\x247', 
		'\x3', '\x248', '\x3', '\x248', '\x3', '\x248', '\x5', '\x248', '\x1725', 
		'\n', '\x248', '\x3', '\x248', '\x3', '\x248', '\x3', '\x249', '\x3', 
		'\x249', '\x3', '\x249', '\x3', '\x249', '\x3', '\x249', '\x3', '\x249', 
		'\x5', '\x249', '\x172F', '\n', '\x249', '\x3', '\x249', '\x3', '\x249', 
		'\x5', '\x249', '\x1733', '\n', '\x249', '\x5', '\x249', '\x1735', '\n', 
		'\x249', '\x3', '\x24A', '\x3', '\x24A', '\x5', '\x24A', '\x1739', '\n', 
		'\x24A', '\x3', '\x24B', '\x3', '\x24B', '\x5', '\x24B', '\x173D', '\n', 
		'\x24B', '\x3', '\x24B', '\x3', '\x24B', '\x3', '\x24C', '\x3', '\x24C', 
		'\x3', '\x24C', '\x3', '\x24C', '\x3', '\x24C', '\x3', '\x24C', '\x3', 
		'\x24D', '\x3', '\x24D', '\x3', '\x24D', '\x3', '\x24E', '\x3', '\x24E', 
		'\x5', '\x24E', '\x174C', '\n', '\x24E', '\x3', '\x24F', '\x3', '\x24F', 
		'\x3', '\x24F', '\x3', '\x24F', '\x3', '\x250', '\x3', '\x250', '\x3', 
		'\x250', '\x5', '\x250', '\x1755', '\n', '\x250', '\x3', '\x251', '\x3', 
		'\x251', '\x3', '\x251', '\x3', '\x251', '\a', '\x251', '\x175B', '\n', 
		'\x251', '\f', '\x251', '\xE', '\x251', '\x175E', '\v', '\x251', '\x3', 
		'\x251', '\x3', '\x251', '\x3', '\x252', '\x3', '\x252', '\x3', '\x252', 
		'\x5', '\x252', '\x1765', '\n', '\x252', '\x5', '\x252', '\x1767', '\n', 
		'\x252', '\x3', '\x253', '\x3', '\x253', '\x3', '\x254', '\x3', '\x254', 
		'\x5', '\x254', '\x176D', '\n', '\x254', '\x3', '\x255', '\x3', '\x255', 
		'\x3', '\x255', '\x3', '\x255', '\x3', '\x256', '\x3', '\x256', '\x3', 
		'\x256', '\x3', '\x256', '\x3', '\x256', '\x5', '\x256', '\x1778', '\n', 
		'\x256', '\x3', '\x256', '\x3', '\x256', '\x3', '\x257', '\x3', '\x257', 
		'\x3', '\x257', '\x3', '\x257', '\x3', '\x257', '\x3', '\x257', '\x3', 
		'\x258', '\x3', '\x258', '\x3', '\x258', '\x3', '\x259', '\x3', '\x259', 
		'\x3', '\x259', '\x3', '\x259', '\a', '\x259', '\x1789', '\n', '\x259', 
		'\f', '\x259', '\xE', '\x259', '\x178C', '\v', '\x259', '\x3', '\x259', 
		'\x3', '\x259', '\x3', '\x25A', '\x3', '\x25A', '\x5', '\x25A', '\x1792', 
		'\n', '\x25A', '\x3', '\x25B', '\x3', '\x25B', '\x3', '\x25B', '\x3', 
		'\x25C', '\x3', '\x25C', '\x5', '\x25C', '\x1799', '\n', '\x25C', '\x3', 
		'\x25D', '\x3', '\x25D', '\x3', '\x25D', '\x3', '\x25D', '\a', '\x25D', 
		'\x179F', '\n', '\x25D', '\f', '\x25D', '\xE', '\x25D', '\x17A2', '\v', 
		'\x25D', '\x3', '\x25D', '\x3', '\x25D', '\x3', '\x25E', '\x3', '\x25E', 
		'\x5', '\x25E', '\x17A8', '\n', '\x25E', '\x3', '\x25F', '\x3', '\x25F', 
		'\x3', '\x25F', '\x3', '\x25F', '\x3', '\x25F', '\x3', '\x25F', '\x5', 
		'\x25F', '\x17B0', '\n', '\x25F', '\x3', '\x260', '\x3', '\x260', '\x3', 
		'\x260', '\x3', '\x260', '\x5', '\x260', '\x17B6', '\n', '\x260', '\x3', 
		'\x260', '\x3', '\x260', '\x3', '\x260', '\x3', '\x260', '\x3', '\x261', 
		'\x3', '\x261', '\x3', '\x261', '\x3', '\x261', '\x3', '\x261', '\x5', 
		'\x261', '\x17C1', '\n', '\x261', '\x3', '\x262', '\x3', '\x262', '\x3', 
		'\x263', '\x3', '\x263', '\x5', '\x263', '\x17C7', '\n', '\x263', '\x3', 
		'\x263', '\x3', '\x263', '\x5', '\x263', '\x17CB', '\n', '\x263', '\x3', 
		'\x264', '\x3', '\x264', '\x3', '\x264', '\x3', '\x265', '\x3', '\x265', 
		'\x3', '\x265', '\x3', '\x265', '\x3', '\x266', '\x5', '\x266', '\x17D5', 
		'\n', '\x266', '\x3', '\x266', '\x3', '\x266', '\x3', '\x267', '\x3', 
		'\x267', '\x3', '\x268', '\x3', '\x268', '\x3', '\x268', '\x3', '\x268', 
		'\x3', '\x269', '\x3', '\x269', '\x3', '\x269', '\x3', '\x269', '\x3', 
		'\x269', '\x3', '\x269', '\x5', '\x269', '\x17E5', '\n', '\x269', '\x3', 
		'\x26A', '\x3', '\x26A', '\x3', '\x26B', '\x3', '\x26B', '\x3', '\x26B', 
		'\x3', '\x26B', '\x5', '\x26B', '\x17ED', '\n', '\x26B', '\x3', '\x26C', 
		'\x3', '\x26C', '\x3', '\x26C', '\x5', '\x26C', '\x17F2', '\n', '\x26C', 
		'\x3', '\x26C', '\x3', '\x26C', '\x5', '\x26C', '\x17F6', '\n', '\x26C', 
		'\x3', '\x26C', '\x5', '\x26C', '\x17F9', '\n', '\x26C', '\x3', '\x26C', 
		'\x5', '\x26C', '\x17FC', '\n', '\x26C', '\x3', '\x26D', '\x3', '\x26D', 
		'\x6', '\x26D', '\x1800', '\n', '\x26D', '\r', '\x26D', '\xE', '\x26D', 
		'\x1801', '\x3', '\x26D', '\x3', '\x26D', '\x3', '\x26E', '\x3', '\x26E', 
		'\x3', '\x26E', '\x5', '\x26E', '\x1809', '\n', '\x26E', '\x3', '\x26E', 
		'\x5', '\x26E', '\x180C', '\n', '\x26E', '\x3', '\x26E', '\x5', '\x26E', 
		'\x180F', '\n', '\x26E', '\x3', '\x26F', '\x5', '\x26F', '\x1812', '\n', 
		'\x26F', '\x3', '\x26F', '\x6', '\x26F', '\x1815', '\n', '\x26F', '\r', 
		'\x26F', '\xE', '\x26F', '\x1816', '\x3', '\x26F', '\x5', '\x26F', '\x181A', 
		'\n', '\x26F', '\x3', '\x26F', '\x3', '\x26F', '\x3', '\x270', '\x3', 
		'\x270', '\x3', '\x270', '\x3', '\x270', '\x3', '\x271', '\x3', '\x271', 
		'\x6', '\x271', '\x1824', '\n', '\x271', '\r', '\x271', '\xE', '\x271', 
		'\x1825', '\x3', '\x272', '\x3', '\x272', '\x6', '\x272', '\x182A', '\n', 
		'\x272', '\r', '\x272', '\xE', '\x272', '\x182B', '\x3', '\x273', '\x3', 
		'\x273', '\x3', '\x273', '\x3', '\x273', '\x3', '\x273', '\a', '\x273', 
		'\x1833', '\n', '\x273', '\f', '\x273', '\xE', '\x273', '\x1836', '\v', 
		'\x273', '\x5', '\x273', '\x1838', '\n', '\x273', '\x3', '\x274', '\x3', 
		'\x274', '\x3', '\x274', '\x3', '\x274', '\x3', '\x274', '\x3', '\x274', 
		'\x3', '\x274', '\x3', '\x275', '\x3', '\x275', '\x3', '\x275', '\x3', 
		'\x275', '\x3', '\x275', '\x5', '\x275', '\x1846', '\n', '\x275', '\x3', 
		'\x275', '\x3', '\x275', '\x3', '\x275', '\x3', '\x275', '\x5', '\x275', 
		'\x184C', '\n', '\x275', '\x3', '\x275', '\x3', '\x275', '\x3', '\x275', 
		'\x3', '\x275', '\x5', '\x275', '\x1852', '\n', '\x275', '\x3', '\x276', 
		'\x3', '\x276', '\x3', '\x276', '\x3', '\x276', '\x3', '\x277', '\x3', 
		'\x277', '\x3', '\x277', '\x5', '\x277', '\x185B', '\n', '\x277', '\x3', 
		'\x277', '\x3', '\x277', '\x5', '\x277', '\x185F', '\n', '\x277', '\x3', 
		'\x277', '\x5', '\x277', '\x1862', '\n', '\x277', '\x3', '\x277', '\x5', 
		'\x277', '\x1865', '\n', '\x277', '\x3', '\x278', '\x3', '\x278', '\x5', 
		'\x278', '\x1869', '\n', '\x278', '\x3', '\x278', '\x3', '\x278', '\x5', 
		'\x278', '\x186D', '\n', '\x278', '\x3', '\x278', '\x5', '\x278', '\x1870', 
		'\n', '\x278', '\x3', '\x278', '\x5', '\x278', '\x1873', '\n', '\x278', 
		'\x3', '\x278', '\x5', '\x278', '\x1876', '\n', '\x278', '\x3', '\x279', 
		'\x3', '\x279', '\x3', '\x279', '\x3', '\x27A', '\x3', '\x27A', '\x3', 
		'\x27A', '\x3', '\x27A', '\x5', '\x27A', '\x187F', '\n', '\x27A', '\x3', 
		'\x27A', '\x5', '\x27A', '\x1882', '\n', '\x27A', '\x3', '\x27B', '\x3', 
		'\x27B', '\x3', '\x27B', '\x3', '\x27C', '\x3', '\x27C', '\x3', '\x27C', 
		'\x3', '\x27C', '\x3', '\x27C', '\x3', '\x27D', '\x3', '\x27D', '\x3', 
		'\x27D', '\x3', '\x27E', '\x3', '\x27E', '\x3', '\x27E', '\x5', '\x27E', 
		'\x1892', '\n', '\x27E', '\x3', '\x27F', '\x3', '\x27F', '\x3', '\x27F', 
		'\x3', '\x27F', '\x5', '\x27F', '\x1898', '\n', '\x27F', '\x5', '\x27F', 
		'\x189A', '\n', '\x27F', '\x3', '\x280', '\x3', '\x280', '\x3', '\x280', 
		'\x3', '\x280', '\a', '\x280', '\x18A0', '\n', '\x280', '\f', '\x280', 
		'\xE', '\x280', '\x18A3', '\v', '\x280', '\x3', '\x281', '\x3', '\x281', 
		'\x3', '\x281', '\x3', '\x281', '\x5', '\x281', '\x18A9', '\n', '\x281', 
		'\x3', '\x281', '\x3', '\x281', '\x3', '\x282', '\x3', '\x282', '\x5', 
		'\x282', '\x18AF', '\n', '\x282', '\x3', '\x282', '\x3', '\x282', '\x5', 
		'\x282', '\x18B3', '\n', '\x282', '\x3', '\x282', '\x3', '\x282', '\x5', 
		'\x282', '\x18B7', '\n', '\x282', '\x3', '\x283', '\x3', '\x283', '\x3', 
		'\x283', '\x3', '\x284', '\x3', '\x284', '\x5', '\x284', '\x18BE', '\n', 
		'\x284', '\x3', '\x284', '\x5', '\x284', '\x18C1', '\n', '\x284', '\x3', 
		'\x285', '\x3', '\x285', '\x3', '\x285', '\x3', '\x285', '\x5', '\x285', 
		'\x18C7', '\n', '\x285', '\x3', '\x286', '\x3', '\x286', '\x3', '\x286', 
		'\x3', '\x286', '\x3', '\x286', '\x5', '\x286', '\x18CE', '\n', '\x286', 
		'\x3', '\x286', '\x5', '\x286', '\x18D1', '\n', '\x286', '\x3', '\x286', 
		'\x5', '\x286', '\x18D4', '\n', '\x286', '\x3', '\x287', '\x3', '\x287', 
		'\x3', '\x287', '\x3', '\x288', '\x3', '\x288', '\x5', '\x288', '\x18DB', 
		'\n', '\x288', '\x3', '\x289', '\x3', '\x289', '\x3', '\x289', '\x3', 
		'\x289', '\x3', '\x289', '\x5', '\x289', '\x18E2', '\n', '\x289', '\x3', 
		'\x28A', '\x3', '\x28A', '\x3', '\x28A', '\x3', '\x28A', '\x3', '\x28A', 
		'\x3', '\x28B', '\x3', '\x28B', '\x5', '\x28B', '\x18EB', '\n', '\x28B', 
		'\x3', '\x28B', '\x5', '\x28B', '\x18EE', '\n', '\x28B', '\x3', '\x28C', 
		'\x3', '\x28C', '\x5', '\x28C', '\x18F2', '\n', '\x28C', '\x3', '\x28C', 
		'\x3', '\x28C', '\x3', '\x28D', '\x3', '\x28D', '\x3', '\x28D', '\x3', 
		'\x28E', '\x3', '\x28E', '\x3', '\x28E', '\x3', '\x28E', '\x3', '\x28F', 
		'\x3', '\x28F', '\x3', '\x28F', '\x5', '\x28F', '\x1900', '\n', '\x28F', 
		'\x3', '\x28F', '\x5', '\x28F', '\x1903', '\n', '\x28F', '\x3', '\x28F', 
		'\x5', '\x28F', '\x1906', '\n', '\x28F', '\x3', '\x290', '\x3', '\x290', 
		'\x3', '\x290', '\x3', '\x291', '\x3', '\x291', '\x3', '\x291', '\x3', 
		'\x291', '\x3', '\x292', '\x3', '\x292', '\x3', '\x292', '\x3', '\x292', 
		'\x5', '\x292', '\x1913', '\n', '\x292', '\x3', '\x293', '\x3', '\x293', 
		'\x3', '\x293', '\x3', '\x293', '\x3', '\x293', '\x3', '\x293', '\x5', 
		'\x293', '\x191B', '\n', '\x293', '\x3', '\x293', '\x5', '\x293', '\x191E', 
		'\n', '\x293', '\x3', '\x294', '\x3', '\x294', '\x5', '\x294', '\x1922', 
		'\n', '\x294', '\x3', '\x294', '\x3', '\x294', '\x5', '\x294', '\x1926', 
		'\n', '\x294', '\x5', '\x294', '\x1928', '\n', '\x294', '\x3', '\x295', 
		'\x3', '\x295', '\x3', '\x295', '\x3', '\x296', '\x3', '\x296', '\x3', 
		'\x296', '\x3', '\x296', '\x3', '\x296', '\x3', '\x297', '\x3', '\x297', 
		'\x3', '\x297', '\x3', '\x297', '\x3', '\x297', '\x3', '\x297', '\x5', 
		'\x297', '\x1938', '\n', '\x297', '\x3', '\x297', '\x5', '\x297', '\x193B', 
		'\n', '\x297', '\x3', '\x298', '\x3', '\x298', '\x3', '\x298', '\x3', 
		'\x299', '\x3', '\x299', '\x3', '\x299', '\x3', '\x299', '\x3', '\x299', 
		'\x3', '\x299', '\x5', '\x299', '\x1946', '\n', '\x299', '\x3', '\x299', 
		'\x3', '\x299', '\x5', '\x299', '\x194A', '\n', '\x299', '\x3', '\x29A', 
		'\x3', '\x29A', '\x3', '\x29A', '\x3', '\x29A', '\x3', '\x29A', '\x5', 
		'\x29A', '\x1951', '\n', '\x29A', '\x3', '\x29A', '\x5', '\x29A', '\x1954', 
		'\n', '\x29A', '\x3', '\x29A', '\x5', '\x29A', '\x1957', '\n', '\x29A', 
		'\x3', '\x29B', '\x3', '\x29B', '\x3', '\x29B', '\x3', '\x29C', '\x3', 
		'\x29C', '\x3', '\x29C', '\x3', '\x29C', '\x3', '\x29C', '\x3', '\x29C', 
		'\x3', '\x29D', '\x3', '\x29D', '\x5', '\x29D', '\x1964', '\n', '\x29D', 
		'\x3', '\x29E', '\x3', '\x29E', '\x3', '\x29E', '\x3', '\x29E', '\x5', 
		'\x29E', '\x196A', '\n', '\x29E', '\x3', '\x29E', '\x5', '\x29E', '\x196D', 
		'\n', '\x29E', '\x3', '\x29F', '\x3', '\x29F', '\x3', '\x29F', '\x3', 
		'\x29F', '\x3', '\x29F', '\x3', '\x2A0', '\x3', '\x2A0', '\x3', '\x2A1', 
		'\x3', '\x2A1', '\x3', '\x2A1', '\x3', '\x2A1', '\x5', '\x2A1', '\x197A', 
		'\n', '\x2A1', '\x3', '\x2A2', '\x3', '\x2A2', '\x3', '\x2A2', '\x3', 
		'\x2A3', '\x3', '\x2A3', '\x3', '\x2A3', '\x3', '\x2A3', '\x3', '\x2A3', 
		'\x5', '\x2A3', '\x1984', '\n', '\x2A3', '\x3', '\x2A4', '\x3', '\x2A4', 
		'\x3', '\x2A4', '\a', '\x2A4', '\x1989', '\n', '\x2A4', '\f', '\x2A4', 
		'\xE', '\x2A4', '\x198C', '\v', '\x2A4', '\x3', '\x2A5', '\x3', '\x2A5', 
		'\x3', '\x2A5', '\x3', '\x2A5', '\x3', '\x2A5', '\x3', '\x2A5', '\x3', 
		'\x2A5', '\x5', '\x2A5', '\x1995', '\n', '\x2A5', '\x3', '\x2A5', '\x5', 
		'\x2A5', '\x1998', '\n', '\x2A5', '\x3', '\x2A5', '\x3', '\x2A5', '\x3', 
		'\x2A6', '\x3', '\x2A6', '\x3', '\x2A7', '\x3', '\x2A7', '\x3', '\x2A7', 
		'\x3', '\x2A7', '\x3', '\x2A7', '\x3', '\x2A7', '\x3', '\x2A7', '\x3', 
		'\x2A8', '\x3', '\x2A8', '\x3', '\x2A8', '\x3', '\x2A8', '\x3', '\x2A8', 
		'\x3', '\x2A8', '\x3', '\x2A8', '\x3', '\x2A8', '\x3', '\x2A8', '\x3', 
		'\x2A8', '\x3', '\x2A8', '\x3', '\x2A8', '\x5', '\x2A8', '\x19B1', '\n', 
		'\x2A8', '\x3', '\x2A9', '\x3', '\x2A9', '\x3', '\x2A9', '\x3', '\x2A9', 
		'\x3', '\x2A9', '\x3', '\x2A9', '\x5', '\x2A9', '\x19B9', '\n', '\x2A9', 
		'\x3', '\x2AA', '\x3', '\x2AA', '\x3', '\x2AA', '\x3', '\x2AA', '\x5', 
		'\x2AA', '\x19BF', '\n', '\x2AA', '\x3', '\x2AA', '\x3', '\x2AA', '\x3', 
		'\x2AA', '\x3', '\x2AA', '\x3', '\x2AA', '\x5', '\x2AA', '\x19C6', '\n', 
		'\x2AA', '\x3', '\x2AB', '\x3', '\x2AB', '\x3', '\x2AB', '\x3', '\x2AB', 
		'\x5', '\x2AB', '\x19CC', '\n', '\x2AB', '\x3', '\x2AC', '\x3', '\x2AC', 
		'\x3', '\x2AC', '\x3', '\x2AC', '\x5', '\x2AC', '\x19D2', '\n', '\x2AC', 
		'\x3', '\x2AD', '\x3', '\x2AD', '\x3', '\x2AD', '\x3', '\x2AD', '\x5', 
		'\x2AD', '\x19D8', '\n', '\x2AD', '\x3', '\x2AE', '\x3', '\x2AE', '\x3', 
		'\x2AE', '\x3', '\x2AE', '\x3', '\x2AF', '\x3', '\x2AF', '\x3', '\x2AF', 
		'\x3', '\x2AF', '\x3', '\x2B0', '\x3', '\x2B0', '\x3', '\x2B0', '\x3', 
		'\x2B1', '\x3', '\x2B1', '\x3', '\x2B1', '\x3', '\x2B1', '\a', '\x2B1', 
		'\x19E9', '\n', '\x2B1', '\f', '\x2B1', '\xE', '\x2B1', '\x19EC', '\v', 
		'\x2B1', '\x3', '\x2B1', '\x5', '\x2B1', '\x19EF', '\n', '\x2B1', '\x3', 
		'\x2B1', '\x3', '\x2B1', '\x3', '\x2B1', '\x3', '\x2B2', '\x3', '\x2B2', 
		'\x3', '\x2B2', '\x3', '\x2B3', '\x3', '\x2B3', '\x3', '\x2B3', '\x3', 
		'\x2B4', '\x3', '\x2B4', '\x3', '\x2B4', '\x3', '\x2B4', '\x3', '\x2B5', 
		'\x3', '\x2B5', '\x3', '\x2B5', '\x3', '\x2B5', '\a', '\x2B5', '\x1A02', 
		'\n', '\x2B5', '\f', '\x2B5', '\xE', '\x2B5', '\x1A05', '\v', '\x2B5', 
		'\x3', '\x2B5', '\x5', '\x2B5', '\x1A08', '\n', '\x2B5', '\x3', '\x2B5', 
		'\x3', '\x2B5', '\x3', '\x2B6', '\x3', '\x2B6', '\x3', '\x2B6', '\a', 
		'\x2B6', '\x1A0F', '\n', '\x2B6', '\f', '\x2B6', '\xE', '\x2B6', '\x1A12', 
		'\v', '\x2B6', '\x3', '\x2B7', '\x3', '\x2B7', '\x3', '\x2B7', '\a', '\x2B7', 
		'\x1A17', '\n', '\x2B7', '\f', '\x2B7', '\xE', '\x2B7', '\x1A1A', '\v', 
		'\x2B7', '\x3', '\x2B8', '\x3', '\x2B8', '\x3', '\x2B8', '\x3', '\x2B8', 
		'\x3', '\x2B9', '\x3', '\x2B9', '\x3', '\x2B9', '\x3', '\x2B9', '\x3', 
		'\x2BA', '\x3', '\x2BA', '\x3', '\x2BB', '\x3', '\x2BB', '\x3', '\x2BB', 
		'\x3', '\x2BB', '\x3', '\x2BC', '\x3', '\x2BC', '\x3', '\x2BC', '\x3', 
		'\x2BC', '\x3', '\x2BD', '\x3', '\x2BD', '\x3', '\x2BD', '\x3', '\x2BD', 
		'\x5', '\x2BD', '\x1A32', '\n', '\x2BD', '\x3', '\x2BE', '\x3', '\x2BE', 
		'\x3', '\x2BE', '\x3', '\x2BE', '\x3', '\x2BE', '\x3', '\x2BF', '\x3', 
		'\x2BF', '\x5', '\x2BF', '\x1A3B', '\n', '\x2BF', '\x3', '\x2BF', '\x3', 
		'\x2BF', '\x3', '\x2BF', '\x5', '\x2BF', '\x1A40', '\n', '\x2BF', '\x3', 
		'\x2C0', '\x3', '\x2C0', '\x5', '\x2C0', '\x1A44', '\n', '\x2C0', '\x3', 
		'\x2C1', '\x3', '\x2C1', '\x3', '\x2C1', '\x5', '\x2C1', '\x1A49', '\n', 
		'\x2C1', '\x3', '\x2C1', '\x3', '\x2C1', '\x3', '\x2C1', '\x3', '\x2C1', 
		'\x5', '\x2C1', '\x1A4F', '\n', '\x2C1', '\x3', '\x2C2', '\x3', '\x2C2', 
		'\x6', '\x2C2', '\x1A53', '\n', '\x2C2', '\r', '\x2C2', '\xE', '\x2C2', 
		'\x1A54', '\x3', '\x2C2', '\x5', '\x2C2', '\x1A58', '\n', '\x2C2', '\x3', 
		'\x2C3', '\x6', '\x2C3', '\x1A5B', '\n', '\x2C3', '\r', '\x2C3', '\xE', 
		'\x2C3', '\x1A5C', '\x3', '\x2C3', '\x5', '\x2C3', '\x1A60', '\n', '\x2C3', 
		'\x3', '\x2C4', '\x3', '\x2C4', '\x3', '\x2C4', '\x3', '\x2C4', '\x3', 
		'\x2C5', '\x5', '\x2C5', '\x1A67', '\n', '\x2C5', '\x3', '\x2C5', '\x3', 
		'\x2C5', '\x3', '\x2C6', '\x3', '\x2C6', '\x3', '\x2C6', '\x5', '\x2C6', 
		'\x1A6E', '\n', '\x2C6', '\x3', '\x2C6', '\x3', '\x2C6', '\x3', '\x2C7', 
		'\x3', '\x2C7', '\x3', '\x2C7', '\x5', '\x2C7', '\x1A75', '\n', '\x2C7', 
		'\x3', '\x2C8', '\x3', '\x2C8', '\x6', '\x2C8', '\x1A79', '\n', '\x2C8', 
		'\r', '\x2C8', '\xE', '\x2C8', '\x1A7A', '\x3', '\x2C9', '\x3', '\x2C9', 
		'\x3', '\x2C9', '\x3', '\x2C9', '\x3', '\x2CA', '\x3', '\x2CA', '\x3', 
		'\x2CA', '\a', '\x2CA', '\x1A84', '\n', '\x2CA', '\f', '\x2CA', '\xE', 
		'\x2CA', '\x1A87', '\v', '\x2CA', '\x3', '\x2CB', '\x3', '\x2CB', '\x3', 
		'\x2CB', '\x3', '\x2CC', '\x3', '\x2CC', '\x3', '\x2CD', '\x3', '\x2CD', 
		'\x3', '\x2CD', '\x3', '\x2CD', '\x3', '\x2CD', '\x3', '\x2CD', '\x3', 
		'\x2CE', '\x3', '\x2CE', '\x3', '\x2CF', '\x3', '\x2CF', '\x5', '\x2CF', 
		'\x1A98', '\n', '\x2CF', '\x3', '\x2D0', '\x3', '\x2D0', '\x3', '\x2D1', 
		'\x3', '\x2D1', '\x5', '\x2D1', '\x1A9E', '\n', '\x2D1', '\x3', '\x2D2', 
		'\x3', '\x2D2', '\x3', '\x2D2', '\x5', '\x2D2', '\x1AA3', '\n', '\x2D2', 
		'\x5', '\x2D2', '\x1AA5', '\n', '\x2D2', '\x3', '\x2D3', '\x3', '\x2D3', 
		'\x3', '\x2D3', '\x3', '\x2D4', '\x6', '\x2D4', '\x1AAB', '\n', '\x2D4', 
		'\r', '\x2D4', '\xE', '\x2D4', '\x1AAC', '\x3', '\x2D4', '\x3', '\x2D4', 
		'\a', '\x2D4', '\x1AB1', '\n', '\x2D4', '\f', '\x2D4', '\xE', '\x2D4', 
		'\x1AB4', '\v', '\x2D4', '\x5', '\x2D4', '\x1AB6', '\n', '\x2D4', '\x3', 
		'\x2D5', '\x3', '\x2D5', '\x3', '\x2D5', '\x3', '\x2D5', '\x3', '\x2D5', 
		'\x3', '\x2D5', '\x3', '\x2D5', '\x3', '\x2D5', '\x3', '\x2D5', '\x5', 
		'\x2D5', '\x1AC1', '\n', '\x2D5', '\x3', '\x2D5', '\x3', '\x2D5', '\x5', 
		'\x2D5', '\x1AC5', '\n', '\x2D5', '\x3', '\x2D6', '\x3', '\x2D6', '\x3', 
		'\x2D6', '\x3', '\x2D7', '\x3', '\x2D7', '\x3', '\x2D8', '\x3', '\x2D8', 
		'\x3', '\x2D8', '\x3', '\x2D9', '\x3', '\x2D9', '\x3', '\x2D9', '\x3', 
		'\x2DA', '\x3', '\x2DA', '\x3', '\x2DA', '\x3', '\x2DB', '\x3', '\x2DB', 
		'\x3', '\x2DB', '\x3', '\x2DB', '\x5', '\x2DB', '\x1AD9', '\n', '\x2DB', 
		'\x3', '\x2DB', '\x5', '\x2DB', '\x1ADC', '\n', '\x2DB', '\x3', '\x2DB', 
		'\x3', '\x2DB', '\x3', '\x2DB', '\x3', '\x2DB', '\x3', '\x2DB', '\x3', 
		'\x2DB', '\x5', '\x2DB', '\x1AE4', '\n', '\x2DB', '\x3', '\x2DC', '\x3', 
		'\x2DC', '\x3', '\x2DD', '\x3', '\x2DD', '\x3', '\x2DE', '\x3', '\x2DE', 
		'\x3', '\x2DE', '\x3', '\x2DE', '\x3', '\x2DE', '\a', '\x2DE', '\x1AEF', 
		'\n', '\x2DE', '\f', '\x2DE', '\xE', '\x2DE', '\x1AF2', '\v', '\x2DE', 
		'\x3', '\x2DE', '\x3', '\x2DE', '\x3', '\x2DF', '\x3', '\x2DF', '\x3', 
		'\x2DF', '\x5', '\x2DF', '\x1AF9', '\n', '\x2DF', '\x3', '\x2DF', '\x3', 
		'\x2DF', '\x3', '\x2DF', '\x5', '\x2DF', '\x1AFE', '\n', '\x2DF', '\x5', 
		'\x2DF', '\x1B00', '\n', '\x2DF', '\x3', '\x2E0', '\x3', '\x2E0', '\x3', 
		'\x2E0', '\x3', '\x2E0', '\x3', '\x2E0', '\a', '\x2E0', '\x1B07', '\n', 
		'\x2E0', '\f', '\x2E0', '\xE', '\x2E0', '\x1B0A', '\v', '\x2E0', '\x3', 
		'\x2E0', '\x3', '\x2E0', '\x3', '\x2E1', '\x3', '\x2E1', '\x3', '\x2E1', 
		'\x5', '\x2E1', '\x1B11', '\n', '\x2E1', '\x3', '\x2E1', '\x3', '\x2E1', 
		'\x3', '\x2E1', '\x5', '\x2E1', '\x1B16', '\n', '\x2E1', '\x5', '\x2E1', 
		'\x1B18', '\n', '\x2E1', '\x3', '\x2E2', '\x3', '\x2E2', '\x3', '\x2E2', 
		'\x5', '\x2E2', '\x1B1D', '\n', '\x2E2', '\x3', '\x2E2', '\x3', '\x2E2', 
		'\x3', '\x2E2', '\x3', '\x2E3', '\x3', '\x2E3', '\x3', '\x2E3', '\x3', 
		'\x2E3', '\x3', '\x2E4', '\x3', '\x2E4', '\x3', '\x2E4', '\x3', '\x2E4', 
		'\x5', '\x2E4', '\x1B2A', '\n', '\x2E4', '\x3', '\x2E5', '\x3', '\x2E5', 
		'\x3', '\x2E5', '\x5', '\x2E5', '\x1B2F', '\n', '\x2E5', '\x3', '\x2E6', 
		'\x3', '\x2E6', '\x3', '\x2E6', '\x3', '\x2E6', '\x3', '\x2E6', '\x5', 
		'\x2E6', '\x1B36', '\n', '\x2E6', '\x3', '\x2E7', '\x3', '\x2E7', '\x3', 
		'\x2E7', '\x5', '\x2E7', '\x1B3B', '\n', '\x2E7', '\x3', '\x2E8', '\x3', 
		'\x2E8', '\x3', '\x2E8', '\x3', '\x2E8', '\x3', '\x2E8', '\x3', '\x2E8', 
		'\x5', '\x2E8', '\x1B43', '\n', '\x2E8', '\x3', '\x2E9', '\x3', '\x2E9', 
		'\x5', '\x2E9', '\x1B47', '\n', '\x2E9', '\x3', '\x2E9', '\x5', '\x2E9', 
		'\x1B4A', '\n', '\x2E9', '\x3', '\x2E9', '\x5', '\x2E9', '\x1B4D', '\n', 
		'\x2E9', '\x3', '\x2EA', '\x3', '\x2EA', '\x3', '\x2EA', '\x3', '\x2EB', 
		'\x3', '\x2EB', '\x3', '\x2EB', '\x3', '\x2EC', '\x3', '\x2EC', '\x3', 
		'\x2EC', '\x3', '\x2EC', '\x3', '\x2EC', '\x3', '\x2EC', '\x3', '\x2EC', 
		'\x3', '\x2EC', '\x3', '\x2EC', '\x3', '\x2EC', '\x5', '\x2EC', '\x1B5F', 
		'\n', '\x2EC', '\x3', '\x2ED', '\x3', '\x2ED', '\x3', '\x2ED', '\x3', 
		'\x2ED', '\x3', '\x2ED', '\x3', '\x2ED', '\x3', '\x2ED', '\x3', '\x2EE', 
		'\x3', '\x2EE', '\x3', '\x2EF', '\x3', '\x2EF', '\x3', '\x2F0', '\x3', 
		'\x2F0', '\x3', '\x2F0', '\x5', '\x2F0', '\x1B6F', '\n', '\x2F0', '\x3', 
		'\x2F0', '\x3', '\x2F0', '\x3', '\x2F1', '\x3', '\x2F1', '\x3', '\x2F1', 
		'\x5', '\x2F1', '\x1B76', '\n', '\x2F1', '\x3', '\x2F1', '\x3', '\x2F1', 
		'\x3', '\x2F2', '\x3', '\x2F2', '\x3', '\x2F2', '\x5', '\x2F2', '\x1B7D', 
		'\n', '\x2F2', '\x3', '\x2F2', '\x3', '\x2F2', '\x3', '\x2F3', '\x3', 
		'\x2F3', '\x3', '\x2F3', '\x5', '\x2F3', '\x1B84', '\n', '\x2F3', '\x3', 
		'\x2F3', '\x3', '\x2F3', '\x3', '\x2F4', '\x3', '\x2F4', '\x3', '\x2F4', 
		'\x5', '\x2F4', '\x1B8B', '\n', '\x2F4', '\x3', '\x2F4', '\x3', '\x2F4', 
		'\x3', '\x2F5', '\x3', '\x2F5', '\x3', '\x2F5', '\x5', '\x2F5', '\x1B92', 
		'\n', '\x2F5', '\x3', '\x2F5', '\x3', '\x2F5', '\x3', '\x2F6', '\x3', 
		'\x2F6', '\x5', '\x2F6', '\x1B98', '\n', '\x2F6', '\x3', '\x2F6', '\x3', 
		'\x2F6', '\x5', '\x2F6', '\x1B9C', '\n', '\x2F6', '\x3', '\x2F6', '\x3', 
		'\x2F6', '\x3', '\x2F6', '\x5', '\x2F6', '\x1BA1', '\n', '\x2F6', '\x5', 
		'\x2F6', '\x1BA3', '\n', '\x2F6', '\x3', '\x2F7', '\x3', '\x2F7', '\x3', 
		'\x2F8', '\x3', '\x2F8', '\x3', '\x2F8', '\x3', '\x2F8', '\x3', '\x2F8', 
		'\x5', '\x2F8', '\x1BAC', '\n', '\x2F8', '\x3', '\x2F9', '\x3', '\x2F9', 
		'\x3', '\x2F9', '\x5', '\x2F9', '\x1BB1', '\n', '\x2F9', '\x3', '\x2FA', 
		'\x3', '\x2FA', '\x3', '\x2FB', '\x3', '\x2FB', '\x3', '\x2FB', '\x3', 
		'\x2FB', '\x3', '\x2FC', '\x3', '\x2FC', '\x3', '\x2FC', '\x3', '\x2FD', 
		'\x3', '\x2FD', '\x3', '\x2FD', '\x5', '\x2FD', '\x1BBF', '\n', '\x2FD', 
		'\x3', '\x2FE', '\x3', '\x2FE', '\x3', '\x2FE', '\x3', '\x2FE', '\x3', 
		'\x2FE', '\x5', '\x2FE', '\x1BC6', '\n', '\x2FE', '\x3', '\x2FF', '\x3', 
		'\x2FF', '\x3', '\x2FF', '\x3', '\x2FF', '\x3', '\x2FF', '\x3', '\x2FF', 
		'\x5', '\x2FF', '\x1BCE', '\n', '\x2FF', '\x5', '\x2FF', '\x1BD0', '\n', 
		'\x2FF', '\x3', '\x300', '\x3', '\x300', '\x3', '\x300', '\x3', '\x300', 
		'\a', '\x300', '\x1BD6', '\n', '\x300', '\f', '\x300', '\xE', '\x300', 
		'\x1BD9', '\v', '\x300', '\x5', '\x300', '\x1BDB', '\n', '\x300', '\x3', 
		'\x301', '\x3', '\x301', '\x3', '\x301', '\x3', '\x301', '\x3', '\x301', 
		'\x3', '\x301', '\x5', '\x301', '\x1BE3', '\n', '\x301', '\x3', '\x302', 
		'\x3', '\x302', '\x3', '\x302', '\x3', '\x302', '\x3', '\x303', '\x3', 
		'\x303', '\x5', '\x303', '\x1BEB', '\n', '\x303', '\x3', '\x303', '\x5', 
		'\x303', '\x1BEE', '\n', '\x303', '\x3', '\x303', '\x3', '\x303', '\x5', 
		'\x303', '\x1BF2', '\n', '\x303', '\x3', '\x304', '\x3', '\x304', '\x3', 
		'\x304', '\x3', '\x304', '\x3', '\x304', '\x3', '\x304', '\x3', '\x304', 
		'\x3', '\x304', '\x3', '\x304', '\x3', '\x304', '\x3', '\x304', '\x3', 
		'\x304', '\x3', '\x304', '\x3', '\x304', '\x3', '\x304', '\x3', '\x304', 
		'\x5', '\x304', '\x1C04', '\n', '\x304', '\x3', '\x305', '\x3', '\x305', 
		'\x3', '\x305', '\x3', '\x305', '\x3', '\x305', '\x3', '\x305', '\a', 
		'\x305', '\x1C0C', '\n', '\x305', '\f', '\x305', '\xE', '\x305', '\x1C0F', 
		'\v', '\x305', '\x3', '\x306', '\x3', '\x306', '\x3', '\x306', '\x5', 
		'\x306', '\x1C14', '\n', '\x306', '\x3', '\x307', '\x3', '\x307', '\x3', 
		'\x307', '\x3', '\x308', '\x3', '\x308', '\x3', '\x308', '\x5', '\x308', 
		'\x1C1C', '\n', '\x308', '\x3', '\x309', '\x3', '\x309', '\x6', '\x309', 
		'\x1C20', '\n', '\x309', '\r', '\x309', '\xE', '\x309', '\x1C21', '\x3', 
		'\x309', '\x3', '\x309', '\x3', '\x30A', '\x3', '\x30A', '\x3', '\x30A', 
		'\x3', '\x30A', '\x3', '\x30A', '\x3', '\x30A', '\x5', '\x30A', '\x1C2C', 
		'\n', '\x30A', '\x3', '\x30B', '\x3', '\x30B', '\x3', '\x30B', '\x5', 
		'\x30B', '\x1C31', '\n', '\x30B', '\x3', '\x30B', '\x5', '\x30B', '\x1C34', 
		'\n', '\x30B', '\x3', '\x30C', '\x3', '\x30C', '\x3', '\x30C', '\x3', 
		'\x30C', '\x3', '\x30C', '\x3', '\x30C', '\x3', '\x30C', '\x3', '\x30C', 
		'\x3', '\x30C', '\x5', '\x30C', '\x1C3F', '\n', '\x30C', '\x3', '\x30D', 
		'\x3', '\x30D', '\x3', '\x30D', '\x3', '\x30D', '\x3', '\x30D', '\x3', 
		'\x30D', '\x3', '\x30D', '\x5', '\x30D', '\x1C48', '\n', '\x30D', '\x3', 
		'\x30D', '\a', '\x30D', '\x1C4B', '\n', '\x30D', '\f', '\x30D', '\xE', 
		'\x30D', '\x1C4E', '\v', '\x30D', '\x3', '\x30E', '\x3', '\x30E', '\x3', 
		'\x30E', '\x3', '\x30E', '\x3', '\x30E', '\x3', '\x30E', '\x3', '\x30E', 
		'\x3', '\x30E', '\x3', '\x30E', '\x5', '\x30E', '\x1C59', '\n', '\x30E', 
		'\x3', '\x30F', '\x3', '\x30F', '\x5', '\x30F', '\x1C5D', '\n', '\x30F', 
		'\x3', '\x30F', '\x5', '\x30F', '\x1C60', '\n', '\x30F', '\x3', '\x310', 
		'\x3', '\x310', '\x3', '\x310', '\x3', '\x311', '\x3', '\x311', '\x3', 
		'\x311', '\x3', '\x311', '\x3', '\x311', '\x3', '\x311', '\x3', '\x311', 
		'\x3', '\x311', '\x5', '\x311', '\x1C6D', '\n', '\x311', '\x3', '\x312', 
		'\x3', '\x312', '\x3', '\x312', '\x3', '\x312', '\x3', '\x312', '\x3', 
		'\x312', '\x5', '\x312', '\x1C75', '\n', '\x312', '\x3', '\x312', '\x6', 
		'\x312', '\x1C78', '\n', '\x312', '\r', '\x312', '\xE', '\x312', '\x1C79', 
		'\x3', '\x313', '\x3', '\x313', '\x3', '\x313', '\x5', '\x313', '\x1C7F', 
		'\n', '\x313', '\x3', '\x314', '\x3', '\x314', '\x3', '\x314', '\x5', 
		'\x314', '\x1C84', '\n', '\x314', '\x3', '\x314', '\x5', '\x314', '\x1C87', 
		'\n', '\x314', '\x3', '\x314', '\x5', '\x314', '\x1C8A', '\n', '\x314', 
		'\x3', '\x315', '\x3', '\x315', '\x3', '\x315', '\x5', '\x315', '\x1C8F', 
		'\n', '\x315', '\x3', '\x316', '\x3', '\x316', '\x3', '\x316', '\x3', 
		'\x316', '\x3', '\x316', '\x3', '\x316', '\x3', '\x316', '\x3', '\x316', 
		'\x3', '\x316', '\x3', '\x316', '\x5', '\x316', '\x1C9B', '\n', '\x316', 
		'\x3', '\x317', '\x3', '\x317', '\x3', '\x317', '\x3', '\x317', '\x3', 
		'\x317', '\a', '\x317', '\x1CA2', '\n', '\x317', '\f', '\x317', '\xE', 
		'\x317', '\x1CA5', '\v', '\x317', '\x3', '\x318', '\x3', '\x318', '\x3', 
		'\x318', '\x3', '\x318', '\x3', '\x318', '\x3', '\x318', '\x3', '\x319', 
		'\x3', '\x319', '\x3', '\x319', '\x3', '\x319', '\x3', '\x31A', '\x3', 
		'\x31A', '\x3', '\x31A', '\x3', '\x31A', '\x3', '\x31A', '\x5', '\x31A', 
		'\x1CB6', '\n', '\x31A', '\x3', '\x31A', '\x5', '\x31A', '\x1CB9', '\n', 
		'\x31A', '\x3', '\x31B', '\x3', '\x31B', '\x3', '\x31B', '\x3', '\x31C', 
		'\x3', '\x31C', '\x3', '\x31C', '\x3', '\x31C', '\x3', '\x31C', '\x3', 
		'\x31C', '\x3', '\x31C', '\x3', '\x31D', '\x3', '\x31D', '\x3', '\x31D', 
		'\x3', '\x31D', '\a', '\x31D', '\x1CC9', '\n', '\x31D', '\f', '\x31D', 
		'\xE', '\x31D', '\x1CCC', '\v', '\x31D', '\x5', '\x31D', '\x1CCE', '\n', 
		'\x31D', '\x3', '\x31E', '\x3', '\x31E', '\x3', '\x31E', '\x3', '\x31E', 
		'\x3', '\x31E', '\x3', '\x31E', '\x5', '\x31E', '\x1CD6', '\n', '\x31E', 
		'\x3', '\x31F', '\x3', '\x31F', '\x5', '\x31F', '\x1CDA', '\n', '\x31F', 
		'\x3', '\x31F', '\x5', '\x31F', '\x1CDD', '\n', '\x31F', '\x3', '\x31F', 
		'\x5', '\x31F', '\x1CE0', '\n', '\x31F', '\x3', '\x31F', '\x3', '\x31F', 
		'\x5', '\x31F', '\x1CE4', '\n', '\x31F', '\x3', '\x320', '\x3', '\x320', 
		'\x3', '\x320', '\x3', '\x320', '\x3', '\x321', '\x3', '\x321', '\x3', 
		'\x321', '\x3', '\x322', '\x3', '\x322', '\x3', '\x322', '\a', '\x322', 
		'\x1CF0', '\n', '\x322', '\f', '\x322', '\xE', '\x322', '\x1CF3', '\v', 
		'\x322', '\x3', '\x323', '\x3', '\x323', '\x3', '\x323', '\x5', '\x323', 
		'\x1CF8', '\n', '\x323', '\x3', '\x324', '\x3', '\x324', '\x5', '\x324', 
		'\x1CFC', '\n', '\x324', '\x3', '\x325', '\x3', '\x325', '\x3', '\x325', 
		'\x3', '\x325', '\x5', '\x325', '\x1D02', '\n', '\x325', '\x3', '\x326', 
		'\x3', '\x326', '\x5', '\x326', '\x1D06', '\n', '\x326', '\x3', '\x327', 
		'\x3', '\x327', '\x3', '\x327', '\x3', '\x327', '\a', '\x327', '\x1D0C', 
		'\n', '\x327', '\f', '\x327', '\xE', '\x327', '\x1D0F', '\v', '\x327', 
		'\x3', '\x327', '\x3', '\x327', '\x3', '\x328', '\x3', '\x328', '\x3', 
		'\x328', '\x3', '\x328', '\x3', '\x328', '\x3', '\x329', '\x3', '\x329', 
		'\x3', '\x329', '\x3', '\x329', '\x3', '\x329', '\x3', '\x329', '\x5', 
		'\x329', '\x1D1E', '\n', '\x329', '\x3', '\x32A', '\x3', '\x32A', '\x5', 
		'\x32A', '\x1D22', '\n', '\x32A', '\x3', '\x32B', '\x3', '\x32B', '\x3', 
		'\x32C', '\x3', '\x32C', '\x5', '\x32C', '\x1D28', '\n', '\x32C', '\x3', 
		'\x32C', '\x5', '\x32C', '\x1D2B', '\n', '\x32C', '\x3', '\x32D', '\x3', 
		'\x32D', '\x5', '\x32D', '\x1D2F', '\n', '\x32D', '\x3', '\x32E', '\x5', 
		'\x32E', '\x1D32', '\n', '\x32E', '\x3', '\x32E', '\x3', '\x32E', '\x3', 
		'\x32E', '\x3', '\x32E', '\x3', '\x32F', '\x3', '\x32F', '\x3', '\x32F', 
		'\x3', '\x32F', '\x3', '\x330', '\x5', '\x330', '\x1D3D', '\n', '\x330', 
		'\x3', '\x330', '\x3', '\x330', '\x3', '\x331', '\x3', '\x331', '\x3', 
		'\x331', '\x6', '\x331', '\x1D44', '\n', '\x331', '\r', '\x331', '\xE', 
		'\x331', '\x1D45', '\x3', '\x332', '\x3', '\x332', '\x3', '\x332', '\x3', 
		'\x332', '\x3', '\x332', '\x3', '\x332', '\x3', '\x332', '\x3', '\x332', 
		'\x3', '\x332', '\x3', '\x332', '\x3', '\x332', '\x5', '\x332', '\x1D53', 
		'\n', '\x332', '\x3', '\x333', '\x3', '\x333', '\x3', '\x333', '\x3', 
		'\x333', '\x3', '\x333', '\x3', '\x333', '\x3', '\x333', '\x3', '\x333', 
		'\x3', '\x333', '\x5', '\x333', '\x1D5E', '\n', '\x333', '\x3', '\x334', 
		'\x3', '\x334', '\x3', '\x334', '\x5', '\x334', '\x1D63', '\n', '\x334', 
		'\x3', '\x334', '\x3', '\x334', '\x3', '\x335', '\x3', '\x335', '\x3', 
		'\x335', '\x5', '\x335', '\x1D6A', '\n', '\x335', '\x3', '\x335', '\x3', 
		'\x335', '\x3', '\x335', '\x5', '\x335', '\x1D6F', '\n', '\x335', '\x3', 
		'\x336', '\x3', '\x336', '\x5', '\x336', '\x1D73', '\n', '\x336', '\x3', 
		'\x336', '\x3', '\x336', '\x5', '\x336', '\x1D77', '\n', '\x336', '\x3', 
		'\x337', '\x3', '\x337', '\x5', '\x337', '\x1D7B', '\n', '\x337', '\x3', 
		'\x337', '\x3', '\x337', '\x5', '\x337', '\x1D7F', '\n', '\x337', '\x3', 
		'\x338', '\x3', '\x338', '\x3', '\x339', '\x3', '\x339', '\x5', '\x339', 
		'\x1D85', '\n', '\x339', '\x3', '\x339', '\x3', '\x339', '\x5', '\x339', 
		'\x1D89', '\n', '\x339', '\x3', '\x33A', '\x3', '\x33A', '\x3', '\x33B', 
		'\x3', '\x33B', '\x5', '\x33B', '\x1D8F', '\n', '\x33B', '\x3', '\x33B', 
		'\x5', '\x33B', '\x1D92', '\n', '\x33B', '\x3', '\x33C', '\x3', '\x33C', 
		'\x3', '\x33D', '\x3', '\x33D', '\x5', '\x33D', '\x1D98', '\n', '\x33D', 
		'\x3', '\x33D', '\x5', '\x33D', '\x1D9B', '\n', '\x33D', '\x3', '\x33E', 
		'\x3', '\x33E', '\x3', '\x33F', '\x3', '\x33F', '\x3', '\x33F', '\x5', 
		'\x33F', '\x1DA2', '\n', '\x33F', '\x3', '\x33F', '\x5', '\x33F', '\x1DA5', 
		'\n', '\x33F', '\x3', '\x33F', '\a', '\x33F', '\x1DA8', '\n', '\x33F', 
		'\f', '\x33F', '\xE', '\x33F', '\x1DAB', '\v', '\x33F', '\x3', '\x340', 
		'\x3', '\x340', '\x3', '\x340', '\x3', '\x341', '\x3', '\x341', '\x3', 
		'\x341', '\x5', '\x341', '\x1DB3', '\n', '\x341', '\x3', '\x342', '\x5', 
		'\x342', '\x1DB6', '\n', '\x342', '\x3', '\x342', '\x3', '\x342', '\x5', 
		'\x342', '\x1DBA', '\n', '\x342', '\x3', '\x342', '\x5', '\x342', '\x1DBD', 
		'\n', '\x342', '\x3', '\x342', '\a', '\x342', '\x1DC0', '\n', '\x342', 
		'\f', '\x342', '\xE', '\x342', '\x1DC3', '\v', '\x342', '\x3', '\x343', 
		'\x3', '\x343', '\x3', '\x343', '\x3', '\x344', '\x3', '\x344', '\x3', 
		'\x345', '\x3', '\x345', '\x3', '\x345', '\x3', '\x345', '\a', '\x345', 
		'\x1DCE', '\n', '\x345', '\f', '\x345', '\xE', '\x345', '\x1DD1', '\v', 
		'\x345', '\x3', '\x345', '\x3', '\x345', '\x3', '\x346', '\x3', '\x346', 
		'\x5', '\x346', '\x1DD7', '\n', '\x346', '\x3', '\x347', '\x3', '\x347', 
		'\x3', '\x347', '\x3', '\x348', '\x3', '\x348', '\x3', '\x348', '\x3', 
		'\x349', '\x3', '\x349', '\x3', '\x349', '\x3', '\x34A', '\x3', '\x34A', 
		'\x3', '\x34A', '\x3', '\x34B', '\x3', '\x34B', '\x3', '\x34B', '\x3', 
		'\x34B', '\x3', '\x34B', '\x3', '\x34B', '\x3', '\x34B', '\x3', '\x34C', 
		'\x3', '\x34C', '\x3', '\x34C', '\x3', '\x34C', '\x3', '\x34C', '\a', 
		'\x34C', '\x1DF1', '\n', '\x34C', '\f', '\x34C', '\xE', '\x34C', '\x1DF4', 
		'\v', '\x34C', '\x3', '\x34D', '\x5', '\x34D', '\x1DF7', '\n', '\x34D', 
		'\x3', '\x34D', '\x3', '\x34D', '\x3', '\x34D', '\x5', '\x34D', '\x1DFC', 
		'\n', '\x34D', '\x3', '\x34E', '\x3', '\x34E', '\x3', '\x34E', '\x5', 
		'\x34E', '\x1E01', '\n', '\x34E', '\x3', '\x34F', '\x3', '\x34F', '\x3', 
		'\x34F', '\x3', '\x34F', '\x5', '\x34F', '\x1E07', '\n', '\x34F', '\x3', 
		'\x350', '\x3', '\x350', '\x3', '\x350', '\x3', '\x350', '\x5', '\x350', 
		'\x1E0D', '\n', '\x350', '\x3', '\x351', '\x3', '\x351', '\x3', '\x351', 
		'\x3', '\x351', '\x3', '\x351', '\x3', '\x352', '\x3', '\x352', '\x3', 
		'\x352', '\x3', '\x352', '\x3', '\x353', '\x5', '\x353', '\x1E19', '\n', 
		'\x353', '\x3', '\x353', '\x3', '\x353', '\x3', '\x354', '\x5', '\x354', 
		'\x1E1E', '\n', '\x354', '\x3', '\x354', '\x3', '\x354', '\x3', '\x354', 
		'\x5', '\x354', '\x1E23', '\n', '\x354', '\x3', '\x354', '\x3', '\x354', 
		'\x3', '\x354', '\x3', '\x355', '\x3', '\x355', '\x3', '\x355', '\x3', 
		'\x355', '\x3', '\x355', '\x3', '\x758', '\x2', '\x356', '\x2', '\x4', 
		'\x6', '\b', '\n', '\f', '\xE', '\x10', '\x12', '\x14', '\x16', '\x18', 
		'\x1A', '\x1C', '\x1E', ' ', '\"', '$', '&', '(', '*', ',', '.', '\x30', 
		'\x32', '\x34', '\x36', '\x38', ':', '<', '>', '@', '\x42', '\x44', '\x46', 
		'H', 'J', 'L', 'N', 'P', 'R', 'T', 'V', 'X', 'Z', '\\', '^', '`', '\x62', 
		'\x64', '\x66', 'h', 'j', 'l', 'n', 'p', 'r', 't', 'v', 'x', 'z', '|', 
		'~', '\x80', '\x82', '\x84', '\x86', '\x88', '\x8A', '\x8C', '\x8E', '\x90', 
		'\x92', '\x94', '\x96', '\x98', '\x9A', '\x9C', '\x9E', '\xA0', '\xA2', 
		'\xA4', '\xA6', '\xA8', '\xAA', '\xAC', '\xAE', '\xB0', '\xB2', '\xB4', 
		'\xB6', '\xB8', '\xBA', '\xBC', '\xBE', '\xC0', '\xC2', '\xC4', '\xC6', 
		'\xC8', '\xCA', '\xCC', '\xCE', '\xD0', '\xD2', '\xD4', '\xD6', '\xD8', 
		'\xDA', '\xDC', '\xDE', '\xE0', '\xE2', '\xE4', '\xE6', '\xE8', '\xEA', 
		'\xEC', '\xEE', '\xF0', '\xF2', '\xF4', '\xF6', '\xF8', '\xFA', '\xFC', 
		'\xFE', '\x100', '\x102', '\x104', '\x106', '\x108', '\x10A', '\x10C', 
		'\x10E', '\x110', '\x112', '\x114', '\x116', '\x118', '\x11A', '\x11C', 
		'\x11E', '\x120', '\x122', '\x124', '\x126', '\x128', '\x12A', '\x12C', 
		'\x12E', '\x130', '\x132', '\x134', '\x136', '\x138', '\x13A', '\x13C', 
		'\x13E', '\x140', '\x142', '\x144', '\x146', '\x148', '\x14A', '\x14C', 
		'\x14E', '\x150', '\x152', '\x154', '\x156', '\x158', '\x15A', '\x15C', 
		'\x15E', '\x160', '\x162', '\x164', '\x166', '\x168', '\x16A', '\x16C', 
		'\x16E', '\x170', '\x172', '\x174', '\x176', '\x178', '\x17A', '\x17C', 
		'\x17E', '\x180', '\x182', '\x184', '\x186', '\x188', '\x18A', '\x18C', 
		'\x18E', '\x190', '\x192', '\x194', '\x196', '\x198', '\x19A', '\x19C', 
		'\x19E', '\x1A0', '\x1A2', '\x1A4', '\x1A6', '\x1A8', '\x1AA', '\x1AC', 
		'\x1AE', '\x1B0', '\x1B2', '\x1B4', '\x1B6', '\x1B8', '\x1BA', '\x1BC', 
		'\x1BE', '\x1C0', '\x1C2', '\x1C4', '\x1C6', '\x1C8', '\x1CA', '\x1CC', 
		'\x1CE', '\x1D0', '\x1D2', '\x1D4', '\x1D6', '\x1D8', '\x1DA', '\x1DC', 
		'\x1DE', '\x1E0', '\x1E2', '\x1E4', '\x1E6', '\x1E8', '\x1EA', '\x1EC', 
		'\x1EE', '\x1F0', '\x1F2', '\x1F4', '\x1F6', '\x1F8', '\x1FA', '\x1FC', 
		'\x1FE', '\x200', '\x202', '\x204', '\x206', '\x208', '\x20A', '\x20C', 
		'\x20E', '\x210', '\x212', '\x214', '\x216', '\x218', '\x21A', '\x21C', 
		'\x21E', '\x220', '\x222', '\x224', '\x226', '\x228', '\x22A', '\x22C', 
		'\x22E', '\x230', '\x232', '\x234', '\x236', '\x238', '\x23A', '\x23C', 
		'\x23E', '\x240', '\x242', '\x244', '\x246', '\x248', '\x24A', '\x24C', 
		'\x24E', '\x250', '\x252', '\x254', '\x256', '\x258', '\x25A', '\x25C', 
		'\x25E', '\x260', '\x262', '\x264', '\x266', '\x268', '\x26A', '\x26C', 
		'\x26E', '\x270', '\x272', '\x274', '\x276', '\x278', '\x27A', '\x27C', 
		'\x27E', '\x280', '\x282', '\x284', '\x286', '\x288', '\x28A', '\x28C', 
		'\x28E', '\x290', '\x292', '\x294', '\x296', '\x298', '\x29A', '\x29C', 
		'\x29E', '\x2A0', '\x2A2', '\x2A4', '\x2A6', '\x2A8', '\x2AA', '\x2AC', 
		'\x2AE', '\x2B0', '\x2B2', '\x2B4', '\x2B6', '\x2B8', '\x2BA', '\x2BC', 
		'\x2BE', '\x2C0', '\x2C2', '\x2C4', '\x2C6', '\x2C8', '\x2CA', '\x2CC', 
		'\x2CE', '\x2D0', '\x2D2', '\x2D4', '\x2D6', '\x2D8', '\x2DA', '\x2DC', 
		'\x2DE', '\x2E0', '\x2E2', '\x2E4', '\x2E6', '\x2E8', '\x2EA', '\x2EC', 
		'\x2EE', '\x2F0', '\x2F2', '\x2F4', '\x2F6', '\x2F8', '\x2FA', '\x2FC', 
		'\x2FE', '\x300', '\x302', '\x304', '\x306', '\x308', '\x30A', '\x30C', 
		'\x30E', '\x310', '\x312', '\x314', '\x316', '\x318', '\x31A', '\x31C', 
		'\x31E', '\x320', '\x322', '\x324', '\x326', '\x328', '\x32A', '\x32C', 
		'\x32E', '\x330', '\x332', '\x334', '\x336', '\x338', '\x33A', '\x33C', 
		'\x33E', '\x340', '\x342', '\x344', '\x346', '\x348', '\x34A', '\x34C', 
		'\x34E', '\x350', '\x352', '\x354', '\x356', '\x358', '\x35A', '\x35C', 
		'\x35E', '\x360', '\x362', '\x364', '\x366', '\x368', '\x36A', '\x36C', 
		'\x36E', '\x370', '\x372', '\x374', '\x376', '\x378', '\x37A', '\x37C', 
		'\x37E', '\x380', '\x382', '\x384', '\x386', '\x388', '\x38A', '\x38C', 
		'\x38E', '\x390', '\x392', '\x394', '\x396', '\x398', '\x39A', '\x39C', 
		'\x39E', '\x3A0', '\x3A2', '\x3A4', '\x3A6', '\x3A8', '\x3AA', '\x3AC', 
		'\x3AE', '\x3B0', '\x3B2', '\x3B4', '\x3B6', '\x3B8', '\x3BA', '\x3BC', 
		'\x3BE', '\x3C0', '\x3C2', '\x3C4', '\x3C6', '\x3C8', '\x3CA', '\x3CC', 
		'\x3CE', '\x3D0', '\x3D2', '\x3D4', '\x3D6', '\x3D8', '\x3DA', '\x3DC', 
		'\x3DE', '\x3E0', '\x3E2', '\x3E4', '\x3E6', '\x3E8', '\x3EA', '\x3EC', 
		'\x3EE', '\x3F0', '\x3F2', '\x3F4', '\x3F6', '\x3F8', '\x3FA', '\x3FC', 
		'\x3FE', '\x400', '\x402', '\x404', '\x406', '\x408', '\x40A', '\x40C', 
		'\x40E', '\x410', '\x412', '\x414', '\x416', '\x418', '\x41A', '\x41C', 
		'\x41E', '\x420', '\x422', '\x424', '\x426', '\x428', '\x42A', '\x42C', 
		'\x42E', '\x430', '\x432', '\x434', '\x436', '\x438', '\x43A', '\x43C', 
		'\x43E', '\x440', '\x442', '\x444', '\x446', '\x448', '\x44A', '\x44C', 
		'\x44E', '\x450', '\x452', '\x454', '\x456', '\x458', '\x45A', '\x45C', 
		'\x45E', '\x460', '\x462', '\x464', '\x466', '\x468', '\x46A', '\x46C', 
		'\x46E', '\x470', '\x472', '\x474', '\x476', '\x478', '\x47A', '\x47C', 
		'\x47E', '\x480', '\x482', '\x484', '\x486', '\x488', '\x48A', '\x48C', 
		'\x48E', '\x490', '\x492', '\x494', '\x496', '\x498', '\x49A', '\x49C', 
		'\x49E', '\x4A0', '\x4A2', '\x4A4', '\x4A6', '\x4A8', '\x4AA', '\x4AC', 
		'\x4AE', '\x4B0', '\x4B2', '\x4B4', '\x4B6', '\x4B8', '\x4BA', '\x4BC', 
		'\x4BE', '\x4C0', '\x4C2', '\x4C4', '\x4C6', '\x4C8', '\x4CA', '\x4CC', 
		'\x4CE', '\x4D0', '\x4D2', '\x4D4', '\x4D6', '\x4D8', '\x4DA', '\x4DC', 
		'\x4DE', '\x4E0', '\x4E2', '\x4E4', '\x4E6', '\x4E8', '\x4EA', '\x4EC', 
		'\x4EE', '\x4F0', '\x4F2', '\x4F4', '\x4F6', '\x4F8', '\x4FA', '\x4FC', 
		'\x4FE', '\x500', '\x502', '\x504', '\x506', '\x508', '\x50A', '\x50C', 
		'\x50E', '\x510', '\x512', '\x514', '\x516', '\x518', '\x51A', '\x51C', 
		'\x51E', '\x520', '\x522', '\x524', '\x526', '\x528', '\x52A', '\x52C', 
		'\x52E', '\x530', '\x532', '\x534', '\x536', '\x538', '\x53A', '\x53C', 
		'\x53E', '\x540', '\x542', '\x544', '\x546', '\x548', '\x54A', '\x54C', 
		'\x54E', '\x550', '\x552', '\x554', '\x556', '\x558', '\x55A', '\x55C', 
		'\x55E', '\x560', '\x562', '\x564', '\x566', '\x568', '\x56A', '\x56C', 
		'\x56E', '\x570', '\x572', '\x574', '\x576', '\x578', '\x57A', '\x57C', 
		'\x57E', '\x580', '\x582', '\x584', '\x586', '\x588', '\x58A', '\x58C', 
		'\x58E', '\x590', '\x592', '\x594', '\x596', '\x598', '\x59A', '\x59C', 
		'\x59E', '\x5A0', '\x5A2', '\x5A4', '\x5A6', '\x5A8', '\x5AA', '\x5AC', 
		'\x5AE', '\x5B0', '\x5B2', '\x5B4', '\x5B6', '\x5B8', '\x5BA', '\x5BC', 
		'\x5BE', '\x5C0', '\x5C2', '\x5C4', '\x5C6', '\x5C8', '\x5CA', '\x5CC', 
		'\x5CE', '\x5D0', '\x5D2', '\x5D4', '\x5D6', '\x5D8', '\x5DA', '\x5DC', 
		'\x5DE', '\x5E0', '\x5E2', '\x5E4', '\x5E6', '\x5E8', '\x5EA', '\x5EC', 
		'\x5EE', '\x5F0', '\x5F2', '\x5F4', '\x5F6', '\x5F8', '\x5FA', '\x5FC', 
		'\x5FE', '\x600', '\x602', '\x604', '\x606', '\x608', '\x60A', '\x60C', 
		'\x60E', '\x610', '\x612', '\x614', '\x616', '\x618', '\x61A', '\x61C', 
		'\x61E', '\x620', '\x622', '\x624', '\x626', '\x628', '\x62A', '\x62C', 
		'\x62E', '\x630', '\x632', '\x634', '\x636', '\x638', '\x63A', '\x63C', 
		'\x63E', '\x640', '\x642', '\x644', '\x646', '\x648', '\x64A', '\x64C', 
		'\x64E', '\x650', '\x652', '\x654', '\x656', '\x658', '\x65A', '\x65C', 
		'\x65E', '\x660', '\x662', '\x664', '\x666', '\x668', '\x66A', '\x66C', 
		'\x66E', '\x670', '\x672', '\x674', '\x676', '\x678', '\x67A', '\x67C', 
		'\x67E', '\x680', '\x682', '\x684', '\x686', '\x688', '\x68A', '\x68C', 
		'\x68E', '\x690', '\x692', '\x694', '\x696', '\x698', '\x69A', '\x69C', 
		'\x69E', '\x6A0', '\x6A2', '\x6A4', '\x6A6', '\x6A8', '\x2', 'o', '\x4', 
		'\x2', '$', '$', 'u', 'u', '\x2', '\x3', '\x3', '\x3', '\x24F', '\x24F', 
		'\x5', '\x2', '\x245', '\x245', '\x25F', '\x25F', '\x265', '\x265', '\x4', 
		'\x2', '\xB4', '\xB4', '\x210', '\x210', '\b', '\x2', 'p', 'p', '\xD7', 
		'\xD7', '\x12E', '\x12E', '\x134', '\x134', '\x1CC', '\x1CC', '\x243', 
		'\x243', 'U', '\x2', '\x3', '\x4', '\x6', '\t', '\v', '\f', '\xE', '\xF', 
		'\x12', '\x14', '\x17', '\x1A', '\x1C', '#', '%', '%', '\'', '\x32', '\x34', 
		'\x38', ':', '?', '\x41', '\x44', '\x46', '\x46', 'H', 'I', 'K', 'K', 
		'N', 'S', 'U', 'W', 'Z', '^', '`', '\x63', '\x65', 'g', 'i', 'i', 'k', 
		't', 'v', 'x', 'z', '\x80', '\x82', '\x83', '\x8A', '\x8C', '\x8E', '\x8E', 
		'\x90', '\x96', '\x98', '\x9B', '\x9D', '\xA4', '\xA6', '\xA8', '\xAA', 
		'\xB2', '\xB4', '\xB5', '\xB7', '\xBD', '\xBF', '\xC7', '\xC9', '\xCD', 
		'\xD1', '\xD3', '\xD5', '\xD8', '\xDA', '\xDB', '\xDF', '\xE0', '\xE3', 
		'\xE3', '\xE5', '\xE6', '\xE8', '\xEA', '\xEC', '\xEF', '\xF1', '\xF1', 
		'\xF3', '\xF5', '\xF7', '\x107', '\x109', '\x111', '\x113', '\x119', '\x11B', 
		'\x121', '\x123', '\x12C', '\x12E', '\x130', '\x133', '\x142', '\x144', 
		'\x144', '\x146', '\x159', '\x15B', '\x15C', '\x15F', '\x15F', '\x161', 
		'\x161', '\x163', '\x165', '\x167', '\x16C', '\x170', '\x182', '\x184', 
		'\x18B', '\x18D', '\x1B3', '\x1B5', '\x1B7', '\x1B9', '\x1BA', '\x1BC', 
		'\x1C0', '\x1C2', '\x1CF', '\x1D1', '\x1DA', '\x1DC', '\x1E5', '\x1E7', 
		'\x1F8', '\x1FA', '\x1FA', '\x1FC', '\x200', '\x203', '\x208', '\x20A', 
		'\x20D', '\x20F', '\x216', '\x219', '\x21A', '\x21C', '\x21D', '\x21F', 
		'\x225', '\x227', '\x22C', '\x22E', '\x231', '\x235', '\x23B', '\x23E', 
		'\x23E', '\x240', '\x244', '\x4', '\x2', '\x255', '\x255', '\x25C', '\x25C', 
		'\x3', '\x2', '\x24E', '\x24E', '\x5', '\x2', '\n', '\n', '\x8D', '\x8D', 
		'\x218', '\x218', '\x4', '\x2', '<', '<', '>', '>', '\x4', '\x2', '\x34', 
		'\x34', '<', '<', '\x4', '\x2', '\x1C2', '\x1C2', '\x213', '\x213', '\x4', 
		'\x2', '\x248', '\x248', '\x256', '\x257', '\x5', '\x2', '\x130', '\x130', 
		'\x24F', '\x24F', '\x25B', '\x25B', '\x5', '\x2', '\xA4', '\xA4', '\xF0', 
		'\xF0', '\x217', '\x217', '\x4', '\x2', '\n', '\n', '\x8D', '\x8D', '\x4', 
		'\x2', '\xBA', '\xBA', '\x101', '\x101', '\x4', '\x2', '\x19E', '\x19E', 
		'\x1C1', '\x1C1', '\x4', '\x2', '\xBD', '\xBD', '\x190', '\x190', '\x6', 
		'\x2', '\xC3', '\xC3', '\xF8', '\xF8', '\x15B', '\x15B', '\x1BE', '\x1BE', 
		'\x3', '\x2', '\x9E', '\x9F', '\x5', '\x2', '+', '+', '\x102', '\x102', 
		'\x20A', '\x20A', '\t', '\x2', 'p', 'p', '\xD7', '\xD7', '\x12E', '\x12E', 
		'\x134', '\x134', '\x1CC', '\x1CC', '\x205', '\x208', '\x243', '\x243', 
		'\x3', '\x2', '\xB2', '\xB3', '\x3', '\x2', '\x108', '\x10B', '\x4', '\x2', 
		'\x112', '\x112', '\x21A', '\x21A', '\x4', '\x2', '\n', '\n', 'h', 'h', 
		'\x4', '\x2', '(', '(', '\x218', '\x218', '\x4', '\x2', '\x21C', '\x21C', 
		'\x21F', '\x21F', '\x4', '\x2', '{', '{', '\xDD', '\xDD', '\x4', '\x2', 
		'\x16', '\x16', '\x81', '\x81', '\x4', '\x2', '\xF5', '\xF5', '\x22F', 
		'\x22F', '\x4', '\x2', '\xC9', '\xC9', '\x17D', '\x17D', '\x5', '\x2', 
		'l', 'l', '\x12A', '\x12A', '\x150', '\x150', '\x4', '\x2', '\x93', '\x93', 
		'\x151', '\x151', '\x3', '\x2', '\x24F', '\x24F', '\x4', '\x2', '\x15', 
		'\x15', '\xF6', '\xF6', '\x4', '\x2', 'i', 'i', '|', '|', '\x4', '\x2', 
		'y', 'y', '\x246', '\x246', '\x4', '\x2', '\xD3', '\xD3', '\x19E', '\x19E', 
		'\x4', '\x2', '\x45', '\x45', '\x16F', '\x16F', '\x4', '\x2', '\x1BD', 
		'\x1BD', '\x1FB', '\x1FB', '\x4', '\x2', '\x1A0', '\x1A0', '\x23A', '\x23A', 
		'\x4', '\x2', '!', '!', '\x1CD', '\x1CD', '\x4', '\x2', '\x10F', '\x10F', 
		'\x1FC', '\x1FC', '\x4', '\x2', '\x111', '\x111', '\x225', '\x225', '\x4', 
		'\x2', '\x8F', '\x8F', '\xFD', '\xFD', '\x4', '\x2', '\x133', '\x133', 
		'\x14E', '\x14E', '\x4', '\x2', '\x156', '\x156', '\x1BF', '\x1BF', '\x4', 
		'\x2', '\x6', '\x6', ' ', ' ', '\x4', '\x2', '\x13', '\x13', '\x19A', 
		'\x19A', '\x4', '\x2', '\xD6', '\xD6', '\x11B', '\x11B', '\x4', '\x2', 
		'\n', '\n', '\x83', '\x83', '\x4', '\x2', '}', '}', '\x192', '\x192', 
		'\x4', '\x2', '\x234', '\x234', '\x236', '\x236', '\x4', '\x2', '\x36', 
		'\x36', '\x144', '\x144', '\x5', '\x2', 'R', 'R', '\xB5', '\xB5', '\xC0', 
		'\xC0', '\x5', '\x2', 'N', 'N', '~', '~', '\x1E8', '\x1E8', '\x4', '\x2', 
		'\x110', '\x110', '\x11E', '\x11E', '\x4', '\x2', '\x9D', '\x9D', '\x212', 
		'\x212', '\x4', '\x2', '\x8A', '\x8A', '\x9A', '\x9A', '\x4', '\x2', '\f', 
		'\f', '\x8B', '\x8B', '\x4', '\x2', '\xDA', '\xDA', '\x163', '\x163', 
		'\x4', '\x2', '\x154', '\x154', '\x1AD', '\x1AD', '\x5', '\x2', '\xB7', 
		'\xB7', '\x116', '\x116', '\x14A', '\x14A', '\x4', '\x2', '\x159', '\x159', 
		'\x1E2', '\x1E2', '\x4', '\x2', '\xE7', '\xE7', '\x141', '\x141', '\x5', 
		'\x2', 'y', 'y', '\xFD', '\xFD', '\x1A4', '\x1A4', '\x5', '\x2', 'y', 
		'y', '\xFD', '\xFD', '\x150', '\x150', '\x4', '\x2', '\x15C', '\x15C', 
		'\x224', '\x224', '\x4', '\x2', '\x245', '\x245', '\x264', '\x264', '\x4', 
		'\x2', '\a', '\a', '#', '#', '\x4', '\x2', 'm', 'm', '\x1C8', '\x1C8', 
		'\a', '\x2', '\x117', '\x118', '\x1D5', '\x1D5', '\x1DD', '\x1DD', '\x1E7', 
		'\x1E7', '\x1F7', '\x1F7', '\x5', '\x2', '}', '}', '\xEB', '\xEB', '\x21E', 
		'\x21E', '\x5', '\x2', '\x13F', '\x13F', '\x165', '\x165', '\x17C', '\x17C', 
		'\x4', '\x2', ',', ',', '\x80', '\x80', '\x4', '\x2', 'g', 'g', '\x1BC', 
		'\x1BC', '\x5', '\x2', '\xC9', '\xC9', '\x103', '\x103', '\x1BA', '\x1BA', 
		'\x4', '\x2', '\x17E', '\x17E', '\x1F2', '\x1F2', '\x4', '\x2', '\x99', 
		'\x99', '\xA0', '\xA0', '\x4', '\x2', '\xA0', '\xA0', '\x15E', '\x15E', 
		'\x5', '\x2', '\xA0', '\xA0', '\xB4', '\xB4', '\x210', '\x210', '\x4', 
		'\x2', 'W', 'W', '\x215', '\x215', '\x4', '\x2', '\x14', '\x14', '\x161', 
		'\x161', '\x4', '\x2', '\x1C9', '\x1C9', '\x204', '\x204', '\x4', '\x2', 
		'\n', '\n', '\xBA', '\xBA', '\x4', '\x2', '\"', '\"', '\xDD', '\xDD', 
		'\x4', '\x2', '\x15D', '\x15D', '\x230', '\x230', '\x4', '\x2', '\x167', 
		'\x167', '\x23A', '\x23A', '\x3', '\x2', '\x1B4', '\x1B5', '\x4', '\x2', 
		'\x192', '\x192', '\x199', '\x199', '\x4', '\x2', '\x8F', '\x8F', '\x1B6', 
		'\x1B6', '\x4', '\x2', '\xA9', '\xA9', '\x1DB', '\x1DB', '\x4', '\x2', 
		'=', '=', '\x13B', '\x13B', '\x4', '\x2', '\xC0', '\xC0', '\x224', '\x224', 
		'\x4', '\x2', '*', '*', '\x1E4', '\x1E4', '\x4', '\x2', '\x5', '\x5', 
		'\x8F', '\x8F', '\x4', '\x2', '\x5', '\x5', '\x132', '\x132', '\x4', '\x2', 
		'k', 'k', '\x147', '\x147', '\x4', '\x2', '\x14F', '\x14F', '\x16F', '\x16F', 
		'\x4', '\x2', '\xAE', '\xAE', '\x148', '\x148', '\x4', '\x2', '\xFD', 
		'\xFD', '\x149', '\x149', '\x4', '\x2', '\xCC', '\xCC', '\x1D6', '\x1D6', 
		'\x4', '\x2', '\x127', '\x127', '\x1E9', '\x1E9', '\x4', '\x2', '\x11C', 
		'\x11C', '\x16F', '\x16F', '\x5', '\x2', '\xB8', '\xB8', '\xED', '\xED', 
		'\x177', '\x177', '\x4', '\x2', '\x12A', '\x12A', '\x150', '\x150', '\x2', 
		'\x1FEC', '\x2', '\x6AA', '\x3', '\x2', '\x2', '\x2', '\x4', '\x6AD', 
		'\x3', '\x2', '\x2', '\x2', '\x6', '\x6B0', '\x3', '\x2', '\x2', '\x2', 
		'\b', '\x6B3', '\x3', '\x2', '\x2', '\x2', '\n', '\x6BE', '\x3', '\x2', 
		'\x2', '\x2', '\f', '\x6C2', '\x3', '\x2', '\x2', '\x2', '\xE', '\x6C5', 
		'\x3', '\x2', '\x2', '\x2', '\x10', '\x6CB', '\x3', '\x2', '\x2', '\x2', 
		'\x12', '\x6D9', '\x3', '\x2', '\x2', '\x2', '\x14', '\x6DE', '\x3', '\x2', 
		'\x2', '\x2', '\x16', '\x6EC', '\x3', '\x2', '\x2', '\x2', '\x18', '\x6F5', 
		'\x3', '\x2', '\x2', '\x2', '\x1A', '\x6FD', '\x3', '\x2', '\x2', '\x2', 
		'\x1C', '\x702', '\x3', '\x2', '\x2', '\x2', '\x1E', '\x723', '\x3', '\x2', 
		'\x2', '\x2', ' ', '\x729', '\x3', '\x2', '\x2', '\x2', '\"', '\x72D', 
		'\x3', '\x2', '\x2', '\x2', '$', '\x74D', '\x3', '\x2', '\x2', '\x2', 
		'&', '\x75F', '\x3', '\x2', '\x2', '\x2', '(', '\x76B', '\x3', '\x2', 
		'\x2', '\x2', '*', '\x76D', '\x3', '\x2', '\x2', '\x2', ',', '\x76F', 
		'\x3', '\x2', '\x2', '\x2', '.', '\x771', '\x3', '\x2', '\x2', '\x2', 
		'\x30', '\x773', '\x3', '\x2', '\x2', '\x2', '\x32', '\x775', '\x3', '\x2', 
		'\x2', '\x2', '\x34', '\x777', '\x3', '\x2', '\x2', '\x2', '\x36', '\x77A', 
		'\x3', '\x2', '\x2', '\x2', '\x38', '\x77D', '\x3', '\x2', '\x2', '\x2', 
		':', '\x784', '\x3', '\x2', '\x2', '\x2', '<', '\x788', '\x3', '\x2', 
		'\x2', '\x2', '>', '\x790', '\x3', '\x2', '\x2', '\x2', '@', '\x794', 
		'\x3', '\x2', '\x2', '\x2', '\x42', '\x796', '\x3', '\x2', '\x2', '\x2', 
		'\x44', '\x798', '\x3', '\x2', '\x2', '\x2', '\x46', '\x7A9', '\x3', '\x2', 
		'\x2', '\x2', 'H', '\x7B2', '\x3', '\x2', '\x2', '\x2', 'J', '\x7BE', 
		'\x3', '\x2', '\x2', '\x2', 'L', '\x7C6', '\x3', '\x2', '\x2', '\x2', 
		'N', '\x7C8', '\x3', '\x2', '\x2', '\x2', 'P', '\x7D9', '\x3', '\x2', 
		'\x2', '\x2', 'R', '\x7E1', '\x3', '\x2', '\x2', '\x2', 'T', '\x7E3', 
		'\x3', '\x2', '\x2', '\x2', 'V', '\x7E5', '\x3', '\x2', '\x2', '\x2', 
		'X', '\x7F1', '\x3', '\x2', '\x2', '\x2', 'Z', '\x7F5', '\x3', '\x2', 
		'\x2', '\x2', '\\', '\x800', '\x3', '\x2', '\x2', '\x2', '^', '\x804', 
		'\x3', '\x2', '\x2', '\x2', '`', '\x809', '\x3', '\x2', '\x2', '\x2', 
		'\x62', '\x819', '\x3', '\x2', '\x2', '\x2', '\x64', '\x81E', '\x3', '\x2', 
		'\x2', '\x2', '\x66', '\x822', '\x3', '\x2', '\x2', '\x2', 'h', '\x826', 
		'\x3', '\x2', '\x2', '\x2', 'j', '\x82A', '\x3', '\x2', '\x2', '\x2', 
		'l', '\x82E', '\x3', '\x2', '\x2', '\x2', 'n', '\x832', '\x3', '\x2', 
		'\x2', '\x2', 'p', '\x836', '\x3', '\x2', '\x2', '\x2', 'r', '\x83A', 
		'\x3', '\x2', '\x2', '\x2', 't', '\x83E', '\x3', '\x2', '\x2', '\x2', 
		'v', '\x842', '\x3', '\x2', '\x2', '\x2', 'x', '\x845', '\x3', '\x2', 
		'\x2', '\x2', 'z', '\x84A', '\x3', '\x2', '\x2', '\x2', '|', '\x854', 
		'\x3', '\x2', '\x2', '\x2', '~', '\x85F', '\x3', '\x2', '\x2', '\x2', 
		'\x80', '\x869', '\x3', '\x2', '\x2', '\x2', '\x82', '\x870', '\x3', '\x2', 
		'\x2', '\x2', '\x84', '\x877', '\x3', '\x2', '\x2', '\x2', '\x86', '\x87E', 
		'\x3', '\x2', '\x2', '\x2', '\x88', '\x885', '\x3', '\x2', '\x2', '\x2', 
		'\x8A', '\x88E', '\x3', '\x2', '\x2', '\x2', '\x8C', '\x899', '\x3', '\x2', 
		'\x2', '\x2', '\x8E', '\x8A5', '\x3', '\x2', '\x2', '\x2', '\x90', '\x8A7', 
		'\x3', '\x2', '\x2', '\x2', '\x92', '\x8AD', '\x3', '\x2', '\x2', '\x2', 
		'\x94', '\x8B2', '\x3', '\x2', '\x2', '\x2', '\x96', '\x8B4', '\x3', '\x2', 
		'\x2', '\x2', '\x98', '\x8BA', '\x3', '\x2', '\x2', '\x2', '\x9A', '\x8BD', 
		'\x3', '\x2', '\x2', '\x2', '\x9C', '\x8C2', '\x3', '\x2', '\x2', '\x2', 
		'\x9E', '\x8C4', '\x3', '\x2', '\x2', '\x2', '\xA0', '\x8C7', '\x3', '\x2', 
		'\x2', '\x2', '\xA2', '\x8CA', '\x3', '\x2', '\x2', '\x2', '\xA4', '\x8CC', 
		'\x3', '\x2', '\x2', '\x2', '\xA6', '\x8D4', '\x3', '\x2', '\x2', '\x2', 
		'\xA8', '\x8DD', '\x3', '\x2', '\x2', '\x2', '\xAA', '\x8EA', '\x3', '\x2', 
		'\x2', '\x2', '\xAC', '\x8EC', '\x3', '\x2', '\x2', '\x2', '\xAE', '\x8EF', 
		'\x3', '\x2', '\x2', '\x2', '\xB0', '\x8F1', '\x3', '\x2', '\x2', '\x2', 
		'\xB2', '\x925', '\x3', '\x2', '\x2', '\x2', '\xB4', '\x927', '\x3', '\x2', 
		'\x2', '\x2', '\xB6', '\x929', '\x3', '\x2', '\x2', '\x2', '\xB8', '\x92B', 
		'\x3', '\x2', '\x2', '\x2', '\xBA', '\x92D', '\x3', '\x2', '\x2', '\x2', 
		'\xBC', '\x92F', '\x3', '\x2', '\x2', '\x2', '\xBE', '\x931', '\x3', '\x2', 
		'\x2', '\x2', '\xC0', '\x933', '\x3', '\x2', '\x2', '\x2', '\xC2', '\x935', 
		'\x3', '\x2', '\x2', '\x2', '\xC4', '\x937', '\x3', '\x2', '\x2', '\x2', 
		'\xC6', '\x941', '\x3', '\x2', '\x2', '\x2', '\xC8', '\x951', '\x3', '\x2', 
		'\x2', '\x2', '\xCA', '\x953', '\x3', '\x2', '\x2', '\x2', '\xCC', '\x95C', 
		'\x3', '\x2', '\x2', '\x2', '\xCE', '\x965', '\x3', '\x2', '\x2', '\x2', 
		'\xD0', '\x967', '\x3', '\x2', '\x2', '\x2', '\xD2', '\x98C', '\x3', '\x2', 
		'\x2', '\x2', '\xD4', '\x991', '\x3', '\x2', '\x2', '\x2', '\xD6', '\x993', 
		'\x3', '\x2', '\x2', '\x2', '\xD8', '\x9A0', '\x3', '\x2', '\x2', '\x2', 
		'\xDA', '\x9A8', '\x3', '\x2', '\x2', '\x2', '\xDC', '\x9AD', '\x3', '\x2', 
		'\x2', '\x2', '\xDE', '\x9B8', '\x3', '\x2', '\x2', '\x2', '\xE0', '\x9BB', 
		'\x3', '\x2', '\x2', '\x2', '\xE2', '\x9C0', '\x3', '\x2', '\x2', '\x2', 
		'\xE4', '\x9C5', '\x3', '\x2', '\x2', '\x2', '\xE6', '\x9CB', '\x3', '\x2', 
		'\x2', '\x2', '\xE8', '\x9CE', '\x3', '\x2', '\x2', '\x2', '\xEA', '\x9D7', 
		'\x3', '\x2', '\x2', '\x2', '\xEC', '\x9DC', '\x3', '\x2', '\x2', '\x2', 
		'\xEE', '\x9E1', '\x3', '\x2', '\x2', '\x2', '\xF0', '\x9E3', '\x3', '\x2', 
		'\x2', '\x2', '\xF2', '\x9EA', '\x3', '\x2', '\x2', '\x2', '\xF4', '\x9EF', 
		'\x3', '\x2', '\x2', '\x2', '\xF6', '\x9F6', '\x3', '\x2', '\x2', '\x2', 
		'\xF8', '\x9FB', '\x3', '\x2', '\x2', '\x2', '\xFA', '\xA01', '\x3', '\x2', 
		'\x2', '\x2', '\xFC', '\xA04', '\x3', '\x2', '\x2', '\x2', '\xFE', '\xA11', 
		'\x3', '\x2', '\x2', '\x2', '\x100', '\xA15', '\x3', '\x2', '\x2', '\x2', 
		'\x102', '\xA1A', '\x3', '\x2', '\x2', '\x2', '\x104', '\xA1F', '\x3', 
		'\x2', '\x2', '\x2', '\x106', '\xA28', '\x3', '\x2', '\x2', '\x2', '\x108', 
		'\xA2A', '\x3', '\x2', '\x2', '\x2', '\x10A', '\xA2C', '\x3', '\x2', '\x2', 
		'\x2', '\x10C', '\xA30', '\x3', '\x2', '\x2', '\x2', '\x10E', '\xA36', 
		'\x3', '\x2', '\x2', '\x2', '\x110', '\xA3F', '\x3', '\x2', '\x2', '\x2', 
		'\x112', '\xA42', '\x3', '\x2', '\x2', '\x2', '\x114', '\xA46', '\x3', 
		'\x2', '\x2', '\x2', '\x116', '\xA4B', '\x3', '\x2', '\x2', '\x2', '\x118', 
		'\xA4D', '\x3', '\x2', '\x2', '\x2', '\x11A', '\xA58', '\x3', '\x2', '\x2', 
		'\x2', '\x11C', '\xA5D', '\x3', '\x2', '\x2', '\x2', '\x11E', '\xA64', 
		'\x3', '\x2', '\x2', '\x2', '\x120', '\xA6D', '\x3', '\x2', '\x2', '\x2', 
		'\x122', '\xA72', '\x3', '\x2', '\x2', '\x2', '\x124', '\xA76', '\x3', 
		'\x2', '\x2', '\x2', '\x126', '\xA7D', '\x3', '\x2', '\x2', '\x2', '\x128', 
		'\xA82', '\x3', '\x2', '\x2', '\x2', '\x12A', '\xA85', '\x3', '\x2', '\x2', 
		'\x2', '\x12C', '\xA88', '\x3', '\x2', '\x2', '\x2', '\x12E', '\xA8B', 
		'\x3', '\x2', '\x2', '\x2', '\x130', '\xA98', '\x3', '\x2', '\x2', '\x2', 
		'\x132', '\xA9C', '\x3', '\x2', '\x2', '\x2', '\x134', '\xAA8', '\x3', 
		'\x2', '\x2', '\x2', '\x136', '\xAAE', '\x3', '\x2', '\x2', '\x2', '\x138', 
		'\xAB9', '\x3', '\x2', '\x2', '\x2', '\x13A', '\xABB', '\x3', '\x2', '\x2', 
		'\x2', '\x13C', '\xABD', '\x3', '\x2', '\x2', '\x2', '\x13E', '\xABF', 
		'\x3', '\x2', '\x2', '\x2', '\x140', '\xAC5', '\x3', '\x2', '\x2', '\x2', 
		'\x142', '\xAD6', '\x3', '\x2', '\x2', '\x2', '\x144', '\xAD8', '\x3', 
		'\x2', '\x2', '\x2', '\x146', '\xADC', '\x3', '\x2', '\x2', '\x2', '\x148', 
		'\xAEE', '\x3', '\x2', '\x2', '\x2', '\x14A', '\xAF1', '\x3', '\x2', '\x2', 
		'\x2', '\x14C', '\xAF8', '\x3', '\x2', '\x2', '\x2', '\x14E', '\xAFE', 
		'\x3', '\x2', '\x2', '\x2', '\x150', '\xB05', '\x3', '\x2', '\x2', '\x2', 
		'\x152', '\xB0B', '\x3', '\x2', '\x2', '\x2', '\x154', '\xB0D', '\x3', 
		'\x2', '\x2', '\x2', '\x156', '\xB10', '\x3', '\x2', '\x2', '\x2', '\x158', 
		'\xB12', '\x3', '\x2', '\x2', '\x2', '\x15A', '\xB23', '\x3', '\x2', '\x2', 
		'\x2', '\x15C', '\xB25', '\x3', '\x2', '\x2', '\x2', '\x15E', '\xB29', 
		'\x3', '\x2', '\x2', '\x2', '\x160', '\xB3B', '\x3', '\x2', '\x2', '\x2', 
		'\x162', '\xB3D', '\x3', '\x2', '\x2', '\x2', '\x164', '\xB4A', '\x3', 
		'\x2', '\x2', '\x2', '\x166', '\xB4C', '\x3', '\x2', '\x2', '\x2', '\x168', 
		'\xB54', '\x3', '\x2', '\x2', '\x2', '\x16A', '\xB5B', '\x3', '\x2', '\x2', 
		'\x2', '\x16C', '\xB5E', '\x3', '\x2', '\x2', '\x2', '\x16E', '\xB67', 
		'\x3', '\x2', '\x2', '\x2', '\x170', '\xB6F', '\x3', '\x2', '\x2', '\x2', 
		'\x172', '\xB73', '\x3', '\x2', '\x2', '\x2', '\x174', '\xB77', '\x3', 
		'\x2', '\x2', '\x2', '\x176', '\xB7F', '\x3', '\x2', '\x2', '\x2', '\x178', 
		'\xB87', '\x3', '\x2', '\x2', '\x2', '\x17A', '\xB89', '\x3', '\x2', '\x2', 
		'\x2', '\x17C', '\xB8B', '\x3', '\x2', '\x2', '\x2', '\x17E', '\xB98', 
		'\x3', '\x2', '\x2', '\x2', '\x180', '\xB9B', '\x3', '\x2', '\x2', '\x2', 
		'\x182', '\xBA9', '\x3', '\x2', '\x2', '\x2', '\x184', '\xBAB', '\x3', 
		'\x2', '\x2', '\x2', '\x186', '\xBB1', '\x3', '\x2', '\x2', '\x2', '\x188', 
		'\xBB6', '\x3', '\x2', '\x2', '\x2', '\x18A', '\xBBB', '\x3', '\x2', '\x2', 
		'\x2', '\x18C', '\xBC7', '\x3', '\x2', '\x2', '\x2', '\x18E', '\xBC9', 
		'\x3', '\x2', '\x2', '\x2', '\x190', '\xBCD', '\x3', '\x2', '\x2', '\x2', 
		'\x192', '\xBD2', '\x3', '\x2', '\x2', '\x2', '\x194', '\xBD8', '\x3', 
		'\x2', '\x2', '\x2', '\x196', '\xBE0', '\x3', '\x2', '\x2', '\x2', '\x198', 
		'\xBE3', '\x3', '\x2', '\x2', '\x2', '\x19A', '\xBE6', '\x3', '\x2', '\x2', 
		'\x2', '\x19C', '\xBE9', '\x3', '\x2', '\x2', '\x2', '\x19E', '\xBEC', 
		'\x3', '\x2', '\x2', '\x2', '\x1A0', '\xBF1', '\x3', '\x2', '\x2', '\x2', 
		'\x1A2', '\xC02', '\x3', '\x2', '\x2', '\x2', '\x1A4', '\xC0A', '\x3', 
		'\x2', '\x2', '\x2', '\x1A6', '\xC1B', '\x3', '\x2', '\x2', '\x2', '\x1A8', 
		'\xC1F', '\x3', '\x2', '\x2', '\x2', '\x1AA', '\xC36', '\x3', '\x2', '\x2', 
		'\x2', '\x1AC', '\xC3A', '\x3', '\x2', '\x2', '\x2', '\x1AE', '\xC46', 
		'\x3', '\x2', '\x2', '\x2', '\x1B0', '\xC48', '\x3', '\x2', '\x2', '\x2', 
		'\x1B2', '\xC4F', '\x3', '\x2', '\x2', '\x2', '\x1B4', '\xC51', '\x3', 
		'\x2', '\x2', '\x2', '\x1B6', '\xC5C', '\x3', '\x2', '\x2', '\x2', '\x1B8', 
		'\xC76', '\x3', '\x2', '\x2', '\x2', '\x1BA', '\xC78', '\x3', '\x2', '\x2', 
		'\x2', '\x1BC', '\xC85', '\x3', '\x2', '\x2', '\x2', '\x1BE', '\xC92', 
		'\x3', '\x2', '\x2', '\x2', '\x1C0', '\xCA1', '\x3', '\x2', '\x2', '\x2', 
		'\x1C2', '\xCA3', '\x3', '\x2', '\x2', '\x2', '\x1C4', '\xCBB', '\x3', 
		'\x2', '\x2', '\x2', '\x1C6', '\xCBD', '\x3', '\x2', '\x2', '\x2', '\x1C8', 
		'\xCBF', '\x3', '\x2', '\x2', '\x2', '\x1CA', '\xCC2', '\x3', '\x2', '\x2', 
		'\x2', '\x1CC', '\xCCE', '\x3', '\x2', '\x2', '\x2', '\x1CE', '\xCD6', 
		'\x3', '\x2', '\x2', '\x2', '\x1D0', '\xCDB', '\x3', '\x2', '\x2', '\x2', 
		'\x1D2', '\xCE0', '\x3', '\x2', '\x2', '\x2', '\x1D4', '\xCE3', '\x3', 
		'\x2', '\x2', '\x2', '\x1D6', '\xCEE', '\x3', '\x2', '\x2', '\x2', '\x1D8', 
		'\xCF3', '\x3', '\x2', '\x2', '\x2', '\x1DA', '\xCFF', '\x3', '\x2', '\x2', 
		'\x2', '\x1DC', '\xD01', '\x3', '\x2', '\x2', '\x2', '\x1DE', '\xD13', 
		'\x3', '\x2', '\x2', '\x2', '\x1E0', '\xD26', '\x3', '\x2', '\x2', '\x2', 
		'\x1E2', '\xD28', '\x3', '\x2', '\x2', '\x2', '\x1E4', '\xD2C', '\x3', 
		'\x2', '\x2', '\x2', '\x1E6', '\xD32', '\x3', '\x2', '\x2', '\x2', '\x1E8', 
		'\xD34', '\x3', '\x2', '\x2', '\x2', '\x1EA', '\xD39', '\x3', '\x2', '\x2', 
		'\x2', '\x1EC', '\xD3F', '\x3', '\x2', '\x2', '\x2', '\x1EE', '\xD41', 
		'\x3', '\x2', '\x2', '\x2', '\x1F0', '\xD44', '\x3', '\x2', '\x2', '\x2', 
		'\x1F2', '\xD49', '\x3', '\x2', '\x2', '\x2', '\x1F4', '\xD4D', '\x3', 
		'\x2', '\x2', '\x2', '\x1F6', '\xD5B', '\x3', '\x2', '\x2', '\x2', '\x1F8', 
		'\xD5E', '\x3', '\x2', '\x2', '\x2', '\x1FA', '\xD61', '\x3', '\x2', '\x2', 
		'\x2', '\x1FC', '\xD65', '\x3', '\x2', '\x2', '\x2', '\x1FE', '\xD68', 
		'\x3', '\x2', '\x2', '\x2', '\x200', '\xD6D', '\x3', '\x2', '\x2', '\x2', 
		'\x202', '\xD7A', '\x3', '\x2', '\x2', '\x2', '\x204', '\xD85', '\x3', 
		'\x2', '\x2', '\x2', '\x206', '\xD8B', '\x3', '\x2', '\x2', '\x2', '\x208', 
		'\xD8D', '\x3', '\x2', '\x2', '\x2', '\x20A', '\xD90', '\x3', '\x2', '\x2', 
		'\x2', '\x20C', '\xD94', '\x3', '\x2', '\x2', '\x2', '\x20E', '\xDA3', 
		'\x3', '\x2', '\x2', '\x2', '\x210', '\xDA5', '\x3', '\x2', '\x2', '\x2', 
		'\x212', '\xDAD', '\x3', '\x2', '\x2', '\x2', '\x214', '\xDB0', '\x3', 
		'\x2', '\x2', '\x2', '\x216', '\xDB2', '\x3', '\x2', '\x2', '\x2', '\x218', 
		'\xDB6', '\x3', '\x2', '\x2', '\x2', '\x21A', '\xDBC', '\x3', '\x2', '\x2', 
		'\x2', '\x21C', '\xDC7', '\x3', '\x2', '\x2', '\x2', '\x21E', '\xDCB', 
		'\x3', '\x2', '\x2', '\x2', '\x220', '\xDCF', '\x3', '\x2', '\x2', '\x2', 
		'\x222', '\xDD2', '\x3', '\x2', '\x2', '\x2', '\x224', '\xDD6', '\x3', 
		'\x2', '\x2', '\x2', '\x226', '\xDE2', '\x3', '\x2', '\x2', '\x2', '\x228', 
		'\xDE6', '\x3', '\x2', '\x2', '\x2', '\x22A', '\xDEF', '\x3', '\x2', '\x2', 
		'\x2', '\x22C', '\xE01', '\x3', '\x2', '\x2', '\x2', '\x22E', '\xE10', 
		'\x3', '\x2', '\x2', '\x2', '\x230', '\xE25', '\x3', '\x2', '\x2', '\x2', 
		'\x232', '\xE29', '\x3', '\x2', '\x2', '\x2', '\x234', '\xE2C', '\x3', 
		'\x2', '\x2', '\x2', '\x236', '\xE32', '\x3', '\x2', '\x2', '\x2', '\x238', 
		'\xE3B', '\x3', '\x2', '\x2', '\x2', '\x23A', '\xE44', '\x3', '\x2', '\x2', 
		'\x2', '\x23C', '\xE4A', '\x3', '\x2', '\x2', '\x2', '\x23E', '\xE57', 
		'\x3', '\x2', '\x2', '\x2', '\x240', '\xE5D', '\x3', '\x2', '\x2', '\x2', 
		'\x242', '\xE81', '\x3', '\x2', '\x2', '\x2', '\x244', '\xE85', '\x3', 
		'\x2', '\x2', '\x2', '\x246', '\xE94', '\x3', '\x2', '\x2', '\x2', '\x248', 
		'\xE96', '\x3', '\x2', '\x2', '\x2', '\x24A', '\xE9C', '\x3', '\x2', '\x2', 
		'\x2', '\x24C', '\xEA0', '\x3', '\x2', '\x2', '\x2', '\x24E', '\xEAD', 
		'\x3', '\x2', '\x2', '\x2', '\x250', '\xEB3', '\x3', '\x2', '\x2', '\x2', 
		'\x252', '\xEB7', '\x3', '\x2', '\x2', '\x2', '\x254', '\xEBB', '\x3', 
		'\x2', '\x2', '\x2', '\x256', '\xEC8', '\x3', '\x2', '\x2', '\x2', '\x258', 
		'\xED0', '\x3', '\x2', '\x2', '\x2', '\x25A', '\xED6', '\x3', '\x2', '\x2', 
		'\x2', '\x25C', '\xEF3', '\x3', '\x2', '\x2', '\x2', '\x25E', '\xEF5', 
		'\x3', '\x2', '\x2', '\x2', '\x260', '\xEFE', '\x3', '\x2', '\x2', '\x2', 
		'\x262', '\xF00', '\x3', '\x2', '\x2', '\x2', '\x264', '\xF03', '\x3', 
		'\x2', '\x2', '\x2', '\x266', '\xF07', '\x3', '\x2', '\x2', '\x2', '\x268', 
		'\xF1C', '\x3', '\x2', '\x2', '\x2', '\x26A', '\xF1F', '\x3', '\x2', '\x2', 
		'\x2', '\x26C', '\xF21', '\x3', '\x2', '\x2', '\x2', '\x26E', '\xF23', 
		'\x3', '\x2', '\x2', '\x2', '\x270', '\xF2A', '\x3', '\x2', '\x2', '\x2', 
		'\x272', '\xF2C', '\x3', '\x2', '\x2', '\x2', '\x274', '\xF34', '\x3', 
		'\x2', '\x2', '\x2', '\x276', '\xF3C', '\x3', '\x2', '\x2', '\x2', '\x278', 
		'\xF44', '\x3', '\x2', '\x2', '\x2', '\x27A', '\xF49', '\x3', '\x2', '\x2', 
		'\x2', '\x27C', '\xF50', '\x3', '\x2', '\x2', '\x2', '\x27E', '\xF56', 
		'\x3', '\x2', '\x2', '\x2', '\x280', '\xF61', '\x3', '\x2', '\x2', '\x2', 
		'\x282', '\xF69', '\x3', '\x2', '\x2', '\x2', '\x284', '\xF6D', '\x3', 
		'\x2', '\x2', '\x2', '\x286', '\xF73', '\x3', '\x2', '\x2', '\x2', '\x288', 
		'\xF7B', '\x3', '\x2', '\x2', '\x2', '\x28A', '\xF86', '\x3', '\x2', '\x2', 
		'\x2', '\x28C', '\xF8E', '\x3', '\x2', '\x2', '\x2', '\x28E', '\xF91', 
		'\x3', '\x2', '\x2', '\x2', '\x290', '\xF9C', '\x3', '\x2', '\x2', '\x2', 
		'\x292', '\xFA7', '\x3', '\x2', '\x2', '\x2', '\x294', '\xFBB', '\x3', 
		'\x2', '\x2', '\x2', '\x296', '\xFBD', '\x3', '\x2', '\x2', '\x2', '\x298', 
		'\xFC8', '\x3', '\x2', '\x2', '\x2', '\x29A', '\xFDB', '\x3', '\x2', '\x2', 
		'\x2', '\x29C', '\xFDF', '\x3', '\x2', '\x2', '\x2', '\x29E', '\xFE2', 
		'\x3', '\x2', '\x2', '\x2', '\x2A0', '\xFE7', '\x3', '\x2', '\x2', '\x2', 
		'\x2A2', '\xFEB', '\x3', '\x2', '\x2', '\x2', '\x2A4', '\xFF6', '\x3', 
		'\x2', '\x2', '\x2', '\x2A6', '\x1000', '\x3', '\x2', '\x2', '\x2', '\x2A8', 
		'\x1003', '\x3', '\x2', '\x2', '\x2', '\x2AA', '\x100B', '\x3', '\x2', 
		'\x2', '\x2', '\x2AC', '\x1019', '\x3', '\x2', '\x2', '\x2', '\x2AE', 
		'\x101B', '\x3', '\x2', '\x2', '\x2', '\x2B0', '\x1028', '\x3', '\x2', 
		'\x2', '\x2', '\x2B2', '\x1030', '\x3', '\x2', '\x2', '\x2', '\x2B4', 
		'\x1071', '\x3', '\x2', '\x2', '\x2', '\x2B6', '\x1073', '\x3', '\x2', 
		'\x2', '\x2', '\x2B8', '\x1081', '\x3', '\x2', '\x2', '\x2', '\x2BA', 
		'\x1086', '\x3', '\x2', '\x2', '\x2', '\x2BC', '\x1093', '\x3', '\x2', 
		'\x2', '\x2', '\x2BE', '\x1095', '\x3', '\x2', '\x2', '\x2', '\x2C0', 
		'\x10A6', '\x3', '\x2', '\x2', '\x2', '\x2C2', '\x10A8', '\x3', '\x2', 
		'\x2', '\x2', '\x2C4', '\x10AC', '\x3', '\x2', '\x2', '\x2', '\x2C6', 
		'\x10C0', '\x3', '\x2', '\x2', '\x2', '\x2C8', '\x10C4', '\x3', '\x2', 
		'\x2', '\x2', '\x2CA', '\x10C9', '\x3', '\x2', '\x2', '\x2', '\x2CC', 
		'\x10CC', '\x3', '\x2', '\x2', '\x2', '\x2CE', '\x10D2', '\x3', '\x2', 
		'\x2', '\x2', '\x2D0', '\x10D9', '\x3', '\x2', '\x2', '\x2', '\x2D2', 
		'\x10DC', '\x3', '\x2', '\x2', '\x2', '\x2D4', '\x10E2', '\x3', '\x2', 
		'\x2', '\x2', '\x2D6', '\x1104', '\x3', '\x2', '\x2', '\x2', '\x2D8', 
		'\x110F', '\x3', '\x2', '\x2', '\x2', '\x2DA', '\x1111', '\x3', '\x2', 
		'\x2', '\x2', '\x2DC', '\x1116', '\x3', '\x2', '\x2', '\x2', '\x2DE', 
		'\x111D', '\x3', '\x2', '\x2', '\x2', '\x2E0', '\x111F', '\x3', '\x2', 
		'\x2', '\x2', '\x2E2', '\x1124', '\x3', '\x2', '\x2', '\x2', '\x2E4', 
		'\x1133', '\x3', '\x2', '\x2', '\x2', '\x2E6', '\x1135', '\x3', '\x2', 
		'\x2', '\x2', '\x2E8', '\x113B', '\x3', '\x2', '\x2', '\x2', '\x2EA', 
		'\x1141', '\x3', '\x2', '\x2', '\x2', '\x2EC', '\x1154', '\x3', '\x2', 
		'\x2', '\x2', '\x2EE', '\x1156', '\x3', '\x2', '\x2', '\x2', '\x2F0', 
		'\x1168', '\x3', '\x2', '\x2', '\x2', '\x2F2', '\x1184', '\x3', '\x2', 
		'\x2', '\x2', '\x2F4', '\x118D', '\x3', '\x2', '\x2', '\x2', '\x2F6', 
		'\x1199', '\x3', '\x2', '\x2', '\x2', '\x2F8', '\x119E', '\x3', '\x2', 
		'\x2', '\x2', '\x2FA', '\x11A0', '\x3', '\x2', '\x2', '\x2', '\x2FC', 
		'\x11A5', '\x3', '\x2', '\x2', '\x2', '\x2FE', '\x11B7', '\x3', '\x2', 
		'\x2', '\x2', '\x300', '\x11B9', '\x3', '\x2', '\x2', '\x2', '\x302', 
		'\x11BC', '\x3', '\x2', '\x2', '\x2', '\x304', '\x11C0', '\x3', '\x2', 
		'\x2', '\x2', '\x306', '\x11C5', '\x3', '\x2', '\x2', '\x2', '\x308', 
		'\x11CF', '\x3', '\x2', '\x2', '\x2', '\x30A', '\x11D3', '\x3', '\x2', 
		'\x2', '\x2', '\x30C', '\x11F4', '\x3', '\x2', '\x2', '\x2', '\x30E', 
		'\x11F7', '\x3', '\x2', '\x2', '\x2', '\x310', '\x11FF', '\x3', '\x2', 
		'\x2', '\x2', '\x312', '\x1203', '\x3', '\x2', '\x2', '\x2', '\x314', 
		'\x120C', '\x3', '\x2', '\x2', '\x2', '\x316', '\x121A', '\x3', '\x2', 
		'\x2', '\x2', '\x318', '\x121C', '\x3', '\x2', '\x2', '\x2', '\x31A', 
		'\x121F', '\x3', '\x2', '\x2', '\x2', '\x31C', '\x122A', '\x3', '\x2', 
		'\x2', '\x2', '\x31E', '\x1232', '\x3', '\x2', '\x2', '\x2', '\x320', 
		'\x123A', '\x3', '\x2', '\x2', '\x2', '\x322', '\x123E', '\x3', '\x2', 
		'\x2', '\x2', '\x324', '\x1240', '\x3', '\x2', '\x2', '\x2', '\x326', 
		'\x1246', '\x3', '\x2', '\x2', '\x2', '\x328', '\x124A', '\x3', '\x2', 
		'\x2', '\x2', '\x32A', '\x1250', '\x3', '\x2', '\x2', '\x2', '\x32C', 
		'\x125F', '\x3', '\x2', '\x2', '\x2', '\x32E', '\x1263', '\x3', '\x2', 
		'\x2', '\x2', '\x330', '\x126D', '\x3', '\x2', '\x2', '\x2', '\x332', 
		'\x1272', '\x3', '\x2', '\x2', '\x2', '\x334', '\x127B', '\x3', '\x2', 
		'\x2', '\x2', '\x336', '\x1283', '\x3', '\x2', '\x2', '\x2', '\x338', 
		'\x128F', '\x3', '\x2', '\x2', '\x2', '\x33A', '\x129A', '\x3', '\x2', 
		'\x2', '\x2', '\x33C', '\x12A6', '\x3', '\x2', '\x2', '\x2', '\x33E', 
		'\x12AC', '\x3', '\x2', '\x2', '\x2', '\x340', '\x12BA', '\x3', '\x2', 
		'\x2', '\x2', '\x342', '\x12BD', '\x3', '\x2', '\x2', '\x2', '\x344', 
		'\x12C3', '\x3', '\x2', '\x2', '\x2', '\x346', '\x12C6', '\x3', '\x2', 
		'\x2', '\x2', '\x348', '\x12C9', '\x3', '\x2', '\x2', '\x2', '\x34A', 
		'\x12D2', '\x3', '\x2', '\x2', '\x2', '\x34C', '\x12D5', '\x3', '\x2', 
		'\x2', '\x2', '\x34E', '\x12DC', '\x3', '\x2', '\x2', '\x2', '\x350', 
		'\x12E1', '\x3', '\x2', '\x2', '\x2', '\x352', '\x12E5', '\x3', '\x2', 
		'\x2', '\x2', '\x354', '\x12E7', '\x3', '\x2', '\x2', '\x2', '\x356', 
		'\x12EF', '\x3', '\x2', '\x2', '\x2', '\x358', '\x12FC', '\x3', '\x2', 
		'\x2', '\x2', '\x35A', '\x12FE', '\x3', '\x2', '\x2', '\x2', '\x35C', 
		'\x1305', '\x3', '\x2', '\x2', '\x2', '\x35E', '\x1312', '\x3', '\x2', 
		'\x2', '\x2', '\x360', '\x1314', '\x3', '\x2', '\x2', '\x2', '\x362', 
		'\x131B', '\x3', '\x2', '\x2', '\x2', '\x364', '\x1326', '\x3', '\x2', 
		'\x2', '\x2', '\x366', '\x1338', '\x3', '\x2', '\x2', '\x2', '\x368', 
		'\x134B', '\x3', '\x2', '\x2', '\x2', '\x36A', '\x1350', '\x3', '\x2', 
		'\x2', '\x2', '\x36C', '\x1354', '\x3', '\x2', '\x2', '\x2', '\x36E', 
		'\x1357', '\x3', '\x2', '\x2', '\x2', '\x370', '\x1359', '\x3', '\x2', 
		'\x2', '\x2', '\x372', '\x135B', '\x3', '\x2', '\x2', '\x2', '\x374', 
		'\x1366', '\x3', '\x2', '\x2', '\x2', '\x376', '\x136A', '\x3', '\x2', 
		'\x2', '\x2', '\x378', '\x136C', '\x3', '\x2', '\x2', '\x2', '\x37A', 
		'\x1374', '\x3', '\x2', '\x2', '\x2', '\x37C', '\x1376', '\x3', '\x2', 
		'\x2', '\x2', '\x37E', '\x138B', '\x3', '\x2', '\x2', '\x2', '\x380', 
		'\x138D', '\x3', '\x2', '\x2', '\x2', '\x382', '\x1392', '\x3', '\x2', 
		'\x2', '\x2', '\x384', '\x1394', '\x3', '\x2', '\x2', '\x2', '\x386', 
		'\x1397', '\x3', '\x2', '\x2', '\x2', '\x388', '\x139E', '\x3', '\x2', 
		'\x2', '\x2', '\x38A', '\x13A1', '\x3', '\x2', '\x2', '\x2', '\x38C', 
		'\x13A6', '\x3', '\x2', '\x2', '\x2', '\x38E', '\x13A9', '\x3', '\x2', 
		'\x2', '\x2', '\x390', '\x13AC', '\x3', '\x2', '\x2', '\x2', '\x392', 
		'\x13B0', '\x3', '\x2', '\x2', '\x2', '\x394', '\x13B3', '\x3', '\x2', 
		'\x2', '\x2', '\x396', '\x13B6', '\x3', '\x2', '\x2', '\x2', '\x398', 
		'\x13B9', '\x3', '\x2', '\x2', '\x2', '\x39A', '\x13BC', '\x3', '\x2', 
		'\x2', '\x2', '\x39C', '\x13BE', '\x3', '\x2', '\x2', '\x2', '\x39E', 
		'\x13C2', '\x3', '\x2', '\x2', '\x2', '\x3A0', '\x13C4', '\x3', '\x2', 
		'\x2', '\x2', '\x3A2', '\x13C8', '\x3', '\x2', '\x2', '\x2', '\x3A4', 
		'\x13CC', '\x3', '\x2', '\x2', '\x2', '\x3A6', '\x13D0', '\x3', '\x2', 
		'\x2', '\x2', '\x3A8', '\x13D5', '\x3', '\x2', '\x2', '\x2', '\x3AA', 
		'\x13D8', '\x3', '\x2', '\x2', '\x2', '\x3AC', '\x13DE', '\x3', '\x2', 
		'\x2', '\x2', '\x3AE', '\x13E7', '\x3', '\x2', '\x2', '\x2', '\x3B0', 
		'\x13EC', '\x3', '\x2', '\x2', '\x2', '\x3B2', '\x13F3', '\x3', '\x2', 
		'\x2', '\x2', '\x3B4', '\x13FB', '\x3', '\x2', '\x2', '\x2', '\x3B6', 
		'\x1404', '\x3', '\x2', '\x2', '\x2', '\x3B8', '\x140A', '\x3', '\x2', 
		'\x2', '\x2', '\x3BA', '\x1411', '\x3', '\x2', '\x2', '\x2', '\x3BC', 
		'\x141B', '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x1427', '\x3', '\x2', 
		'\x2', '\x2', '\x3C0', '\x1437', '\x3', '\x2', '\x2', '\x2', '\x3C2', 
		'\x1439', '\x3', '\x2', '\x2', '\x2', '\x3C4', '\x143E', '\x3', '\x2', 
		'\x2', '\x2', '\x3C6', '\x1442', '\x3', '\x2', '\x2', '\x2', '\x3C8', 
		'\x1448', '\x3', '\x2', '\x2', '\x2', '\x3CA', '\x144C', '\x3', '\x2', 
		'\x2', '\x2', '\x3CC', '\x144F', '\x3', '\x2', '\x2', '\x2', '\x3CE', 
		'\x1452', '\x3', '\x2', '\x2', '\x2', '\x3D0', '\x145A', '\x3', '\x2', 
		'\x2', '\x2', '\x3D2', '\x1472', '\x3', '\x2', '\x2', '\x2', '\x3D4', 
		'\x1474', '\x3', '\x2', '\x2', '\x2', '\x3D6', '\x147B', '\x3', '\x2', 
		'\x2', '\x2', '\x3D8', '\x147D', '\x3', '\x2', '\x2', '\x2', '\x3DA', 
		'\x1485', '\x3', '\x2', '\x2', '\x2', '\x3DC', '\x148D', '\x3', '\x2', 
		'\x2', '\x2', '\x3DE', '\x1491', '\x3', '\x2', '\x2', '\x2', '\x3E0', 
		'\x1494', '\x3', '\x2', '\x2', '\x2', '\x3E2', '\x149B', '\x3', '\x2', 
		'\x2', '\x2', '\x3E4', '\x14A0', '\x3', '\x2', '\x2', '\x2', '\x3E6', 
		'\x14A6', '\x3', '\x2', '\x2', '\x2', '\x3E8', '\x14AC', '\x3', '\x2', 
		'\x2', '\x2', '\x3EA', '\x14B0', '\x3', '\x2', '\x2', '\x2', '\x3EC', 
		'\x14B6', '\x3', '\x2', '\x2', '\x2', '\x3EE', '\x14BC', '\x3', '\x2', 
		'\x2', '\x2', '\x3F0', '\x14D9', '\x3', '\x2', '\x2', '\x2', '\x3F2', 
		'\x14E0', '\x3', '\x2', '\x2', '\x2', '\x3F4', '\x14E2', '\x3', '\x2', 
		'\x2', '\x2', '\x3F6', '\x14E5', '\x3', '\x2', '\x2', '\x2', '\x3F8', 
		'\x14E8', '\x3', '\x2', '\x2', '\x2', '\x3FA', '\x14EF', '\x3', '\x2', 
		'\x2', '\x2', '\x3FC', '\x14F6', '\x3', '\x2', '\x2', '\x2', '\x3FE', 
		'\x14FD', '\x3', '\x2', '\x2', '\x2', '\x400', '\x1505', '\x3', '\x2', 
		'\x2', '\x2', '\x402', '\x150C', '\x3', '\x2', '\x2', '\x2', '\x404', 
		'\x150E', '\x3', '\x2', '\x2', '\x2', '\x406', '\x1511', '\x3', '\x2', 
		'\x2', '\x2', '\x408', '\x151C', '\x3', '\x2', '\x2', '\x2', '\x40A', 
		'\x1521', '\x3', '\x2', '\x2', '\x2', '\x40C', '\x1523', '\x3', '\x2', 
		'\x2', '\x2', '\x40E', '\x1526', '\x3', '\x2', '\x2', '\x2', '\x410', 
		'\x152F', '\x3', '\x2', '\x2', '\x2', '\x412', '\x153A', '\x3', '\x2', 
		'\x2', '\x2', '\x414', '\x153E', '\x3', '\x2', '\x2', '\x2', '\x416', 
		'\x1545', '\x3', '\x2', '\x2', '\x2', '\x418', '\x1548', '\x3', '\x2', 
		'\x2', '\x2', '\x41A', '\x154E', '\x3', '\x2', '\x2', '\x2', '\x41C', 
		'\x1551', '\x3', '\x2', '\x2', '\x2', '\x41E', '\x1554', '\x3', '\x2', 
		'\x2', '\x2', '\x420', '\x1574', '\x3', '\x2', '\x2', '\x2', '\x422', 
		'\x1576', '\x3', '\x2', '\x2', '\x2', '\x424', '\x1579', '\x3', '\x2', 
		'\x2', '\x2', '\x426', '\x157C', '\x3', '\x2', '\x2', '\x2', '\x428', 
		'\x1580', '\x3', '\x2', '\x2', '\x2', '\x42A', '\x1582', '\x3', '\x2', 
		'\x2', '\x2', '\x42C', '\x158C', '\x3', '\x2', '\x2', '\x2', '\x42E', 
		'\x158E', '\x3', '\x2', '\x2', '\x2', '\x430', '\x159D', '\x3', '\x2', 
		'\x2', '\x2', '\x432', '\x159F', '\x3', '\x2', '\x2', '\x2', '\x434', 
		'\x15A2', '\x3', '\x2', '\x2', '\x2', '\x436', '\x15A8', '\x3', '\x2', 
		'\x2', '\x2', '\x438', '\x15B3', '\x3', '\x2', '\x2', '\x2', '\x43A', 
		'\x15B7', '\x3', '\x2', '\x2', '\x2', '\x43C', '\x15B9', '\x3', '\x2', 
		'\x2', '\x2', '\x43E', '\x15C4', '\x3', '\x2', '\x2', '\x2', '\x440', 
		'\x15C9', '\x3', '\x2', '\x2', '\x2', '\x442', '\x15D3', '\x3', '\x2', 
		'\x2', '\x2', '\x444', '\x15D5', '\x3', '\x2', '\x2', '\x2', '\x446', 
		'\x15E0', '\x3', '\x2', '\x2', '\x2', '\x448', '\x15E7', '\x3', '\x2', 
		'\x2', '\x2', '\x44A', '\x15EB', '\x3', '\x2', '\x2', '\x2', '\x44C', 
		'\x15EE', '\x3', '\x2', '\x2', '\x2', '\x44E', '\x15F7', '\x3', '\x2', 
		'\x2', '\x2', '\x450', '\x15FB', '\x3', '\x2', '\x2', '\x2', '\x452', 
		'\x1615', '\x3', '\x2', '\x2', '\x2', '\x454', '\x1619', '\x3', '\x2', 
		'\x2', '\x2', '\x456', '\x161D', '\x3', '\x2', '\x2', '\x2', '\x458', 
		'\x1621', '\x3', '\x2', '\x2', '\x2', '\x45A', '\x1624', '\x3', '\x2', 
		'\x2', '\x2', '\x45C', '\x1630', '\x3', '\x2', '\x2', '\x2', '\x45E', 
		'\x1636', '\x3', '\x2', '\x2', '\x2', '\x460', '\x164B', '\x3', '\x2', 
		'\x2', '\x2', '\x462', '\x1657', '\x3', '\x2', '\x2', '\x2', '\x464', 
		'\x166B', '\x3', '\x2', '\x2', '\x2', '\x466', '\x166E', '\x3', '\x2', 
		'\x2', '\x2', '\x468', '\x1673', '\x3', '\x2', '\x2', '\x2', '\x46A', 
		'\x1675', '\x3', '\x2', '\x2', '\x2', '\x46C', '\x1686', '\x3', '\x2', 
		'\x2', '\x2', '\x46E', '\x1688', '\x3', '\x2', '\x2', '\x2', '\x470', 
		'\x1697', '\x3', '\x2', '\x2', '\x2', '\x472', '\x169A', '\x3', '\x2', 
		'\x2', '\x2', '\x474', '\x169D', '\x3', '\x2', '\x2', '\x2', '\x476', 
		'\x16B8', '\x3', '\x2', '\x2', '\x2', '\x478', '\x16BF', '\x3', '\x2', 
		'\x2', '\x2', '\x47A', '\x16C8', '\x3', '\x2', '\x2', '\x2', '\x47C', 
		'\x16CC', '\x3', '\x2', '\x2', '\x2', '\x47E', '\x16DD', '\x3', '\x2', 
		'\x2', '\x2', '\x480', '\x16E4', '\x3', '\x2', '\x2', '\x2', '\x482', 
		'\x16E8', '\x3', '\x2', '\x2', '\x2', '\x484', '\x16EF', '\x3', '\x2', 
		'\x2', '\x2', '\x486', '\x16FB', '\x3', '\x2', '\x2', '\x2', '\x488', 
		'\x16FD', '\x3', '\x2', '\x2', '\x2', '\x48A', '\x1708', '\x3', '\x2', 
		'\x2', '\x2', '\x48C', '\x1714', '\x3', '\x2', '\x2', '\x2', '\x48E', 
		'\x1721', '\x3', '\x2', '\x2', '\x2', '\x490', '\x1728', '\x3', '\x2', 
		'\x2', '\x2', '\x492', '\x1738', '\x3', '\x2', '\x2', '\x2', '\x494', 
		'\x173A', '\x3', '\x2', '\x2', '\x2', '\x496', '\x1740', '\x3', '\x2', 
		'\x2', '\x2', '\x498', '\x1746', '\x3', '\x2', '\x2', '\x2', '\x49A', 
		'\x174B', '\x3', '\x2', '\x2', '\x2', '\x49C', '\x174D', '\x3', '\x2', 
		'\x2', '\x2', '\x49E', '\x1751', '\x3', '\x2', '\x2', '\x2', '\x4A0', 
		'\x1756', '\x3', '\x2', '\x2', '\x2', '\x4A2', '\x1766', '\x3', '\x2', 
		'\x2', '\x2', '\x4A4', '\x1768', '\x3', '\x2', '\x2', '\x2', '\x4A6', 
		'\x176C', '\x3', '\x2', '\x2', '\x2', '\x4A8', '\x176E', '\x3', '\x2', 
		'\x2', '\x2', '\x4AA', '\x1772', '\x3', '\x2', '\x2', '\x2', '\x4AC', 
		'\x177B', '\x3', '\x2', '\x2', '\x2', '\x4AE', '\x1781', '\x3', '\x2', 
		'\x2', '\x2', '\x4B0', '\x1784', '\x3', '\x2', '\x2', '\x2', '\x4B2', 
		'\x178F', '\x3', '\x2', '\x2', '\x2', '\x4B4', '\x1793', '\x3', '\x2', 
		'\x2', '\x2', '\x4B6', '\x1798', '\x3', '\x2', '\x2', '\x2', '\x4B8', 
		'\x179A', '\x3', '\x2', '\x2', '\x2', '\x4BA', '\x17A7', '\x3', '\x2', 
		'\x2', '\x2', '\x4BC', '\x17A9', '\x3', '\x2', '\x2', '\x2', '\x4BE', 
		'\x17B1', '\x3', '\x2', '\x2', '\x2', '\x4C0', '\x17BB', '\x3', '\x2', 
		'\x2', '\x2', '\x4C2', '\x17C2', '\x3', '\x2', '\x2', '\x2', '\x4C4', 
		'\x17C4', '\x3', '\x2', '\x2', '\x2', '\x4C6', '\x17CC', '\x3', '\x2', 
		'\x2', '\x2', '\x4C8', '\x17CF', '\x3', '\x2', '\x2', '\x2', '\x4CA', 
		'\x17D4', '\x3', '\x2', '\x2', '\x2', '\x4CC', '\x17D8', '\x3', '\x2', 
		'\x2', '\x2', '\x4CE', '\x17DA', '\x3', '\x2', '\x2', '\x2', '\x4D0', 
		'\x17DE', '\x3', '\x2', '\x2', '\x2', '\x4D2', '\x17E6', '\x3', '\x2', 
		'\x2', '\x2', '\x4D4', '\x17E8', '\x3', '\x2', '\x2', '\x2', '\x4D6', 
		'\x17EE', '\x3', '\x2', '\x2', '\x2', '\x4D8', '\x17FD', '\x3', '\x2', 
		'\x2', '\x2', '\x4DA', '\x1805', '\x3', '\x2', '\x2', '\x2', '\x4DC', 
		'\x1811', '\x3', '\x2', '\x2', '\x2', '\x4DE', '\x181D', '\x3', '\x2', 
		'\x2', '\x2', '\x4E0', '\x1821', '\x3', '\x2', '\x2', '\x2', '\x4E2', 
		'\x1827', '\x3', '\x2', '\x2', '\x2', '\x4E4', '\x182D', '\x3', '\x2', 
		'\x2', '\x2', '\x4E6', '\x1839', '\x3', '\x2', '\x2', '\x2', '\x4E8', 
		'\x1851', '\x3', '\x2', '\x2', '\x2', '\x4EA', '\x1853', '\x3', '\x2', 
		'\x2', '\x2', '\x4EC', '\x1857', '\x3', '\x2', '\x2', '\x2', '\x4EE', 
		'\x1866', '\x3', '\x2', '\x2', '\x2', '\x4F0', '\x1877', '\x3', '\x2', 
		'\x2', '\x2', '\x4F2', '\x187A', '\x3', '\x2', '\x2', '\x2', '\x4F4', 
		'\x1883', '\x3', '\x2', '\x2', '\x2', '\x4F6', '\x1886', '\x3', '\x2', 
		'\x2', '\x2', '\x4F8', '\x188B', '\x3', '\x2', '\x2', '\x2', '\x4FA', 
		'\x188E', '\x3', '\x2', '\x2', '\x2', '\x4FC', '\x1893', '\x3', '\x2', 
		'\x2', '\x2', '\x4FE', '\x189B', '\x3', '\x2', '\x2', '\x2', '\x500', 
		'\x18A8', '\x3', '\x2', '\x2', '\x2', '\x502', '\x18AC', '\x3', '\x2', 
		'\x2', '\x2', '\x504', '\x18B8', '\x3', '\x2', '\x2', '\x2', '\x506', 
		'\x18BB', '\x3', '\x2', '\x2', '\x2', '\x508', '\x18C2', '\x3', '\x2', 
		'\x2', '\x2', '\x50A', '\x18C8', '\x3', '\x2', '\x2', '\x2', '\x50C', 
		'\x18D5', '\x3', '\x2', '\x2', '\x2', '\x50E', '\x18D8', '\x3', '\x2', 
		'\x2', '\x2', '\x510', '\x18DC', '\x3', '\x2', '\x2', '\x2', '\x512', 
		'\x18E3', '\x3', '\x2', '\x2', '\x2', '\x514', '\x18E8', '\x3', '\x2', 
		'\x2', '\x2', '\x516', '\x18EF', '\x3', '\x2', '\x2', '\x2', '\x518', 
		'\x18F5', '\x3', '\x2', '\x2', '\x2', '\x51A', '\x18F8', '\x3', '\x2', 
		'\x2', '\x2', '\x51C', '\x18FC', '\x3', '\x2', '\x2', '\x2', '\x51E', 
		'\x1907', '\x3', '\x2', '\x2', '\x2', '\x520', '\x190A', '\x3', '\x2', 
		'\x2', '\x2', '\x522', '\x190E', '\x3', '\x2', '\x2', '\x2', '\x524', 
		'\x1914', '\x3', '\x2', '\x2', '\x2', '\x526', '\x1927', '\x3', '\x2', 
		'\x2', '\x2', '\x528', '\x1929', '\x3', '\x2', '\x2', '\x2', '\x52A', 
		'\x192C', '\x3', '\x2', '\x2', '\x2', '\x52C', '\x1931', '\x3', '\x2', 
		'\x2', '\x2', '\x52E', '\x193C', '\x3', '\x2', '\x2', '\x2', '\x530', 
		'\x193F', '\x3', '\x2', '\x2', '\x2', '\x532', '\x194B', '\x3', '\x2', 
		'\x2', '\x2', '\x534', '\x1958', '\x3', '\x2', '\x2', '\x2', '\x536', 
		'\x195B', '\x3', '\x2', '\x2', '\x2', '\x538', '\x1961', '\x3', '\x2', 
		'\x2', '\x2', '\x53A', '\x1965', '\x3', '\x2', '\x2', '\x2', '\x53C', 
		'\x196E', '\x3', '\x2', '\x2', '\x2', '\x53E', '\x1973', '\x3', '\x2', 
		'\x2', '\x2', '\x540', '\x1975', '\x3', '\x2', '\x2', '\x2', '\x542', 
		'\x197B', '\x3', '\x2', '\x2', '\x2', '\x544', '\x197E', '\x3', '\x2', 
		'\x2', '\x2', '\x546', '\x1985', '\x3', '\x2', '\x2', '\x2', '\x548', 
		'\x198D', '\x3', '\x2', '\x2', '\x2', '\x54A', '\x199B', '\x3', '\x2', 
		'\x2', '\x2', '\x54C', '\x199D', '\x3', '\x2', '\x2', '\x2', '\x54E', 
		'\x19B0', '\x3', '\x2', '\x2', '\x2', '\x550', '\x19B8', '\x3', '\x2', 
		'\x2', '\x2', '\x552', '\x19BA', '\x3', '\x2', '\x2', '\x2', '\x554', 
		'\x19C7', '\x3', '\x2', '\x2', '\x2', '\x556', '\x19CD', '\x3', '\x2', 
		'\x2', '\x2', '\x558', '\x19D3', '\x3', '\x2', '\x2', '\x2', '\x55A', 
		'\x19D9', '\x3', '\x2', '\x2', '\x2', '\x55C', '\x19DD', '\x3', '\x2', 
		'\x2', '\x2', '\x55E', '\x19E1', '\x3', '\x2', '\x2', '\x2', '\x560', 
		'\x19E4', '\x3', '\x2', '\x2', '\x2', '\x562', '\x19F3', '\x3', '\x2', 
		'\x2', '\x2', '\x564', '\x19F6', '\x3', '\x2', '\x2', '\x2', '\x566', 
		'\x19F9', '\x3', '\x2', '\x2', '\x2', '\x568', '\x19FD', '\x3', '\x2', 
		'\x2', '\x2', '\x56A', '\x1A0B', '\x3', '\x2', '\x2', '\x2', '\x56C', 
		'\x1A13', '\x3', '\x2', '\x2', '\x2', '\x56E', '\x1A1B', '\x3', '\x2', 
		'\x2', '\x2', '\x570', '\x1A1F', '\x3', '\x2', '\x2', '\x2', '\x572', 
		'\x1A23', '\x3', '\x2', '\x2', '\x2', '\x574', '\x1A25', '\x3', '\x2', 
		'\x2', '\x2', '\x576', '\x1A29', '\x3', '\x2', '\x2', '\x2', '\x578', 
		'\x1A2D', '\x3', '\x2', '\x2', '\x2', '\x57A', '\x1A33', '\x3', '\x2', 
		'\x2', '\x2', '\x57C', '\x1A38', '\x3', '\x2', '\x2', '\x2', '\x57E', 
		'\x1A41', '\x3', '\x2', '\x2', '\x2', '\x580', '\x1A45', '\x3', '\x2', 
		'\x2', '\x2', '\x582', '\x1A50', '\x3', '\x2', '\x2', '\x2', '\x584', 
		'\x1A5A', '\x3', '\x2', '\x2', '\x2', '\x586', '\x1A61', '\x3', '\x2', 
		'\x2', '\x2', '\x588', '\x1A66', '\x3', '\x2', '\x2', '\x2', '\x58A', 
		'\x1A6A', '\x3', '\x2', '\x2', '\x2', '\x58C', '\x1A71', '\x3', '\x2', 
		'\x2', '\x2', '\x58E', '\x1A76', '\x3', '\x2', '\x2', '\x2', '\x590', 
		'\x1A7C', '\x3', '\x2', '\x2', '\x2', '\x592', '\x1A80', '\x3', '\x2', 
		'\x2', '\x2', '\x594', '\x1A88', '\x3', '\x2', '\x2', '\x2', '\x596', 
		'\x1A8B', '\x3', '\x2', '\x2', '\x2', '\x598', '\x1A8D', '\x3', '\x2', 
		'\x2', '\x2', '\x59A', '\x1A93', '\x3', '\x2', '\x2', '\x2', '\x59C', 
		'\x1A95', '\x3', '\x2', '\x2', '\x2', '\x59E', '\x1A99', '\x3', '\x2', 
		'\x2', '\x2', '\x5A0', '\x1A9B', '\x3', '\x2', '\x2', '\x2', '\x5A2', 
		'\x1AA4', '\x3', '\x2', '\x2', '\x2', '\x5A4', '\x1AA6', '\x3', '\x2', 
		'\x2', '\x2', '\x5A6', '\x1AB5', '\x3', '\x2', '\x2', '\x2', '\x5A8', 
		'\x1AC4', '\x3', '\x2', '\x2', '\x2', '\x5AA', '\x1AC6', '\x3', '\x2', 
		'\x2', '\x2', '\x5AC', '\x1AC9', '\x3', '\x2', '\x2', '\x2', '\x5AE', 
		'\x1ACB', '\x3', '\x2', '\x2', '\x2', '\x5B0', '\x1ACE', '\x3', '\x2', 
		'\x2', '\x2', '\x5B2', '\x1AD1', '\x3', '\x2', '\x2', '\x2', '\x5B4', 
		'\x1AD4', '\x3', '\x2', '\x2', '\x2', '\x5B6', '\x1AE5', '\x3', '\x2', 
		'\x2', '\x2', '\x5B8', '\x1AE7', '\x3', '\x2', '\x2', '\x2', '\x5BA', 
		'\x1AE9', '\x3', '\x2', '\x2', '\x2', '\x5BC', '\x1AF5', '\x3', '\x2', 
		'\x2', '\x2', '\x5BE', '\x1B01', '\x3', '\x2', '\x2', '\x2', '\x5C0', 
		'\x1B0D', '\x3', '\x2', '\x2', '\x2', '\x5C2', '\x1B1C', '\x3', '\x2', 
		'\x2', '\x2', '\x5C4', '\x1B21', '\x3', '\x2', '\x2', '\x2', '\x5C6', 
		'\x1B25', '\x3', '\x2', '\x2', '\x2', '\x5C8', '\x1B2B', '\x3', '\x2', 
		'\x2', '\x2', '\x5CA', '\x1B30', '\x3', '\x2', '\x2', '\x2', '\x5CC', 
		'\x1B37', '\x3', '\x2', '\x2', '\x2', '\x5CE', '\x1B3C', '\x3', '\x2', 
		'\x2', '\x2', '\x5D0', '\x1B44', '\x3', '\x2', '\x2', '\x2', '\x5D2', 
		'\x1B4E', '\x3', '\x2', '\x2', '\x2', '\x5D4', '\x1B51', '\x3', '\x2', 
		'\x2', '\x2', '\x5D6', '\x1B54', '\x3', '\x2', '\x2', '\x2', '\x5D8', 
		'\x1B60', '\x3', '\x2', '\x2', '\x2', '\x5DA', '\x1B67', '\x3', '\x2', 
		'\x2', '\x2', '\x5DC', '\x1B69', '\x3', '\x2', '\x2', '\x2', '\x5DE', 
		'\x1B6B', '\x3', '\x2', '\x2', '\x2', '\x5E0', '\x1B72', '\x3', '\x2', 
		'\x2', '\x2', '\x5E2', '\x1B79', '\x3', '\x2', '\x2', '\x2', '\x5E4', 
		'\x1B80', '\x3', '\x2', '\x2', '\x2', '\x5E6', '\x1B87', '\x3', '\x2', 
		'\x2', '\x2', '\x5E8', '\x1B8E', '\x3', '\x2', '\x2', '\x2', '\x5EA', 
		'\x1B95', '\x3', '\x2', '\x2', '\x2', '\x5EC', '\x1BA4', '\x3', '\x2', 
		'\x2', '\x2', '\x5EE', '\x1BA6', '\x3', '\x2', '\x2', '\x2', '\x5F0', 
		'\x1BAD', '\x3', '\x2', '\x2', '\x2', '\x5F2', '\x1BB2', '\x3', '\x2', 
		'\x2', '\x2', '\x5F4', '\x1BB4', '\x3', '\x2', '\x2', '\x2', '\x5F6', 
		'\x1BB8', '\x3', '\x2', '\x2', '\x2', '\x5F8', '\x1BBB', '\x3', '\x2', 
		'\x2', '\x2', '\x5FA', '\x1BC0', '\x3', '\x2', '\x2', '\x2', '\x5FC', 
		'\x1BC7', '\x3', '\x2', '\x2', '\x2', '\x5FE', '\x1BDA', '\x3', '\x2', 
		'\x2', '\x2', '\x600', '\x1BDC', '\x3', '\x2', '\x2', '\x2', '\x602', 
		'\x1BE4', '\x3', '\x2', '\x2', '\x2', '\x604', '\x1BE8', '\x3', '\x2', 
		'\x2', '\x2', '\x606', '\x1BF3', '\x3', '\x2', '\x2', '\x2', '\x608', 
		'\x1C0D', '\x3', '\x2', '\x2', '\x2', '\x60A', '\x1C10', '\x3', '\x2', 
		'\x2', '\x2', '\x60C', '\x1C15', '\x3', '\x2', '\x2', '\x2', '\x60E', 
		'\x1C18', '\x3', '\x2', '\x2', '\x2', '\x610', '\x1C1D', '\x3', '\x2', 
		'\x2', '\x2', '\x612', '\x1C2B', '\x3', '\x2', '\x2', '\x2', '\x614', 
		'\x1C2D', '\x3', '\x2', '\x2', '\x2', '\x616', '\x1C3E', '\x3', '\x2', 
		'\x2', '\x2', '\x618', '\x1C40', '\x3', '\x2', '\x2', '\x2', '\x61A', 
		'\x1C58', '\x3', '\x2', '\x2', '\x2', '\x61C', '\x1C5F', '\x3', '\x2', 
		'\x2', '\x2', '\x61E', '\x1C61', '\x3', '\x2', '\x2', '\x2', '\x620', 
		'\x1C6C', '\x3', '\x2', '\x2', '\x2', '\x622', '\x1C6E', '\x3', '\x2', 
		'\x2', '\x2', '\x624', '\x1C7E', '\x3', '\x2', '\x2', '\x2', '\x626', 
		'\x1C80', '\x3', '\x2', '\x2', '\x2', '\x628', '\x1C8B', '\x3', '\x2', 
		'\x2', '\x2', '\x62A', '\x1C90', '\x3', '\x2', '\x2', '\x2', '\x62C', 
		'\x1CA3', '\x3', '\x2', '\x2', '\x2', '\x62E', '\x1CA6', '\x3', '\x2', 
		'\x2', '\x2', '\x630', '\x1CAC', '\x3', '\x2', '\x2', '\x2', '\x632', 
		'\x1CB0', '\x3', '\x2', '\x2', '\x2', '\x634', '\x1CBA', '\x3', '\x2', 
		'\x2', '\x2', '\x636', '\x1CBD', '\x3', '\x2', '\x2', '\x2', '\x638', 
		'\x1CC4', '\x3', '\x2', '\x2', '\x2', '\x63A', '\x1CCF', '\x3', '\x2', 
		'\x2', '\x2', '\x63C', '\x1CD7', '\x3', '\x2', '\x2', '\x2', '\x63E', 
		'\x1CE5', '\x3', '\x2', '\x2', '\x2', '\x640', '\x1CE9', '\x3', '\x2', 
		'\x2', '\x2', '\x642', '\x1CEC', '\x3', '\x2', '\x2', '\x2', '\x644', 
		'\x1CF4', '\x3', '\x2', '\x2', '\x2', '\x646', '\x1CFB', '\x3', '\x2', 
		'\x2', '\x2', '\x648', '\x1CFD', '\x3', '\x2', '\x2', '\x2', '\x64A', 
		'\x1D03', '\x3', '\x2', '\x2', '\x2', '\x64C', '\x1D07', '\x3', '\x2', 
		'\x2', '\x2', '\x64E', '\x1D12', '\x3', '\x2', '\x2', '\x2', '\x650', 
		'\x1D17', '\x3', '\x2', '\x2', '\x2', '\x652', '\x1D21', '\x3', '\x2', 
		'\x2', '\x2', '\x654', '\x1D23', '\x3', '\x2', '\x2', '\x2', '\x656', 
		'\x1D25', '\x3', '\x2', '\x2', '\x2', '\x658', '\x1D2E', '\x3', '\x2', 
		'\x2', '\x2', '\x65A', '\x1D31', '\x3', '\x2', '\x2', '\x2', '\x65C', 
		'\x1D37', '\x3', '\x2', '\x2', '\x2', '\x65E', '\x1D3C', '\x3', '\x2', 
		'\x2', '\x2', '\x660', '\x1D40', '\x3', '\x2', '\x2', '\x2', '\x662', 
		'\x1D52', '\x3', '\x2', '\x2', '\x2', '\x664', '\x1D5D', '\x3', '\x2', 
		'\x2', '\x2', '\x666', '\x1D5F', '\x3', '\x2', '\x2', '\x2', '\x668', 
		'\x1D66', '\x3', '\x2', '\x2', '\x2', '\x66A', '\x1D76', '\x3', '\x2', 
		'\x2', '\x2', '\x66C', '\x1D7E', '\x3', '\x2', '\x2', '\x2', '\x66E', 
		'\x1D80', '\x3', '\x2', '\x2', '\x2', '\x670', '\x1D88', '\x3', '\x2', 
		'\x2', '\x2', '\x672', '\x1D8A', '\x3', '\x2', '\x2', '\x2', '\x674', 
		'\x1D91', '\x3', '\x2', '\x2', '\x2', '\x676', '\x1D93', '\x3', '\x2', 
		'\x2', '\x2', '\x678', '\x1D9A', '\x3', '\x2', '\x2', '\x2', '\x67A', 
		'\x1D9C', '\x3', '\x2', '\x2', '\x2', '\x67C', '\x1D9E', '\x3', '\x2', 
		'\x2', '\x2', '\x67E', '\x1DAC', '\x3', '\x2', '\x2', '\x2', '\x680', 
		'\x1DB2', '\x3', '\x2', '\x2', '\x2', '\x682', '\x1DB5', '\x3', '\x2', 
		'\x2', '\x2', '\x684', '\x1DC4', '\x3', '\x2', '\x2', '\x2', '\x686', 
		'\x1DC7', '\x3', '\x2', '\x2', '\x2', '\x688', '\x1DC9', '\x3', '\x2', 
		'\x2', '\x2', '\x68A', '\x1DD6', '\x3', '\x2', '\x2', '\x2', '\x68C', 
		'\x1DD8', '\x3', '\x2', '\x2', '\x2', '\x68E', '\x1DDB', '\x3', '\x2', 
		'\x2', '\x2', '\x690', '\x1DDE', '\x3', '\x2', '\x2', '\x2', '\x692', 
		'\x1DE1', '\x3', '\x2', '\x2', '\x2', '\x694', '\x1DE4', '\x3', '\x2', 
		'\x2', '\x2', '\x696', '\x1DEB', '\x3', '\x2', '\x2', '\x2', '\x698', 
		'\x1DF6', '\x3', '\x2', '\x2', '\x2', '\x69A', '\x1DFD', '\x3', '\x2', 
		'\x2', '\x2', '\x69C', '\x1E02', '\x3', '\x2', '\x2', '\x2', '\x69E', 
		'\x1E08', '\x3', '\x2', '\x2', '\x2', '\x6A0', '\x1E0E', '\x3', '\x2', 
		'\x2', '\x2', '\x6A2', '\x1E13', '\x3', '\x2', '\x2', '\x2', '\x6A4', 
		'\x1E18', '\x3', '\x2', '\x2', '\x2', '\x6A6', '\x1E1D', '\x3', '\x2', 
		'\x2', '\x2', '\x6A8', '\x1E27', '\x3', '\x2', '\x2', '\x2', '\x6AA', 
		'\x6AB', '\x5', '\xA2', 'R', '\x2', '\x6AB', '\x6AC', '\a', '\x2', '\x2', 
		'\x3', '\x6AC', '\x3', '\x3', '\x2', '\x2', '\x2', '\x6AD', '\x6AE', '\x5', 
		'\xA2', 'R', '\x2', '\x6AE', '\x6AF', '\a', '\x2', '\x2', '\x3', '\x6AF', 
		'\x5', '\x3', '\x2', '\x2', '\x2', '\x6B0', '\x6B1', '\x5', '\x10', '\t', 
		'\x2', '\x6B1', '\x6B2', '\a', '\x2', '\x2', '\x3', '\x6B2', '\a', '\x3', 
		'\x2', '\x2', '\x2', '\x6B3', '\x6B7', '\t', '\x2', '\x2', '\x2', '\x6B4', 
		'\x6B6', '\n', '\x3', '\x2', '\x2', '\x6B5', '\x6B4', '\x3', '\x2', '\x2', 
		'\x2', '\x6B6', '\x6B9', '\x3', '\x2', '\x2', '\x2', '\x6B7', '\x6B5', 
		'\x3', '\x2', '\x2', '\x2', '\x6B7', '\x6B8', '\x3', '\x2', '\x2', '\x2', 
		'\x6B8', '\x6BA', '\x3', '\x2', '\x2', '\x2', '\x6B9', '\x6B7', '\x3', 
		'\x2', '\x2', '\x2', '\x6BA', '\x6BB', '\a', '\x2', '\x2', '\x3', '\x6BB', 
		'\t', '\x3', '\x2', '\x2', '\x2', '\x6BC', '\x6BF', '\x5', '\x1E', '\x10', 
		'\x2', '\x6BD', '\x6BF', '\x5', '\"', '\x12', '\x2', '\x6BE', '\x6BC', 
		'\x3', '\x2', '\x2', '\x2', '\x6BE', '\x6BD', '\x3', '\x2', '\x2', '\x2', 
		'\x6BF', '\x6C0', '\x3', '\x2', '\x2', '\x2', '\x6C0', '\x6C1', '\a', 
		'\x2', '\x2', '\x3', '\x6C1', '\v', '\x3', '\x2', '\x2', '\x2', '\x6C2', 
		'\x6C3', '\x5', '\x2F6', '\x17C', '\x2', '\x6C3', '\x6C4', '\a', '\x2', 
		'\x2', '\x3', '\x6C4', '\r', '\x3', '\x2', '\x2', '\x2', '\x6C5', '\x6C6', 
		'\x5', '\x162', '\xB2', '\x2', '\x6C6', '\x6C7', '\a', '\x2', '\x2', '\x3', 
		'\x6C7', '\xF', '\x3', '\x2', '\x2', '\x2', '\x6C8', '\x6CA', '\x5', '\x12', 
		'\n', '\x2', '\x6C9', '\x6C8', '\x3', '\x2', '\x2', '\x2', '\x6CA', '\x6CD', 
		'\x3', '\x2', '\x2', '\x2', '\x6CB', '\x6C9', '\x3', '\x2', '\x2', '\x2', 
		'\x6CB', '\x6CC', '\x3', '\x2', '\x2', '\x2', '\x6CC', '\x6CE', '\x3', 
		'\x2', '\x2', '\x2', '\x6CD', '\x6CB', '\x3', '\x2', '\x2', '\x2', '\x6CE', 
		'\x6CF', '\a', '\x2', '\x2', '\x3', '\x6CF', '\x11', '\x3', '\x2', '\x2', 
		'\x2', '\x6D0', '\x6DA', '\a', '\xBB', '\x2', '\x2', '\x6D1', '\x6DA', 
		'\a', '\xE2', '\x2', '\x2', '\x6D2', '\x6DA', '\a', '\xC9', '\x2', '\x2', 
		'\x6D3', '\x6DA', '\a', '\xD3', '\x2', '\x2', '\x6D4', '\x6DA', '\a', 
		'\x129', '\x2', '\x2', '\x6D5', '\x6DA', '\a', '\x179', '\x2', '\x2', 
		'\x6D6', '\x6DA', '\a', '\x36', '\x2', '\x2', '\x6D7', '\x6DA', '\a', 
		'\x144', '\x2', '\x2', '\x6D8', '\x6DA', '\x5', 'P', ')', '\x2', '\x6D9', 
		'\x6D0', '\x3', '\x2', '\x2', '\x2', '\x6D9', '\x6D1', '\x3', '\x2', '\x2', 
		'\x2', '\x6D9', '\x6D2', '\x3', '\x2', '\x2', '\x2', '\x6D9', '\x6D3', 
		'\x3', '\x2', '\x2', '\x2', '\x6D9', '\x6D4', '\x3', '\x2', '\x2', '\x2', 
		'\x6D9', '\x6D5', '\x3', '\x2', '\x2', '\x2', '\x6D9', '\x6D6', '\x3', 
		'\x2', '\x2', '\x2', '\x6D9', '\x6D7', '\x3', '\x2', '\x2', '\x2', '\x6D9', 
		'\x6D8', '\x3', '\x2', '\x2', '\x2', '\x6DA', '\x6DC', '\x3', '\x2', '\x2', 
		'\x2', '\x6DB', '\x6DD', '\x5', '\x14', '\v', '\x2', '\x6DC', '\x6DB', 
		'\x3', '\x2', '\x2', '\x2', '\x6DC', '\x6DD', '\x3', '\x2', '\x2', '\x2', 
		'\x6DD', '\x13', '\x3', '\x2', '\x2', '\x2', '\x6DE', '\x6E0', '\a', '\x24B', 
		'\x2', '\x2', '\x6DF', '\x6E1', '\x5', '\x18', '\r', '\x2', '\x6E0', '\x6DF', 
		'\x3', '\x2', '\x2', '\x2', '\x6E0', '\x6E1', '\x3', '\x2', '\x2', '\x2', 
		'\x6E1', '\x6E7', '\x3', '\x2', '\x2', '\x2', '\x6E2', '\x6E6', '\x5', 
		'(', '\x15', '\x2', '\x6E3', '\x6E6', '\x5', '\x44', '#', '\x2', '\x6E4', 
		'\x6E6', '\x5', '\x16', '\f', '\x2', '\x6E5', '\x6E2', '\x3', '\x2', '\x2', 
		'\x2', '\x6E5', '\x6E3', '\x3', '\x2', '\x2', '\x2', '\x6E5', '\x6E4', 
		'\x3', '\x2', '\x2', '\x2', '\x6E6', '\x6E9', '\x3', '\x2', '\x2', '\x2', 
		'\x6E7', '\x6E5', '\x3', '\x2', '\x2', '\x2', '\x6E7', '\x6E8', '\x3', 
		'\x2', '\x2', '\x2', '\x6E8', '\x6EA', '\x3', '\x2', '\x2', '\x2', '\x6E9', 
		'\x6E7', '\x3', '\x2', '\x2', '\x2', '\x6EA', '\x6EB', '\a', '\x24C', 
		'\x2', '\x2', '\x6EB', '\x15', '\x3', '\x2', '\x2', '\x2', '\x6EC', '\x6F0', 
		'\a', '\x24B', '\x2', '\x2', '\x6ED', '\x6EF', '\x5', '\x44', '#', '\x2', 
		'\x6EE', '\x6ED', '\x3', '\x2', '\x2', '\x2', '\x6EF', '\x6F2', '\x3', 
		'\x2', '\x2', '\x2', '\x6F0', '\x6EE', '\x3', '\x2', '\x2', '\x2', '\x6F0', 
		'\x6F1', '\x3', '\x2', '\x2', '\x2', '\x6F1', '\x6F3', '\x3', '\x2', '\x2', 
		'\x2', '\x6F2', '\x6F0', '\x3', '\x2', '\x2', '\x2', '\x6F3', '\x6F4', 
		'\a', '\x24C', '\x2', '\x2', '\x6F4', '\x17', '\x3', '\x2', '\x2', '\x2', 
		'\x6F5', '\x6F6', '\a', '\x255', '\x2', '\x2', '\x6F6', '\x6F7', '\x5', 
		'\x44', '#', '\x2', '\x6F7', '\x19', '\x3', '\x2', '\x2', '\x2', '\x6F8', 
		'\x6F9', '\x5', '\x1C', '\xF', '\x2', '\x6F9', '\x6FA', '\t', '\x4', '\x2', 
		'\x2', '\x6FA', '\x6FC', '\x3', '\x2', '\x2', '\x2', '\x6FB', '\x6F8', 
		'\x3', '\x2', '\x2', '\x2', '\x6FC', '\x6FF', '\x3', '\x2', '\x2', '\x2', 
		'\x6FD', '\x6FB', '\x3', '\x2', '\x2', '\x2', '\x6FD', '\x6FE', '\x3', 
		'\x2', '\x2', '\x2', '\x6FE', '\x700', '\x3', '\x2', '\x2', '\x2', '\x6FF', 
		'\x6FD', '\x3', '\x2', '\x2', '\x2', '\x700', '\x701', '\a', '\x2', '\x2', 
		'\x3', '\x701', '\x1B', '\x3', '\x2', '\x2', '\x2', '\x702', '\x707', 
		'\x5', '\x1E', '\x10', '\x2', '\x703', '\x705', '\a', '\x24E', '\x2', 
		'\x2', '\x704', '\x706', '\x5', '\x1C', '\xF', '\x2', '\x705', '\x704', 
		'\x3', '\x2', '\x2', '\x2', '\x705', '\x706', '\x3', '\x2', '\x2', '\x2', 
		'\x706', '\x708', '\x3', '\x2', '\x2', '\x2', '\x707', '\x703', '\x3', 
		'\x2', '\x2', '\x2', '\x707', '\x708', '\x3', '\x2', '\x2', '\x2', '\x708', 
		'\x1D', '\x3', '\x2', '\x2', '\x2', '\x709', '\x724', '\x5', '\x17C', 
		'\xBF', '\x2', '\x70A', '\x724', '\x5', '\x5FA', '\x2FE', '\x2', '\x70B', 
		'\x724', '\x5', '\x5EE', '\x2F8', '\x2', '\x70C', '\x70E', '\x5', '\x596', 
		'\x2CC', '\x2', '\x70D', '\x70C', '\x3', '\x2', '\x2', '\x2', '\x70D', 
		'\x70E', '\x3', '\x2', '\x2', '\x2', '\x70E', '\x721', '\x3', '\x2', '\x2', 
		'\x2', '\x70F', '\x722', '\x5', '\x4EE', '\x278', '\x2', '\x710', '\x722', 
		'\x5', '\x4F0', '\x279', '\x2', '\x711', '\x722', '\x5', '\x4FA', '\x27E', 
		'\x2', '\x712', '\x722', '\x5', '\x532', '\x29A', '\x2', '\x713', '\x722', 
		'\x5', '\x50A', '\x286', '\x2', '\x714', '\x722', '\x5', '\x538', '\x29D', 
		'\x2', '\x715', '\x722', '\x5', '\x53A', '\x29E', '\x2', '\x716', '\x722', 
		'\x5', '\x540', '\x2A1', '\x2', '\x717', '\x722', '\x5', '\x588', '\x2C5', 
		'\x2', '\x718', '\x722', '\x5', '\x3EE', '\x1F8', '\x2', '\x719', '\x722', 
		'\x5', '\x4D4', '\x26B', '\x2', '\x71A', '\x722', '\x5', '\x4EC', '\x277', 
		'\x2', '\x71B', '\x722', '\x5', '\x594', '\x2CB', '\x2', '\x71C', '\x722', 
		'\x5', '\x4F2', '\x27A', '\x2', '\x71D', '\x722', '\x5', '\x502', '\x282', 
		'\x2', '\x71E', '\x722', '\x5', '\x514', '\x28B', '\x2', '\x71F', '\x722', 
		'\x5', '\x518', '\x28D', '\x2', '\x720', '\x722', '\x5', '\x524', '\x293', 
		'\x2', '\x721', '\x70F', '\x3', '\x2', '\x2', '\x2', '\x721', '\x710', 
		'\x3', '\x2', '\x2', '\x2', '\x721', '\x711', '\x3', '\x2', '\x2', '\x2', 
		'\x721', '\x712', '\x3', '\x2', '\x2', '\x2', '\x721', '\x713', '\x3', 
		'\x2', '\x2', '\x2', '\x721', '\x714', '\x3', '\x2', '\x2', '\x2', '\x721', 
		'\x715', '\x3', '\x2', '\x2', '\x2', '\x721', '\x716', '\x3', '\x2', '\x2', 
		'\x2', '\x721', '\x717', '\x3', '\x2', '\x2', '\x2', '\x721', '\x718', 
		'\x3', '\x2', '\x2', '\x2', '\x721', '\x719', '\x3', '\x2', '\x2', '\x2', 
		'\x721', '\x71A', '\x3', '\x2', '\x2', '\x2', '\x721', '\x71B', '\x3', 
		'\x2', '\x2', '\x2', '\x721', '\x71C', '\x3', '\x2', '\x2', '\x2', '\x721', 
		'\x71D', '\x3', '\x2', '\x2', '\x2', '\x721', '\x71E', '\x3', '\x2', '\x2', 
		'\x2', '\x721', '\x71F', '\x3', '\x2', '\x2', '\x2', '\x721', '\x720', 
		'\x3', '\x2', '\x2', '\x2', '\x722', '\x724', '\x3', '\x2', '\x2', '\x2', 
		'\x723', '\x709', '\x3', '\x2', '\x2', '\x2', '\x723', '\x70A', '\x3', 
		'\x2', '\x2', '\x2', '\x723', '\x70B', '\x3', '\x2', '\x2', '\x2', '\x723', 
		'\x70D', '\x3', '\x2', '\x2', '\x2', '\x724', '\x1F', '\x3', '\x2', '\x2', 
		'\x2', '\x725', '\x726', '\x6', '\x11', '\x2', '\x2', '\x726', '\x728', 
		'\x5', '\"', '\x12', '\x2', '\x727', '\x725', '\x3', '\x2', '\x2', '\x2', 
		'\x728', '\x72B', '\x3', '\x2', '\x2', '\x2', '\x729', '\x727', '\x3', 
		'\x2', '\x2', '\x2', '\x729', '\x72A', '\x3', '\x2', '\x2', '\x2', '\x72A', 
		'!', '\x3', '\x2', '\x2', '\x2', '\x72B', '\x729', '\x3', '\x2', '\x2', 
		'\x2', '\x72C', '\x72E', '\x5', '\x596', '\x2CC', '\x2', '\x72D', '\x72C', 
		'\x3', '\x2', '\x2', '\x2', '\x72D', '\x72E', '\x3', '\x2', '\x2', '\x2', 
		'\x72E', '\x749', '\x3', '\x2', '\x2', '\x2', '\x72F', '\x74A', '\x5', 
		'\x550', '\x2A9', '\x2', '\x730', '\x74A', '\x5', '\x57E', '\x2C0', '\x2', 
		'\x731', '\x74A', '\x5', '\x4EE', '\x278', '\x2', '\x732', '\x74A', '\x5', 
		'\x532', '\x29A', '\x2', '\x733', '\x74A', '\x5', '\x51A', '\x28E', '\x2', 
		'\x734', '\x74A', '\x5', '\x538', '\x29D', '\x2', '\x735', '\x74A', '\x5', 
		'\x502', '\x282', '\x2', '\x736', '\x74A', '\x5', '\x5A0', '\x2D1', '\x2', 
		'\x737', '\x74A', '\x5', '\x59E', '\x2D0', '\x2', '\x738', '\x74A', '\x5', 
		'\x4F0', '\x279', '\x2', '\x739', '\x74A', '\x5', '\x4FA', '\x27E', '\x2', 
		'\x73A', '\x74A', '\x5', '\x50A', '\x286', '\x2', '\x73B', '\x74A', '\x5', 
		'\x5D6', '\x2EC', '\x2', '\x73C', '\x74A', '\x5', '\x588', '\x2C5', '\x2', 
		'\x73D', '\x74A', '\x5', '\x3EE', '\x1F8', '\x2', '\x73E', '\x74A', '\x5', 
		'\x4D4', '\x26B', '\x2', '\x73F', '\x74A', '\x5', '\x4EC', '\x277', '\x2', 
		'\x740', '\x74A', '\x5', '\x594', '\x2CB', '\x2', '\x741', '\x74A', '\x5', 
		'\x4F2', '\x27A', '\x2', '\x742', '\x74A', '\x5', '\x514', '\x28B', '\x2', 
		'\x743', '\x74A', '\x5', '\x518', '\x28D', '\x2', '\x744', '\x74A', '\x5', 
		'\x59C', '\x2CF', '\x2', '\x745', '\x74A', '\x5', '\x59A', '\x2CE', '\x2', 
		'\x746', '\x74A', '\x5', '\x544', '\x2A3', '\x2', '\x747', '\x74A', '\x5', 
		'\x524', '\x293', '\x2', '\x748', '\x74A', '\x5', '\x536', '\x29C', '\x2', 
		'\x749', '\x72F', '\x3', '\x2', '\x2', '\x2', '\x749', '\x730', '\x3', 
		'\x2', '\x2', '\x2', '\x749', '\x731', '\x3', '\x2', '\x2', '\x2', '\x749', 
		'\x732', '\x3', '\x2', '\x2', '\x2', '\x749', '\x733', '\x3', '\x2', '\x2', 
		'\x2', '\x749', '\x734', '\x3', '\x2', '\x2', '\x2', '\x749', '\x735', 
		'\x3', '\x2', '\x2', '\x2', '\x749', '\x736', '\x3', '\x2', '\x2', '\x2', 
		'\x749', '\x737', '\x3', '\x2', '\x2', '\x2', '\x749', '\x738', '\x3', 
		'\x2', '\x2', '\x2', '\x749', '\x739', '\x3', '\x2', '\x2', '\x2', '\x749', 
		'\x73A', '\x3', '\x2', '\x2', '\x2', '\x749', '\x73B', '\x3', '\x2', '\x2', 
		'\x2', '\x749', '\x73C', '\x3', '\x2', '\x2', '\x2', '\x749', '\x73D', 
		'\x3', '\x2', '\x2', '\x2', '\x749', '\x73E', '\x3', '\x2', '\x2', '\x2', 
		'\x749', '\x73F', '\x3', '\x2', '\x2', '\x2', '\x749', '\x740', '\x3', 
		'\x2', '\x2', '\x2', '\x749', '\x741', '\x3', '\x2', '\x2', '\x2', '\x749', 
		'\x742', '\x3', '\x2', '\x2', '\x2', '\x749', '\x743', '\x3', '\x2', '\x2', 
		'\x2', '\x749', '\x744', '\x3', '\x2', '\x2', '\x2', '\x749', '\x745', 
		'\x3', '\x2', '\x2', '\x2', '\x749', '\x746', '\x3', '\x2', '\x2', '\x2', 
		'\x749', '\x747', '\x3', '\x2', '\x2', '\x2', '\x749', '\x748', '\x3', 
		'\x2', '\x2', '\x2', '\x74A', '\x74B', '\x3', '\x2', '\x2', '\x2', '\x74B', 
		'\x74C', '\a', '\x24E', '\x2', '\x2', '\x74C', '#', '\x3', '\x2', '\x2', 
		'\x2', '\x74D', '\x74F', '\a', '\x64', '\x2', '\x2', '\x74E', '\x750', 
		'\x5', '\x17E', '\xC0', '\x2', '\x74F', '\x74E', '\x3', '\x2', '\x2', 
		'\x2', '\x74F', '\x750', '\x3', '\x2', '\x2', '\x2', '\x750', '\x752', 
		'\x3', '\x2', '\x2', '\x2', '\x751', '\x753', '\x5', '\x1DA', '\xEE', 
		'\x2', '\x752', '\x751', '\x3', '\x2', '\x2', '\x2', '\x752', '\x753', 
		'\x3', '\x2', '\x2', '\x2', '\x753', '\x754', '\x3', '\x2', '\x2', '\x2', 
		'\x754', '\x758', '\x5', '&', '\x14', '\x2', '\x755', '\x757', '\v', '\x2', 
		'\x2', '\x2', '\x756', '\x755', '\x3', '\x2', '\x2', '\x2', '\x757', '\x75A', 
		'\x3', '\x2', '\x2', '\x2', '\x758', '\x759', '\x3', '\x2', '\x2', '\x2', 
		'\x758', '\x756', '\x3', '\x2', '\x2', '\x2', '\x759', '\x75B', '\x3', 
		'\x2', '\x2', '\x2', '\x75A', '\x758', '\x3', '\x2', '\x2', '\x2', '\x75B', 
		'\x75C', '\a', '\x2', '\x2', '\x3', '\x75C', '%', '\x3', '\x2', '\x2', 
		'\x2', '\x75D', '\x760', '\x5', '\x1E4', '\xF3', '\x2', '\x75E', '\x760', 
		'\x5', '\x20C', '\x107', '\x2', '\x75F', '\x75D', '\x3', '\x2', '\x2', 
		'\x2', '\x75F', '\x75E', '\x3', '\x2', '\x2', '\x2', '\x760', '\'', '\x3', 
		'\x2', '\x2', '\x2', '\x761', '\x76C', '\t', '\x5', '\x2', '\x2', '\x762', 
		'\x76C', '\x5', ',', '\x17', '\x2', '\x763', '\x76C', '\x5', '*', '\x16', 
		'\x2', '\x764', '\x76C', '\x5', '.', '\x18', '\x2', '\x765', '\x76C', 
		'\x5', '\x30', '\x19', '\x2', '\x766', '\x76C', '\x5', '\x32', '\x1A', 
		'\x2', '\x767', '\x76C', '\x5', '\x34', '\x1B', '\x2', '\x768', '\x76C', 
		'\x5', '\x36', '\x1C', '\x2', '\x769', '\x76C', '\x5', '\x38', '\x1D', 
		'\x2', '\x76A', '\x76C', '\x5', '>', ' ', '\x2', '\x76B', '\x761', '\x3', 
		'\x2', '\x2', '\x2', '\x76B', '\x762', '\x3', '\x2', '\x2', '\x2', '\x76B', 
		'\x763', '\x3', '\x2', '\x2', '\x2', '\x76B', '\x764', '\x3', '\x2', '\x2', 
		'\x2', '\x76B', '\x765', '\x3', '\x2', '\x2', '\x2', '\x76B', '\x766', 
		'\x3', '\x2', '\x2', '\x2', '\x76B', '\x767', '\x3', '\x2', '\x2', '\x2', 
		'\x76B', '\x768', '\x3', '\x2', '\x2', '\x2', '\x76B', '\x769', '\x3', 
		'\x2', '\x2', '\x2', '\x76B', '\x76A', '\x3', '\x2', '\x2', '\x2', '\x76C', 
		')', '\x3', '\x2', '\x2', '\x2', '\x76D', '\x76E', '\a', '\x26A', '\x2', 
		'\x2', '\x76E', '+', '\x3', '\x2', '\x2', '\x2', '\x76F', '\x770', '\a', 
		'\x263', '\x2', '\x2', '\x770', '-', '\x3', '\x2', '\x2', '\x2', '\x771', 
		'\x772', '\a', '\x261', '\x2', '\x2', '\x772', '/', '\x3', '\x2', '\x2', 
		'\x2', '\x773', '\x774', '\a', '\x262', '\x2', '\x2', '\x774', '\x31', 
		'\x3', '\x2', '\x2', '\x2', '\x775', '\x776', '\t', '\x6', '\x2', '\x2', 
		'\x776', '\x33', '\x3', '\x2', '\x2', '\x2', '\x777', '\x778', '\a', 'o', 
		'\x2', '\x2', '\x778', '\x779', '\a', '\x263', '\x2', '\x2', '\x779', 
		'\x35', '\x3', '\x2', '\x2', '\x2', '\x77A', '\x77B', '\a', '\x204', '\x2', 
		'\x2', '\x77B', '\x77C', '\a', '\x263', '\x2', '\x2', '\x77C', '\x37', 
		'\x3', '\x2', '\x2', '\x2', '\x77D', '\x77E', '\a', '\xF1', '\x2', '\x2', 
		'\x77E', '\x77F', '\a', '\x263', '\x2', '\x2', '\x77F', '\x782', '\x5', 
		':', '\x1E', '\x2', '\x780', '\x781', '\a', '\x209', '\x2', '\x2', '\x781', 
		'\x783', '\x5', ':', '\x1E', '\x2', '\x782', '\x780', '\x3', '\x2', '\x2', 
		'\x2', '\x782', '\x783', '\x3', '\x2', '\x2', '\x2', '\x783', '\x39', 
		'\x3', '\x2', '\x2', '\x2', '\x784', '\x786', '\t', '\a', '\x2', '\x2', 
		'\x785', '\x787', '\x5', '<', '\x1F', '\x2', '\x786', '\x785', '\x3', 
		'\x2', '\x2', '\x2', '\x786', '\x787', '\x3', '\x2', '\x2', '\x2', '\x787', 
		';', '\x3', '\x2', '\x2', '\x2', '\x788', '\x789', '\a', '\x24B', '\x2', 
		'\x2', '\x789', '\x78C', '\x5', '(', '\x15', '\x2', '\x78A', '\x78B', 
		'\a', '\x24D', '\x2', '\x2', '\x78B', '\x78D', '\x5', '(', '\x15', '\x2', 
		'\x78C', '\x78A', '\x3', '\x2', '\x2', '\x2', '\x78C', '\x78D', '\x3', 
		'\x2', '\x2', '\x2', '\x78D', '\x78E', '\x3', '\x2', '\x2', '\x2', '\x78E', 
		'\x78F', '\a', '\x24C', '\x2', '\x2', '\x78F', '=', '\x3', '\x2', '\x2', 
		'\x2', '\x790', '\x791', '\a', '\x260', '\x2', '\x2', '\x791', '?', '\x3', 
		'\x2', '\x2', '\x2', '\x792', '\x795', '\a', '\x266', '\x2', '\x2', '\x793', 
		'\x795', '\t', '\b', '\x2', '\x2', '\x794', '\x792', '\x3', '\x2', '\x2', 
		'\x2', '\x794', '\x793', '\x3', '\x2', '\x2', '\x2', '\x795', '\x41', 
		'\x3', '\x2', '\x2', '\x2', '\x796', '\x797', '\a', '\x25C', '\x2', '\x2', 
		'\x797', '\x43', '\x3', '\x2', '\x2', '\x2', '\x798', '\x7A1', '\x5', 
		'P', ')', '\x2', '\x799', '\x79C', '\x5', '\x42', '\"', '\x2', '\x79A', 
		'\x79D', '\x5', 'P', ')', '\x2', '\x79B', '\x79D', '\x5', 'L', '\'', '\x2', 
		'\x79C', '\x79A', '\x3', '\x2', '\x2', '\x2', '\x79C', '\x79B', '\x3', 
		'\x2', '\x2', '\x2', '\x79D', '\x7A0', '\x3', '\x2', '\x2', '\x2', '\x79E', 
		'\x7A0', '\x5', 'R', '*', '\x2', '\x79F', '\x799', '\x3', '\x2', '\x2', 
		'\x2', '\x79F', '\x79E', '\x3', '\x2', '\x2', '\x2', '\x7A0', '\x7A3', 
		'\x3', '\x2', '\x2', '\x2', '\x7A1', '\x79F', '\x3', '\x2', '\x2', '\x2', 
		'\x7A1', '\x7A2', '\x3', '\x2', '\x2', '\x2', '\x7A2', '\x7A7', '\x3', 
		'\x2', '\x2', '\x2', '\x7A3', '\x7A1', '\x3', '\x2', '\x2', '\x2', '\x7A4', 
		'\x7A5', '\a', '\x24B', '\x2', '\x2', '\x7A5', '\x7A6', '\a', '\x256', 
		'\x2', '\x2', '\x7A6', '\x7A8', '\a', '\x24C', '\x2', '\x2', '\x7A7', 
		'\x7A4', '\x3', '\x2', '\x2', '\x2', '\x7A7', '\x7A8', '\x3', '\x2', '\x2', 
		'\x2', '\x7A8', '\x45', '\x3', '\x2', '\x2', '\x2', '\x7A9', '\x7AF', 
		'\x5', '^', '\x30', '\x2', '\x7AA', '\x7AB', '\x5', '\x42', '\"', '\x2', 
		'\x7AB', '\x7AC', '\x5', '^', '\x30', '\x2', '\x7AC', '\x7AE', '\x3', 
		'\x2', '\x2', '\x2', '\x7AD', '\x7AA', '\x3', '\x2', '\x2', '\x2', '\x7AE', 
		'\x7B1', '\x3', '\x2', '\x2', '\x2', '\x7AF', '\x7AD', '\x3', '\x2', '\x2', 
		'\x2', '\x7AF', '\x7B0', '\x3', '\x2', '\x2', '\x2', '\x7B0', 'G', '\x3', 
		'\x2', '\x2', '\x2', '\x7B1', '\x7AF', '\x3', '\x2', '\x2', '\x2', '\x7B2', 
		'\x7B8', '\x5', '^', '\x30', '\x2', '\x7B3', '\x7B4', '\x5', '\x42', '\"', 
		'\x2', '\x7B4', '\x7B5', '\x5', '^', '\x30', '\x2', '\x7B5', '\x7B7', 
		'\x3', '\x2', '\x2', '\x2', '\x7B6', '\x7B3', '\x3', '\x2', '\x2', '\x2', 
		'\x7B7', '\x7BA', '\x3', '\x2', '\x2', '\x2', '\x7B8', '\x7B6', '\x3', 
		'\x2', '\x2', '\x2', '\x7B8', '\x7B9', '\x3', '\x2', '\x2', '\x2', '\x7B9', 
		'\x7BC', '\x3', '\x2', '\x2', '\x2', '\x7BA', '\x7B8', '\x3', '\x2', '\x2', 
		'\x2', '\x7BB', '\x7BD', '\x5', 'N', '(', '\x2', '\x7BC', '\x7BB', '\x3', 
		'\x2', '\x2', '\x2', '\x7BC', '\x7BD', '\x3', '\x2', '\x2', '\x2', '\x7BD', 
		'I', '\x3', '\x2', '\x2', '\x2', '\x7BE', '\x7C2', '\x5', '^', '\x30', 
		'\x2', '\x7BF', '\x7C0', '\x5', '\x42', '\"', '\x2', '\x7C0', '\x7C1', 
		'\x5', '^', '\x30', '\x2', '\x7C1', '\x7C3', '\x3', '\x2', '\x2', '\x2', 
		'\x7C2', '\x7BF', '\x3', '\x2', '\x2', '\x2', '\x7C3', '\x7C4', '\x3', 
		'\x2', '\x2', '\x2', '\x7C4', '\x7C2', '\x3', '\x2', '\x2', '\x2', '\x7C4', 
		'\x7C5', '\x3', '\x2', '\x2', '\x2', '\x7C5', 'K', '\x3', '\x2', '\x2', 
		'\x2', '\x7C6', '\x7C7', '\a', '\x25B', '\x2', '\x2', '\x7C7', 'M', '\x3', 
		'\x2', '\x2', '\x2', '\x7C8', '\x7CB', '\a', '\x255', '\x2', '\x2', '\x7C9', 
		'\x7CC', '\x5', '@', '!', '\x2', '\x7CA', '\x7CC', '\a', '\x267', '\x2', 
		'\x2', '\x7CB', '\x7C9', '\x3', '\x2', '\x2', '\x2', '\x7CB', '\x7CA', 
		'\x3', '\x2', '\x2', '\x2', '\x7CC', '\x7D4', '\x3', '\x2', '\x2', '\x2', 
		'\x7CD', '\x7D0', '\t', '\t', '\x2', '\x2', '\x7CE', '\x7D1', '\x5', '@', 
		'!', '\x2', '\x7CF', '\x7D1', '\a', '\x267', '\x2', '\x2', '\x7D0', '\x7CE', 
		'\x3', '\x2', '\x2', '\x2', '\x7D0', '\x7CF', '\x3', '\x2', '\x2', '\x2', 
		'\x7D1', '\x7D3', '\x3', '\x2', '\x2', '\x2', '\x7D2', '\x7CD', '\x3', 
		'\x2', '\x2', '\x2', '\x7D3', '\x7D6', '\x3', '\x2', '\x2', '\x2', '\x7D4', 
		'\x7D2', '\x3', '\x2', '\x2', '\x2', '\x7D4', '\x7D5', '\x3', '\x2', '\x2', 
		'\x2', '\x7D5', 'O', '\x3', '\x2', '\x2', '\x2', '\x7D6', '\x7D4', '\x3', 
		'\x2', '\x2', '\x2', '\x7D7', '\x7DA', '\x5', '@', '!', '\x2', '\x7D8', 
		'\x7DA', '\a', '\x267', '\x2', '\x2', '\x7D9', '\x7D7', '\x3', '\x2', 
		'\x2', '\x2', '\x7D9', '\x7D8', '\x3', '\x2', '\x2', '\x2', '\x7DA', '\x7DC', 
		'\x3', '\x2', '\x2', '\x2', '\x7DB', '\x7DD', '\x5', 'N', '(', '\x2', 
		'\x7DC', '\x7DB', '\x3', '\x2', '\x2', '\x2', '\x7DC', '\x7DD', '\x3', 
		'\x2', '\x2', '\x2', '\x7DD', '\x7DF', '\x3', '\x2', '\x2', '\x2', '\x7DE', 
		'\x7E0', '\x5', 'Z', '.', '\x2', '\x7DF', '\x7DE', '\x3', '\x2', '\x2', 
		'\x2', '\x7DF', '\x7E0', '\x3', '\x2', '\x2', '\x2', '\x7E0', 'Q', '\x3', 
		'\x2', '\x2', '\x2', '\x7E1', '\x7E2', '\x5', 'Z', '.', '\x2', '\x7E2', 
		'S', '\x3', '\x2', '\x2', '\x2', '\x7E3', '\x7E4', '\x5', 'X', '-', '\x2', 
		'\x7E4', 'U', '\x3', '\x2', '\x2', '\x2', '\x7E5', '\x7E6', '\a', '\x169', 
		'\x2', '\x2', '\x7E6', '\x7E7', '\a', '\xBC', '\x2', '\x2', '\x7E7', '\x7E8', 
		'\x5', 'Z', '.', '\x2', '\x7E8', '\x7E9', '\a', '\x223', '\x2', '\x2', 
		'\x7E9', '\x7EA', '\a', '\x107', '\x2', '\x2', '\x7EA', '\x7EE', '\x5', 
		'\x44', '#', '\x2', '\x7EB', '\x7ED', '\n', '\n', '\x2', '\x2', '\x7EC', 
		'\x7EB', '\x3', '\x2', '\x2', '\x2', '\x7ED', '\x7F0', '\x3', '\x2', '\x2', 
		'\x2', '\x7EE', '\x7EC', '\x3', '\x2', '\x2', '\x2', '\x7EE', '\x7EF', 
		'\x3', '\x2', '\x2', '\x2', '\x7EF', 'W', '\x3', '\x2', '\x2', '\x2', 
		'\x7F0', '\x7EE', '\x3', '\x2', '\x2', '\x2', '\x7F1', '\x7F3', '\a', 
		'\x263', '\x2', '\x2', '\x7F2', '\x7F4', '\x5', 'Z', '.', '\x2', '\x7F3', 
		'\x7F2', '\x3', '\x2', '\x2', '\x2', '\x7F3', '\x7F4', '\x3', '\x2', '\x2', 
		'\x2', '\x7F4', 'Y', '\x3', '\x2', '\x2', '\x2', '\x7F5', '\x7F7', '\a', 
		'\x24B', '\x2', '\x2', '\x7F6', '\x7F8', '\t', '\v', '\x2', '\x2', '\x7F7', 
		'\x7F6', '\x3', '\x2', '\x2', '\x2', '\x7F7', '\x7F8', '\x3', '\x2', '\x2', 
		'\x2', '\x7F8', '\x7FA', '\x3', '\x2', '\x2', '\x2', '\x7F9', '\x7FB', 
		'\x5', '\x166', '\xB4', '\x2', '\x7FA', '\x7F9', '\x3', '\x2', '\x2', 
		'\x2', '\x7FA', '\x7FB', '\x3', '\x2', '\x2', '\x2', '\x7FB', '\x7FC', 
		'\x3', '\x2', '\x2', '\x2', '\x7FC', '\x7FD', '\a', '\x24C', '\x2', '\x2', 
		'\x7FD', '[', '\x3', '\x2', '\x2', '\x2', '\x7FE', '\x801', '\x5', '@', 
		'!', '\x2', '\x7FF', '\x801', '\a', '\x267', '\x2', '\x2', '\x800', '\x7FE', 
		'\x3', '\x2', '\x2', '\x2', '\x800', '\x7FF', '\x3', '\x2', '\x2', '\x2', 
		'\x801', ']', '\x3', '\x2', '\x2', '\x2', '\x802', '\x805', '\x5', '@', 
		'!', '\x2', '\x803', '\x805', '\a', '\x267', '\x2', '\x2', '\x804', '\x802', 
		'\x3', '\x2', '\x2', '\x2', '\x804', '\x803', '\x3', '\x2', '\x2', '\x2', 
		'\x805', '\x807', '\x3', '\x2', '\x2', '\x2', '\x806', '\x808', '\x5', 
		'N', '(', '\x2', '\x807', '\x806', '\x3', '\x2', '\x2', '\x2', '\x807', 
		'\x808', '\x3', '\x2', '\x2', '\x2', '\x808', '_', '\x3', '\x2', '\x2', 
		'\x2', '\x809', '\x80A', '\a', '\x259', '\x2', '\x2', '\x80A', '\x61', 
		'\x3', '\x2', '\x2', '\x2', '\x80B', '\x81A', '\x5', '\x8A', '\x46', '\x2', 
		'\x80C', '\x81A', '\x5', '\x8C', 'G', '\x2', '\x80D', '\x81A', '\x5', 
		'\x8E', 'H', '\x2', '\x80E', '\x81A', '\x5', '\x92', 'J', '\x2', '\x80F', 
		'\x81A', '\x5', '\xA0', 'Q', '\x2', '\x810', '\x811', '\a', '\x24B', '\x2', 
		'\x2', '\x811', '\x812', '\x5', '\x32', '\x1A', '\x2', '\x812', '\x813', 
		'\a', '\x24D', '\x2', '\x2', '\x813', '\x814', '\x5', '\x32', '\x1A', 
		'\x2', '\x814', '\x815', '\a', '\x24C', '\x2', '\x2', '\x815', '\x81A', 
		'\x3', '\x2', '\x2', '\x2', '\x816', '\x81A', '\x5', 'V', ',', '\x2', 
		'\x817', '\x81A', '\x5', 'x', '=', '\x2', '\x818', '\x81A', '\x5', '\x44', 
		'#', '\x2', '\x819', '\x80B', '\x3', '\x2', '\x2', '\x2', '\x819', '\x80C', 
		'\x3', '\x2', '\x2', '\x2', '\x819', '\x80D', '\x3', '\x2', '\x2', '\x2', 
		'\x819', '\x80E', '\x3', '\x2', '\x2', '\x2', '\x819', '\x80F', '\x3', 
		'\x2', '\x2', '\x2', '\x819', '\x810', '\x3', '\x2', '\x2', '\x2', '\x819', 
		'\x816', '\x3', '\x2', '\x2', '\x2', '\x819', '\x817', '\x3', '\x2', '\x2', 
		'\x2', '\x819', '\x818', '\x3', '\x2', '\x2', '\x2', '\x81A', '\x81C', 
		'\x3', '\x2', '\x2', '\x2', '\x81B', '\x81D', '\x5', '\x94', 'K', '\x2', 
		'\x81C', '\x81B', '\x3', '\x2', '\x2', '\x2', '\x81C', '\x81D', '\x3', 
		'\x2', '\x2', '\x2', '\x81D', '\x63', '\x3', '\x2', '\x2', '\x2', '\x81E', 
		'\x820', '\a', '\x204', '\x2', '\x2', '\x81F', '\x821', '\x5', 'Z', '.', 
		'\x2', '\x820', '\x81F', '\x3', '\x2', '\x2', '\x2', '\x820', '\x821', 
		'\x3', '\x2', '\x2', '\x2', '\x821', '\x65', '\x3', '\x2', '\x2', '\x2', 
		'\x822', '\x824', '\a', '\x203', '\x2', '\x2', '\x823', '\x825', '\x5', 
		'Z', '.', '\x2', '\x824', '\x823', '\x3', '\x2', '\x2', '\x2', '\x824', 
		'\x825', '\x3', '\x2', '\x2', '\x2', '\x825', 'g', '\x3', '\x2', '\x2', 
		'\x2', '\x826', '\x828', '\a', '\x234', '\x2', '\x2', '\x827', '\x829', 
		'\x5', 'Z', '.', '\x2', '\x828', '\x827', '\x3', '\x2', '\x2', '\x2', 
		'\x828', '\x829', '\x3', '\x2', '\x2', '\x2', '\x829', 'i', '\x3', '\x2', 
		'\x2', '\x2', '\x82A', '\x82C', '\a', '\x110', '\x2', '\x2', '\x82B', 
		'\x82D', '\x5', 'Z', '.', '\x2', '\x82C', '\x82B', '\x3', '\x2', '\x2', 
		'\x2', '\x82C', '\x82D', '\x3', '\x2', '\x2', '\x2', '\x82D', 'k', '\x3', 
		'\x2', '\x2', '\x2', '\x82E', '\x830', '\a', '\x244', '\x2', '\x2', '\x82F', 
		'\x831', '\x5', 'Z', '.', '\x2', '\x830', '\x82F', '\x3', '\x2', '\x2', 
		'\x2', '\x830', '\x831', '\x3', '\x2', '\x2', '\x2', '\x831', 'm', '\x3', 
		'\x2', '\x2', '\x2', '\x832', '\x834', '\a', '\xF1', '\x2', '\x2', '\x833', 
		'\x835', '\x5', 'Z', '.', '\x2', '\x834', '\x833', '\x3', '\x2', '\x2', 
		'\x2', '\x834', '\x835', '\x3', '\x2', '\x2', '\x2', '\x835', 'o', '\x3', 
		'\x2', '\x2', '\x2', '\x836', '\x838', '\a', '\x209', '\x2', '\x2', '\x837', 
		'\x839', '\x5', 'Z', '.', '\x2', '\x838', '\x837', '\x3', '\x2', '\x2', 
		'\x2', '\x838', '\x839', '\x3', '\x2', '\x2', '\x2', '\x839', 'q', '\x3', 
		'\x2', '\x2', '\x2', '\x83A', '\x83C', '\a', '\x119', '\x2', '\x2', '\x83B', 
		'\x83D', '\x5', 'Z', '.', '\x2', '\x83C', '\x83B', '\x3', '\x2', '\x2', 
		'\x2', '\x83C', '\x83D', '\x3', '\x2', '\x2', '\x2', '\x83D', 's', '\x3', 
		'\x2', '\x2', '\x2', '\x83E', '\x840', '\a', '\x19F', '\x2', '\x2', '\x83F', 
		'\x841', '\x5', 'Z', '.', '\x2', '\x840', '\x83F', '\x3', '\x2', '\x2', 
		'\x2', '\x840', '\x841', '\x3', '\x2', '\x2', '\x2', '\x841', 'u', '\x3', 
		'\x2', '\x2', '\x2', '\x842', '\x843', '\a', '\x119', '\x2', '\x2', '\x843', 
		'\x844', '\x5', 't', ';', '\x2', '\x844', 'w', '\x3', '\x2', '\x2', '\x2', 
		'\x845', '\x846', '\a', '\x8E', '\x2', '\x2', '\x846', '\x848', '\a', 
		'\x191', '\x2', '\x2', '\x847', '\x849', '\x5', 'Z', '.', '\x2', '\x848', 
		'\x847', '\x3', '\x2', '\x2', '\x2', '\x848', '\x849', '\x3', '\x2', '\x2', 
		'\x2', '\x849', 'y', '\x3', '\x2', '\x2', '\x2', '\x84A', '\x84C', '\t', 
		'\f', '\x2', '\x2', '\x84B', '\x84D', '\a', '\x22B', '\x2', '\x2', '\x84C', 
		'\x84B', '\x3', '\x2', '\x2', '\x2', '\x84C', '\x84D', '\x3', '\x2', '\x2', 
		'\x2', '\x84D', '\x84F', '\x3', '\x2', '\x2', '\x2', '\x84E', '\x850', 
		'\x5', '\x88', '\x45', '\x2', '\x84F', '\x84E', '\x3', '\x2', '\x2', '\x2', 
		'\x84F', '\x850', '\x3', '\x2', '\x2', '\x2', '\x850', '\x852', '\x3', 
		'\x2', '\x2', '\x2', '\x851', '\x853', '\x5', '\x90', 'I', '\x2', '\x852', 
		'\x851', '\x3', '\x2', '\x2', '\x2', '\x852', '\x853', '\x3', '\x2', '\x2', 
		'\x2', '\x853', '{', '\x3', '\x2', '\x2', '\x2', '\x854', '\x855', '\a', 
		'\x138', '\x2', '\x2', '\x855', '\x857', '\t', '\f', '\x2', '\x2', '\x856', 
		'\x858', '\a', '\x22B', '\x2', '\x2', '\x857', '\x856', '\x3', '\x2', 
		'\x2', '\x2', '\x857', '\x858', '\x3', '\x2', '\x2', '\x2', '\x858', '\x85A', 
		'\x3', '\x2', '\x2', '\x2', '\x859', '\x85B', '\x5', 'Z', '.', '\x2', 
		'\x85A', '\x859', '\x3', '\x2', '\x2', '\x2', '\x85A', '\x85B', '\x3', 
		'\x2', '\x2', '\x2', '\x85B', '\x85D', '\x3', '\x2', '\x2', '\x2', '\x85C', 
		'\x85E', '\x5', '\x90', 'I', '\x2', '\x85D', '\x85C', '\x3', '\x2', '\x2', 
		'\x2', '\x85D', '\x85E', '\x3', '\x2', '\x2', '\x2', '\x85E', '}', '\x3', 
		'\x2', '\x2', '\x2', '\x85F', '\x861', '\a', '\x13A', '\x2', '\x2', '\x860', 
		'\x862', '\a', '\x22B', '\x2', '\x2', '\x861', '\x860', '\x3', '\x2', 
		'\x2', '\x2', '\x861', '\x862', '\x3', '\x2', '\x2', '\x2', '\x862', '\x864', 
		'\x3', '\x2', '\x2', '\x2', '\x863', '\x865', '\x5', 'Z', '.', '\x2', 
		'\x864', '\x863', '\x3', '\x2', '\x2', '\x2', '\x864', '\x865', '\x3', 
		'\x2', '\x2', '\x2', '\x865', '\x867', '\x3', '\x2', '\x2', '\x2', '\x866', 
		'\x868', '\x5', '\x90', 'I', '\x2', '\x867', '\x866', '\x3', '\x2', '\x2', 
		'\x2', '\x867', '\x868', '\x3', '\x2', '\x2', '\x2', '\x868', '\x7F', 
		'\x3', '\x2', '\x2', '\x2', '\x869', '\x86B', '\a', '\x160', '\x2', '\x2', 
		'\x86A', '\x86C', '\x5', 'Z', '.', '\x2', '\x86B', '\x86A', '\x3', '\x2', 
		'\x2', '\x2', '\x86B', '\x86C', '\x3', '\x2', '\x2', '\x2', '\x86C', '\x86E', 
		'\x3', '\x2', '\x2', '\x2', '\x86D', '\x86F', '\x5', '\x90', 'I', '\x2', 
		'\x86E', '\x86D', '\x3', '\x2', '\x2', '\x2', '\x86E', '\x86F', '\x3', 
		'\x2', '\x2', '\x2', '\x86F', '\x81', '\x3', '\x2', '\x2', '\x2', '\x870', 
		'\x872', '\a', '\x227', '\x2', '\x2', '\x871', '\x873', '\x5', '\x88', 
		'\x45', '\x2', '\x872', '\x871', '\x3', '\x2', '\x2', '\x2', '\x872', 
		'\x873', '\x3', '\x2', '\x2', '\x2', '\x873', '\x875', '\x3', '\x2', '\x2', 
		'\x2', '\x874', '\x876', '\x5', '\x90', 'I', '\x2', '\x875', '\x874', 
		'\x3', '\x2', '\x2', '\x2', '\x875', '\x876', '\x3', '\x2', '\x2', '\x2', 
		'\x876', '\x83', '\x3', '\x2', '\x2', '\x2', '\x877', '\x879', '\a', '\x228', 
		'\x2', '\x2', '\x878', '\x87A', '\x5', '\x88', '\x45', '\x2', '\x879', 
		'\x878', '\x3', '\x2', '\x2', '\x2', '\x879', '\x87A', '\x3', '\x2', '\x2', 
		'\x2', '\x87A', '\x87C', '\x3', '\x2', '\x2', '\x2', '\x87B', '\x87D', 
		'\x5', '\x90', 'I', '\x2', '\x87C', '\x87B', '\x3', '\x2', '\x2', '\x2', 
		'\x87C', '\x87D', '\x3', '\x2', '\x2', '\x2', '\x87D', '\x85', '\x3', 
		'\x2', '\x2', '\x2', '\x87E', '\x880', '\a', '\x1ED', '\x2', '\x2', '\x87F', 
		'\x881', '\x5', '\x88', '\x45', '\x2', '\x880', '\x87F', '\x3', '\x2', 
		'\x2', '\x2', '\x880', '\x881', '\x3', '\x2', '\x2', '\x2', '\x881', '\x883', 
		'\x3', '\x2', '\x2', '\x2', '\x882', '\x884', '\x5', '\x90', 'I', '\x2', 
		'\x883', '\x882', '\x3', '\x2', '\x2', '\x2', '\x883', '\x884', '\x3', 
		'\x2', '\x2', '\x2', '\x884', '\x87', '\x3', '\x2', '\x2', '\x2', '\x885', 
		'\x886', '\a', '\x24B', '\x2', '\x2', '\x886', '\x888', '\x5', '\xA2', 
		'R', '\x2', '\x887', '\x889', '\t', '\r', '\x2', '\x2', '\x888', '\x887', 
		'\x3', '\x2', '\x2', '\x2', '\x888', '\x889', '\x3', '\x2', '\x2', '\x2', 
		'\x889', '\x88A', '\x3', '\x2', '\x2', '\x2', '\x88A', '\x88B', '\a', 
		'\x24C', '\x2', '\x2', '\x88B', '\x89', '\x3', '\x2', '\x2', '\x2', '\x88C', 
		'\x88F', '\x5', '\x64', '\x33', '\x2', '\x88D', '\x88F', '\x5', '\x66', 
		'\x34', '\x2', '\x88E', '\x88C', '\x3', '\x2', '\x2', '\x2', '\x88E', 
		'\x88D', '\x3', '\x2', '\x2', '\x2', '\x88F', '\x897', '\x3', '\x2', '\x2', 
		'\x2', '\x890', '\x892', '\x5', 'h', '\x35', '\x2', '\x891', '\x893', 
		'\x5', 'j', '\x36', '\x2', '\x892', '\x891', '\x3', '\x2', '\x2', '\x2', 
		'\x892', '\x893', '\x3', '\x2', '\x2', '\x2', '\x893', '\x894', '\x3', 
		'\x2', '\x2', '\x2', '\x894', '\x895', '\x5', '\x66', '\x34', '\x2', '\x895', 
		'\x896', '\x5', 'l', '\x37', '\x2', '\x896', '\x898', '\x3', '\x2', '\x2', 
		'\x2', '\x897', '\x890', '\x3', '\x2', '\x2', '\x2', '\x897', '\x898', 
		'\x3', '\x2', '\x2', '\x2', '\x898', '\x8B', '\x3', '\x2', '\x2', '\x2', 
		'\x899', '\x89A', '\x5', 'n', '\x38', '\x2', '\x89A', '\x89B', '\x5', 
		'\x44', '#', '\x2', '\x89B', '\x89C', '\x5', 'p', '\x39', '\x2', '\x89C', 
		'\x89D', '\x5', '\x44', '#', '\x2', '\x89D', '\x8D', '\x3', '\x2', '\x2', 
		'\x2', '\x89E', '\x8A6', '\x5', 'z', '>', '\x2', '\x89F', '\x8A6', '\x5', 
		'\x82', '\x42', '\x2', '\x8A0', '\x8A6', '\x5', '\x84', '\x43', '\x2', 
		'\x8A1', '\x8A6', '\x5', '~', '@', '\x2', '\x8A2', '\x8A6', '\x5', '\x80', 
		'\x41', '\x2', '\x8A3', '\x8A6', '\x5', '\x86', '\x44', '\x2', '\x8A4', 
		'\x8A6', '\x5', '|', '?', '\x2', '\x8A5', '\x89E', '\x3', '\x2', '\x2', 
		'\x2', '\x8A5', '\x89F', '\x3', '\x2', '\x2', '\x2', '\x8A5', '\x8A0', 
		'\x3', '\x2', '\x2', '\x2', '\x8A5', '\x8A1', '\x3', '\x2', '\x2', '\x2', 
		'\x8A5', '\x8A2', '\x3', '\x2', '\x2', '\x2', '\x8A5', '\x8A3', '\x3', 
		'\x2', '\x2', '\x2', '\x8A5', '\x8A4', '\x3', '\x2', '\x2', '\x2', '\x8A6', 
		'\x8F', '\x3', '\x2', '\x2', '\x2', '\x8A7', '\x8A8', '\a', 'G', '\x2', 
		'\x2', '\x8A8', '\x8A9', '\x5', '\\', '/', '\x2', '\x8A9', '\x91', '\x3', 
		'\x2', '\x2', '\x2', '\x8AA', '\x8AE', '\x5', 't', ';', '\x2', '\x8AB', 
		'\x8AE', '\x5', 'v', '<', '\x2', '\x8AC', '\x8AE', '\x5', 'r', ':', '\x2', 
		'\x8AD', '\x8AA', '\x3', '\x2', '\x2', '\x2', '\x8AD', '\x8AB', '\x3', 
		'\x2', '\x2', '\x2', '\x8AD', '\x8AC', '\x3', '\x2', '\x2', '\x2', '\x8AE', 
		'\x93', '\x3', '\x2', '\x2', '\x2', '\x8AF', '\x8B3', '\x5', '\x96', 'L', 
		'\x2', '\x8B0', '\x8B3', '\x5', '\x9A', 'N', '\x2', '\x8B1', '\x8B3', 
		'\x5', '\x9E', 'P', '\x2', '\x8B2', '\x8AF', '\x3', '\x2', '\x2', '\x2', 
		'\x8B2', '\x8B0', '\x3', '\x2', '\x2', '\x2', '\x8B2', '\x8B1', '\x3', 
		'\x2', '\x2', '\x2', '\x8B3', '\x95', '\x3', '\x2', '\x2', '\x2', '\x8B4', 
		'\x8B5', '\a', '>', '\x2', '\x2', '\x8B5', '\x8B6', '\a', '\x1D8', '\x2', 
		'\x2', '\x8B6', '\x8B8', '\x5', '\xA2', 'R', '\x2', '\x8B7', '\x8B9', 
		'\x5', '\x98', 'M', '\x2', '\x8B8', '\x8B7', '\x3', '\x2', '\x2', '\x2', 
		'\x8B8', '\x8B9', '\x3', '\x2', '\x2', '\x2', '\x8B9', '\x97', '\x3', 
		'\x2', '\x2', '\x2', '\x8BA', '\x8BB', '\a', '\x254', '\x2', '\x2', '\x8BB', 
		'\x8BC', '\a', '?', '\x2', '\x2', '\x8BC', '\x99', '\x3', '\x2', '\x2', 
		'\x2', '\x8BD', '\x8BE', '\a', '\x19E', '\x2', '\x2', '\x8BE', '\x8BF', 
		'\x5', '\xA2', 'R', '\x2', '\x8BF', '\x8C0', '\x5', '\x9C', 'O', '\x2', 
		'\x8C0', '\x8C1', '\x5', '\xA2', 'R', '\x2', '\x8C1', '\x9B', '\x3', '\x2', 
		'\x2', '\x2', '\x8C2', '\x8C3', '\a', '\x24A', '\x2', '\x2', '\x8C3', 
		'\x9D', '\x3', '\x2', '\x2', '\x2', '\x8C4', '\x8C5', '\a', '\x254', '\x2', 
		'\x2', '\x8C5', '\x8C6', '\t', '\xE', '\x2', '\x2', '\x8C6', '\x9F', '\x3', 
		'\x2', '\x2', '\x2', '\x8C7', '\x8C8', '\a', '\x1A6', '\x2', '\x2', '\x8C8', 
		'\x8C9', '\x5', '\x44', '#', '\x2', '\x8C9', '\xA1', '\x3', '\x2', '\x2', 
		'\x2', '\x8CA', '\x8CB', '\x5', '\xA4', 'S', '\x2', '\x8CB', '\xA3', '\x3', 
		'\x2', '\x2', '\x2', '\x8CC', '\x8D1', '\x5', '\xA6', 'T', '\x2', '\x8CD', 
		'\x8CE', '\a', '\x16E', '\x2', '\x2', '\x8CE', '\x8D0', '\x5', '\xA6', 
		'T', '\x2', '\x8CF', '\x8CD', '\x3', '\x2', '\x2', '\x2', '\x8D0', '\x8D3', 
		'\x3', '\x2', '\x2', '\x2', '\x8D1', '\x8CF', '\x3', '\x2', '\x2', '\x2', 
		'\x8D1', '\x8D2', '\x3', '\x2', '\x2', '\x2', '\x8D2', '\xA5', '\x3', 
		'\x2', '\x2', '\x2', '\x8D3', '\x8D1', '\x3', '\x2', '\x2', '\x2', '\x8D4', 
		'\x8D9', '\x5', '\xA8', 'U', '\x2', '\x8D5', '\x8D6', '\a', '\x10', '\x2', 
		'\x2', '\x8D6', '\x8D8', '\x5', '\xA8', 'U', '\x2', '\x8D7', '\x8D5', 
		'\x3', '\x2', '\x2', '\x2', '\x8D8', '\x8DB', '\x3', '\x2', '\x2', '\x2', 
		'\x8D9', '\x8D7', '\x3', '\x2', '\x2', '\x2', '\x8D9', '\x8DA', '\x3', 
		'\x2', '\x2', '\x2', '\x8DA', '\xA7', '\x3', '\x2', '\x2', '\x2', '\x8DB', 
		'\x8D9', '\x3', '\x2', '\x2', '\x2', '\x8DC', '\x8DE', '\a', '\x15A', 
		'\x2', '\x2', '\x8DD', '\x8DC', '\x3', '\x2', '\x2', '\x2', '\x8DD', '\x8DE', 
		'\x3', '\x2', '\x2', '\x2', '\x8DE', '\x8E1', '\x3', '\x2', '\x2', '\x2', 
		'\x8DF', '\x8E2', '\x5', '\xAA', 'V', '\x2', '\x8E0', '\x8E2', '\x5', 
		'\xB0', 'Y', '\x2', '\x8E1', '\x8DF', '\x3', '\x2', '\x2', '\x2', '\x8E1', 
		'\x8E0', '\x3', '\x2', '\x2', '\x2', '\x8E2', '\xA9', '\x3', '\x2', '\x2', 
		'\x2', '\x8E3', '\x8E4', '\x5', '\xAC', 'W', '\x2', '\x8E4', '\x8E5', 
		'\x5', '\x44', '#', '\x2', '\x8E5', '\x8EB', '\x3', '\x2', '\x2', '\x2', 
		'\x8E6', '\x8E7', '\x5', '\xAE', 'X', '\x2', '\x8E7', '\x8E8', '\x5', 
		'\x15C', '\xAF', '\x2', '\x8E8', '\x8EB', '\x3', '\x2', '\x2', '\x2', 
		'\x8E9', '\x8EB', '\x5', '\x142', '\xA2', '\x2', '\x8EA', '\x8E3', '\x3', 
		'\x2', '\x2', '\x2', '\x8EA', '\x8E6', '\x3', '\x2', '\x2', '\x2', '\x8EA', 
		'\x8E9', '\x3', '\x2', '\x2', '\x2', '\x8EB', '\xAB', '\x3', '\x2', '\x2', 
		'\x2', '\x8EC', '\x8ED', '\a', 'h', '\x2', '\x2', '\x8ED', '\x8EE', '\a', 
		'\x162', '\x2', '\x2', '\x8EE', '\xAD', '\x3', '\x2', '\x2', '\x2', '\x8EF', 
		'\x8F0', '\a', '\xAB', '\x2', '\x2', '\x8F0', '\xAF', '\x3', '\x2', '\x2', 
		'\x2', '\x8F1', '\x923', '\x5', '\xC8', '\x65', '\x2', '\x8F2', '\x8FD', 
		'\x5', '\x15A', '\xAE', '\x2', '\x8F3', '\x8F7', '\x5', '\xB4', '[', '\x2', 
		'\x8F4', '\x8F7', '\x5', '\xB6', '\\', '\x2', '\x8F5', '\x8F7', '\x5', 
		'\xB8', ']', '\x2', '\x8F6', '\x8F3', '\x3', '\x2', '\x2', '\x2', '\x8F6', 
		'\x8F4', '\x3', '\x2', '\x2', '\x2', '\x8F6', '\x8F5', '\x3', '\x2', '\x2', 
		'\x2', '\x8F7', '\x8FA', '\x3', '\x2', '\x2', '\x2', '\x8F8', '\x8FB', 
		'\x5', '\x15C', '\xAF', '\x2', '\x8F9', '\x8FB', '\x5', '\x146', '\xA4', 
		'\x2', '\x8FA', '\x8F8', '\x3', '\x2', '\x2', '\x2', '\x8FA', '\x8F9', 
		'\x3', '\x2', '\x2', '\x2', '\x8FB', '\x8FE', '\x3', '\x2', '\x2', '\x2', 
		'\x8FC', '\x8FE', '\x5', '\xC8', '\x65', '\x2', '\x8FD', '\x8F6', '\x3', 
		'\x2', '\x2', '\x2', '\x8FD', '\x8FC', '\x3', '\x2', '\x2', '\x2', '\x8FE', 
		'\x924', '\x3', '\x2', '\x2', '\x2', '\x8FF', '\x924', '\x5', '\x148', 
		'\xA5', '\x2', '\x900', '\x924', '\x5', '\xC4', '\x63', '\x2', '\x901', 
		'\x903', '\x5', '\xBA', '^', '\x2', '\x902', '\x901', '\x3', '\x2', '\x2', 
		'\x2', '\x902', '\x903', '\x3', '\x2', '\x2', '\x2', '\x903', '\x904', 
		'\x3', '\x2', '\x2', '\x2', '\x904', '\x905', '\x5', '\x156', '\xAC', 
		'\x2', '\x905', '\x906', '\x5', '\xC8', '\x65', '\x2', '\x906', '\x907', 
		'\x5', '\x158', '\xAD', '\x2', '\x907', '\x908', '\x5', '\xC8', '\x65', 
		'\x2', '\x908', '\x924', '\x3', '\x2', '\x2', '\x2', '\x909', '\x90B', 
		'\x5', '\xBC', '_', '\x2', '\x90A', '\x90C', '\x5', '\xBA', '^', '\x2', 
		'\x90B', '\x90A', '\x3', '\x2', '\x2', '\x2', '\x90B', '\x90C', '\x3', 
		'\x2', '\x2', '\x2', '\x90C', '\x90D', '\x3', '\x2', '\x2', '\x2', '\x90D', 
		'\x90E', '\x5', '\x116', '\x8C', '\x2', '\x90E', '\x924', '\x3', '\x2', 
		'\x2', '\x2', '\x90F', '\x911', '\x5', '\xBA', '^', '\x2', '\x910', '\x90F', 
		'\x3', '\x2', '\x2', '\x2', '\x910', '\x911', '\x3', '\x2', '\x2', '\x2', 
		'\x911', '\x912', '\x3', '\x2', '\x2', '\x2', '\x912', '\x913', '\x5', 
		'\x152', '\xAA', '\x2', '\x913', '\x915', '\x5', '\xC8', '\x65', '\x2', 
		'\x914', '\x916', '\x5', '\x154', '\xAB', '\x2', '\x915', '\x914', '\x3', 
		'\x2', '\x2', '\x2', '\x915', '\x916', '\x3', '\x2', '\x2', '\x2', '\x916', 
		'\x924', '\x3', '\x2', '\x2', '\x2', '\x917', '\x919', '\x5', '\xBA', 
		'^', '\x2', '\x918', '\x917', '\x3', '\x2', '\x2', '\x2', '\x918', '\x919', 
		'\x3', '\x2', '\x2', '\x2', '\x919', '\x91A', '\x3', '\x2', '\x2', '\x2', 
		'\x91A', '\x921', '\x5', '\xBE', '`', '\x2', '\x91B', '\x922', '\x5', 
		'\x15C', '\xAF', '\x2', '\x91C', '\x922', '\x5', '\xB2', 'Z', '\x2', '\x91D', 
		'\x91E', '\x5', '\xC0', '\x61', '\x2', '\x91E', '\x91F', '\x5', '\x166', 
		'\xB4', '\x2', '\x91F', '\x920', '\x5', '\xC2', '\x62', '\x2', '\x920', 
		'\x922', '\x3', '\x2', '\x2', '\x2', '\x921', '\x91B', '\x3', '\x2', '\x2', 
		'\x2', '\x921', '\x91C', '\x3', '\x2', '\x2', '\x2', '\x921', '\x91D', 
		'\x3', '\x2', '\x2', '\x2', '\x922', '\x924', '\x3', '\x2', '\x2', '\x2', 
		'\x923', '\x8F2', '\x3', '\x2', '\x2', '\x2', '\x923', '\x8FF', '\x3', 
		'\x2', '\x2', '\x2', '\x923', '\x900', '\x3', '\x2', '\x2', '\x2', '\x923', 
		'\x902', '\x3', '\x2', '\x2', '\x2', '\x923', '\x909', '\x3', '\x2', '\x2', 
		'\x2', '\x923', '\x910', '\x3', '\x2', '\x2', '\x2', '\x923', '\x918', 
		'\x3', '\x2', '\x2', '\x2', '\x923', '\x924', '\x3', '\x2', '\x2', '\x2', 
		'\x924', '\xB1', '\x3', '\x2', '\x2', '\x2', '\x925', '\x926', '\x5', 
		'\xC8', '\x65', '\x2', '\x926', '\xB3', '\x3', '\x2', '\x2', '\x2', '\x927', 
		'\x928', '\a', '\x11', '\x2', '\x2', '\x928', '\xB5', '\x3', '\x2', '\x2', 
		'\x2', '\x929', '\x92A', '\a', '\x1E1', '\x2', '\x2', '\x92A', '\xB7', 
		'\x3', '\x2', '\x2', '\x2', '\x92B', '\x92C', '\a', '\n', '\x2', '\x2', 
		'\x92C', '\xB9', '\x3', '\x2', '\x2', '\x2', '\x92D', '\x92E', '\a', '\x15A', 
		'\x2', '\x2', '\x92E', '\xBB', '\x3', '\x2', '\x2', '\x2', '\x92F', '\x930', 
		'\a', '\xF6', '\x2', '\x2', '\x930', '\xBD', '\x3', '\x2', '\x2', '\x2', 
		'\x931', '\x932', '\a', '\xDE', '\x2', '\x2', '\x932', '\xBF', '\x3', 
		'\x2', '\x2', '\x2', '\x933', '\x934', '\a', '\x24B', '\x2', '\x2', '\x934', 
		'\xC1', '\x3', '\x2', '\x2', '\x2', '\x935', '\x936', '\a', '\x24C', '\x2', 
		'\x2', '\x936', '\xC3', '\x3', '\x2', '\x2', '\x2', '\x937', '\x939', 
		'\a', '\xF6', '\x2', '\x2', '\x938', '\x93A', '\a', '\x15A', '\x2', '\x2', 
		'\x939', '\x938', '\x3', '\x2', '\x2', '\x2', '\x939', '\x93A', '\x3', 
		'\x2', '\x2', '\x2', '\x93A', '\x93B', '\x3', '\x2', '\x2', '\x2', '\x93B', 
		'\x93D', '\a', '\x162', '\x2', '\x2', '\x93C', '\x93E', '\a', '\x213', 
		'\x2', '\x2', '\x93D', '\x93C', '\x3', '\x2', '\x2', '\x2', '\x93D', '\x93E', 
		'\x3', '\x2', '\x2', '\x2', '\x93E', '\x93F', '\x3', '\x2', '\x2', '\x2', 
		'\x93F', '\x940', '\x5', '\xC6', '\x64', '\x2', '\x940', '\xC5', '\x3', 
		'\x2', '\x2', '\x2', '\x941', '\x943', '\a', '\x24B', '\x2', '\x2', '\x942', 
		'\x944', '\a', '\x167', '\x2', '\x2', '\x943', '\x942', '\x3', '\x2', 
		'\x2', '\x2', '\x943', '\x944', '\x3', '\x2', '\x2', '\x2', '\x944', '\x945', 
		'\x3', '\x2', '\x2', '\x2', '\x945', '\x94A', '\x5', '\x46', '$', '\x2', 
		'\x946', '\x947', '\a', '\x24D', '\x2', '\x2', '\x947', '\x949', '\x5', 
		'\x46', '$', '\x2', '\x948', '\x946', '\x3', '\x2', '\x2', '\x2', '\x949', 
		'\x94C', '\x3', '\x2', '\x2', '\x2', '\x94A', '\x948', '\x3', '\x2', '\x2', 
		'\x2', '\x94A', '\x94B', '\x3', '\x2', '\x2', '\x2', '\x94B', '\x94D', 
		'\x3', '\x2', '\x2', '\x2', '\x94C', '\x94A', '\x3', '\x2', '\x2', '\x2', 
		'\x94D', '\x94E', '\a', '\x24C', '\x2', '\x2', '\x94E', '\xC7', '\x3', 
		'\x2', '\x2', '\x2', '\x94F', '\x952', '\x5', '\xCA', '\x66', '\x2', '\x950', 
		'\x952', '\x5', 'L', '\'', '\x2', '\x951', '\x94F', '\x3', '\x2', '\x2', 
		'\x2', '\x951', '\x950', '\x3', '\x2', '\x2', '\x2', '\x952', '\xC9', 
		'\x3', '\x2', '\x2', '\x2', '\x953', '\x959', '\x5', '\xCC', 'g', '\x2', 
		'\x954', '\x955', '\x5', '\xCE', 'h', '\x2', '\x955', '\x956', '\x5', 
		'\xCC', 'g', '\x2', '\x956', '\x958', '\x3', '\x2', '\x2', '\x2', '\x957', 
		'\x954', '\x3', '\x2', '\x2', '\x2', '\x958', '\x95B', '\x3', '\x2', '\x2', 
		'\x2', '\x959', '\x957', '\x3', '\x2', '\x2', '\x2', '\x959', '\x95A', 
		'\x3', '\x2', '\x2', '\x2', '\x95A', '\xCB', '\x3', '\x2', '\x2', '\x2', 
		'\x95B', '\x959', '\x3', '\x2', '\x2', '\x2', '\x95C', '\x962', '\x5', 
		'\x114', '\x8B', '\x2', '\x95D', '\x95E', '\x5', '\xD0', 'i', '\x2', '\x95E', 
		'\x95F', '\x5', '\x114', '\x8B', '\x2', '\x95F', '\x961', '\x3', '\x2', 
		'\x2', '\x2', '\x960', '\x95D', '\x3', '\x2', '\x2', '\x2', '\x961', '\x964', 
		'\x3', '\x2', '\x2', '\x2', '\x962', '\x960', '\x3', '\x2', '\x2', '\x2', 
		'\x962', '\x963', '\x3', '\x2', '\x2', '\x2', '\x963', '\xCD', '\x3', 
		'\x2', '\x2', '\x2', '\x964', '\x962', '\x3', '\x2', '\x2', '\x2', '\x965', 
		'\x966', '\t', '\xF', '\x2', '\x2', '\x966', '\xCF', '\x3', '\x2', '\x2', 
		'\x2', '\x967', '\x968', '\t', '\x10', '\x2', '\x2', '\x968', '\xD1', 
		'\x3', '\x2', '\x2', '\x2', '\x969', '\x98D', '\x5', '\x116', '\x8C', 
		'\x2', '\x96A', '\x98D', '\x5', '(', '\x15', '\x2', '\x96B', '\x98D', 
		'\x5', '\x118', '\x8D', '\x2', '\x96C', '\x98D', '\x5', '\x11A', '\x8E', 
		'\x2', '\x96D', '\x98D', '\x5', '\x12E', '\x98', '\x2', '\x96E', '\x98D', 
		'\x5', '\xE0', 'q', '\x2', '\x96F', '\x98D', '\x5', '\x11C', '\x8F', '\x2', 
		'\x970', '\x98D', '\x5', '\x132', '\x9A', '\x2', '\x971', '\x98D', '\x5', 
		'\x134', '\x9B', '\x2', '\x972', '\x98D', '\x5', '\x136', '\x9C', '\x2', 
		'\x973', '\x98D', '\x5', '\xDE', 'p', '\x2', '\x974', '\x975', '\a', '\x257', 
		'\x2', '\x2', '\x975', '\x98D', '\x5', '\xD2', 'j', '\x2', '\x976', '\x977', 
		'\a', '\x256', '\x2', '\x2', '\x977', '\x98D', '\x5', '\xD2', 'j', '\x2', 
		'\x978', '\x98D', '\x5', '\x128', '\x95', '\x2', '\x979', '\x98D', '\x5', 
		'\x12A', '\x96', '\x2', '\x97A', '\x98D', '\x5', '\x12C', '\x97', '\x2', 
		'\x97B', '\x98D', '\x5', '\x54C', '\x2A7', '\x2', '\x97C', '\x98D', '\x5', 
		'\x54E', '\x2A8', '\x2', '\x97D', '\x98D', '\x5', '\x15C', '\xAF', '\x2', 
		'\x97E', '\x97F', '\a', '\x24B', '\x2', '\x2', '\x97F', '\x980', '\x5', 
		'\xA2', 'R', '\x2', '\x980', '\x981', '\a', '\x24C', '\x2', '\x2', '\x981', 
		'\x98D', '\x3', '\x2', '\x2', '\x2', '\x982', '\x98D', '\x5', '\x16E', 
		'\xB8', '\x2', '\x983', '\x98D', '\x5', '\x10A', '\x86', '\x2', '\x984', 
		'\x98D', '\x5', '\x10C', '\x87', '\x2', '\x985', '\x98D', '\x5', '\xFA', 
		'~', '\x2', '\x986', '\x98D', '\x5', '\xF6', '|', '\x2', '\x987', '\x98D', 
		'\x5', '\xF2', 'z', '\x2', '\x988', '\x98D', '\x5', '\x44', '#', '\x2', 
		'\x989', '\x98D', '\x5', '`', '\x31', '\x2', '\x98A', '\x98D', '\x5', 
		'\xD4', 'k', '\x2', '\x98B', '\x98D', '\x5', '\xDC', 'o', '\x2', '\x98C', 
		'\x969', '\x3', '\x2', '\x2', '\x2', '\x98C', '\x96A', '\x3', '\x2', '\x2', 
		'\x2', '\x98C', '\x96B', '\x3', '\x2', '\x2', '\x2', '\x98C', '\x96C', 
		'\x3', '\x2', '\x2', '\x2', '\x98C', '\x96D', '\x3', '\x2', '\x2', '\x2', 
		'\x98C', '\x96E', '\x3', '\x2', '\x2', '\x2', '\x98C', '\x96F', '\x3', 
		'\x2', '\x2', '\x2', '\x98C', '\x970', '\x3', '\x2', '\x2', '\x2', '\x98C', 
		'\x971', '\x3', '\x2', '\x2', '\x2', '\x98C', '\x972', '\x3', '\x2', '\x2', 
		'\x2', '\x98C', '\x973', '\x3', '\x2', '\x2', '\x2', '\x98C', '\x974', 
		'\x3', '\x2', '\x2', '\x2', '\x98C', '\x976', '\x3', '\x2', '\x2', '\x2', 
		'\x98C', '\x978', '\x3', '\x2', '\x2', '\x2', '\x98C', '\x979', '\x3', 
		'\x2', '\x2', '\x2', '\x98C', '\x97A', '\x3', '\x2', '\x2', '\x2', '\x98C', 
		'\x97B', '\x3', '\x2', '\x2', '\x2', '\x98C', '\x97C', '\x3', '\x2', '\x2', 
		'\x2', '\x98C', '\x97D', '\x3', '\x2', '\x2', '\x2', '\x98C', '\x97E', 
		'\x3', '\x2', '\x2', '\x2', '\x98C', '\x982', '\x3', '\x2', '\x2', '\x2', 
		'\x98C', '\x983', '\x3', '\x2', '\x2', '\x2', '\x98C', '\x984', '\x3', 
		'\x2', '\x2', '\x2', '\x98C', '\x985', '\x3', '\x2', '\x2', '\x2', '\x98C', 
		'\x986', '\x3', '\x2', '\x2', '\x2', '\x98C', '\x987', '\x3', '\x2', '\x2', 
		'\x2', '\x98C', '\x988', '\x3', '\x2', '\x2', '\x2', '\x98C', '\x989', 
		'\x3', '\x2', '\x2', '\x2', '\x98C', '\x98A', '\x3', '\x2', '\x2', '\x2', 
		'\x98C', '\x98B', '\x3', '\x2', '\x2', '\x2', '\x98D', '\x98F', '\x3', 
		'\x2', '\x2', '\x2', '\x98E', '\x990', '\x5', '\xEC', 'w', '\x2', '\x98F', 
		'\x98E', '\x3', '\x2', '\x2', '\x2', '\x98F', '\x990', '\x3', '\x2', '\x2', 
		'\x2', '\x990', '\xD3', '\x3', '\x2', '\x2', '\x2', '\x991', '\x992', 
		'\x5', '\xD6', 'l', '\x2', '\x992', '\xD5', '\x3', '\x2', '\x2', '\x2', 
		'\x993', '\x994', '\a', '\x23F', '\x2', '\x2', '\x994', '\x995', '\a', 
		'\x24B', '\x2', '\x2', '\x995', '\x996', '\x5', '\xC8', '\x65', '\x2', 
		'\x996', '\x999', '\a', '\x180', '\x2', '\x2', '\x997', '\x998', '\a', 
		'\x33', '\x2', '\x2', '\x998', '\x99A', '\a', '\x225', '\x2', '\x2', '\x999', 
		'\x997', '\x3', '\x2', '\x2', '\x2', '\x999', '\x99A', '\x3', '\x2', '\x2', 
		'\x2', '\x99A', '\x99B', '\x3', '\x2', '\x2', '\x2', '\x99B', '\x99C', 
		'\x5', '\xD8', 'm', '\x2', '\x99C', '\x99D', '\a', '\x1B5', '\x2', '\x2', 
		'\x99D', '\x99E', '\a', '_', '\x2', '\x2', '\x99E', '\x99F', '\a', '\x24C', 
		'\x2', '\x2', '\x99F', '\xD7', '\x3', '\x2', '\x2', '\x2', '\x9A0', '\x9A5', 
		'\x5', '\xDA', 'n', '\x2', '\x9A1', '\x9A2', '\a', '\x24D', '\x2', '\x2', 
		'\x9A2', '\x9A4', '\x5', '\xDA', 'n', '\x2', '\x9A3', '\x9A1', '\x3', 
		'\x2', '\x2', '\x2', '\x9A4', '\x9A7', '\x3', '\x2', '\x2', '\x2', '\x9A5', 
		'\x9A3', '\x3', '\x2', '\x2', '\x2', '\x9A5', '\x9A6', '\x3', '\x2', '\x2', 
		'\x2', '\x9A6', '\xD9', '\x3', '\x2', '\x2', '\x2', '\x9A7', '\x9A5', 
		'\x3', '\x2', '\x2', '\x2', '\x9A8', '\x9AB', '\x5', '\xC8', '\x65', '\x2', 
		'\x9A9', '\x9AA', '\a', '\x15', '\x2', '\x2', '\x9AA', '\x9AC', '\x5', 
		'\x44', '#', '\x2', '\x9AB', '\x9A9', '\x3', '\x2', '\x2', '\x2', '\x9AB', 
		'\x9AC', '\x3', '\x2', '\x2', '\x2', '\x9AC', '\xDB', '\x3', '\x2', '\x2', 
		'\x2', '\x9AD', '\x9AE', '\a', '\x23D', '\x2', '\x2', '\x9AE', '\x9B2', 
		'\a', '\x24B', '\x2', '\x2', '\x9AF', '\x9B0', '\a', '\x136', '\x2', '\x2', 
		'\x9B0', '\x9B3', '\x5', '\x15C', '\xAF', '\x2', '\x9B1', '\x9B3', '\x5', 
		'\xA2', 'R', '\x2', '\x9B2', '\x9AF', '\x3', '\x2', '\x2', '\x2', '\x9B2', 
		'\x9B1', '\x3', '\x2', '\x2', '\x2', '\x9B3', '\x9B4', '\x3', '\x2', '\x2', 
		'\x2', '\x9B4', '\x9B5', '\a', '\x15', '\x2', '\x2', '\x9B5', '\x9B6', 
		'\x5', '\x62', '\x32', '\x2', '\x9B6', '\x9B7', '\a', '\x24C', '\x2', 
		'\x2', '\x9B7', '\xDD', '\x3', '\x2', '\x2', '\x2', '\x9B8', '\x9B9', 
		'\a', '\x13F', '\x2', '\x2', '\x9B9', '\x9BA', '\x5', '\x44', '#', '\x2', 
		'\x9BA', '\xDF', '\x3', '\x2', '\x2', '\x2', '\x9BB', '\x9BC', '\a', '\x20D', 
		'\x2', '\x2', '\x9BC', '\x9BE', '\x5', '\xE2', 'r', '\x2', '\x9BD', '\x9BF', 
		'\x5', '\xE6', 't', '\x2', '\x9BE', '\x9BD', '\x3', '\x2', '\x2', '\x2', 
		'\x9BE', '\x9BF', '\x3', '\x2', '\x2', '\x2', '\x9BF', '\xE1', '\x3', 
		'\x2', '\x2', '\x2', '\x9C0', '\x9C1', '\a', '\x24B', '\x2', '\x2', '\x9C1', 
		'\x9C2', '\x5', '\xA2', 'R', '\x2', '\x9C2', '\x9C3', '\x5', '\xE4', 's', 
		'\x2', '\x9C3', '\x9C4', '\a', '\x24C', '\x2', '\x2', '\x9C4', '\xE3', 
		'\x3', '\x2', '\x2', '\x2', '\x9C5', '\x9C7', '\a', '\x15', '\x2', '\x2', 
		'\x9C6', '\x9C8', '\a', '\x1A6', '\x2', '\x2', '\x9C7', '\x9C6', '\x3', 
		'\x2', '\x2', '\x2', '\x9C7', '\x9C8', '\x3', '\x2', '\x2', '\x2', '\x9C8', 
		'\x9C9', '\x3', '\x2', '\x2', '\x2', '\x9C9', '\x9CA', '\x5', '\x46', 
		'$', '\x2', '\x9CA', '\xE5', '\x3', '\x2', '\x2', '\x2', '\x9CB', '\x9CC', 
		'\a', '\x25C', '\x2', '\x2', '\x9CC', '\x9CD', '\x5', '\x44', '#', '\x2', 
		'\x9CD', '\xE7', '\x3', '\x2', '\x2', '\x2', '\x9CE', '\x9D4', '\x5', 
		'\xD2', 'j', '\x2', '\x9CF', '\x9D0', '\x5', '\xEA', 'v', '\x2', '\x9D0', 
		'\x9D1', '\x5', '\xD2', 'j', '\x2', '\x9D1', '\x9D3', '\x3', '\x2', '\x2', 
		'\x2', '\x9D2', '\x9CF', '\x3', '\x2', '\x2', '\x2', '\x9D3', '\x9D6', 
		'\x3', '\x2', '\x2', '\x2', '\x9D4', '\x9D2', '\x3', '\x2', '\x2', '\x2', 
		'\x9D4', '\x9D5', '\x3', '\x2', '\x2', '\x2', '\x9D5', '\xE9', '\x3', 
		'\x2', '\x2', '\x2', '\x9D6', '\x9D4', '\x3', '\x2', '\x2', '\x2', '\x9D7', 
		'\x9D8', '\a', '\x136', '\x2', '\x2', '\x9D8', '\x9DA', '\t', '\x11', 
		'\x2', '\x2', '\x9D9', '\x9DB', '\t', '\x12', '\x2', '\x2', '\x9DA', '\x9D9', 
		'\x3', '\x2', '\x2', '\x2', '\x9DA', '\x9DB', '\x3', '\x2', '\x2', '\x2', 
		'\x9DB', '\xEB', '\x3', '\x2', '\x2', '\x2', '\x9DC', '\x9DF', '\a', '\x18', 
		'\x2', '\x2', '\x9DD', '\x9E0', '\x5', '\xEE', 'x', '\x2', '\x9DE', '\x9E0', 
		'\x5', '\xF0', 'y', '\x2', '\x9DF', '\x9DD', '\x3', '\x2', '\x2', '\x2', 
		'\x9DF', '\x9DE', '\x3', '\x2', '\x2', '\x2', '\x9E0', '\xED', '\x3', 
		'\x2', '\x2', '\x2', '\x9E1', '\x9E2', '\a', '\x110', '\x2', '\x2', '\x9E2', 
		'\xEF', '\x3', '\x2', '\x2', '\x2', '\x9E3', '\x9E4', '\a', '\x203', '\x2', 
		'\x2', '\x9E4', '\x9E8', '\a', '\x244', '\x2', '\x2', '\x9E5', '\x9E9', 
		'\a', 'q', '\x2', '\x2', '\x9E6', '\x9E9', '\a', '\x1D7', '\x2', '\x2', 
		'\x9E7', '\x9E9', '\x5', '\xD2', 'j', '\x2', '\x9E8', '\x9E5', '\x3', 
		'\x2', '\x2', '\x2', '\x9E8', '\x9E6', '\x3', '\x2', '\x2', '\x2', '\x9E8', 
		'\x9E7', '\x3', '\x2', '\x2', '\x2', '\x9E9', '\xF1', '\x3', '\x2', '\x2', 
		'\x2', '\x9EA', '\x9EB', '\x5', '\x44', '#', '\x2', '\x9EB', '\x9ED', 
		'\x5', '\xF4', '{', '\x2', '\x9EC', '\x9EE', '\x5', '\xFC', '\x7F', '\x2', 
		'\x9ED', '\x9EC', '\x3', '\x2', '\x2', '\x2', '\x9ED', '\x9EE', '\x3', 
		'\x2', '\x2', '\x2', '\x9EE', '\xF3', '\x3', '\x2', '\x2', '\x2', '\x9EF', 
		'\x9F0', '\a', '\xFD', '\x2', '\x2', '\x9F0', '\x9F1', '\a', '\x24B', 
		'\x2', '\x2', '\x9F1', '\x9F2', '\a', '\x7F', '\x2', '\x2', '\x9F2', '\x9F3', 
		'\t', '\x13', '\x2', '\x2', '\x9F3', '\x9F4', '\x5', '\x3FC', '\x1FF', 
		'\x2', '\x9F4', '\x9F5', '\a', '\x24C', '\x2', '\x2', '\x9F5', '\xF5', 
		'\x3', '\x2', '\x2', '\x2', '\x9F6', '\x9F7', '\x5', '\x44', '#', '\x2', 
		'\x9F7', '\x9F9', '\x5', '\xF8', '}', '\x2', '\x9F8', '\x9FA', '\x5', 
		'\xFC', '\x7F', '\x2', '\x9F9', '\x9F8', '\x3', '\x2', '\x2', '\x2', '\x9F9', 
		'\x9FA', '\x3', '\x2', '\x2', '\x2', '\x9FA', '\xF7', '\x3', '\x2', '\x2', 
		'\x2', '\x9FB', '\x9FC', '\a', '\x235', '\x2', '\x2', '\x9FC', '\x9FD', 
		'\a', '\xD0', '\x2', '\x2', '\x9FD', '\x9FE', '\a', '\x24B', '\x2', '\x2', 
		'\x9FE', '\x9FF', '\x5', '\x3FA', '\x1FE', '\x2', '\x9FF', '\xA00', '\a', 
		'\x24C', '\x2', '\x2', '\xA00', '\xF9', '\x3', '\x2', '\x2', '\x2', '\xA01', 
		'\xA02', '\x5', '\x44', '#', '\x2', '\xA02', '\xA03', '\x5', '\xFC', '\x7F', 
		'\x2', '\xA03', '\xFB', '\x3', '\x2', '\x2', '\x2', '\xA04', '\xA05', 
		'\a', '\x174', '\x2', '\x2', '\xA05', '\xA07', '\a', '\x24B', '\x2', '\x2', 
		'\xA06', '\xA08', '\x5', '\xFE', '\x80', '\x2', '\xA07', '\xA06', '\x3', 
		'\x2', '\x2', '\x2', '\xA07', '\xA08', '\x3', '\x2', '\x2', '\x2', '\xA08', 
		'\xA0D', '\x3', '\x2', '\x2', '\x2', '\xA09', '\xA0B', '\x5', '\x3F8', 
		'\x1FD', '\x2', '\xA0A', '\xA0C', '\x5', '\x100', '\x81', '\x2', '\xA0B', 
		'\xA0A', '\x3', '\x2', '\x2', '\x2', '\xA0B', '\xA0C', '\x3', '\x2', '\x2', 
		'\x2', '\xA0C', '\xA0E', '\x3', '\x2', '\x2', '\x2', '\xA0D', '\xA09', 
		'\x3', '\x2', '\x2', '\x2', '\xA0D', '\xA0E', '\x3', '\x2', '\x2', '\x2', 
		'\xA0E', '\xA0F', '\x3', '\x2', '\x2', '\x2', '\xA0F', '\xA10', '\a', 
		'\x24C', '\x2', '\x2', '\xA10', '\xFD', '\x3', '\x2', '\x2', '\x2', '\xA11', 
		'\xA12', '\a', '\x17E', '\x2', '\x2', '\xA12', '\xA13', '\a', '\x33', 
		'\x2', '\x2', '\xA13', '\xA14', '\x5', '\x166', '\xB4', '\x2', '\xA14', 
		'\xFF', '\x3', '\x2', '\x2', '\x2', '\xA15', '\xA18', '\t', '\x14', '\x2', 
		'\x2', '\xA16', '\xA19', '\x5', '\x102', '\x82', '\x2', '\xA17', '\xA19', 
		'\x5', '\x104', '\x83', '\x2', '\xA18', '\xA16', '\x3', '\x2', '\x2', 
		'\x2', '\xA18', '\xA17', '\x3', '\x2', '\x2', '\x2', '\xA19', '\x101', 
		'\x3', '\x2', '\x2', '\x2', '\xA1A', '\xA1B', '\a', '&', '\x2', '\x2', 
		'\xA1B', '\xA1C', '\x5', '\x106', '\x84', '\x2', '\xA1C', '\xA1D', '\a', 
		'\x10', '\x2', '\x2', '\xA1D', '\xA1E', '\x5', '\x106', '\x84', '\x2', 
		'\xA1E', '\x103', '\x3', '\x2', '\x2', '\x2', '\xA1F', '\xA20', '\x5', 
		'\x106', '\x84', '\x2', '\xA20', '\x105', '\x3', '\x2', '\x2', '\x2', 
		'\xA21', '\xA22', '\a', '\x214', '\x2', '\x2', '\xA22', '\xA29', '\t', 
		'\x15', '\x2', '\x2', '\xA23', '\xA24', '\a', 'h', '\x2', '\x2', '\xA24', 
		'\xA29', '\a', '\x1BD', '\x2', '\x2', '\xA25', '\xA26', '\x5', '\x108', 
		'\x85', '\x2', '\xA26', '\xA27', '\t', '\x15', '\x2', '\x2', '\xA27', 
		'\xA29', '\x3', '\x2', '\x2', '\x2', '\xA28', '\xA21', '\x3', '\x2', '\x2', 
		'\x2', '\xA28', '\xA23', '\x3', '\x2', '\x2', '\x2', '\xA28', '\xA25', 
		'\x3', '\x2', '\x2', '\x2', '\xA29', '\x107', '\x3', '\x2', '\x2', '\x2', 
		'\xA2A', '\xA2B', '\x5', '\xA2', 'R', '\x2', '\xA2B', '\x109', '\x3', 
		'\x2', '\x2', '\x2', '\xA2C', '\xA2D', '\x5', '\x44', '#', '\x2', '\xA2D', 
		'\xA2E', '\a', '\x254', '\x2', '\x2', '\xA2E', '\xA2F', '\t', '\x16', 
		'\x2', '\x2', '\xA2F', '\x10B', '\x3', '\x2', '\x2', '\x2', '\xA30', '\xA31', 
		'\x5', '\x44', '#', '\x2', '\xA31', '\xA34', '\a', '\x254', '\x2', '\x2', 
		'\xA32', '\xA35', '\x5', '\x10E', '\x88', '\x2', '\xA33', '\xA35', '\x5', 
		'\x110', '\x89', '\x2', '\xA34', '\xA32', '\x3', '\x2', '\x2', '\x2', 
		'\xA34', '\xA33', '\x3', '\x2', '\x2', '\x2', '\xA35', '\x10D', '\x3', 
		'\x2', '\x2', '\x2', '\xA36', '\xA3D', '\a', '\x31', '\x2', '\x2', '\xA37', 
		'\xA38', '\a', '\x25C', '\x2', '\x2', '\xA38', '\xA3E', '\a', '\x63', 
		'\x2', '\x2', '\xA39', '\xA3A', '\x5', '\x112', '\x8A', '\x2', '\xA3A', 
		'\xA3B', '\a', '\x25C', '\x2', '\x2', '\xA3B', '\xA3C', '\t', '\x17', 
		'\x2', '\x2', '\xA3C', '\xA3E', '\x3', '\x2', '\x2', '\x2', '\xA3D', '\xA37', 
		'\x3', '\x2', '\x2', '\x2', '\xA3D', '\xA39', '\x3', '\x2', '\x2', '\x2', 
		'\xA3E', '\x10F', '\x3', '\x2', '\x2', '\x2', '\xA3F', '\xA40', '\a', 
		'\x32', '\x2', '\x2', '\xA40', '\xA41', '\x5', '\x112', '\x8A', '\x2', 
		'\xA41', '\x111', '\x3', '\x2', '\x2', '\x2', '\xA42', '\xA43', '\a', 
		'\x24B', '\x2', '\x2', '\xA43', '\xA44', '\x5', '\xA2', 'R', '\x2', '\xA44', 
		'\xA45', '\a', '\x24C', '\x2', '\x2', '\xA45', '\x113', '\x3', '\x2', 
		'\x2', '\x2', '\xA46', '\xA49', '\x5', '\xE8', 'u', '\x2', '\xA47', '\xA48', 
		'\a', '\x249', '\x2', '\x2', '\xA48', '\xA4A', '\x5', '\xE8', 'u', '\x2', 
		'\xA49', '\xA47', '\x3', '\x2', '\x2', '\x2', '\xA49', '\xA4A', '\x3', 
		'\x2', '\x2', '\x2', '\xA4A', '\x115', '\x3', '\x2', '\x2', '\x2', '\xA4B', 
		'\xA4C', '\a', '\x15E', '\x2', '\x2', '\xA4C', '\x117', '\x3', '\x2', 
		'\x2', '\x2', '\xA4D', '\xA4E', '\a', ':', '\x2', '\x2', '\xA4E', '\xA52', 
		'\a', '\x24B', '\x2', '\x2', '\xA4F', '\xA50', '\a', '\x136', '\x2', '\x2', 
		'\xA50', '\xA53', '\x5', '\x15C', '\xAF', '\x2', '\xA51', '\xA53', '\x5', 
		'\xA2', 'R', '\x2', '\xA52', '\xA4F', '\x3', '\x2', '\x2', '\x2', '\xA52', 
		'\xA51', '\x3', '\x2', '\x2', '\x2', '\xA53', '\xA54', '\x3', '\x2', '\x2', 
		'\x2', '\xA54', '\xA55', '\a', '\x15', '\x2', '\x2', '\xA55', '\xA56', 
		'\x5', '\x62', '\x32', '\x2', '\xA56', '\xA57', '\a', '\x24C', '\x2', 
		'\x2', '\xA57', '\x119', '\x3', '\x2', '\x2', '\x2', '\xA58', '\xA59', 
		'\a', 'j', '\x2', '\x2', '\xA59', '\xA5A', '\a', '\x24B', '\x2', '\x2', 
		'\xA5A', '\xA5B', '\x5', '\x3EE', '\x1F8', '\x2', '\xA5B', '\xA5C', '\a', 
		'\x24C', '\x2', '\x2', '\xA5C', '\x11B', '\x3', '\x2', '\x2', '\x2', '\xA5D', 
		'\xA60', '\a', '\x39', '\x2', '\x2', '\xA5E', '\xA61', '\x5', '\x124', 
		'\x93', '\x2', '\xA5F', '\xA61', '\x5', '\x11E', '\x90', '\x2', '\xA60', 
		'\xA5E', '\x3', '\x2', '\x2', '\x2', '\xA60', '\xA5F', '\x3', '\x2', '\x2', 
		'\x2', '\xA61', '\xA62', '\x3', '\x2', '\x2', '\x2', '\xA62', '\xA63', 
		'\a', '\x9C', '\x2', '\x2', '\xA63', '\x11D', '\x3', '\x2', '\x2', '\x2', 
		'\xA64', '\xA66', '\x5', '\xA2', 'R', '\x2', '\xA65', '\xA67', '\x5', 
		'\x120', '\x91', '\x2', '\xA66', '\xA65', '\x3', '\x2', '\x2', '\x2', 
		'\xA67', '\xA68', '\x3', '\x2', '\x2', '\x2', '\xA68', '\xA66', '\x3', 
		'\x2', '\x2', '\x2', '\xA68', '\xA69', '\x3', '\x2', '\x2', '\x2', '\xA69', 
		'\xA6B', '\x3', '\x2', '\x2', '\x2', '\xA6A', '\xA6C', '\x5', '\x122', 
		'\x92', '\x2', '\xA6B', '\xA6A', '\x3', '\x2', '\x2', '\x2', '\xA6B', 
		'\xA6C', '\x3', '\x2', '\x2', '\x2', '\xA6C', '\x11F', '\x3', '\x2', '\x2', 
		'\x2', '\xA6D', '\xA6E', '\a', '\x231', '\x2', '\x2', '\xA6E', '\xA6F', 
		'\x5', '\xA2', 'R', '\x2', '\xA6F', '\xA70', '\a', '\x202', '\x2', '\x2', 
		'\xA70', '\xA71', '\x5', '\xA2', 'R', '\x2', '\xA71', '\x121', '\x3', 
		'\x2', '\x2', '\x2', '\xA72', '\xA73', '\a', '\x97', '\x2', '\x2', '\xA73', 
		'\xA74', '\x5', '\xA2', 'R', '\x2', '\xA74', '\x123', '\x3', '\x2', '\x2', 
		'\x2', '\xA75', '\xA77', '\x5', '\x126', '\x94', '\x2', '\xA76', '\xA75', 
		'\x3', '\x2', '\x2', '\x2', '\xA77', '\xA78', '\x3', '\x2', '\x2', '\x2', 
		'\xA78', '\xA76', '\x3', '\x2', '\x2', '\x2', '\xA78', '\xA79', '\x3', 
		'\x2', '\x2', '\x2', '\xA79', '\xA7B', '\x3', '\x2', '\x2', '\x2', '\xA7A', 
		'\xA7C', '\x5', '\x122', '\x92', '\x2', '\xA7B', '\xA7A', '\x3', '\x2', 
		'\x2', '\x2', '\xA7B', '\xA7C', '\x3', '\x2', '\x2', '\x2', '\xA7C', '\x125', 
		'\x3', '\x2', '\x2', '\x2', '\xA7D', '\xA7E', '\a', '\x231', '\x2', '\x2', 
		'\xA7E', '\xA7F', '\x5', '\xA2', 'R', '\x2', '\xA7F', '\xA80', '\a', '\x202', 
		'\x2', '\x2', '\xA80', '\xA81', '\x5', '\xA2', 'R', '\x2', '\xA81', '\x127', 
		'\x3', '\x2', '\x2', '\x2', '\xA82', '\xA83', '\a', '\x194', '\x2', '\x2', 
		'\xA83', '\xA84', '\x5', '\xD2', 'j', '\x2', '\xA84', '\x129', '\x3', 
		'\x2', '\x2', '\x2', '\xA85', '\xA86', '\a', 'Y', '\x2', '\x2', '\xA86', 
		'\xA87', '\x5', '\xD2', 'j', '\x2', '\xA87', '\x12B', '\x3', '\x2', '\x2', 
		'\x2', '\xA88', '\xA89', '\a', '\x1F9', '\x2', '\x2', '\xA89', '\xA8A', 
		'\x5', 'Z', '.', '\x2', '\xA8A', '\x12D', '\x3', '\x2', '\x2', '\x2', 
		'\xA8B', '\xA8C', '\a', '\x20F', '\x2', '\x2', '\xA8C', '\xA8E', '\a', 
		'\x24B', '\x2', '\x2', '\xA8D', '\xA8F', '\x5', '\x130', '\x99', '\x2', 
		'\xA8E', '\xA8D', '\x3', '\x2', '\x2', '\x2', '\xA8E', '\xA8F', '\x3', 
		'\x2', '\x2', '\x2', '\xA8F', '\xA90', '\x3', '\x2', '\x2', '\x2', '\xA90', 
		'\xA91', '\x5', '\xA2', 'R', '\x2', '\xA91', '\xA92', '\a', '\x24C', '\x2', 
		'\x2', '\xA92', '\x12F', '\x3', '\x2', '\x2', '\x2', '\xA93', '\xA95', 
		'\t', '\x18', '\x2', '\x2', '\xA94', '\xA96', '\x5', '\xA2', 'R', '\x2', 
		'\xA95', '\xA94', '\x3', '\x2', '\x2', '\x2', '\xA95', '\xA96', '\x3', 
		'\x2', '\x2', '\x2', '\xA96', '\xA99', '\x3', '\x2', '\x2', '\x2', '\xA97', 
		'\xA99', '\x5', '\xA2', 'R', '\x2', '\xA98', '\xA93', '\x3', '\x2', '\x2', 
		'\x2', '\xA98', '\xA97', '\x3', '\x2', '\x2', '\x2', '\xA99', '\xA9A', 
		'\x3', '\x2', '\x2', '\x2', '\xA9A', '\xA9B', '\a', '\xC8', '\x2', '\x2', 
		'\xA9B', '\x131', '\x3', '\x2', '\x2', '\x2', '\xA9C', '\xA9D', '\a', 
		'v', '\x2', '\x2', '\xA9D', '\xA9E', '\a', '\x24B', '\x2', '\x2', '\xA9E', 
		'\xAA3', '\x5', '\xA2', 'R', '\x2', '\xA9F', '\xAA0', '\a', '\x24D', '\x2', 
		'\x2', '\xAA0', '\xAA2', '\x5', '\xA2', 'R', '\x2', '\xAA1', '\xA9F', 
		'\x3', '\x2', '\x2', '\x2', '\xAA2', '\xAA5', '\x3', '\x2', '\x2', '\x2', 
		'\xAA3', '\xAA1', '\x3', '\x2', '\x2', '\x2', '\xAA3', '\xAA4', '\x3', 
		'\x2', '\x2', '\x2', '\xAA4', '\xAA6', '\x3', '\x2', '\x2', '\x2', '\xAA5', 
		'\xAA3', '\x3', '\x2', '\x2', '\x2', '\xAA6', '\xAA7', '\a', '\x24C', 
		'\x2', '\x2', '\xAA7', '\x133', '\x3', '\x2', '\x2', '\x2', '\xAA8', '\xAA9', 
		'\a', '\xB2', '\x2', '\x2', '\xAA9', '\xAAA', '\a', '\x24B', '\x2', '\x2', 
		'\xAAA', '\xAAB', '\t', '\x19', '\x2', '\x2', '\xAAB', '\xAAC', '\x5', 
		'\x13E', '\xA0', '\x2', '\xAAC', '\xAAD', '\a', '\x24C', '\x2', '\x2', 
		'\xAAD', '\x135', '\x3', '\x2', '\x2', '\x2', '\xAAE', '\xAAF', '\t', 
		'\x1A', '\x2', '\x2', '\xAAF', '\xAB0', '\a', '\x24B', '\x2', '\x2', '\xAB0', 
		'\xAB1', '\x5', '\x138', '\x9D', '\x2', '\xAB1', '\xAB2', '\a', '\x24D', 
		'\x2', '\x2', '\xAB2', '\xAB5', '\x5', '\x13A', '\x9E', '\x2', '\xAB3', 
		'\xAB4', '\a', '\x24D', '\x2', '\x2', '\xAB4', '\xAB6', '\x5', '\x13C', 
		'\x9F', '\x2', '\xAB5', '\xAB3', '\x3', '\x2', '\x2', '\x2', '\xAB5', 
		'\xAB6', '\x3', '\x2', '\x2', '\x2', '\xAB6', '\xAB7', '\x3', '\x2', '\x2', 
		'\x2', '\xAB7', '\xAB8', '\a', '\x24C', '\x2', '\x2', '\xAB8', '\x137', 
		'\x3', '\x2', '\x2', '\x2', '\xAB9', '\xABA', '\x5', '\x16C', '\xB7', 
		'\x2', '\xABA', '\x139', '\x3', '\x2', '\x2', '\x2', '\xABB', '\xABC', 
		'\x5', '\xC8', '\x65', '\x2', '\xABC', '\x13B', '\x3', '\x2', '\x2', '\x2', 
		'\xABD', '\xABE', '\x5', '\xC8', '\x65', '\x2', '\xABE', '\x13D', '\x3', 
		'\x2', '\x2', '\x2', '\xABF', '\xAC1', '\a', '\xC8', '\x2', '\x2', '\xAC0', 
		'\xAC2', '\x5', '\x140', '\xA1', '\x2', '\xAC1', '\xAC0', '\x3', '\x2', 
		'\x2', '\x2', '\xAC1', '\xAC2', '\x3', '\x2', '\x2', '\x2', '\xAC2', '\xAC3', 
		'\x3', '\x2', '\x2', '\x2', '\xAC3', '\xAC4', '\x5', '\xA2', 'R', '\x2', 
		'\xAC4', '\x13F', '\x3', '\x2', '\x2', '\x2', '\xAC5', '\xAC6', '\a', 
		'o', '\x2', '\x2', '\xAC6', '\x141', '\x3', '\x2', '\x2', '\x2', '\xAC7', 
		'\xAD7', '\x5', '\x144', '\xA3', '\x2', '\xAC8', '\xAC9', '\x5', '\xC0', 
		'\x61', '\x2', '\xAC9', '\xACA', '\x5', '\x168', '\xB5', '\x2', '\xACA', 
		'\xAD0', '\x5', '\xC2', '\x62', '\x2', '\xACB', '\xACD', '\x5', '\xBA', 
		'^', '\x2', '\xACC', '\xACB', '\x3', '\x2', '\x2', '\x2', '\xACC', '\xACD', 
		'\x3', '\x2', '\x2', '\x2', '\xACD', '\xACE', '\x3', '\x2', '\x2', '\x2', 
		'\xACE', '\xAD1', '\x5', '\xBE', '`', '\x2', '\xACF', '\xAD1', '\x5', 
		'\x15A', '\xAE', '\x2', '\xAD0', '\xACC', '\x3', '\x2', '\x2', '\x2', 
		'\xAD0', '\xACF', '\x3', '\x2', '\x2', '\x2', '\xAD1', '\xAD4', '\x3', 
		'\x2', '\x2', '\x2', '\xAD2', '\xAD5', '\x5', '\x146', '\xA4', '\x2', 
		'\xAD3', '\xAD5', '\x5', '\x15C', '\xAF', '\x2', '\xAD4', '\xAD2', '\x3', 
		'\x2', '\x2', '\x2', '\xAD4', '\xAD3', '\x3', '\x2', '\x2', '\x2', '\xAD5', 
		'\xAD7', '\x3', '\x2', '\x2', '\x2', '\xAD6', '\xAC7', '\x3', '\x2', '\x2', 
		'\x2', '\xAD6', '\xAC8', '\x3', '\x2', '\x2', '\x2', '\xAD7', '\x143', 
		'\x3', '\x2', '\x2', '\x2', '\xAD8', '\xAD9', '\x5', '\x34E', '\x1A8', 
		'\x2', '\xAD9', '\xADA', '\a', '\x176', '\x2', '\x2', '\xADA', '\xADB', 
		'\x5', '\x34E', '\x1A8', '\x2', '\xADB', '\x145', '\x3', '\x2', '\x2', 
		'\x2', '\xADC', '\xAE6', '\a', '\x24B', '\x2', '\x2', '\xADD', '\xAE7', 
		'\x5', '\x166', '\xB4', '\x2', '\xADE', '\xAE3', '\x5', '\x146', '\xA4', 
		'\x2', '\xADF', '\xAE0', '\a', '\x24D', '\x2', '\x2', '\xAE0', '\xAE2', 
		'\x5', '\x146', '\xA4', '\x2', '\xAE1', '\xADF', '\x3', '\x2', '\x2', 
		'\x2', '\xAE2', '\xAE5', '\x3', '\x2', '\x2', '\x2', '\xAE3', '\xAE1', 
		'\x3', '\x2', '\x2', '\x2', '\xAE3', '\xAE4', '\x3', '\x2', '\x2', '\x2', 
		'\xAE4', '\xAE7', '\x3', '\x2', '\x2', '\x2', '\xAE5', '\xAE3', '\x3', 
		'\x2', '\x2', '\x2', '\xAE6', '\xADD', '\x3', '\x2', '\x2', '\x2', '\xAE6', 
		'\xADE', '\x3', '\x2', '\x2', '\x2', '\xAE7', '\xAE8', '\x3', '\x2', '\x2', 
		'\x2', '\xAE8', '\xAE9', '\a', '\x24C', '\x2', '\x2', '\xAE9', '\x147', 
		'\x3', '\x2', '\x2', '\x2', '\xAEA', '\xAEF', '\x5', '\x14A', '\xA6', 
		'\x2', '\xAEB', '\xAEF', '\x5', '\x14C', '\xA7', '\x2', '\xAEC', '\xAEF', 
		'\x5', '\x14E', '\xA8', '\x2', '\xAED', '\xAEF', '\x5', '\x150', '\xA9', 
		'\x2', '\xAEE', '\xAEA', '\x3', '\x2', '\x2', '\x2', '\xAEE', '\xAEB', 
		'\x3', '\x2', '\x2', '\x2', '\xAEE', '\xAEC', '\x3', '\x2', '\x2', '\x2', 
		'\xAEE', '\xAED', '\x3', '\x2', '\x2', '\x2', '\xAEF', '\x149', '\x3', 
		'\x2', '\x2', '\x2', '\xAF0', '\xAF2', '\a', '\x15A', '\x2', '\x2', '\xAF1', 
		'\xAF0', '\x3', '\x2', '\x2', '\x2', '\xAF1', '\xAF2', '\x3', '\x2', '\x2', 
		'\x2', '\xAF2', '\xAF3', '\x3', '\x2', '\x2', '\x2', '\xAF3', '\xAF4', 
		'\a', '\x1F1', '\x2', '\x2', '\xAF4', '\xAF5', '\a', '\x162', '\x2', '\x2', 
		'\xAF5', '\xAF6', '\x5', '\xC8', '\x65', '\x2', '\xAF6', '\x14B', '\x3', 
		'\x2', '\x2', '\x2', '\xAF7', '\xAF9', '\a', '\x15A', '\x2', '\x2', '\xAF8', 
		'\xAF7', '\x3', '\x2', '\x2', '\x2', '\xAF8', '\xAF9', '\x3', '\x2', '\x2', 
		'\x2', '\xAF9', '\xAFA', '\x3', '\x2', '\x2', '\x2', '\xAFA', '\xAFB', 
		'\a', '\x127', '\x2', '\x2', '\xAFB', '\xAFC', '\a', '\x162', '\x2', '\x2', 
		'\xAFC', '\xAFD', '\x5', '\xC8', '\x65', '\x2', '\xAFD', '\x14D', '\x3', 
		'\x2', '\x2', '\x2', '\xAFE', '\xB00', '\a', '\xF6', '\x2', '\x2', '\xAFF', 
		'\xB01', '\a', '\x15A', '\x2', '\x2', '\xB00', '\xAFF', '\x3', '\x2', 
		'\x2', '\x2', '\xB00', '\xB01', '\x3', '\x2', '\x2', '\x2', '\xB01', '\xB02', 
		'\x3', '\x2', '\x2', '\x2', '\xB02', '\xB03', '\a', '\x3', '\x2', '\x2', 
		'\xB03', '\xB04', '\a', '\x1D8', '\x2', '\x2', '\xB04', '\x14F', '\x3', 
		'\x2', '\x2', '\x2', '\xB05', '\xB07', '\a', '\xF6', '\x2', '\x2', '\xB06', 
		'\xB08', '\a', '\x15A', '\x2', '\x2', '\xB07', '\xB06', '\x3', '\x2', 
		'\x2', '\x2', '\xB07', '\xB08', '\x3', '\x2', '\x2', '\x2', '\xB08', '\xB09', 
		'\x3', '\x2', '\x2', '\x2', '\xB09', '\xB0A', '\a', '\x99', '\x2', '\x2', 
		'\xB0A', '\x151', '\x3', '\x2', '\x2', '\x2', '\xB0B', '\xB0C', '\t', 
		'\x1B', '\x2', '\x2', '\xB0C', '\x153', '\x3', '\x2', '\x2', '\x2', '\xB0D', 
		'\xB0E', '\a', '\xA2', '\x2', '\x2', '\xB0E', '\xB0F', '\x5', '\xA2', 
		'R', '\x2', '\xB0F', '\x155', '\x3', '\x2', '\x2', '\x2', '\xB10', '\xB11', 
		'\a', '&', '\x2', '\x2', '\xB11', '\x157', '\x3', '\x2', '\x2', '\x2', 
		'\xB12', '\xB13', '\a', '\x10', '\x2', '\x2', '\xB13', '\x159', '\x3', 
		'\x2', '\x2', '\x2', '\xB14', '\xB15', '\a', '\x252', '\x2', '\x2', '\xB15', 
		'\xB24', '\a', '\x251', '\x2', '\x2', '\xB16', '\xB17', '\a', '\x25A', 
		'\x2', '\x2', '\xB17', '\xB24', '\a', '\x253', '\x2', '\x2', '\xB18', 
		'\xB19', '\a', '\x25E', '\x2', '\x2', '\xB19', '\xB24', '\a', '\x253', 
		'\x2', '\x2', '\xB1A', '\xB1B', '\a', '\x251', '\x2', '\x2', '\xB1B', 
		'\xB24', '\a', '\x253', '\x2', '\x2', '\xB1C', '\xB1D', '\a', '\x252', 
		'\x2', '\x2', '\xB1D', '\xB24', '\a', '\x253', '\x2', '\x2', '\xB1E', 
		'\xB24', '\a', '\x253', '\x2', '\x2', '\xB1F', '\xB20', '\a', '\x25D', 
		'\x2', '\x2', '\xB20', '\xB24', '\a', '\x253', '\x2', '\x2', '\xB21', 
		'\xB24', '\a', '\x251', '\x2', '\x2', '\xB22', '\xB24', '\a', '\x252', 
		'\x2', '\x2', '\xB23', '\xB14', '\x3', '\x2', '\x2', '\x2', '\xB23', '\xB16', 
		'\x3', '\x2', '\x2', '\x2', '\xB23', '\xB18', '\x3', '\x2', '\x2', '\x2', 
		'\xB23', '\xB1A', '\x3', '\x2', '\x2', '\x2', '\xB23', '\xB1C', '\x3', 
		'\x2', '\x2', '\x2', '\xB23', '\xB1E', '\x3', '\x2', '\x2', '\x2', '\xB23', 
		'\xB1F', '\x3', '\x2', '\x2', '\x2', '\xB23', '\xB21', '\x3', '\x2', '\x2', 
		'\x2', '\xB23', '\xB22', '\x3', '\x2', '\x2', '\x2', '\xB24', '\x15B', 
		'\x3', '\x2', '\x2', '\x2', '\xB25', '\xB26', '\a', '\x24B', '\x2', '\x2', 
		'\xB26', '\xB27', '\x5', '\x3EE', '\x1F8', '\x2', '\xB27', '\xB28', '\a', 
		'\x24C', '\x2', '\x2', '\xB28', '\x15D', '\x3', '\x2', '\x2', '\x2', '\xB29', 
		'\xB2A', '\a', '\x15', '\x2', '\x2', '\xB2A', '\xB2B', '\a', '\x24B', 
		'\x2', '\x2', '\xB2B', '\xB2C', '\x5', '\x3EE', '\x1F8', '\x2', '\xB2C', 
		'\xB2D', '\a', '\x24C', '\x2', '\x2', '\xB2D', '\x15F', '\x3', '\x2', 
		'\x2', '\x2', '\xB2E', '\xB2F', '\a', '\x201', '\x2', '\x2', '\xB2F', 
		'\xB30', '\a', '\x24B', '\x2', '\x2', '\xB30', '\xB31', '\x5', '\x3EE', 
		'\x1F8', '\x2', '\xB31', '\xB32', '\a', '\x24C', '\x2', '\x2', '\xB32', 
		'\xB3C', '\x3', '\x2', '\x2', '\x2', '\xB33', '\xB34', '\a', '\x1FB', 
		'\x2', '\x2', '\xB34', '\xB37', '\a', '\x24B', '\x2', '\x2', '\xB35', 
		'\xB38', '\x5', '\x3EE', '\x1F8', '\x2', '\xB36', '\xB38', '\x5', '\xA2', 
		'R', '\x2', '\xB37', '\xB35', '\x3', '\x2', '\x2', '\x2', '\xB37', '\xB36', 
		'\x3', '\x2', '\x2', '\x2', '\xB38', '\xB39', '\x3', '\x2', '\x2', '\x2', 
		'\xB39', '\xB3A', '\a', '\x24C', '\x2', '\x2', '\xB3A', '\xB3C', '\x3', 
		'\x2', '\x2', '\x2', '\xB3B', '\xB2E', '\x3', '\x2', '\x2', '\x2', '\xB3B', 
		'\xB33', '\x3', '\x2', '\x2', '\x2', '\xB3C', '\x161', '\x3', '\x2', '\x2', 
		'\x2', '\xB3D', '\xB42', '\x5', '\x164', '\xB3', '\x2', '\xB3E', '\xB3F', 
		'\a', '\x24D', '\x2', '\x2', '\xB3F', '\xB41', '\x5', '\x164', '\xB3', 
		'\x2', '\xB40', '\xB3E', '\x3', '\x2', '\x2', '\x2', '\xB41', '\xB44', 
		'\x3', '\x2', '\x2', '\x2', '\xB42', '\xB40', '\x3', '\x2', '\x2', '\x2', 
		'\xB42', '\xB43', '\x3', '\x2', '\x2', '\x2', '\xB43', '\x163', '\x3', 
		'\x2', '\x2', '\x2', '\xB44', '\xB42', '\x3', '\x2', '\x2', '\x2', '\xB45', 
		'\xB4B', '\x5', '\x16C', '\xB7', '\x2', '\xB46', '\xB47', '\a', '\x24B', 
		'\x2', '\x2', '\xB47', '\xB48', '\x5', '\x162', '\xB2', '\x2', '\xB48', 
		'\xB49', '\a', '\x24C', '\x2', '\x2', '\xB49', '\xB4B', '\x3', '\x2', 
		'\x2', '\x2', '\xB4A', '\xB45', '\x3', '\x2', '\x2', '\x2', '\xB4A', '\xB46', 
		'\x3', '\x2', '\x2', '\x2', '\xB4B', '\x165', '\x3', '\x2', '\x2', '\x2', 
		'\xB4C', '\xB51', '\x5', '\x16C', '\xB7', '\x2', '\xB4D', '\xB4E', '\a', 
		'\x24D', '\x2', '\x2', '\xB4E', '\xB50', '\x5', '\x16C', '\xB7', '\x2', 
		'\xB4F', '\xB4D', '\x3', '\x2', '\x2', '\x2', '\xB50', '\xB53', '\x3', 
		'\x2', '\x2', '\x2', '\xB51', '\xB4F', '\x3', '\x2', '\x2', '\x2', '\xB51', 
		'\xB52', '\x3', '\x2', '\x2', '\x2', '\xB52', '\x167', '\x3', '\x2', '\x2', 
		'\x2', '\xB53', '\xB51', '\x3', '\x2', '\x2', '\x2', '\xB54', '\xB57', 
		'\x5', '\x16C', '\xB7', '\x2', '\xB55', '\xB56', '\a', '\x24D', '\x2', 
		'\x2', '\xB56', '\xB58', '\x5', '\x16C', '\xB7', '\x2', '\xB57', '\xB55', 
		'\x3', '\x2', '\x2', '\x2', '\xB58', '\xB59', '\x3', '\x2', '\x2', '\x2', 
		'\xB59', '\xB57', '\x3', '\x2', '\x2', '\x2', '\xB59', '\xB5A', '\x3', 
		'\x2', '\x2', '\x2', '\xB5A', '\x169', '\x3', '\x2', '\x2', '\x2', '\xB5B', 
		'\xB5C', '\a', 'y', '\x2', '\x2', '\xB5C', '\x16B', '\x3', '\x2', '\x2', 
		'\x2', '\xB5D', '\xB5F', '\x5', '\x170', '\xB9', '\x2', '\xB5E', '\xB5D', 
		'\x3', '\x2', '\x2', '\x2', '\xB5E', '\xB5F', '\x3', '\x2', '\x2', '\x2', 
		'\xB5F', '\xB62', '\x3', '\x2', '\x2', '\x2', '\xB60', '\xB63', '\x5', 
		'\xA2', 'R', '\x2', '\xB61', '\xB63', '\x5', '\x16A', '\xB6', '\x2', '\xB62', 
		'\xB60', '\x3', '\x2', '\x2', '\x2', '\xB62', '\xB61', '\x3', '\x2', '\x2', 
		'\x2', '\xB63', '\xB65', '\x3', '\x2', '\x2', '\x2', '\xB64', '\xB66', 
		'\x5', '\x172', '\xBA', '\x2', '\xB65', '\xB64', '\x3', '\x2', '\x2', 
		'\x2', '\xB65', '\xB66', '\x3', '\x2', '\x2', '\x2', '\xB66', '\x16D', 
		'\x3', '\x2', '\x2', '\x2', '\xB67', '\xB68', '\a', '\x23C', '\x2', '\x2', 
		'\xB68', '\xB69', '\a', '\x24B', '\x2', '\x2', '\xB69', '\xB6B', '\x5', 
		'\xA2', 'R', '\x2', '\xB6A', '\xB6C', '\x5', '\x3FC', '\x1FF', '\x2', 
		'\xB6B', '\xB6A', '\x3', '\x2', '\x2', '\x2', '\xB6B', '\xB6C', '\x3', 
		'\x2', '\x2', '\x2', '\xB6C', '\xB6D', '\x3', '\x2', '\x2', '\x2', '\xB6D', 
		'\xB6E', '\a', '\x24C', '\x2', '\x2', '\xB6E', '\x16F', '\x3', '\x2', 
		'\x2', '\x2', '\xB6F', '\xB70', '\x5', 'P', ')', '\x2', '\xB70', '\xB71', 
		'\a', '\x247', '\x2', '\x2', '\xB71', '\x171', '\x3', '\x2', '\x2', '\x2', 
		'\xB72', '\xB74', '\a', '\x15', '\x2', '\x2', '\xB73', '\xB72', '\x3', 
		'\x2', '\x2', '\x2', '\xB73', '\xB74', '\x3', '\x2', '\x2', '\x2', '\xB74', 
		'\xB75', '\x3', '\x2', '\x2', '\x2', '\xB75', '\xB76', '\x5', '^', '\x30', 
		'\x2', '\xB76', '\x173', '\x3', '\x2', '\x2', '\x2', '\xB77', '\xB7C', 
		'\x5', '\x44', '#', '\x2', '\xB78', '\xB79', '\a', '\x24D', '\x2', '\x2', 
		'\xB79', '\xB7B', '\x5', '\x44', '#', '\x2', '\xB7A', '\xB78', '\x3', 
		'\x2', '\x2', '\x2', '\xB7B', '\xB7E', '\x3', '\x2', '\x2', '\x2', '\xB7C', 
		'\xB7A', '\x3', '\x2', '\x2', '\x2', '\xB7C', '\xB7D', '\x3', '\x2', '\x2', 
		'\x2', '\xB7D', '\x175', '\x3', '\x2', '\x2', '\x2', '\xB7E', '\xB7C', 
		'\x3', '\x2', '\x2', '\x2', '\xB7F', '\xB84', '\x5', '\x178', '\xBD', 
		'\x2', '\xB80', '\xB81', '\a', '\x24D', '\x2', '\x2', '\xB81', '\xB83', 
		'\x5', '\x178', '\xBD', '\x2', '\xB82', '\xB80', '\x3', '\x2', '\x2', 
		'\x2', '\xB83', '\xB86', '\x3', '\x2', '\x2', '\x2', '\xB84', '\xB82', 
		'\x3', '\x2', '\x2', '\x2', '\xB84', '\xB85', '\x3', '\x2', '\x2', '\x2', 
		'\xB85', '\x177', '\x3', '\x2', '\x2', '\x2', '\xB86', '\xB84', '\x3', 
		'\x2', '\x2', '\x2', '\xB87', '\xB88', '\x5', '^', '\x30', '\x2', '\xB88', 
		'\x179', '\x3', '\x2', '\x2', '\x2', '\xB89', '\xB8A', '\x5', 'J', '&', 
		'\x2', '\xB8A', '\x17B', '\x3', '\x2', '\x2', '\x2', '\xB8B', '\xB8D', 
		'\a', '\x64', '\x2', '\x2', '\xB8C', '\xB8E', '\x5', '\x17E', '\xC0', 
		'\x2', '\xB8D', '\xB8C', '\x3', '\x2', '\x2', '\x2', '\xB8D', '\xB8E', 
		'\x3', '\x2', '\x2', '\x2', '\xB8E', '\xB96', '\x3', '\x2', '\x2', '\x2', 
		'\xB8F', '\xB97', '\x5', '\x22A', '\x116', '\x2', '\xB90', '\xB97', '\x5', 
		'\x338', '\x19D', '\x2', '\xB91', '\xB97', '\x5', '\x308', '\x185', '\x2', 
		'\xB92', '\xB97', '\x5', '\x1D8', '\xED', '\x2', '\xB93', '\xB97', '\x5', 
		'\x180', '\xC1', '\x2', '\xB94', '\xB97', '\x5', '\x1A0', '\xD1', '\x2', 
		'\xB95', '\xB97', '\x5', '\x1D4', '\xEB', '\x2', '\xB96', '\xB8F', '\x3', 
		'\x2', '\x2', '\x2', '\xB96', '\xB90', '\x3', '\x2', '\x2', '\x2', '\xB96', 
		'\xB91', '\x3', '\x2', '\x2', '\x2', '\xB96', '\xB92', '\x3', '\x2', '\x2', 
		'\x2', '\xB96', '\xB93', '\x3', '\x2', '\x2', '\x2', '\xB96', '\xB94', 
		'\x3', '\x2', '\x2', '\x2', '\xB96', '\xB95', '\x3', '\x2', '\x2', '\x2', 
		'\xB97', '\x17D', '\x3', '\x2', '\x2', '\x2', '\xB98', '\xB99', '\a', 
		'\x16E', '\x2', '\x2', '\xB99', '\xB9A', '\a', '\x1AF', '\x2', '\x2', 
		'\xB9A', '\x17F', '\x3', '\x2', '\x2', '\x2', '\xB9B', '\xB9C', '\a', 
		'\x222', '\x2', '\x2', '\xB9C', '\xB9D', '\x5', '\\', '/', '\x2', '\xB9D', 
		'\xB9E', '\a', '\xD9', '\x2', '\x2', '\xB9E', '\xBA2', '\x5', '\x182', 
		'\xC2', '\x2', '\xB9F', '\xBA1', '\x5', '\x18C', '\xC7', '\x2', '\xBA0', 
		'\xB9F', '\x3', '\x2', '\x2', '\x2', '\xBA1', '\xBA4', '\x3', '\x2', '\x2', 
		'\x2', '\xBA2', '\xBA0', '\x3', '\x2', '\x2', '\x2', '\xBA2', '\xBA3', 
		'\x3', '\x2', '\x2', '\x2', '\xBA3', '\x181', '\x3', '\x2', '\x2', '\x2', 
		'\xBA4', '\xBA2', '\x3', '\x2', '\x2', '\x2', '\xBA5', '\xBAA', '\x5', 
		'\x184', '\xC3', '\x2', '\xBA6', '\xBAA', '\x5', '\x186', '\xC4', '\x2', 
		'\xBA7', '\xBAA', '\x5', '\x188', '\xC5', '\x2', '\xBA8', '\xBAA', '\x5', 
		'\x18A', '\xC6', '\x2', '\xBA9', '\xBA5', '\x3', '\x2', '\x2', '\x2', 
		'\xBA9', '\xBA6', '\x3', '\x2', '\x2', '\x2', '\xBA9', '\xBA7', '\x3', 
		'\x2', '\x2', '\x2', '\xBA9', '\xBA8', '\x3', '\x2', '\x2', '\x2', '\xBAA', 
		'\x183', '\x3', '\x2', '\x2', '\x2', '\xBAB', '\xBAF', '\a', '\x33', '\x2', 
		'\x2', '\xBAC', '\xBB0', '\x5', '\\', '/', '\x2', '\xBAD', '\xBAE', '\a', 
		'\x226', '\x2', '\x2', '\xBAE', '\xBB0', '\x5', ',', '\x17', '\x2', '\xBAF', 
		'\xBAC', '\x3', '\x2', '\x2', '\x2', '\xBAF', '\xBAD', '\x3', '\x2', '\x2', 
		'\x2', '\xBB0', '\x185', '\x3', '\x2', '\x2', '\x2', '\xBB1', '\xBB4', 
		'\a', '\xB1', '\x2', '\x2', '\xBB2', '\xBB3', '\a', '\x15', '\x2', '\x2', 
		'\xBB3', '\xBB5', '\x5', ',', '\x17', '\x2', '\xBB4', '\xBB2', '\x3', 
		'\x2', '\x2', '\x2', '\xBB4', '\xBB5', '\x3', '\x2', '\x2', '\x2', '\xBB5', 
		'\x187', '\x3', '\x2', '\x2', '\x2', '\xBB6', '\xBB9', '\a', '\xCD', '\x2', 
		'\x2', '\xBB7', '\xBB8', '\a', '\x15', '\x2', '\x2', '\xBB8', '\xBBA', 
		'\x5', ',', '\x17', '\x2', '\xBB9', '\xBB7', '\x3', '\x2', '\x2', '\x2', 
		'\xBB9', '\xBBA', '\x3', '\x2', '\x2', '\x2', '\xBBA', '\x189', '\x3', 
		'\x2', '\x2', '\x2', '\xBBB', '\xBBC', '\a', '\x142', '\x2', '\x2', '\xBBC', 
		'\xBBD', '\a', '\x1C', '\x2', '\x2', '\xBBD', '\x18B', '\x3', '\x2', '\x2', 
		'\x2', '\xBBE', '\xBC8', '\x5', '\x18E', '\xC8', '\x2', '\xBBF', '\xBC8', 
		'\x5', '\x190', '\xC9', '\x2', '\xBC0', '\xBC8', '\x5', '\x192', '\xCA', 
		'\x2', '\xBC1', '\xBC8', '\x5', '\x194', '\xCB', '\x2', '\xBC2', '\xBC8', 
		'\x5', '\x196', '\xCC', '\x2', '\xBC3', '\xBC8', '\x5', '\x198', '\xCD', 
		'\x2', '\xBC4', '\xBC8', '\x5', '\x19A', '\xCE', '\x2', '\xBC5', '\xBC8', 
		'\x5', '\x19C', '\xCF', '\x2', '\xBC6', '\xBC8', '\x5', '\x19E', '\xD0', 
		'\x2', '\xBC7', '\xBBE', '\x3', '\x2', '\x2', '\x2', '\xBC7', '\xBBF', 
		'\x3', '\x2', '\x2', '\x2', '\xBC7', '\xBC0', '\x3', '\x2', '\x2', '\x2', 
		'\xBC7', '\xBC1', '\x3', '\x2', '\x2', '\x2', '\xBC7', '\xBC2', '\x3', 
		'\x2', '\x2', '\x2', '\xBC7', '\xBC3', '\x3', '\x2', '\x2', '\x2', '\xBC7', 
		'\xBC4', '\x3', '\x2', '\x2', '\x2', '\xBC7', '\xBC5', '\x3', '\x2', '\x2', 
		'\x2', '\xBC7', '\xBC6', '\x3', '\x2', '\x2', '\x2', '\xBC8', '\x18D', 
		'\x3', '\x2', '\x2', '\x2', '\xBC9', '\xBCA', '\a', 'y', '\x2', '\x2', 
		'\xBCA', '\xBCB', '\a', 'H', '\x2', '\x2', '\xBCB', '\xBCC', '\x5', '\\', 
		'/', '\x2', '\xBCC', '\x18F', '\x3', '\x2', '\x2', '\x2', '\xBCD', '\xBCE', 
		'\a', 'y', '\x2', '\x2', '\xBCE', '\xBCF', '\a', '\x1FD', '\x2', '\x2', 
		'\xBCF', '\xBD0', '\x5', '\\', '/', '\x2', '\xBD0', '\x191', '\x3', '\x2', 
		'\x2', '\x2', '\xBD1', '\xBD3', '\a', '\x110', '\x2', '\x2', '\xBD2', 
		'\xBD1', '\x3', '\x2', '\x2', '\x2', '\xBD2', '\xBD3', '\x3', '\x2', '\x2', 
		'\x2', '\xBD3', '\xBD4', '\x3', '\x2', '\x2', '\x2', '\xBD4', '\xBD5', 
		'\a', '\x1FF', '\x2', '\x2', '\xBD5', '\xBD6', '\a', '\x1FD', '\x2', '\x2', 
		'\xBD6', '\xBD7', '\x5', '\\', '/', '\x2', '\xBD7', '\x193', '\x3', '\x2', 
		'\x2', '\x2', '\xBD8', '\xBDB', '\a', '\x19B', '\x2', '\x2', '\xBD9', 
		'\xBDC', '\a', '\x219', '\x2', '\x2', '\xBDA', '\xBDC', '\x5', '\x39E', 
		'\x1D0', '\x2', '\xBDB', '\xBD9', '\x3', '\x2', '\x2', '\x2', '\xBDB', 
		'\xBDA', '\x3', '\x2', '\x2', '\x2', '\xBDC', '\xBDD', '\x3', '\x2', '\x2', 
		'\x2', '\xBDD', '\xBDE', '\a', '\x166', '\x2', '\x2', '\xBDE', '\xBDF', 
		'\x5', '\\', '/', '\x2', '\xBDF', '\x195', '\x3', '\x2', '\x2', '\x2', 
		'\xBE0', '\xBE1', '\a', '\x197', '\x2', '\x2', '\xBE1', '\xBE2', '\x5', 
		'\\', '/', '\x2', '\xBE2', '\x197', '\x3', '\x2', '\x2', '\x2', '\xBE3', 
		'\xBE4', '\a', '\x181', '\x2', '\x2', '\xBE4', '\xBE5', '\a', '\xAD', 
		'\x2', '\x2', '\xBE5', '\x199', '\x3', '\x2', '\x2', '\x2', '\xBE6', '\xBE7', 
		'\a', '\x4', '\x2', '\x2', '\xBE7', '\xBE8', '\t', '\x1C', '\x2', '\x2', 
		'\xBE8', '\x19B', '\x3', '\x2', '\x2', '\x2', '\xBE9', '\xBEA', '\a', 
		'\x9A', '\x2', '\x2', '\xBEA', '\xBEB', '\a', '\x95', '\x2', '\x2', '\xBEB', 
		'\x19D', '\x3', '\x2', '\x2', '\x2', '\xBEC', '\xBED', '\a', '^', '\x2', 
		'\x2', '\xBED', '\xBEE', '\a', '\x253', '\x2', '\x2', '\xBEE', '\xBEF', 
		'\t', '\x1D', '\x2', '\x2', '\xBEF', '\x19F', '\x3', '\x2', '\x2', '\x2', 
		'\xBF0', '\xBF2', '\t', '\x1E', '\x2', '\x2', '\xBF1', '\xBF0', '\x3', 
		'\x2', '\x2', '\x2', '\xBF1', '\xBF2', '\x3', '\x2', '\x2', '\x2', '\xBF2', 
		'\xBF3', '\x3', '\x2', '\x2', '\x2', '\xBF3', '\xBF4', '\a', '\xE2', '\x2', 
		'\x2', '\xBF4', '\xBF5', '\x5', '\x46', '$', '\x2', '\xBF5', '\xBF9', 
		'\a', '\x166', '\x2', '\x2', '\xBF6', '\xBFA', '\x5', '\x1A2', '\xD2', 
		'\x2', '\xBF7', '\xBFA', '\x5', '\x1A4', '\xD3', '\x2', '\xBF8', '\xBFA', 
		'\x5', '\x1A8', '\xD5', '\x2', '\xBF9', '\xBF6', '\x3', '\x2', '\x2', 
		'\x2', '\xBF9', '\xBF7', '\x3', '\x2', '\x2', '\x2', '\xBF9', '\xBF8', 
		'\x3', '\x2', '\x2', '\x2', '\xBFA', '\xBFC', '\x3', '\x2', '\x2', '\x2', 
		'\xBFB', '\xBFD', '\t', '\x1F', '\x2', '\x2', '\xBFC', '\xBFB', '\x3', 
		'\x2', '\x2', '\x2', '\xBFC', '\xBFD', '\x3', '\x2', '\x2', '\x2', '\xBFD', 
		'\xC00', '\x3', '\x2', '\x2', '\x2', '\xBFE', '\xBFF', '\t', ' ', '\x2', 
		'\x2', '\xBFF', '\xC01', '\a', '\xF4', '\x2', '\x2', '\xC00', '\xBFE', 
		'\x3', '\x2', '\x2', '\x2', '\xC00', '\xC01', '\x3', '\x2', '\x2', '\x2', 
		'\xC01', '\x1A1', '\x3', '\x2', '\x2', '\x2', '\xC02', '\xC03', '\a', 
		'\x45', '\x2', '\x2', '\xC03', '\xC07', '\x5', '\x46', '$', '\x2', '\xC04', 
		'\xC06', '\x5', '\x1C4', '\xE3', '\x2', '\xC05', '\xC04', '\x3', '\x2', 
		'\x2', '\x2', '\xC06', '\xC09', '\x3', '\x2', '\x2', '\x2', '\xC07', '\xC05', 
		'\x3', '\x2', '\x2', '\x2', '\xC07', '\xC08', '\x3', '\x2', '\x2', '\x2', 
		'\xC08', '\x1A3', '\x3', '\x2', '\x2', '\x2', '\xC09', '\xC07', '\x3', 
		'\x2', '\x2', '\x2', '\xC0A', '\xC0C', '\x5', '\x46', '$', '\x2', '\xC0B', 
		'\xC0D', '\x5', '\x4CC', '\x267', '\x2', '\xC0C', '\xC0B', '\x3', '\x2', 
		'\x2', '\x2', '\xC0C', '\xC0D', '\x3', '\x2', '\x2', '\x2', '\xC0D', '\xC0E', 
		'\x3', '\x2', '\x2', '\x2', '\xC0E', '\xC0F', '\a', '\x24B', '\x2', '\x2', 
		'\xC0F', '\xC14', '\x5', '\x1A6', '\xD4', '\x2', '\xC10', '\xC11', '\a', 
		'\x24D', '\x2', '\x2', '\xC11', '\xC13', '\x5', '\x1A6', '\xD4', '\x2', 
		'\xC12', '\xC10', '\x3', '\x2', '\x2', '\x2', '\xC13', '\xC16', '\x3', 
		'\x2', '\x2', '\x2', '\xC14', '\xC12', '\x3', '\x2', '\x2', '\x2', '\xC14', 
		'\xC15', '\x3', '\x2', '\x2', '\x2', '\xC15', '\xC17', '\x3', '\x2', '\x2', 
		'\x2', '\xC16', '\xC14', '\x3', '\x2', '\x2', '\x2', '\xC17', '\xC19', 
		'\a', '\x24C', '\x2', '\x2', '\xC18', '\xC1A', '\x5', '\x1AE', '\xD8', 
		'\x2', '\xC19', '\xC18', '\x3', '\x2', '\x2', '\x2', '\xC19', '\xC1A', 
		'\x3', '\x2', '\x2', '\x2', '\xC1A', '\x1A5', '\x3', '\x2', '\x2', '\x2', 
		'\xC1B', '\xC1D', '\x5', '\xA2', 'R', '\x2', '\xC1C', '\xC1E', '\t', '!', 
		'\x2', '\x2', '\xC1D', '\xC1C', '\x3', '\x2', '\x2', '\x2', '\xC1D', '\xC1E', 
		'\x3', '\x2', '\x2', '\x2', '\xC1E', '\x1A7', '\x3', '\x2', '\x2', '\x2', 
		'\xC1F', '\xC20', '\x5', '\x46', '$', '\x2', '\xC20', '\xC21', '\a', '\x24B', 
		'\x2', '\x2', '\xC21', '\xC22', '\x5', '\x1AA', '\xD6', '\x2', '\xC22', 
		'\xC23', '\a', '\x24C', '\x2', '\x2', '\xC23', '\xC24', '\a', '\xC8', 
		'\x2', '\x2', '\xC24', '\xC29', '\x5', '\x1AC', '\xD7', '\x2', '\xC25', 
		'\xC26', '\a', '\x24D', '\x2', '\x2', '\xC26', '\xC28', '\x5', '\x1AC', 
		'\xD7', '\x2', '\xC27', '\xC25', '\x3', '\x2', '\x2', '\x2', '\xC28', 
		'\xC2B', '\x3', '\x2', '\x2', '\x2', '\xC29', '\xC27', '\x3', '\x2', '\x2', 
		'\x2', '\xC29', '\xC2A', '\x3', '\x2', '\x2', '\x2', '\xC2A', '\xC2C', 
		'\x3', '\x2', '\x2', '\x2', '\xC2B', '\xC29', '\x3', '\x2', '\x2', '\x2', 
		'\xC2C', '\xC2E', '\x5', '\x424', '\x213', '\x2', '\xC2D', '\xC2F', '\x5', 
		'\x1B2', '\xDA', '\x2', '\xC2E', '\xC2D', '\x3', '\x2', '\x2', '\x2', 
		'\xC2E', '\xC2F', '\x3', '\x2', '\x2', '\x2', '\xC2F', '\xC33', '\x3', 
		'\x2', '\x2', '\x2', '\xC30', '\xC32', '\x5', '\x1C4', '\xE3', '\x2', 
		'\xC31', '\xC30', '\x3', '\x2', '\x2', '\x2', '\xC32', '\xC35', '\x3', 
		'\x2', '\x2', '\x2', '\xC33', '\xC31', '\x3', '\x2', '\x2', '\x2', '\xC33', 
		'\xC34', '\x3', '\x2', '\x2', '\x2', '\xC34', '\x1A9', '\x3', '\x2', '\x2', 
		'\x2', '\xC35', '\xC33', '\x3', '\x2', '\x2', '\x2', '\xC36', '\xC38', 
		'\x5', '\x46', '$', '\x2', '\xC37', '\xC39', '\t', '!', '\x2', '\x2', 
		'\xC38', '\xC37', '\x3', '\x2', '\x2', '\x2', '\xC38', '\xC39', '\x3', 
		'\x2', '\x2', '\x2', '\xC39', '\x1AB', '\x3', '\x2', '\x2', '\x2', '\xC3A', 
		'\xC3C', '\x5', '\x46', '$', '\x2', '\xC3B', '\xC3D', '\x5', '\x4CC', 
		'\x267', '\x2', '\xC3C', '\xC3B', '\x3', '\x2', '\x2', '\x2', '\xC3C', 
		'\xC3D', '\x3', '\x2', '\x2', '\x2', '\xC3D', '\x1AD', '\x3', '\x2', '\x2', 
		'\x2', '\xC3E', '\xC42', '\x5', '\x1B0', '\xD9', '\x2', '\xC3F', '\xC42', 
		'\x5', '\x1B2', '\xDA', '\x2', '\xC40', '\xC42', '\x5', '\x1C4', '\xE3', 
		'\x2', '\xC41', '\xC3E', '\x3', '\x2', '\x2', '\x2', '\xC41', '\xC3F', 
		'\x3', '\x2', '\x2', '\x2', '\xC41', '\xC40', '\x3', '\x2', '\x2', '\x2', 
		'\xC42', '\xC43', '\x3', '\x2', '\x2', '\x2', '\xC43', '\xC41', '\x3', 
		'\x2', '\x2', '\x2', '\xC43', '\xC44', '\x3', '\x2', '\x2', '\x2', '\xC44', 
		'\xC47', '\x3', '\x2', '\x2', '\x2', '\xC45', '\xC47', '\x5', '\x1CA', 
		'\xE6', '\x2', '\xC46', '\xC41', '\x3', '\x2', '\x2', '\x2', '\xC46', 
		'\xC45', '\x3', '\x2', '\x2', '\x2', '\xC47', '\x1AF', '\x3', '\x2', '\x2', 
		'\x2', '\xC48', '\xC49', '\a', '\xCC', '\x2', '\x2', '\xC49', '\xC4A', 
		'\x5', '\x272', '\x13A', '\x2', '\xC4A', '\x1B1', '\x3', '\x2', '\x2', 
		'\x2', '\xC4B', '\xC4C', '\a', '\x110', '\x2', '\x2', '\xC4C', '\xC50', 
		'\x5', '\x1B4', '\xDB', '\x2', '\xC4D', '\xC50', '\x5', '\x1B8', '\xDD', 
		'\x2', '\xC4E', '\xC50', '\x5', '\x1BC', '\xDF', '\x2', '\xC4F', '\xC4B', 
		'\x3', '\x2', '\x2', '\x2', '\xC4F', '\xC4D', '\x3', '\x2', '\x2', '\x2', 
		'\xC4F', '\xC4E', '\x3', '\x2', '\x2', '\x2', '\xC50', '\x1B3', '\x3', 
		'\x2', '\x2', '\x2', '\xC51', '\xC52', '\a', '\x24B', '\x2', '\x2', '\xC52', 
		'\xC57', '\x5', '\x1B6', '\xDC', '\x2', '\xC53', '\xC54', '\a', '\x24D', 
		'\x2', '\x2', '\xC54', '\xC56', '\x5', '\x1B6', '\xDC', '\x2', '\xC55', 
		'\xC53', '\x3', '\x2', '\x2', '\x2', '\xC56', '\xC59', '\x3', '\x2', '\x2', 
		'\x2', '\xC57', '\xC55', '\x3', '\x2', '\x2', '\x2', '\xC57', '\xC58', 
		'\x3', '\x2', '\x2', '\x2', '\xC58', '\xC5A', '\x3', '\x2', '\x2', '\x2', 
		'\xC59', '\xC57', '\x3', '\x2', '\x2', '\x2', '\xC5A', '\xC5B', '\a', 
		'\x24C', '\x2', '\x2', '\xC5B', '\x1B5', '\x3', '\x2', '\x2', '\x2', '\xC5C', 
		'\xC5E', '\a', '\x17E', '\x2', '\x2', '\xC5D', '\xC5F', '\x5', '\\', '/', 
		'\x2', '\xC5E', '\xC5D', '\x3', '\x2', '\x2', '\x2', '\xC5E', '\xC5F', 
		'\x3', '\x2', '\x2', '\x2', '\xC5F', '\xC64', '\x3', '\x2', '\x2', '\x2', 
		'\xC60', '\xC63', '\x5', '\x2DC', '\x16F', '\x2', '\xC61', '\xC63', '\x5', 
		'\x2D8', '\x16D', '\x2', '\xC62', '\xC60', '\x3', '\x2', '\x2', '\x2', 
		'\xC62', '\xC61', '\x3', '\x2', '\x2', '\x2', '\xC63', '\xC66', '\x3', 
		'\x2', '\x2', '\x2', '\xC64', '\xC62', '\x3', '\x2', '\x2', '\x2', '\xC64', 
		'\xC65', '\x3', '\x2', '\x2', '\x2', '\xC65', '\xC68', '\x3', '\x2', '\x2', 
		'\x2', '\xC66', '\xC64', '\x3', '\x2', '\x2', '\x2', '\xC67', '\xC69', 
		'\t', '\x1F', '\x2', '\x2', '\xC68', '\xC67', '\x3', '\x2', '\x2', '\x2', 
		'\xC68', '\xC69', '\x3', '\x2', '\x2', '\x2', '\xC69', '\x1B7', '\x3', 
		'\x2', '\x2', '\x2', '\xC6A', '\xC77', '\x5', '\x2A0', '\x151', '\x2', 
		'\xC6B', '\xC6C', '\a', '\x24B', '\x2', '\x2', '\xC6C', '\xC71', '\x5', 
		'\x1BA', '\xDE', '\x2', '\xC6D', '\xC6E', '\a', '\x24D', '\x2', '\x2', 
		'\xC6E', '\xC70', '\x5', '\x1BA', '\xDE', '\x2', '\xC6F', '\xC6D', '\x3', 
		'\x2', '\x2', '\x2', '\xC70', '\xC73', '\x3', '\x2', '\x2', '\x2', '\xC71', 
		'\xC6F', '\x3', '\x2', '\x2', '\x2', '\xC71', '\xC72', '\x3', '\x2', '\x2', 
		'\x2', '\xC72', '\xC74', '\x3', '\x2', '\x2', '\x2', '\xC73', '\xC71', 
		'\x3', '\x2', '\x2', '\x2', '\xC74', '\xC75', '\a', '\x24C', '\x2', '\x2', 
		'\xC75', '\xC77', '\x3', '\x2', '\x2', '\x2', '\xC76', '\xC6A', '\x3', 
		'\x2', '\x2', '\x2', '\xC76', '\xC6B', '\x3', '\x2', '\x2', '\x2', '\xC77', 
		'\x1B9', '\x3', '\x2', '\x2', '\x2', '\xC78', '\xC7A', '\a', '\x17E', 
		'\x2', '\x2', '\xC79', '\xC7B', '\x5', '\\', '/', '\x2', '\xC7A', '\xC79', 
		'\x3', '\x2', '\x2', '\x2', '\xC7A', '\xC7B', '\x3', '\x2', '\x2', '\x2', 
		'\xC7B', '\xC7D', '\x3', '\x2', '\x2', '\x2', '\xC7C', '\xC7E', '\x5', 
		'\x1D2', '\xEA', '\x2', '\xC7D', '\xC7C', '\x3', '\x2', '\x2', '\x2', 
		'\xC7D', '\xC7E', '\x3', '\x2', '\x2', '\x2', '\xC7E', '\xC80', '\x3', 
		'\x2', '\x2', '\x2', '\xC7F', '\xC81', '\x5', '\x2D8', '\x16D', '\x2', 
		'\xC80', '\xC7F', '\x3', '\x2', '\x2', '\x2', '\xC80', '\xC81', '\x3', 
		'\x2', '\x2', '\x2', '\xC81', '\xC82', '\x3', '\x2', '\x2', '\x2', '\xC82', 
		'\xC83', '\t', '\x1F', '\x2', '\x2', '\xC83', '\x1BB', '\x3', '\x2', '\x2', 
		'\x2', '\xC84', '\xC86', '\x5', '\x2A0', '\x151', '\x2', '\xC85', '\xC84', 
		'\x3', '\x2', '\x2', '\x2', '\xC85', '\xC86', '\x3', '\x2', '\x2', '\x2', 
		'\xC86', '\xC87', '\x3', '\x2', '\x2', '\x2', '\xC87', '\xC88', '\a', 
		'\x24B', '\x2', '\x2', '\xC88', '\xC8D', '\x5', '\x1BE', '\xE0', '\x2', 
		'\xC89', '\xC8A', '\a', '\x24D', '\x2', '\x2', '\xC8A', '\xC8C', '\x5', 
		'\x1BE', '\xE0', '\x2', '\xC8B', '\xC89', '\x3', '\x2', '\x2', '\x2', 
		'\xC8C', '\xC8F', '\x3', '\x2', '\x2', '\x2', '\xC8D', '\xC8B', '\x3', 
		'\x2', '\x2', '\x2', '\xC8D', '\xC8E', '\x3', '\x2', '\x2', '\x2', '\xC8E', 
		'\xC90', '\x3', '\x2', '\x2', '\x2', '\xC8F', '\xC8D', '\x3', '\x2', '\x2', 
		'\x2', '\xC90', '\xC91', '\a', '\x24C', '\x2', '\x2', '\xC91', '\x1BD', 
		'\x3', '\x2', '\x2', '\x2', '\xC92', '\xC93', '\x5', '\x1B6', '\xDC', 
		'\x2', '\xC93', '\xC94', '\x5', '\x1C0', '\xE1', '\x2', '\xC94', '\x1BF', 
		'\x3', '\x2', '\x2', '\x2', '\xC95', '\xCA2', '\x5', '\x2A0', '\x151', 
		'\x2', '\xC96', '\xC97', '\a', '\x24B', '\x2', '\x2', '\xC97', '\xC9C', 
		'\x5', '\x1C2', '\xE2', '\x2', '\xC98', '\xC99', '\a', '\x24D', '\x2', 
		'\x2', '\xC99', '\xC9B', '\x5', '\x1C2', '\xE2', '\x2', '\xC9A', '\xC98', 
		'\x3', '\x2', '\x2', '\x2', '\xC9B', '\xC9E', '\x3', '\x2', '\x2', '\x2', 
		'\xC9C', '\xC9A', '\x3', '\x2', '\x2', '\x2', '\xC9C', '\xC9D', '\x3', 
		'\x2', '\x2', '\x2', '\xC9D', '\xC9F', '\x3', '\x2', '\x2', '\x2', '\xC9E', 
		'\xC9C', '\x3', '\x2', '\x2', '\x2', '\xC9F', '\xCA0', '\a', '\x24C', 
		'\x2', '\x2', '\xCA0', '\xCA2', '\x3', '\x2', '\x2', '\x2', '\xCA1', '\xC95', 
		'\x3', '\x2', '\x2', '\x2', '\xCA1', '\xC96', '\x3', '\x2', '\x2', '\x2', 
		'\xCA2', '\x1C1', '\x3', '\x2', '\x2', '\x2', '\xCA3', '\xCA5', '\a', 
		'\x1F2', '\x2', '\x2', '\xCA4', '\xCA6', '\x5', '\\', '/', '\x2', '\xCA5', 
		'\xCA4', '\x3', '\x2', '\x2', '\x2', '\xCA5', '\xCA6', '\x3', '\x2', '\x2', 
		'\x2', '\xCA6', '\xCA8', '\x3', '\x2', '\x2', '\x2', '\xCA7', '\xCA9', 
		'\x5', '\x1D2', '\xEA', '\x2', '\xCA8', '\xCA7', '\x3', '\x2', '\x2', 
		'\x2', '\xCA8', '\xCA9', '\x3', '\x2', '\x2', '\x2', '\xCA9', '\xCAB', 
		'\x3', '\x2', '\x2', '\x2', '\xCAA', '\xCAC', '\x5', '\x2D8', '\x16D', 
		'\x2', '\xCAB', '\xCAA', '\x3', '\x2', '\x2', '\x2', '\xCAB', '\xCAC', 
		'\x3', '\x2', '\x2', '\x2', '\xCAC', '\xCAD', '\x3', '\x2', '\x2', '\x2', 
		'\xCAD', '\xCAE', '\t', '\x1F', '\x2', '\x2', '\xCAE', '\x1C3', '\x3', 
		'\x2', '\x2', '\x2', '\xCAF', '\xCBC', '\x5', '\x616', '\x30C', '\x2', 
		'\xCB0', '\xCBC', '\x5', '\x376', '\x1BC', '\x2', '\xCB1', '\xCBC', '\a', 
		'\x168', '\x2', '\x2', '\xCB2', '\xCB3', '\a', 'V', '\x2', '\x2', '\xCB3', 
		'\xCBC', '\a', '\x1EA', '\x2', '\x2', '\xCB4', '\xCBC', '\x5', '\x378', 
		'\x1BD', '\x2', '\xCB5', '\xCBC', '\x5', '\x2D8', '\x16D', '\x2', '\xCB6', 
		'\xCBC', '\x5', '\x37A', '\x1BE', '\x2', '\xCB7', '\xCBC', '\a', '\x1B7', 
		'\x2', '\x2', '\xCB8', '\xCBC', '\x5', '\x1C6', '\xE4', '\x2', '\xCB9', 
		'\xCBC', '\x5', '\x1C8', '\xE5', '\x2', '\xCBA', '\xCBC', '\x5', '\x270', 
		'\x139', '\x2', '\xCBB', '\xCAF', '\x3', '\x2', '\x2', '\x2', '\xCBB', 
		'\xCB0', '\x3', '\x2', '\x2', '\x2', '\xCBB', '\xCB1', '\x3', '\x2', '\x2', 
		'\x2', '\xCBB', '\xCB2', '\x3', '\x2', '\x2', '\x2', '\xCBB', '\xCB4', 
		'\x3', '\x2', '\x2', '\x2', '\xCBB', '\xCB5', '\x3', '\x2', '\x2', '\x2', 
		'\xCBB', '\xCB6', '\x3', '\x2', '\x2', '\x2', '\xCBB', '\xCB7', '\x3', 
		'\x2', '\x2', '\x2', '\xCBB', '\xCB8', '\x3', '\x2', '\x2', '\x2', '\xCBB', 
		'\xCB9', '\x3', '\x2', '\x2', '\x2', '\xCBB', '\xCBA', '\x3', '\x2', '\x2', 
		'\x2', '\xCBC', '\x1C5', '\x3', '\x2', '\x2', '\x2', '\xCBD', '\xCBE', 
		'\t', '\"', '\x2', '\x2', '\xCBE', '\x1C7', '\x3', '\x2', '\x2', '\x2', 
		'\xCBF', '\xCC0', '\a', '\xE3', '\x2', '\x2', '\xCC0', '\xCC1', '\t', 
		'#', '\x2', '\x2', '\xCC1', '\x1C9', '\x3', '\x2', '\x2', '\x2', '\xCC2', 
		'\xCC3', '\a', '\xE4', '\x2', '\x2', '\xCC3', '\xCC4', '\a', '\xF6', '\x2', 
		'\x2', '\xCC4', '\xCC6', '\x5', '\x46', '$', '\x2', '\xCC5', '\xCC7', 
		'\x5', '\x1CC', '\xE7', '\x2', '\xCC6', '\xCC5', '\x3', '\x2', '\x2', 
		'\x2', '\xCC6', '\xCC7', '\x3', '\x2', '\x2', '\x2', '\xCC7', '\xCC9', 
		'\x3', '\x2', '\x2', '\x2', '\xCC8', '\xCCA', '\x5', '\x270', '\x139', 
		'\x2', '\xCC9', '\xCC8', '\x3', '\x2', '\x2', '\x2', '\xCC9', '\xCCA', 
		'\x3', '\x2', '\x2', '\x2', '\xCCA', '\xCCC', '\x3', '\x2', '\x2', '\x2', 
		'\xCCB', '\xCCD', '\x5', '\x1D0', '\xE9', '\x2', '\xCCC', '\xCCB', '\x3', 
		'\x2', '\x2', '\x2', '\xCCC', '\xCCD', '\x3', '\x2', '\x2', '\x2', '\xCCD', 
		'\x1CB', '\x3', '\x2', '\x2', '\x2', '\xCCE', '\xCCF', '\a', '\x110', 
		'\x2', '\x2', '\xCCF', '\xCD0', '\a', '\x24B', '\x2', '\x2', '\xCD0', 
		'\xCD1', '\x5', '\x1CE', '\xE8', '\x2', '\xCD1', '\xCD2', '\a', '\x24D', 
		'\x2', '\x2', '\xCD2', '\xCD3', '\x5', '\x1CE', '\xE8', '\x2', '\xCD3', 
		'\xCD4', '\x3', '\x2', '\x2', '\x2', '\xCD4', '\xCD5', '\a', '\x24C', 
		'\x2', '\x2', '\xCD5', '\x1CD', '\x3', '\x2', '\x2', '\x2', '\xCD6', '\xCD7', 
		'\a', '\x17E', '\x2', '\x2', '\xCD7', '\xCD9', '\x5', '\\', '/', '\x2', 
		'\xCD8', '\xCDA', '\x5', '\x1D0', '\xE9', '\x2', '\xCD9', '\xCD8', '\x3', 
		'\x2', '\x2', '\x2', '\xCD9', '\xCDA', '\x3', '\x2', '\x2', '\x2', '\xCDA', 
		'\x1CF', '\x3', '\x2', '\x2', '\x2', '\xCDB', '\xCDC', '\a', '\x17B', 
		'\x2', '\x2', '\xCDC', '\xCDD', '\a', '\x24B', '\x2', '\x2', '\xCDD', 
		'\xCDE', '\x5', ',', '\x17', '\x2', '\xCDE', '\xCDF', '\a', '\x24C', '\x2', 
		'\x2', '\xCDF', '\x1D1', '\x3', '\x2', '\x2', '\x2', '\xCE0', '\xCE1', 
		'\a', '\x1FD', '\x2', '\x2', '\xCE1', '\xCE2', '\x5', '\\', '/', '\x2', 
		'\xCE2', '\x1D3', '\x3', '\x2', '\x2', '\x2', '\xCE3', '\xCE4', '\a', 
		'\x1D2', '\x2', '\x2', '\xCE4', '\xCE6', '\x5', '\x46', '$', '\x2', '\xCE5', 
		'\xCE7', '\x5', '\x1D6', '\xEC', '\x2', '\xCE6', '\xCE5', '\x3', '\x2', 
		'\x2', '\x2', '\xCE6', '\xCE7', '\x3', '\x2', '\x2', '\x2', '\xCE7', '\xCEB', 
		'\x3', '\x2', '\x2', '\x2', '\xCE8', '\xCEA', '\x5', '\x662', '\x332', 
		'\x2', '\xCE9', '\xCE8', '\x3', '\x2', '\x2', '\x2', '\xCEA', '\xCED', 
		'\x3', '\x2', '\x2', '\x2', '\xCEB', '\xCE9', '\x3', '\x2', '\x2', '\x2', 
		'\xCEB', '\xCEC', '\x3', '\x2', '\x2', '\x2', '\xCEC', '\x1D5', '\x3', 
		'\x2', '\x2', '\x2', '\xCED', '\xCEB', '\x3', '\x2', '\x2', '\x2', '\xCEE', 
		'\xCEF', '\a', '\x1F0', '\x2', '\x2', '\xCEF', '\xCF0', '\a', '\x253', 
		'\x2', '\x2', '\xCF0', '\xCF1', '\t', '$', '\x2', '\x2', '\xCF1', '\x1D7', 
		'\x3', '\x2', '\x2', '\x2', '\xCF2', '\xCF4', '\x5', '\x1DA', '\xEE', 
		'\x2', '\xCF3', '\xCF2', '\x3', '\x2', '\x2', '\x2', '\xCF3', '\xCF4', 
		'\x3', '\x2', '\x2', '\x2', '\xCF4', '\xCFD', '\x3', '\x2', '\x2', '\x2', 
		'\xCF5', '\xCFE', '\x5', '\x1E2', '\xF2', '\x2', '\xCF6', '\xCFE', '\x5', 
		'\x20A', '\x106', '\x2', '\xCF7', '\xCFE', '\x5', '\x3B2', '\x1DA', '\x2', 
		'\xCF8', '\xCFE', '\x5', '\x1DE', '\xF0', '\x2', '\xCF9', '\xCFE', '\x5', 
		'\x1DC', '\xEF', '\x2', '\xCFA', '\xCFE', '\x5', '\x694', '\x34B', '\x2', 
		'\xCFB', '\xCFE', '\x5', '\x67C', '\x33F', '\x2', '\xCFC', '\xCFE', '\x5', 
		'\x6A6', '\x354', '\x2', '\xCFD', '\xCF5', '\x3', '\x2', '\x2', '\x2', 
		'\xCFD', '\xCF6', '\x3', '\x2', '\x2', '\x2', '\xCFD', '\xCF7', '\x3', 
		'\x2', '\x2', '\x2', '\xCFD', '\xCF8', '\x3', '\x2', '\x2', '\x2', '\xCFD', 
		'\xCF9', '\x3', '\x2', '\x2', '\x2', '\xCFD', '\xCFA', '\x3', '\x2', '\x2', 
		'\x2', '\xCFD', '\xCFB', '\x3', '\x2', '\x2', '\x2', '\xCFD', '\xCFC', 
		'\x3', '\x2', '\x2', '\x2', '\xCFE', '\x1D9', '\x3', '\x2', '\x2', '\x2', 
		'\xCFF', '\xD00', '\t', '%', '\x2', '\x2', '\xD00', '\x1DB', '\x3', '\x2', 
		'\x2', '\x2', '\xD01', '\xD02', '\a', '\x178', '\x2', '\x2', '\xD02', 
		'\xD11', '\x5', '\x46', '$', '\x2', '\xD03', '\xD07', '\a', '\x238', '\x2', 
		'\x2', '\xD04', '\xD06', '\n', '&', '\x2', '\x2', '\xD05', '\xD04', '\x3', 
		'\x2', '\x2', '\x2', '\xD06', '\xD09', '\x3', '\x2', '\x2', '\x2', '\xD07', 
		'\xD05', '\x3', '\x2', '\x2', '\x2', '\xD07', '\xD08', '\x3', '\x2', '\x2', 
		'\x2', '\xD08', '\xD12', '\x3', '\x2', '\x2', '\x2', '\xD09', '\xD07', 
		'\x3', '\x2', '\x2', '\x2', '\xD0A', '\xD0C', '\x5', '\x1EE', '\xF8', 
		'\x2', '\xD0B', '\xD0A', '\x3', '\x2', '\x2', '\x2', '\xD0B', '\xD0C', 
		'\x3', '\x2', '\x2', '\x2', '\xD0C', '\xD0D', '\x3', '\x2', '\x2', '\x2', 
		'\xD0D', '\xD0E', '\x5', '\x1EC', '\xF7', '\x2', '\xD0E', '\xD0F', '\x5', 
		'\x1E0', '\xF1', '\x2', '\xD0F', '\xD10', '\x5', '\x58C', '\x2C7', '\x2', 
		'\xD10', '\xD12', '\x3', '\x2', '\x2', '\x2', '\xD11', '\xD03', '\x3', 
		'\x2', '\x2', '\x2', '\xD11', '\xD0B', '\x3', '\x2', '\x2', '\x2', '\xD12', 
		'\x1DD', '\x3', '\x2', '\x2', '\x2', '\xD13', '\xD14', '\a', '\x178', 
		'\x2', '\x2', '\xD14', '\xD15', '\a', '*', '\x2', '\x2', '\xD15', '\xD23', 
		'\x5', '\x46', '$', '\x2', '\xD16', '\xD1A', '\a', '\x238', '\x2', '\x2', 
		'\xD17', '\xD19', '\n', '&', '\x2', '\x2', '\xD18', '\xD17', '\x3', '\x2', 
		'\x2', '\x2', '\xD19', '\xD1C', '\x3', '\x2', '\x2', '\x2', '\xD1A', '\xD18', 
		'\x3', '\x2', '\x2', '\x2', '\xD1A', '\xD1B', '\x3', '\x2', '\x2', '\x2', 
		'\xD1B', '\xD24', '\x3', '\x2', '\x2', '\x2', '\xD1C', '\xD1A', '\x3', 
		'\x2', '\x2', '\x2', '\xD1D', '\xD1E', '\x5', '\x1EC', '\xF7', '\x2', 
		'\xD1E', '\xD21', '\x5', '\x1E0', '\xF1', '\x2', '\xD1F', '\xD22', '\x5', 
		'\x58A', '\x2C6', '\x2', '\xD20', '\xD22', '\x5', '\x58C', '\x2C7', '\x2', 
		'\xD21', '\xD1F', '\x3', '\x2', '\x2', '\x2', '\xD21', '\xD20', '\x3', 
		'\x2', '\x2', '\x2', '\xD22', '\xD24', '\x3', '\x2', '\x2', '\x2', '\xD23', 
		'\xD16', '\x3', '\x2', '\x2', '\x2', '\xD23', '\xD1D', '\x3', '\x2', '\x2', 
		'\x2', '\xD24', '\x1DF', '\x3', '\x2', '\x2', '\x2', '\xD25', '\xD27', 
		'\x5', '\x5A6', '\x2D4', '\x2', '\xD26', '\xD25', '\x3', '\x2', '\x2', 
		'\x2', '\xD26', '\xD27', '\x3', '\x2', '\x2', '\x2', '\xD27', '\x1E1', 
		'\x3', '\x2', '\x2', '\x2', '\xD28', '\xD2A', '\x5', '\x1E4', '\xF3', 
		'\x2', '\xD29', '\xD2B', '\x5', '\x1E6', '\xF4', '\x2', '\xD2A', '\xD29', 
		'\x3', '\x2', '\x2', '\x2', '\xD2A', '\xD2B', '\x3', '\x2', '\x2', '\x2', 
		'\xD2B', '\x1E3', '\x3', '\x2', '\x2', '\x2', '\xD2C', '\xD2E', '\x5', 
		'\x1E8', '\xF5', '\x2', '\xD2D', '\xD2F', '\x5', '\x1EE', '\xF8', '\x2', 
		'\xD2E', '\xD2D', '\x3', '\x2', '\x2', '\x2', '\xD2E', '\xD2F', '\x3', 
		'\x2', '\x2', '\x2', '\xD2F', '\x1E5', '\x3', '\x2', '\x2', '\x2', '\xD30', 
		'\xD33', '\x5', '\x1EA', '\xF6', '\x2', '\xD31', '\xD33', '\x5', '\x1F0', 
		'\xF9', '\x2', '\xD32', '\xD30', '\x3', '\x2', '\x2', '\x2', '\xD32', 
		'\xD31', '\x3', '\x2', '\x2', '\x2', '\xD33', '\x1E7', '\x3', '\x2', '\x2', 
		'\x2', '\xD34', '\xD35', '\a', '\x196', '\x2', '\x2', '\xD35', '\xD37', 
		'\x5', '\x46', '$', '\x2', '\xD36', '\xD38', '\x5', '\x200', '\x101', 
		'\x2', '\xD37', '\xD36', '\x3', '\x2', '\x2', '\x2', '\xD37', '\xD38', 
		'\x3', '\x2', '\x2', '\x2', '\xD38', '\x1E9', '\x3', '\x2', '\x2', '\x2', 
		'\xD39', '\xD3B', '\x5', '\x1EC', '\xF7', '\x2', '\xD3A', '\xD3C', '\x5', 
		'\x5A6', '\x2D4', '\x2', '\xD3B', '\xD3A', '\x3', '\x2', '\x2', '\x2', 
		'\xD3B', '\xD3C', '\x3', '\x2', '\x2', '\x2', '\xD3C', '\xD3D', '\x3', 
		'\x2', '\x2', '\x2', '\xD3D', '\xD3E', '\x5', '\x58A', '\x2C6', '\x2', 
		'\xD3E', '\x1EB', '\x3', '\x2', '\x2', '\x2', '\xD3F', '\xD40', '\t', 
		'\'', '\x2', '\x2', '\xD40', '\x1ED', '\x3', '\x2', '\x2', '\x2', '\xD41', 
		'\xD42', '\a', '\x1D', '\x2', '\x2', '\xD42', '\xD43', '\t', '(', '\x2', 
		'\x2', '\xD43', '\x1EF', '\x3', '\x2', '\x2', '\x2', '\xD44', '\xD47', 
		'\a', '\x100', '\x2', '\x2', '\xD45', '\xD48', '\x5', '\x1F2', '\xFA', 
		'\x2', '\xD46', '\xD48', '\x5', '\x1F4', '\xFB', '\x2', '\xD47', '\xD45', 
		'\x3', '\x2', '\x2', '\x2', '\xD47', '\xD46', '\x3', '\x2', '\x2', '\x2', 
		'\xD48', '\x1F1', '\x3', '\x2', '\x2', '\x2', '\xD49', '\xD4A', '\a', 
		'\xF9', '\x2', '\x2', '\xD4A', '\xD4B', '\a', '\x137', '\x2', '\x2', '\xD4B', 
		'\xD4C', '\x5', '(', '\x15', '\x2', '\xD4C', '\x1F3', '\x3', '\x2', '\x2', 
		'\x2', '\xD4D', '\xD4F', '\a', '\x35', '\x2', '\x2', '\xD4E', '\xD50', 
		'\x5', '\x1F6', '\xFC', '\x2', '\xD4F', '\xD4E', '\x3', '\x2', '\x2', 
		'\x2', '\xD4F', '\xD50', '\x3', '\x2', '\x2', '\x2', '\xD50', '\xD51', 
		'\x3', '\x2', '\x2', '\x2', '\xD51', '\xD53', '\x5', '\x1F8', '\xFD', 
		'\x2', '\xD52', '\xD54', '\x5', '\x1FA', '\xFE', '\x2', '\xD53', '\xD52', 
		'\x3', '\x2', '\x2', '\x2', '\xD53', '\xD54', '\x3', '\x2', '\x2', '\x2', 
		'\xD54', '\xD56', '\x3', '\x2', '\x2', '\x2', '\xD55', '\xD57', '\x5', 
		'\x1FC', '\xFF', '\x2', '\xD56', '\xD55', '\x3', '\x2', '\x2', '\x2', 
		'\xD56', '\xD57', '\x3', '\x2', '\x2', '\x2', '\xD57', '\xD59', '\x3', 
		'\x2', '\x2', '\x2', '\xD58', '\xD5A', '\x5', '\x1FE', '\x100', '\x2', 
		'\xD59', '\xD58', '\x3', '\x2', '\x2', '\x2', '\xD59', '\xD5A', '\x3', 
		'\x2', '\x2', '\x2', '\xD5A', '\x1F5', '\x3', '\x2', '\x2', '\x2', '\xD5B', 
		'\xD5C', '\a', '\x137', '\x2', '\x2', '\xD5C', '\xD5D', '\x5', '\x44', 
		'#', '\x2', '\xD5D', '\x1F7', '\x3', '\x2', '\x2', '\x2', '\xD5E', '\xD5F', 
		'\a', '\x107', '\x2', '\x2', '\xD5F', '\xD60', '\x5', '\x44', '#', '\x2', 
		'\xD60', '\x1F9', '\x3', '\x2', '\x2', '\x2', '\xD61', '\xD62', '\a', 
		'\b', '\x2', '\x2', '\xD62', '\xD63', '\a', '\xDE', '\x2', '\x2', '\xD63', 
		'\xD64', '\x5', '\x200', '\x101', '\x2', '\xD64', '\x1FB', '\x3', '\x2', 
		'\x2', '\x2', '\xD65', '\xD66', '\a', '\x234', '\x2', '\x2', '\xD66', 
		'\xD67', '\a', '`', '\x2', '\x2', '\xD67', '\x1FD', '\x3', '\x2', '\x2', 
		'\x2', '\xD68', '\xD69', '\a', '\x17B', '\x2', '\x2', '\xD69', '\xD6A', 
		'\a', '\x24B', '\x2', '\x2', '\xD6A', '\xD6B', '\x5', '\x174', '\xBB', 
		'\x2', '\xD6B', '\xD6C', '\a', '\x24C', '\x2', '\x2', '\xD6C', '\x1FF', 
		'\x3', '\x2', '\x2', '\x2', '\xD6D', '\xD76', '\a', '\x24B', '\x2', '\x2', 
		'\xD6E', '\xD73', '\x5', '\x202', '\x102', '\x2', '\xD6F', '\xD70', '\a', 
		'\x24D', '\x2', '\x2', '\xD70', '\xD72', '\x5', '\x202', '\x102', '\x2', 
		'\xD71', '\xD6F', '\x3', '\x2', '\x2', '\x2', '\xD72', '\xD75', '\x3', 
		'\x2', '\x2', '\x2', '\xD73', '\xD71', '\x3', '\x2', '\x2', '\x2', '\xD73', 
		'\xD74', '\x3', '\x2', '\x2', '\x2', '\xD74', '\xD77', '\x3', '\x2', '\x2', 
		'\x2', '\xD75', '\xD73', '\x3', '\x2', '\x2', '\x2', '\xD76', '\xD6E', 
		'\x3', '\x2', '\x2', '\x2', '\xD76', '\xD77', '\x3', '\x2', '\x2', '\x2', 
		'\xD77', '\xD78', '\x3', '\x2', '\x2', '\x2', '\xD78', '\xD79', '\a', 
		'\x24C', '\x2', '\x2', '\xD79', '\x201', '\x3', '\x2', '\x2', '\x2', '\xD7A', 
		'\xD7C', '\x5', 'P', ')', '\x2', '\xD7B', '\xD7D', '\x5', '\x206', '\x104', 
		'\x2', '\xD7C', '\xD7B', '\x3', '\x2', '\x2', '\x2', '\xD7C', '\xD7D', 
		'\x3', '\x2', '\x2', '\x2', '\xD7D', '\xD7F', '\x3', '\x2', '\x2', '\x2', 
		'\xD7E', '\xD80', '\x5', '\x204', '\x103', '\x2', '\xD7F', '\xD7E', '\x3', 
		'\x2', '\x2', '\x2', '\xD7F', '\xD80', '\x3', '\x2', '\x2', '\x2', '\xD80', 
		'\xD81', '\x3', '\x2', '\x2', '\x2', '\xD81', '\xD83', '\x5', '\x62', 
		'\x32', '\x2', '\xD82', '\xD84', '\x5', '\x208', '\x105', '\x2', '\xD83', 
		'\xD82', '\x3', '\x2', '\x2', '\x2', '\xD83', '\xD84', '\x3', '\x2', '\x2', 
		'\x2', '\xD84', '\x203', '\x3', '\x2', '\x2', '\x2', '\xD85', '\xD86', 
		'\a', '\x146', '\x2', '\x2', '\xD86', '\x205', '\x3', '\x2', '\x2', '\x2', 
		'\xD87', '\xD88', '\a', '\xDE', '\x2', '\x2', '\xD88', '\xD8C', '\a', 
		'\x172', '\x2', '\x2', '\xD89', '\xD8C', '\a', '\xDE', '\x2', '\x2', '\xD8A', 
		'\xD8C', '\a', '\x172', '\x2', '\x2', '\xD8B', '\xD87', '\x3', '\x2', 
		'\x2', '\x2', '\xD8B', '\xD89', '\x3', '\x2', '\x2', '\x2', '\xD8B', '\xD8A', 
		'\x3', '\x2', '\x2', '\x2', '\xD8C', '\x207', '\x3', '\x2', '\x2', '\x2', 
		'\xD8D', '\xD8E', '\t', ')', '\x2', '\x2', '\xD8E', '\xD8F', '\x5', '\xA2', 
		'R', '\x2', '\xD8F', '\x209', '\x3', '\x2', '\x2', '\x2', '\xD90', '\xD92', 
		'\x5', '\x20C', '\x107', '\x2', '\xD91', '\xD93', '\x5', '\x20E', '\x108', 
		'\x2', '\xD92', '\xD91', '\x3', '\x2', '\x2', '\x2', '\xD92', '\xD93', 
		'\x3', '\x2', '\x2', '\x2', '\xD93', '\x20B', '\x3', '\x2', '\x2', '\x2', 
		'\xD94', '\xD95', '\x5', '\x210', '\x109', '\x2', '\xD95', '\xD9E', '\x5', 
		'\x212', '\x10A', '\x2', '\xD96', '\xD9D', '\x5', '\x1EE', '\xF8', '\x2', 
		'\xD97', '\xD9D', '\x5', '\x214', '\x10B', '\x2', '\xD98', '\xD9D', '\x5', 
		'\x216', '\x10C', '\x2', '\xD99', '\xD9D', '\x5', '\x226', '\x114', '\x2', 
		'\xD9A', '\xD9D', '\x5', '\x228', '\x115', '\x2', '\xD9B', '\xD9D', '\x5', 
		'\x222', '\x112', '\x2', '\xD9C', '\xD96', '\x3', '\x2', '\x2', '\x2', 
		'\xD9C', '\xD97', '\x3', '\x2', '\x2', '\x2', '\xD9C', '\xD98', '\x3', 
		'\x2', '\x2', '\x2', '\xD9C', '\xD99', '\x3', '\x2', '\x2', '\x2', '\xD9C', 
		'\xD9A', '\x3', '\x2', '\x2', '\x2', '\xD9C', '\xD9B', '\x3', '\x2', '\x2', 
		'\x2', '\xD9D', '\xDA0', '\x3', '\x2', '\x2', '\x2', '\xD9E', '\xD9C', 
		'\x3', '\x2', '\x2', '\x2', '\xD9E', '\xD9F', '\x3', '\x2', '\x2', '\x2', 
		'\xD9F', '\x20D', '\x3', '\x2', '\x2', '\x2', '\xDA0', '\xD9E', '\x3', 
		'\x2', '\x2', '\x2', '\xDA1', '\xDA4', '\x5', '\x1EA', '\xF6', '\x2', 
		'\xDA2', '\xDA4', '\x5', '\x1F0', '\xF9', '\x2', '\xDA3', '\xDA1', '\x3', 
		'\x2', '\x2', '\x2', '\xDA3', '\xDA2', '\x3', '\x2', '\x2', '\x2', '\xDA4', 
		'\x20F', '\x3', '\x2', '\x2', '\x2', '\xDA5', '\xDA8', '\a', '\xCA', '\x2', 
		'\x2', '\xDA6', '\xDA9', '\x5', '\x46', '$', '\x2', '\xDA7', '\xDA9', 
		'\x5', 'T', '+', '\x2', '\xDA8', '\xDA6', '\x3', '\x2', '\x2', '\x2', 
		'\xDA8', '\xDA7', '\x3', '\x2', '\x2', '\x2', '\xDA9', '\xDAB', '\x3', 
		'\x2', '\x2', '\x2', '\xDAA', '\xDAC', '\x5', '\x200', '\x101', '\x2', 
		'\xDAB', '\xDAA', '\x3', '\x2', '\x2', '\x2', '\xDAB', '\xDAC', '\x3', 
		'\x2', '\x2', '\x2', '\xDAC', '\x211', '\x3', '\x2', '\x2', '\x2', '\xDAD', 
		'\xDAE', '\a', '\x1B4', '\x2', '\x2', '\xDAE', '\xDAF', '\x5', '\x62', 
		'\x32', '\x2', '\xDAF', '\x213', '\x3', '\x2', '\x2', '\x2', '\xDB0', 
		'\xDB1', '\a', '\x82', '\x2', '\x2', '\xDB1', '\x215', '\x3', '\x2', '\x2', 
		'\x2', '\xDB2', '\xDB4', '\a', '\x17A', '\x2', '\x2', '\xDB3', '\xDB5', 
		'\x5', '\x218', '\x10D', '\x2', '\xDB4', '\xDB3', '\x3', '\x2', '\x2', 
		'\x2', '\xDB4', '\xDB5', '\x3', '\x2', '\x2', '\x2', '\xDB5', '\x217', 
		'\x3', '\x2', '\x2', '\x2', '\xDB6', '\xDB7', '\a', '\x24B', '\x2', '\x2', 
		'\xDB7', '\xDB8', '\a', '\x17E', '\x2', '\x2', '\xDB8', '\xDB9', '\x5', 
		'P', ')', '\x2', '\xDB9', '\xDBA', '\x5', '\x21A', '\x10E', '\x2', '\xDBA', 
		'\xDBB', '\a', '\x24C', '\x2', '\x2', '\xDBB', '\x219', '\x3', '\x2', 
		'\x2', '\x2', '\xDBC', '\xDC5', '\a', '\x33', '\x2', '\x2', '\xDBD', '\xDC6', 
		'\a', '\x11', '\x2', '\x2', '\xDBE', '\xDBF', '\a', '\x225', '\x2', '\x2', 
		'\xDBF', '\xDC6', '\x5', '\x21C', '\x10F', '\x2', '\xDC0', '\xDC1', '\t', 
		'*', '\x2', '\x2', '\xDC1', '\xDC3', '\x5', '\x364', '\x1B3', '\x2', '\xDC2', 
		'\xDC4', '\x5', '\x21E', '\x110', '\x2', '\xDC3', '\xDC2', '\x3', '\x2', 
		'\x2', '\x2', '\xDC3', '\xDC4', '\x3', '\x2', '\x2', '\x2', '\xDC4', '\xDC6', 
		'\x3', '\x2', '\x2', '\x2', '\xDC5', '\xDBD', '\x3', '\x2', '\x2', '\x2', 
		'\xDC5', '\xDBE', '\x3', '\x2', '\x2', '\x2', '\xDC5', '\xDC0', '\x3', 
		'\x2', '\x2', '\x2', '\xDC6', '\x21B', '\x3', '\x2', '\x2', '\x2', '\xDC7', 
		'\xDC8', '\a', '\x24B', '\x2', '\x2', '\xDC8', '\xDC9', '\x5', '\x178', 
		'\xBD', '\x2', '\xDC9', '\xDCA', '\a', '\x24C', '\x2', '\x2', '\xDCA', 
		'\x21D', '\x3', '\x2', '\x2', '\x2', '\xDCB', '\xDCC', '\t', '+', '\x2', 
		'\x2', '\xDCC', '\xDCD', '\x5', '\xC8', '\x65', '\x2', '\xDCD', '\xDCE', 
		'\x5', '\x220', '\x111', '\x2', '\xDCE', '\x21F', '\x3', '\x2', '\x2', 
		'\x2', '\xDCF', '\xDD0', '\a', '\x33', '\x2', '\x2', '\xDD0', '\xDD1', 
		'\x5', '\x364', '\x1B3', '\x2', '\xDD1', '\x221', '\x3', '\x2', '\x2', 
		'\x2', '\xDD2', '\xDD4', '\a', '\x1B2', '\x2', '\x2', '\xDD3', '\xDD5', 
		'\x5', '\x224', '\x113', '\x2', '\xDD4', '\xDD3', '\x3', '\x2', '\x2', 
		'\x2', '\xDD4', '\xDD5', '\x3', '\x2', '\x2', '\x2', '\xDD5', '\x223', 
		'\x3', '\x2', '\x2', '\x2', '\xDD6', '\xDD7', '\a', '\x1AC', '\x2', '\x2', 
		'\xDD7', '\xDD8', '\a', '\x24B', '\x2', '\x2', '\xDD8', '\xDDD', '\x5', 
		'\x44', '#', '\x2', '\xDD9', '\xDDA', '\a', '\x24D', '\x2', '\x2', '\xDDA', 
		'\xDDC', '\x5', '\x44', '#', '\x2', '\xDDB', '\xDD9', '\x3', '\x2', '\x2', 
		'\x2', '\xDDC', '\xDDF', '\x3', '\x2', '\x2', '\x2', '\xDDD', '\xDDB', 
		'\x3', '\x2', '\x2', '\x2', '\xDDD', '\xDDE', '\x3', '\x2', '\x2', '\x2', 
		'\xDDE', '\xDE0', '\x3', '\x2', '\x2', '\x2', '\xDDF', '\xDDD', '\x3', 
		'\x2', '\x2', '\x2', '\xDE0', '\xDE1', '\a', '\x24C', '\x2', '\x2', '\xDE1', 
		'\x225', '\x3', '\x2', '\x2', '\x2', '\xDE2', '\xDE3', '\a', '\t', '\x2', 
		'\x2', '\xDE3', '\xDE4', '\a', '\x223', '\x2', '\x2', '\xDE4', '\xDE5', 
		'\x5', '\x44', '#', '\x2', '\xDE5', '\x227', '\x3', '\x2', '\x2', '\x2', 
		'\xDE6', '\xDE9', '\a', '\x18B', '\x2', '\x2', '\xDE7', '\xDE8', '\t', 
		',', '\x2', '\x2', '\xDE8', '\xDEA', '\a', '\x18D', '\x2', '\x2', '\xDE9', 
		'\xDE7', '\x3', '\x2', '\x2', '\x2', '\xDE9', '\xDEA', '\x3', '\x2', '\x2', 
		'\x2', '\xDEA', '\xDED', '\x3', '\x2', '\x2', '\x2', '\xDEB', '\xDEC', 
		'\a', '\x223', '\x2', '\x2', '\xDEC', '\xDEE', '\x5', '\x44', '#', '\x2', 
		'\xDED', '\xDEB', '\x3', '\x2', '\x2', '\x2', '\xDED', '\xDEE', '\x3', 
		'\x2', '\x2', '\x2', '\xDEE', '\x229', '\x3', '\x2', '\x2', '\x2', '\xDEF', 
		'\xDF3', '\x5', '\x22C', '\x117', '\x2', '\xDF0', '\xDF4', '\x5', '\x22E', 
		'\x118', '\x2', '\xDF1', '\xDF4', '\x5', '\x23C', '\x11F', '\x2', '\xDF2', 
		'\xDF4', '\x5', '\x23E', '\x120', '\x2', '\xDF3', '\xDF0', '\x3', '\x2', 
		'\x2', '\x2', '\xDF3', '\xDF1', '\x3', '\x2', '\x2', '\x2', '\xDF3', '\xDF2', 
		'\x3', '\x2', '\x2', '\x2', '\xDF4', '\xDF6', '\x3', '\x2', '\x2', '\x2', 
		'\xDF5', '\xDF7', '\x5', '\x230', '\x119', '\x2', '\xDF6', '\xDF5', '\x3', 
		'\x2', '\x2', '\x2', '\xDF6', '\xDF7', '\x3', '\x2', '\x2', '\x2', '\xDF7', 
		'\xDF9', '\x3', '\x2', '\x2', '\x2', '\xDF8', '\xDFA', '\x5', '\x232', 
		'\x11A', '\x2', '\xDF9', '\xDF8', '\x3', '\x2', '\x2', '\x2', '\xDF9', 
		'\xDFA', '\x3', '\x2', '\x2', '\x2', '\xDFA', '\x22B', '\x3', '\x2', '\x2', 
		'\x2', '\xDFB', '\xDFC', '\a', '\xCC', '\x2', '\x2', '\xDFC', '\xE02', 
		'\a', '\x1FF', '\x2', '\x2', '\xDFD', '\xDFE', '\a', '\x195', '\x2', '\x2', 
		'\xDFE', '\xE02', '\a', '\x1FF', '\x2', '\x2', '\xDFF', '\xE02', '\a', 
		'\x1EF', '\x2', '\x2', '\xE00', '\xE02', '\a', '\x90', '\x2', '\x2', '\xE01', 
		'\xDFB', '\x3', '\x2', '\x2', '\x2', '\xE01', '\xDFD', '\x3', '\x2', '\x2', 
		'\x2', '\xE01', '\xDFF', '\x3', '\x2', '\x2', '\x2', '\xE01', '\xE00', 
		'\x3', '\x2', '\x2', '\x2', '\xE01', '\xE02', '\x3', '\x2', '\x2', '\x2', 
		'\xE02', '\xE03', '\x3', '\x2', '\x2', '\x2', '\xE03', '\xE04', '\a', 
		'\x1FB', '\x2', '\x2', '\xE04', '\xE0E', '\x5', '\x46', '$', '\x2', '\xE05', 
		'\xE06', '\a', '\x1F0', '\x2', '\x2', '\xE06', '\xE0C', '\a', '\x253', 
		'\x2', '\x2', '\xE07', '\xE0D', '\a', '\x12A', '\x2', '\x2', '\xE08', 
		'\xE0D', '\a', 'l', '\x2', '\x2', '\xE09', '\xE0A', '\a', '\xAF', '\x2', 
		'\x2', '\xE0A', '\xE0D', '\a', 'l', '\x2', '\x2', '\xE0B', '\xE0D', '\a', 
		'\x150', '\x2', '\x2', '\xE0C', '\xE07', '\x3', '\x2', '\x2', '\x2', '\xE0C', 
		'\xE08', '\x3', '\x2', '\x2', '\x2', '\xE0C', '\xE09', '\x3', '\x2', '\x2', 
		'\x2', '\xE0C', '\xE0B', '\x3', '\x2', '\x2', '\x2', '\xE0D', '\xE0F', 
		'\x3', '\x2', '\x2', '\x2', '\xE0E', '\xE05', '\x3', '\x2', '\x2', '\x2', 
		'\xE0E', '\xE0F', '\x3', '\x2', '\x2', '\x2', '\xE0F', '\x22D', '\x3', 
		'\x2', '\x2', '\x2', '\xE10', '\xE12', '\x5', '\x23A', '\x11E', '\x2', 
		'\xE11', '\xE13', '\x5', '\x25A', '\x12E', '\x2', '\xE12', '\xE11', '\x3', 
		'\x2', '\x2', '\x2', '\xE12', '\xE13', '\x3', '\x2', '\x2', '\x2', '\xE13', 
		'\xE15', '\x3', '\x2', '\x2', '\x2', '\xE14', '\xE16', '\x5', '\x2E0', 
		'\x171', '\x2', '\xE15', '\xE14', '\x3', '\x2', '\x2', '\x2', '\xE15', 
		'\xE16', '\x3', '\x2', '\x2', '\x2', '\xE16', '\xE18', '\x3', '\x2', '\x2', 
		'\x2', '\xE17', '\xE19', '\x5', '\x238', '\x11D', '\x2', '\xE18', '\xE17', 
		'\x3', '\x2', '\x2', '\x2', '\xE18', '\xE19', '\x3', '\x2', '\x2', '\x2', 
		'\xE19', '\xE1B', '\x3', '\x2', '\x2', '\x2', '\xE1A', '\xE1C', '\x5', 
		'\x234', '\x11B', '\x2', '\xE1B', '\xE1A', '\x3', '\x2', '\x2', '\x2', 
		'\xE1B', '\xE1C', '\x3', '\x2', '\x2', '\x2', '\xE1C', '\xE1E', '\x3', 
		'\x2', '\x2', '\x2', '\xE1D', '\xE1F', '\x5', '\x2C0', '\x161', '\x2', 
		'\xE1E', '\xE1D', '\x3', '\x2', '\x2', '\x2', '\xE1E', '\xE1F', '\x3', 
		'\x2', '\x2', '\x2', '\xE1F', '\xE20', '\x3', '\x2', '\x2', '\x2', '\xE20', 
		'\xE21', '\x5', '\x240', '\x121', '\x2', '\xE21', '\x22F', '\x3', '\x2', 
		'\x2', '\x2', '\xE22', '\xE23', '\a', '\x128', '\x2', '\x2', '\xE23', 
		'\xE24', '\a', '\xBE', '\x2', '\x2', '\xE24', '\xE26', '\t', '-', '\x2', 
		'\x2', '\xE25', '\xE22', '\x3', '\x2', '\x2', '\x2', '\xE26', '\xE27', 
		'\x3', '\x2', '\x2', '\x2', '\xE27', '\xE25', '\x3', '\x2', '\x2', '\x2', 
		'\xE27', '\xE28', '\x3', '\x2', '\x2', '\x2', '\xE28', '\x231', '\x3', 
		'\x2', '\x2', '\x2', '\xE29', '\xE2A', '\a', '\x17C', '\x2', '\x2', '\xE2A', 
		'\xE2B', '\x5', '\x46', '$', '\x2', '\xE2B', '\x233', '\x3', '\x2', '\x2', 
		'\x2', '\xE2C', '\xE2E', '\a', '\x164', '\x2', '\x2', '\xE2D', '\xE2F', 
		'\x5', '\x44', '#', '\x2', '\xE2E', '\xE2D', '\x3', '\x2', '\x2', '\x2', 
		'\xE2E', '\xE2F', '\x3', '\x2', '\x2', '\x2', '\xE2F', '\xE30', '\x3', 
		'\x2', '\x2', '\x2', '\xE30', '\xE31', '\x5', '\x236', '\x11C', '\x2', 
		'\xE31', '\x235', '\x3', '\x2', '\x2', '\x2', '\xE32', '\xE35', '\a', 
		'\x24B', '\x2', '\x2', '\xE33', '\xE36', '\x5', '\x616', '\x30C', '\x2', 
		'\xE34', '\xE36', '\x5', '\x378', '\x1BD', '\x2', '\xE35', '\xE33', '\x3', 
		'\x2', '\x2', '\x2', '\xE35', '\xE34', '\x3', '\x2', '\x2', '\x2', '\xE36', 
		'\xE37', '\x3', '\x2', '\x2', '\x2', '\xE37', '\xE35', '\x3', '\x2', '\x2', 
		'\x2', '\xE37', '\xE38', '\x3', '\x2', '\x2', '\x2', '\xE38', '\xE39', 
		'\x3', '\x2', '\x2', '\x2', '\xE39', '\xE3A', '\a', '\x24C', '\x2', '\x2', 
		'\xE3A', '\x237', '\x3', '\x2', '\x2', '\x2', '\xE3B', '\xE3C', '\a', 
		'\x161', '\x2', '\x2', '\xE3C', '\xE3D', '\a', '\xDA', '\x2', '\x2', '\xE3D', 
		'\xE42', '\a', '\xF6', '\x2', '\x2', '\xE3E', '\xE3F', '\a', '\x1FA', 
		'\x2', '\x2', '\xE3F', '\xE43', '\a', '\xCB', '\x2', '\x2', '\xE40', '\xE41', 
		'\a', '\x193', '\x2', '\x2', '\xE41', '\xE43', '\a', '\xFF', '\x2', '\x2', 
		'\xE42', '\xE3E', '\x3', '\x2', '\x2', '\x2', '\xE42', '\xE40', '\x3', 
		'\x2', '\x2', '\x2', '\xE43', '\x239', '\x3', '\x2', '\x2', '\x2', '\xE44', 
		'\xE45', '\a', '\x162', '\x2', '\x2', '\xE45', '\xE47', '\x5', '\x46', 
		'$', '\x2', '\xE46', '\xE48', '\x5', '\x2A8', '\x155', '\x2', '\xE47', 
		'\xE46', '\x3', '\x2', '\x2', '\x2', '\xE47', '\xE48', '\x3', '\x2', '\x2', 
		'\x2', '\xE48', '\x23B', '\x3', '\x2', '\x2', '\x2', '\xE49', '\xE4B', 
		'\x5', '\x2E2', '\x172', '\x2', '\xE4A', '\xE49', '\x3', '\x2', '\x2', 
		'\x2', '\xE4A', '\xE4B', '\x3', '\x2', '\x2', '\x2', '\xE4B', '\xE4D', 
		'\x3', '\x2', '\x2', '\x2', '\xE4C', '\xE4E', '\x5', '\x18E', '\xC8', 
		'\x2', '\xE4D', '\xE4C', '\x3', '\x2', '\x2', '\x2', '\xE4D', '\xE4E', 
		'\x3', '\x2', '\x2', '\x2', '\xE4E', '\xE50', '\x3', '\x2', '\x2', '\x2', 
		'\xE4F', '\xE51', '\x5', '\x2E0', '\x171', '\x2', '\xE50', '\xE4F', '\x3', 
		'\x2', '\x2', '\x2', '\xE50', '\xE51', '\x3', '\x2', '\x2', '\x2', '\xE51', 
		'\xE53', '\x3', '\x2', '\x2', '\x2', '\xE52', '\xE54', '\x5', '\x2C0', 
		'\x161', '\x2', '\xE53', '\xE52', '\x3', '\x2', '\x2', '\x2', '\xE53', 
		'\xE54', '\x3', '\x2', '\x2', '\x2', '\xE54', '\xE55', '\x3', '\x2', '\x2', 
		'\x2', '\xE55', '\xE56', '\x5', '\x240', '\x121', '\x2', '\xE56', '\x23D', 
		'\x3', '\x2', '\x2', '\x2', '\xE57', '\xE58', '\a', '\x162', '\x2', '\x2', 
		'\xE58', '\xE5A', '\a', '\x242', '\x2', '\x2', '\xE59', '\xE5B', '\x5', 
		'\x25A', '\x12E', '\x2', '\xE5A', '\xE59', '\x3', '\x2', '\x2', '\x2', 
		'\xE5A', '\xE5B', '\x3', '\x2', '\x2', '\x2', '\xE5B', '\x23F', '\x3', 
		'\x2', '\x2', '\x2', '\xE5C', '\xE5E', '\x5', '\x242', '\x122', '\x2', 
		'\xE5D', '\xE5C', '\x3', '\x2', '\x2', '\x2', '\xE5D', '\xE5E', '\x3', 
		'\x2', '\x2', '\x2', '\xE5E', '\xE60', '\x3', '\x2', '\x2', '\x2', '\xE5F', 
		'\xE61', '\x5', '\x272', '\x13A', '\x2', '\xE60', '\xE5F', '\x3', '\x2', 
		'\x2', '\x2', '\xE60', '\xE61', '\x3', '\x2', '\x2', '\x2', '\xE61', '\xE63', 
		'\x3', '\x2', '\x2', '\x2', '\xE62', '\xE64', '\x5', '\x2B4', '\x15B', 
		'\x2', '\xE63', '\xE62', '\x3', '\x2', '\x2', '\x2', '\xE63', '\xE64', 
		'\x3', '\x2', '\x2', '\x2', '\xE64', '\xE66', '\x3', '\x2', '\x2', '\x2', 
		'\xE65', '\xE67', '\x5', '\x270', '\x139', '\x2', '\xE66', '\xE65', '\x3', 
		'\x2', '\x2', '\x2', '\xE66', '\xE67', '\x3', '\x2', '\x2', '\x2', '\xE67', 
		'\xE69', '\x3', '\x2', '\x2', '\x2', '\xE68', '\xE6A', '\x5', '\x26E', 
		'\x138', '\x2', '\xE69', '\xE68', '\x3', '\x2', '\x2', '\x2', '\xE69', 
		'\xE6A', '\x3', '\x2', '\x2', '\x2', '\xE6A', '\xE6C', '\x3', '\x2', '\x2', 
		'\x2', '\xE6B', '\xE6D', '\x5', '\x26C', '\x137', '\x2', '\xE6C', '\xE6B', 
		'\x3', '\x2', '\x2', '\x2', '\xE6C', '\xE6D', '\x3', '\x2', '\x2', '\x2', 
		'\xE6D', '\xE71', '\x3', '\x2', '\x2', '\x2', '\xE6E', '\xE70', '\x5', 
		'\x266', '\x134', '\x2', '\xE6F', '\xE6E', '\x3', '\x2', '\x2', '\x2', 
		'\xE70', '\xE73', '\x3', '\x2', '\x2', '\x2', '\xE71', '\xE6F', '\x3', 
		'\x2', '\x2', '\x2', '\xE71', '\xE72', '\x3', '\x2', '\x2', '\x2', '\xE72', 
		'\xE75', '\x3', '\x2', '\x2', '\x2', '\xE73', '\xE71', '\x3', '\x2', '\x2', 
		'\x2', '\xE74', '\xE76', '\x5', '\x264', '\x133', '\x2', '\xE75', '\xE74', 
		'\x3', '\x2', '\x2', '\x2', '\xE75', '\xE76', '\x3', '\x2', '\x2', '\x2', 
		'\xE76', '\xE78', '\x3', '\x2', '\x2', '\x2', '\xE77', '\xE79', '\x5', 
		'\x262', '\x132', '\x2', '\xE78', '\xE77', '\x3', '\x2', '\x2', '\x2', 
		'\xE78', '\xE79', '\x3', '\x2', '\x2', '\x2', '\xE79', '\x241', '\x3', 
		'\x2', '\x2', '\x2', '\xE7A', '\xE82', '\x5', '\x254', '\x12B', '\x2', 
		'\xE7B', '\xE82', '\x5', '\x250', '\x129', '\x2', '\xE7C', '\xE7F', '\x5', 
		'\x2A4', '\x153', '\x2', '\xE7D', '\xE7F', '\x5', '\x2B0', '\x159', '\x2', 
		'\xE7E', '\xE7C', '\x3', '\x2', '\x2', '\x2', '\xE7E', '\xE7D', '\x3', 
		'\x2', '\x2', '\x2', '\xE7F', '\xE82', '\x3', '\x2', '\x2', '\x2', '\xE80', 
		'\xE82', '\x5', '\x244', '\x123', '\x2', '\xE81', '\xE7A', '\x3', '\x2', 
		'\x2', '\x2', '\xE81', '\xE7B', '\x3', '\x2', '\x2', '\x2', '\xE81', '\xE7E', 
		'\x3', '\x2', '\x2', '\x2', '\xE81', '\xE80', '\x3', '\x2', '\x2', '\x2', 
		'\xE82', '\xE83', '\x3', '\x2', '\x2', '\x2', '\xE83', '\xE81', '\x3', 
		'\x2', '\x2', '\x2', '\xE83', '\xE84', '\x3', '\x2', '\x2', '\x2', '\xE84', 
		'\x243', '\x3', '\x2', '\x2', '\x2', '\xE85', '\xE87', '\a', '\x242', 
		'\x2', '\x2', '\xE86', '\xE88', '\a', 'J', '\x2', '\x2', '\xE87', '\xE86', 
		'\x3', '\x2', '\x2', '\x2', '\xE87', '\xE88', '\x3', '\x2', '\x2', '\x2', 
		'\xE88', '\xE89', '\x3', '\x2', '\x2', '\x2', '\xE89', '\xE8B', '\x5', 
		'\x178', '\xBD', '\x2', '\xE8A', '\xE8C', '\x5', '\x246', '\x124', '\x2', 
		'\xE8B', '\xE8A', '\x3', '\x2', '\x2', '\x2', '\xE8B', '\xE8C', '\x3', 
		'\x2', '\x2', '\x2', '\xE8C', '\xE8D', '\x3', '\x2', '\x2', '\x2', '\xE8D', 
		'\xE90', '\x5', '\x33E', '\x1A0', '\x2', '\xE8E', '\xE8F', '\a', '\xD8', 
		'\x2', '\x2', '\xE8F', '\xE91', '\x5', '(', '\x15', '\x2', '\xE90', '\xE8E', 
		'\x3', '\x2', '\x2', '\x2', '\xE90', '\xE91', '\x3', '\x2', '\x2', '\x2', 
		'\xE91', '\x245', '\x3', '\x2', '\x2', '\x2', '\xE92', '\xE95', '\x5', 
		'\x248', '\x125', '\x2', '\xE93', '\xE95', '\x5', '\x24E', '\x128', '\x2', 
		'\xE94', '\xE92', '\x3', '\x2', '\x2', '\x2', '\xE94', '\xE93', '\x3', 
		'\x2', '\x2', '\x2', '\xE95', '\x247', '\x3', '\x2', '\x2', '\x2', '\xE96', 
		'\xE97', '\a', '\x1EC', '\x2', '\x2', '\xE97', '\xE9A', '\a', '\x15', 
		'\x2', '\x2', '\xE98', '\xE9B', '\x5', '\x24A', '\x126', '\x2', '\xE99', 
		'\xE9B', '\x5', '\x24C', '\x127', '\x2', '\xE9A', '\xE98', '\x3', '\x2', 
		'\x2', '\x2', '\xE9A', '\xE99', '\x3', '\x2', '\x2', '\x2', '\xE9B', '\x249', 
		'\x3', '\x2', '\x2', '\x2', '\xE9C', '\xE9D', '\a', '\x161', '\x2', '\x2', 
		'\xE9D', '\xE9E', '\a', '\x1AB', '\x2', '\x2', '\xE9E', '\x24B', '\x3', 
		'\x2', '\x2', '\x2', '\xE9F', '\xEA1', '\t', '.', '\x2', '\x2', '\xEA0', 
		'\xE9F', '\x3', '\x2', '\x2', '\x2', '\xEA0', '\xEA1', '\x3', '\x2', '\x2', 
		'\x2', '\xEA1', '\xEA5', '\x3', '\x2', '\x2', '\x2', '\xEA2', '\xEA6', 
		'\a', '\x43', '\x2', '\x2', '\xEA3', '\xEA4', '\a', '\'', '\x2', '\x2', 
		'\xEA4', '\xEA6', '\a', '\x23B', '\x2', '\x2', '\xEA5', '\xEA2', '\x3', 
		'\x2', '\x2', '\x2', '\xEA5', '\xEA3', '\x3', '\x2', '\x2', '\x2', '\xEA6', 
		'\xEA8', '\x3', '\x2', '\x2', '\x2', '\xEA7', '\xEA9', '\x5', '\\', '/', 
		'\x2', '\xEA8', '\xEA7', '\x3', '\x2', '\x2', '\x2', '\xEA8', '\xEA9', 
		'\x3', '\x2', '\x2', '\x2', '\xEA9', '\xEAB', '\x3', '\x2', '\x2', '\x2', 
		'\xEAA', '\xEAC', '\x5', '\x2B2', '\x15A', '\x2', '\xEAB', '\xEAA', '\x3', 
		'\x2', '\x2', '\x2', '\xEAB', '\xEAC', '\x3', '\x2', '\x2', '\x2', '\xEAC', 
		'\x24D', '\x3', '\x2', '\x2', '\x2', '\xEAD', '\xEAE', '\a', '\x1EC', 
		'\x2', '\x2', '\xEAE', '\xEAF', '\a', '\n', '\x2', '\x2', '\xEAF', '\xEB0', 
		'\a', '\x22A', '\x2', '\x2', '\xEB0', '\xEB1', '\a', '\x15', '\x2', '\x2', 
		'\xEB1', '\xEB2', '\t', '/', '\x2', '\x2', '\xEB2', '\x24F', '\x3', '\x2', 
		'\x2', '\x2', '\xEB3', '\xEB4', '\a', 'J', '\x2', '\x2', '\xEB4', '\xEB5', 
		'\x5', '\x178', '\xBD', '\x2', '\xEB5', '\xEB6', '\x5', '\x2A6', '\x154', 
		'\x2', '\xEB6', '\x251', '\x3', '\x2', '\x2', '\x2', '\xEB7', '\xEB8', 
		'\a', '\x229', '\x2', '\x2', '\xEB8', '\xEB9', '\x5', '\x178', '\xBD', 
		'\x2', '\xEB9', '\xEBA', '\x5', '\x2A6', '\x154', '\x2', '\xEBA', '\x253', 
		'\x3', '\x2', '\x2', '\x2', '\xEBB', '\xEBC', '\a', '\x13D', '\x2', '\x2', 
		'\xEBC', '\xEBD', '\a', '\x1FB', '\x2', '\x2', '\xEBD', '\xEBF', '\x5', 
		'\x260', '\x131', '\x2', '\xEBE', '\xEC0', '\x5', '\x2A6', '\x154', '\x2', 
		'\xEBF', '\xEBE', '\x3', '\x2', '\x2', '\x2', '\xEBF', '\xEC0', '\x3', 
		'\x2', '\x2', '\x2', '\xEC0', '\xEC1', '\x3', '\x2', '\x2', '\x2', '\xEC1', 
		'\xEC3', '\x5', '\x25E', '\x130', '\x2', '\xEC2', '\xEC4', '\x5', '\x256', 
		'\x12C', '\x2', '\xEC3', '\xEC2', '\x3', '\x2', '\x2', '\x2', '\xEC3', 
		'\xEC4', '\x3', '\x2', '\x2', '\x2', '\xEC4', '\xEC6', '\x3', '\x2', '\x2', 
		'\x2', '\xEC5', '\xEC7', '\x5', '\x258', '\x12D', '\x2', '\xEC6', '\xEC5', 
		'\x3', '\x2', '\x2', '\x2', '\xEC6', '\xEC7', '\x3', '\x2', '\x2', '\x2', 
		'\xEC7', '\x255', '\x3', '\x2', '\x2', '\x2', '\xEC8', '\xECC', '\a', 
		'\x24B', '\x2', '\x2', '\xEC9', '\xECD', '\x5', '\x25A', '\x12E', '\x2', 
		'\xECA', '\xECD', '\x5', '\x2C0', '\x161', '\x2', '\xECB', '\xECD', '\x5', 
		'\x242', '\x122', '\x2', '\xECC', '\xEC9', '\x3', '\x2', '\x2', '\x2', 
		'\xECC', '\xECA', '\x3', '\x2', '\x2', '\x2', '\xECC', '\xECB', '\x3', 
		'\x2', '\x2', '\x2', '\xECD', '\xECE', '\x3', '\x2', '\x2', '\x2', '\xECE', 
		'\xECF', '\a', '\x24C', '\x2', '\x2', '\xECF', '\x257', '\x3', '\x2', 
		'\x2', '\x2', '\xED0', '\xED2', '\a', '\x1B4', '\x2', '\x2', '\xED1', 
		'\xED3', '\a', '\x15', '\x2', '\x2', '\xED2', '\xED1', '\x3', '\x2', '\x2', 
		'\x2', '\xED2', '\xED3', '\x3', '\x2', '\x2', '\x2', '\xED3', '\xED4', 
		'\x3', '\x2', '\x2', '\x2', '\xED4', '\xED5', '\t', '\x30', '\x2', '\x2', 
		'\xED5', '\x259', '\x3', '\x2', '\x2', '\x2', '\xED6', '\xED7', '\a', 
		'\x24B', '\x2', '\x2', '\xED7', '\xEDC', '\x5', '\x25C', '\x12F', '\x2', 
		'\xED8', '\xED9', '\a', '\x24D', '\x2', '\x2', '\xED9', '\xEDB', '\x5', 
		'\x25C', '\x12F', '\x2', '\xEDA', '\xED8', '\x3', '\x2', '\x2', '\x2', 
		'\xEDB', '\xEDE', '\x3', '\x2', '\x2', '\x2', '\xEDC', '\xEDA', '\x3', 
		'\x2', '\x2', '\x2', '\xEDC', '\xEDD', '\x3', '\x2', '\x2', '\x2', '\xEDD', 
		'\xEDF', '\x3', '\x2', '\x2', '\x2', '\xEDE', '\xEDC', '\x3', '\x2', '\x2', 
		'\x2', '\xEDF', '\xEE0', '\a', '\x24C', '\x2', '\x2', '\xEE0', '\x25B', 
		'\x3', '\x2', '\x2', '\x2', '\xEE1', '\xEF4', '\x5', '\x2F8', '\x17D', 
		'\x2', '\xEE2', '\xEF4', '\x5', '\x362', '\x1B2', '\x2', '\xEE3', '\xEF4', 
		'\x5', '\x2E6', '\x174', '\x2', '\xEE4', '\xEE7', '\x5', '\x17A', '\xBE', 
		'\x2', '\xEE5', '\xEE7', '\x5', '\x178', '\xBD', '\x2', '\xEE6', '\xEE4', 
		'\x3', '\x2', '\x2', '\x2', '\xEE6', '\xEE5', '\x3', '\x2', '\x2', '\x2', 
		'\xEE7', '\xEE9', '\x3', '\x2', '\x2', '\x2', '\xEE8', '\xEEA', '\x5', 
		'\x5AE', '\x2D8', '\x2', '\xEE9', '\xEE8', '\x3', '\x2', '\x2', '\x2', 
		'\xEE9', '\xEEA', '\x3', '\x2', '\x2', '\x2', '\xEEA', '\xEF1', '\x3', 
		'\x2', '\x2', '\x2', '\xEEB', '\xEF2', '\x5', '\x2FE', '\x180', '\x2', 
		'\xEEC', '\xEEE', '\x5', '\x366', '\x1B4', '\x2', '\xEED', '\xEEC', '\x3', 
		'\x2', '\x2', '\x2', '\xEEE', '\xEEF', '\x3', '\x2', '\x2', '\x2', '\xEEF', 
		'\xEED', '\x3', '\x2', '\x2', '\x2', '\xEEF', '\xEF0', '\x3', '\x2', '\x2', 
		'\x2', '\xEF0', '\xEF2', '\x3', '\x2', '\x2', '\x2', '\xEF1', '\xEEB', 
		'\x3', '\x2', '\x2', '\x2', '\xEF1', '\xEED', '\x3', '\x2', '\x2', '\x2', 
		'\xEF1', '\xEF2', '\x3', '\x2', '\x2', '\x2', '\xEF2', '\xEF4', '\x3', 
		'\x2', '\x2', '\x2', '\xEF3', '\xEE1', '\x3', '\x2', '\x2', '\x2', '\xEF3', 
		'\xEE2', '\x3', '\x2', '\x2', '\x2', '\xEF3', '\xEE3', '\x3', '\x2', '\x2', 
		'\x2', '\xEF3', '\xEE6', '\x3', '\x2', '\x2', '\x2', '\xEF4', '\x25D', 
		'\x3', '\x2', '\x2', '\x2', '\xEF5', '\xEF6', '\a', '\x1EC', '\x2', '\x2', 
		'\xEF6', '\xEF7', '\a', '\x15', '\x2', '\x2', '\xEF7', '\xEF8', '\x5', 
		'\x46', '$', '\x2', '\xEF8', '\x25F', '\x3', '\x2', '\x2', '\x2', '\xEF9', 
		'\xEFF', '\a', 'K', '\x2', '\x2', '\xEFA', '\xEFD', '\x5', '\x17A', '\xBE', 
		'\x2', '\xEFB', '\xEFD', '\x5', '\x178', '\xBD', '\x2', '\xEFC', '\xEFA', 
		'\x3', '\x2', '\x2', '\x2', '\xEFC', '\xEFB', '\x3', '\x2', '\x2', '\x2', 
		'\xEFD', '\xEFF', '\x3', '\x2', '\x2', '\x2', '\xEFE', '\xEF9', '\x3', 
		'\x2', '\x2', '\x2', '\xEFE', '\xEFC', '\x3', '\x2', '\x2', '\x2', '\xEFF', 
		'\x261', '\x3', '\x2', '\x2', '\x2', '\xF00', '\xF01', '\a', '\x15', '\x2', 
		'\x2', '\xF01', '\xF02', '\x5', '\x3EE', '\x1F8', '\x2', '\xF02', '\x263', 
		'\x3', '\x2', '\x2', '\x2', '\xF03', '\xF04', '\x5', '\x36E', '\x1B8', 
		'\x2', '\xF04', '\xF05', '\a', '\x1BD', '\x2', '\x2', '\xF05', '\xF06', 
		'\a', '\x135', '\x2', '\x2', '\xF06', '\x265', '\x3', '\x2', '\x2', '\x2', 
		'\xF07', '\xF09', '\x5', '\x36E', '\x1B8', '\x2', '\xF08', '\xF0A', '\x5', 
		'\x39A', '\x1CE', '\x2', '\xF09', '\xF08', '\x3', '\x2', '\x2', '\x2', 
		'\xF09', '\xF0A', '\x3', '\x2', '\x2', '\x2', '\xF0A', '\xF0E', '\x3', 
		'\x2', '\x2', '\x2', '\xF0B', '\xF0F', '\x5', '\x3A6', '\x1D4', '\x2', 
		'\xF0C', '\xF0F', '\x5', '\x3A4', '\x1D3', '\x2', '\xF0D', '\xF0F', '\x5', 
		'\x3A0', '\x1D1', '\x2', '\xF0E', '\xF0B', '\x3', '\x2', '\x2', '\x2', 
		'\xF0E', '\xF0C', '\x3', '\x2', '\x2', '\x2', '\xF0E', '\xF0D', '\x3', 
		'\x2', '\x2', '\x2', '\xF0F', '\xF11', '\x3', '\x2', '\x2', '\x2', '\xF10', 
		'\xF12', '\x5', '\x372', '\x1BA', '\x2', '\xF11', '\xF10', '\x3', '\x2', 
		'\x2', '\x2', '\xF11', '\xF12', '\x3', '\x2', '\x2', '\x2', '\xF12', '\xF14', 
		'\x3', '\x2', '\x2', '\x2', '\xF13', '\xF15', '\x5', '\x39C', '\x1CF', 
		'\x2', '\xF14', '\xF13', '\x3', '\x2', '\x2', '\x2', '\xF14', '\xF15', 
		'\x3', '\x2', '\x2', '\x2', '\xF15', '\xF17', '\x3', '\x2', '\x2', '\x2', 
		'\xF16', '\xF18', '\x5', '\x26A', '\x136', '\x2', '\xF17', '\xF16', '\x3', 
		'\x2', '\x2', '\x2', '\xF17', '\xF18', '\x3', '\x2', '\x2', '\x2', '\xF18', 
		'\xF1A', '\x3', '\x2', '\x2', '\x2', '\xF19', '\xF1B', '\x5', '\x268', 
		'\x135', '\x2', '\xF1A', '\xF19', '\x3', '\x2', '\x2', '\x2', '\xF1A', 
		'\xF1B', '\x3', '\x2', '\x2', '\x2', '\xF1B', '\x267', '\x3', '\x2', '\x2', 
		'\x2', '\xF1C', '\xF1D', '\t', '\x31', '\x2', '\x2', '\xF1D', '\xF1E', 
		'\a', '\xE2', '\x2', '\x2', '\xF1E', '\x269', '\x3', '\x2', '\x2', '\x2', 
		'\xF1F', '\xF20', '\a', '\x38', '\x2', '\x2', '\xF20', '\x26B', '\x3', 
		'\x2', '\x2', '\x2', '\xF21', '\xF22', '\t', '\x32', '\x2', '\x2', '\xF22', 
		'\x26D', '\x3', '\x2', '\x2', '\x2', '\xF23', '\xF24', '\t', '\x33', '\x2', 
		'\x2', '\xF24', '\x26F', '\x3', '\x2', '\x2', '\x2', '\xF25', '\xF27', 
		'\a', '\x179', '\x2', '\x2', '\xF26', '\xF28', '\x5', '(', '\x15', '\x2', 
		'\xF27', '\xF26', '\x3', '\x2', '\x2', '\x2', '\xF27', '\xF28', '\x3', 
		'\x2', '\x2', '\x2', '\xF28', '\xF2B', '\x3', '\x2', '\x2', '\x2', '\xF29', 
		'\xF2B', '\a', '\x153', '\x2', '\x2', '\xF2A', '\xF25', '\x3', '\x2', 
		'\x2', '\x2', '\xF2A', '\xF29', '\x3', '\x2', '\x2', '\x2', '\xF2B', '\x271', 
		'\x3', '\x2', '\x2', '\x2', '\xF2C', '\xF2D', '\a', '\x17E', '\x2', '\x2', 
		'\xF2D', '\xF32', '\a', '\x33', '\x2', '\x2', '\xF2E', '\xF33', '\x5', 
		'\x284', '\x143', '\x2', '\xF2F', '\xF33', '\x5', '\x274', '\x13B', '\x2', 
		'\xF30', '\xF33', '\x5', '\x28C', '\x147', '\x2', '\xF31', '\xF33', '\x5', 
		'\x282', '\x142', '\x2', '\xF32', '\xF2E', '\x3', '\x2', '\x2', '\x2', 
		'\xF32', '\xF2F', '\x3', '\x2', '\x2', '\x2', '\xF32', '\xF30', '\x3', 
		'\x2', '\x2', '\x2', '\xF32', '\xF31', '\x3', '\x2', '\x2', '\x2', '\xF33', 
		'\x273', '\x3', '\x2', '\x2', '\x2', '\xF34', '\xF35', '\a', '\x19E', 
		'\x2', '\x2', '\xF35', '\xF38', '\x5', '\x364', '\x1B3', '\x2', '\xF36', 
		'\xF39', '\x5', '\x27A', '\x13E', '\x2', '\xF37', '\xF39', '\x5', '\x276', 
		'\x13C', '\x2', '\xF38', '\xF36', '\x3', '\x2', '\x2', '\x2', '\xF38', 
		'\xF37', '\x3', '\x2', '\x2', '\x2', '\xF39', '\xF3A', '\x3', '\x2', '\x2', 
		'\x2', '\xF3A', '\xF3B', '\x5', '\x28E', '\x148', '\x2', '\xF3B', '\x275', 
		'\x3', '\x2', '\x2', '\x2', '\xF3C', '\xF3D', '\a', '\x1F2', '\x2', '\x2', 
		'\xF3D', '\xF3E', '\a', '\x33', '\x2', '\x2', '\xF3E', '\xF3F', '\a', 
		'\xD3', '\x2', '\x2', '\xF3F', '\xF42', '\x5', '\x364', '\x1B3', '\x2', 
		'\xF40', '\xF43', '\x5', '\x278', '\x13D', '\x2', '\xF41', '\xF43', '\x5', 
		'\x27C', '\x13F', '\x2', '\xF42', '\xF40', '\x3', '\x2', '\x2', '\x2', 
		'\xF42', '\xF41', '\x3', '\x2', '\x2', '\x2', '\xF42', '\xF43', '\x3', 
		'\x2', '\x2', '\x2', '\xF43', '\x277', '\x3', '\x2', '\x2', '\x2', '\xF44', 
		'\xF45', '\a', '\x1F3', '\x2', '\x2', '\xF45', '\xF47', '\x5', '(', '\x15', 
		'\x2', '\xF46', '\xF48', '\x5', '\x2A0', '\x151', '\x2', '\xF47', '\xF46', 
		'\x3', '\x2', '\x2', '\x2', '\xF47', '\xF48', '\x3', '\x2', '\x2', '\x2', 
		'\xF48', '\x279', '\x3', '\x2', '\x2', '\x2', '\xF49', '\xF4A', '\a', 
		'\x1F2', '\x2', '\x2', '\xF4A', '\xF4B', '\a', '\x33', '\x2', '\x2', '\xF4B', 
		'\xF4C', '\a', '\x10D', '\x2', '\x2', '\xF4C', '\xF4E', '\x5', '\x364', 
		'\x1B3', '\x2', '\xF4D', '\xF4F', '\x5', '\x27C', '\x13F', '\x2', '\xF4E', 
		'\xF4D', '\x3', '\x2', '\x2', '\x2', '\xF4E', '\xF4F', '\x3', '\x2', '\x2', 
		'\x2', '\xF4F', '\x27B', '\x3', '\x2', '\x2', '\x2', '\xF50', '\xF51', 
		'\a', '\x1F2', '\x2', '\x2', '\xF51', '\xF54', '\a', '\x1FE', '\x2', '\x2', 
		'\xF52', '\xF55', '\x5', '\x27E', '\x140', '\x2', '\xF53', '\xF55', '\x5', 
		'(', '\x15', '\x2', '\xF54', '\xF52', '\x3', '\x2', '\x2', '\x2', '\xF54', 
		'\xF53', '\x3', '\x2', '\x2', '\x2', '\xF55', '\x27D', '\x3', '\x2', '\x2', 
		'\x2', '\xF56', '\xF57', '\a', '\x24B', '\x2', '\x2', '\xF57', '\xF5C', 
		'\x5', '\x280', '\x141', '\x2', '\xF58', '\xF59', '\a', '\x24D', '\x2', 
		'\x2', '\xF59', '\xF5B', '\x5', '\x280', '\x141', '\x2', '\xF5A', '\xF58', 
		'\x3', '\x2', '\x2', '\x2', '\xF5B', '\xF5E', '\x3', '\x2', '\x2', '\x2', 
		'\xF5C', '\xF5A', '\x3', '\x2', '\x2', '\x2', '\xF5C', '\xF5D', '\x3', 
		'\x2', '\x2', '\x2', '\xF5D', '\xF5F', '\x3', '\x2', '\x2', '\x2', '\xF5E', 
		'\xF5C', '\x3', '\x2', '\x2', '\x2', '\xF5F', '\xF60', '\a', '\x24C', 
		'\x2', '\x2', '\xF60', '\x27F', '\x3', '\x2', '\x2', '\x2', '\xF61', '\xF62', 
		'\a', '\x1F2', '\x2', '\x2', '\xF62', '\xF64', '\x5', 'P', ')', '\x2', 
		'\xF63', '\xF65', '\x5', '\x29C', '\x14F', '\x2', '\xF64', '\xF63', '\x3', 
		'\x2', '\x2', '\x2', '\xF64', '\xF65', '\x3', '\x2', '\x2', '\x2', '\xF65', 
		'\xF67', '\x3', '\x2', '\x2', '\x2', '\xF66', '\xF68', '\x5', '\x29A', 
		'\x14E', '\x2', '\xF67', '\xF66', '\x3', '\x2', '\x2', '\x2', '\xF67', 
		'\xF68', '\x3', '\x2', '\x2', '\x2', '\xF68', '\x281', '\x3', '\x2', '\x2', 
		'\x2', '\xF69', '\xF6A', '\a', '\x10D', '\x2', '\x2', '\xF6A', '\xF6B', 
		'\x5', '\x364', '\x1B3', '\x2', '\xF6B', '\xF6C', '\x5', '\x28E', '\x148', 
		'\x2', '\xF6C', '\x283', '\x3', '\x2', '\x2', '\x2', '\xF6D', '\xF6E', 
		'\a', '\xD3', '\x2', '\x2', '\xF6E', '\xF71', '\x5', '\x364', '\x1B3', 
		'\x2', '\xF6F', '\xF72', '\x5', '\x286', '\x144', '\x2', '\xF70', '\xF72', 
		'\x5', '\x288', '\x145', '\x2', '\xF71', '\xF6F', '\x3', '\x2', '\x2', 
		'\x2', '\xF71', '\xF70', '\x3', '\x2', '\x2', '\x2', '\xF72', '\x285', 
		'\x3', '\x2', '\x2', '\x2', '\xF73', '\xF74', '\a', '\x17F', '\x2', '\x2', 
		'\xF74', '\xF76', '\x5', '(', '\x15', '\x2', '\xF75', '\xF77', '\x5', 
		'\x2A0', '\x151', '\x2', '\xF76', '\xF75', '\x3', '\x2', '\x2', '\x2', 
		'\xF76', '\xF77', '\x3', '\x2', '\x2', '\x2', '\xF77', '\xF79', '\x3', 
		'\x2', '\x2', '\x2', '\xF78', '\xF7A', '\x5', '\x2CE', '\x168', '\x2', 
		'\xF79', '\xF78', '\x3', '\x2', '\x2', '\x2', '\xF79', '\xF7A', '\x3', 
		'\x2', '\x2', '\x2', '\xF7A', '\x287', '\x3', '\x2', '\x2', '\x2', '\xF7B', 
		'\xF7C', '\a', '\x24B', '\x2', '\x2', '\xF7C', '\xF81', '\x5', '\x28A', 
		'\x146', '\x2', '\xF7D', '\xF7E', '\a', '\x24D', '\x2', '\x2', '\xF7E', 
		'\xF80', '\x5', '\x28A', '\x146', '\x2', '\xF7F', '\xF7D', '\x3', '\x2', 
		'\x2', '\x2', '\xF80', '\xF83', '\x3', '\x2', '\x2', '\x2', '\xF81', '\xF7F', 
		'\x3', '\x2', '\x2', '\x2', '\xF81', '\xF82', '\x3', '\x2', '\x2', '\x2', 
		'\xF82', '\xF84', '\x3', '\x2', '\x2', '\x2', '\xF83', '\xF81', '\x3', 
		'\x2', '\x2', '\x2', '\xF84', '\xF85', '\a', '\x24C', '\x2', '\x2', '\xF85', 
		'\x289', '\x3', '\x2', '\x2', '\x2', '\xF86', '\xF8C', '\a', '\x17E', 
		'\x2', '\x2', '\xF87', '\xF8D', '\x5', '\x29A', '\x14E', '\x2', '\xF88', 
		'\xF8A', '\x5', 'P', ')', '\x2', '\xF89', '\xF8B', '\x5', '\x29A', '\x14E', 
		'\x2', '\xF8A', '\xF89', '\x3', '\x2', '\x2', '\x2', '\xF8A', '\xF8B', 
		'\x3', '\x2', '\x2', '\x2', '\xF8B', '\xF8D', '\x3', '\x2', '\x2', '\x2', 
		'\xF8C', '\xF87', '\x3', '\x2', '\x2', '\x2', '\xF8C', '\xF88', '\x3', 
		'\x2', '\x2', '\x2', '\xF8C', '\xF8D', '\x3', '\x2', '\x2', '\x2', '\xF8D', 
		'\x28B', '\x3', '\x2', '\x2', '\x2', '\xF8E', '\xF8F', '\x5', '\x2BE', 
		'\x160', '\x2', '\xF8F', '\xF90', '\x5', '\x28E', '\x148', '\x2', '\xF90', 
		'\x28D', '\x3', '\x2', '\x2', '\x2', '\xF91', '\xF92', '\a', '\x24B', 
		'\x2', '\x2', '\xF92', '\xF97', '\x5', '\x290', '\x149', '\x2', '\xF93', 
		'\xF94', '\a', '\x24D', '\x2', '\x2', '\xF94', '\xF96', '\x5', '\x290', 
		'\x149', '\x2', '\xF95', '\xF93', '\x3', '\x2', '\x2', '\x2', '\xF96', 
		'\xF99', '\x3', '\x2', '\x2', '\x2', '\xF97', '\xF95', '\x3', '\x2', '\x2', 
		'\x2', '\xF97', '\xF98', '\x3', '\x2', '\x2', '\x2', '\xF98', '\xF9A', 
		'\x3', '\x2', '\x2', '\x2', '\xF99', '\xF97', '\x3', '\x2', '\x2', '\x2', 
		'\xF9A', '\xF9B', '\a', '\x24C', '\x2', '\x2', '\xF9B', '\x28F', '\x3', 
		'\x2', '\x2', '\x2', '\xF9C', '\xF9E', '\a', '\x17E', '\x2', '\x2', '\xF9D', 
		'\xF9F', '\x5', 'P', ')', '\x2', '\xF9E', '\xF9D', '\x3', '\x2', '\x2', 
		'\x2', '\xF9E', '\xF9F', '\x3', '\x2', '\x2', '\x2', '\xF9F', '\xFA2', 
		'\x3', '\x2', '\x2', '\x2', '\xFA0', '\xFA3', '\x5', '\x2B8', '\x15D', 
		'\x2', '\xFA1', '\xFA3', '\x5', '\x29C', '\x14F', '\x2', '\xFA2', '\xFA0', 
		'\x3', '\x2', '\x2', '\x2', '\xFA2', '\xFA1', '\x3', '\x2', '\x2', '\x2', 
		'\xFA3', '\xFA4', '\x3', '\x2', '\x2', '\x2', '\xFA4', '\xFA5', '\x5', 
		'\x292', '\x14A', '\x2', '\xFA5', '\x291', '\x3', '\x2', '\x2', '\x2', 
		'\xFA6', '\xFA8', '\x5', '\x2DC', '\x16F', '\x2', '\xFA7', '\xFA6', '\x3', 
		'\x2', '\x2', '\x2', '\xFA7', '\xFA8', '\x3', '\x2', '\x2', '\x2', '\xFA8', 
		'\xFAA', '\x3', '\x2', '\x2', '\x2', '\xFA9', '\xFAB', '\x5', '\x2D6', 
		'\x16C', '\x2', '\xFAA', '\xFA9', '\x3', '\x2', '\x2', '\x2', '\xFAA', 
		'\xFAB', '\x3', '\x2', '\x2', '\x2', '\xFAB', '\xFAD', '\x3', '\x2', '\x2', 
		'\x2', '\xFAC', '\xFAE', '\x5', '\x2CE', '\x168', '\x2', '\xFAD', '\xFAC', 
		'\x3', '\x2', '\x2', '\x2', '\xFAD', '\xFAE', '\x3', '\x2', '\x2', '\x2', 
		'\xFAE', '\xFB3', '\x3', '\x2', '\x2', '\x2', '\xFAF', '\xFB2', '\x5', 
		'\x2A4', '\x153', '\x2', '\xFB0', '\xFB2', '\x5', '\x2B0', '\x159', '\x2', 
		'\xFB1', '\xFAF', '\x3', '\x2', '\x2', '\x2', '\xFB1', '\xFB0', '\x3', 
		'\x2', '\x2', '\x2', '\xFB2', '\xFB5', '\x3', '\x2', '\x2', '\x2', '\xFB3', 
		'\xFB1', '\x3', '\x2', '\x2', '\x2', '\xFB3', '\xFB4', '\x3', '\x2', '\x2', 
		'\x2', '\xFB4', '\xFB7', '\x3', '\x2', '\x2', '\x2', '\xFB5', '\xFB3', 
		'\x3', '\x2', '\x2', '\x2', '\xFB6', '\xFB8', '\x5', '\x294', '\x14B', 
		'\x2', '\xFB7', '\xFB6', '\x3', '\x2', '\x2', '\x2', '\xFB7', '\xFB8', 
		'\x3', '\x2', '\x2', '\x2', '\xFB8', '\x293', '\x3', '\x2', '\x2', '\x2', 
		'\xFB9', '\xFBC', '\x5', '\x29E', '\x150', '\x2', '\xFBA', '\xFBC', '\x5', 
		'\x296', '\x14C', '\x2', '\xFBB', '\xFB9', '\x3', '\x2', '\x2', '\x2', 
		'\xFBB', '\xFBA', '\x3', '\x2', '\x2', '\x2', '\xFBC', '\x295', '\x3', 
		'\x2', '\x2', '\x2', '\xFBD', '\xFBE', '\a', '\x24B', '\x2', '\x2', '\xFBE', 
		'\xFC3', '\x5', '\x298', '\x14D', '\x2', '\xFBF', '\xFC0', '\a', '\x24D', 
		'\x2', '\x2', '\xFC0', '\xFC2', '\x5', '\x298', '\x14D', '\x2', '\xFC1', 
		'\xFBF', '\x3', '\x2', '\x2', '\x2', '\xFC2', '\xFC5', '\x3', '\x2', '\x2', 
		'\x2', '\xFC3', '\xFC1', '\x3', '\x2', '\x2', '\x2', '\xFC3', '\xFC4', 
		'\x3', '\x2', '\x2', '\x2', '\xFC4', '\xFC6', '\x3', '\x2', '\x2', '\x2', 
		'\xFC5', '\xFC3', '\x3', '\x2', '\x2', '\x2', '\xFC6', '\xFC7', '\a', 
		'\x24C', '\x2', '\x2', '\xFC7', '\x297', '\x3', '\x2', '\x2', '\x2', '\xFC8', 
		'\xFD5', '\a', '\x1F2', '\x2', '\x2', '\xFC9', '\xFD6', '\x5', '\x29A', 
		'\x14E', '\x2', '\xFCA', '\xFCC', '\x5', '\x29C', '\x14F', '\x2', '\xFCB', 
		'\xFCD', '\x5', '\x29A', '\x14E', '\x2', '\xFCC', '\xFCB', '\x3', '\x2', 
		'\x2', '\x2', '\xFCC', '\xFCD', '\x3', '\x2', '\x2', '\x2', '\xFCD', '\xFD6', 
		'\x3', '\x2', '\x2', '\x2', '\xFCE', '\xFD0', '\x5', 'P', ')', '\x2', 
		'\xFCF', '\xFD1', '\x5', '\x29C', '\x14F', '\x2', '\xFD0', '\xFCF', '\x3', 
		'\x2', '\x2', '\x2', '\xFD0', '\xFD1', '\x3', '\x2', '\x2', '\x2', '\xFD1', 
		'\xFD3', '\x3', '\x2', '\x2', '\x2', '\xFD2', '\xFD4', '\x5', '\x29A', 
		'\x14E', '\x2', '\xFD3', '\xFD2', '\x3', '\x2', '\x2', '\x2', '\xFD3', 
		'\xFD4', '\x3', '\x2', '\x2', '\x2', '\xFD4', '\xFD6', '\x3', '\x2', '\x2', 
		'\x2', '\xFD5', '\xFC9', '\x3', '\x2', '\x2', '\x2', '\xFD5', '\xFCA', 
		'\x3', '\x2', '\x2', '\x2', '\xFD5', '\xFCE', '\x3', '\x2', '\x2', '\x2', 
		'\xFD5', '\xFD6', '\x3', '\x2', '\x2', '\x2', '\xFD6', '\x299', '\x3', 
		'\x2', '\x2', '\x2', '\xFD7', '\xFDC', '\x5', '\x378', '\x1BD', '\x2', 
		'\xFD8', '\xFDC', '\x5', '\x2CE', '\x168', '\x2', '\xFD9', '\xFDC', '\x5', 
		'\x2A4', '\x153', '\x2', '\xFDA', '\xFDC', '\x5', '\x2B0', '\x159', '\x2', 
		'\xFDB', '\xFD7', '\x3', '\x2', '\x2', '\x2', '\xFDB', '\xFD8', '\x3', 
		'\x2', '\x2', '\x2', '\xFDB', '\xFD9', '\x3', '\x2', '\x2', '\x2', '\xFDB', 
		'\xFDA', '\x3', '\x2', '\x2', '\x2', '\xFDC', '\xFDD', '\x3', '\x2', '\x2', 
		'\x2', '\xFDD', '\xFDB', '\x3', '\x2', '\x2', '\x2', '\xFDD', '\xFDE', 
		'\x3', '\x2', '\x2', '\x2', '\xFDE', '\x29B', '\x3', '\x2', '\x2', '\x2', 
		'\xFDF', '\xFE0', '\a', '\x226', '\x2', '\x2', '\xFE0', '\xFE1', '\x5', 
		'\x34E', '\x1A8', '\x2', '\xFE1', '\x29D', '\x3', '\x2', '\x2', '\x2', 
		'\xFE2', '\xFE3', '\a', '\x1F3', '\x2', '\x2', '\xFE3', '\xFE5', '\x5', 
		'(', '\x15', '\x2', '\xFE4', '\xFE6', '\x5', '\x2A0', '\x151', '\x2', 
		'\xFE5', '\xFE4', '\x3', '\x2', '\x2', '\x2', '\xFE5', '\xFE6', '\x3', 
		'\x2', '\x2', '\x2', '\xFE6', '\x29F', '\x3', '\x2', '\x2', '\x2', '\xFE7', 
		'\xFE8', '\a', '\x1EC', '\x2', '\x2', '\xFE8', '\xFE9', '\a', '\xDE', 
		'\x2', '\x2', '\xFE9', '\xFEA', '\x5', '\x2A2', '\x152', '\x2', '\xFEA', 
		'\x2A1', '\x3', '\x2', '\x2', '\x2', '\xFEB', '\xFEC', '\a', '\x24B', 
		'\x2', '\x2', '\xFEC', '\xFF1', '\x5', '^', '\x30', '\x2', '\xFED', '\xFEE', 
		'\a', '\x24D', '\x2', '\x2', '\xFEE', '\xFF0', '\x5', '^', '\x30', '\x2', 
		'\xFEF', '\xFED', '\x3', '\x2', '\x2', '\x2', '\xFF0', '\xFF3', '\x3', 
		'\x2', '\x2', '\x2', '\xFF1', '\xFEF', '\x3', '\x2', '\x2', '\x2', '\xFF1', 
		'\xFF2', '\x3', '\x2', '\x2', '\x2', '\xFF2', '\xFF4', '\x3', '\x2', '\x2', 
		'\x2', '\xFF3', '\xFF1', '\x3', '\x2', '\x2', '\x2', '\xFF4', '\xFF5', 
		'\a', '\x24C', '\x2', '\x2', '\xFF5', '\x2A3', '\x3', '\x2', '\x2', '\x2', 
		'\xFF6', '\xFF7', '\a', '\x229', '\x2', '\x2', '\xFF7', '\xFF9', '\x5', 
		'P', ')', '\x2', '\xFF8', '\xFFA', '\x5', '\x2A6', '\x154', '\x2', '\xFF9', 
		'\xFF8', '\x3', '\x2', '\x2', '\x2', '\xFF9', '\xFFA', '\x3', '\x2', '\x2', 
		'\x2', '\xFFA', '\xFFC', '\x3', '\x2', '\x2', '\x2', '\xFFB', '\xFFD', 
		'\x5', '\x2AE', '\x158', '\x2', '\xFFC', '\xFFB', '\x3', '\x2', '\x2', 
		'\x2', '\xFFC', '\xFFD', '\x3', '\x2', '\x2', '\x2', '\xFFD', '\x2A5', 
		'\x3', '\x2', '\x2', '\x2', '\xFFE', '\x1001', '\x5', '\x2AA', '\x156', 
		'\x2', '\xFFF', '\x1001', '\x5', '\x2A8', '\x155', '\x2', '\x1000', '\xFFE', 
		'\x3', '\x2', '\x2', '\x2', '\x1000', '\xFFF', '\x3', '\x2', '\x2', '\x2', 
		'\x1001', '\x2A7', '\x3', '\x2', '\x2', '\x2', '\x1002', '\x1004', '\a', 
		'\x15A', '\x2', '\x2', '\x1003', '\x1002', '\x3', '\x2', '\x2', '\x2', 
		'\x1003', '\x1004', '\x3', '\x2', '\x2', '\x2', '\x1004', '\x1005', '\x3', 
		'\x2', '\x2', '\x2', '\x1005', '\x1006', '\a', '\x1F4', '\x2', '\x2', 
		'\x1006', '\x1007', '\a', '\x18', '\x2', '\x2', '\x1007', '\x1008', '\a', 
		'\n', '\x2', '\x2', '\x1008', '\x1009', '\a', '\x106', '\x2', '\x2', '\x1009', 
		'\x2A9', '\x3', '\x2', '\x2', '\x2', '\x100A', '\x100C', '\a', '\x96', 
		'\x2', '\x2', '\x100B', '\x100A', '\x3', '\x2', '\x2', '\x2', '\x100B', 
		'\x100C', '\x3', '\x2', '\x2', '\x2', '\x100C', '\x100D', '\x3', '\x2', 
		'\x2', '\x2', '\x100D', '\x100E', '\a', '\xF6', '\x2', '\x2', '\x100E', 
		'\x1010', '\a', '\x162', '\x2', '\x2', '\x100F', '\x1011', '\a', '\x213', 
		'\x2', '\x2', '\x1010', '\x100F', '\x3', '\x2', '\x2', '\x2', '\x1010', 
		'\x1011', '\x3', '\x2', '\x2', '\x2', '\x1011', '\x1012', '\x3', '\x2', 
		'\x2', '\x2', '\x1012', '\x1014', '\a', '\x24B', '\x2', '\x2', '\x1013', 
		'\x1015', '\x5', '\x2AC', '\x157', '\x2', '\x1014', '\x1013', '\x3', '\x2', 
		'\x2', '\x2', '\x1014', '\x1015', '\x3', '\x2', '\x2', '\x2', '\x1015', 
		'\x1016', '\x3', '\x2', '\x2', '\x2', '\x1016', '\x1017', '\x5', '\x62', 
		'\x32', '\x2', '\x1017', '\x1018', '\a', '\x24C', '\x2', '\x2', '\x1018', 
		'\x2AB', '\x3', '\x2', '\x2', '\x2', '\x1019', '\x101A', '\a', '\x167', 
		'\x2', '\x2', '\x101A', '\x2AD', '\x3', '\x2', '\x2', '\x2', '\x101B', 
		'\x101C', '\a', '\x1EC', '\x2', '\x2', '\x101C', '\x101E', '\a', '\x15', 
		'\x2', '\x2', '\x101D', '\x101F', '\t', '.', '\x2', '\x2', '\x101E', '\x101D', 
		'\x3', '\x2', '\x2', '\x2', '\x101E', '\x101F', '\x3', '\x2', '\x2', '\x2', 
		'\x101F', '\x1020', '\x3', '\x2', '\x2', '\x2', '\x1020', '\x1026', '\a', 
		'\x10E', '\x2', '\x2', '\x1021', '\x1027', '\x5', '\x2B2', '\x15A', '\x2', 
		'\x1022', '\x1024', '\x5', '^', '\x30', '\x2', '\x1023', '\x1025', '\x5', 
		'\x2B2', '\x15A', '\x2', '\x1024', '\x1023', '\x3', '\x2', '\x2', '\x2', 
		'\x1024', '\x1025', '\x3', '\x2', '\x2', '\x2', '\x1025', '\x1027', '\x3', 
		'\x2', '\x2', '\x2', '\x1026', '\x1021', '\x3', '\x2', '\x2', '\x2', '\x1026', 
		'\x1022', '\x3', '\x2', '\x2', '\x2', '\x1027', '\x2AF', '\x3', '\x2', 
		'\x2', '\x2', '\x1028', '\x102E', '\x5', '\x2B6', '\x15C', '\x2', '\x1029', 
		'\x102F', '\x5', '\x2B2', '\x15A', '\x2', '\x102A', '\x102C', '\x5', '^', 
		'\x30', '\x2', '\x102B', '\x102D', '\x5', '\x2B2', '\x15A', '\x2', '\x102C', 
		'\x102B', '\x3', '\x2', '\x2', '\x2', '\x102C', '\x102D', '\x3', '\x2', 
		'\x2', '\x2', '\x102D', '\x102F', '\x3', '\x2', '\x2', '\x2', '\x102E', 
		'\x1029', '\x3', '\x2', '\x2', '\x2', '\x102E', '\x102A', '\x3', '\x2', 
		'\x2', '\x2', '\x102F', '\x2B1', '\x3', '\x2', '\x2', '\x2', '\x1030', 
		'\x1034', '\a', '\x24B', '\x2', '\x2', '\x1031', '\x1035', '\x5', '\x378', 
		'\x1BD', '\x2', '\x1032', '\x1035', '\x5', '\x37C', '\x1BF', '\x2', '\x1033', 
		'\x1035', '\x5', '\x2B4', '\x15B', '\x2', '\x1034', '\x1031', '\x3', '\x2', 
		'\x2', '\x2', '\x1034', '\x1032', '\x3', '\x2', '\x2', '\x2', '\x1034', 
		'\x1033', '\x3', '\x2', '\x2', '\x2', '\x1035', '\x1036', '\x3', '\x2', 
		'\x2', '\x2', '\x1036', '\x1034', '\x3', '\x2', '\x2', '\x2', '\x1036', 
		'\x1037', '\x3', '\x2', '\x2', '\x2', '\x1037', '\x1038', '\x3', '\x2', 
		'\x2', '\x2', '\x1038', '\x1039', '\a', '\x24C', '\x2', '\x2', '\x1039', 
		'\x2B3', '\x3', '\x2', '\x2', '\x2', '\x103A', '\x103B', '\a', '\x1B3', 
		'\x2', '\x2', '\x103B', '\x1072', '\a', '\x121', '\x2', '\x2', '\x103C', 
		'\x103D', '\a', '\x1B3', '\x2', '\x2', '\x103D', '\x103E', '\a', '\x12B', 
		'\x2', '\x2', '\x103E', '\x1072', '\x5', '(', '\x15', '\x2', '\x103F', 
		'\x1040', '\a', '\x1B3', '\x2', '\x2', '\x1040', '\x1072', '\a', '\x1E', 
		'\x2', '\x2', '\x1041', '\x1042', '\a', '\x1B3', '\x2', '\x2', '\x1042', 
		'\x1072', '\a', '\x150', '\x2', '\x2', '\x1043', '\x1044', '\a', '\x9B', 
		'\x2', '\x2', '\x1044', '\x1045', '\a', '\x223', '\x2', '\x2', '\x1045', 
		'\x1072', '\x5', ',', '\x17', '\x2', '\x1046', '\x1047', '\a', '\x9B', 
		'\x2', '\x2', '\x1047', '\x1048', '\a', '\xD9', '\x2', '\x2', '\x1048', 
		'\x1049', '\a', '\x33', '\x2', '\x2', '\x1049', '\x1072', '\x5', 'P', 
		')', '\x2', '\x104A', '\x104B', '\a', '\x9B', '\x2', '\x2', '\x104B', 
		'\x1072', '\a', '\x1C3', '\x2', '\x2', '\x104C', '\x104D', '\a', '\x9B', 
		'\x2', '\x2', '\x104D', '\x104E', '\a', '\x142', '\x2', '\x2', '\x104E', 
		'\x1072', '\a', '\x1C3', '\x2', '\x2', '\x104F', '\x1050', '\a', '\x36', 
		'\x2', '\x2', '\x1050', '\x1052', '\a', '\x1A1', '\x2', '\x2', '\x1051', 
		'\x1053', '\x5', '\x376', '\x1BC', '\x2', '\x1052', '\x1051', '\x3', '\x2', 
		'\x2', '\x2', '\x1052', '\x1053', '\x3', '\x2', '\x2', '\x2', '\x1053', 
		'\x1072', '\x3', '\x2', '\x2', '\x2', '\x1054', '\x1055', '\a', 'T', '\x2', 
		'\x2', '\x1055', '\x1072', '\a', '\xD6', '\x2', '\x2', '\x1056', '\x1057', 
		'\a', 'T', '\x2', '\x2', '\x1057', '\x1072', '\a', '\x126', '\x2', '\x2', 
		'\x1058', '\x1059', '\a', '\x9A', '\x2', '\x2', '\x1059', '\x105A', '\a', 
		'\x1EB', '\x2', '\x2', '\x105A', '\x105B', '\a', '\xDE', '\x2', '\x2', 
		'\x105B', '\x1072', '\a', '\x1BD', '\x2', '\x2', '\x105C', '\x105D', '\a', 
		'\x8A', '\x2', '\x2', '\x105D', '\x105E', '\a', '\x1EB', '\x2', '\x2', 
		'\x105E', '\x105F', '\a', '\xDE', '\x2', '\x2', '\x105F', '\x1072', '\a', 
		'\x1BD', '\x2', '\x2', '\x1060', '\x1072', '\a', '\x36', '\x2', '\x2', 
		'\x1061', '\x1062', '\a', '\x42', '\x2', '\x2', '\x1062', '\x1072', '\x5', 
		'(', '\x15', '\x2', '\x1063', '\x1064', '\a', '\x187', '\x2', '\x2', '\x1064', 
		'\x1072', '\x5', '(', '\x15', '\x2', '\x1065', '\x1072', '\a', '\x1B3', 
		'\x2', '\x2', '\x1066', '\x1067', '\a', '\xC7', '\x2', '\x2', '\x1067', 
		'\x1072', '\x5', '(', '\x15', '\x2', '\x1068', '\x106A', '\a', '\x144', 
		'\x2', '\x2', '\x1069', '\x106B', '\x5', '\x376', '\x1BC', '\x2', '\x106A', 
		'\x1069', '\x3', '\x2', '\x2', '\x2', '\x106A', '\x106B', '\x3', '\x2', 
		'\x2', '\x2', '\x106B', '\x1072', '\x3', '\x2', '\x2', '\x2', '\x106C', 
		'\x1072', '\a', 'x', '\x2', '\x2', '\x106D', '\x1072', '\a', '\xFE', '\x2', 
		'\x2', '\x106E', '\x1072', '\a', 'w', '\x2', '\x2', '\x106F', '\x1072', 
		'\a', 'T', '\x2', '\x2', '\x1070', '\x1072', '\a', '\x145', '\x2', '\x2', 
		'\x1071', '\x103A', '\x3', '\x2', '\x2', '\x2', '\x1071', '\x103C', '\x3', 
		'\x2', '\x2', '\x2', '\x1071', '\x103F', '\x3', '\x2', '\x2', '\x2', '\x1071', 
		'\x1041', '\x3', '\x2', '\x2', '\x2', '\x1071', '\x1043', '\x3', '\x2', 
		'\x2', '\x2', '\x1071', '\x1046', '\x3', '\x2', '\x2', '\x2', '\x1071', 
		'\x104A', '\x3', '\x2', '\x2', '\x2', '\x1071', '\x104C', '\x3', '\x2', 
		'\x2', '\x2', '\x1071', '\x104F', '\x3', '\x2', '\x2', '\x2', '\x1071', 
		'\x1054', '\x3', '\x2', '\x2', '\x2', '\x1071', '\x1056', '\x3', '\x2', 
		'\x2', '\x2', '\x1071', '\x1058', '\x3', '\x2', '\x2', '\x2', '\x1071', 
		'\x105C', '\x3', '\x2', '\x2', '\x2', '\x1071', '\x1060', '\x3', '\x2', 
		'\x2', '\x2', '\x1071', '\x1061', '\x3', '\x2', '\x2', '\x2', '\x1071', 
		'\x1063', '\x3', '\x2', '\x2', '\x2', '\x1071', '\x1065', '\x3', '\x2', 
		'\x2', '\x2', '\x1071', '\x1066', '\x3', '\x2', '\x2', '\x2', '\x1071', 
		'\x1068', '\x3', '\x2', '\x2', '\x2', '\x1071', '\x106C', '\x3', '\x2', 
		'\x2', '\x2', '\x1071', '\x106D', '\x3', '\x2', '\x2', '\x2', '\x1071', 
		'\x106E', '\x3', '\x2', '\x2', '\x2', '\x1071', '\x106F', '\x3', '\x2', 
		'\x2', '\x2', '\x1071', '\x1070', '\x3', '\x2', '\x2', '\x2', '\x1072', 
		'\x2B5', '\x3', '\x2', '\x2', '\x2', '\x1073', '\x1074', '\a', '\x10E', 
		'\x2', '\x2', '\x1074', '\x1075', '\a', '\x24B', '\x2', '\x2', '\x1075', 
		'\x107A', '\x5', 'P', ')', '\x2', '\x1076', '\x1077', '\a', '\x24D', '\x2', 
		'\x2', '\x1077', '\x1079', '\x5', 'P', ')', '\x2', '\x1078', '\x1076', 
		'\x3', '\x2', '\x2', '\x2', '\x1079', '\x107C', '\x3', '\x2', '\x2', '\x2', 
		'\x107A', '\x1078', '\x3', '\x2', '\x2', '\x2', '\x107A', '\x107B', '\x3', 
		'\x2', '\x2', '\x2', '\x107B', '\x107D', '\x3', '\x2', '\x2', '\x2', '\x107C', 
		'\x107A', '\x3', '\x2', '\x2', '\x2', '\x107D', '\x107E', '\a', '\x24C', 
		'\x2', '\x2', '\x107E', '\x107F', '\a', '\x1EC', '\x2', '\x2', '\x107F', 
		'\x1080', '\a', '\x15', '\x2', '\x2', '\x1080', '\x2B7', '\x3', '\x2', 
		'\x2', '\x2', '\x1081', '\x1082', '\a', '\x226', '\x2', '\x2', '\x1082', 
		'\x1083', '\a', '\x104', '\x2', '\x2', '\x1083', '\x1084', '\a', '\x200', 
		'\x2', '\x2', '\x1084', '\x1085', '\x5', '\x2BA', '\x15E', '\x2', '\x1085', 
		'\x2B9', '\x3', '\x2', '\x2', '\x2', '\x1086', '\x1087', '\a', '\x24B', 
		'\x2', '\x2', '\x1087', '\x108C', '\x5', '\x2BC', '\x15F', '\x2', '\x1088', 
		'\x1089', '\a', '\x24D', '\x2', '\x2', '\x1089', '\x108B', '\x5', '\x2BC', 
		'\x15F', '\x2', '\x108A', '\x1088', '\x3', '\x2', '\x2', '\x2', '\x108B', 
		'\x108E', '\x3', '\x2', '\x2', '\x2', '\x108C', '\x108A', '\x3', '\x2', 
		'\x2', '\x2', '\x108C', '\x108D', '\x3', '\x2', '\x2', '\x2', '\x108D', 
		'\x108F', '\x3', '\x2', '\x2', '\x2', '\x108E', '\x108C', '\x3', '\x2', 
		'\x2', '\x2', '\x108F', '\x1090', '\a', '\x24C', '\x2', '\x2', '\x1090', 
		'\x2BB', '\x3', '\x2', '\x2', '\x2', '\x1091', '\x1094', '\a', '\x125', 
		'\x2', '\x2', '\x1092', '\x1094', '\x5', '(', '\x15', '\x2', '\x1093', 
		'\x1091', '\x3', '\x2', '\x2', '\x2', '\x1093', '\x1092', '\x3', '\x2', 
		'\x2', '\x2', '\x1094', '\x2BD', '\x3', '\x2', '\x2', '\x2', '\x1095', 
		'\x1096', '\a', '\x19E', '\x2', '\x2', '\x1096', '\x1097', '\x5', '\x364', 
		'\x1B3', '\x2', '\x1097', '\x2BF', '\x3', '\x2', '\x2', '\x2', '\x1098', 
		'\x109A', '\x5', '\x2C6', '\x164', '\x2', '\x1099', '\x1098', '\x3', '\x2', 
		'\x2', '\x2', '\x1099', '\x109A', '\x3', '\x2', '\x2', '\x2', '\x109A', 
		'\x109B', '\x3', '\x2', '\x2', '\x2', '\x109B', '\x10A7', '\x5', '\x2C4', 
		'\x163', '\x2', '\x109C', '\x109E', '\x5', '\x2C6', '\x164', '\x2', '\x109D', 
		'\x109C', '\x3', '\x2', '\x2', '\x2', '\x109D', '\x109E', '\x3', '\x2', 
		'\x2', '\x2', '\x109E', '\x10A1', '\x3', '\x2', '\x2', '\x2', '\x109F', 
		'\x10A2', '\x5', '\x2DE', '\x170', '\x2', '\x10A0', '\x10A2', '\x5', '\x2D6', 
		'\x16C', '\x2', '\x10A1', '\x109F', '\x3', '\x2', '\x2', '\x2', '\x10A1', 
		'\x10A0', '\x3', '\x2', '\x2', '\x2', '\x10A2', '\x10A3', '\x3', '\x2', 
		'\x2', '\x2', '\x10A3', '\x10A1', '\x3', '\x2', '\x2', '\x2', '\x10A3', 
		'\x10A4', '\x3', '\x2', '\x2', '\x2', '\x10A4', '\x10A7', '\x3', '\x2', 
		'\x2', '\x2', '\x10A5', '\x10A7', '\x5', '\x2C2', '\x162', '\x2', '\x10A6', 
		'\x1099', '\x3', '\x2', '\x2', '\x2', '\x10A6', '\x109D', '\x3', '\x2', 
		'\x2', '\x2', '\x10A6', '\x10A5', '\x3', '\x2', '\x2', '\x2', '\x10A7', 
		'\x2C1', '\x3', '\x2', '\x2', '\x2', '\x10A8', '\x10A9', '\a', '\x45', 
		'\x2', '\x2', '\x10A9', '\x10AA', '\x5', '^', '\x30', '\x2', '\x10AA', 
		'\x10AB', '\x5', '\x364', '\x1B3', '\x2', '\x10AB', '\x2C3', '\x3', '\x2', 
		'\x2', '\x2', '\x10AC', '\x10BE', '\a', '\x171', '\x2', '\x2', '\x10AD', 
		'\x10B0', '\a', '\xD5', '\x2', '\x2', '\x10AE', '\x10B1', '\x5', '\x2DE', 
		'\x170', '\x2', '\x10AF', '\x10B1', '\x5', '\x2C8', '\x165', '\x2', '\x10B0', 
		'\x10AE', '\x3', '\x2', '\x2', '\x2', '\x10B0', '\x10AF', '\x3', '\x2', 
		'\x2', '\x2', '\x10B1', '\x10B2', '\x3', '\x2', '\x2', '\x2', '\x10B2', 
		'\x10B0', '\x3', '\x2', '\x2', '\x2', '\x10B2', '\x10B3', '\x3', '\x2', 
		'\x2', '\x2', '\x10B3', '\x10BF', '\x3', '\x2', '\x2', '\x2', '\x10B4', 
		'\x10B7', '\a', '\xE2', '\x2', '\x2', '\x10B5', '\x10B8', '\x5', '\x2DE', 
		'\x170', '\x2', '\x10B6', '\x10B8', '\x5', '\x2CA', '\x166', '\x2', '\x10B7', 
		'\x10B5', '\x3', '\x2', '\x2', '\x2', '\x10B7', '\x10B6', '\x3', '\x2', 
		'\x2', '\x2', '\x10B8', '\x10B9', '\x3', '\x2', '\x2', '\x2', '\x10B9', 
		'\x10B7', '\x3', '\x2', '\x2', '\x2', '\x10B9', '\x10BA', '\x3', '\x2', 
		'\x2', '\x2', '\x10BA', '\x10BC', '\x3', '\x2', '\x2', '\x2', '\x10BB', 
		'\x10BD', '\x5', '\x2CC', '\x167', '\x2', '\x10BC', '\x10BB', '\x3', '\x2', 
		'\x2', '\x2', '\x10BC', '\x10BD', '\x3', '\x2', '\x2', '\x2', '\x10BD', 
		'\x10BF', '\x3', '\x2', '\x2', '\x2', '\x10BE', '\x10AD', '\x3', '\x2', 
		'\x2', '\x2', '\x10BE', '\x10B4', '\x3', '\x2', '\x2', '\x2', '\x10BF', 
		'\x2C5', '\x3', '\x2', '\x2', '\x2', '\x10C0', '\x10C1', '\a', '\x1CF', 
		'\x2', '\x2', '\x10C1', '\x10C2', '\a', '\x65', '\x2', '\x2', '\x10C2', 
		'\x10C3', '\t', ' ', '\x2', '\x2', '\x10C3', '\x2C7', '\x3', '\x2', '\x2', 
		'\x2', '\x10C4', '\x10C5', '\x5', '\x2D6', '\x16C', '\x2', '\x10C5', '\x2C9', 
		'\x3', '\x2', '\x2', '\x2', '\x10C6', '\x10CA', '\x5', '\x2D2', '\x16A', 
		'\x2', '\x10C7', '\x10CA', '\x5', '\x2D8', '\x16D', '\x2', '\x10C8', '\x10CA', 
		'\x5', '\x2D4', '\x16B', '\x2', '\x10C9', '\x10C6', '\x3', '\x2', '\x2', 
		'\x2', '\x10C9', '\x10C7', '\x3', '\x2', '\x2', '\x2', '\x10C9', '\x10C8', 
		'\x3', '\x2', '\x2', '\x2', '\x10CA', '\x2CB', '\x3', '\x2', '\x2', '\x2', 
		'\x10CB', '\x10CD', '\x5', '\x2D0', '\x169', '\x2', '\x10CC', '\x10CB', 
		'\x3', '\x2', '\x2', '\x2', '\x10CC', '\x10CD', '\x3', '\x2', '\x2', '\x2', 
		'\x10CD', '\x10CE', '\x3', '\x2', '\x2', '\x2', '\x10CE', '\x10D0', '\x5', 
		'\x2CE', '\x168', '\x2', '\x10CF', '\x10D1', '\x5', '\x2DC', '\x16F', 
		'\x2', '\x10D0', '\x10CF', '\x3', '\x2', '\x2', '\x2', '\x10D0', '\x10D1', 
		'\x3', '\x2', '\x2', '\x2', '\x10D1', '\x2CD', '\x3', '\x2', '\x2', '\x2', 
		'\x10D2', '\x10D4', '\a', '\x175', '\x2', '\x2', '\x10D3', '\x10D5', '\x5', 
		'\x2DC', '\x16F', '\x2', '\x10D4', '\x10D3', '\x3', '\x2', '\x2', '\x2', 
		'\x10D4', '\x10D5', '\x3', '\x2', '\x2', '\x2', '\x10D5', '\x10D7', '\x3', 
		'\x2', '\x2', '\x2', '\x10D6', '\x10D8', '\x5', '\x2A0', '\x151', '\x2', 
		'\x10D7', '\x10D6', '\x3', '\x2', '\x2', '\x2', '\x10D7', '\x10D8', '\x3', 
		'\x2', '\x2', '\x2', '\x10D8', '\x2CF', '\x3', '\x2', '\x2', '\x2', '\x10D9', 
		'\x10DA', '\a', '\xE0', '\x2', '\x2', '\x10DA', '\x10DB', '\x5', '^', 
		'\x30', '\x2', '\x10DB', '\x2D1', '\x3', '\x2', '\x2', '\x2', '\x10DC', 
		'\x10DD', '\a', '\x185', '\x2', '\x2', '\x10DD', '\x10DE', '\x5', '(', 
		'\x15', '\x2', '\x10DE', '\x2D3', '\x3', '\x2', '\x2', '\x2', '\x10DF', 
		'\x10E0', '\a', '\x11D', '\x2', '\x2', '\x10E0', '\x10E3', '\a', '\x1FB', 
		'\x2', '\x2', '\x10E1', '\x10E3', '\a', '\x14B', '\x2', '\x2', '\x10E2', 
		'\x10DF', '\x3', '\x2', '\x2', '\x2', '\x10E2', '\x10E1', '\x3', '\x2', 
		'\x2', '\x2', '\x10E3', '\x2D5', '\x3', '\x2', '\x2', '\x2', '\x10E4', 
		'\x10E6', '\a', 'T', '\x2', '\x2', '\x10E5', '\x10E7', '\x5', '\x2DA', 
		'\x16E', '\x2', '\x10E6', '\x10E5', '\x3', '\x2', '\x2', '\x2', '\x10E6', 
		'\x10E7', '\x3', '\x2', '\x2', '\x2', '\x10E7', '\x10E9', '\x3', '\x2', 
		'\x2', '\x2', '\x10E8', '\x10EA', '\x5', '(', '\x15', '\x2', '\x10E9', 
		'\x10E8', '\x3', '\x2', '\x2', '\x2', '\x10E9', '\x10EA', '\x3', '\x2', 
		'\x2', '\x2', '\x10EA', '\x1105', '\x3', '\x2', '\x2', '\x2', '\x10EB', 
		'\x10EC', '\a', '\x1BD', '\x2', '\x2', '\x10EC', '\x10ED', '\a', '\x1EC', 
		'\x2', '\x2', '\x10ED', '\x10EF', '\a', 'T', '\x2', '\x2', '\x10EE', '\x10F0', 
		'\t', '\x34', '\x2', '\x2', '\x10EF', '\x10EE', '\x3', '\x2', '\x2', '\x2', 
		'\x10EF', '\x10F0', '\x3', '\x2', '\x2', '\x2', '\x10F0', '\x1105', '\x3', 
		'\x2', '\x2', '\x2', '\x10F1', '\x10F2', '\a', 'J', '\x2', '\x2', '\x10F2', 
		'\x10F3', '\a', '\x1EC', '\x2', '\x2', '\x10F3', '\x10F9', '\a', 'T', 
		'\x2', '\x2', '\x10F4', '\x10F5', '\a', '\xBE', '\x2', '\x2', '\x10F5', 
		'\x10F7', '\t', '\x35', '\x2', '\x2', '\x10F6', '\x10F8', '\t', '\x36', 
		'\x2', '\x2', '\x10F7', '\x10F6', '\x3', '\x2', '\x2', '\x2', '\x10F7', 
		'\x10F8', '\x3', '\x2', '\x2', '\x2', '\x10F8', '\x10FA', '\x3', '\x2', 
		'\x2', '\x2', '\x10F9', '\x10F4', '\x3', '\x2', '\x2', '\x2', '\x10F9', 
		'\x10FA', '\x3', '\x2', '\x2', '\x2', '\x10FA', '\x1101', '\x3', '\x2', 
		'\x2', '\x2', '\x10FB', '\x10FD', '\a', '\x142', '\x2', '\x2', '\x10FC', 
		'\x10FB', '\x3', '\x2', '\x2', '\x2', '\x10FC', '\x10FD', '\x3', '\x2', 
		'\x2', '\x2', '\x10FD', '\x10FE', '\x3', '\x2', '\x2', '\x2', '\x10FE', 
		'\x10FF', '\a', '\x1BD', '\x2', '\x2', '\x10FF', '\x1100', '\a', '\x105', 
		'\x2', '\x2', '\x1100', '\x1102', '\a', '\x114', '\x2', '\x2', '\x1101', 
		'\x10FC', '\x3', '\x2', '\x2', '\x2', '\x1101', '\x1102', '\x3', '\x2', 
		'\x2', '\x2', '\x1102', '\x1105', '\x3', '\x2', '\x2', '\x2', '\x1103', 
		'\x1105', '\a', '\x145', '\x2', '\x2', '\x1104', '\x10E4', '\x3', '\x2', 
		'\x2', '\x2', '\x1104', '\x10EB', '\x3', '\x2', '\x2', '\x2', '\x1104', 
		'\x10F1', '\x3', '\x2', '\x2', '\x2', '\x1104', '\x1103', '\x3', '\x2', 
		'\x2', '\x2', '\x1105', '\x2D7', '\x3', '\x2', '\x2', '\x2', '\x1106', 
		'\x110C', '\a', 'T', '\x2', '\x2', '\x1107', '\x1108', '\a', '\x6', '\x2', 
		'\x2', '\x1108', '\x110D', '\t', '\x36', '\x2', '\x2', '\x1109', '\x110B', 
		'\x5', '(', '\x15', '\x2', '\x110A', '\x1109', '\x3', '\x2', '\x2', '\x2', 
		'\x110A', '\x110B', '\x3', '\x2', '\x2', '\x2', '\x110B', '\x110D', '\x3', 
		'\x2', '\x2', '\x2', '\x110C', '\x1107', '\x3', '\x2', '\x2', '\x2', '\x110C', 
		'\x110A', '\x3', '\x2', '\x2', '\x2', '\x110D', '\x1110', '\x3', '\x2', 
		'\x2', '\x2', '\x110E', '\x1110', '\a', '\x145', '\x2', '\x2', '\x110F', 
		'\x1106', '\x3', '\x2', '\x2', '\x2', '\x110F', '\x110E', '\x3', '\x2', 
		'\x2', '\x2', '\x1110', '\x2D9', '\x3', '\x2', '\x2', '\x2', '\x1111', 
		'\x1112', '\a', '\xBE', '\x2', '\x2', '\x1112', '\x1113', '\t', '\x37', 
		'\x2', '\x2', '\x1113', '\x1114', '\a', '\x16B', '\x2', '\x2', '\x1114', 
		'\x2DB', '\x3', '\x2', '\x2', '\x2', '\x1115', '\x1117', '\x5', '\x2DE', 
		'\x170', '\x2', '\x1116', '\x1115', '\x3', '\x2', '\x2', '\x2', '\x1117', 
		'\x1118', '\x3', '\x2', '\x2', '\x2', '\x1118', '\x1116', '\x3', '\x2', 
		'\x2', '\x2', '\x1118', '\x1119', '\x3', '\x2', '\x2', '\x2', '\x1119', 
		'\x2DD', '\x3', '\x2', '\x2', '\x2', '\x111A', '\x111E', '\x5', '\x378', 
		'\x1BD', '\x2', '\x111B', '\x111E', '\x5', '\x376', '\x1BC', '\x2', '\x111C', 
		'\x111E', '\x5', '\x616', '\x30C', '\x2', '\x111D', '\x111A', '\x3', '\x2', 
		'\x2', '\x2', '\x111D', '\x111B', '\x3', '\x2', '\x2', '\x2', '\x111D', 
		'\x111C', '\x3', '\x2', '\x2', '\x2', '\x111E', '\x2DF', '\x3', '\x2', 
		'\x2', '\x2', '\x111F', '\x1120', '\a', '\x166', '\x2', '\x2', '\x1120', 
		'\x1121', '\a', 'N', '\x2', '\x2', '\x1121', '\x1122', '\t', '\x38', '\x2', 
		'\x2', '\x1122', '\x1123', '\a', '\x1C1', '\x2', '\x2', '\x1123', '\x2E1', 
		'\x3', '\x2', '\x2', '\x2', '\x1124', '\x1125', '\a', '\x24B', '\x2', 
		'\x2', '\x1125', '\x112A', '\x5', '\x2E4', '\x173', '\x2', '\x1126', '\x1127', 
		'\a', '\x24D', '\x2', '\x2', '\x1127', '\x1129', '\x5', '\x2E4', '\x173', 
		'\x2', '\x1128', '\x1126', '\x3', '\x2', '\x2', '\x2', '\x1129', '\x112C', 
		'\x3', '\x2', '\x2', '\x2', '\x112A', '\x1128', '\x3', '\x2', '\x2', '\x2', 
		'\x112A', '\x112B', '\x3', '\x2', '\x2', '\x2', '\x112B', '\x112D', '\x3', 
		'\x2', '\x2', '\x2', '\x112C', '\x112A', '\x3', '\x2', '\x2', '\x2', '\x112D', 
		'\x112E', '\a', '\x24C', '\x2', '\x2', '\x112E', '\x2E3', '\x3', '\x2', 
		'\x2', '\x2', '\x112F', '\x1134', '\x5', '\x2F8', '\x17D', '\x2', '\x1130', 
		'\x1134', '\x5', '\x362', '\x1B2', '\x2', '\x1131', '\x1134', '\x5', '\x2E6', 
		'\x174', '\x2', '\x1132', '\x1134', '\x5', '\x2EE', '\x178', '\x2', '\x1133', 
		'\x112F', '\x3', '\x2', '\x2', '\x2', '\x1133', '\x1130', '\x3', '\x2', 
		'\x2', '\x2', '\x1133', '\x1131', '\x3', '\x2', '\x2', '\x2', '\x1133', 
		'\x1132', '\x3', '\x2', '\x2', '\x2', '\x1134', '\x2E5', '\x3', '\x2', 
		'\x2', '\x2', '\x1135', '\x1136', '\a', '\x1F6', '\x2', '\x2', '\x1136', 
		'\x1139', '\a', '\x115', '\x2', '\x2', '\x1137', '\x113A', '\x5', '\x2E8', 
		'\x175', '\x2', '\x1138', '\x113A', '\x5', '\x2EA', '\x176', '\x2', '\x1139', 
		'\x1137', '\x3', '\x2', '\x2', '\x2', '\x1139', '\x1138', '\x3', '\x2', 
		'\x2', '\x2', '\x113A', '\x2E7', '\x3', '\x2', '\x2', '\x2', '\x113B', 
		'\x113C', '\a', '\xD0', '\x2', '\x2', '\x113C', '\x113D', '\x5', '^', 
		'\x30', '\x2', '\x113D', '\x113F', '\x5', '\x364', '\x1B3', '\x2', '\x113E', 
		'\x1140', '\a', '\xE', '\x2', '\x2', '\x113F', '\x113E', '\x3', '\x2', 
		'\x2', '\x2', '\x113F', '\x1140', '\x3', '\x2', '\x2', '\x2', '\x1140', 
		'\x2E9', '\x3', '\x2', '\x2', '\x2', '\x1141', '\x1142', '\a', 'l', '\x2', 
		'\x2', '\x1142', '\x1143', '\a', '\x24B', '\x2', '\x2', '\x1143', '\x1148', 
		'\x5', '\x2EC', '\x177', '\x2', '\x1144', '\x1145', '\a', '\x24D', '\x2', 
		'\x2', '\x1145', '\x1147', '\x5', '\x2EC', '\x177', '\x2', '\x1146', '\x1144', 
		'\x3', '\x2', '\x2', '\x2', '\x1147', '\x114A', '\x3', '\x2', '\x2', '\x2', 
		'\x1148', '\x1146', '\x3', '\x2', '\x2', '\x2', '\x1148', '\x1149', '\x3', 
		'\x2', '\x2', '\x2', '\x1149', '\x114B', '\x3', '\x2', '\x2', '\x2', '\x114A', 
		'\x1148', '\x3', '\x2', '\x2', '\x2', '\x114B', '\x114C', '\a', '\x24C', 
		'\x2', '\x2', '\x114C', '\x114D', '\a', 'L', '\x2', '\x2', '\x114D', '\x2EB', 
		'\x3', '\x2', '\x2', '\x2', '\x114E', '\x1155', '\a', '\n', '\x2', '\x2', 
		'\x114F', '\x1150', '\a', '\x193', '\x2', '\x2', '\x1150', '\x1155', '\a', 
		'\xFF', '\x2', '\x2', '\x1151', '\x1155', '\a', '\x218', '\x2', '\x2', 
		'\x1152', '\x1153', '\a', '\xC1', '\x2', '\x2', '\x1153', '\x1155', '\a', 
		'\xFF', '\x2', '\x2', '\x1154', '\x114E', '\x3', '\x2', '\x2', '\x2', 
		'\x1154', '\x114F', '\x3', '\x2', '\x2', '\x2', '\x1154', '\x1151', '\x3', 
		'\x2', '\x2', '\x2', '\x1154', '\x1152', '\x3', '\x2', '\x2', '\x2', '\x1155', 
		'\x2ED', '\x3', '\x2', '\x2', '\x2', '\x1156', '\x1157', '\x5', '^', '\x30', 
		'\x2', '\x1157', '\x1159', '\x5', '\x62', '\x32', '\x2', '\x1158', '\x115A', 
		'\x5', '\x37A', '\x1BE', '\x2', '\x1159', '\x1158', '\x3', '\x2', '\x2', 
		'\x2', '\x1159', '\x115A', '\x3', '\x2', '\x2', '\x2', '\x115A', '\x115E', 
		'\x3', '\x2', '\x2', '\x2', '\x115B', '\x115F', '\x5', '\x2F2', '\x17A', 
		'\x2', '\x115C', '\x115F', '\x5', '\x2F0', '\x179', '\x2', '\x115D', '\x115F', 
		'\x5', '\x2F4', '\x17B', '\x2', '\x115E', '\x115B', '\x3', '\x2', '\x2', 
		'\x2', '\x115E', '\x115C', '\x3', '\x2', '\x2', '\x2', '\x115E', '\x115D', 
		'\x3', '\x2', '\x2', '\x2', '\x115E', '\x115F', '\x3', '\x2', '\x2', '\x2', 
		'\x115F', '\x1166', '\x3', '\x2', '\x2', '\x2', '\x1160', '\x1167', '\x5', 
		'\x2FE', '\x180', '\x2', '\x1161', '\x1163', '\x5', '\x366', '\x1B4', 
		'\x2', '\x1162', '\x1161', '\x3', '\x2', '\x2', '\x2', '\x1163', '\x1164', 
		'\x3', '\x2', '\x2', '\x2', '\x1164', '\x1162', '\x3', '\x2', '\x2', '\x2', 
		'\x1164', '\x1165', '\x3', '\x2', '\x2', '\x2', '\x1165', '\x1167', '\x3', 
		'\x2', '\x2', '\x2', '\x1166', '\x1160', '\x3', '\x2', '\x2', '\x2', '\x1166', 
		'\x1162', '\x3', '\x2', '\x2', '\x2', '\x1166', '\x1167', '\x3', '\x2', 
		'\x2', '\x2', '\x1167', '\x2EF', '\x3', '\x2', '\x2', '\x2', '\x1168', 
		'\x1170', '\a', '\xCB', '\x2', '\x2', '\x1169', '\x1171', '\a', '\xE', 
		'\x2', '\x2', '\x116A', '\x116B', '\a', '\x33', '\x2', '\x2', '\x116B', 
		'\x116E', '\a', 'y', '\x2', '\x2', '\x116C', '\x116D', '\a', '\x166', 
		'\x2', '\x2', '\x116D', '\x116F', '\a', '\x15E', '\x2', '\x2', '\x116E', 
		'\x116C', '\x3', '\x2', '\x2', '\x2', '\x116E', '\x116F', '\x3', '\x2', 
		'\x2', '\x2', '\x116F', '\x1171', '\x3', '\x2', '\x2', '\x2', '\x1170', 
		'\x1169', '\x3', '\x2', '\x2', '\x2', '\x1170', '\x116A', '\x3', '\x2', 
		'\x2', '\x2', '\x1171', '\x1172', '\x3', '\x2', '\x2', '\x2', '\x1172', 
		'\x1173', '\a', '\x15', '\x2', '\x2', '\x1173', '\x1182', '\a', '\xDB', 
		'\x2', '\x2', '\x1174', '\x1176', '\a', '\x24B', '\x2', '\x2', '\x1175', 
		'\x1177', '\x5', '\x664', '\x333', '\x2', '\x1176', '\x1175', '\x3', '\x2', 
		'\x2', '\x2', '\x1177', '\x1178', '\x3', '\x2', '\x2', '\x2', '\x1178', 
		'\x1176', '\x3', '\x2', '\x2', '\x2', '\x1178', '\x1179', '\x3', '\x2', 
		'\x2', '\x2', '\x1179', '\x117A', '\x3', '\x2', '\x2', '\x2', '\x117A', 
		'\x117B', '\a', '\x24C', '\x2', '\x2', '\x117B', '\x1183', '\x3', '\x2', 
		'\x2', '\x2', '\x117C', '\x117E', '\x5', '\x664', '\x333', '\x2', '\x117D', 
		'\x117C', '\x3', '\x2', '\x2', '\x2', '\x117E', '\x1181', '\x3', '\x2', 
		'\x2', '\x2', '\x117F', '\x117D', '\x3', '\x2', '\x2', '\x2', '\x117F', 
		'\x1180', '\x3', '\x2', '\x2', '\x2', '\x1180', '\x1183', '\x3', '\x2', 
		'\x2', '\x2', '\x1181', '\x117F', '\x3', '\x2', '\x2', '\x2', '\x1182', 
		'\x1174', '\x3', '\x2', '\x2', '\x2', '\x1182', '\x117F', '\x3', '\x2', 
		'\x2', '\x2', '\x1183', '\x2F1', '\x3', '\x2', '\x2', '\x2', '\x1184', 
		'\x1187', '\a', 'y', '\x2', '\x2', '\x1185', '\x1186', '\a', '\x166', 
		'\x2', '\x2', '\x1186', '\x1188', '\a', '\x15E', '\x2', '\x2', '\x1187', 
		'\x1185', '\x3', '\x2', '\x2', '\x2', '\x1187', '\x1188', '\x3', '\x2', 
		'\x2', '\x2', '\x1188', '\x1189', '\x3', '\x2', '\x2', '\x2', '\x1189', 
		'\x118A', '\x5', '\xA2', 'R', '\x2', '\x118A', '\x2F3', '\x3', '\x2', 
		'\x2', '\x2', '\x118B', '\x118C', '\a', '\xCB', '\x2', '\x2', '\x118C', 
		'\x118E', '\a', '\xE', '\x2', '\x2', '\x118D', '\x118B', '\x3', '\x2', 
		'\x2', '\x2', '\x118D', '\x118E', '\x3', '\x2', '\x2', '\x2', '\x118E', 
		'\x118F', '\x3', '\x2', '\x2', '\x2', '\x118F', '\x1190', '\a', '\x15', 
		'\x2', '\x2', '\x1190', '\x1191', '\a', '\x24B', '\x2', '\x2', '\x1191', 
		'\x1192', '\x5', '\x2F6', '\x17C', '\x2', '\x1192', '\x1194', '\a', '\x24C', 
		'\x2', '\x2', '\x1193', '\x1195', '\a', '\x22E', '\x2', '\x2', '\x1194', 
		'\x1193', '\x3', '\x2', '\x2', '\x2', '\x1194', '\x1195', '\x3', '\x2', 
		'\x2', '\x2', '\x1195', '\x1197', '\x3', '\x2', '\x2', '\x2', '\x1196', 
		'\x1198', '\x5', '\x1C6', '\xE4', '\x2', '\x1197', '\x1196', '\x3', '\x2', 
		'\x2', '\x2', '\x1197', '\x1198', '\x3', '\x2', '\x2', '\x2', '\x1198', 
		'\x2F5', '\x3', '\x2', '\x2', '\x2', '\x1199', '\x119A', '\x5', '\xA2', 
		'R', '\x2', '\x119A', '\x2F7', '\x3', '\x2', '\x2', '\x2', '\x119B', '\x119F', 
		'\x5', '\x2FA', '\x17E', '\x2', '\x119C', '\x119F', '\x5', '\x306', '\x184', 
		'\x2', '\x119D', '\x119F', '\x5', '\x2FC', '\x17F', '\x2', '\x119E', '\x119B', 
		'\x3', '\x2', '\x2', '\x2', '\x119E', '\x119C', '\x3', '\x2', '\x2', '\x2', 
		'\x119E', '\x119D', '\x3', '\x2', '\x2', '\x2', '\x119F', '\x2F9', '\x3', 
		'\x2', '\x2', '\x2', '\x11A0', '\x11A1', '\a', '\x1A6', '\x2', '\x2', 
		'\x11A1', '\x11A2', '\x5', '\x364', '\x1B3', '\x2', '\x11A2', '\x11A3', 
		'\a', '\x234', '\x2', '\x2', '\x11A3', '\x11A4', '\a', '\x1C0', '\x2', 
		'\x2', '\x11A4', '\x2FB', '\x3', '\x2', '\x2', '\x2', '\x11A5', '\x11A6', 
		'\a', '\x1CA', '\x2', '\x2', '\x11A6', '\x11A7', '\a', '\xBE', '\x2', 
		'\x2', '\x11A7', '\x11A8', '\x5', '\x364', '\x1B3', '\x2', '\x11A8', '\x11A9', 
		'\a', '\xF6', '\x2', '\x2', '\x11A9', '\x11AA', '\x5', '\x46', '$', '\x2', 
		'\x11AA', '\x2FD', '\x3', '\x2', '\x2', '\x2', '\x11AB', '\x11AD', '\x5', 
		'\x3A0', '\x1D1', '\x2', '\x11AC', '\x11AB', '\x3', '\x2', '\x2', '\x2', 
		'\x11AC', '\x11AD', '\x3', '\x2', '\x2', '\x2', '\x11AD', '\x11AE', '\x3', 
		'\x2', '\x2', '\x2', '\x11AE', '\x11B0', '\x5', '\x3AE', '\x1D8', '\x2', 
		'\x11AF', '\x11B1', '\x5', '\x3B0', '\x1D9', '\x2', '\x11B0', '\x11AF', 
		'\x3', '\x2', '\x2', '\x2', '\x11B0', '\x11B1', '\x3', '\x2', '\x2', '\x2', 
		'\x11B1', '\x11B3', '\x3', '\x2', '\x2', '\x2', '\x11B2', '\x11B4', '\x5', 
		'\x368', '\x1B5', '\x2', '\x11B3', '\x11B2', '\x3', '\x2', '\x2', '\x2', 
		'\x11B3', '\x11B4', '\x3', '\x2', '\x2', '\x2', '\x11B4', '\x11B8', '\x3', 
		'\x2', '\x2', '\x2', '\x11B5', '\x11B8', '\x5', '\x300', '\x181', '\x2', 
		'\x11B6', '\x11B8', '\x5', '\x302', '\x182', '\x2', '\x11B7', '\x11AC', 
		'\x3', '\x2', '\x2', '\x2', '\x11B7', '\x11B5', '\x3', '\x2', '\x2', '\x2', 
		'\x11B7', '\x11B6', '\x3', '\x2', '\x2', '\x2', '\x11B8', '\x2FF', '\x3', 
		'\x2', '\x2', '\x2', '\x11B9', '\x11BA', '\a', '\x234', '\x2', '\x2', 
		'\x11BA', '\x11BB', '\a', '\x1C0', '\x2', '\x2', '\x11BB', '\x301', '\x3', 
		'\x2', '\x2', '\x2', '\x11BC', '\x11BD', '\a', '\x1CA', '\x2', '\x2', 
		'\x11BD', '\x11BE', '\a', '\xF6', '\x2', '\x2', '\x11BE', '\x11BF', '\x5', 
		'\x46', '$', '\x2', '\x11BF', '\x303', '\x3', '\x2', '\x2', '\x2', '\x11C0', 
		'\x11C1', '\a', '\xC1', '\x2', '\x2', '\x11C1', '\x11C2', '\a', '\xFF', 
		'\x2', '\x2', '\x11C2', '\x11C3', '\x5', '\x364', '\x1B3', '\x2', '\x11C3', 
		'\x305', '\x3', '\x2', '\x2', '\x2', '\x11C4', '\x11C6', '\x5', '\x3A0', 
		'\x1D1', '\x2', '\x11C5', '\x11C4', '\x3', '\x2', '\x2', '\x2', '\x11C5', 
		'\x11C6', '\x3', '\x2', '\x2', '\x2', '\x11C6', '\x11C7', '\x3', '\x2', 
		'\x2', '\x2', '\x11C7', '\x11C8', '\x5', '\x304', '\x183', '\x2', '\x11C8', 
		'\x11CA', '\x5', '\x3AE', '\x1D8', '\x2', '\x11C9', '\x11CB', '\x5', '\x3B0', 
		'\x1D9', '\x2', '\x11CA', '\x11C9', '\x3', '\x2', '\x2', '\x2', '\x11CA', 
		'\x11CB', '\x3', '\x2', '\x2', '\x2', '\x11CB', '\x11CD', '\x3', '\x2', 
		'\x2', '\x2', '\x11CC', '\x11CE', '\x5', '\x368', '\x1B5', '\x2', '\x11CD', 
		'\x11CC', '\x3', '\x2', '\x2', '\x2', '\x11CD', '\x11CE', '\x3', '\x2', 
		'\x2', '\x2', '\x11CE', '\x307', '\x3', '\x2', '\x2', '\x2', '\x11CF', 
		'\x11D0', '\x5', '\x30A', '\x186', '\x2', '\x11D0', '\x11D1', '\a', '\x15', 
		'\x2', '\x2', '\x11D1', '\x11D2', '\x5', '\x352', '\x1AA', '\x2', '\x11D2', 
		'\x309', '\x3', '\x2', '\x2', '\x2', '\x11D3', '\x11D4', '\a', '\x120', 
		'\x2', '\x2', '\x11D4', '\x11D5', '\a', '\x22D', '\x2', '\x2', '\x11D5', 
		'\x11D7', '\x5', '\x46', '$', '\x2', '\x11D6', '\x11D8', '\x5', '\x30C', 
		'\x187', '\x2', '\x11D7', '\x11D6', '\x3', '\x2', '\x2', '\x2', '\x11D7', 
		'\x11D8', '\x3', '\x2', '\x2', '\x2', '\x11D8', '\x11DA', '\x3', '\x2', 
		'\x2', '\x2', '\x11D9', '\x11DB', '\x5', '\x356', '\x1AC', '\x2', '\x11DA', 
		'\x11D9', '\x3', '\x2', '\x2', '\x2', '\x11DA', '\x11DB', '\x3', '\x2', 
		'\x2', '\x2', '\x11DB', '\x11DD', '\x3', '\x2', '\x2', '\x2', '\x11DC', 
		'\x11DE', '\x5', '\x18E', '\xC8', '\x2', '\x11DD', '\x11DC', '\x3', '\x2', 
		'\x2', '\x2', '\x11DD', '\x11DE', '\x3', '\x2', '\x2', '\x2', '\x11DE', 
		'\x11E3', '\x3', '\x2', '\x2', '\x2', '\x11DF', '\x11E4', '\x5', '\x30E', 
		'\x188', '\x2', '\x11E0', '\x11E1', '\x5', '\x2C0', '\x161', '\x2', '\x11E1', 
		'\x11E2', '\x5', '\x314', '\x18B', '\x2', '\x11E2', '\x11E4', '\x3', '\x2', 
		'\x2', '\x2', '\x11E3', '\x11DF', '\x3', '\x2', '\x2', '\x2', '\x11E3', 
		'\x11E0', '\x3', '\x2', '\x2', '\x2', '\x11E3', '\x11E4', '\x3', '\x2', 
		'\x2', '\x2', '\x11E4', '\x11E6', '\x3', '\x2', '\x2', '\x2', '\x11E5', 
		'\x11E7', '\x5', '\x31A', '\x18E', '\x2', '\x11E6', '\x11E5', '\x3', '\x2', 
		'\x2', '\x2', '\x11E6', '\x11E7', '\x3', '\x2', '\x2', '\x2', '\x11E7', 
		'\x11E9', '\x3', '\x2', '\x2', '\x2', '\x11E8', '\x11EA', '\x5', '\x31E', 
		'\x190', '\x2', '\x11E9', '\x11E8', '\x3', '\x2', '\x2', '\x2', '\x11E9', 
		'\x11EA', '\x3', '\x2', '\x2', '\x2', '\x11EA', '\x11EC', '\x3', '\x2', 
		'\x2', '\x2', '\x11EB', '\x11ED', '\x5', '\x32E', '\x198', '\x2', '\x11EC', 
		'\x11EB', '\x3', '\x2', '\x2', '\x2', '\x11EC', '\x11ED', '\x3', '\x2', 
		'\x2', '\x2', '\x11ED', '\x11EF', '\x3', '\x2', '\x2', '\x2', '\x11EE', 
		'\x11F0', '\x5', '\x330', '\x199', '\x2', '\x11EF', '\x11EE', '\x3', '\x2', 
		'\x2', '\x2', '\x11EF', '\x11F0', '\x3', '\x2', '\x2', '\x2', '\x11F0', 
		'\x11F2', '\x3', '\x2', '\x2', '\x2', '\x11F1', '\x11F3', '\x5', '\x332', 
		'\x19A', '\x2', '\x11F2', '\x11F1', '\x3', '\x2', '\x2', '\x2', '\x11F2', 
		'\x11F3', '\x3', '\x2', '\x2', '\x2', '\x11F3', '\x30B', '\x3', '\x2', 
		'\x2', '\x2', '\x11F4', '\x11F5', '\a', '\x162', '\x2', '\x2', '\x11F5', 
		'\x11F6', '\x5', '\x46', '$', '\x2', '\x11F6', '\x30D', '\x3', '\x2', 
		'\x2', '\x2', '\x11F7', '\x11F8', '\a', '\x166', '\x2', '\x2', '\x11F8', 
		'\x11F9', '\a', '\x18F', '\x2', '\x2', '\x11F9', '\x11FD', '\a', '\x1FB', 
		'\x2', '\x2', '\x11FA', '\x11FB', '\t', '\x39', '\x2', '\x2', '\x11FB', 
		'\x11FC', '\a', '\x1A5', '\x2', '\x2', '\x11FC', '\x11FE', '\a', '\x191', 
		'\x2', '\x2', '\x11FD', '\x11FA', '\x3', '\x2', '\x2', '\x2', '\x11FD', 
		'\x11FE', '\x3', '\x2', '\x2', '\x2', '\x11FE', '\x30F', '\x3', '\x2', 
		'\x2', '\x2', '\x11FF', '\x1200', '\a', '\x45', '\x2', '\x2', '\x1200', 
		'\x1201', '\x5', '\\', '/', '\x2', '\x1201', '\x1202', '\x5', '\x312', 
		'\x18A', '\x2', '\x1202', '\x311', '\x3', '\x2', '\x2', '\x2', '\x1203', 
		'\x1205', '\a', '\x24B', '\x2', '\x2', '\x1204', '\x1206', '\x5', '\\', 
		'/', '\x2', '\x1205', '\x1204', '\x3', '\x2', '\x2', '\x2', '\x1206', 
		'\x1207', '\x3', '\x2', '\x2', '\x2', '\x1207', '\x1205', '\x3', '\x2', 
		'\x2', '\x2', '\x1207', '\x1208', '\x3', '\x2', '\x2', '\x2', '\x1208', 
		'\x1209', '\x3', '\x2', '\x2', '\x2', '\x1209', '\x120A', '\a', '\x24C', 
		'\x2', '\x2', '\x120A', '\x313', '\x3', '\x2', '\x2', '\x2', '\x120B', 
		'\x120D', '\x5', '\x242', '\x122', '\x2', '\x120C', '\x120B', '\x3', '\x2', 
		'\x2', '\x2', '\x120C', '\x120D', '\x3', '\x2', '\x2', '\x2', '\x120D', 
		'\x120F', '\x3', '\x2', '\x2', '\x2', '\x120E', '\x1210', '\x5', '\x272', 
		'\x13A', '\x2', '\x120F', '\x120E', '\x3', '\x2', '\x2', '\x2', '\x120F', 
		'\x1210', '\x3', '\x2', '\x2', '\x2', '\x1210', '\x1212', '\x3', '\x2', 
		'\x2', '\x2', '\x1211', '\x1213', '\x5', '\x316', '\x18C', '\x2', '\x1212', 
		'\x1211', '\x3', '\x2', '\x2', '\x2', '\x1212', '\x1213', '\x3', '\x2', 
		'\x2', '\x2', '\x1213', '\x1215', '\x3', '\x2', '\x2', '\x2', '\x1214', 
		'\x1216', '\x5', '\x270', '\x139', '\x2', '\x1215', '\x1214', '\x3', '\x2', 
		'\x2', '\x2', '\x1215', '\x1216', '\x3', '\x2', '\x2', '\x2', '\x1216', 
		'\x1218', '\x3', '\x2', '\x2', '\x2', '\x1217', '\x1219', '\x5', '\x318', 
		'\x18D', '\x2', '\x1218', '\x1217', '\x3', '\x2', '\x2', '\x2', '\x1218', 
		'\x1219', '\x3', '\x2', '\x2', '\x2', '\x1219', '\x315', '\x3', '\x2', 
		'\x2', '\x2', '\x121A', '\x121B', '\t', ':', '\x2', '\x2', '\x121B', '\x317', 
		'\x3', '\x2', '\x2', '\x2', '\x121C', '\x121D', '\a', '.', '\x2', '\x2', 
		'\x121D', '\x121E', '\t', ' ', '\x2', '\x2', '\x121E', '\x319', '\x3', 
		'\x2', '\x2', '\x2', '\x121F', '\x1226', '\a', '\x223', '\x2', '\x2', 
		'\x1220', '\x1221', '\a', '\x142', '\x2', '\x2', '\x1221', '\x1227', '\a', 
		'\xE2', '\x2', '\x2', '\x1222', '\x1224', '\a', '\xE2', '\x2', '\x2', 
		'\x1223', '\x1225', '\x5', '\x31C', '\x18F', '\x2', '\x1224', '\x1223', 
		'\x3', '\x2', '\x2', '\x2', '\x1224', '\x1225', '\x3', '\x2', '\x2', '\x2', 
		'\x1225', '\x1227', '\x3', '\x2', '\x2', '\x2', '\x1226', '\x1220', '\x3', 
		'\x2', '\x2', '\x2', '\x1226', '\x1222', '\x3', '\x2', '\x2', '\x2', '\x1227', 
		'\x31B', '\x3', '\x2', '\x2', '\x2', '\x1228', '\x122B', '\x5', '\x378', 
		'\x1BD', '\x2', '\x1229', '\x122B', '\x5', '\x616', '\x30C', '\x2', '\x122A', 
		'\x1228', '\x3', '\x2', '\x2', '\x2', '\x122A', '\x1229', '\x3', '\x2', 
		'\x2', '\x2', '\x122B', '\x122C', '\x3', '\x2', '\x2', '\x2', '\x122C', 
		'\x122A', '\x3', '\x2', '\x2', '\x2', '\x122C', '\x122D', '\x3', '\x2', 
		'\x2', '\x2', '\x122D', '\x31D', '\x3', '\x2', '\x2', '\x2', '\x122E', 
		'\x122F', '\a', '\x1A9', '\x2', '\x2', '\x122F', '\x1233', '\x5', '\x320', 
		'\x191', '\x2', '\x1230', '\x1231', '\a', '\x13E', '\x2', '\x2', '\x1231', 
		'\x1233', '\a', '\x1A9', '\x2', '\x2', '\x1232', '\x122E', '\x3', '\x2', 
		'\x2', '\x2', '\x1232', '\x1230', '\x3', '\x2', '\x2', '\x2', '\x1233', 
		'\x31F', '\x3', '\x2', '\x2', '\x2', '\x1234', '\x123B', '\x5', '\x322', 
		'\x192', '\x2', '\x1235', '\x123B', '\x5', '\x324', '\x193', '\x2', '\x1236', 
		'\x123B', '\x5', '\x326', '\x194', '\x2', '\x1237', '\x123B', '\x5', '\x328', 
		'\x195', '\x2', '\x1238', '\x123B', '\x5', '\x32A', '\x196', '\x2', '\x1239', 
		'\x123B', '\x5', '\x32C', '\x197', '\x2', '\x123A', '\x1234', '\x3', '\x2', 
		'\x2', '\x2', '\x123A', '\x1235', '\x3', '\x2', '\x2', '\x2', '\x123A', 
		'\x1236', '\x3', '\x2', '\x2', '\x2', '\x123A', '\x1237', '\x3', '\x2', 
		'\x2', '\x2', '\x123A', '\x1238', '\x3', '\x2', '\x2', '\x2', '\x123A', 
		'\x1239', '\x3', '\x2', '\x2', '\x2', '\x123B', '\x123C', '\x3', '\x2', 
		'\x2', '\x2', '\x123C', '\x123A', '\x3', '\x2', '\x2', '\x2', '\x123C', 
		'\x123D', '\x3', '\x2', '\x2', '\x2', '\x123D', '\x321', '\x3', '\x2', 
		'\x2', '\x2', '\x123E', '\x123F', '\t', ';', '\x2', '\x2', '\x123F', '\x323', 
		'\x3', '\x2', '\x2', '\x2', '\x1240', '\x1241', '\a', '\x166', '\x2', 
		'\x2', '\x1241', '\x1242', '\t', '<', '\x2', '\x2', '\x1242', '\x325', 
		'\x3', '\x2', '\x2', '\x2', '\x1243', '\x1244', '\a', '\x1E6', '\x2', 
		'\x2', '\x1244', '\x1247', '\a', '\x234', '\x2', '\x2', '\x1245', '\x1247', 
		'\a', '\x141', '\x2', '\x2', '\x1246', '\x1243', '\x3', '\x2', '\x2', 
		'\x2', '\x1246', '\x1245', '\x3', '\x2', '\x2', '\x2', '\x1247', '\x1248', 
		'\x3', '\x2', '\x2', '\x2', '\x1248', '\x1249', '\x5', '\xA2', 'R', '\x2', 
		'\x1249', '\x327', '\x3', '\x2', '\x2', '\x2', '\x124A', '\x124E', '\a', 
		'\x234', '\x2', '\x2', '\x124B', '\x124C', '\a', '\x193', '\x2', '\x2', 
		'\x124C', '\x124F', '\a', '\xFF', '\x2', '\x2', '\x124D', '\x124F', '\a', 
		'\x1C0', '\x2', '\x2', '\x124E', '\x124B', '\x3', '\x2', '\x2', '\x2', 
		'\x124E', '\x124D', '\x3', '\x2', '\x2', '\x2', '\x124F', '\x329', '\x3', 
		'\x2', '\x2', '\x2', '\x1250', '\x125D', '\a', '\x223', '\x2', '\x2', 
		'\x1251', '\x1253', '\a', 'y', '\x2', '\x2', '\x1252', '\x1254', '\t', 
		'=', '\x2', '\x2', '\x1253', '\x1252', '\x3', '\x2', '\x2', '\x2', '\x1253', 
		'\x1254', '\x3', '\x2', '\x2', '\x2', '\x1254', '\x1255', '\x3', '\x2', 
		'\x2', '\x2', '\x1255', '\x1256', '\a', '\x1BB', '\x2', '\x2', '\x1256', 
		'\x125E', '\a', '\x1CF', '\x2', '\x2', '\x1257', '\x1259', '\t', '=', 
		'\x2', '\x2', '\x1258', '\x1257', '\x3', '\x2', '\x2', '\x2', '\x1258', 
		'\x1259', '\x3', '\x2', '\x2', '\x2', '\x1259', '\x125A', '\x3', '\x2', 
		'\x2', '\x2', '\x125A', '\x125B', '\a', '\x1BB', '\x2', '\x2', '\x125B', 
		'\x125C', '\a', '\x1CF', '\x2', '\x2', '\x125C', '\x125E', '\x5', '\\', 
		'/', '\x2', '\x125D', '\x1251', '\x3', '\x2', '\x2', '\x2', '\x125D', 
		'\x1258', '\x3', '\x2', '\x2', '\x2', '\x125E', '\x32B', '\x3', '\x2', 
		'\x2', '\x2', '\x125F', '\x1260', '\a', '\x223', '\x2', '\x2', '\x1260', 
		'\x1261', '\t', '>', '\x2', '\x2', '\x1261', '\x1262', '\a', '\\', '\x2', 
		'\x2', '\x1262', '\x32D', '\x3', '\x2', '\x2', '\x2', '\x1263', '\x1264', 
		'\a', '\xA3', '\x2', '\x2', '\x1264', '\x126B', '\a', '\x223', '\x2', 
		'\x2', '\x1265', '\x1266', '\a', 'h', '\x2', '\x2', '\x1266', '\x126C', 
		'\a', '\x92', '\x2', '\x2', '\x1267', '\x1268', '\a', '\x92', '\x2', '\x2', 
		'\x1268', '\x126C', '\x5', '\\', '/', '\x2', '\x1269', '\x126A', '\a', 
		'\x15E', '\x2', '\x2', '\x126A', '\x126C', '\a', '\x92', '\x2', '\x2', 
		'\x126B', '\x1265', '\x3', '\x2', '\x2', '\x2', '\x126B', '\x1267', '\x3', 
		'\x2', '\x2', '\x2', '\x126B', '\x1269', '\x3', '\x2', '\x2', '\x2', '\x126C', 
		'\x32F', '\x3', '\x2', '\x2', '\x2', '\x126D', '\x126E', '\t', '?', '\x2', 
		'\x2', '\x126E', '\x126F', '\a', '\x166', '\x2', '\x2', '\x126F', '\x1270', 
		'\a', '\x19A', '\x2', '\x2', '\x1270', '\x1271', '\a', 'U', '\x2', '\x2', 
		'\x1271', '\x331', '\x3', '\x2', '\x2', '\x2', '\x1272', '\x1273', '\t', 
		'?', '\x2', '\x2', '\x1273', '\x1274', '\a', '\x19A', '\x2', '\x2', '\x1274', 
		'\x1276', '\a', '\x1B9', '\x2', '\x2', '\x1275', '\x1277', '\x5', '\x334', 
		'\x19B', '\x2', '\x1276', '\x1275', '\x3', '\x2', '\x2', '\x2', '\x1276', 
		'\x1277', '\x3', '\x2', '\x2', '\x2', '\x1277', '\x1279', '\x3', '\x2', 
		'\x2', '\x2', '\x1278', '\x127A', '\x5', '\x336', '\x19C', '\x2', '\x1279', 
		'\x1278', '\x3', '\x2', '\x2', '\x2', '\x1279', '\x127A', '\x3', '\x2', 
		'\x2', '\x2', '\x127A', '\x333', '\x3', '\x2', '\x2', '\x2', '\x127B', 
		'\x127C', '\a', '\x21C', '\x2', '\x2', '\x127C', '\x1281', '\a', '#', 
		'\x2', '\x2', '\x127D', '\x127E', '\a', 'h', '\x2', '\x2', '\x127E', '\x1282', 
		'\a', '\x92', '\x2', '\x2', '\x127F', '\x1280', '\a', '\x92', '\x2', '\x2', 
		'\x1280', '\x1282', '\x5', '\\', '/', '\x2', '\x1281', '\x127D', '\x3', 
		'\x2', '\x2', '\x2', '\x1281', '\x127F', '\x3', '\x2', '\x2', '\x2', '\x1282', 
		'\x335', '\x3', '\x2', '\x2', '\x2', '\x1283', '\x1284', '\a', '\x21C', 
		'\x2', '\x2', '\x1284', '\x1285', '\a', '%', '\x2', '\x2', '\x1285', '\x128C', 
		'\a', '\x234', '\x2', '\x2', '\x1286', '\x1287', '\a', 'h', '\x2', '\x2', 
		'\x1287', '\x128D', '\a', '\x92', '\x2', '\x2', '\x1288', '\x1289', '\a', 
		'\x92', '\x2', '\x2', '\x1289', '\x128D', '\x5', '\\', '/', '\x2', '\x128A', 
		'\x128B', '\a', '\x15E', '\x2', '\x2', '\x128B', '\x128D', '\a', '\x92', 
		'\x2', '\x2', '\x128C', '\x1286', '\x3', '\x2', '\x2', '\x2', '\x128C', 
		'\x1288', '\x3', '\x2', '\x2', '\x2', '\x128C', '\x128A', '\x3', '\x2', 
		'\x2', '\x2', '\x128D', '\x337', '\x3', '\x2', '\x2', '\x2', '\x128E', 
		'\x1290', '\x5', '\x350', '\x1A9', '\x2', '\x128F', '\x128E', '\x3', '\x2', 
		'\x2', '\x2', '\x128F', '\x1290', '\x3', '\x2', '\x2', '\x2', '\x1290', 
		'\x1292', '\x3', '\x2', '\x2', '\x2', '\x1291', '\x1293', '\x5', '\x1DA', 
		'\xEE', '\x2', '\x1292', '\x1291', '\x3', '\x2', '\x2', '\x2', '\x1292', 
		'\x1293', '\x3', '\x2', '\x2', '\x2', '\x1293', '\x1295', '\x3', '\x2', 
		'\x2', '\x2', '\x1294', '\x1296', '\a', '\x94', '\x2', '\x2', '\x1295', 
		'\x1294', '\x3', '\x2', '\x2', '\x2', '\x1295', '\x1296', '\x3', '\x2', 
		'\x2', '\x2', '\x1296', '\x1297', '\x3', '\x2', '\x2', '\x2', '\x1297', 
		'\x1298', '\x5', '\x33A', '\x19E', '\x2', '\x1298', '\x1299', '\x5', '\x352', 
		'\x1AA', '\x2', '\x1299', '\x339', '\x3', '\x2', '\x2', '\x2', '\x129A', 
		'\x129B', '\a', '\x22D', '\x2', '\x2', '\x129B', '\x129F', '\x5', '\x46', 
		'$', '\x2', '\x129C', '\x12A0', '\x5', '\x356', '\x1AC', '\x2', '\x129D', 
		'\x12A0', '\x5', '\x33C', '\x19F', '\x2', '\x129E', '\x12A0', '\x5', '\x348', 
		'\x1A5', '\x2', '\x129F', '\x129C', '\x3', '\x2', '\x2', '\x2', '\x129F', 
		'\x129D', '\x3', '\x2', '\x2', '\x2', '\x129F', '\x129E', '\x3', '\x2', 
		'\x2', '\x2', '\x129F', '\x12A0', '\x3', '\x2', '\x2', '\x2', '\x12A0', 
		'\x12A2', '\x3', '\x2', '\x2', '\x2', '\x12A1', '\x12A3', '\x5', '\x18E', 
		'\xC8', '\x2', '\x12A2', '\x12A1', '\x3', '\x2', '\x2', '\x2', '\x12A2', 
		'\x12A3', '\x3', '\x2', '\x2', '\x2', '\x12A3', '\x12A4', '\x3', '\x2', 
		'\x2', '\x2', '\x12A4', '\x12A5', '\a', '\x15', '\x2', '\x2', '\x12A5', 
		'\x33B', '\x3', '\x2', '\x2', '\x2', '\x12A6', '\x12A7', '\a', '\x162', 
		'\x2', '\x2', '\x12A7', '\x12A8', '\a', '\x242', '\x2', '\x2', '\x12A8', 
		'\x12A9', '\x5', '\x33E', '\x1A0', '\x2', '\x12A9', '\x12AA', '\x5', '\x34C', 
		'\x1A7', '\x2', '\x12AA', '\x33D', '\x3', '\x2', '\x2', '\x2', '\x12AB', 
		'\x12AD', '\x5', '\x340', '\x1A1', '\x2', '\x12AC', '\x12AB', '\x3', '\x2', 
		'\x2', '\x2', '\x12AC', '\x12AD', '\x3', '\x2', '\x2', '\x2', '\x12AD', 
		'\x12AF', '\x3', '\x2', '\x2', '\x2', '\x12AE', '\x12B0', '\x5', '\x342', 
		'\x1A2', '\x2', '\x12AF', '\x12AE', '\x3', '\x2', '\x2', '\x2', '\x12AF', 
		'\x12B0', '\x3', '\x2', '\x2', '\x2', '\x12B0', '\x12B2', '\x3', '\x2', 
		'\x2', '\x2', '\x12B1', '\x12B3', '\x5', '\x24E', '\x128', '\x2', '\x12B2', 
		'\x12B1', '\x3', '\x2', '\x2', '\x2', '\x12B2', '\x12B3', '\x3', '\x2', 
		'\x2', '\x2', '\x12B3', '\x12B5', '\x3', '\x2', '\x2', '\x2', '\x12B4', 
		'\x12B6', '\x5', '\x344', '\x1A3', '\x2', '\x12B5', '\x12B4', '\x3', '\x2', 
		'\x2', '\x2', '\x12B5', '\x12B6', '\x3', '\x2', '\x2', '\x2', '\x12B6', 
		'\x12B8', '\x3', '\x2', '\x2', '\x2', '\x12B7', '\x12B9', '\x5', '\x346', 
		'\x1A4', '\x2', '\x12B8', '\x12B7', '\x3', '\x2', '\x2', '\x2', '\x12B8', 
		'\x12B9', '\x3', '\x2', '\x2', '\x2', '\x12B9', '\x33F', '\x3', '\x2', 
		'\x2', '\x2', '\x12BA', '\x12BB', '\a', '\x240', '\x2', '\x2', '\x12BB', 
		'\x12BC', '\x5', '\\', '/', '\x2', '\x12BC', '\x341', '\x3', '\x2', '\x2', 
		'\x2', '\x12BD', '\x12BE', '\a', '\x96', '\x2', '\x2', '\x12BE', '\x12C1', 
		'\x5', '\\', '/', '\x2', '\x12BF', '\x12C0', '\a', '\x258', '\x2', '\x2', 
		'\x12C0', '\x12C2', '\x5', '\\', '/', '\x2', '\x12C1', '\x12BF', '\x3', 
		'\x2', '\x2', '\x2', '\x12C1', '\x12C2', '\x3', '\x2', '\x2', '\x2', '\x12C2', 
		'\x343', '\x3', '\x2', '\x2', '\x2', '\x12C3', '\x12C4', '\t', '@', '\x2', 
		'\x2', '\x12C4', '\x12C5', '\a', '\x152', '\x2', '\x2', '\x12C5', '\x345', 
		'\x3', '\x2', '\x2', '\x2', '\x12C6', '\x12C7', '\t', '@', '\x2', '\x2', 
		'\x12C7', '\x12C8', '\a', '\x12', '\x2', '\x2', '\x12C8', '\x347', '\x3', 
		'\x2', '\x2', '\x2', '\x12C9', '\x12CA', '\a', '\x162', '\x2', '\x2', 
		'\x12CA', '\x12CD', '\x5', '\x46', '$', '\x2', '\x12CB', '\x12CE', '\x5', 
		'\x34C', '\x1A7', '\x2', '\x12CC', '\x12CE', '\x5', '\x34A', '\x1A6', 
		'\x2', '\x12CD', '\x12CB', '\x3', '\x2', '\x2', '\x2', '\x12CD', '\x12CC', 
		'\x3', '\x2', '\x2', '\x2', '\x12CE', '\x12D0', '\x3', '\x2', '\x2', '\x2', 
		'\x12CF', '\x12D1', '\x5', '\x35C', '\x1AF', '\x2', '\x12D0', '\x12CF', 
		'\x3', '\x2', '\x2', '\x2', '\x12D0', '\x12D1', '\x3', '\x2', '\x2', '\x2', 
		'\x12D1', '\x349', '\x3', '\x2', '\x2', '\x2', '\x12D2', '\x12D3', '\a', 
		'\x216', '\x2', '\x2', '\x12D3', '\x12D4', '\x5', '\x46', '$', '\x2', 
		'\x12D4', '\x34B', '\x3', '\x2', '\x2', '\x2', '\x12D5', '\x12D6', '\a', 
		'\x234', '\x2', '\x2', '\x12D6', '\x12D7', '\a', '\x161', '\x2', '\x2', 
		'\x12D7', '\x12DA', '\t', '\x41', '\x2', '\x2', '\x12D8', '\x12DB', '\x5', 
		'\x34E', '\x1A8', '\x2', '\x12D9', '\x12DB', '\a', 'y', '\x2', '\x2', 
		'\x12DA', '\x12D8', '\x3', '\x2', '\x2', '\x2', '\x12DA', '\x12D9', '\x3', 
		'\x2', '\x2', '\x2', '\x12DB', '\x34D', '\x3', '\x2', '\x2', '\x2', '\x12DC', 
		'\x12DD', '\a', '\x24B', '\x2', '\x2', '\x12DD', '\x12DE', '\x5', '\x166', 
		'\xB4', '\x2', '\x12DE', '\x12DF', '\a', '\x24C', '\x2', '\x2', '\x12DF', 
		'\x34F', '\x3', '\x2', '\x2', '\x2', '\x12E0', '\x12E2', '\a', '\x142', 
		'\x2', '\x2', '\x12E1', '\x12E0', '\x3', '\x2', '\x2', '\x2', '\x12E1', 
		'\x12E2', '\x3', '\x2', '\x2', '\x2', '\x12E2', '\x12E3', '\x3', '\x2', 
		'\x2', '\x2', '\x12E3', '\x12E4', '\a', '\xC0', '\x2', '\x2', '\x12E4', 
		'\x351', '\x3', '\x2', '\x2', '\x2', '\x12E5', '\x12E6', '\x5', '\x3EE', 
		'\x1F8', '\x2', '\x12E6', '\x353', '\x3', '\x2', '\x2', '\x2', '\x12E7', 
		'\x12EA', '\a', '\x234', '\x2', '\x2', '\x12E8', '\x12EB', '\x5', '\x3F4', 
		'\x1FB', '\x2', '\x12E9', '\x12EB', '\x5', '\x3F6', '\x1FC', '\x2', '\x12EA', 
		'\x12E8', '\x3', '\x2', '\x2', '\x2', '\x12EA', '\x12E9', '\x3', '\x2', 
		'\x2', '\x2', '\x12EB', '\x12ED', '\x3', '\x2', '\x2', '\x2', '\x12EC', 
		'\x12EE', '\x5', '\x3A0', '\x1D1', '\x2', '\x12ED', '\x12EC', '\x3', '\x2', 
		'\x2', '\x2', '\x12ED', '\x12EE', '\x3', '\x2', '\x2', '\x2', '\x12EE', 
		'\x355', '\x3', '\x2', '\x2', '\x2', '\x12EF', '\x12F0', '\a', '\x24B', 
		'\x2', '\x2', '\x12F0', '\x12F5', '\x5', '\x358', '\x1AD', '\x2', '\x12F1', 
		'\x12F2', '\a', '\x24D', '\x2', '\x2', '\x12F2', '\x12F4', '\x5', '\x358', 
		'\x1AD', '\x2', '\x12F3', '\x12F1', '\x3', '\x2', '\x2', '\x2', '\x12F4', 
		'\x12F7', '\x3', '\x2', '\x2', '\x2', '\x12F5', '\x12F3', '\x3', '\x2', 
		'\x2', '\x2', '\x12F5', '\x12F6', '\x3', '\x2', '\x2', '\x2', '\x12F6', 
		'\x12F8', '\x3', '\x2', '\x2', '\x2', '\x12F7', '\x12F5', '\x3', '\x2', 
		'\x2', '\x2', '\x12F8', '\x12F9', '\a', '\x24C', '\x2', '\x2', '\x12F9', 
		'\x357', '\x3', '\x2', '\x2', '\x2', '\x12FA', '\x12FD', '\x5', '\x35A', 
		'\x1AE', '\x2', '\x12FB', '\x12FD', '\x5', '\x362', '\x1B2', '\x2', '\x12FC', 
		'\x12FA', '\x3', '\x2', '\x2', '\x2', '\x12FC', '\x12FB', '\x3', '\x2', 
		'\x2', '\x2', '\x12FD', '\x359', '\x3', '\x2', '\x2', '\x2', '\x12FE', 
		'\x1302', '\x5', '\x46', '$', '\x2', '\x12FF', '\x1301', '\x5', '\x366', 
		'\x1B4', '\x2', '\x1300', '\x12FF', '\x3', '\x2', '\x2', '\x2', '\x1301', 
		'\x1304', '\x3', '\x2', '\x2', '\x2', '\x1302', '\x1300', '\x3', '\x2', 
		'\x2', '\x2', '\x1302', '\x1303', '\x3', '\x2', '\x2', '\x2', '\x1303', 
		'\x35B', '\x3', '\x2', '\x2', '\x2', '\x1304', '\x1302', '\x3', '\x2', 
		'\x2', '\x2', '\x1305', '\x1306', '\a', '\x24B', '\x2', '\x2', '\x1306', 
		'\x130B', '\x5', '\x35E', '\x1B0', '\x2', '\x1307', '\x1308', '\a', '\x24D', 
		'\x2', '\x2', '\x1308', '\x130A', '\x5', '\x35E', '\x1B0', '\x2', '\x1309', 
		'\x1307', '\x3', '\x2', '\x2', '\x2', '\x130A', '\x130D', '\x3', '\x2', 
		'\x2', '\x2', '\x130B', '\x1309', '\x3', '\x2', '\x2', '\x2', '\x130B', 
		'\x130C', '\x3', '\x2', '\x2', '\x2', '\x130C', '\x130E', '\x3', '\x2', 
		'\x2', '\x2', '\x130D', '\x130B', '\x3', '\x2', '\x2', '\x2', '\x130E', 
		'\x130F', '\a', '\x24C', '\x2', '\x2', '\x130F', '\x35D', '\x3', '\x2', 
		'\x2', '\x2', '\x1310', '\x1313', '\x5', '\x360', '\x1B1', '\x2', '\x1311', 
		'\x1313', '\x5', '\x362', '\x1B2', '\x2', '\x1312', '\x1310', '\x3', '\x2', 
		'\x2', '\x2', '\x1312', '\x1311', '\x3', '\x2', '\x2', '\x2', '\x1313', 
		'\x35F', '\x3', '\x2', '\x2', '\x2', '\x1314', '\x1316', '\x5', '\x44', 
		'#', '\x2', '\x1315', '\x1317', '\x5', '\x366', '\x1B4', '\x2', '\x1316', 
		'\x1315', '\x3', '\x2', '\x2', '\x2', '\x1317', '\x1318', '\x3', '\x2', 
		'\x2', '\x2', '\x1318', '\x1316', '\x3', '\x2', '\x2', '\x2', '\x1318', 
		'\x1319', '\x3', '\x2', '\x2', '\x2', '\x1319', '\x361', '\x3', '\x2', 
		'\x2', '\x2', '\x131A', '\x131C', '\x5', '\x3A0', '\x1D1', '\x2', '\x131B', 
		'\x131A', '\x3', '\x2', '\x2', '\x2', '\x131B', '\x131C', '\x3', '\x2', 
		'\x2', '\x2', '\x131C', '\x1321', '\x3', '\x2', '\x2', '\x2', '\x131D', 
		'\x1322', '\x5', '\x3A4', '\x1D3', '\x2', '\x131E', '\x1322', '\x5', '\x3A6', 
		'\x1D4', '\x2', '\x131F', '\x1322', '\x5', '\x3AC', '\x1D7', '\x2', '\x1320', 
		'\x1322', '\x5', '\x3A8', '\x1D5', '\x2', '\x1321', '\x131D', '\x3', '\x2', 
		'\x2', '\x2', '\x1321', '\x131E', '\x3', '\x2', '\x2', '\x2', '\x1321', 
		'\x131F', '\x3', '\x2', '\x2', '\x2', '\x1321', '\x1320', '\x3', '\x2', 
		'\x2', '\x2', '\x1322', '\x1324', '\x3', '\x2', '\x2', '\x2', '\x1323', 
		'\x1325', '\x5', '\x368', '\x1B5', '\x2', '\x1324', '\x1323', '\x3', '\x2', 
		'\x2', '\x2', '\x1324', '\x1325', '\x3', '\x2', '\x2', '\x2', '\x1325', 
		'\x363', '\x3', '\x2', '\x2', '\x2', '\x1326', '\x1329', '\a', '\x24B', 
		'\x2', '\x2', '\x1327', '\x132A', '\x5', '\x17A', '\xBE', '\x2', '\x1328', 
		'\x132A', '\x5', '\x178', '\xBD', '\x2', '\x1329', '\x1327', '\x3', '\x2', 
		'\x2', '\x2', '\x1329', '\x1328', '\x3', '\x2', '\x2', '\x2', '\x132A', 
		'\x1332', '\x3', '\x2', '\x2', '\x2', '\x132B', '\x132E', '\a', '\x24D', 
		'\x2', '\x2', '\x132C', '\x132F', '\x5', '\x17A', '\xBE', '\x2', '\x132D', 
		'\x132F', '\x5', '\x178', '\xBD', '\x2', '\x132E', '\x132C', '\x3', '\x2', 
		'\x2', '\x2', '\x132E', '\x132D', '\x3', '\x2', '\x2', '\x2', '\x132F', 
		'\x1331', '\x3', '\x2', '\x2', '\x2', '\x1330', '\x132B', '\x3', '\x2', 
		'\x2', '\x2', '\x1331', '\x1334', '\x3', '\x2', '\x2', '\x2', '\x1332', 
		'\x1330', '\x3', '\x2', '\x2', '\x2', '\x1332', '\x1333', '\x3', '\x2', 
		'\x2', '\x2', '\x1333', '\x1335', '\x3', '\x2', '\x2', '\x2', '\x1334', 
		'\x1332', '\x3', '\x2', '\x2', '\x2', '\x1335', '\x1336', '\a', '\x24C', 
		'\x2', '\x2', '\x1336', '\x365', '\x3', '\x2', '\x2', '\x2', '\x1337', 
		'\x1339', '\x5', '\x3A0', '\x1D1', '\x2', '\x1338', '\x1337', '\x3', '\x2', 
		'\x2', '\x2', '\x1338', '\x1339', '\x3', '\x2', '\x2', '\x2', '\x1339', 
		'\x133F', '\x3', '\x2', '\x2', '\x2', '\x133A', '\x1340', '\x5', '\x3A2', 
		'\x1D2', '\x2', '\x133B', '\x1340', '\x5', '\x3A4', '\x1D3', '\x2', '\x133C', 
		'\x1340', '\x5', '\x3A6', '\x1D4', '\x2', '\x133D', '\x1340', '\x5', '\x3AC', 
		'\x1D7', '\x2', '\x133E', '\x1340', '\x5', '\x3A8', '\x1D5', '\x2', '\x133F', 
		'\x133A', '\x3', '\x2', '\x2', '\x2', '\x133F', '\x133B', '\x3', '\x2', 
		'\x2', '\x2', '\x133F', '\x133C', '\x3', '\x2', '\x2', '\x2', '\x133F', 
		'\x133D', '\x3', '\x2', '\x2', '\x2', '\x133F', '\x133E', '\x3', '\x2', 
		'\x2', '\x2', '\x1340', '\x1342', '\x3', '\x2', '\x2', '\x2', '\x1341', 
		'\x1343', '\x5', '\x368', '\x1B5', '\x2', '\x1342', '\x1341', '\x3', '\x2', 
		'\x2', '\x2', '\x1342', '\x1343', '\x3', '\x2', '\x2', '\x2', '\x1343', 
		'\x367', '\x3', '\x2', '\x2', '\x2', '\x1344', '\x134C', '\x5', '\x36A', 
		'\x1B6', '\x2', '\x1345', '\x134C', '\x5', '\x36C', '\x1B7', '\x2', '\x1346', 
		'\x134C', '\x5', '\x370', '\x1B9', '\x2', '\x1347', '\x134C', '\x5', '\x372', 
		'\x1BA', '\x2', '\x1348', '\x134C', '\x5', '\x36E', '\x1B8', '\x2', '\x1349', 
		'\x134C', '\x5', '\x39A', '\x1CE', '\x2', '\x134A', '\x134C', '\x5', '\x39C', 
		'\x1CF', '\x2', '\x134B', '\x1344', '\x3', '\x2', '\x2', '\x2', '\x134B', 
		'\x1345', '\x3', '\x2', '\x2', '\x2', '\x134B', '\x1346', '\x3', '\x2', 
		'\x2', '\x2', '\x134B', '\x1347', '\x3', '\x2', '\x2', '\x2', '\x134B', 
		'\x1348', '\x3', '\x2', '\x2', '\x2', '\x134B', '\x1349', '\x3', '\x2', 
		'\x2', '\x2', '\x134B', '\x134A', '\x3', '\x2', '\x2', '\x2', '\x134C', 
		'\x134D', '\x3', '\x2', '\x2', '\x2', '\x134D', '\x134B', '\x3', '\x2', 
		'\x2', '\x2', '\x134D', '\x134E', '\x3', '\x2', '\x2', '\x2', '\x134E', 
		'\x369', '\x3', '\x2', '\x2', '\x2', '\x134F', '\x1351', '\a', '\x15A', 
		'\x2', '\x2', '\x1350', '\x134F', '\x3', '\x2', '\x2', '\x2', '\x1350', 
		'\x1351', '\x3', '\x2', '\x2', '\x2', '\x1351', '\x1352', '\x3', '\x2', 
		'\x2', '\x2', '\x1352', '\x1353', '\a', 'z', '\x2', '\x2', '\x1353', '\x36B', 
		'\x3', '\x2', '\x2', '\x2', '\x1354', '\x1355', '\a', '\xE8', '\x2', '\x2', 
		'\x1355', '\x1356', '\t', ' ', '\x2', '\x2', '\x1356', '\x36D', '\x3', 
		'\x2', '\x2', '\x2', '\x1357', '\x1358', '\t', '?', '\x2', '\x2', '\x1358', 
		'\x36F', '\x3', '\x2', '\x2', '\x2', '\x1359', '\x135A', '\t', '\x42', 
		'\x2', '\x2', '\x135A', '\x371', '\x3', '\x2', '\x2', '\x2', '\x135B', 
		'\x135C', '\a', '\x223', '\x2', '\x2', '\x135C', '\x135F', '\a', '\xE2', 
		'\x2', '\x2', '\x135D', '\x1360', '\x5', '\x374', '\x1BB', '\x2', '\x135E', 
		'\x1360', '\x5', '\x46', '$', '\x2', '\x135F', '\x135D', '\x3', '\x2', 
		'\x2', '\x2', '\x135F', '\x135E', '\x3', '\x2', '\x2', '\x2', '\x1360', 
		'\x373', '\x3', '\x2', '\x2', '\x2', '\x1361', '\x1367', '\x5', '\x376', 
		'\x1BC', '\x2', '\x1362', '\x1367', '\x5', '\x378', '\x1BD', '\x2', '\x1363', 
		'\x1367', '\x5', '\x37A', '\x1BE', '\x2', '\x1364', '\x1367', '\x5', '\x616', 
		'\x30C', '\x2', '\x1365', '\x1367', '\x5', '\x398', '\x1CD', '\x2', '\x1366', 
		'\x1361', '\x3', '\x2', '\x2', '\x2', '\x1366', '\x1362', '\x3', '\x2', 
		'\x2', '\x2', '\x1366', '\x1363', '\x3', '\x2', '\x2', '\x2', '\x1366', 
		'\x1364', '\x3', '\x2', '\x2', '\x2', '\x1366', '\x1365', '\x3', '\x2', 
		'\x2', '\x2', '\x1367', '\x1368', '\x3', '\x2', '\x2', '\x2', '\x1368', 
		'\x1366', '\x3', '\x2', '\x2', '\x2', '\x1368', '\x1369', '\x3', '\x2', 
		'\x2', '\x2', '\x1369', '\x375', '\x3', '\x2', '\x2', '\x2', '\x136A', 
		'\x136B', '\t', '\x43', '\x2', '\x2', '\x136B', '\x377', '\x3', '\x2', 
		'\x2', '\x2', '\x136C', '\x136E', '\a', '\x1FD', '\x2', '\x2', '\x136D', 
		'\x136F', '\a', '\x1D8', '\x2', '\x2', '\x136E', '\x136D', '\x3', '\x2', 
		'\x2', '\x2', '\x136E', '\x136F', '\x3', '\x2', '\x2', '\x2', '\x136F', 
		'\x1372', '\x3', '\x2', '\x2', '\x2', '\x1370', '\x1373', '\a', 'y', '\x2', 
		'\x2', '\x1371', '\x1373', '\x5', '^', '\x30', '\x2', '\x1372', '\x1370', 
		'\x3', '\x2', '\x2', '\x2', '\x1372', '\x1371', '\x3', '\x2', '\x2', '\x2', 
		'\x1373', '\x379', '\x3', '\x2', '\x2', '\x2', '\x1374', '\x1375', '\t', 
		'\x44', '\x2', '\x2', '\x1375', '\x37B', '\x3', '\x2', '\x2', '\x2', '\x1376', 
		'\x1377', '\a', '\x1EB', '\x2', '\x2', '\x1377', '\x1379', '\a', '\x24B', 
		'\x2', '\x2', '\x1378', '\x137A', '\x5', '\x37E', '\x1C0', '\x2', '\x1379', 
		'\x1378', '\x3', '\x2', '\x2', '\x2', '\x137A', '\x137B', '\x3', '\x2', 
		'\x2', '\x2', '\x137B', '\x1379', '\x3', '\x2', '\x2', '\x2', '\x137B', 
		'\x137C', '\x3', '\x2', '\x2', '\x2', '\x137C', '\x137D', '\x3', '\x2', 
		'\x2', '\x2', '\x137D', '\x137E', '\a', '\x24C', '\x2', '\x2', '\x137E', 
		'\x37D', '\x3', '\x2', '\x2', '\x2', '\x137F', '\x138C', '\x5', '\x384', 
		'\x1C3', '\x2', '\x1380', '\x138C', '\x5', '\x388', '\x1C5', '\x2', '\x1381', 
		'\x138C', '\x5', '\x38C', '\x1C7', '\x2', '\x1382', '\x138C', '\x5', '\x38E', 
		'\x1C8', '\x2', '\x1383', '\x138C', '\x5', '\x390', '\x1C9', '\x2', '\x1384', 
		'\x138C', '\x5', '\x386', '\x1C4', '\x2', '\x1385', '\x138C', '\x5', '\x38A', 
		'\x1C6', '\x2', '\x1386', '\x138C', '\x5', '\x392', '\x1CA', '\x2', '\x1387', 
		'\x138C', '\x5', '\x394', '\x1CB', '\x2', '\x1388', '\x138C', '\x5', '\x396', 
		'\x1CC', '\x2', '\x1389', '\x138C', '\x5', '\x380', '\x1C1', '\x2', '\x138A', 
		'\x138C', '\x5', '\x382', '\x1C2', '\x2', '\x138B', '\x137F', '\x3', '\x2', 
		'\x2', '\x2', '\x138B', '\x1380', '\x3', '\x2', '\x2', '\x2', '\x138B', 
		'\x1381', '\x3', '\x2', '\x2', '\x2', '\x138B', '\x1382', '\x3', '\x2', 
		'\x2', '\x2', '\x138B', '\x1383', '\x3', '\x2', '\x2', '\x2', '\x138B', 
		'\x1384', '\x3', '\x2', '\x2', '\x2', '\x138B', '\x1385', '\x3', '\x2', 
		'\x2', '\x2', '\x138B', '\x1386', '\x3', '\x2', '\x2', '\x2', '\x138B', 
		'\x1387', '\x3', '\x2', '\x2', '\x2', '\x138B', '\x1388', '\x3', '\x2', 
		'\x2', '\x2', '\x138B', '\x1389', '\x3', '\x2', '\x2', '\x2', '\x138B', 
		'\x138A', '\x3', '\x2', '\x2', '\x2', '\x138C', '\x37F', '\x3', '\x2', 
		'\x2', '\x2', '\x138D', '\x1390', '\a', '\x123', '\x2', '\x2', '\x138E', 
		'\x1391', '\a', '\x219', '\x2', '\x2', '\x138F', '\x1391', '\x5', '\x39E', 
		'\x1D0', '\x2', '\x1390', '\x138E', '\x3', '\x2', '\x2', '\x2', '\x1390', 
		'\x138F', '\x3', '\x2', '\x2', '\x2', '\x1391', '\x381', '\x3', '\x2', 
		'\x2', '\x2', '\x1392', '\x1393', '\a', '\x9B', '\x2', '\x2', '\x1393', 
		'\x383', '\x3', '\x2', '\x2', '\x2', '\x1394', '\x1395', '\t', '\x45', 
		'\x2', '\x2', '\x1395', '\x1396', '\x5', '\x39E', '\x1D0', '\x2', '\x1396', 
		'\x385', '\x3', '\x2', '\x2', '\x2', '\x1397', '\x139C', '\a', '\x16C', 
		'\x2', '\x2', '\x1398', '\x139D', '\a', '\x15E', '\x2', '\x2', '\x1399', 
		'\x139B', '\x5', '\x39E', '\x1D0', '\x2', '\x139A', '\x1399', '\x3', '\x2', 
		'\x2', '\x2', '\x139A', '\x139B', '\x3', '\x2', '\x2', '\x2', '\x139B', 
		'\x139D', '\x3', '\x2', '\x2', '\x2', '\x139C', '\x1398', '\x3', '\x2', 
		'\x2', '\x2', '\x139C', '\x139A', '\x3', '\x2', '\x2', '\x2', '\x139D', 
		'\x387', '\x3', '\x2', '\x2', '\x2', '\x139E', '\x139F', '\a', '\x12C', 
		'\x2', '\x2', '\x139F', '\x13A0', '\x5', '(', '\x15', '\x2', '\x13A0', 
		'\x389', '\x3', '\x2', '\x2', '\x2', '\x13A1', '\x13A4', '\a', '\x122', 
		'\x2', '\x2', '\x13A2', '\x13A5', '\a', '\x219', '\x2', '\x2', '\x13A3', 
		'\x13A5', '\x5', '(', '\x15', '\x2', '\x13A4', '\x13A2', '\x3', '\x2', 
		'\x2', '\x2', '\x13A4', '\x13A3', '\x3', '\x2', '\x2', '\x2', '\x13A5', 
		'\x38B', '\x3', '\x2', '\x2', '\x2', '\x13A6', '\x13A7', '\a', '\x184', 
		'\x2', '\x2', '\x13A7', '\x13A8', '\x5', '(', '\x15', '\x2', '\x13A8', 
		'\x38D', '\x3', '\x2', '\x2', '\x2', '\x13A9', '\x13AA', '\a', '\xC6', 
		'\x2', '\x2', '\x13AA', '\x13AB', '\x5', '(', '\x15', '\x2', '\x13AB', 
		'\x38F', '\x3', '\x2', '\x2', '\x2', '\x13AC', '\x13AD', '\a', '\xC5', 
		'\x2', '\x2', '\x13AD', '\x13AE', '\a', '\xD2', '\x2', '\x2', '\x13AE', 
		'\x13AF', '\x5', '(', '\x15', '\x2', '\x13AF', '\x391', '\x3', '\x2', 
		'\x2', '\x2', '\x13B0', '\x13B1', '\a', '-', '\x2', '\x2', '\x13B1', '\x13B2', 
		'\t', '\x46', '\x2', '\x2', '\x13B2', '\x393', '\x3', '\x2', '\x2', '\x2', 
		'\x13B3', '\x13B4', '\a', '\xC4', '\x2', '\x2', '\x13B4', '\x13B5', '\t', 
		'G', '\x2', '\x2', '\x13B5', '\x395', '\x3', '\x2', '\x2', '\x2', '\x13B6', 
		'\x13B7', '\a', ';', '\x2', '\x2', '\x13B7', '\x13B8', '\t', 'G', '\x2', 
		'\x2', '\x13B8', '\x397', '\x3', '\x2', '\x2', '\x2', '\x13B9', '\x13BA', 
		'\a', 'V', '\x2', '\x2', '\x13BA', '\x13BB', '\a', '\x1EA', '\x2', '\x2', 
		'\x13BB', '\x399', '\x3', '\x2', '\x2', '\x2', '\x13BC', '\x13BD', '\t', 
		'H', '\x2', '\x2', '\x13BD', '\x39B', '\x3', '\x2', '\x2', '\x2', '\x13BE', 
		'\x13BF', '\a', '\xA7', '\x2', '\x2', '\x13BF', '\x13C0', '\a', '\xF2', 
		'\x2', '\x2', '\x13C0', '\x13C1', '\x5', '\x46', '$', '\x2', '\x13C1', 
		'\x39D', '\x3', '\x2', '\x2', '\x2', '\x13C2', '\x13C3', '\t', 'I', '\x2', 
		'\x2', '\x13C3', '\x39F', '\x3', '\x2', '\x2', '\x2', '\x13C4', '\x13C5', 
		'\a', '[', '\x2', '\x2', '\x13C5', '\x13C6', '\x5', 'P', ')', '\x2', '\x13C6', 
		'\x3A1', '\x3', '\x2', '\x2', '\x2', '\x13C7', '\x13C9', '\a', '\x15A', 
		'\x2', '\x2', '\x13C8', '\x13C7', '\x3', '\x2', '\x2', '\x2', '\x13C8', 
		'\x13C9', '\x3', '\x2', '\x2', '\x2', '\x13C9', '\x13CA', '\x3', '\x2', 
		'\x2', '\x2', '\x13CA', '\x13CB', '\a', '\x15E', '\x2', '\x2', '\x13CB', 
		'\x3A3', '\x3', '\x2', '\x2', '\x2', '\x13CC', '\x13CE', '\a', '\x218', 
		'\x2', '\x2', '\x13CD', '\x13CF', '\x5', '\x364', '\x1B3', '\x2', '\x13CE', 
		'\x13CD', '\x3', '\x2', '\x2', '\x2', '\x13CE', '\x13CF', '\x3', '\x2', 
		'\x2', '\x2', '\x13CF', '\x3A5', '\x3', '\x2', '\x2', '\x2', '\x13D0', 
		'\x13D1', '\a', '\x193', '\x2', '\x2', '\x13D1', '\x13D3', '\a', '\xFF', 
		'\x2', '\x2', '\x13D2', '\x13D4', '\x5', '\x364', '\x1B3', '\x2', '\x13D3', 
		'\x13D2', '\x3', '\x2', '\x2', '\x2', '\x13D3', '\x13D4', '\x3', '\x2', 
		'\x2', '\x2', '\x13D4', '\x3A7', '\x3', '\x2', '\x2', '\x2', '\x13D5', 
		'\x13D6', '\a', '@', '\x2', '\x2', '\x13D6', '\x13D7', '\x5', '\x3AA', 
		'\x1D6', '\x2', '\x13D7', '\x3A9', '\x3', '\x2', '\x2', '\x2', '\x13D8', 
		'\x13D9', '\a', '\x24B', '\x2', '\x2', '\x13D9', '\x13DA', '\x5', '\xA2', 
		'R', '\x2', '\x13DA', '\x13DB', '\a', '\x24C', '\x2', '\x2', '\x13DB', 
		'\x3AB', '\x3', '\x2', '\x2', '\x2', '\x13DC', '\x13DD', '\a', '\xC1', 
		'\x2', '\x2', '\x13DD', '\x13DF', '\a', '\xFF', '\x2', '\x2', '\x13DE', 
		'\x13DC', '\x3', '\x2', '\x2', '\x2', '\x13DE', '\x13DF', '\x3', '\x2', 
		'\x2', '\x2', '\x13DF', '\x13E1', '\x3', '\x2', '\x2', '\x2', '\x13E0', 
		'\x13E2', '\x5', '\x364', '\x1B3', '\x2', '\x13E1', '\x13E0', '\x3', '\x2', 
		'\x2', '\x2', '\x13E1', '\x13E2', '\x3', '\x2', '\x2', '\x2', '\x13E2', 
		'\x13E3', '\x3', '\x2', '\x2', '\x2', '\x13E3', '\x13E5', '\x5', '\x3AE', 
		'\x1D8', '\x2', '\x13E4', '\x13E6', '\x5', '\x3B0', '\x1D9', '\x2', '\x13E5', 
		'\x13E4', '\x3', '\x2', '\x2', '\x2', '\x13E5', '\x13E6', '\x3', '\x2', 
		'\x2', '\x2', '\x13E6', '\x3AD', '\x3', '\x2', '\x2', '\x2', '\x13E7', 
		'\x13E8', '\a', '\x1A7', '\x2', '\x2', '\x13E8', '\x13EA', '\x5', '\x46', 
		'$', '\x2', '\x13E9', '\x13EB', '\x5', '\x364', '\x1B3', '\x2', '\x13EA', 
		'\x13E9', '\x3', '\x2', '\x2', '\x2', '\x13EA', '\x13EB', '\x3', '\x2', 
		'\x2', '\x2', '\x13EB', '\x3AF', '\x3', '\x2', '\x2', '\x2', '\x13EC', 
		'\x13ED', '\a', '\x166', '\x2', '\x2', '\x13ED', '\x13F1', '\a', '}', 
		'\x2', '\x2', '\x13EE', '\x13F2', '\a', '\x38', '\x2', '\x2', '\x13EF', 
		'\x13F0', '\a', '\x1D8', '\x2', '\x2', '\x13F0', '\x13F2', '\a', '\x15E', 
		'\x2', '\x2', '\x13F1', '\x13EE', '\x3', '\x2', '\x2', '\x2', '\x13F1', 
		'\x13EF', '\x3', '\x2', '\x2', '\x2', '\x13F2', '\x3B1', '\x3', '\x2', 
		'\x2', '\x2', '\x13F3', '\x13F4', '\a', '\x20E', '\x2', '\x2', '\x13F4', 
		'\x13F9', '\x5', '\x46', '$', '\x2', '\x13F5', '\x13FA', '\x5', '\x3B4', 
		'\x1DB', '\x2', '\x13F6', '\x13FA', '\x5', '\x3B6', '\x1DC', '\x2', '\x13F7', 
		'\x13FA', '\x5', '\x3B8', '\x1DD', '\x2', '\x13F8', '\x13FA', '\x5', '\x3BA', 
		'\x1DE', '\x2', '\x13F9', '\x13F5', '\x3', '\x2', '\x2', '\x2', '\x13F9', 
		'\x13F6', '\x3', '\x2', '\x2', '\x2', '\x13F9', '\x13F7', '\x3', '\x2', 
		'\x2', '\x2', '\x13F9', '\x13F8', '\x3', '\x2', '\x2', '\x2', '\x13FA', 
		'\x3B3', '\x3', '\x2', '\x2', '\x2', '\x13FB', '\x13FC', '\x5', '\x3D6', 
		'\x1EC', '\x2', '\x13FC', '\x13FE', '\x5', '\x3D8', '\x1ED', '\x2', '\x13FD', 
		'\x13FF', '\x5', '\x3CA', '\x1E6', '\x2', '\x13FE', '\x13FD', '\x3', '\x2', 
		'\x2', '\x2', '\x13FE', '\x13FF', '\x3', '\x2', '\x2', '\x2', '\x13FF', 
		'\x1402', '\x3', '\x2', '\x2', '\x2', '\x1400', '\x1403', '\x5', '\x3C2', 
		'\x1E2', '\x2', '\x1401', '\x1403', '\x5', '\x588', '\x2C5', '\x2', '\x1402', 
		'\x1400', '\x3', '\x2', '\x2', '\x2', '\x1402', '\x1401', '\x3', '\x2', 
		'\x2', '\x2', '\x1403', '\x3B5', '\x3', '\x2', '\x2', '\x2', '\x1404', 
		'\x1405', '\x5', '\x3D6', '\x1EC', '\x2', '\x1405', '\x1408', '\x5', '\x3D8', 
		'\x1ED', '\x2', '\x1406', '\x1409', '\x5', '\x3C2', '\x1E2', '\x2', '\x1407', 
		'\x1409', '\x5', '\x588', '\x2C5', '\x2', '\x1408', '\x1406', '\x3', '\x2', 
		'\x2', '\x2', '\x1408', '\x1407', '\x3', '\x2', '\x2', '\x2', '\x1409', 
		'\x3B7', '\x3', '\x2', '\x2', '\x2', '\x140A', '\x140B', '\x5', '\x3D6', 
		'\x1EC', '\x2', '\x140B', '\x140D', '\x5', '\x3D8', '\x1ED', '\x2', '\x140C', 
		'\x140E', '\x5', '\x3CA', '\x1E6', '\x2', '\x140D', '\x140C', '\x3', '\x2', 
		'\x2', '\x2', '\x140D', '\x140E', '\x3', '\x2', '\x2', '\x2', '\x140E', 
		'\x140F', '\x3', '\x2', '\x2', '\x2', '\x140F', '\x1410', '\x5', '\x3BC', 
		'\x1DF', '\x2', '\x1410', '\x3B9', '\x3', '\x2', '\x2', '\x2', '\x1411', 
		'\x1414', '\x5', '\x3D6', '\x1EC', '\x2', '\x1412', '\x1415', '\x5', '\x3CE', 
		'\x1E8', '\x2', '\x1413', '\x1415', '\x5', '\x3D0', '\x1E9', '\x2', '\x1414', 
		'\x1412', '\x3', '\x2', '\x2', '\x2', '\x1414', '\x1413', '\x3', '\x2', 
		'\x2', '\x2', '\x1415', '\x1416', '\x3', '\x2', '\x2', '\x2', '\x1416', 
		'\x1419', '\x5', '\x3CC', '\x1E7', '\x2', '\x1417', '\x141A', '\x5', '\x3C2', 
		'\x1E2', '\x2', '\x1418', '\x141A', '\x5', '\x588', '\x2C5', '\x2', '\x1419', 
		'\x1417', '\x3', '\x2', '\x2', '\x2', '\x1419', '\x1418', '\x3', '\x2', 
		'\x2', '\x2', '\x141A', '\x3BB', '\x3', '\x2', '\x2', '\x2', '\x141B', 
		'\x141C', '\a', 'S', '\x2', '\x2', '\x141C', '\x141E', '\a', '\x20E', 
		'\x2', '\x2', '\x141D', '\x141F', '\x5', '\x5A6', '\x2D4', '\x2', '\x141E', 
		'\x141D', '\x3', '\x2', '\x2', '\x2', '\x141E', '\x141F', '\x3', '\x2', 
		'\x2', '\x2', '\x141F', '\x1421', '\x3', '\x2', '\x2', '\x2', '\x1420', 
		'\x1422', '\x5', '\x3BE', '\x1E0', '\x2', '\x1421', '\x1420', '\x3', '\x2', 
		'\x2', '\x2', '\x1422', '\x1423', '\x3', '\x2', '\x2', '\x2', '\x1423', 
		'\x1421', '\x3', '\x2', '\x2', '\x2', '\x1423', '\x1424', '\x3', '\x2', 
		'\x2', '\x2', '\x1424', '\x1425', '\x3', '\x2', '\x2', '\x2', '\x1425', 
		'\x1426', '\x5', '\x58C', '\x2C7', '\x2', '\x1426', '\x3BD', '\x3', '\x2', 
		'\x2', '\x2', '\x1427', '\x1428', '\x5', '\x3C0', '\x1E1', '\x2', '\x1428', 
		'\x1429', '\a', '\xF6', '\x2', '\x2', '\x1429', '\x142A', '\x5', '\x58A', 
		'\x2C6', '\x2', '\x142A', '\x142B', '\x5', '\x3C0', '\x1E1', '\x2', '\x142B', 
		'\x142C', '\a', '\x24E', '\x2', '\x2', '\x142C', '\x3BF', '\x3', '\x2', 
		'\x2', '\x2', '\x142D', '\x142E', '\t', 'J', '\x2', '\x2', '\x142E', '\x1438', 
		'\a', '\x1E8', '\x2', '\x2', '\x142F', '\x1434', '\a', '#', '\x2', '\x2', 
		'\x1430', '\x1434', '\a', '\a', '\x2', '\x2', '\x1431', '\x1432', '\a', 
		'\xEE', '\x2', '\x2', '\x1432', '\x1434', '\a', '\x162', '\x2', '\x2', 
		'\x1433', '\x142F', '\x3', '\x2', '\x2', '\x2', '\x1433', '\x1430', '\x3', 
		'\x2', '\x2', '\x2', '\x1433', '\x1431', '\x3', '\x2', '\x2', '\x2', '\x1434', 
		'\x1435', '\x3', '\x2', '\x2', '\x2', '\x1435', '\x1436', '\a', '\x91', 
		'\x2', '\x2', '\x1436', '\x1438', '\a', '\x1BD', '\x2', '\x2', '\x1437', 
		'\x142D', '\x3', '\x2', '\x2', '\x2', '\x1437', '\x1433', '\x3', '\x2', 
		'\x2', '\x2', '\x1438', '\x3C1', '\x3', '\x2', '\x2', '\x2', '\x1439', 
		'\x143A', '\a', '\x37', '\x2', '\x2', '\x143A', '\x143C', '\x5', '\x44', 
		'#', '\x2', '\x143B', '\x143D', '\x5', '\x3C6', '\x1E4', '\x2', '\x143C', 
		'\x143B', '\x3', '\x2', '\x2', '\x2', '\x143C', '\x143D', '\x3', '\x2', 
		'\x2', '\x2', '\x143D', '\x3C3', '\x3', '\x2', '\x2', '\x2', '\x143E', 
		'\x143F', '\x5', '\xA2', 'R', '\x2', '\x143F', '\x1440', '\a', '\x25C', 
		'\x2', '\x2', '\x1440', '\x1441', '\x5', '\x44', '#', '\x2', '\x1441', 
		'\x3C5', '\x3', '\x2', '\x2', '\x2', '\x1442', '\x1443', '\a', '\xF2', 
		'\x2', '\x2', '\x1443', '\x1445', '\x5', 'P', ')', '\x2', '\x1444', '\x1446', 
		'\x5', '\x3C8', '\x1E5', '\x2', '\x1445', '\x1444', '\x3', '\x2', '\x2', 
		'\x2', '\x1445', '\x1446', '\x3', '\x2', '\x2', '\x2', '\x1446', '\x3C7', 
		'\x3', '\x2', '\x2', '\x2', '\x1447', '\x1449', '\a', '\xE5', '\x2', '\x2', 
		'\x1448', '\x1447', '\x3', '\x2', '\x2', '\x2', '\x1448', '\x1449', '\x3', 
		'\x2', '\x2', '\x2', '\x1449', '\x144A', '\x3', '\x2', '\x2', '\x2', '\x144A', 
		'\x144B', '\x5', 'P', ')', '\x2', '\x144B', '\x3C9', '\x3', '\x2', '\x2', 
		'\x2', '\x144C', '\x144D', '\a', '\x231', '\x2', '\x2', '\x144D', '\x144E', 
		'\x5', '\x3AA', '\x1D6', '\x2', '\x144E', '\x3CB', '\x3', '\x2', '\x2', 
		'\x2', '\x144F', '\x1450', '\a', '\x166', '\x2', '\x2', '\x1450', '\x1451', 
		'\t', 'K', '\x2', '\x2', '\x1451', '\x3CD', '\x3', '\x2', '\x2', '\x2', 
		'\x1452', '\x1457', '\x5', '\x3D2', '\x1EA', '\x2', '\x1453', '\x1454', 
		'\a', '\x16E', '\x2', '\x2', '\x1454', '\x1456', '\x5', '\x3D2', '\x1EA', 
		'\x2', '\x1455', '\x1453', '\x3', '\x2', '\x2', '\x2', '\x1456', '\x1459', 
		'\x3', '\x2', '\x2', '\x2', '\x1457', '\x1455', '\x3', '\x2', '\x2', '\x2', 
		'\x1457', '\x1458', '\x3', '\x2', '\x2', '\x2', '\x1458', '\x3CF', '\x3', 
		'\x2', '\x2', '\x2', '\x1459', '\x1457', '\x3', '\x2', '\x2', '\x2', '\x145A', 
		'\x145F', '\x5', '\x3D4', '\x1EB', '\x2', '\x145B', '\x145C', '\a', '\x16E', 
		'\x2', '\x2', '\x145C', '\x145E', '\x5', '\x3D4', '\x1EB', '\x2', '\x145D', 
		'\x145B', '\x3', '\x2', '\x2', '\x2', '\x145E', '\x1461', '\x3', '\x2', 
		'\x2', '\x2', '\x145F', '\x145D', '\x3', '\x2', '\x2', '\x2', '\x145F', 
		'\x1460', '\x3', '\x2', '\x2', '\x2', '\x1460', '\x3D1', '\x3', '\x2', 
		'\x2', '\x2', '\x1461', '\x145F', '\x3', '\x2', '\x2', '\x2', '\x1462', 
		'\x1473', '\a', '\r', '\x2', '\x2', '\x1463', '\x1473', '\a', '\xF', '\x2', 
		'\x2', '\x1464', '\x1465', '\a', '\x17', '\x2', '\x2', '\x1465', '\x1473', 
		'\a', '\x1EA', '\x2', '\x2', '\x1466', '\x1473', '\a', '\x1B', '\x2', 
		'\x2', '\x1467', '\x1473', '\a', 'M', '\x2', '\x2', '\x1468', '\x1473', 
		'\a', '\x64', '\x2', '\x2', '\x1469', '\x146A', '\a', '\x8C', '\x2', '\x2', 
		'\x146A', '\x1473', '\a', '\x1EA', '\x2', '\x2', '\x146B', '\x1473', '\a', 
		'\x8F', '\x2', '\x2', '\x146C', '\x1473', '\a', '\xCF', '\x2', '\x2', 
		'\x146D', '\x1473', '\a', '\x143', '\x2', '\x2', '\x146E', '\x1473', '\a', 
		'\x1AE', '\x2', '\x2', '\x146F', '\x1473', '\a', '\x1B8', '\x2', '\x2', 
		'\x1470', '\x1473', '\a', '\x211', '\x2', '\x2', '\x1471', '\x1473', '\a', 
		'r', '\x2', '\x2', '\x1472', '\x1462', '\x3', '\x2', '\x2', '\x2', '\x1472', 
		'\x1463', '\x3', '\x2', '\x2', '\x2', '\x1472', '\x1464', '\x3', '\x2', 
		'\x2', '\x2', '\x1472', '\x1466', '\x3', '\x2', '\x2', '\x2', '\x1472', 
		'\x1467', '\x3', '\x2', '\x2', '\x2', '\x1472', '\x1468', '\x3', '\x2', 
		'\x2', '\x2', '\x1472', '\x1469', '\x3', '\x2', '\x2', '\x2', '\x1472', 
		'\x146B', '\x3', '\x2', '\x2', '\x2', '\x1472', '\x146C', '\x3', '\x2', 
		'\x2', '\x2', '\x1472', '\x146D', '\x3', '\x2', '\x2', '\x2', '\x1472', 
		'\x146E', '\x3', '\x2', '\x2', '\x2', '\x1472', '\x146F', '\x3', '\x2', 
		'\x2', '\x2', '\x1472', '\x1470', '\x3', '\x2', '\x2', '\x2', '\x1472', 
		'\x1471', '\x3', '\x2', '\x2', '\x2', '\x1473', '\x3D3', '\x3', '\x2', 
		'\x2', '\x2', '\x1474', '\x1475', '\t', 'L', '\x2', '\x2', '\x1475', '\x3D5', 
		'\x3', '\x2', '\x2', '\x2', '\x1476', '\x147C', '\a', '#', '\x2', '\x2', 
		'\x1477', '\x147C', '\a', '\a', '\x2', '\x2', '\x1478', '\x1479', '\a', 
		'\xEE', '\x2', '\x2', '\x1479', '\x147C', '\a', '\x162', '\x2', '\x2', 
		'\x147A', '\x147C', '\a', '\xBE', '\x2', '\x2', '\x147B', '\x1476', '\x3', 
		'\x2', '\x2', '\x2', '\x147B', '\x1477', '\x3', '\x2', '\x2', '\x2', '\x147B', 
		'\x1478', '\x3', '\x2', '\x2', '\x2', '\x147B', '\x147A', '\x3', '\x2', 
		'\x2', '\x2', '\x147C', '\x3D7', '\x3', '\x2', '\x2', '\x2', '\x147D', 
		'\x147E', '\x5', '\x3DA', '\x1EE', '\x2', '\x147E', '\x1480', '\x5', '\x3E0', 
		'\x1F1', '\x2', '\x147F', '\x1481', '\x5', '\x3E4', '\x1F3', '\x2', '\x1480', 
		'\x147F', '\x3', '\x2', '\x2', '\x2', '\x1480', '\x1481', '\x3', '\x2', 
		'\x2', '\x2', '\x1481', '\x1483', '\x3', '\x2', '\x2', '\x2', '\x1482', 
		'\x1484', '\x5', '\x3E8', '\x1F5', '\x2', '\x1483', '\x1482', '\x3', '\x2', 
		'\x2', '\x2', '\x1483', '\x1484', '\x3', '\x2', '\x2', '\x2', '\x1484', 
		'\x3D9', '\x3', '\x2', '\x2', '\x2', '\x1485', '\x148A', '\x5', '\x3DC', 
		'\x1EF', '\x2', '\x1486', '\x1487', '\a', '\x16E', '\x2', '\x2', '\x1487', 
		'\x1489', '\x5', '\x3DC', '\x1EF', '\x2', '\x1488', '\x1486', '\x3', '\x2', 
		'\x2', '\x2', '\x1489', '\x148C', '\x3', '\x2', '\x2', '\x2', '\x148A', 
		'\x1488', '\x3', '\x2', '\x2', '\x2', '\x148A', '\x148B', '\x3', '\x2', 
		'\x2', '\x2', '\x148B', '\x3DB', '\x3', '\x2', '\x2', '\x2', '\x148C', 
		'\x148A', '\x3', '\x2', '\x2', '\x2', '\x148D', '\x148F', '\t', 'M', '\x2', 
		'\x2', '\x148E', '\x1490', '\x5', '\x3DE', '\x1F0', '\x2', '\x148F', '\x148E', 
		'\x3', '\x2', '\x2', '\x2', '\x148F', '\x1490', '\x3', '\x2', '\x2', '\x2', 
		'\x1490', '\x3DD', '\x3', '\x2', '\x2', '\x2', '\x1491', '\x1492', '\a', 
		'\x162', '\x2', '\x2', '\x1492', '\x1493', '\x5', '\x176', '\xBC', '\x2', 
		'\x1493', '\x3DF', '\x3', '\x2', '\x2', '\x2', '\x1494', '\x1499', '\a', 
		'\x166', '\x2', '\x2', '\x1495', '\x1496', '\x5', '\x3E2', '\x1F2', '\x2', 
		'\x1496', '\x1497', '\x5', '\x46', '$', '\x2', '\x1497', '\x149A', '\x3', 
		'\x2', '\x2', '\x2', '\x1498', '\x149A', '\x5', '\x46', '$', '\x2', '\x1499', 
		'\x1495', '\x3', '\x2', '\x2', '\x2', '\x1499', '\x1498', '\x3', '\x2', 
		'\x2', '\x2', '\x149A', '\x3E1', '\x3', '\x2', '\x2', '\x2', '\x149B', 
		'\x149C', '\a', '\x13D', '\x2', '\x2', '\x149C', '\x149D', '\a', '\x1FB', 
		'\x2', '\x2', '\x149D', '\x149E', '\x5', '^', '\x30', '\x2', '\x149E', 
		'\x149F', '\a', '\x162', '\x2', '\x2', '\x149F', '\x3E3', '\x3', '\x2', 
		'\x2', '\x2', '\x14A0', '\x14A2', '\a', '\x1A8', '\x2', '\x2', '\x14A1', 
		'\x14A3', '\x5', '\x3E6', '\x1F4', '\x2', '\x14A2', '\x14A1', '\x3', '\x2', 
		'\x2', '\x2', '\x14A3', '\x14A4', '\x3', '\x2', '\x2', '\x2', '\x14A4', 
		'\x14A2', '\x3', '\x2', '\x2', '\x2', '\x14A4', '\x14A5', '\x3', '\x2', 
		'\x2', '\x2', '\x14A5', '\x3E5', '\x3', '\x2', '\x2', '\x2', '\x14A6', 
		'\x14A8', '\t', 'N', '\x2', '\x2', '\x14A7', '\x14A9', '\a', '\x15', '\x2', 
		'\x2', '\x14A8', '\x14A7', '\x3', '\x2', '\x2', '\x2', '\x14A8', '\x14A9', 
		'\x3', '\x2', '\x2', '\x2', '\x14A9', '\x14AA', '\x3', '\x2', '\x2', '\x2', 
		'\x14AA', '\x14AB', '\x5', 'P', ')', '\x2', '\x14AB', '\x3E7', '\x3', 
		'\x2', '\x2', '\x2', '\x14AC', '\x14AD', '\a', '\xBE', '\x2', '\x2', '\x14AD', 
		'\x14AE', '\a', '\x91', '\x2', '\x2', '\x14AE', '\x14AF', '\a', '\x1BD', 
		'\x2', '\x2', '\x14AF', '\x3E9', '\x3', '\x2', '\x2', '\x2', '\x14B0', 
		'\x14B1', '\a', '\x1B5', '\x2', '\x2', '\x14B1', '\x14B4', '\x5', '\x166', 
		'\xB4', '\x2', '\x14B2', '\x14B5', '\x5', '\x422', '\x212', '\x2', '\x14B3', 
		'\x14B5', '\x5', '\x4F6', '\x27C', '\x2', '\x14B4', '\x14B2', '\x3', '\x2', 
		'\x2', '\x2', '\x14B4', '\x14B3', '\x3', '\x2', '\x2', '\x2', '\x14B5', 
		'\x3EB', '\x3', '\x2', '\x2', '\x2', '\x14B6', '\x14B7', '\a', '\x167', 
		'\x2', '\x2', '\x14B7', '\x14B8', '\a', '\x24B', '\x2', '\x2', '\x14B8', 
		'\x14B9', '\x5', '\x460', '\x231', '\x2', '\x14B9', '\x14BA', '\a', '\x24C', 
		'\x2', '\x2', '\x14BA', '\x3ED', '\x3', '\x2', '\x2', '\x2', '\x14BB', 
		'\x14BD', '\x5', '\x40E', '\x208', '\x2', '\x14BC', '\x14BB', '\x3', '\x2', 
		'\x2', '\x2', '\x14BC', '\x14BD', '\x3', '\x2', '\x2', '\x2', '\x14BD', 
		'\x14BE', '\x3', '\x2', '\x2', '\x2', '\x14BE', '\x14C4', '\x5', '\x3F0', 
		'\x1F9', '\x2', '\x14BF', '\x14C0', '\x5', '\x3F2', '\x1FA', '\x2', '\x14C0', 
		'\x14C1', '\x5', '\x3F0', '\x1F9', '\x2', '\x14C1', '\x14C3', '\x3', '\x2', 
		'\x2', '\x2', '\x14C2', '\x14BF', '\x3', '\x2', '\x2', '\x2', '\x14C3', 
		'\x14C6', '\x3', '\x2', '\x2', '\x2', '\x14C4', '\x14C2', '\x3', '\x2', 
		'\x2', '\x2', '\x14C4', '\x14C5', '\x3', '\x2', '\x2', '\x2', '\x14C5', 
		'\x14CF', '\x3', '\x2', '\x2', '\x2', '\x14C6', '\x14C4', '\x3', '\x2', 
		'\x2', '\x2', '\x14C7', '\x14C9', '\x5', '\x3FC', '\x1FF', '\x2', '\x14C8', 
		'\x14CA', '\x5', '\x406', '\x204', '\x2', '\x14C9', '\x14C8', '\x3', '\x2', 
		'\x2', '\x2', '\x14C9', '\x14CA', '\x3', '\x2', '\x2', '\x2', '\x14CA', 
		'\x14D0', '\x3', '\x2', '\x2', '\x2', '\x14CB', '\x14CD', '\x5', '\x406', 
		'\x204', '\x2', '\x14CC', '\x14CE', '\x5', '\x3FC', '\x1FF', '\x2', '\x14CD', 
		'\x14CC', '\x3', '\x2', '\x2', '\x2', '\x14CD', '\x14CE', '\x3', '\x2', 
		'\x2', '\x2', '\x14CE', '\x14D0', '\x3', '\x2', '\x2', '\x2', '\x14CF', 
		'\x14C7', '\x3', '\x2', '\x2', '\x2', '\x14CF', '\x14CB', '\x3', '\x2', 
		'\x2', '\x2', '\x14CF', '\x14D0', '\x3', '\x2', '\x2', '\x2', '\x14D0', 
		'\x14D2', '\x3', '\x2', '\x2', '\x2', '\x14D1', '\x14D3', '\x5', '\x354', 
		'\x1AB', '\x2', '\x14D2', '\x14D1', '\x3', '\x2', '\x2', '\x2', '\x14D2', 
		'\x14D3', '\x3', '\x2', '\x2', '\x2', '\x14D3', '\x3EF', '\x3', '\x2', 
		'\x2', '\x2', '\x14D4', '\x14DA', '\x5', '\x41E', '\x210', '\x2', '\x14D5', 
		'\x14D6', '\a', '\x24B', '\x2', '\x2', '\x14D6', '\x14D7', '\x5', '\x3EE', 
		'\x1F8', '\x2', '\x14D7', '\x14D8', '\a', '\x24C', '\x2', '\x2', '\x14D8', 
		'\x14DA', '\x3', '\x2', '\x2', '\x2', '\x14D9', '\x14D4', '\x3', '\x2', 
		'\x2', '\x2', '\x14D9', '\x14D5', '\x3', '\x2', '\x2', '\x2', '\x14DA', 
		'\x3F1', '\x3', '\x2', '\x2', '\x2', '\x14DB', '\x14DC', '\a', '\x217', 
		'\x2', '\x2', '\x14DC', '\x14E1', '\a', '\n', '\x2', '\x2', '\x14DD', 
		'\x14E1', '\a', '\x217', '\x2', '\x2', '\x14DE', '\x14E1', '\a', '\x12D', 
		'\x2', '\x2', '\x14DF', '\x14E1', '\a', '\xF0', '\x2', '\x2', '\x14E0', 
		'\x14DB', '\x3', '\x2', '\x2', '\x2', '\x14E0', '\x14DD', '\x3', '\x2', 
		'\x2', '\x2', '\x14E0', '\x14DE', '\x3', '\x2', '\x2', '\x2', '\x14E0', 
		'\x14DF', '\x3', '\x2', '\x2', '\x2', '\x14E1', '\x3F3', '\x3', '\x2', 
		'\x2', '\x2', '\x14E2', '\x14E3', '\a', '@', '\x2', '\x2', '\x14E3', '\x14E4', 
		'\a', '\x16D', '\x2', '\x2', '\x14E4', '\x3F5', '\x3', '\x2', '\x2', '\x2', 
		'\x14E5', '\x14E6', '\a', '\x1A0', '\x2', '\x2', '\x14E6', '\x14E7', '\a', 
		'\x167', '\x2', '\x2', '\x14E7', '\x3F7', '\x3', '\x2', '\x2', '\x2', 
		'\x14E8', '\x14EA', '\a', '\x16F', '\x2', '\x2', '\x14E9', '\x14EB', '\a', 
		'\x1DE', '\x2', '\x2', '\x14EA', '\x14E9', '\x3', '\x2', '\x2', '\x2', 
		'\x14EA', '\x14EB', '\x3', '\x2', '\x2', '\x2', '\x14EB', '\x14EC', '\x3', 
		'\x2', '\x2', '\x2', '\x14EC', '\x14ED', '\a', '\x33', '\x2', '\x2', '\x14ED', 
		'\x14EE', '\x5', '\x3FE', '\x200', '\x2', '\x14EE', '\x3F9', '\x3', '\x2', 
		'\x2', '\x2', '\x14EF', '\x14F1', '\a', '\x16F', '\x2', '\x2', '\x14F0', 
		'\x14F2', '\a', '\x1DE', '\x2', '\x2', '\x14F1', '\x14F0', '\x3', '\x2', 
		'\x2', '\x2', '\x14F1', '\x14F2', '\x3', '\x2', '\x2', '\x2', '\x14F2', 
		'\x14F3', '\x3', '\x2', '\x2', '\x2', '\x14F3', '\x14F4', '\a', '\x33', 
		'\x2', '\x2', '\x14F4', '\x14F5', '\x5', '\x3FE', '\x200', '\x2', '\x14F5', 
		'\x3FB', '\x3', '\x2', '\x2', '\x2', '\x14F6', '\x14F8', '\a', '\x16F', 
		'\x2', '\x2', '\x14F7', '\x14F9', '\a', '\x1DE', '\x2', '\x2', '\x14F8', 
		'\x14F7', '\x3', '\x2', '\x2', '\x2', '\x14F8', '\x14F9', '\x3', '\x2', 
		'\x2', '\x2', '\x14F9', '\x14FA', '\x3', '\x2', '\x2', '\x2', '\x14FA', 
		'\x14FB', '\a', '\x33', '\x2', '\x2', '\x14FB', '\x14FC', '\x5', '\x3FE', 
		'\x200', '\x2', '\x14FC', '\x3FD', '\x3', '\x2', '\x2', '\x2', '\x14FD', 
		'\x1502', '\x5', '\x400', '\x201', '\x2', '\x14FE', '\x14FF', '\a', '\x24D', 
		'\x2', '\x2', '\x14FF', '\x1501', '\x5', '\x400', '\x201', '\x2', '\x1500', 
		'\x14FE', '\x3', '\x2', '\x2', '\x2', '\x1501', '\x1504', '\x3', '\x2', 
		'\x2', '\x2', '\x1502', '\x1500', '\x3', '\x2', '\x2', '\x2', '\x1502', 
		'\x1503', '\x3', '\x2', '\x2', '\x2', '\x1503', '\x3FF', '\x3', '\x2', 
		'\x2', '\x2', '\x1504', '\x1502', '\x3', '\x2', '\x2', '\x2', '\x1505', 
		'\x1507', '\x5', '\xA2', 'R', '\x2', '\x1506', '\x1508', '\x5', '\x402', 
		'\x202', '\x2', '\x1507', '\x1506', '\x3', '\x2', '\x2', '\x2', '\x1507', 
		'\x1508', '\x3', '\x2', '\x2', '\x2', '\x1508', '\x150A', '\x3', '\x2', 
		'\x2', '\x2', '\x1509', '\x150B', '\x5', '\x404', '\x203', '\x2', '\x150A', 
		'\x1509', '\x3', '\x2', '\x2', '\x2', '\x150A', '\x150B', '\x3', '\x2', 
		'\x2', '\x2', '\x150B', '\x401', '\x3', '\x2', '\x2', '\x2', '\x150C', 
		'\x150D', '\t', '!', '\x2', '\x2', '\x150D', '\x403', '\x3', '\x2', '\x2', 
		'\x2', '\x150E', '\x150F', '\a', '\x15F', '\x2', '\x2', '\x150F', '\x1510', 
		'\t', '\x13', '\x2', '\x2', '\x1510', '\x405', '\x3', '\x2', '\x2', '\x2', 
		'\x1511', '\x1512', '\a', '\xBE', '\x2', '\x2', '\x1512', '\x1516', '\a', 
		'\x21E', '\x2', '\x2', '\x1513', '\x1514', '\x5', '\x408', '\x205', '\x2', 
		'\x1514', '\x1515', '\x5', '\x174', '\xBB', '\x2', '\x1515', '\x1517', 
		'\x3', '\x2', '\x2', '\x2', '\x1516', '\x1513', '\x3', '\x2', '\x2', '\x2', 
		'\x1516', '\x1517', '\x3', '\x2', '\x2', '\x2', '\x1517', '\x151A', '\x3', 
		'\x2', '\x2', '\x2', '\x1518', '\x151B', '\x5', '\x40A', '\x206', '\x2', 
		'\x1519', '\x151B', '\x5', '\x40C', '\x207', '\x2', '\x151A', '\x1518', 
		'\x3', '\x2', '\x2', '\x2', '\x151A', '\x1519', '\x3', '\x2', '\x2', '\x2', 
		'\x151A', '\x151B', '\x3', '\x2', '\x2', '\x2', '\x151B', '\x407', '\x3', 
		'\x2', '\x2', '\x2', '\x151C', '\x151D', '\a', '\x162', '\x2', '\x2', 
		'\x151D', '\x409', '\x3', '\x2', '\x2', '\x2', '\x151E', '\x1522', '\a', 
		'\x15D', '\x2', '\x2', '\x151F', '\x1520', '\a', '\x230', '\x2', '\x2', 
		'\x1520', '\x1522', '\x5', '(', '\x15', '\x2', '\x1521', '\x151E', '\x3', 
		'\x2', '\x2', '\x2', '\x1521', '\x151F', '\x3', '\x2', '\x2', '\x2', '\x1522', 
		'\x40B', '\x3', '\x2', '\x2', '\x2', '\x1523', '\x1524', '\a', '\x1E0', 
		'\x2', '\x2', '\x1524', '\x1525', '\a', '\x113', '\x2', '\x2', '\x1525', 
		'\x40D', '\x3', '\x2', '\x2', '\x2', '\x1526', '\x1527', '\a', '\x234', 
		'\x2', '\x2', '\x1527', '\x152C', '\x5', '\x410', '\x209', '\x2', '\x1528', 
		'\x1529', '\a', '\x24D', '\x2', '\x2', '\x1529', '\x152B', '\x5', '\x410', 
		'\x209', '\x2', '\x152A', '\x1528', '\x3', '\x2', '\x2', '\x2', '\x152B', 
		'\x152E', '\x3', '\x2', '\x2', '\x2', '\x152C', '\x152A', '\x3', '\x2', 
		'\x2', '\x2', '\x152C', '\x152D', '\x3', '\x2', '\x2', '\x2', '\x152D', 
		'\x40F', '\x3', '\x2', '\x2', '\x2', '\x152E', '\x152C', '\x3', '\x2', 
		'\x2', '\x2', '\x152F', '\x1531', '\x5', '\x46', '$', '\x2', '\x1530', 
		'\x1532', '\x5', '\x412', '\x20A', '\x2', '\x1531', '\x1530', '\x3', '\x2', 
		'\x2', '\x2', '\x1531', '\x1532', '\x3', '\x2', '\x2', '\x2', '\x1532', 
		'\x1533', '\x3', '\x2', '\x2', '\x2', '\x1533', '\x1535', '\x5', '\x15E', 
		'\xB0', '\x2', '\x1534', '\x1536', '\x5', '\x414', '\x20B', '\x2', '\x1535', 
		'\x1534', '\x3', '\x2', '\x2', '\x2', '\x1535', '\x1536', '\x3', '\x2', 
		'\x2', '\x2', '\x1536', '\x1538', '\x3', '\x2', '\x2', '\x2', '\x1537', 
		'\x1539', '\x5', '\x418', '\x20D', '\x2', '\x1538', '\x1537', '\x3', '\x2', 
		'\x2', '\x2', '\x1538', '\x1539', '\x3', '\x2', '\x2', '\x2', '\x1539', 
		'\x411', '\x3', '\x2', '\x2', '\x2', '\x153A', '\x153B', '\a', '\x24B', 
		'\x2', '\x2', '\x153B', '\x153C', '\x5', '\x174', '\xBB', '\x2', '\x153C', 
		'\x153D', '\a', '\x24C', '\x2', '\x2', '\x153D', '\x413', '\x3', '\x2', 
		'\x2', '\x2', '\x153E', '\x153F', '\a', '\x1CB', '\x2', '\x2', '\x153F', 
		'\x1540', '\t', 'O', '\x2', '\x2', '\x1540', '\x1541', '\a', '\xBA', '\x2', 
		'\x2', '\x1541', '\x1542', '\a', '\x33', '\x2', '\x2', '\x1542', '\x1543', 
		'\x5', '\x3FE', '\x200', '\x2', '\x1543', '\x1544', '\x5', '\x416', '\x20C', 
		'\x2', '\x1544', '\x415', '\x3', '\x2', '\x2', '\x2', '\x1545', '\x1546', 
		'\a', '\x1D8', '\x2', '\x2', '\x1546', '\x1547', '\x5', '\x46', '$', '\x2', 
		'\x1547', '\x417', '\x3', '\x2', '\x2', '\x2', '\x1548', '\x1549', '\a', 
		'k', '\x2', '\x2', '\x1549', '\x154A', '\x5', '\x174', '\xBB', '\x2', 
		'\x154A', '\x154B', '\x5', '\x416', '\x20C', '\x2', '\x154B', '\x154C', 
		'\x5', '\x41A', '\x20E', '\x2', '\x154C', '\x154D', '\x5', '\x41C', '\x20F', 
		'\x2', '\x154D', '\x419', '\x3', '\x2', '\x2', '\x2', '\x154E', '\x154F', 
		'\a', '\x209', '\x2', '\x2', '\x154F', '\x1550', '\x5', '(', '\x15', '\x2', 
		'\x1550', '\x41B', '\x3', '\x2', '\x2', '\x2', '\x1551', '\x1552', '\a', 
		'y', '\x2', '\x2', '\x1552', '\x1553', '\x5', '(', '\x15', '\x2', '\x1553', 
		'\x41D', '\x3', '\x2', '\x2', '\x2', '\x1554', '\x1556', '\a', '\x1D0', 
		'\x2', '\x2', '\x1555', '\x1557', '\t', '\v', '\x2', '\x2', '\x1556', 
		'\x1555', '\x3', '\x2', '\x2', '\x2', '\x1556', '\x1557', '\x3', '\x2', 
		'\x2', '\x2', '\x1557', '\x1558', '\x3', '\x2', '\x2', '\x2', '\x1558', 
		'\x155B', '\x5', '\x420', '\x211', '\x2', '\x1559', '\x155C', '\x5', '\x422', 
		'\x212', '\x2', '\x155A', '\x155C', '\x5', '\x4F6', '\x27C', '\x2', '\x155B', 
		'\x1559', '\x3', '\x2', '\x2', '\x2', '\x155B', '\x155A', '\x3', '\x2', 
		'\x2', '\x2', '\x155B', '\x155C', '\x3', '\x2', '\x2', '\x2', '\x155C', 
		'\x155D', '\x3', '\x2', '\x2', '\x2', '\x155D', '\x155F', '\x5', '\x44C', 
		'\x227', '\x2', '\x155E', '\x1560', '\x5', '\x424', '\x213', '\x2', '\x155F', 
		'\x155E', '\x3', '\x2', '\x2', '\x2', '\x155F', '\x1560', '\x3', '\x2', 
		'\x2', '\x2', '\x1560', '\x1568', '\x3', '\x2', '\x2', '\x2', '\x1561', 
		'\x1563', '\x5', '\x446', '\x224', '\x2', '\x1562', '\x1564', '\x5', '\x448', 
		'\x225', '\x2', '\x1563', '\x1562', '\x3', '\x2', '\x2', '\x2', '\x1563', 
		'\x1564', '\x3', '\x2', '\x2', '\x2', '\x1564', '\x1569', '\x3', '\x2', 
		'\x2', '\x2', '\x1565', '\x1566', '\x5', '\x448', '\x225', '\x2', '\x1566', 
		'\x1567', '\x5', '\x446', '\x224', '\x2', '\x1567', '\x1569', '\x3', '\x2', 
		'\x2', '\x2', '\x1568', '\x1561', '\x3', '\x2', '\x2', '\x2', '\x1568', 
		'\x1565', '\x3', '\x2', '\x2', '\x2', '\x1568', '\x1569', '\x3', '\x2', 
		'\x2', '\x2', '\x1569', '\x1572', '\x3', '\x2', '\x2', '\x2', '\x156A', 
		'\x156C', '\x5', '\x426', '\x214', '\x2', '\x156B', '\x156D', '\x5', '\x44A', 
		'\x226', '\x2', '\x156C', '\x156B', '\x3', '\x2', '\x2', '\x2', '\x156C', 
		'\x156D', '\x3', '\x2', '\x2', '\x2', '\x156D', '\x1573', '\x3', '\x2', 
		'\x2', '\x2', '\x156E', '\x1570', '\x5', '\x44A', '\x226', '\x2', '\x156F', 
		'\x1571', '\x5', '\x426', '\x214', '\x2', '\x1570', '\x156F', '\x3', '\x2', 
		'\x2', '\x2', '\x1570', '\x1571', '\x3', '\x2', '\x2', '\x2', '\x1571', 
		'\x1573', '\x3', '\x2', '\x2', '\x2', '\x1572', '\x156A', '\x3', '\x2', 
		'\x2', '\x2', '\x1572', '\x156E', '\x3', '\x2', '\x2', '\x2', '\x1572', 
		'\x1573', '\x3', '\x2', '\x2', '\x2', '\x1573', '\x41F', '\x3', '\x2', 
		'\x2', '\x2', '\x1574', '\x1575', '\x5', '\x166', '\xB4', '\x2', '\x1575', 
		'\x421', '\x3', '\x2', '\x2', '\x2', '\x1576', '\x1577', '\a', '\xF2', 
		'\x2', '\x2', '\x1577', '\x1578', '\x5', '\x174', '\xBB', '\x2', '\x1578', 
		'\x423', '\x3', '\x2', '\x2', '\x2', '\x1579', '\x157A', '\a', '\x232', 
		'\x2', '\x2', '\x157A', '\x157B', '\x5', '\xA2', 'R', '\x2', '\x157B', 
		'\x425', '\x3', '\x2', '\x2', '\x2', '\x157C', '\x157D', '\a', '\xD0', 
		'\x2', '\x2', '\x157D', '\x157E', '\a', '\x33', '\x2', '\x2', '\x157E', 
		'\x157F', '\x5', '\x428', '\x215', '\x2', '\x157F', '\x427', '\x3', '\x2', 
		'\x2', '\x2', '\x1580', '\x1581', '\x5', '\x42A', '\x216', '\x2', '\x1581', 
		'\x429', '\x3', '\x2', '\x2', '\x2', '\x1582', '\x1587', '\x5', '\x42C', 
		'\x217', '\x2', '\x1583', '\x1584', '\a', '\x24D', '\x2', '\x2', '\x1584', 
		'\x1586', '\x5', '\x42C', '\x217', '\x2', '\x1585', '\x1583', '\x3', '\x2', 
		'\x2', '\x2', '\x1586', '\x1589', '\x3', '\x2', '\x2', '\x2', '\x1587', 
		'\x1585', '\x3', '\x2', '\x2', '\x2', '\x1587', '\x1588', '\x3', '\x2', 
		'\x2', '\x2', '\x1588', '\x42B', '\x3', '\x2', '\x2', '\x2', '\x1589', 
		'\x1587', '\x3', '\x2', '\x2', '\x2', '\x158A', '\x158D', '\x5', '\x430', 
		'\x219', '\x2', '\x158B', '\x158D', '\x5', '\x42E', '\x218', '\x2', '\x158C', 
		'\x158A', '\x3', '\x2', '\x2', '\x2', '\x158C', '\x158B', '\x3', '\x2', 
		'\x2', '\x2', '\x158D', '\x42D', '\x3', '\x2', '\x2', '\x2', '\x158E', 
		'\x158F', '\a', '\x24B', '\x2', '\x2', '\x158F', '\x1594', '\x5', '\x42C', 
		'\x217', '\x2', '\x1590', '\x1591', '\a', '\x24D', '\x2', '\x2', '\x1591', 
		'\x1593', '\x5', '\x42C', '\x217', '\x2', '\x1592', '\x1590', '\x3', '\x2', 
		'\x2', '\x2', '\x1593', '\x1596', '\x3', '\x2', '\x2', '\x2', '\x1594', 
		'\x1592', '\x3', '\x2', '\x2', '\x2', '\x1594', '\x1595', '\x3', '\x2', 
		'\x2', '\x2', '\x1595', '\x1597', '\x3', '\x2', '\x2', '\x2', '\x1596', 
		'\x1594', '\x3', '\x2', '\x2', '\x2', '\x1597', '\x1598', '\a', '\x24C', 
		'\x2', '\x2', '\x1598', '\x42F', '\x3', '\x2', '\x2', '\x2', '\x1599', 
		'\x159E', '\x5', '\x43E', '\x220', '\x2', '\x159A', '\x159E', '\x5', '\x434', 
		'\x21B', '\x2', '\x159B', '\x159E', '\x5', '\x432', '\x21A', '\x2', '\x159C', 
		'\x159E', '\x5', '\xA2', 'R', '\x2', '\x159D', '\x1599', '\x3', '\x2', 
		'\x2', '\x2', '\x159D', '\x159A', '\x3', '\x2', '\x2', '\x2', '\x159D', 
		'\x159B', '\x3', '\x2', '\x2', '\x2', '\x159D', '\x159C', '\x3', '\x2', 
		'\x2', '\x2', '\x159E', '\x431', '\x3', '\x2', '\x2', '\x2', '\x159F', 
		'\x15A0', '\a', '\x24B', '\x2', '\x2', '\x15A0', '\x15A1', '\a', '\x24C', 
		'\x2', '\x2', '\x15A1', '\x433', '\x3', '\x2', '\x2', '\x2', '\x15A2', 
		'\x15A3', '\a', '\xD1', '\x2', '\x2', '\x15A3', '\x15A4', '\a', '\x1D9', 
		'\x2', '\x2', '\x15A4', '\x15A5', '\a', '\x24B', '\x2', '\x2', '\x15A5', 
		'\x15A6', '\x5', '\x436', '\x21C', '\x2', '\x15A6', '\x15A7', '\a', '\x24C', 
		'\x2', '\x2', '\x15A7', '\x435', '\x3', '\x2', '\x2', '\x2', '\x15A8', 
		'\x15AD', '\x5', '\x438', '\x21D', '\x2', '\x15A9', '\x15AA', '\a', '\x24D', 
		'\x2', '\x2', '\x15AA', '\x15AC', '\x5', '\x438', '\x21D', '\x2', '\x15AB', 
		'\x15A9', '\x3', '\x2', '\x2', '\x2', '\x15AC', '\x15AF', '\x3', '\x2', 
		'\x2', '\x2', '\x15AD', '\x15AB', '\x3', '\x2', '\x2', '\x2', '\x15AD', 
		'\x15AE', '\x3', '\x2', '\x2', '\x2', '\x15AE', '\x437', '\x3', '\x2', 
		'\x2', '\x2', '\x15AF', '\x15AD', '\x3', '\x2', '\x2', '\x2', '\x15B0', 
		'\x15B4', '\x5', '\x432', '\x21A', '\x2', '\x15B1', '\x15B4', '\x5', '\x43C', 
		'\x21F', '\x2', '\x15B2', '\x15B4', '\x5', '\x43A', '\x21E', '\x2', '\x15B3', 
		'\x15B0', '\x3', '\x2', '\x2', '\x2', '\x15B3', '\x15B1', '\x3', '\x2', 
		'\x2', '\x2', '\x15B3', '\x15B2', '\x3', '\x2', '\x2', '\x2', '\x15B4', 
		'\x439', '\x3', '\x2', '\x2', '\x2', '\x15B5', '\x15B8', '\x5', '\x43E', 
		'\x220', '\x2', '\x15B6', '\x15B8', '\x5', '\xA2', 'R', '\x2', '\x15B7', 
		'\x15B5', '\x3', '\x2', '\x2', '\x2', '\x15B7', '\x15B6', '\x3', '\x2', 
		'\x2', '\x2', '\x15B8', '\x43B', '\x3', '\x2', '\x2', '\x2', '\x15B9', 
		'\x15BA', '\a', '\x24B', '\x2', '\x2', '\x15BA', '\x15BF', '\x5', '\xA2', 
		'R', '\x2', '\x15BB', '\x15BC', '\a', '\x24D', '\x2', '\x2', '\x15BC', 
		'\x15BE', '\x5', '\xA2', 'R', '\x2', '\x15BD', '\x15BB', '\x3', '\x2', 
		'\x2', '\x2', '\x15BE', '\x15C1', '\x3', '\x2', '\x2', '\x2', '\x15BF', 
		'\x15BD', '\x3', '\x2', '\x2', '\x2', '\x15BF', '\x15C0', '\x3', '\x2', 
		'\x2', '\x2', '\x15C0', '\x15C2', '\x3', '\x2', '\x2', '\x2', '\x15C1', 
		'\x15BF', '\x3', '\x2', '\x2', '\x2', '\x15C2', '\x15C3', '\a', '\x24C', 
		'\x2', '\x2', '\x15C3', '\x43D', '\x3', '\x2', '\x2', '\x2', '\x15C4', 
		'\x15C5', '\t', 'P', '\x2', '\x2', '\x15C5', '\x15C6', '\a', '\x24B', 
		'\x2', '\x2', '\x15C6', '\x15C7', '\x5', '\x440', '\x221', '\x2', '\x15C7', 
		'\x15C8', '\a', '\x24C', '\x2', '\x2', '\x15C8', '\x43F', '\x3', '\x2', 
		'\x2', '\x2', '\x15C9', '\x15CE', '\x5', '\x442', '\x222', '\x2', '\x15CA', 
		'\x15CB', '\a', '\x24D', '\x2', '\x2', '\x15CB', '\x15CD', '\x5', '\x442', 
		'\x222', '\x2', '\x15CC', '\x15CA', '\x3', '\x2', '\x2', '\x2', '\x15CD', 
		'\x15D0', '\x3', '\x2', '\x2', '\x2', '\x15CE', '\x15CC', '\x3', '\x2', 
		'\x2', '\x2', '\x15CE', '\x15CF', '\x3', '\x2', '\x2', '\x2', '\x15CF', 
		'\x441', '\x3', '\x2', '\x2', '\x2', '\x15D0', '\x15CE', '\x3', '\x2', 
		'\x2', '\x2', '\x15D1', '\x15D4', '\x5', '\x444', '\x223', '\x2', '\x15D2', 
		'\x15D4', '\x5', '\xA2', 'R', '\x2', '\x15D3', '\x15D1', '\x3', '\x2', 
		'\x2', '\x2', '\x15D3', '\x15D2', '\x3', '\x2', '\x2', '\x2', '\x15D4', 
		'\x443', '\x3', '\x2', '\x2', '\x2', '\x15D5', '\x15D6', '\a', '\x24B', 
		'\x2', '\x2', '\x15D6', '\x15DB', '\x5', '\xA2', 'R', '\x2', '\x15D7', 
		'\x15D8', '\a', '\x24D', '\x2', '\x2', '\x15D8', '\x15DA', '\x5', '\xA2', 
		'R', '\x2', '\x15D9', '\x15D7', '\x3', '\x2', '\x2', '\x2', '\x15DA', 
		'\x15DD', '\x3', '\x2', '\x2', '\x2', '\x15DB', '\x15D9', '\x3', '\x2', 
		'\x2', '\x2', '\x15DB', '\x15DC', '\x3', '\x2', '\x2', '\x2', '\x15DC', 
		'\x15DE', '\x3', '\x2', '\x2', '\x2', '\x15DD', '\x15DB', '\x3', '\x2', 
		'\x2', '\x2', '\x15DE', '\x15DF', '\a', '\x24C', '\x2', '\x2', '\x15DF', 
		'\x445', '\x3', '\x2', '\x2', '\x2', '\x15E0', '\x15E1', '\a', 'X', '\x2', 
		'\x2', '\x15E1', '\x15E3', '\a', '\x33', '\x2', '\x2', '\x15E2', '\x15E4', 
		'\a', '\x147', '\x2', '\x2', '\x15E3', '\x15E2', '\x3', '\x2', '\x2', 
		'\x2', '\x15E3', '\x15E4', '\x3', '\x2', '\x2', '\x2', '\x15E4', '\x15E5', 
		'\x3', '\x2', '\x2', '\x2', '\x15E5', '\x15E6', '\x5', '\xA2', 'R', '\x2', 
		'\x15E6', '\x447', '\x3', '\x2', '\x2', '\x2', '\x15E7', '\x15E8', '\a', 
		'\x1E6', '\x2', '\x2', '\x15E8', '\x15E9', '\a', '\x234', '\x2', '\x2', 
		'\x15E9', '\x15EA', '\x5', '\xA2', 'R', '\x2', '\x15EA', '\x449', '\x3', 
		'\x2', '\x2', '\x2', '\x15EB', '\x15EC', '\a', '\xD4', '\x2', '\x2', '\x15EC', 
		'\x15ED', '\x5', '\xA2', 'R', '\x2', '\x15ED', '\x44B', '\x3', '\x2', 
		'\x2', '\x2', '\x15EE', '\x15EF', '\a', '\xC8', '\x2', '\x2', '\x15EF', 
		'\x15F4', '\x5', '\x44E', '\x228', '\x2', '\x15F0', '\x15F1', '\a', '\x24D', 
		'\x2', '\x2', '\x15F1', '\x15F3', '\x5', '\x44E', '\x228', '\x2', '\x15F2', 
		'\x15F0', '\x3', '\x2', '\x2', '\x2', '\x15F3', '\x15F6', '\x3', '\x2', 
		'\x2', '\x2', '\x15F4', '\x15F2', '\x3', '\x2', '\x2', '\x2', '\x15F4', 
		'\x15F5', '\x3', '\x2', '\x2', '\x2', '\x15F5', '\x44D', '\x3', '\x2', 
		'\x2', '\x2', '\x15F6', '\x15F4', '\x3', '\x2', '\x2', '\x2', '\x15F7', 
		'\x15F9', '\x5', '\x450', '\x229', '\x2', '\x15F8', '\x15FA', '\x5', '\x492', 
		'\x24A', '\x2', '\x15F9', '\x15F8', '\x3', '\x2', '\x2', '\x2', '\x15F9', 
		'\x15FA', '\x3', '\x2', '\x2', '\x2', '\x15FA', '\x44F', '\x3', '\x2', 
		'\x2', '\x2', '\x15FB', '\x15FD', '\x5', '\x460', '\x231', '\x2', '\x15FC', 
		'\x15FE', '\x5', '\x45C', '\x22F', '\x2', '\x15FD', '\x15FC', '\x3', '\x2', 
		'\x2', '\x2', '\x15FD', '\x15FE', '\x3', '\x2', '\x2', '\x2', '\x15FE', 
		'\x160A', '\x3', '\x2', '\x2', '\x2', '\x15FF', '\x1600', '\x5', '\x454', 
		'\x22B', '\x2', '\x1600', '\x1603', '\x5', '\x450', '\x229', '\x2', '\x1601', 
		'\x1604', '\x5', '\x458', '\x22D', '\x2', '\x1602', '\x1604', '\x5', '\x45A', 
		'\x22E', '\x2', '\x1603', '\x1601', '\x3', '\x2', '\x2', '\x2', '\x1603', 
		'\x1602', '\x3', '\x2', '\x2', '\x2', '\x1603', '\x1604', '\x3', '\x2', 
		'\x2', '\x2', '\x1604', '\x1609', '\x3', '\x2', '\x2', '\x2', '\x1605', 
		'\x1606', '\x5', '\x452', '\x22A', '\x2', '\x1606', '\x1607', '\x5', '\x450', 
		'\x229', '\x2', '\x1607', '\x1609', '\x3', '\x2', '\x2', '\x2', '\x1608', 
		'\x15FF', '\x3', '\x2', '\x2', '\x2', '\x1608', '\x1605', '\x3', '\x2', 
		'\x2', '\x2', '\x1609', '\x160C', '\x3', '\x2', '\x2', '\x2', '\x160A', 
		'\x1608', '\x3', '\x2', '\x2', '\x2', '\x160A', '\x160B', '\x3', '\x2', 
		'\x2', '\x2', '\x160B', '\x451', '\x3', '\x2', '\x2', '\x2', '\x160C', 
		'\x160A', '\x3', '\x2', '\x2', '\x2', '\x160D', '\x160E', '\a', '\x66', 
		'\x2', '\x2', '\x160E', '\x1616', '\a', '\xFA', '\x2', '\x2', '\x160F', 
		'\x1612', '\a', '\x139', '\x2', '\x2', '\x1610', '\x1613', '\a', '\xEA', 
		'\x2', '\x2', '\x1611', '\x1613', '\x5', '\x456', '\x22C', '\x2', '\x1612', 
		'\x1610', '\x3', '\x2', '\x2', '\x2', '\x1612', '\x1611', '\x3', '\x2', 
		'\x2', '\x2', '\x1612', '\x1613', '\x3', '\x2', '\x2', '\x2', '\x1613', 
		'\x1614', '\x3', '\x2', '\x2', '\x2', '\x1614', '\x1616', '\a', '\xFA', 
		'\x2', '\x2', '\x1615', '\x160D', '\x3', '\x2', '\x2', '\x2', '\x1615', 
		'\x160F', '\x3', '\x2', '\x2', '\x2', '\x1616', '\x453', '\x3', '\x2', 
		'\x2', '\x2', '\x1617', '\x161A', '\x5', '\x456', '\x22C', '\x2', '\x1618', 
		'\x161A', '\a', '\xEA', '\x2', '\x2', '\x1619', '\x1617', '\x3', '\x2', 
		'\x2', '\x2', '\x1619', '\x1618', '\x3', '\x2', '\x2', '\x2', '\x1619', 
		'\x161A', '\x3', '\x2', '\x2', '\x2', '\x161A', '\x161B', '\x3', '\x2', 
		'\x2', '\x2', '\x161B', '\x161C', '\a', '\xFA', '\x2', '\x2', '\x161C', 
		'\x455', '\x3', '\x2', '\x2', '\x2', '\x161D', '\x161F', '\t', 'Q', '\x2', 
		'\x2', '\x161E', '\x1620', '\a', '\x173', '\x2', '\x2', '\x161F', '\x161E', 
		'\x3', '\x2', '\x2', '\x2', '\x161F', '\x1620', '\x3', '\x2', '\x2', '\x2', 
		'\x1620', '\x457', '\x3', '\x2', '\x2', '\x2', '\x1621', '\x1622', '\a', 
		'\x166', '\x2', '\x2', '\x1622', '\x1623', '\x5', '\xA2', 'R', '\x2', 
		'\x1623', '\x459', '\x3', '\x2', '\x2', '\x2', '\x1624', '\x1625', '\a', 
		'\x223', '\x2', '\x2', '\x1625', '\x1626', '\a', '\x24B', '\x2', '\x2', 
		'\x1626', '\x162B', '\x5', '\x44', '#', '\x2', '\x1627', '\x1628', '\a', 
		'\x24D', '\x2', '\x2', '\x1628', '\x162A', '\x5', '\x44', '#', '\x2', 
		'\x1629', '\x1627', '\x3', '\x2', '\x2', '\x2', '\x162A', '\x162D', '\x3', 
		'\x2', '\x2', '\x2', '\x162B', '\x1629', '\x3', '\x2', '\x2', '\x2', '\x162B', 
		'\x162C', '\x3', '\x2', '\x2', '\x2', '\x162C', '\x162E', '\x3', '\x2', 
		'\x2', '\x2', '\x162D', '\x162B', '\x3', '\x2', '\x2', '\x2', '\x162E', 
		'\x162F', '\a', '\x24C', '\x2', '\x2', '\x162F', '\x45B', '\x3', '\x2', 
		'\x2', '\x2', '\x1630', '\x1631', '\a', '\x17E', '\x2', '\x2', '\x1631', 
		'\x1632', '\a', '\x33', '\x2', '\x2', '\x1632', '\x1633', '\a', '\x24B', 
		'\x2', '\x2', '\x1633', '\x1634', '\x5', '\x166', '\xB4', '\x2', '\x1634', 
		'\x1635', '\a', '\x24C', '\x2', '\x2', '\x1635', '\x45D', '\x3', '\x2', 
		'\x2', '\x2', '\x1636', '\x1637', '\t', 'R', '\x2', '\x2', '\x1637', '\x1638', 
		'\a', '\x24B', '\x2', '\x2', '\x1638', '\x1639', '\x5', '\x44', '#', '\x2', 
		'\x1639', '\x163A', '\a', '\x24C', '\x2', '\x2', '\x163A', '\x45F', '\x3', 
		'\x2', '\x2', '\x2', '\x163B', '\x1641', '\x5', '\x46', '$', '\x2', '\x163C', 
		'\x163E', '\x5', '\x45E', '\x230', '\x2', '\x163D', '\x163F', '\x5', '\x4C4', 
		'\x263', '\x2', '\x163E', '\x163D', '\x3', '\x2', '\x2', '\x2', '\x163E', 
		'\x163F', '\x3', '\x2', '\x2', '\x2', '\x163F', '\x1642', '\x3', '\x2', 
		'\x2', '\x2', '\x1640', '\x1642', '\x5', '\x4C4', '\x263', '\x2', '\x1641', 
		'\x163C', '\x3', '\x2', '\x2', '\x2', '\x1641', '\x1640', '\x3', '\x2', 
		'\x2', '\x2', '\x1641', '\x1642', '\x3', '\x2', '\x2', '\x2', '\x1642', 
		'\x164C', '\x3', '\x2', '\x2', '\x2', '\x1643', '\x1644', '\a', '\x24B', 
		'\x2', '\x2', '\x1644', '\x1645', '\x5', '\x44E', '\x228', '\x2', '\x1645', 
		'\x1646', '\a', '\x24C', '\x2', '\x2', '\x1646', '\x164C', '\x3', '\x2', 
		'\x2', '\x2', '\x1647', '\x164C', '\x5', '\x488', '\x245', '\x2', '\x1648', 
		'\x164C', '\x5', '\x160', '\xB1', '\x2', '\x1649', '\x164C', '\x5', '\x15C', 
		'\xAF', '\x2', '\x164A', '\x164C', '\x5', '\x462', '\x232', '\x2', '\x164B', 
		'\x163B', '\x3', '\x2', '\x2', '\x2', '\x164B', '\x1643', '\x3', '\x2', 
		'\x2', '\x2', '\x164B', '\x1647', '\x3', '\x2', '\x2', '\x2', '\x164B', 
		'\x1648', '\x3', '\x2', '\x2', '\x2', '\x164B', '\x1649', '\x3', '\x2', 
		'\x2', '\x2', '\x164B', '\x164A', '\x3', '\x2', '\x2', '\x2', '\x164C', 
		'\x164E', '\x3', '\x2', '\x2', '\x2', '\x164D', '\x164F', '\x5', '\x486', 
		'\x244', '\x2', '\x164E', '\x164D', '\x3', '\x2', '\x2', '\x2', '\x164E', 
		'\x164F', '\x3', '\x2', '\x2', '\x2', '\x164F', '\x1655', '\x3', '\x2', 
		'\x2', '\x2', '\x1650', '\x1652', '\x6', '\x231', '\x3', '\x2', '\x1651', 
		'\x1653', '\x5', '\x4CA', '\x266', '\x2', '\x1652', '\x1651', '\x3', '\x2', 
		'\x2', '\x2', '\x1652', '\x1653', '\x3', '\x2', '\x2', '\x2', '\x1653', 
		'\x1656', '\x3', '\x2', '\x2', '\x2', '\x1654', '\x1656', '\x3', '\x2', 
		'\x2', '\x2', '\x1655', '\x1650', '\x3', '\x2', '\x2', '\x2', '\x1655', 
		'\x1654', '\x3', '\x2', '\x2', '\x2', '\x1656', '\x461', '\x3', '\x2', 
		'\x2', '\x2', '\x1657', '\x1658', '\a', '\xFC', '\x2', '\x2', '\x1658', 
		'\x1659', '\a', '\x24B', '\x2', '\x2', '\x1659', '\x165C', '\x5', '\xA2', 
		'R', '\x2', '\x165A', '\x165B', '\a', '\xC2', '\x2', '\x2', '\x165B', 
		'\x165D', '\a', '\xFB', '\x2', '\x2', '\x165C', '\x165A', '\x3', '\x2', 
		'\x2', '\x2', '\x165C', '\x165D', '\x3', '\x2', '\x2', '\x2', '\x165D', 
		'\x1660', '\x3', '\x2', '\x2', '\x2', '\x165E', '\x165F', '\a', '\x24D', 
		'\x2', '\x2', '\x165F', '\x1661', '\x5', '\x468', '\x235', '\x2', '\x1660', 
		'\x165E', '\x3', '\x2', '\x2', '\x2', '\x1660', '\x1661', '\x3', '\x2', 
		'\x2', '\x2', '\x1661', '\x1665', '\x3', '\x2', '\x2', '\x2', '\x1662', 
		'\x1664', '\x5', '\x464', '\x233', '\x2', '\x1663', '\x1662', '\x3', '\x2', 
		'\x2', '\x2', '\x1664', '\x1667', '\x3', '\x2', '\x2', '\x2', '\x1665', 
		'\x1663', '\x3', '\x2', '\x2', '\x2', '\x1665', '\x1666', '\x3', '\x2', 
		'\x2', '\x2', '\x1666', '\x1668', '\x3', '\x2', '\x2', '\x2', '\x1667', 
		'\x1665', '\x3', '\x2', '\x2', '\x2', '\x1668', '\x1669', '\x5', '\x46A', 
		'\x236', '\x2', '\x1669', '\x166A', '\a', '\x24C', '\x2', '\x2', '\x166A', 
		'\x463', '\x3', '\x2', '\x2', '\x2', '\x166B', '\x166C', '\x5', '\x466', 
		'\x234', '\x2', '\x166C', '\x166D', '\t', 'S', '\x2', '\x2', '\x166D', 
		'\x465', '\x3', '\x2', '\x2', '\x2', '\x166E', '\x166F', '\t', 'T', '\x2', 
		'\x2', '\x166F', '\x1670', '\a', '\x166', '\x2', '\x2', '\x1670', '\x467', 
		'\x3', '\x2', '\x2', '\x2', '\x1671', '\x1674', '\x5', '\x46', '$', '\x2', 
		'\x1672', '\x1674', '\x5', '(', '\x15', '\x2', '\x1673', '\x1671', '\x3', 
		'\x2', '\x2', '\x2', '\x1673', '\x1672', '\x3', '\x2', '\x2', '\x2', '\x1674', 
		'\x469', '\x3', '\x2', '\x2', '\x2', '\x1675', '\x1676', '\a', 'L', '\x2', 
		'\x2', '\x1676', '\x1677', '\a', '\x24B', '\x2', '\x2', '\x1677', '\x167C', 
		'\x5', '\x46C', '\x237', '\x2', '\x1678', '\x1679', '\a', '\x24D', '\x2', 
		'\x2', '\x1679', '\x167B', '\x5', '\x46C', '\x237', '\x2', '\x167A', '\x1678', 
		'\x3', '\x2', '\x2', '\x2', '\x167B', '\x167E', '\x3', '\x2', '\x2', '\x2', 
		'\x167C', '\x167A', '\x3', '\x2', '\x2', '\x2', '\x167C', '\x167D', '\x3', 
		'\x2', '\x2', '\x2', '\x167D', '\x167F', '\x3', '\x2', '\x2', '\x2', '\x167E', 
		'\x167C', '\x3', '\x2', '\x2', '\x2', '\x167F', '\x1680', '\a', '\x24C', 
		'\x2', '\x2', '\x1680', '\x46B', '\x3', '\x2', '\x2', '\x2', '\x1681', 
		'\x1687', '\x5', '\x46E', '\x238', '\x2', '\x1682', '\x1687', '\x5', '\x474', 
		'\x23B', '\x2', '\x1683', '\x1687', '\x5', '\x47C', '\x23F', '\x2', '\x1684', 
		'\x1687', '\x5', '\x482', '\x242', '\x2', '\x1685', '\x1687', '\x5', '\x484', 
		'\x243', '\x2', '\x1686', '\x1681', '\x3', '\x2', '\x2', '\x2', '\x1686', 
		'\x1682', '\x3', '\x2', '\x2', '\x2', '\x1686', '\x1683', '\x3', '\x2', 
		'\x2', '\x2', '\x1686', '\x1684', '\x3', '\x2', '\x2', '\x2', '\x1686', 
		'\x1685', '\x3', '\x2', '\x2', '\x2', '\x1687', '\x46D', '\x3', '\x2', 
		'\x2', '\x2', '\x1688', '\x168A', '\x5', '\x46', '$', '\x2', '\x1689', 
		'\x168B', '\x5', '\x62', '\x32', '\x2', '\x168A', '\x1689', '\x3', '\x2', 
		'\x2', '\x2', '\x168A', '\x168B', '\x3', '\x2', '\x2', '\x2', '\x168B', 
		'\x168C', '\x3', '\x2', '\x2', '\x2', '\x168C', '\x168F', '\a', '\xAB', 
		'\x2', '\x2', '\x168D', '\x168E', '\a', '\x182', '\x2', '\x2', '\x168E', 
		'\x1690', '\x5', '\x468', '\x235', '\x2', '\x168F', '\x168D', '\x3', '\x2', 
		'\x2', '\x2', '\x168F', '\x1690', '\x3', '\x2', '\x2', '\x2', '\x1690', 
		'\x1694', '\x3', '\x2', '\x2', '\x2', '\x1691', '\x1693', '\x5', '\x470', 
		'\x239', '\x2', '\x1692', '\x1691', '\x3', '\x2', '\x2', '\x2', '\x1693', 
		'\x1696', '\x3', '\x2', '\x2', '\x2', '\x1694', '\x1692', '\x3', '\x2', 
		'\x2', '\x2', '\x1694', '\x1695', '\x3', '\x2', '\x2', '\x2', '\x1695', 
		'\x46F', '\x3', '\x2', '\x2', '\x2', '\x1696', '\x1694', '\x3', '\x2', 
		'\x2', '\x2', '\x1697', '\x1698', '\x5', '\x472', '\x23A', '\x2', '\x1698', 
		'\x1699', '\t', 'S', '\x2', '\x2', '\x1699', '\x471', '\x3', '\x2', '\x2', 
		'\x2', '\x169A', '\x169B', '\t', 'U', '\x2', '\x2', '\x169B', '\x169C', 
		'\a', '\x166', '\x2', '\x2', '\x169C', '\x473', '\x3', '\x2', '\x2', '\x2', 
		'\x169D', '\x169F', '\x5', '\x46', '$', '\x2', '\x169E', '\x16A0', '\x5', 
		'\x62', '\x32', '\x2', '\x169F', '\x169E', '\x3', '\x2', '\x2', '\x2', 
		'\x169F', '\x16A0', '\x3', '\x2', '\x2', '\x2', '\x16A0', '\x16A2', '\x3', 
		'\x2', '\x2', '\x2', '\x16A1', '\x16A3', '\a', '\x211', '\x2', '\x2', 
		'\x16A2', '\x16A1', '\x3', '\x2', '\x2', '\x2', '\x16A2', '\x16A3', '\x3', 
		'\x2', '\x2', '\x2', '\x16A3', '\x16A4', '\x3', '\x2', '\x2', '\x2', '\x16A4', 
		'\x16A5', '\a', '\xC2', '\x2', '\x2', '\x16A5', '\x16A7', '\a', '\xFB', 
		'\x2', '\x2', '\x16A6', '\x16A8', '\x5', '\x476', '\x23C', '\x2', '\x16A7', 
		'\x16A6', '\x3', '\x2', '\x2', '\x2', '\x16A7', '\x16A8', '\x3', '\x2', 
		'\x2', '\x2', '\x16A8', '\x16AB', '\x3', '\x2', '\x2', '\x2', '\x16A9', 
		'\x16AA', '\a', '\x182', '\x2', '\x2', '\x16AA', '\x16AC', '\x5', '\x468', 
		'\x235', '\x2', '\x16AB', '\x16A9', '\x3', '\x2', '\x2', '\x2', '\x16AB', 
		'\x16AC', '\x3', '\x2', '\x2', '\x2', '\x16AC', '\x16B0', '\x3', '\x2', 
		'\x2', '\x2', '\x16AD', '\x16AF', '\x5', '\x478', '\x23D', '\x2', '\x16AE', 
		'\x16AD', '\x3', '\x2', '\x2', '\x2', '\x16AF', '\x16B2', '\x3', '\x2', 
		'\x2', '\x2', '\x16B0', '\x16AE', '\x3', '\x2', '\x2', '\x2', '\x16B0', 
		'\x16B1', '\x3', '\x2', '\x2', '\x2', '\x16B1', '\x475', '\x3', '\x2', 
		'\x2', '\x2', '\x16B2', '\x16B0', '\x3', '\x2', '\x2', '\x2', '\x16B3', 
		'\x16B5', '\a', '\x234', '\x2', '\x2', '\x16B4', '\x16B6', '\t', 'V', 
		'\x2', '\x2', '\x16B5', '\x16B4', '\x3', '\x2', '\x2', '\x2', '\x16B5', 
		'\x16B6', '\x3', '\x2', '\x2', '\x2', '\x16B6', '\x16B9', '\x3', '\x2', 
		'\x2', '\x2', '\x16B7', '\x16B9', '\a', '\x236', '\x2', '\x2', '\x16B8', 
		'\x16B3', '\x3', '\x2', '\x2', '\x2', '\x16B8', '\x16B7', '\x3', '\x2', 
		'\x2', '\x2', '\x16B9', '\x16BB', '\x3', '\x2', '\x2', '\x2', '\x16BA', 
		'\x16BC', '\a', '\x14', '\x2', '\x2', '\x16BB', '\x16BA', '\x3', '\x2', 
		'\x2', '\x2', '\x16BB', '\x16BC', '\x3', '\x2', '\x2', '\x2', '\x16BC', 
		'\x16BD', '\x3', '\x2', '\x2', '\x2', '\x16BD', '\x16BE', '\a', '\x239', 
		'\x2', '\x2', '\x16BE', '\x477', '\x3', '\x2', '\x2', '\x2', '\x16BF', 
		'\x16C0', '\x5', '\x47A', '\x23E', '\x2', '\x16C0', '\x16C1', '\t', 'S', 
		'\x2', '\x2', '\x16C1', '\x479', '\x3', '\x2', '\x2', '\x2', '\x16C2', 
		'\x16C9', '\a', '\xA0', '\x2', '\x2', '\x16C3', '\x16C9', '\a', '\x15E', 
		'\x2', '\x2', '\x16C4', '\x16C6', '\a', '\x99', '\x2', '\x2', '\x16C5', 
		'\x16C7', '\t', 'W', '\x2', '\x2', '\x16C6', '\x16C5', '\x3', '\x2', '\x2', 
		'\x2', '\x16C6', '\x16C7', '\x3', '\x2', '\x2', '\x2', '\x16C7', '\x16C9', 
		'\x3', '\x2', '\x2', '\x2', '\x16C8', '\x16C2', '\x3', '\x2', '\x2', '\x2', 
		'\x16C8', '\x16C3', '\x3', '\x2', '\x2', '\x2', '\x16C8', '\x16C4', '\x3', 
		'\x2', '\x2', '\x2', '\x16C9', '\x16CA', '\x3', '\x2', '\x2', '\x2', '\x16CA', 
		'\x16CB', '\a', '\x166', '\x2', '\x2', '\x16CB', '\x47B', '\x3', '\x2', 
		'\x2', '\x2', '\x16CC', '\x16CE', '\x5', '\x46', '$', '\x2', '\x16CD', 
		'\x16CF', '\x5', '\x62', '\x32', '\x2', '\x16CE', '\x16CD', '\x3', '\x2', 
		'\x2', '\x2', '\x16CE', '\x16CF', '\x3', '\x2', '\x2', '\x2', '\x16CF', 
		'\x16D1', '\x3', '\x2', '\x2', '\x2', '\x16D0', '\x16D2', '\a', '\x211', 
		'\x2', '\x2', '\x16D1', '\x16D0', '\x3', '\x2', '\x2', '\x2', '\x16D1', 
		'\x16D2', '\x3', '\x2', '\x2', '\x2', '\x16D2', '\x16D5', '\x3', '\x2', 
		'\x2', '\x2', '\x16D3', '\x16D4', '\a', '\x182', '\x2', '\x2', '\x16D4', 
		'\x16D6', '\x5', '\x468', '\x235', '\x2', '\x16D5', '\x16D3', '\x3', '\x2', 
		'\x2', '\x2', '\x16D5', '\x16D6', '\x3', '\x2', '\x2', '\x2', '\x16D6', 
		'\x16DA', '\x3', '\x2', '\x2', '\x2', '\x16D7', '\x16D9', '\x5', '\x47E', 
		'\x240', '\x2', '\x16D8', '\x16D7', '\x3', '\x2', '\x2', '\x2', '\x16D9', 
		'\x16DC', '\x3', '\x2', '\x2', '\x2', '\x16DA', '\x16D8', '\x3', '\x2', 
		'\x2', '\x2', '\x16DA', '\x16DB', '\x3', '\x2', '\x2', '\x2', '\x16DB', 
		'\x47D', '\x3', '\x2', '\x2', '\x2', '\x16DC', '\x16DA', '\x3', '\x2', 
		'\x2', '\x2', '\x16DD', '\x16DE', '\x5', '\x480', '\x241', '\x2', '\x16DE', 
		'\x16DF', '\t', 'S', '\x2', '\x2', '\x16DF', '\x47F', '\x3', '\x2', '\x2', 
		'\x2', '\x16E0', '\x16E5', '\a', '\xA0', '\x2', '\x2', '\x16E1', '\x16E5', 
		'\a', '\x15E', '\x2', '\x2', '\x16E2', '\x16E3', '\a', 'y', '\x2', '\x2', 
		'\x16E3', '\x16E5', '\x5', '(', '\x15', '\x2', '\x16E4', '\x16E0', '\x3', 
		'\x2', '\x2', '\x2', '\x16E4', '\x16E1', '\x3', '\x2', '\x2', '\x2', '\x16E4', 
		'\x16E2', '\x3', '\x2', '\x2', '\x2', '\x16E5', '\x16E6', '\x3', '\x2', 
		'\x2', '\x2', '\x16E6', '\x16E7', '\a', '\x166', '\x2', '\x2', '\x16E7', 
		'\x481', '\x3', '\x2', '\x2', '\x2', '\x16E8', '\x16EA', '\a', '\x13D', 
		'\x2', '\x2', '\x16E9', '\x16EB', '\a', '\x182', '\x2', '\x2', '\x16EA', 
		'\x16E9', '\x3', '\x2', '\x2', '\x2', '\x16EA', '\x16EB', '\x3', '\x2', 
		'\x2', '\x2', '\x16EB', '\x16EC', '\x3', '\x2', '\x2', '\x2', '\x16EC', 
		'\x16ED', '\x5', '\x468', '\x235', '\x2', '\x16ED', '\x16EE', '\x5', '\x46A', 
		'\x236', '\x2', '\x16EE', '\x483', '\x3', '\x2', '\x2', '\x2', '\x16EF', 
		'\x16F0', '\x5', '\x46', '$', '\x2', '\x16F0', '\x16F1', '\a', '\xBE', 
		'\x2', '\x2', '\x16F1', '\x16F2', '\a', '\x170', '\x2', '\x2', '\x16F2', 
		'\x485', '\x3', '\x2', '\x2', '\x2', '\x16F3', '\x16F5', '\x5', '\x492', 
		'\x24A', '\x2', '\x16F4', '\x16F6', '\x5', '\x4BA', '\x25E', '\x2', '\x16F5', 
		'\x16F4', '\x3', '\x2', '\x2', '\x2', '\x16F5', '\x16F6', '\x3', '\x2', 
		'\x2', '\x2', '\x16F6', '\x16FC', '\x3', '\x2', '\x2', '\x2', '\x16F7', 
		'\x16F9', '\x5', '\x4BA', '\x25E', '\x2', '\x16F8', '\x16FA', '\x5', '\x492', 
		'\x24A', '\x2', '\x16F9', '\x16F8', '\x3', '\x2', '\x2', '\x2', '\x16F9', 
		'\x16FA', '\x3', '\x2', '\x2', '\x2', '\x16FA', '\x16FC', '\x3', '\x2', 
		'\x2', '\x2', '\x16FB', '\x16F3', '\x3', '\x2', '\x2', '\x2', '\x16FB', 
		'\x16F7', '\x3', '\x2', '\x2', '\x2', '\x16FC', '\x487', '\x3', '\x2', 
		'\x2', '\x2', '\x16FD', '\x16FE', '\a', '\x241', '\x2', '\x2', '\x16FE', 
		'\x1702', '\a', '\x24B', '\x2', '\x2', '\x16FF', '\x1700', '\x5', '\x48A', 
		'\x246', '\x2', '\x1700', '\x1701', '\a', '\x24D', '\x2', '\x2', '\x1701', 
		'\x1703', '\x3', '\x2', '\x2', '\x2', '\x1702', '\x16FF', '\x3', '\x2', 
		'\x2', '\x2', '\x1702', '\x1703', '\x3', '\x2', '\x2', '\x2', '\x1703', 
		'\x1704', '\x3', '\x2', '\x2', '\x2', '\x1704', '\x1705', '\x5', '(', 
		'\x15', '\x2', '\x1705', '\x1706', '\x5', '\x48C', '\x247', '\x2', '\x1706', 
		'\x1707', '\a', '\x24C', '\x2', '\x2', '\x1707', '\x489', '\x3', '\x2', 
		'\x2', '\x2', '\x1708', '\x1709', '\a', '\x23E', '\x2', '\x2', '\x1709', 
		'\x170B', '\a', '\x24B', '\x2', '\x2', '\x170A', '\x170C', '\x5', '\x166', 
		'\xB4', '\x2', '\x170B', '\x170A', '\x3', '\x2', '\x2', '\x2', '\x170B', 
		'\x170C', '\x3', '\x2', '\x2', '\x2', '\x170C', '\x170F', '\x3', '\x2', 
		'\x2', '\x2', '\x170D', '\x170E', '\a', 'y', '\x2', '\x2', '\x170E', '\x1710', 
		'\x5', '(', '\x15', '\x2', '\x170F', '\x170D', '\x3', '\x2', '\x2', '\x2', 
		'\x170F', '\x1710', '\x3', '\x2', '\x2', '\x2', '\x1710', '\x1711', '\x3', 
		'\x2', '\x2', '\x2', '\x1711', '\x1712', '\a', '\x24C', '\x2', '\x2', 
		'\x1712', '\x48B', '\x3', '\x2', '\x2', '\x2', '\x1713', '\x1715', '\x5', 
		'\x48E', '\x248', '\x2', '\x1714', '\x1713', '\x3', '\x2', '\x2', '\x2', 
		'\x1714', '\x1715', '\x3', '\x2', '\x2', '\x2', '\x1715', '\x171F', '\x3', 
		'\x2', '\x2', '\x2', '\x1716', '\x1717', '\a', 'L', '\x2', '\x2', '\x1717', 
		'\x171C', '\x5', '\x490', '\x249', '\x2', '\x1718', '\x1719', '\a', '\x24D', 
		'\x2', '\x2', '\x1719', '\x171B', '\x5', '\x490', '\x249', '\x2', '\x171A', 
		'\x1718', '\x3', '\x2', '\x2', '\x2', '\x171B', '\x171E', '\x3', '\x2', 
		'\x2', '\x2', '\x171C', '\x171A', '\x3', '\x2', '\x2', '\x2', '\x171C', 
		'\x171D', '\x3', '\x2', '\x2', '\x2', '\x171D', '\x1720', '\x3', '\x2', 
		'\x2', '\x2', '\x171E', '\x171C', '\x3', '\x2', '\x2', '\x2', '\x171F', 
		'\x1716', '\x3', '\x2', '\x2', '\x2', '\x171F', '\x1720', '\x3', '\x2', 
		'\x2', '\x2', '\x1720', '\x48D', '\x3', '\x2', '\x2', '\x2', '\x1721', 
		'\x1724', '\a', '\x180', '\x2', '\x2', '\x1722', '\x1723', '\a', '\x33', 
		'\x2', '\x2', '\x1723', '\x1725', '\a', '\x225', '\x2', '\x2', '\x1724', 
		'\x1722', '\x3', '\x2', '\x2', '\x2', '\x1724', '\x1725', '\x3', '\x2', 
		'\x2', '\x2', '\x1725', '\x1726', '\x3', '\x2', '\x2', '\x2', '\x1726', 
		'\x1727', '\x5', '\x166', '\xB4', '\x2', '\x1727', '\x48F', '\x3', '\x2', 
		'\x2', '\x2', '\x1728', '\x1734', '\x5', '\xA2', 'R', '\x2', '\x1729', 
		'\x172A', '\a', '\xBE', '\x2', '\x2', '\x172A', '\x1735', '\a', '\x170', 
		'\x2', '\x2', '\x172B', '\x172E', '\x5', '\x62', '\x32', '\x2', '\x172C', 
		'\x172D', '\a', '\x182', '\x2', '\x2', '\x172D', '\x172F', '\x5', '(', 
		'\x15', '\x2', '\x172E', '\x172C', '\x3', '\x2', '\x2', '\x2', '\x172E', 
		'\x172F', '\x3', '\x2', '\x2', '\x2', '\x172F', '\x1732', '\x3', '\x2', 
		'\x2', '\x2', '\x1730', '\x1731', '\a', 'y', '\x2', '\x2', '\x1731', '\x1733', 
		'\x5', '\xA2', 'R', '\x2', '\x1732', '\x1730', '\x3', '\x2', '\x2', '\x2', 
		'\x1732', '\x1733', '\x3', '\x2', '\x2', '\x2', '\x1733', '\x1735', '\x3', 
		'\x2', '\x2', '\x2', '\x1734', '\x1729', '\x3', '\x2', '\x2', '\x2', '\x1734', 
		'\x172B', '\x3', '\x2', '\x2', '\x2', '\x1735', '\x491', '\x3', '\x2', 
		'\x2', '\x2', '\x1736', '\x1739', '\x5', '\x494', '\x24B', '\x2', '\x1737', 
		'\x1739', '\x5', '\x4AA', '\x256', '\x2', '\x1738', '\x1736', '\x3', '\x2', 
		'\x2', '\x2', '\x1738', '\x1737', '\x3', '\x2', '\x2', '\x2', '\x1739', 
		'\x493', '\x3', '\x2', '\x2', '\x2', '\x173A', '\x173C', '\a', '\x18C', 
		'\x2', '\x2', '\x173B', '\x173D', '\a', '\x23B', '\x2', '\x2', '\x173C', 
		'\x173B', '\x3', '\x2', '\x2', '\x2', '\x173C', '\x173D', '\x3', '\x2', 
		'\x2', '\x2', '\x173D', '\x173E', '\x3', '\x2', '\x2', '\x2', '\x173E', 
		'\x173F', '\x5', '\x496', '\x24C', '\x2', '\x173F', '\x495', '\x3', '\x2', 
		'\x2', '\x2', '\x1740', '\x1741', '\a', '\x24B', '\x2', '\x2', '\x1741', 
		'\x1742', '\x5', '\x166', '\xB4', '\x2', '\x1742', '\x1743', '\x5', '\x498', 
		'\x24D', '\x2', '\x1743', '\x1744', '\x5', '\x49E', '\x250', '\x2', '\x1744', 
		'\x1745', '\a', '\x24C', '\x2', '\x2', '\x1745', '\x497', '\x3', '\x2', 
		'\x2', '\x2', '\x1746', '\x1747', '\a', '\xBE', '\x2', '\x2', '\x1747', 
		'\x1748', '\x5', '\x49A', '\x24E', '\x2', '\x1748', '\x499', '\x3', '\x2', 
		'\x2', '\x2', '\x1749', '\x174C', '\x5', '\x49C', '\x24F', '\x2', '\x174A', 
		'\x174C', '\x5', '\x44', '#', '\x2', '\x174B', '\x1749', '\x3', '\x2', 
		'\x2', '\x2', '\x174B', '\x174A', '\x3', '\x2', '\x2', '\x2', '\x174C', 
		'\x49B', '\x3', '\x2', '\x2', '\x2', '\x174D', '\x174E', '\a', '\x24B', 
		'\x2', '\x2', '\x174E', '\x174F', '\x5', '\x174', '\xBB', '\x2', '\x174F', 
		'\x1750', '\a', '\x24C', '\x2', '\x2', '\x1750', '\x49D', '\x3', '\x2', 
		'\x2', '\x2', '\x1751', '\x1754', '\a', '\xDE', '\x2', '\x2', '\x1752', 
		'\x1755', '\x5', '\x15C', '\xAF', '\x2', '\x1753', '\x1755', '\x5', '\x4A0', 
		'\x251', '\x2', '\x1754', '\x1752', '\x3', '\x2', '\x2', '\x2', '\x1754', 
		'\x1753', '\x3', '\x2', '\x2', '\x2', '\x1755', '\x49F', '\x3', '\x2', 
		'\x2', '\x2', '\x1756', '\x1757', '\a', '\x24B', '\x2', '\x2', '\x1757', 
		'\x175C', '\x5', '\x4A2', '\x252', '\x2', '\x1758', '\x1759', '\a', '\x24D', 
		'\x2', '\x2', '\x1759', '\x175B', '\x5', '\x4A2', '\x252', '\x2', '\x175A', 
		'\x1758', '\x3', '\x2', '\x2', '\x2', '\x175B', '\x175E', '\x3', '\x2', 
		'\x2', '\x2', '\x175C', '\x175A', '\x3', '\x2', '\x2', '\x2', '\x175C', 
		'\x175D', '\x3', '\x2', '\x2', '\x2', '\x175D', '\x175F', '\x3', '\x2', 
		'\x2', '\x2', '\x175E', '\x175C', '\x3', '\x2', '\x2', '\x2', '\x175F', 
		'\x1760', '\a', '\x24C', '\x2', '\x2', '\x1760', '\x4A1', '\x3', '\x2', 
		'\x2', '\x2', '\x1761', '\x1767', '\x5', '\x4A4', '\x253', '\x2', '\x1762', 
		'\x1764', '\x5', '\x4A6', '\x254', '\x2', '\x1763', '\x1765', '\x5', '\x172', 
		'\xBA', '\x2', '\x1764', '\x1763', '\x3', '\x2', '\x2', '\x2', '\x1764', 
		'\x1765', '\x3', '\x2', '\x2', '\x2', '\x1765', '\x1767', '\x3', '\x2', 
		'\x2', '\x2', '\x1766', '\x1761', '\x3', '\x2', '\x2', '\x2', '\x1766', 
		'\x1762', '\x3', '\x2', '\x2', '\x2', '\x1767', '\x4A3', '\x3', '\x2', 
		'\x2', '\x2', '\x1768', '\x1769', '\a', '\x11', '\x2', '\x2', '\x1769', 
		'\x4A5', '\x3', '\x2', '\x2', '\x2', '\x176A', '\x176D', '\x5', '\x4A8', 
		'\x255', '\x2', '\x176B', '\x176D', '\x5', '\xA2', 'R', '\x2', '\x176C', 
		'\x176A', '\x3', '\x2', '\x2', '\x2', '\x176C', '\x176B', '\x3', '\x2', 
		'\x2', '\x2', '\x176D', '\x4A7', '\x3', '\x2', '\x2', '\x2', '\x176E', 
		'\x176F', '\a', '\x24B', '\x2', '\x2', '\x176F', '\x1770', '\x5', '\x166', 
		'\xB4', '\x2', '\x1770', '\x1771', '\a', '\x24C', '\x2', '\x2', '\x1771', 
		'\x4A9', '\x3', '\x2', '\x2', '\x2', '\x1772', '\x1777', '\a', '\x21B', 
		'\x2', '\x2', '\x1773', '\x1774', '\a', '\xDF', '\x2', '\x2', '\x1774', 
		'\x1778', '\a', '\x15F', '\x2', '\x2', '\x1775', '\x1776', '\a', '\xA8', 
		'\x2', '\x2', '\x1776', '\x1778', '\a', '\x15F', '\x2', '\x2', '\x1777', 
		'\x1773', '\x3', '\x2', '\x2', '\x2', '\x1777', '\x1775', '\x3', '\x2', 
		'\x2', '\x2', '\x1777', '\x1778', '\x3', '\x2', '\x2', '\x2', '\x1778', 
		'\x1779', '\x3', '\x2', '\x2', '\x2', '\x1779', '\x177A', '\x5', '\x4AC', 
		'\x257', '\x2', '\x177A', '\x4AB', '\x3', '\x2', '\x2', '\x2', '\x177B', 
		'\x177C', '\a', '\x24B', '\x2', '\x2', '\x177C', '\x177D', '\x5', '\x49A', 
		'\x24E', '\x2', '\x177D', '\x177E', '\x5', '\x498', '\x24D', '\x2', '\x177E', 
		'\x177F', '\x5', '\x4AE', '\x258', '\x2', '\x177F', '\x1780', '\a', '\x24C', 
		'\x2', '\x2', '\x1780', '\x4AD', '\x3', '\x2', '\x2', '\x2', '\x1781', 
		'\x1782', '\a', '\xDE', '\x2', '\x2', '\x1782', '\x1783', '\x5', '\x4B0', 
		'\x259', '\x2', '\x1783', '\x4AF', '\x3', '\x2', '\x2', '\x2', '\x1784', 
		'\x1785', '\a', '\x24B', '\x2', '\x2', '\x1785', '\x178A', '\x5', '\x4B2', 
		'\x25A', '\x2', '\x1786', '\x1787', '\a', '\x24D', '\x2', '\x2', '\x1787', 
		'\x1789', '\x5', '\x4B2', '\x25A', '\x2', '\x1788', '\x1786', '\x3', '\x2', 
		'\x2', '\x2', '\x1789', '\x178C', '\x3', '\x2', '\x2', '\x2', '\x178A', 
		'\x1788', '\x3', '\x2', '\x2', '\x2', '\x178A', '\x178B', '\x3', '\x2', 
		'\x2', '\x2', '\x178B', '\x178D', '\x3', '\x2', '\x2', '\x2', '\x178C', 
		'\x178A', '\x3', '\x2', '\x2', '\x2', '\x178D', '\x178E', '\a', '\x24C', 
		'\x2', '\x2', '\x178E', '\x4B1', '\x3', '\x2', '\x2', '\x2', '\x178F', 
		'\x1791', '\x5', '\x49A', '\x24E', '\x2', '\x1790', '\x1792', '\x5', '\x4B4', 
		'\x25B', '\x2', '\x1791', '\x1790', '\x3', '\x2', '\x2', '\x2', '\x1791', 
		'\x1792', '\x3', '\x2', '\x2', '\x2', '\x1792', '\x4B3', '\x3', '\x2', 
		'\x2', '\x2', '\x1793', '\x1794', '\a', '\x15', '\x2', '\x2', '\x1794', 
		'\x1795', '\x5', '\x4B6', '\x25C', '\x2', '\x1795', '\x4B5', '\x3', '\x2', 
		'\x2', '\x2', '\x1796', '\x1799', '\x5', '\x4B8', '\x25D', '\x2', '\x1797', 
		'\x1799', '\x5', '(', '\x15', '\x2', '\x1798', '\x1796', '\x3', '\x2', 
		'\x2', '\x2', '\x1798', '\x1797', '\x3', '\x2', '\x2', '\x2', '\x1799', 
		'\x4B7', '\x3', '\x2', '\x2', '\x2', '\x179A', '\x179B', '\a', '\x24B', 
		'\x2', '\x2', '\x179B', '\x17A0', '\x5', '(', '\x15', '\x2', '\x179C', 
		'\x179D', '\a', '\x24D', '\x2', '\x2', '\x179D', '\x179F', '\x5', '(', 
		'\x15', '\x2', '\x179E', '\x179C', '\x3', '\x2', '\x2', '\x2', '\x179F', 
		'\x17A2', '\x3', '\x2', '\x2', '\x2', '\x17A0', '\x179E', '\x3', '\x2', 
		'\x2', '\x2', '\x17A0', '\x17A1', '\x3', '\x2', '\x2', '\x2', '\x17A1', 
		'\x17A3', '\x3', '\x2', '\x2', '\x2', '\x17A2', '\x17A0', '\x3', '\x2', 
		'\x2', '\x2', '\x17A3', '\x17A4', '\a', '\x24C', '\x2', '\x2', '\x17A4', 
		'\x4B9', '\x3', '\x2', '\x2', '\x2', '\x17A5', '\x17A8', '\x5', '\x4BC', 
		'\x25F', '\x2', '\x17A6', '\x17A8', '\x5', '\x4BE', '\x260', '\x2', '\x17A7', 
		'\x17A5', '\x3', '\x2', '\x2', '\x2', '\x17A7', '\x17A6', '\x3', '\x2', 
		'\x2', '\x2', '\x17A8', '\x4BB', '\x3', '\x2', '\x2', '\x2', '\x17A9', 
		'\x17AA', '\a', '\x15', '\x2', '\x2', '\x17AA', '\x17AF', '\a', '\x162', 
		'\x2', '\x2', '\x17AB', '\x17AC', '\x5', '\x4C2', '\x262', '\x2', '\x17AC', 
		'\x17AD', '\x5', '\x166', '\xB4', '\x2', '\x17AD', '\x17B0', '\x3', '\x2', 
		'\x2', '\x2', '\x17AE', '\x17B0', '\x5', '\x4C0', '\x261', '\x2', '\x17AF', 
		'\x17AB', '\x3', '\x2', '\x2', '\x2', '\x17AF', '\x17AE', '\x3', '\x2', 
		'\x2', '\x2', '\x17B0', '\x4BD', '\x3', '\x2', '\x2', '\x2', '\x17B1', 
		'\x17B5', '\a', '\x22C', '\x2', '\x2', '\x17B2', '\x17B3', '\a', '&', 
		'\x2', '\x2', '\x17B3', '\x17B6', '\x5', '\x4C2', '\x262', '\x2', '\x17B4', 
		'\x17B6', '\x5', '\x4C0', '\x261', '\x2', '\x17B5', '\x17B2', '\x3', '\x2', 
		'\x2', '\x2', '\x17B5', '\x17B4', '\x3', '\x2', '\x2', '\x2', '\x17B6', 
		'\x17B7', '\x3', '\x2', '\x2', '\x2', '\x17B7', '\x17B8', '\x5', '\xC8', 
		'\x65', '\x2', '\x17B8', '\x17B9', '\a', '\x10', '\x2', '\x2', '\x17B9', 
		'\x17BA', '\x5', '\xC8', '\x65', '\x2', '\x17BA', '\x4BF', '\x3', '\x2', 
		'\x2', '\x2', '\x17BB', '\x17BC', '\a', '\x189', '\x2', '\x2', '\x17BC', 
		'\x17BD', '\a', '\xBE', '\x2', '\x2', '\x17BD', '\x17C0', '\x5', '\x44', 
		'#', '\x2', '\x17BE', '\x17C1', '\x5', '\xA2', 'R', '\x2', '\x17BF', '\x17C1', 
		'\a', '&', '\x2', '\x2', '\x17C0', '\x17BE', '\x3', '\x2', '\x2', '\x2', 
		'\x17C0', '\x17BF', '\x3', '\x2', '\x2', '\x2', '\x17C1', '\x4C1', '\x3', 
		'\x2', '\x2', '\x2', '\x17C2', '\x17C3', '\t', 'X', '\x2', '\x2', '\x17C3', 
		'\x4C3', '\x3', '\x2', '\x2', '\x2', '\x17C4', '\x17C6', '\a', '\x1C4', 
		'\x2', '\x2', '\x17C5', '\x17C7', '\a', ')', '\x2', '\x2', '\x17C6', '\x17C5', 
		'\x3', '\x2', '\x2', '\x2', '\x17C6', '\x17C7', '\x3', '\x2', '\x2', '\x2', 
		'\x17C7', '\x17C8', '\x3', '\x2', '\x2', '\x2', '\x17C8', '\x17CA', '\x5', 
		'\x4C8', '\x265', '\x2', '\x17C9', '\x17CB', '\x5', '\x4C6', '\x264', 
		'\x2', '\x17CA', '\x17C9', '\x3', '\x2', '\x2', '\x2', '\x17CA', '\x17CB', 
		'\x3', '\x2', '\x2', '\x2', '\x17CB', '\x4C5', '\x3', '\x2', '\x2', '\x2', 
		'\x17CC', '\x17CD', '\a', '\x1CE', '\x2', '\x2', '\x17CD', '\x17CE', '\x5', 
		'\x4C8', '\x265', '\x2', '\x17CE', '\x4C7', '\x3', '\x2', '\x2', '\x2', 
		'\x17CF', '\x17D0', '\a', '\x24B', '\x2', '\x2', '\x17D0', '\x17D1', '\x5', 
		'\xA2', 'R', '\x2', '\x17D1', '\x17D2', '\a', '\x24C', '\x2', '\x2', '\x17D2', 
		'\x4C9', '\x3', '\x2', '\x2', '\x2', '\x17D3', '\x17D5', '\a', '\x15', 
		'\x2', '\x2', '\x17D4', '\x17D3', '\x3', '\x2', '\x2', '\x2', '\x17D4', 
		'\x17D5', '\x3', '\x2', '\x2', '\x2', '\x17D5', '\x17D6', '\x3', '\x2', 
		'\x2', '\x2', '\x17D6', '\x17D7', '\x5', '^', '\x30', '\x2', '\x17D7', 
		'\x4CB', '\x3', '\x2', '\x2', '\x2', '\x17D8', '\x17D9', '\x5', '\\', 
		'/', '\x2', '\x17D9', '\x4CD', '\x3', '\x2', '\x2', '\x2', '\x17DA', '\x17DB', 
		'\a', '\x24B', '\x2', '\x2', '\x17DB', '\x17DC', '\x5', '\x174', '\xBB', 
		'\x2', '\x17DC', '\x17DD', '\a', '\x24C', '\x2', '\x2', '\x17DD', '\x4CF', 
		'\x3', '\x2', '\x2', '\x2', '\x17DE', '\x17E4', '\a', '\x226', '\x2', 
		'\x2', '\x17DF', '\x17E0', '\a', '\x24B', '\x2', '\x2', '\x17E0', '\x17E1', 
		'\x5', '\x4D2', '\x26A', '\x2', '\x17E1', '\x17E2', '\a', '\x24C', '\x2', 
		'\x2', '\x17E2', '\x17E5', '\x3', '\x2', '\x2', '\x2', '\x17E3', '\x17E5', 
		'\x5', '\x44', '#', '\x2', '\x17E4', '\x17DF', '\x3', '\x2', '\x2', '\x2', 
		'\x17E4', '\x17E3', '\x3', '\x2', '\x2', '\x2', '\x17E5', '\x4D1', '\x3', 
		'\x2', '\x2', '\x2', '\x17E6', '\x17E7', '\x5', '\x166', '\xB4', '\x2', 
		'\x17E7', '\x4D3', '\x3', '\x2', '\x2', '\x2', '\x17E8', '\x17EC', '\a', 
		'\xEB', '\x2', '\x2', '\x17E9', '\x17ED', '\x5', '\x4D6', '\x26C', '\x2', 
		'\x17EA', '\x17ED', '\x5', '\x4D8', '\x26D', '\x2', '\x17EB', '\x17ED', 
		'\x5', '\x4DC', '\x26F', '\x2', '\x17EC', '\x17E9', '\x3', '\x2', '\x2', 
		'\x2', '\x17EC', '\x17EA', '\x3', '\x2', '\x2', '\x2', '\x17EC', '\x17EB', 
		'\x3', '\x2', '\x2', '\x2', '\x17ED', '\x4D5', '\x3', '\x2', '\x2', '\x2', 
		'\x17EE', '\x17EF', '\a', '\xF2', '\x2', '\x2', '\x17EF', '\x17F1', '\x5', 
		'\x460', '\x231', '\x2', '\x17F0', '\x17F2', '\x5', '\x4CE', '\x268', 
		'\x2', '\x17F1', '\x17F0', '\x3', '\x2', '\x2', '\x2', '\x17F1', '\x17F2', 
		'\x3', '\x2', '\x2', '\x2', '\x17F2', '\x17F5', '\x3', '\x2', '\x2', '\x2', 
		'\x17F3', '\x17F6', '\x5', '\x4D0', '\x269', '\x2', '\x17F4', '\x17F6', 
		'\x5', '\x3EE', '\x1F8', '\x2', '\x17F5', '\x17F3', '\x3', '\x2', '\x2', 
		'\x2', '\x17F5', '\x17F4', '\x3', '\x2', '\x2', '\x2', '\x17F6', '\x17F8', 
		'\x3', '\x2', '\x2', '\x2', '\x17F7', '\x17F9', '\x5', '\x3EA', '\x1F6', 
		'\x2', '\x17F8', '\x17F7', '\x3', '\x2', '\x2', '\x2', '\x17F8', '\x17F9', 
		'\x3', '\x2', '\x2', '\x2', '\x17F9', '\x17FB', '\x3', '\x2', '\x2', '\x2', 
		'\x17FA', '\x17FC', '\x5', '\x51C', '\x28F', '\x2', '\x17FB', '\x17FA', 
		'\x3', '\x2', '\x2', '\x2', '\x17FB', '\x17FC', '\x3', '\x2', '\x2', '\x2', 
		'\x17FC', '\x4D7', '\x3', '\x2', '\x2', '\x2', '\x17FD', '\x17FF', '\a', 
		'\n', '\x2', '\x2', '\x17FE', '\x1800', '\x5', '\x4DA', '\x26E', '\x2', 
		'\x17FF', '\x17FE', '\x3', '\x2', '\x2', '\x2', '\x1800', '\x1801', '\x3', 
		'\x2', '\x2', '\x2', '\x1801', '\x17FF', '\x3', '\x2', '\x2', '\x2', '\x1801', 
		'\x1802', '\x3', '\x2', '\x2', '\x2', '\x1802', '\x1803', '\x3', '\x2', 
		'\x2', '\x2', '\x1803', '\x1804', '\x5', '\x3EE', '\x1F8', '\x2', '\x1804', 
		'\x4D9', '\x3', '\x2', '\x2', '\x2', '\x1805', '\x1806', '\a', '\xF2', 
		'\x2', '\x2', '\x1806', '\x1808', '\x5', '\x460', '\x231', '\x2', '\x1807', 
		'\x1809', '\x5', '\x4CE', '\x268', '\x2', '\x1808', '\x1807', '\x3', '\x2', 
		'\x2', '\x2', '\x1808', '\x1809', '\x3', '\x2', '\x2', '\x2', '\x1809', 
		'\x180B', '\x3', '\x2', '\x2', '\x2', '\x180A', '\x180C', '\x5', '\x4D0', 
		'\x269', '\x2', '\x180B', '\x180A', '\x3', '\x2', '\x2', '\x2', '\x180B', 
		'\x180C', '\x3', '\x2', '\x2', '\x2', '\x180C', '\x180E', '\x3', '\x2', 
		'\x2', '\x2', '\x180D', '\x180F', '\x5', '\x51C', '\x28F', '\x2', '\x180E', 
		'\x180D', '\x3', '\x2', '\x2', '\x2', '\x180E', '\x180F', '\x3', '\x2', 
		'\x2', '\x2', '\x180F', '\x4DB', '\x3', '\x2', '\x2', '\x2', '\x1810', 
		'\x1812', '\t', 'Y', '\x2', '\x2', '\x1811', '\x1810', '\x3', '\x2', '\x2', 
		'\x2', '\x1811', '\x1812', '\x3', '\x2', '\x2', '\x2', '\x1812', '\x1814', 
		'\x3', '\x2', '\x2', '\x2', '\x1813', '\x1815', '\x5', '\x4DE', '\x270', 
		'\x2', '\x1814', '\x1813', '\x3', '\x2', '\x2', '\x2', '\x1815', '\x1816', 
		'\x3', '\x2', '\x2', '\x2', '\x1816', '\x1814', '\x3', '\x2', '\x2', '\x2', 
		'\x1816', '\x1817', '\x3', '\x2', '\x2', '\x2', '\x1817', '\x1819', '\x3', 
		'\x2', '\x2', '\x2', '\x1818', '\x181A', '\x5', '\x4E2', '\x272', '\x2', 
		'\x1819', '\x1818', '\x3', '\x2', '\x2', '\x2', '\x1819', '\x181A', '\x3', 
		'\x2', '\x2', '\x2', '\x181A', '\x181B', '\x3', '\x2', '\x2', '\x2', '\x181B', 
		'\x181C', '\x5', '\x3EE', '\x1F8', '\x2', '\x181C', '\x4DD', '\x3', '\x2', 
		'\x2', '\x2', '\x181D', '\x181E', '\a', '\x231', '\x2', '\x2', '\x181E', 
		'\x181F', '\x5', '\xA2', 'R', '\x2', '\x181F', '\x1820', '\x5', '\x4E0', 
		'\x271', '\x2', '\x1820', '\x4DF', '\x3', '\x2', '\x2', '\x2', '\x1821', 
		'\x1823', '\a', '\x202', '\x2', '\x2', '\x1822', '\x1824', '\x5', '\x4DA', 
		'\x26E', '\x2', '\x1823', '\x1822', '\x3', '\x2', '\x2', '\x2', '\x1824', 
		'\x1825', '\x3', '\x2', '\x2', '\x2', '\x1825', '\x1823', '\x3', '\x2', 
		'\x2', '\x2', '\x1825', '\x1826', '\x3', '\x2', '\x2', '\x2', '\x1826', 
		'\x4E1', '\x3', '\x2', '\x2', '\x2', '\x1827', '\x1829', '\a', '\x97', 
		'\x2', '\x2', '\x1828', '\x182A', '\x5', '\x4DA', '\x26E', '\x2', '\x1829', 
		'\x1828', '\x3', '\x2', '\x2', '\x2', '\x182A', '\x182B', '\x3', '\x2', 
		'\x2', '\x2', '\x182B', '\x1829', '\x3', '\x2', '\x2', '\x2', '\x182B', 
		'\x182C', '\x3', '\x2', '\x2', '\x2', '\x182C', '\x4E3', '\x3', '\x2', 
		'\x2', '\x2', '\x182D', '\x1837', '\a', '\x1D8', '\x2', '\x2', '\x182E', 
		'\x1838', '\x5', '\x4E6', '\x274', '\x2', '\x182F', '\x1834', '\x5', '\x4E8', 
		'\x275', '\x2', '\x1830', '\x1831', '\a', '\x24D', '\x2', '\x2', '\x1831', 
		'\x1833', '\x5', '\x4E8', '\x275', '\x2', '\x1832', '\x1830', '\x3', '\x2', 
		'\x2', '\x2', '\x1833', '\x1836', '\x3', '\x2', '\x2', '\x2', '\x1834', 
		'\x1832', '\x3', '\x2', '\x2', '\x2', '\x1834', '\x1835', '\x3', '\x2', 
		'\x2', '\x2', '\x1835', '\x1838', '\x3', '\x2', '\x2', '\x2', '\x1836', 
		'\x1834', '\x3', '\x2', '\x2', '\x2', '\x1837', '\x182E', '\x3', '\x2', 
		'\x2', '\x2', '\x1837', '\x182F', '\x3', '\x2', '\x2', '\x2', '\x1838', 
		'\x4E5', '\x3', '\x2', '\x2', '\x2', '\x1839', '\x183A', '\a', '\x225', 
		'\x2', '\x2', '\x183A', '\x183B', '\a', '\x24B', '\x2', '\x2', '\x183B', 
		'\x183C', '\x5', '\x44', '#', '\x2', '\x183C', '\x183D', '\a', '\x24C', 
		'\x2', '\x2', '\x183D', '\x183E', '\a', '\x253', '\x2', '\x2', '\x183E', 
		'\x183F', '\x5', '\xA2', 'R', '\x2', '\x183F', '\x4E7', '\x3', '\x2', 
		'\x2', '\x2', '\x1840', '\x1846', '\x5', '\x44', '#', '\x2', '\x1841', 
		'\x1842', '\a', '\x24B', '\x2', '\x2', '\x1842', '\x1843', '\x5', '\x44', 
		'#', '\x2', '\x1843', '\x1844', '\a', '\x24C', '\x2', '\x2', '\x1844', 
		'\x1846', '\x3', '\x2', '\x2', '\x2', '\x1845', '\x1840', '\x3', '\x2', 
		'\x2', '\x2', '\x1845', '\x1841', '\x3', '\x2', '\x2', '\x2', '\x1846', 
		'\x1847', '\x3', '\x2', '\x2', '\x2', '\x1847', '\x184B', '\a', '\x253', 
		'\x2', '\x2', '\x1848', '\x184C', '\x5', '\x15C', '\xAF', '\x2', '\x1849', 
		'\x184C', '\x5', '\xA2', 'R', '\x2', '\x184A', '\x184C', '\x5', '\x16A', 
		'\xB6', '\x2', '\x184B', '\x1848', '\x3', '\x2', '\x2', '\x2', '\x184B', 
		'\x1849', '\x3', '\x2', '\x2', '\x2', '\x184B', '\x184A', '\x3', '\x2', 
		'\x2', '\x2', '\x184C', '\x1852', '\x3', '\x2', '\x2', '\x2', '\x184D', 
		'\x184E', '\x5', '\x4EA', '\x276', '\x2', '\x184E', '\x184F', '\a', '\x253', 
		'\x2', '\x2', '\x184F', '\x1850', '\x5', '\x15C', '\xAF', '\x2', '\x1850', 
		'\x1852', '\x3', '\x2', '\x2', '\x2', '\x1851', '\x1845', '\x3', '\x2', 
		'\x2', '\x2', '\x1851', '\x184D', '\x3', '\x2', '\x2', '\x2', '\x1852', 
		'\x4E9', '\x3', '\x2', '\x2', '\x2', '\x1853', '\x1854', '\a', '\x24B', 
		'\x2', '\x2', '\x1854', '\x1855', '\x5', '\x174', '\xBB', '\x2', '\x1855', 
		'\x1856', '\a', '\x24C', '\x2', '\x2', '\x1856', '\x4EB', '\x3', '\x2', 
		'\x2', '\x2', '\x1857', '\x185A', '\a', '\x21E', '\x2', '\x2', '\x1858', 
		'\x185B', '\x5', '\x3EC', '\x1F7', '\x2', '\x1859', '\x185B', '\x5', '\x460', 
		'\x231', '\x2', '\x185A', '\x1858', '\x3', '\x2', '\x2', '\x2', '\x185A', 
		'\x1859', '\x3', '\x2', '\x2', '\x2', '\x185B', '\x185C', '\x3', '\x2', 
		'\x2', '\x2', '\x185C', '\x185E', '\x5', '\x4E4', '\x273', '\x2', '\x185D', 
		'\x185F', '\x5', '\x424', '\x213', '\x2', '\x185E', '\x185D', '\x3', '\x2', 
		'\x2', '\x2', '\x185E', '\x185F', '\x3', '\x2', '\x2', '\x2', '\x185F', 
		'\x1861', '\x3', '\x2', '\x2', '\x2', '\x1860', '\x1862', '\x5', '\x3EA', 
		'\x1F6', '\x2', '\x1861', '\x1860', '\x3', '\x2', '\x2', '\x2', '\x1861', 
		'\x1862', '\x3', '\x2', '\x2', '\x2', '\x1862', '\x1864', '\x3', '\x2', 
		'\x2', '\x2', '\x1863', '\x1865', '\x5', '\x51C', '\x28F', '\x2', '\x1864', 
		'\x1863', '\x3', '\x2', '\x2', '\x2', '\x1864', '\x1865', '\x3', '\x2', 
		'\x2', '\x2', '\x1865', '\x4ED', '\x3', '\x2', '\x2', '\x2', '\x1866', 
		'\x1868', '\a', '}', '\x2', '\x2', '\x1867', '\x1869', '\a', '\xC8', '\x2', 
		'\x2', '\x1868', '\x1867', '\x3', '\x2', '\x2', '\x2', '\x1868', '\x1869', 
		'\x3', '\x2', '\x2', '\x2', '\x1869', '\x186C', '\x3', '\x2', '\x2', '\x2', 
		'\x186A', '\x186D', '\x5', '\x3EC', '\x1F7', '\x2', '\x186B', '\x186D', 
		'\x5', '\x460', '\x231', '\x2', '\x186C', '\x186A', '\x3', '\x2', '\x2', 
		'\x2', '\x186C', '\x186B', '\x3', '\x2', '\x2', '\x2', '\x186D', '\x186F', 
		'\x3', '\x2', '\x2', '\x2', '\x186E', '\x1870', '\x5', '\x424', '\x213', 
		'\x2', '\x186F', '\x186E', '\x3', '\x2', '\x2', '\x2', '\x186F', '\x1870', 
		'\x3', '\x2', '\x2', '\x2', '\x1870', '\x1872', '\x3', '\x2', '\x2', '\x2', 
		'\x1871', '\x1873', '\x5', '\x3EA', '\x1F6', '\x2', '\x1872', '\x1871', 
		'\x3', '\x2', '\x2', '\x2', '\x1872', '\x1873', '\x3', '\x2', '\x2', '\x2', 
		'\x1873', '\x1875', '\x3', '\x2', '\x2', '\x2', '\x1874', '\x1876', '\x5', 
		'\x51C', '\x28F', '\x2', '\x1875', '\x1874', '\x3', '\x2', '\x2', '\x2', 
		'\x1875', '\x1876', '\x3', '\x2', '\x2', '\x2', '\x1876', '\x4EF', '\x3', 
		'\x2', '\x2', '\x2', '\x1877', '\x1878', '\a', '\x44', '\x2', '\x2', '\x1878', 
		'\x1879', '\x5', '\x44', '#', '\x2', '\x1879', '\x4F1', '\x3', '\x2', 
		'\x2', '\x2', '\x187A', '\x187B', '\a', '\xB6', '\x2', '\x2', '\x187B', 
		'\x187E', '\x5', '\x44', '#', '\x2', '\x187C', '\x187F', '\x5', '\x4F4', 
		'\x27B', '\x2', '\x187D', '\x187F', '\x5', '\x4F6', '\x27C', '\x2', '\x187E', 
		'\x187C', '\x3', '\x2', '\x2', '\x2', '\x187E', '\x187D', '\x3', '\x2', 
		'\x2', '\x2', '\x187F', '\x1881', '\x3', '\x2', '\x2', '\x2', '\x1880', 
		'\x1882', '\x5', '\x4F8', '\x27D', '\x2', '\x1881', '\x1880', '\x3', '\x2', 
		'\x2', '\x2', '\x1881', '\x1882', '\x3', '\x2', '\x2', '\x2', '\x1882', 
		'\x4F3', '\x3', '\x2', '\x2', '\x2', '\x1883', '\x1884', '\a', '\xF2', 
		'\x2', '\x2', '\x1884', '\x1885', '\x5', '\x174', '\xBB', '\x2', '\x1885', 
		'\x4F5', '\x3', '\x2', '\x2', '\x2', '\x1886', '\x1887', '\a', '\x30', 
		'\x2', '\x2', '\x1887', '\x1888', '\a', 'I', '\x2', '\x2', '\x1888', '\x1889', 
		'\a', '\xF2', '\x2', '\x2', '\x1889', '\x188A', '\x5', '\x174', '\xBB', 
		'\x2', '\x188A', '\x4F7', '\x3', '\x2', '\x2', '\x2', '\x188B', '\x188C', 
		'\a', '\x10C', '\x2', '\x2', '\x188C', '\x188D', '\x5', '\xA2', 'R', '\x2', 
		'\x188D', '\x4F9', '\x3', '\x2', '\x2', '\x2', '\x188E', '\x188F', '\a', 
		'\x16A', '\x2', '\x2', '\x188F', '\x1891', '\x5', '\x44', '#', '\x2', 
		'\x1890', '\x1892', '\x5', '\x4FC', '\x27F', '\x2', '\x1891', '\x1890', 
		'\x3', '\x2', '\x2', '\x2', '\x1891', '\x1892', '\x3', '\x2', '\x2', '\x2', 
		'\x1892', '\x4FB', '\x3', '\x2', '\x2', '\x2', '\x1893', '\x1899', '\a', 
		'\xBE', '\x2', '\x2', '\x1894', '\x189A', '\x5', '\x3EE', '\x1F8', '\x2', 
		'\x1895', '\x1897', '\x5', '\xA2', 'R', '\x2', '\x1896', '\x1898', '\x5', 
		'\x4FE', '\x280', '\x2', '\x1897', '\x1896', '\x3', '\x2', '\x2', '\x2', 
		'\x1897', '\x1898', '\x3', '\x2', '\x2', '\x2', '\x1898', '\x189A', '\x3', 
		'\x2', '\x2', '\x2', '\x1899', '\x1894', '\x3', '\x2', '\x2', '\x2', '\x1899', 
		'\x1895', '\x3', '\x2', '\x2', '\x2', '\x189A', '\x4FD', '\x3', '\x2', 
		'\x2', '\x2', '\x189B', '\x189C', '\a', '\x223', '\x2', '\x2', '\x189C', 
		'\x18A1', '\x5', '\x500', '\x281', '\x2', '\x189D', '\x189E', '\a', '\x24D', 
		'\x2', '\x2', '\x189E', '\x18A0', '\x5', '\x500', '\x281', '\x2', '\x189F', 
		'\x189D', '\x3', '\x2', '\x2', '\x2', '\x18A0', '\x18A3', '\x3', '\x2', 
		'\x2', '\x2', '\x18A1', '\x189F', '\x3', '\x2', '\x2', '\x2', '\x18A1', 
		'\x18A2', '\x3', '\x2', '\x2', '\x2', '\x18A2', '\x4FF', '\x3', '\x2', 
		'\x2', '\x2', '\x18A3', '\x18A1', '\x3', '\x2', '\x2', '\x2', '\x18A4', 
		'\x18A5', '\a', '\xDE', '\x2', '\x2', '\x18A5', '\x18A9', '\a', '\x172', 
		'\x2', '\x2', '\x18A6', '\x18A9', '\a', '\xDE', '\x2', '\x2', '\x18A7', 
		'\x18A9', '\a', '\x172', '\x2', '\x2', '\x18A8', '\x18A4', '\x3', '\x2', 
		'\x2', '\x2', '\x18A8', '\x18A6', '\x3', '\x2', '\x2', '\x2', '\x18A8', 
		'\x18A7', '\x3', '\x2', '\x2', '\x2', '\x18A8', '\x18A9', '\x3', '\x2', 
		'\x2', '\x2', '\x18A9', '\x18AA', '\x3', '\x2', '\x2', '\x2', '\x18AA', 
		'\x18AB', '\x5', '\xA2', 'R', '\x2', '\x18AB', '\x501', '\x3', '\x2', 
		'\x2', '\x2', '\x18AC', '\x18AE', '\a', 'N', '\x2', '\x2', '\x18AD', '\x18AF', 
		'\a', '\x237', '\x2', '\x2', '\x18AE', '\x18AD', '\x3', '\x2', '\x2', 
		'\x2', '\x18AE', '\x18AF', '\x3', '\x2', '\x2', '\x2', '\x18AF', '\x18B6', 
		'\x3', '\x2', '\x2', '\x2', '\x18B0', '\x18B2', '\x5', '\x504', '\x283', 
		'\x2', '\x18B1', '\x18B3', '\x5', '\x506', '\x284', '\x2', '\x18B2', '\x18B1', 
		'\x3', '\x2', '\x2', '\x2', '\x18B2', '\x18B3', '\x3', '\x2', '\x2', '\x2', 
		'\x18B3', '\x18B7', '\x3', '\x2', '\x2', '\x2', '\x18B4', '\x18B7', '\x5', 
		'\x506', '\x284', '\x2', '\x18B5', '\x18B7', '\x5', '\x508', '\x285', 
		'\x2', '\x18B6', '\x18B0', '\x3', '\x2', '\x2', '\x2', '\x18B6', '\x18B4', 
		'\x3', '\x2', '\x2', '\x2', '\x18B6', '\x18B5', '\x3', '\x2', '\x2', '\x2', 
		'\x18B6', '\x18B7', '\x3', '\x2', '\x2', '\x2', '\x18B7', '\x503', '\x3', 
		'\x2', '\x2', '\x2', '\x18B8', '\x18B9', '\a', 'M', '\x2', '\x2', '\x18B9', 
		'\x18BA', '\x5', '(', '\x15', '\x2', '\x18BA', '\x505', '\x3', '\x2', 
		'\x2', '\x2', '\x18BB', '\x18BD', '\a', '\x23A', '\x2', '\x2', '\x18BC', 
		'\x18BE', '\t', 'Z', '\x2', '\x2', '\x18BD', '\x18BC', '\x3', '\x2', '\x2', 
		'\x2', '\x18BD', '\x18BE', '\x3', '\x2', '\x2', '\x2', '\x18BE', '\x18C0', 
		'\x3', '\x2', '\x2', '\x2', '\x18BF', '\x18C1', '\t', '[', '\x2', '\x2', 
		'\x18C0', '\x18BF', '\x3', '\x2', '\x2', '\x2', '\x18C0', '\x18C1', '\x3', 
		'\x2', '\x2', '\x2', '\x18C1', '\x507', '\x3', '\x2', '\x2', '\x2', '\x18C2', 
		'\x18C3', '\a', '\xC0', '\x2', '\x2', '\x18C3', '\x18C6', '\x5', '(', 
		'\x15', '\x2', '\x18C4', '\x18C5', '\a', '\x24D', '\x2', '\x2', '\x18C5', 
		'\x18C7', '\a', '\x245', '\x2', '\x2', '\x18C6', '\x18C4', '\x3', '\x2', 
		'\x2', '\x2', '\x18C6', '\x18C7', '\x3', '\x2', '\x2', '\x2', '\x18C7', 
		'\x509', '\x3', '\x2', '\x2', '\x2', '\x18C8', '\x18C9', '\a', '\x1D8', 
		'\x2', '\x2', '\x18C9', '\x18D3', '\a', '\x20B', '\x2', '\x2', '\x18CA', 
		'\x18CE', '\x5', '\x50E', '\x288', '\x2', '\x18CB', '\x18CE', '\x5', '\x510', 
		'\x289', '\x2', '\x18CC', '\x18CE', '\x5', '\x512', '\x28A', '\x2', '\x18CD', 
		'\x18CA', '\x3', '\x2', '\x2', '\x2', '\x18CD', '\x18CB', '\x3', '\x2', 
		'\x2', '\x2', '\x18CD', '\x18CC', '\x3', '\x2', '\x2', '\x2', '\x18CE', 
		'\x18D0', '\x3', '\x2', '\x2', '\x2', '\x18CF', '\x18D1', '\x5', '\x50C', 
		'\x287', '\x2', '\x18D0', '\x18CF', '\x3', '\x2', '\x2', '\x2', '\x18D0', 
		'\x18D1', '\x3', '\x2', '\x2', '\x2', '\x18D1', '\x18D4', '\x3', '\x2', 
		'\x2', '\x2', '\x18D2', '\x18D4', '\x5', '\x50C', '\x287', '\x2', '\x18D3', 
		'\x18CD', '\x3', '\x2', '\x2', '\x2', '\x18D3', '\x18D2', '\x3', '\x2', 
		'\x2', '\x2', '\x18D4', '\x50B', '\x3', '\x2', '\x2', '\x2', '\x18D5', 
		'\x18D6', '\a', '\x137', '\x2', '\x2', '\x18D6', '\x18D7', '\x5', '(', 
		'\x15', '\x2', '\x18D7', '\x50D', '\x3', '\x2', '\x2', '\x2', '\x18D8', 
		'\x18DA', '\a', '\x1A0', '\x2', '\x2', '\x18D9', '\x18DB', '\t', '\\', 
		'\x2', '\x2', '\x18DA', '\x18D9', '\x3', '\x2', '\x2', '\x2', '\x18DA', 
		'\x18DB', '\x3', '\x2', '\x2', '\x2', '\x18DB', '\x50F', '\x3', '\x2', 
		'\x2', '\x2', '\x18DC', '\x18DD', '\a', '\xF7', '\x2', '\x2', '\x18DD', 
		'\x18E1', '\a', '\x105', '\x2', '\x2', '\x18DE', '\x18E2', '\a', '\x1D3', 
		'\x2', '\x2', '\x18DF', '\x18E0', '\a', '\x1A0', '\x2', '\x2', '\x18E0', 
		'\x18E2', '\a', 'O', '\x2', '\x2', '\x18E1', '\x18DE', '\x3', '\x2', '\x2', 
		'\x2', '\x18E1', '\x18DF', '\x3', '\x2', '\x2', '\x2', '\x18E1', '\x18E2', 
		'\x3', '\x2', '\x2', '\x2', '\x18E2', '\x511', '\x3', '\x2', '\x2', '\x2', 
		'\x18E3', '\x18E4', '\a', '\x221', '\x2', '\x2', '\x18E4', '\x18E5', '\a', 
		'\x1BB', '\x2', '\x2', '\x18E5', '\x18E6', '\a', '\x1CF', '\x2', '\x2', 
		'\x18E6', '\x18E7', '\x5', '^', '\x30', '\x2', '\x18E7', '\x513', '\x3', 
		'\x2', '\x2', '\x2', '\x18E8', '\x18EA', '\a', '\x1BB', '\x2', '\x2', 
		'\x18E9', '\x18EB', '\a', '\x237', '\x2', '\x2', '\x18EA', '\x18E9', '\x3', 
		'\x2', '\x2', '\x2', '\x18EA', '\x18EB', '\x3', '\x2', '\x2', '\x2', '\x18EB', 
		'\x18ED', '\x3', '\x2', '\x2', '\x2', '\x18EC', '\x18EE', '\x5', '\x516', 
		'\x28C', '\x2', '\x18ED', '\x18EC', '\x3', '\x2', '\x2', '\x2', '\x18ED', 
		'\x18EE', '\x3', '\x2', '\x2', '\x2', '\x18EE', '\x515', '\x3', '\x2', 
		'\x2', '\x2', '\x18EF', '\x18F1', '\a', '\x209', '\x2', '\x2', '\x18F0', 
		'\x18F2', '\a', '\x1C6', '\x2', '\x2', '\x18F1', '\x18F0', '\x3', '\x2', 
		'\x2', '\x2', '\x18F1', '\x18F2', '\x3', '\x2', '\x2', '\x2', '\x18F2', 
		'\x18F3', '\x3', '\x2', '\x2', '\x2', '\x18F3', '\x18F4', '\x5', 'P', 
		')', '\x2', '\x18F4', '\x517', '\x3', '\x2', '\x2', '\x2', '\x18F5', '\x18F6', 
		'\a', '\x1C6', '\x2', '\x2', '\x18F6', '\x18F7', '\x5', 'P', ')', '\x2', 
		'\x18F7', '\x519', '\x3', '\x2', '\x2', '\x2', '\x18F8', '\x18F9', '\x5', 
		'\x44', '#', '\x2', '\x18F9', '\x18FA', '\a', '\x246', '\x2', '\x2', '\x18FA', 
		'\x18FB', '\x5', '\xA2', 'R', '\x2', '\x18FB', '\x51B', '\x3', '\x2', 
		'\x2', '\x2', '\x18FC', '\x18FD', '\a', '\x115', '\x2', '\x2', '\x18FD', 
		'\x18FF', '\a', '\xA1', '\x2', '\x2', '\x18FE', '\x1900', '\x5', '\x51E', 
		'\x290', '\x2', '\x18FF', '\x18FE', '\x3', '\x2', '\x2', '\x2', '\x18FF', 
		'\x1900', '\x3', '\x2', '\x2', '\x2', '\x1900', '\x1902', '\x3', '\x2', 
		'\x2', '\x2', '\x1901', '\x1903', '\x5', '\x520', '\x291', '\x2', '\x1902', 
		'\x1901', '\x3', '\x2', '\x2', '\x2', '\x1902', '\x1903', '\x3', '\x2', 
		'\x2', '\x2', '\x1903', '\x1905', '\x3', '\x2', '\x2', '\x2', '\x1904', 
		'\x1906', '\x5', '\x522', '\x292', '\x2', '\x1905', '\x1904', '\x3', '\x2', 
		'\x2', '\x2', '\x1905', '\x1906', '\x3', '\x2', '\x2', '\x2', '\x1906', 
		'\x51D', '\x3', '\x2', '\x2', '\x2', '\x1907', '\x1908', '\a', '\xF2', 
		'\x2', '\x2', '\x1908', '\x1909', '\x5', '\x44', '#', '\x2', '\x1909', 
		'\x51F', '\x3', '\x2', '\x2', '\x2', '\x190A', '\x190B', '\a', '\x24B', 
		'\x2', '\x2', '\x190B', '\x190C', '\x5', '\xA2', 'R', '\x2', '\x190C', 
		'\x190D', '\a', '\x24C', '\x2', '\x2', '\x190D', '\x521', '\x3', '\x2', 
		'\x2', '\x2', '\x190E', '\x190F', '\a', '\x1AA', '\x2', '\x2', '\x190F', 
		'\x1912', '\a', '\x10C', '\x2', '\x2', '\x1910', '\x1913', '\a', '\x219', 
		'\x2', '\x2', '\x1911', '\x1913', '\x5', '(', '\x15', '\x2', '\x1912', 
		'\x1910', '\x3', '\x2', '\x2', '\x2', '\x1912', '\x1911', '\x3', '\x2', 
		'\x2', '\x2', '\x1913', '\x523', '\x3', '\x2', '\x2', '\x2', '\x1914', 
		'\x1915', '\a', '\x129', '\x2', '\x2', '\x1915', '\x1916', '\a', '\xF2', 
		'\x2', '\x2', '\x1916', '\x1917', '\x5', '\x460', '\x231', '\x2', '\x1917', 
		'\x1918', '\x5', '\x528', '\x295', '\x2', '\x1918', '\x191A', '\x5', '\x52A', 
		'\x296', '\x2', '\x1919', '\x191B', '\x5', '\x526', '\x294', '\x2', '\x191A', 
		'\x1919', '\x3', '\x2', '\x2', '\x2', '\x191A', '\x191B', '\x3', '\x2', 
		'\x2', '\x2', '\x191B', '\x191D', '\x3', '\x2', '\x2', '\x2', '\x191C', 
		'\x191E', '\x5', '\x51C', '\x28F', '\x2', '\x191D', '\x191C', '\x3', '\x2', 
		'\x2', '\x2', '\x191D', '\x191E', '\x3', '\x2', '\x2', '\x2', '\x191E', 
		'\x525', '\x3', '\x2', '\x2', '\x2', '\x191F', '\x1921', '\x5', '\x52C', 
		'\x297', '\x2', '\x1920', '\x1922', '\x5', '\x530', '\x299', '\x2', '\x1921', 
		'\x1920', '\x3', '\x2', '\x2', '\x2', '\x1921', '\x1922', '\x3', '\x2', 
		'\x2', '\x2', '\x1922', '\x1928', '\x3', '\x2', '\x2', '\x2', '\x1923', 
		'\x1925', '\x5', '\x530', '\x299', '\x2', '\x1924', '\x1926', '\x5', '\x52C', 
		'\x297', '\x2', '\x1925', '\x1924', '\x3', '\x2', '\x2', '\x2', '\x1925', 
		'\x1926', '\x3', '\x2', '\x2', '\x2', '\x1926', '\x1928', '\x3', '\x2', 
		'\x2', '\x2', '\x1927', '\x191F', '\x3', '\x2', '\x2', '\x2', '\x1927', 
		'\x1923', '\x3', '\x2', '\x2', '\x2', '\x1928', '\x527', '\x3', '\x2', 
		'\x2', '\x2', '\x1929', '\x192A', '\a', '\x223', '\x2', '\x2', '\x192A', 
		'\x192B', '\x5', '\x460', '\x231', '\x2', '\x192B', '\x529', '\x3', '\x2', 
		'\x2', '\x2', '\x192C', '\x192D', '\a', '\x166', '\x2', '\x2', '\x192D', 
		'\x192E', '\a', '\x24B', '\x2', '\x2', '\x192E', '\x192F', '\x5', '\xA2', 
		'R', '\x2', '\x192F', '\x1930', '\a', '\x24C', '\x2', '\x2', '\x1930', 
		'\x52B', '\x3', '\x2', '\x2', '\x2', '\x1931', '\x1932', '\a', '\x231', 
		'\x2', '\x2', '\x1932', '\x1933', '\a', '\x11F', '\x2', '\x2', '\x1933', 
		'\x1934', '\a', '\x202', '\x2', '\x2', '\x1934', '\x1935', '\a', '\x21E', 
		'\x2', '\x2', '\x1935', '\x1937', '\x5', '\x4E4', '\x273', '\x2', '\x1936', 
		'\x1938', '\x5', '\x424', '\x213', '\x2', '\x1937', '\x1936', '\x3', '\x2', 
		'\x2', '\x2', '\x1937', '\x1938', '\x3', '\x2', '\x2', '\x2', '\x1938', 
		'\x193A', '\x3', '\x2', '\x2', '\x2', '\x1939', '\x193B', '\x5', '\x52E', 
		'\x298', '\x2', '\x193A', '\x1939', '\x3', '\x2', '\x2', '\x2', '\x193A', 
		'\x193B', '\x3', '\x2', '\x2', '\x2', '\x193B', '\x52D', '\x3', '\x2', 
		'\x2', '\x2', '\x193C', '\x193D', '\a', '}', '\x2', '\x2', '\x193D', '\x193E', 
		'\x5', '\x424', '\x213', '\x2', '\x193E', '\x52F', '\x3', '\x2', '\x2', 
		'\x2', '\x193F', '\x1940', '\a', '\x231', '\x2', '\x2', '\x1940', '\x1941', 
		'\a', '\x15A', '\x2', '\x2', '\x1941', '\x1942', '\a', '\x11F', '\x2', 
		'\x2', '\x1942', '\x1943', '\a', '\x202', '\x2', '\x2', '\x1943', '\x1945', 
		'\a', '\xEB', '\x2', '\x2', '\x1944', '\x1946', '\x5', '\x4CE', '\x268', 
		'\x2', '\x1945', '\x1944', '\x3', '\x2', '\x2', '\x2', '\x1945', '\x1946', 
		'\x3', '\x2', '\x2', '\x2', '\x1946', '\x1947', '\x3', '\x2', '\x2', '\x2', 
		'\x1947', '\x1949', '\x5', '\x4D0', '\x269', '\x2', '\x1948', '\x194A', 
		'\x5', '\x424', '\x213', '\x2', '\x1949', '\x1948', '\x3', '\x2', '\x2', 
		'\x2', '\x1949', '\x194A', '\x3', '\x2', '\x2', '\x2', '\x194A', '\x531', 
		'\x3', '\x2', '\x2', '\x2', '\x194B', '\x194C', '\a', '\xAA', '\x2', '\x2', 
		'\x194C', '\x194D', '\a', '\xDD', '\x2', '\x2', '\x194D', '\x1950', '\x5', 
		'\xA2', 'R', '\x2', '\x194E', '\x1951', '\x5', '\x422', '\x212', '\x2', 
		'\x194F', '\x1951', '\x5', '\x4F6', '\x27C', '\x2', '\x1950', '\x194E', 
		'\x3', '\x2', '\x2', '\x2', '\x1950', '\x194F', '\x3', '\x2', '\x2', '\x2', 
		'\x1950', '\x1951', '\x3', '\x2', '\x2', '\x2', '\x1951', '\x1953', '\x3', 
		'\x2', '\x2', '\x2', '\x1952', '\x1954', '\x5', '\x4FE', '\x280', '\x2', 
		'\x1953', '\x1952', '\x3', '\x2', '\x2', '\x2', '\x1953', '\x1954', '\x3', 
		'\x2', '\x2', '\x2', '\x1954', '\x1956', '\x3', '\x2', '\x2', '\x2', '\x1955', 
		'\x1957', '\x5', '\x534', '\x29B', '\x2', '\x1956', '\x1955', '\x3', '\x2', 
		'\x2', '\x2', '\x1956', '\x1957', '\x3', '\x2', '\x2', '\x2', '\x1957', 
		'\x533', '\x3', '\x2', '\x2', '\x2', '\x1958', '\x1959', '\t', ']', '\x2', 
		'\x2', '\x1959', '\x195A', '\x5', '\x422', '\x212', '\x2', '\x195A', '\x535', 
		'\x3', '\x2', '\x2', '\x2', '\x195B', '\x195C', '\a', '\x18A', '\x2', 
		'\x2', '\x195C', '\x195D', '\a', '\x1BD', '\x2', '\x2', '\x195D', '\x195E', 
		'\a', '\x24B', '\x2', '\x2', '\x195E', '\x195F', '\x5', '\xC8', '\x65', 
		'\x2', '\x195F', '\x1960', '\a', '\x24C', '\x2', '\x2', '\x1960', '\x537', 
		'\x3', '\x2', '\x2', '\x2', '\x1961', '\x1963', '\a', '\x19C', '\x2', 
		'\x2', '\x1962', '\x1964', '\x5', '\x44', '#', '\x2', '\x1963', '\x1962', 
		'\x3', '\x2', '\x2', '\x2', '\x1963', '\x1964', '\x3', '\x2', '\x2', '\x2', 
		'\x1964', '\x539', '\x3', '\x2', '\x2', '\x2', '\x1965', '\x1966', '\a', 
		'\x211', '\x2', '\x2', '\x1966', '\x1967', '\a', '\x1FB', '\x2', '\x2', 
		'\x1967', '\x1969', '\x5', '\x44', '#', '\x2', '\x1968', '\x196A', '\x5', 
		'\x53C', '\x29F', '\x2', '\x1969', '\x1968', '\x3', '\x2', '\x2', '\x2', 
		'\x1969', '\x196A', '\x3', '\x2', '\x2', '\x2', '\x196A', '\x196C', '\x3', 
		'\x2', '\x2', '\x2', '\x196B', '\x196D', '\x5', '\x542', '\x2A2', '\x2', 
		'\x196C', '\x196B', '\x3', '\x2', '\x2', '\x2', '\x196C', '\x196D', '\x3', 
		'\x2', '\x2', '\x2', '\x196D', '\x53B', '\x3', '\x2', '\x2', '\x2', '\x196E', 
		'\x196F', '\x5', '\x53E', '\x2A0', '\x2', '\x196F', '\x1970', '\a', '\x120', 
		'\x2', '\x2', '\x1970', '\x1971', '\a', '\x22D', '\x2', '\x2', '\x1971', 
		'\x1972', '\a', '\x115', '\x2', '\x2', '\x1972', '\x53D', '\x3', '\x2', 
		'\x2', '\x2', '\x1973', '\x1974', '\t', '^', '\x2', '\x2', '\x1974', '\x53F', 
		'\x3', '\x2', '\x2', '\x2', '\x1975', '\x1976', '\a', '\x211', '\x2', 
		'\x2', '\x1976', '\x1977', '\a', '\x45', '\x2', '\x2', '\x1977', '\x1979', 
		'\x5', '\x44', '#', '\x2', '\x1978', '\x197A', '\x5', '\x542', '\x2A2', 
		'\x2', '\x1979', '\x1978', '\x3', '\x2', '\x2', '\x2', '\x1979', '\x197A', 
		'\x3', '\x2', '\x2', '\x2', '\x197A', '\x541', '\x3', '\x2', '\x2', '\x2', 
		'\x197B', '\x197C', '\t', '_', '\x2', '\x2', '\x197C', '\x197D', '\a', 
		'\x1EB', '\x2', '\x2', '\x197D', '\x543', '\x3', '\x2', '\x2', '\x2', 
		'\x197E', '\x197F', '\a', '\x112', '\x2', '\x2', '\x197F', '\x1980', '\a', 
		'\x1FB', '\x2', '\x2', '\x1980', '\x1981', '\x5', '\x546', '\x2A4', '\x2', 
		'\x1981', '\x1983', '\x5', '\x548', '\x2A5', '\x2', '\x1982', '\x1984', 
		'\x5', '\x54A', '\x2A6', '\x2', '\x1983', '\x1982', '\x3', '\x2', '\x2', 
		'\x2', '\x1983', '\x1984', '\x3', '\x2', '\x2', '\x2', '\x1984', '\x545', 
		'\x3', '\x2', '\x2', '\x2', '\x1985', '\x198A', '\x5', '\x460', '\x231', 
		'\x2', '\x1986', '\x1987', '\a', '\x24D', '\x2', '\x2', '\x1987', '\x1989', 
		'\x5', '\x460', '\x231', '\x2', '\x1988', '\x1986', '\x3', '\x2', '\x2', 
		'\x2', '\x1989', '\x198C', '\x3', '\x2', '\x2', '\x2', '\x198A', '\x1988', 
		'\x3', '\x2', '\x2', '\x2', '\x198A', '\x198B', '\x3', '\x2', '\x2', '\x2', 
		'\x198B', '\x547', '\x3', '\x2', '\x2', '\x2', '\x198C', '\x198A', '\x3', 
		'\x2', '\x2', '\x2', '\x198D', '\x1997', '\a', '\xDE', '\x2', '\x2', '\x198E', 
		'\x198F', '\a', '\x1BD', '\x2', '\x2', '\x198F', '\x1998', '\t', '`', 
		'\x2', '\x2', '\x1990', '\x1994', '\a', '\x1DB', '\x2', '\x2', '\x1991', 
		'\x1995', '\a', '\x21E', '\x2', '\x2', '\x1992', '\x1993', '\a', '\x1BD', 
		'\x2', '\x2', '\x1993', '\x1995', '\a', '\xA9', '\x2', '\x2', '\x1994', 
		'\x1991', '\x3', '\x2', '\x2', '\x2', '\x1994', '\x1992', '\x3', '\x2', 
		'\x2', '\x2', '\x1995', '\x1998', '\x3', '\x2', '\x2', '\x2', '\x1996', 
		'\x1998', '\a', '\xA9', '\x2', '\x2', '\x1997', '\x198E', '\x3', '\x2', 
		'\x2', '\x2', '\x1997', '\x1990', '\x3', '\x2', '\x2', '\x2', '\x1997', 
		'\x1996', '\x3', '\x2', '\x2', '\x2', '\x1998', '\x1999', '\x3', '\x2', 
		'\x2', '\x2', '\x1999', '\x199A', '\a', '\x131', '\x2', '\x2', '\x199A', 
		'\x549', '\x3', '\x2', '\x2', '\x2', '\x199B', '\x199C', '\a', '\x15D', 
		'\x2', '\x2', '\x199C', '\x54B', '\x3', '\x2', '\x2', '\x2', '\x199D', 
		'\x199E', '\a', '\x20C', '\x2', '\x2', '\x199E', '\x199F', '\a', '\x24B', 
		'\x2', '\x2', '\x199F', '\x19A0', '\x5', '\xA2', 'R', '\x2', '\x19A0', 
		'\x19A1', '\a', '\x223', '\x2', '\x2', '\x19A1', '\x19A2', '\t', '\x61', 
		'\x2', '\x2', '\x19A2', '\x19A3', '\a', '\x24C', '\x2', '\x2', '\x19A3', 
		'\x54D', '\x3', '\x2', '\x2', '\x2', '\x19A4', '\x19A5', '\a', '\x41', 
		'\x2', '\x2', '\x19A5', '\x19A6', '\a', '\x24B', '\x2', '\x2', '\x19A6', 
		'\x19A7', '\x5', '\xA2', 'R', '\x2', '\x19A7', '\x19A8', '\a', '\x223', 
		'\x2', '\x2', '\x19A8', '\x19A9', '\a', '\x13B', '\x2', '\x2', '\x19A9', 
		'\x19AA', '\a', '\x24C', '\x2', '\x2', '\x19AA', '\x19B1', '\x3', '\x2', 
		'\x2', '\x2', '\x19AB', '\x19AC', '\a', '\x13C', '\x2', '\x2', '\x19AC', 
		'\x19AD', '\a', '\x24B', '\x2', '\x2', '\x19AD', '\x19AE', '\x5', '\xA2', 
		'R', '\x2', '\x19AE', '\x19AF', '\a', '\x24C', '\x2', '\x2', '\x19AF', 
		'\x19B1', '\x3', '\x2', '\x2', '\x2', '\x19B0', '\x19A4', '\x3', '\x2', 
		'\x2', '\x2', '\x19B0', '\x19AB', '\x3', '\x2', '\x2', '\x2', '\x19B1', 
		'\x54F', '\x3', '\x2', '\x2', '\x2', '\x19B2', '\x19B9', '\x5', '\x560', 
		'\x2B1', '\x2', '\x19B3', '\x19B9', '\x5', '\x576', '\x2BC', '\x2', '\x19B4', 
		'\x19B9', '\x5', '\x57A', '\x2BE', '\x2', '\x19B5', '\x19B9', '\x5', '\x580', 
		'\x2C1', '\x2', '\x19B6', '\x19B9', '\x5', '\x572', '\x2BA', '\x2', '\x19B7', 
		'\x19B9', '\x5', '\x552', '\x2AA', '\x2', '\x19B8', '\x19B2', '\x3', '\x2', 
		'\x2', '\x2', '\x19B8', '\x19B3', '\x3', '\x2', '\x2', '\x2', '\x19B8', 
		'\x19B4', '\x3', '\x2', '\x2', '\x2', '\x19B8', '\x19B5', '\x3', '\x2', 
		'\x2', '\x2', '\x19B8', '\x19B6', '\x3', '\x2', '\x2', '\x2', '\x19B8', 
		'\x19B7', '\x3', '\x2', '\x2', '\x2', '\x19B9', '\x551', '\x3', '\x2', 
		'\x2', '\x2', '\x19BA', '\x19BB', '\a', '\xBF', '\x2', '\x2', '\x19BB', 
		'\x19BC', '\x5', 'P', ')', '\x2', '\x19BC', '\x19BE', '\x5', '\x554', 
		'\x2AB', '\x2', '\x19BD', '\x19BF', '\x5', '\x55E', '\x2B0', '\x2', '\x19BE', 
		'\x19BD', '\x3', '\x2', '\x2', '\x2', '\x19BE', '\x19BF', '\x3', '\x2', 
		'\x2', '\x2', '\x19BF', '\x19C5', '\x3', '\x2', '\x2', '\x2', '\x19C0', 
		'\x19C6', '\x5', '\x4D4', '\x26B', '\x2', '\x19C1', '\x19C6', '\x5', '\x4EE', 
		'\x278', '\x2', '\x19C2', '\x19C6', '\x5', '\x4EC', '\x277', '\x2', '\x19C3', 
		'\x19C6', '\x5', '\x524', '\x293', '\x2', '\x19C4', '\x19C6', '\x5', '\x532', 
		'\x29A', '\x2', '\x19C5', '\x19C0', '\x3', '\x2', '\x2', '\x2', '\x19C5', 
		'\x19C1', '\x3', '\x2', '\x2', '\x2', '\x19C5', '\x19C2', '\x3', '\x2', 
		'\x2', '\x2', '\x19C5', '\x19C3', '\x3', '\x2', '\x2', '\x2', '\x19C5', 
		'\x19C4', '\x3', '\x2', '\x2', '\x2', '\x19C6', '\x553', '\x3', '\x2', 
		'\x2', '\x2', '\x19C7', '\x19CB', '\a', '\xDE', '\x2', '\x2', '\x19C8', 
		'\x19CC', '\x5', '\x556', '\x2AC', '\x2', '\x19C9', '\x19CC', '\x5', '\x55A', 
		'\x2AE', '\x2', '\x19CA', '\x19CC', '\x5', '\x55C', '\x2AF', '\x2', '\x19CB', 
		'\x19C8', '\x3', '\x2', '\x2', '\x2', '\x19CB', '\x19C9', '\x3', '\x2', 
		'\x2', '\x2', '\x19CB', '\x19CA', '\x3', '\x2', '\x2', '\x2', '\x19CC', 
		'\x555', '\x3', '\x2', '\x2', '\x2', '\x19CD', '\x19CE', '\a', '\xE6', 
		'\x2', '\x2', '\x19CE', '\x19CF', '\a', '\x162', '\x2', '\x2', '\x19CF', 
		'\x19D1', '\x5', '\x44', '#', '\x2', '\x19D0', '\x19D2', '\x5', '\x558', 
		'\x2AD', '\x2', '\x19D1', '\x19D0', '\x3', '\x2', '\x2', '\x2', '\x19D1', 
		'\x19D2', '\x3', '\x2', '\x2', '\x2', '\x19D2', '\x557', '\x3', '\x2', 
		'\x2', '\x2', '\x19D3', '\x19D4', '\a', '&', '\x2', '\x2', '\x19D4', '\x19D7', 
		'\x5', '\xA2', 'R', '\x2', '\x19D5', '\x19D6', '\a', '\x10', '\x2', '\x2', 
		'\x19D6', '\x19D8', '\x5', '\xA2', 'R', '\x2', '\x19D7', '\x19D5', '\x3', 
		'\x2', '\x2', '\x2', '\x19D7', '\x19D8', '\x3', '\x2', '\x2', '\x2', '\x19D8', 
		'\x559', '\x3', '\x2', '\x2', '\x2', '\x19D9', '\x19DA', '\a', '\x226', 
		'\x2', '\x2', '\x19DA', '\x19DB', '\a', '\x162', '\x2', '\x2', '\x19DB', 
		'\x19DC', '\x5', '\x44', '#', '\x2', '\x19DC', '\x55B', '\x3', '\x2', 
		'\x2', '\x2', '\x19DD', '\x19DE', '\x5', '\xA2', 'R', '\x2', '\x19DE', 
		'\x19DF', '\x5', '\x9C', 'O', '\x2', '\x19DF', '\x19E0', '\x5', '\xA2', 
		'R', '\x2', '\x19E0', '\x55D', '\x3', '\x2', '\x2', '\x2', '\x19E1', '\x19E2', 
		'\a', '\x1C5', '\x2', '\x2', '\x19E2', '\x19E3', '\a', '\xA7', '\x2', 
		'\x2', '\x19E3', '\x55F', '\x3', '\x2', '\x2', '\x2', '\x19E4', '\x19E5', 
		'\a', '\xDC', '\x2', '\x2', '\x19E5', '\x19E6', '\x5', '\xA2', 'R', '\x2', 
		'\x19E6', '\x19EA', '\x5', '\x562', '\x2B2', '\x2', '\x19E7', '\x19E9', 
		'\x5', '\x566', '\x2B4', '\x2', '\x19E8', '\x19E7', '\x3', '\x2', '\x2', 
		'\x2', '\x19E9', '\x19EC', '\x3', '\x2', '\x2', '\x2', '\x19EA', '\x19E8', 
		'\x3', '\x2', '\x2', '\x2', '\x19EA', '\x19EB', '\x3', '\x2', '\x2', '\x2', 
		'\x19EB', '\x19EE', '\x3', '\x2', '\x2', '\x2', '\x19EC', '\x19EA', '\x3', 
		'\x2', '\x2', '\x2', '\x19ED', '\x19EF', '\x5', '\x564', '\x2B3', '\x2', 
		'\x19EE', '\x19ED', '\x3', '\x2', '\x2', '\x2', '\x19EE', '\x19EF', '\x3', 
		'\x2', '\x2', '\x2', '\x19EF', '\x19F0', '\x3', '\x2', '\x2', '\x2', '\x19F0', 
		'\x19F1', '\a', '\x9C', '\x2', '\x2', '\x19F1', '\x19F2', '\a', '\xDC', 
		'\x2', '\x2', '\x19F2', '\x561', '\x3', '\x2', '\x2', '\x2', '\x19F3', 
		'\x19F4', '\a', '\x202', '\x2', '\x2', '\x19F4', '\x19F5', '\x5', ' ', 
		'\x11', '\x2', '\x19F5', '\x563', '\x3', '\x2', '\x2', '\x2', '\x19F6', 
		'\x19F7', '\a', '\x97', '\x2', '\x2', '\x19F7', '\x19F8', '\x5', ' ', 
		'\x11', '\x2', '\x19F8', '\x565', '\x3', '\x2', '\x2', '\x2', '\x19F9', 
		'\x19FA', '\a', '\x98', '\x2', '\x2', '\x19FA', '\x19FB', '\x5', '\xA2', 
		'R', '\x2', '\x19FB', '\x19FC', '\x5', '\x562', '\x2B2', '\x2', '\x19FC', 
		'\x567', '\x3', '\x2', '\x2', '\x2', '\x19FD', '\x19FE', '\a', '\x88', 
		'\x2', '\x2', '\x19FE', '\x19FF', '\x5', '\xA2', 'R', '\x2', '\x19FF', 
		'\x1A03', '\x5', '\x56A', '\x2B6', '\x2', '\x1A00', '\x1A02', '\x5', '\x56E', 
		'\x2B8', '\x2', '\x1A01', '\x1A00', '\x3', '\x2', '\x2', '\x2', '\x1A02', 
		'\x1A05', '\x3', '\x2', '\x2', '\x2', '\x1A03', '\x1A01', '\x3', '\x2', 
		'\x2', '\x2', '\x1A03', '\x1A04', '\x3', '\x2', '\x2', '\x2', '\x1A04', 
		'\x1A07', '\x3', '\x2', '\x2', '\x2', '\x1A05', '\x1A03', '\x3', '\x2', 
		'\x2', '\x2', '\x1A06', '\x1A08', '\x5', '\x56C', '\x2B7', '\x2', '\x1A07', 
		'\x1A06', '\x3', '\x2', '\x2', '\x2', '\x1A07', '\x1A08', '\x3', '\x2', 
		'\x2', '\x2', '\x1A08', '\x1A09', '\x3', '\x2', '\x2', '\x2', '\x1A09', 
		'\x1A0A', '\a', '\x86', '\x2', '\x2', '\x1A0A', '\x569', '\x3', '\x2', 
		'\x2', '\x2', '\x1A0B', '\x1A10', '\a', '\x89', '\x2', '\x2', '\x1A0C', 
		'\x1A0F', '\x5', '\x570', '\x2B9', '\x2', '\x1A0D', '\x1A0F', '\x5', '\x5A8', 
		'\x2D5', '\x2', '\x1A0E', '\x1A0C', '\x3', '\x2', '\x2', '\x2', '\x1A0E', 
		'\x1A0D', '\x3', '\x2', '\x2', '\x2', '\x1A0F', '\x1A12', '\x3', '\x2', 
		'\x2', '\x2', '\x1A10', '\x1A0E', '\x3', '\x2', '\x2', '\x2', '\x1A10', 
		'\x1A11', '\x3', '\x2', '\x2', '\x2', '\x1A11', '\x56B', '\x3', '\x2', 
		'\x2', '\x2', '\x1A12', '\x1A10', '\x3', '\x2', '\x2', '\x2', '\x1A13', 
		'\x1A18', '\a', '\x84', '\x2', '\x2', '\x1A14', '\x1A17', '\x5', '\x570', 
		'\x2B9', '\x2', '\x1A15', '\x1A17', '\x5', '\x5A8', '\x2D5', '\x2', '\x1A16', 
		'\x1A14', '\x3', '\x2', '\x2', '\x2', '\x1A16', '\x1A15', '\x3', '\x2', 
		'\x2', '\x2', '\x1A17', '\x1A1A', '\x3', '\x2', '\x2', '\x2', '\x1A18', 
		'\x1A16', '\x3', '\x2', '\x2', '\x2', '\x1A18', '\x1A19', '\x3', '\x2', 
		'\x2', '\x2', '\x1A19', '\x56D', '\x3', '\x2', '\x2', '\x2', '\x1A1A', 
		'\x1A18', '\x3', '\x2', '\x2', '\x2', '\x1A1B', '\x1A1C', '\a', '\x85', 
		'\x2', '\x2', '\x1A1C', '\x1A1D', '\x5', '\xA2', 'R', '\x2', '\x1A1D', 
		'\x1A1E', '\x5', '\x56A', '\x2B6', '\x2', '\x1A1E', '\x56F', '\x3', '\x2', 
		'\x2', '\x2', '\x1A1F', '\x1A20', '\a', '\x87', '\x2', '\x2', '\x1A20', 
		'\x1A21', '\x5', '\xA2', 'R', '\x2', '\x1A21', '\x1A22', '\a', '\x86', 
		'\x2', '\x2', '\x1A22', '\x571', '\x3', '\x2', '\x2', '\x2', '\x1A23', 
		'\x1A24', '\x5', '\x574', '\x2BB', '\x2', '\x1A24', '\x573', '\x3', '\x2', 
		'\x2', '\x2', '\x1A25', '\x1A26', '\a', '\x11A', '\x2', '\x2', '\x1A26', 
		'\x1A27', '\x5', ' ', '\x11', '\x2', '\x1A27', '\x1A28', '\x5', '\x578', 
		'\x2BD', '\x2', '\x1A28', '\x575', '\x3', '\x2', '\x2', '\x2', '\x1A29', 
		'\x1A2A', '\a', '\x233', '\x2', '\x2', '\x1A2A', '\x1A2B', '\x5', '\xA2', 
		'R', '\x2', '\x1A2B', '\x1A2C', '\x5', '\x574', '\x2BB', '\x2', '\x1A2C', 
		'\x577', '\x3', '\x2', '\x2', '\x2', '\x1A2D', '\x1A2E', '\a', '\x9C', 
		'\x2', '\x2', '\x1A2E', '\x1A31', '\a', '\x11A', '\x2', '\x2', '\x1A2F', 
		'\x1A32', '\x5', '@', '!', '\x2', '\x1A30', '\x1A32', '\a', '\x267', '\x2', 
		'\x2', '\x1A31', '\x1A2F', '\x3', '\x2', '\x2', '\x2', '\x1A31', '\x1A30', 
		'\x3', '\x2', '\x2', '\x2', '\x1A31', '\x1A32', '\x3', '\x2', '\x2', '\x2', 
		'\x1A32', '\x579', '\x3', '\x2', '\x2', '\x2', '\x1A33', '\x1A34', '\a', 
		'\xBE', '\x2', '\x2', '\x1A34', '\x1A35', '\x5', 'P', ')', '\x2', '\x1A35', 
		'\x1A36', '\x5', '\x57C', '\x2BF', '\x2', '\x1A36', '\x1A37', '\x5', '\x574', 
		'\x2BB', '\x2', '\x1A37', '\x57B', '\x3', '\x2', '\x2', '\x2', '\x1A38', 
		'\x1A3A', '\a', '\xDE', '\x2', '\x2', '\x1A39', '\x1A3B', '\a', '\x1B7', 
		'\x2', '\x2', '\x1A3A', '\x1A39', '\x3', '\x2', '\x2', '\x2', '\x1A3A', 
		'\x1A3B', '\x3', '\x2', '\x2', '\x2', '\x1A3B', '\x1A3C', '\x3', '\x2', 
		'\x2', '\x2', '\x1A3C', '\x1A3F', '\x5', '\xA2', 'R', '\x2', '\x1A3D', 
		'\x1A3E', '\a', '\x24A', '\x2', '\x2', '\x1A3E', '\x1A40', '\x5', '\xA2', 
		'R', '\x2', '\x1A3F', '\x1A3D', '\x3', '\x2', '\x2', '\x2', '\x1A3F', 
		'\x1A40', '\x3', '\x2', '\x2', '\x2', '\x1A40', '\x57D', '\x3', '\x2', 
		'\x2', '\x2', '\x1A41', '\x1A43', '\a', '\x61', '\x2', '\x2', '\x1A42', 
		'\x1A44', '\x5', '\x5A2', '\x2D2', '\x2', '\x1A43', '\x1A42', '\x3', '\x2', 
		'\x2', '\x2', '\x1A43', '\x1A44', '\x3', '\x2', '\x2', '\x2', '\x1A44', 
		'\x57F', '\x3', '\x2', '\x2', '\x2', '\x1A45', '\x1A48', '\a', '\x39', 
		'\x2', '\x2', '\x1A46', '\x1A49', '\x5', '\x584', '\x2C3', '\x2', '\x1A47', 
		'\x1A49', '\x5', '\x582', '\x2C2', '\x2', '\x1A48', '\x1A46', '\x3', '\x2', 
		'\x2', '\x2', '\x1A48', '\x1A47', '\x3', '\x2', '\x2', '\x2', '\x1A49', 
		'\x1A4A', '\x3', '\x2', '\x2', '\x2', '\x1A4A', '\x1A4B', '\a', '\x9C', 
		'\x2', '\x2', '\x1A4B', '\x1A4E', '\a', '\x39', '\x2', '\x2', '\x1A4C', 
		'\x1A4F', '\x5', '@', '!', '\x2', '\x1A4D', '\x1A4F', '\a', '\x267', '\x2', 
		'\x2', '\x1A4E', '\x1A4C', '\x3', '\x2', '\x2', '\x2', '\x1A4E', '\x1A4D', 
		'\x3', '\x2', '\x2', '\x2', '\x1A4E', '\x1A4F', '\x3', '\x2', '\x2', '\x2', 
		'\x1A4F', '\x581', '\x3', '\x2', '\x2', '\x2', '\x1A50', '\x1A52', '\x5', 
		'\xA2', 'R', '\x2', '\x1A51', '\x1A53', '\x5', '\x586', '\x2C4', '\x2', 
		'\x1A52', '\x1A51', '\x3', '\x2', '\x2', '\x2', '\x1A53', '\x1A54', '\x3', 
		'\x2', '\x2', '\x2', '\x1A54', '\x1A52', '\x3', '\x2', '\x2', '\x2', '\x1A54', 
		'\x1A55', '\x3', '\x2', '\x2', '\x2', '\x1A55', '\x1A57', '\x3', '\x2', 
		'\x2', '\x2', '\x1A56', '\x1A58', '\x5', '\x564', '\x2B3', '\x2', '\x1A57', 
		'\x1A56', '\x3', '\x2', '\x2', '\x2', '\x1A57', '\x1A58', '\x3', '\x2', 
		'\x2', '\x2', '\x1A58', '\x583', '\x3', '\x2', '\x2', '\x2', '\x1A59', 
		'\x1A5B', '\x5', '\x586', '\x2C4', '\x2', '\x1A5A', '\x1A59', '\x3', '\x2', 
		'\x2', '\x2', '\x1A5B', '\x1A5C', '\x3', '\x2', '\x2', '\x2', '\x1A5C', 
		'\x1A5A', '\x3', '\x2', '\x2', '\x2', '\x1A5C', '\x1A5D', '\x3', '\x2', 
		'\x2', '\x2', '\x1A5D', '\x1A5F', '\x3', '\x2', '\x2', '\x2', '\x1A5E', 
		'\x1A60', '\x5', '\x564', '\x2B3', '\x2', '\x1A5F', '\x1A5E', '\x3', '\x2', 
		'\x2', '\x2', '\x1A5F', '\x1A60', '\x3', '\x2', '\x2', '\x2', '\x1A60', 
		'\x585', '\x3', '\x2', '\x2', '\x2', '\x1A61', '\x1A62', '\a', '\x231', 
		'\x2', '\x2', '\x1A62', '\x1A63', '\x5', '\xA2', 'R', '\x2', '\x1A63', 
		'\x1A64', '\x5', '\x562', '\x2B2', '\x2', '\x1A64', '\x587', '\x3', '\x2', 
		'\x2', '\x2', '\x1A65', '\x1A67', '\x5', '\x5A6', '\x2D4', '\x2', '\x1A66', 
		'\x1A65', '\x3', '\x2', '\x2', '\x2', '\x1A66', '\x1A67', '\x3', '\x2', 
		'\x2', '\x2', '\x1A67', '\x1A68', '\x3', '\x2', '\x2', '\x2', '\x1A68', 
		'\x1A69', '\x5', '\x58A', '\x2C6', '\x2', '\x1A69', '\x589', '\x3', '\x2', 
		'\x2', '\x2', '\x1A6A', '\x1A6B', '\a', '$', '\x2', '\x2', '\x1A6B', '\x1A6D', 
		'\x5', ' ', '\x11', '\x2', '\x1A6C', '\x1A6E', '\x5', '\x58E', '\x2C8', 
		'\x2', '\x1A6D', '\x1A6C', '\x3', '\x2', '\x2', '\x2', '\x1A6D', '\x1A6E', 
		'\x3', '\x2', '\x2', '\x2', '\x1A6E', '\x1A6F', '\x3', '\x2', '\x2', '\x2', 
		'\x1A6F', '\x1A70', '\x5', '\x58C', '\x2C7', '\x2', '\x1A70', '\x58B', 
		'\x3', '\x2', '\x2', '\x2', '\x1A71', '\x1A74', '\a', '\x9C', '\x2', '\x2', 
		'\x1A72', '\x1A75', '\x5', '@', '!', '\x2', '\x1A73', '\x1A75', '\a', 
		'\x267', '\x2', '\x2', '\x1A74', '\x1A72', '\x3', '\x2', '\x2', '\x2', 
		'\x1A74', '\x1A73', '\x3', '\x2', '\x2', '\x2', '\x1A74', '\x1A75', '\x3', 
		'\x2', '\x2', '\x2', '\x1A75', '\x58D', '\x3', '\x2', '\x2', '\x2', '\x1A76', 
		'\x1A78', '\a', '\xA5', '\x2', '\x2', '\x1A77', '\x1A79', '\x5', '\x590', 
		'\x2C9', '\x2', '\x1A78', '\x1A77', '\x3', '\x2', '\x2', '\x2', '\x1A79', 
		'\x1A7A', '\x3', '\x2', '\x2', '\x2', '\x1A7A', '\x1A78', '\x3', '\x2', 
		'\x2', '\x2', '\x1A7A', '\x1A7B', '\x3', '\x2', '\x2', '\x2', '\x1A7B', 
		'\x58F', '\x3', '\x2', '\x2', '\x2', '\x1A7C', '\x1A7D', '\a', '\x231', 
		'\x2', '\x2', '\x1A7D', '\x1A7E', '\x5', '\x592', '\x2CA', '\x2', '\x1A7E', 
		'\x1A7F', '\x5', '\x562', '\x2B2', '\x2', '\x1A7F', '\x591', '\x3', '\x2', 
		'\x2', '\x2', '\x1A80', '\x1A85', '\x5', '\x44', '#', '\x2', '\x1A81', 
		'\x1A82', '\a', '\x16E', '\x2', '\x2', '\x1A82', '\x1A84', '\x5', '\x44', 
		'#', '\x2', '\x1A83', '\x1A81', '\x3', '\x2', '\x2', '\x2', '\x1A84', 
		'\x1A87', '\x3', '\x2', '\x2', '\x2', '\x1A85', '\x1A83', '\x3', '\x2', 
		'\x2', '\x2', '\x1A85', '\x1A86', '\x3', '\x2', '\x2', '\x2', '\x1A86', 
		'\x593', '\x3', '\x2', '\x2', '\x2', '\x1A87', '\x1A85', '\x3', '\x2', 
		'\x2', '\x2', '\x1A88', '\x1A89', '\a', '\xCE', '\x2', '\x2', '\x1A89', 
		'\x1A8A', '\x5', '^', '\x30', '\x2', '\x1A8A', '\x595', '\x3', '\x2', 
		'\x2', '\x2', '\x1A8B', '\x1A8C', '\x5', '\x598', '\x2CD', '\x2', '\x1A8C', 
		'\x597', '\x3', '\x2', '\x2', '\x2', '\x1A8D', '\x1A8E', '\a', '\x252', 
		'\x2', '\x2', '\x1A8E', '\x1A8F', '\a', '\x252', '\x2', '\x2', '\x1A8F', 
		'\x1A90', '\x5', '^', '\x30', '\x2', '\x1A90', '\x1A91', '\a', '\x251', 
		'\x2', '\x2', '\x1A91', '\x1A92', '\a', '\x251', '\x2', '\x2', '\x1A92', 
		'\x599', '\x3', '\x2', '\x2', '\x2', '\x1A93', '\x1A94', '\a', '\x15E', 
		'\x2', '\x2', '\x1A94', '\x59B', '\x3', '\x2', '\x2', '\x2', '\x1A95', 
		'\x1A97', '\a', '\x1B4', '\x2', '\x2', '\x1A96', '\x1A98', '\x5', '\xA2', 
		'R', '\x2', '\x1A97', '\x1A96', '\x3', '\x2', '\x2', '\x2', '\x1A97', 
		'\x1A98', '\x3', '\x2', '\x2', '\x2', '\x1A98', '\x59D', '\x3', '\x2', 
		'\x2', '\x2', '\x1A99', '\x1A9A', '\x5', '\x44', '#', '\x2', '\x1A9A', 
		'\x59F', '\x3', '\x2', '\x2', '\x2', '\x1A9B', '\x1A9D', '\a', '\xAC', 
		'\x2', '\x2', '\x1A9C', '\x1A9E', '\x5', '\x5A2', '\x2D2', '\x2', '\x1A9D', 
		'\x1A9C', '\x3', '\x2', '\x2', '\x2', '\x1A9D', '\x1A9E', '\x3', '\x2', 
		'\x2', '\x2', '\x1A9E', '\x5A1', '\x3', '\x2', '\x2', '\x2', '\x1A9F', 
		'\x1AA5', '\x5', '\x5A4', '\x2D3', '\x2', '\x1AA0', '\x1AA2', '\x5', 'P', 
		')', '\x2', '\x1AA1', '\x1AA3', '\x5', '\x5A4', '\x2D3', '\x2', '\x1AA2', 
		'\x1AA1', '\x3', '\x2', '\x2', '\x2', '\x1AA2', '\x1AA3', '\x3', '\x2', 
		'\x2', '\x2', '\x1AA3', '\x1AA5', '\x3', '\x2', '\x2', '\x2', '\x1AA4', 
		'\x1A9F', '\x3', '\x2', '\x2', '\x2', '\x1AA4', '\x1AA0', '\x3', '\x2', 
		'\x2', '\x2', '\x1AA5', '\x5A3', '\x3', '\x2', '\x2', '\x2', '\x1AA6', 
		'\x1AA7', '\a', '\x231', '\x2', '\x2', '\x1AA7', '\x1AA8', '\x5', '\xA2', 
		'R', '\x2', '\x1AA8', '\x5A5', '\x3', '\x2', '\x2', '\x2', '\x1AA9', '\x1AAB', 
		'\x5', '\x5A8', '\x2D5', '\x2', '\x1AAA', '\x1AA9', '\x3', '\x2', '\x2', 
		'\x2', '\x1AAB', '\x1AAC', '\x3', '\x2', '\x2', '\x2', '\x1AAC', '\x1AAA', 
		'\x3', '\x2', '\x2', '\x2', '\x1AAC', '\x1AAD', '\x3', '\x2', '\x2', '\x2', 
		'\x1AAD', '\x1AB6', '\x3', '\x2', '\x2', '\x2', '\x1AAE', '\x1AB2', '\a', 
		'u', '\x2', '\x2', '\x1AAF', '\x1AB1', '\x5', '\x5A8', '\x2D5', '\x2', 
		'\x1AB0', '\x1AAF', '\x3', '\x2', '\x2', '\x2', '\x1AB1', '\x1AB4', '\x3', 
		'\x2', '\x2', '\x2', '\x1AB2', '\x1AB0', '\x3', '\x2', '\x2', '\x2', '\x1AB2', 
		'\x1AB3', '\x3', '\x2', '\x2', '\x2', '\x1AB3', '\x1AB6', '\x3', '\x2', 
		'\x2', '\x2', '\x1AB4', '\x1AB2', '\x3', '\x2', '\x2', '\x2', '\x1AB5', 
		'\x1AAA', '\x3', '\x2', '\x2', '\x2', '\x1AB5', '\x1AAE', '\x3', '\x2', 
		'\x2', '\x2', '\x1AB6', '\x5A7', '\x3', '\x2', '\x2', '\x2', '\x1AB7', 
		'\x1AC5', '\x5', '\x568', '\x2B5', '\x2', '\x1AB8', '\x1AC1', '\x5', '\x20A', 
		'\x106', '\x2', '\x1AB9', '\x1AC1', '\x5', '\x1E2', '\xF2', '\x2', '\x1ABA', 
		'\x1AC1', '\x5', '\x5B2', '\x2DA', '\x2', '\x1ABB', '\x1AC1', '\x5', '\x5B4', 
		'\x2DB', '\x2', '\x1ABC', '\x1AC1', '\x5', '\x5CE', '\x2E8', '\x2', '\x1ABD', 
		'\x1AC1', '\x5', '\x5D0', '\x2E9', '\x2', '\x1ABE', '\x1AC1', '\x5', '\x5D6', 
		'\x2EC', '\x2', '\x1ABF', '\x1AC1', '\x5', '\x5EA', '\x2F6', '\x2', '\x1AC0', 
		'\x1AB8', '\x3', '\x2', '\x2', '\x2', '\x1AC0', '\x1AB9', '\x3', '\x2', 
		'\x2', '\x2', '\x1AC0', '\x1ABA', '\x3', '\x2', '\x2', '\x2', '\x1AC0', 
		'\x1ABB', '\x3', '\x2', '\x2', '\x2', '\x1AC0', '\x1ABC', '\x3', '\x2', 
		'\x2', '\x2', '\x1AC0', '\x1ABD', '\x3', '\x2', '\x2', '\x2', '\x1AC0', 
		'\x1ABE', '\x3', '\x2', '\x2', '\x2', '\x1AC0', '\x1ABF', '\x3', '\x2', 
		'\x2', '\x2', '\x1AC1', '\x1AC2', '\x3', '\x2', '\x2', '\x2', '\x1AC2', 
		'\x1AC3', '\a', '\x24E', '\x2', '\x2', '\x1AC3', '\x1AC5', '\x3', '\x2', 
		'\x2', '\x2', '\x1AC4', '\x1AB7', '\x3', '\x2', '\x2', '\x2', '\x1AC4', 
		'\x1AC0', '\x3', '\x2', '\x2', '\x2', '\x1AC5', '\x5A9', '\x3', '\x2', 
		'\x2', '\x2', '\x1AC6', '\x1AC7', '\a', '\x15A', '\x2', '\x2', '\x1AC7', 
		'\x1AC8', '\a', '\x15E', '\x2', '\x2', '\x1AC8', '\x5AB', '\x3', '\x2', 
		'\x2', '\x2', '\x1AC9', '\x1ACA', '\a', '\x15E', '\x2', '\x2', '\x1ACA', 
		'\x5AD', '\x3', '\x2', '\x2', '\x2', '\x1ACB', '\x1ACC', '\t', ')', '\x2', 
		'\x2', '\x1ACC', '\x1ACD', '\x5', '\xA2', 'R', '\x2', '\x1ACD', '\x5AF', 
		'\x3', '\x2', '\x2', '\x2', '\x1ACE', '\x1ACF', '\a', '\x1B4', '\x2', 
		'\x2', '\x1ACF', '\x1AD0', '\x5', '\x62', '\x32', '\x2', '\x1AD0', '\x5B1', 
		'\x3', '\x2', '\x2', '\x2', '\x1AD1', '\x1AD2', '\x5', 'P', ')', '\x2', 
		'\x1AD2', '\x1AD3', '\a', '\xA5', '\x2', '\x2', '\x1AD3', '\x5B3', '\x3', 
		'\x2', '\x2', '\x2', '\x1AD4', '\x1AD5', '\a', '\x213', '\x2', '\x2', 
		'\x1AD5', '\x1AD8', '\x5', 'P', ')', '\x2', '\x1AD6', '\x1AD9', '\x5', 
		'\xBC', '_', '\x2', '\x1AD7', '\x1AD9', '\x5', '\x5B6', '\x2DC', '\x2', 
		'\x1AD8', '\x1AD6', '\x3', '\x2', '\x2', '\x2', '\x1AD8', '\x1AD7', '\x3', 
		'\x2', '\x2', '\x2', '\x1AD9', '\x1ADB', '\x3', '\x2', '\x2', '\x2', '\x1ADA', 
		'\x1ADC', '\x5', '\x5B8', '\x2DD', '\x2', '\x1ADB', '\x1ADA', '\x3', '\x2', 
		'\x2', '\x2', '\x1ADB', '\x1ADC', '\x3', '\x2', '\x2', '\x2', '\x1ADC', 
		'\x1AE3', '\x3', '\x2', '\x2', '\x2', '\x1ADD', '\x1AE4', '\x5', '\x5BA', 
		'\x2DE', '\x2', '\x1ADE', '\x1AE4', '\x5', '\x5C2', '\x2E2', '\x2', '\x1ADF', 
		'\x1AE4', '\x5', '\x5C8', '\x2E5', '\x2', '\x1AE0', '\x1AE4', '\x5', '\x5CC', 
		'\x2E7', '\x2', '\x1AE1', '\x1AE4', '\x5', '\x5BE', '\x2E0', '\x2', '\x1AE2', 
		'\x1AE4', '\x5', '\x62', '\x32', '\x2', '\x1AE3', '\x1ADD', '\x3', '\x2', 
		'\x2', '\x2', '\x1AE3', '\x1ADE', '\x3', '\x2', '\x2', '\x2', '\x1AE3', 
		'\x1ADF', '\x3', '\x2', '\x2', '\x2', '\x1AE3', '\x1AE0', '\x3', '\x2', 
		'\x2', '\x2', '\x1AE3', '\x1AE1', '\x3', '\x2', '\x2', '\x2', '\x1AE3', 
		'\x1AE2', '\x3', '\x2', '\x2', '\x2', '\x1AE4', '\x5B5', '\x3', '\x2', 
		'\x2', '\x2', '\x1AE5', '\x1AE6', '\a', '\x15', '\x2', '\x2', '\x1AE6', 
		'\x5B7', '\x3', '\x2', '\x2', '\x2', '\x1AE7', '\x1AE8', '\a', '\x13F', 
		'\x2', '\x2', '\x1AE8', '\x5B9', '\x3', '\x2', '\x2', '\x2', '\x1AE9', 
		'\x1AEA', '\a', '\x1A3', '\x2', '\x2', '\x1AEA', '\x1AEB', '\a', '\x24B', 
		'\x2', '\x2', '\x1AEB', '\x1AF0', '\x5', '\x5BC', '\x2DF', '\x2', '\x1AEC', 
		'\x1AED', '\a', '\x24D', '\x2', '\x2', '\x1AED', '\x1AEF', '\x5', '\x5BC', 
		'\x2DF', '\x2', '\x1AEE', '\x1AEC', '\x3', '\x2', '\x2', '\x2', '\x1AEF', 
		'\x1AF2', '\x3', '\x2', '\x2', '\x2', '\x1AF0', '\x1AEE', '\x3', '\x2', 
		'\x2', '\x2', '\x1AF0', '\x1AF1', '\x3', '\x2', '\x2', '\x2', '\x1AF1', 
		'\x1AF3', '\x3', '\x2', '\x2', '\x2', '\x1AF2', '\x1AF0', '\x3', '\x2', 
		'\x2', '\x2', '\x1AF3', '\x1AF4', '\a', '\x24C', '\x2', '\x2', '\x1AF4', 
		'\x5BB', '\x3', '\x2', '\x2', '\x2', '\x1AF5', '\x1AF6', '\x5', 'P', ')', 
		'\x2', '\x1AF6', '\x1AFF', '\x5', '\x62', '\x32', '\x2', '\x1AF7', '\x1AF9', 
		'\x5', '\x5AA', '\x2D6', '\x2', '\x1AF8', '\x1AF7', '\x3', '\x2', '\x2', 
		'\x2', '\x1AF8', '\x1AF9', '\x3', '\x2', '\x2', '\x2', '\x1AF9', '\x1AFA', 
		'\x3', '\x2', '\x2', '\x2', '\x1AFA', '\x1B00', '\x5', '\x5AE', '\x2D8', 
		'\x2', '\x1AFB', '\x1AFD', '\x5', '\x5AC', '\x2D7', '\x2', '\x1AFC', '\x1AFE', 
		'\x5', '\x5AE', '\x2D8', '\x2', '\x1AFD', '\x1AFC', '\x3', '\x2', '\x2', 
		'\x2', '\x1AFD', '\x1AFE', '\x3', '\x2', '\x2', '\x2', '\x1AFE', '\x1B00', 
		'\x3', '\x2', '\x2', '\x2', '\x1AFF', '\x1AF8', '\x3', '\x2', '\x2', '\x2', 
		'\x1AFF', '\x1AFB', '\x3', '\x2', '\x2', '\x2', '\x1AFF', '\x1B00', '\x3', 
		'\x2', '\x2', '\x2', '\x1B00', '\x5BD', '\x3', '\x2', '\x2', '\x2', '\x1B01', 
		'\x1B02', '\a', '\x161', '\x2', '\x2', '\x1B02', '\x1B03', '\a', '\x24B', 
		'\x2', '\x2', '\x1B03', '\x1B08', '\x5', '\x5C0', '\x2E1', '\x2', '\x1B04', 
		'\x1B05', '\a', '\x24D', '\x2', '\x2', '\x1B05', '\x1B07', '\x5', '\x5BC', 
		'\x2DF', '\x2', '\x1B06', '\x1B04', '\x3', '\x2', '\x2', '\x2', '\x1B07', 
		'\x1B0A', '\x3', '\x2', '\x2', '\x2', '\x1B08', '\x1B06', '\x3', '\x2', 
		'\x2', '\x2', '\x1B08', '\x1B09', '\x3', '\x2', '\x2', '\x2', '\x1B09', 
		'\x1B0B', '\x3', '\x2', '\x2', '\x2', '\x1B0A', '\x1B08', '\x3', '\x2', 
		'\x2', '\x2', '\x1B0B', '\x1B0C', '\a', '\x24C', '\x2', '\x2', '\x1B0C', 
		'\x5BF', '\x3', '\x2', '\x2', '\x2', '\x1B0D', '\x1B0E', '\x5', 'P', ')', 
		'\x2', '\x1B0E', '\x1B17', '\x5', '\x62', '\x32', '\x2', '\x1B0F', '\x1B11', 
		'\x5', '\x5AA', '\x2D6', '\x2', '\x1B10', '\x1B0F', '\x3', '\x2', '\x2', 
		'\x2', '\x1B10', '\x1B11', '\x3', '\x2', '\x2', '\x2', '\x1B11', '\x1B12', 
		'\x3', '\x2', '\x2', '\x2', '\x1B12', '\x1B18', '\x5', '\x5AE', '\x2D8', 
		'\x2', '\x1B13', '\x1B15', '\x5', '\x5AC', '\x2D7', '\x2', '\x1B14', '\x1B16', 
		'\x5', '\x5AE', '\x2D8', '\x2', '\x1B15', '\x1B14', '\x3', '\x2', '\x2', 
		'\x2', '\x1B15', '\x1B16', '\x3', '\x2', '\x2', '\x2', '\x1B16', '\x1B18', 
		'\x3', '\x2', '\x2', '\x2', '\x1B17', '\x1B10', '\x3', '\x2', '\x2', '\x2', 
		'\x1B17', '\x1B13', '\x3', '\x2', '\x2', '\x2', '\x1B17', '\x1B18', '\x3', 
		'\x2', '\x2', '\x2', '\x1B18', '\x5C1', '\x3', '\x2', '\x2', '\x2', '\x1B19', 
		'\x1B1D', '\a', '\x229', '\x2', '\x2', '\x1B1A', '\x1B1B', '\a', '\x22B', 
		'\x2', '\x2', '\x1B1B', '\x1B1D', '\a', '\x14', '\x2', '\x2', '\x1B1C', 
		'\x1B19', '\x3', '\x2', '\x2', '\x2', '\x1B1C', '\x1B1A', '\x3', '\x2', 
		'\x2', '\x2', '\x1B1D', '\x1B1E', '\x3', '\x2', '\x2', '\x2', '\x1B1E', 
		'\x1B1F', '\x5', '\x5C4', '\x2E3', '\x2', '\x1B1F', '\x1B20', '\x5', '\x5C6', 
		'\x2E4', '\x2', '\x1B20', '\x5C3', '\x3', '\x2', '\x2', '\x2', '\x1B21', 
		'\x1B22', '\a', '\x24B', '\x2', '\x2', '\x1B22', '\x1B23', '\x5', '(', 
		'\x15', '\x2', '\x1B23', '\x1B24', '\a', '\x24C', '\x2', '\x2', '\x1B24', 
		'\x5C5', '\x3', '\x2', '\x2', '\x2', '\x1B25', '\x1B26', '\a', '\x162', 
		'\x2', '\x2', '\x1B26', '\x1B29', '\x5', '\x62', '\x32', '\x2', '\x1B27', 
		'\x1B2A', '\x5', '\x5AA', '\x2D6', '\x2', '\x1B28', '\x1B2A', '\x5', '\x5AC', 
		'\x2D7', '\x2', '\x1B29', '\x1B27', '\x3', '\x2', '\x2', '\x2', '\x1B29', 
		'\x1B28', '\x3', '\x2', '\x2', '\x2', '\x1B29', '\x1B2A', '\x3', '\x2', 
		'\x2', '\x2', '\x1B2A', '\x5C7', '\x3', '\x2', '\x2', '\x2', '\x1B2B', 
		'\x1B2C', '\a', '\x1FB', '\x2', '\x2', '\x1B2C', '\x1B2E', '\x5', '\x5C6', 
		'\x2E4', '\x2', '\x1B2D', '\x1B2F', '\x5', '\x5CA', '\x2E6', '\x2', '\x1B2E', 
		'\x1B2D', '\x3', '\x2', '\x2', '\x2', '\x1B2E', '\x1B2F', '\x3', '\x2', 
		'\x2', '\x2', '\x1B2F', '\x5C9', '\x3', '\x2', '\x2', '\x2', '\x1B30', 
		'\x1B31', '\a', '\xE2', '\x2', '\x2', '\x1B31', '\x1B32', '\a', '\x33', 
		'\x2', '\x2', '\x1B32', '\x1B35', '\x5', '\x62', '\x32', '\x2', '\x1B33', 
		'\x1B36', '\x5', '\x5AA', '\x2D6', '\x2', '\x1B34', '\x1B36', '\x5', '\x5AC', 
		'\x2D7', '\x2', '\x1B35', '\x1B33', '\x3', '\x2', '\x2', '\x2', '\x1B35', 
		'\x1B34', '\x3', '\x2', '\x2', '\x2', '\x1B35', '\x1B36', '\x3', '\x2', 
		'\x2', '\x2', '\x1B36', '\x5CB', '\x3', '\x2', '\x2', '\x2', '\x1B37', 
		'\x1B38', '\a', '\x1A6', '\x2', '\x2', '\x1B38', '\x1B3A', '\a', 'j', 
		'\x2', '\x2', '\x1B39', '\x1B3B', '\x5', '\x5B0', '\x2D9', '\x2', '\x1B3A', 
		'\x1B39', '\x3', '\x2', '\x2', '\x2', '\x1B3A', '\x1B3B', '\x3', '\x2', 
		'\x2', '\x2', '\x1B3B', '\x5CD', '\x3', '\x2', '\x2', '\x2', '\x1B3C', 
		'\x1B3D', '\a', '\x1F5', '\x2', '\x2', '\x1B3D', '\x1B3E', '\x5', 'P', 
		')', '\x2', '\x1B3E', '\x1B3F', '\x5', '\xBC', '_', '\x2', '\x1B3F', '\x1B42', 
		'\x5', '\x62', '\x32', '\x2', '\x1B40', '\x1B43', '\x5', '\x5AA', '\x2D6', 
		'\x2', '\x1B41', '\x1B43', '\x5', '\x5AC', '\x2D7', '\x2', '\x1B42', '\x1B40', 
		'\x3', '\x2', '\x2', '\x2', '\x1B42', '\x1B41', '\x3', '\x2', '\x2', '\x2', 
		'\x1B42', '\x1B43', '\x3', '\x2', '\x2', '\x2', '\x1B43', '\x5CF', '\x3', 
		'\x2', '\x2', '\x2', '\x1B44', '\x1B46', '\x5', '\x5D2', '\x2EA', '\x2', 
		'\x1B45', '\x1B47', '\x5', '\x200', '\x101', '\x2', '\x1B46', '\x1B45', 
		'\x3', '\x2', '\x2', '\x2', '\x1B46', '\x1B47', '\x3', '\x2', '\x2', '\x2', 
		'\x1B47', '\x1B49', '\x3', '\x2', '\x2', '\x2', '\x1B48', '\x1B4A', '\x5', 
		'\x5B0', '\x2D9', '\x2', '\x1B49', '\x1B48', '\x3', '\x2', '\x2', '\x2', 
		'\x1B49', '\x1B4A', '\x3', '\x2', '\x2', '\x2', '\x1B4A', '\x1B4C', '\x3', 
		'\x2', '\x2', '\x2', '\x1B4B', '\x1B4D', '\x5', '\x5D4', '\x2EB', '\x2', 
		'\x1B4C', '\x1B4B', '\x3', '\x2', '\x2', '\x2', '\x1B4C', '\x1B4D', '\x3', 
		'\x2', '\x2', '\x2', '\x1B4D', '\x5D1', '\x3', '\x2', '\x2', '\x2', '\x1B4E', 
		'\x1B4F', '\a', 'j', '\x2', '\x2', '\x1B4F', '\x1B50', '\x5', '^', '\x30', 
		'\x2', '\x1B50', '\x5D3', '\x3', '\x2', '\x2', '\x2', '\x1B51', '\x1B52', 
		'\a', '\xF6', '\x2', '\x2', '\x1B52', '\x1B53', '\x5', '\x3EE', '\x1F8', 
		'\x2', '\x1B53', '\x5D5', '\x3', '\x2', '\x2', '\x2', '\x1B54', '\x1B5E', 
		'\a', '\x18E', '\x2', '\x2', '\x1B55', '\x1B5F', '\x5', '\x5D8', '\x2ED', 
		'\x2', '\x1B56', '\x1B5F', '\x5', '\x5DA', '\x2EE', '\x2', '\x1B57', '\x1B5F', 
		'\x5', '\x5DC', '\x2EF', '\x2', '\x1B58', '\x1B5F', '\x5', '\x5DE', '\x2F0', 
		'\x2', '\x1B59', '\x1B5F', '\x5', '\x5E0', '\x2F1', '\x2', '\x1B5A', '\x1B5F', 
		'\x5', '\x5E2', '\x2F2', '\x2', '\x1B5B', '\x1B5F', '\x5', '\x5E4', '\x2F3', 
		'\x2', '\x1B5C', '\x1B5F', '\x5', '\x5E6', '\x2F4', '\x2', '\x1B5D', '\x1B5F', 
		'\x5', '\x5E8', '\x2F5', '\x2', '\x1B5E', '\x1B55', '\x3', '\x2', '\x2', 
		'\x2', '\x1B5E', '\x1B56', '\x3', '\x2', '\x2', '\x2', '\x1B5E', '\x1B57', 
		'\x3', '\x2', '\x2', '\x2', '\x1B5E', '\x1B58', '\x3', '\x2', '\x2', '\x2', 
		'\x1B5E', '\x1B59', '\x3', '\x2', '\x2', '\x2', '\x1B5E', '\x1B5A', '\x3', 
		'\x2', '\x2', '\x2', '\x1B5E', '\x1B5B', '\x3', '\x2', '\x2', '\x2', '\x1B5E', 
		'\x1B5C', '\x3', '\x2', '\x2', '\x2', '\x1B5E', '\x1B5D', '\x3', '\x2', 
		'\x2', '\x2', '\x1B5F', '\x5D7', '\x3', '\x2', '\x2', '\x2', '\x1B60', 
		'\x1B61', '\a', '\xA6', '\x2', '\x2', '\x1B61', '\x1B62', '\a', '\x24B', 
		'\x2', '\x2', '\x1B62', '\x1B63', '\x5', '\x44', '#', '\x2', '\x1B63', 
		'\x1B64', '\a', '\x24D', '\x2', '\x2', '\x1B64', '\x1B65', '\x5', '\xA2', 
		'R', '\x2', '\x1B65', '\x1B66', '\a', '\x24C', '\x2', '\x2', '\x1B66', 
		'\x5D9', '\x3', '\x2', '\x2', '\x2', '\x1B67', '\x1B68', '\a', '\x1F', 
		'\x2', '\x2', '\x1B68', '\x5DB', '\x3', '\x2', '\x2', '\x2', '\x1B69', 
		'\x1B6A', '\a', '\x1D4', '\x2', '\x2', '\x1B6A', '\x5DD', '\x3', '\x2', 
		'\x2', '\x2', '\x1B6B', '\x1B6C', '\a', '\x1B0', '\x2', '\x2', '\x1B6C', 
		'\x1B6E', '\a', '\x24B', '\x2', '\x2', '\x1B6D', '\x1B6F', '\x5', '\x174', 
		'\xBB', '\x2', '\x1B6E', '\x1B6D', '\x3', '\x2', '\x2', '\x2', '\x1B6E', 
		'\x1B6F', '\x3', '\x2', '\x2', '\x2', '\x1B6F', '\x1B70', '\x3', '\x2', 
		'\x2', '\x2', '\x1B70', '\x1B71', '\a', '\x24C', '\x2', '\x2', '\x1B71', 
		'\x5DF', '\x3', '\x2', '\x2', '\x2', '\x1B72', '\x1B73', '\a', '/', '\x2', 
		'\x2', '\x1B73', '\x1B75', '\a', '\x24B', '\x2', '\x2', '\x1B74', '\x1B76', 
		'\x5', '\x166', '\xB4', '\x2', '\x1B75', '\x1B74', '\x3', '\x2', '\x2', 
		'\x2', '\x1B75', '\x1B76', '\x3', '\x2', '\x2', '\x2', '\x1B76', '\x1B77', 
		'\x3', '\x2', '\x2', '\x2', '\x1B77', '\x1B78', '\a', '\x24C', '\x2', 
		'\x2', '\x1B78', '\x5E1', '\x3', '\x2', '\x2', '\x2', '\x1B79', '\x1B7A', 
		'\a', '\xB9', '\x2', '\x2', '\x1B7A', '\x1B7C', '\a', '\x24B', '\x2', 
		'\x2', '\x1B7B', '\x1B7D', '\x5', '\x166', '\xB4', '\x2', '\x1B7C', '\x1B7B', 
		'\x3', '\x2', '\x2', '\x2', '\x1B7C', '\x1B7D', '\x3', '\x2', '\x2', '\x2', 
		'\x1B7D', '\x1B7E', '\x3', '\x2', '\x2', '\x2', '\x1B7E', '\x1B7F', '\a', 
		'\x24C', '\x2', '\x2', '\x1B7F', '\x5E3', '\x3', '\x2', '\x2', '\x2', 
		'\x1B80', '\x1B81', '\a', '\xEF', '\x2', '\x2', '\x1B81', '\x1B83', '\a', 
		'\x24B', '\x2', '\x2', '\x1B82', '\x1B84', '\x5', '\x166', '\xB4', '\x2', 
		'\x1B83', '\x1B82', '\x3', '\x2', '\x2', '\x2', '\x1B83', '\x1B84', '\x3', 
		'\x2', '\x2', '\x2', '\x1B84', '\x1B85', '\x3', '\x2', '\x2', '\x2', '\x1B85', 
		'\x1B86', '\a', '\x24C', '\x2', '\x2', '\x1B86', '\x5E5', '\x3', '\x2', 
		'\x2', '\x2', '\x1B87', '\x1B88', '\a', '\x204', '\x2', '\x2', '\x1B88', 
		'\x1B8A', '\a', '\x24B', '\x2', '\x2', '\x1B89', '\x1B8B', '\x5', '\x166', 
		'\xB4', '\x2', '\x1B8A', '\x1B89', '\x3', '\x2', '\x2', '\x2', '\x1B8A', 
		'\x1B8B', '\x3', '\x2', '\x2', '\x2', '\x1B8B', '\x1B8C', '\x3', '\x2', 
		'\x2', '\x2', '\x1B8C', '\x1B8D', '\a', '\x24C', '\x2', '\x2', '\x1B8D', 
		'\x5E7', '\x3', '\x2', '\x2', '\x2', '\x1B8E', '\x1B8F', '\a', '\x140', 
		'\x2', '\x2', '\x1B8F', '\x1B91', '\a', '\x24B', '\x2', '\x2', '\x1B90', 
		'\x1B92', '\x5', '\x166', '\xB4', '\x2', '\x1B91', '\x1B90', '\x3', '\x2', 
		'\x2', '\x2', '\x1B91', '\x1B92', '\x3', '\x2', '\x2', '\x2', '\x1B92', 
		'\x1B93', '\x3', '\x2', '\x2', '\x2', '\x1B93', '\x1B94', '\a', '\x24C', 
		'\x2', '\x2', '\x1B94', '\x5E9', '\x3', '\x2', '\x2', '\x2', '\x1B95', 
		'\x1B97', '\x5', 'P', ')', '\x2', '\x1B96', '\x1B98', '\x5', '\x5EC', 
		'\x2F7', '\x2', '\x1B97', '\x1B96', '\x3', '\x2', '\x2', '\x2', '\x1B97', 
		'\x1B98', '\x3', '\x2', '\x2', '\x2', '\x1B98', '\x1B99', '\x3', '\x2', 
		'\x2', '\x2', '\x1B99', '\x1BA2', '\x5', '\x62', '\x32', '\x2', '\x1B9A', 
		'\x1B9C', '\x5', '\x5AA', '\x2D6', '\x2', '\x1B9B', '\x1B9A', '\x3', '\x2', 
		'\x2', '\x2', '\x1B9B', '\x1B9C', '\x3', '\x2', '\x2', '\x2', '\x1B9C', 
		'\x1B9D', '\x3', '\x2', '\x2', '\x2', '\x1B9D', '\x1BA3', '\x5', '\x5AE', 
		'\x2D8', '\x2', '\x1B9E', '\x1BA0', '\x5', '\x5AC', '\x2D7', '\x2', '\x1B9F', 
		'\x1BA1', '\x5', '\x5AE', '\x2D8', '\x2', '\x1BA0', '\x1B9F', '\x3', '\x2', 
		'\x2', '\x2', '\x1BA0', '\x1BA1', '\x3', '\x2', '\x2', '\x2', '\x1BA1', 
		'\x1BA3', '\x3', '\x2', '\x2', '\x2', '\x1BA2', '\x1B9B', '\x3', '\x2', 
		'\x2', '\x2', '\x1BA2', '\x1B9E', '\x3', '\x2', '\x2', '\x2', '\x1BA2', 
		'\x1BA3', '\x3', '\x2', '\x2', '\x2', '\x1BA3', '\x5EB', '\x3', '\x2', 
		'\x2', '\x2', '\x1BA4', '\x1BA5', '\a', 'Z', '\x2', '\x2', '\x1BA5', '\x5ED', 
		'\x3', '\x2', '\x2', '\x2', '\x1BA6', '\x1BAB', '\a', '\x8F', '\x2', '\x2', 
		'\x1BA7', '\x1BAC', '\x5', '\x5F4', '\x2FB', '\x2', '\x1BA8', '\x1BAC', 
		'\x5', '\x5F0', '\x2F9', '\x2', '\x1BA9', '\x1BAC', '\x5', '\x5F6', '\x2FC', 
		'\x2', '\x1BAA', '\x1BAC', '\x5', '\x5F8', '\x2FD', '\x2', '\x1BAB', '\x1BA7', 
		'\x3', '\x2', '\x2', '\x2', '\x1BAB', '\x1BA8', '\x3', '\x2', '\x2', '\x2', 
		'\x1BAB', '\x1BA9', '\x3', '\x2', '\x2', '\x2', '\x1BAB', '\x1BAA', '\x3', 
		'\x2', '\x2', '\x2', '\x1BAC', '\x5EF', '\x3', '\x2', '\x2', '\x2', '\x1BAD', 
		'\x1BAE', '\a', '\x213', '\x2', '\x2', '\x1BAE', '\x1BB0', '\x5', '\x46', 
		'$', '\x2', '\x1BAF', '\x1BB1', '\x5', '\x5F2', '\x2FA', '\x2', '\x1BB0', 
		'\x1BAF', '\x3', '\x2', '\x2', '\x2', '\x1BB0', '\x1BB1', '\x3', '\x2', 
		'\x2', '\x2', '\x1BB1', '\x5F1', '\x3', '\x2', '\x2', '\x2', '\x1BB2', 
		'\x1BB3', '\t', '\x62', '\x2', '\x2', '\x1BB3', '\x5F3', '\x3', '\x2', 
		'\x2', '\x2', '\x1BB4', '\x1BB5', '\a', '\x213', '\x2', '\x2', '\x1BB5', 
		'\x1BB6', '\a', '*', '\x2', '\x2', '\x1BB6', '\x1BB7', '\x5', '\x46', 
		'$', '\x2', '\x1BB7', '\x5F5', '\x3', '\x2', '\x2', '\x2', '\x1BB8', '\x1BB9', 
		'\a', '\x20E', '\x2', '\x2', '\x1BB9', '\x1BBA', '\x5', '\x46', '$', '\x2', 
		'\x1BBA', '\x5F7', '\x3', '\x2', '\x2', '\x2', '\x1BBB', '\x1BBC', '\a', 
		'\xE2', '\x2', '\x2', '\x1BBC', '\x1BBE', '\x5', '\x46', '$', '\x2', '\x1BBD', 
		'\x1BBF', '\a', '\xC0', '\x2', '\x2', '\x1BBE', '\x1BBD', '\x3', '\x2', 
		'\x2', '\x2', '\x1BBE', '\x1BBF', '\x3', '\x2', '\x2', '\x2', '\x1BBF', 
		'\x5F9', '\x3', '\x2', '\x2', '\x2', '\x1BC0', '\x1BC5', '\a', '\r', '\x2', 
		'\x2', '\x1BC1', '\x1BC6', '\x5', '\x5FC', '\x2FF', '\x2', '\x1BC2', '\x1BC6', 
		'\x5', '\x660', '\x331', '\x2', '\x1BC3', '\x1BC6', '\x5', '\x600', '\x301', 
		'\x2', '\x1BC4', '\x1BC6', '\x5', '\x606', '\x304', '\x2', '\x1BC5', '\x1BC1', 
		'\x3', '\x2', '\x2', '\x2', '\x1BC5', '\x1BC2', '\x3', '\x2', '\x2', '\x2', 
		'\x1BC5', '\x1BC3', '\x3', '\x2', '\x2', '\x2', '\x1BC5', '\x1BC4', '\x3', 
		'\x2', '\x2', '\x2', '\x1BC6', '\x5FB', '\x3', '\x2', '\x2', '\x2', '\x1BC7', 
		'\x1BC8', '\a', '\x213', '\x2', '\x2', '\x1BC8', '\x1BCF', '\x5', '\x46', 
		'$', '\x2', '\x1BC9', '\x1BD0', '\x5', '\x63C', '\x31F', '\x2', '\x1BCA', 
		'\x1BD0', '\x5', '\x640', '\x321', '\x2', '\x1BCB', '\x1BCD', '\x5', '\x5FE', 
		'\x300', '\x2', '\x1BCC', '\x1BCE', '\x5', '\x652', '\x32A', '\x2', '\x1BCD', 
		'\x1BCC', '\x3', '\x2', '\x2', '\x2', '\x1BCD', '\x1BCE', '\x3', '\x2', 
		'\x2', '\x2', '\x1BCE', '\x1BD0', '\x3', '\x2', '\x2', '\x2', '\x1BCF', 
		'\x1BC9', '\x3', '\x2', '\x2', '\x2', '\x1BCF', '\x1BCA', '\x3', '\x2', 
		'\x2', '\x2', '\x1BCF', '\x1BCB', '\x3', '\x2', '\x2', '\x2', '\x1BD0', 
		'\x5FD', '\x3', '\x2', '\x2', '\x2', '\x1BD1', '\x1BDB', '\x5', '\x642', 
		'\x322', '\x2', '\x1BD2', '\x1BDB', '\x5', '\x650', '\x329', '\x2', '\x1BD3', 
		'\x1BDB', '\x5', '\x646', '\x324', '\x2', '\x1BD4', '\x1BD6', '\x5', '\x6A4', 
		'\x353', '\x2', '\x1BD5', '\x1BD4', '\x3', '\x2', '\x2', '\x2', '\x1BD6', 
		'\x1BD9', '\x3', '\x2', '\x2', '\x2', '\x1BD7', '\x1BD5', '\x3', '\x2', 
		'\x2', '\x2', '\x1BD7', '\x1BD8', '\x3', '\x2', '\x2', '\x2', '\x1BD8', 
		'\x1BDB', '\x3', '\x2', '\x2', '\x2', '\x1BD9', '\x1BD7', '\x3', '\x2', 
		'\x2', '\x2', '\x1BDA', '\x1BD1', '\x3', '\x2', '\x2', '\x2', '\x1BDA', 
		'\x1BD2', '\x3', '\x2', '\x2', '\x2', '\x1BDA', '\x1BD3', '\x3', '\x2', 
		'\x2', '\x2', '\x1BDA', '\x1BD7', '\x3', '\x2', '\x2', '\x2', '\x1BDB', 
		'\x5FF', '\x3', '\x2', '\x2', '\x2', '\x1BDC', '\x1BDD', '\a', '\x20E', 
		'\x2', '\x2', '\x1BDD', '\x1BE2', '\x5', '\x46', '$', '\x2', '\x1BDE', 
		'\x1BE3', '\a', '\x9A', '\x2', '\x2', '\x1BDF', '\x1BE3', '\a', '\x8A', 
		'\x2', '\x2', '\x1BE0', '\x1BE3', '\x5', '\x602', '\x302', '\x2', '\x1BE1', 
		'\x1BE3', '\x5', '\x604', '\x303', '\x2', '\x1BE2', '\x1BDE', '\x3', '\x2', 
		'\x2', '\x2', '\x1BE2', '\x1BDF', '\x3', '\x2', '\x2', '\x2', '\x1BE2', 
		'\x1BE0', '\x3', '\x2', '\x2', '\x2', '\x1BE2', '\x1BE1', '\x3', '\x2', 
		'\x2', '\x2', '\x1BE3', '\x601', '\x3', '\x2', '\x2', '\x2', '\x1BE4', 
		'\x1BE5', '\a', '\x1AE', '\x2', '\x2', '\x1BE5', '\x1BE6', '\a', '\x209', 
		'\x2', '\x2', '\x1BE6', '\x1BE7', '\x5', '^', '\x30', '\x2', '\x1BE7', 
		'\x603', '\x3', '\x2', '\x2', '\x2', '\x1BE8', '\x1BEA', '\a', 'Q', '\x2', 
		'\x2', '\x1BE9', '\x1BEB', '\a', 't', '\x2', '\x2', '\x1BEA', '\x1BE9', 
		'\x3', '\x2', '\x2', '\x2', '\x1BEA', '\x1BEB', '\x3', '\x2', '\x2', '\x2', 
		'\x1BEB', '\x1BED', '\x3', '\x2', '\x2', '\x2', '\x1BEC', '\x1BEE', '\x5', 
		'\x63E', '\x320', '\x2', '\x1BED', '\x1BEC', '\x3', '\x2', '\x2', '\x2', 
		'\x1BED', '\x1BEE', '\x3', '\x2', '\x2', '\x2', '\x1BEE', '\x1BF1', '\x3', 
		'\x2', '\x2', '\x2', '\x1BEF', '\x1BF0', '\a', '\x1B6', '\x2', '\x2', 
		'\x1BF0', '\x1BF2', '\a', '\x1DA', '\x2', '\x2', '\x1BF1', '\x1BEF', '\x3', 
		'\x2', '\x2', '\x2', '\x1BF1', '\x1BF2', '\x3', '\x2', '\x2', '\x2', '\x1BF2', 
		'\x605', '\x3', '\x2', '\x2', '\x2', '\x1BF3', '\x1BF4', '\a', '\xE2', 
		'\x2', '\x2', '\x1BF4', '\x1C03', '\x5', '\x46', '$', '\x2', '\x1BF5', 
		'\x1C04', '\a', '\x9A', '\x2', '\x2', '\x1BF6', '\x1C04', '\a', '\x8A', 
		'\x2', '\x2', '\x1BF7', '\x1C04', '\a', '\x21C', '\x2', '\x2', '\x1BF8', 
		'\x1C04', '\a', '\x46', '\x2', '\x2', '\x1BF9', '\x1BFA', '\t', '\x32', 
		'\x2', '\x2', '\x1BFA', '\x1C04', '\a', '\x220', '\x2', '\x2', '\x1BFB', 
		'\x1BFC', '\a', '\x21E', '\x2', '\x2', '\x1BFC', '\x1BFD', '\a', ')', 
		'\x2', '\x2', '\x1BFD', '\x1C04', '\a', '\x1A7', '\x2', '\x2', '\x1BFE', 
		'\x1C04', '\x5', '\x608', '\x305', '\x2', '\x1BFF', '\x1C04', '\x5', '\x618', 
		'\x30D', '\x2', '\x1C00', '\x1C04', '\x5', '\x61E', '\x310', '\x2', '\x1C01', 
		'\x1C04', '\x5', '\x602', '\x302', '\x2', '\x1C02', '\x1C04', '\x5', '\x620', 
		'\x311', '\x2', '\x1C03', '\x1BF5', '\x3', '\x2', '\x2', '\x2', '\x1C03', 
		'\x1BF6', '\x3', '\x2', '\x2', '\x2', '\x1C03', '\x1BF7', '\x3', '\x2', 
		'\x2', '\x2', '\x1C03', '\x1BF8', '\x3', '\x2', '\x2', '\x2', '\x1C03', 
		'\x1BF9', '\x3', '\x2', '\x2', '\x2', '\x1C03', '\x1BFB', '\x3', '\x2', 
		'\x2', '\x2', '\x1C03', '\x1BFE', '\x3', '\x2', '\x2', '\x2', '\x1C03', 
		'\x1BFF', '\x3', '\x2', '\x2', '\x2', '\x1C03', '\x1C00', '\x3', '\x2', 
		'\x2', '\x2', '\x1C03', '\x1C01', '\x3', '\x2', '\x2', '\x2', '\x1C03', 
		'\x1C02', '\x3', '\x2', '\x2', '\x2', '\x1C04', '\x607', '\x3', '\x2', 
		'\x2', '\x2', '\x1C05', '\x1C0C', '\x5', '\x60A', '\x306', '\x2', '\x1C06', 
		'\x1C0C', '\x5', '\x60E', '\x308', '\x2', '\x1C07', '\x1C0C', '\x5', '\x614', 
		'\x30B', '\x2', '\x1C08', '\x1C0C', '\x5', '\x270', '\x139', '\x2', '\x1C09', 
		'\x1C0C', '\x5', '\x616', '\x30C', '\x2', '\x1C0A', '\x1C0C', '\x5', '\x376', 
		'\x1BC', '\x2', '\x1C0B', '\x1C05', '\x3', '\x2', '\x2', '\x2', '\x1C0B', 
		'\x1C06', '\x3', '\x2', '\x2', '\x2', '\x1C0B', '\x1C07', '\x3', '\x2', 
		'\x2', '\x2', '\x1C0B', '\x1C08', '\x3', '\x2', '\x2', '\x2', '\x1C0B', 
		'\x1C09', '\x3', '\x2', '\x2', '\x2', '\x1C0B', '\x1C0A', '\x3', '\x2', 
		'\x2', '\x2', '\x1C0C', '\x1C0F', '\x3', '\x2', '\x2', '\x2', '\x1C0D', 
		'\x1C0B', '\x3', '\x2', '\x2', '\x2', '\x1C0D', '\x1C0E', '\x3', '\x2', 
		'\x2', '\x2', '\x1C0E', '\x609', '\x3', '\x2', '\x2', '\x2', '\x1C0F', 
		'\x1C0D', '\x3', '\x2', '\x2', '\x2', '\x1C10', '\x1C11', '\a', 's', '\x2', 
		'\x2', '\x1C11', '\x1C13', '\a', '\x21D', '\x2', '\x2', '\x1C12', '\x1C14', 
		'\x5', '\x60C', '\x307', '\x2', '\x1C13', '\x1C12', '\x3', '\x2', '\x2', 
		'\x2', '\x1C13', '\x1C14', '\x3', '\x2', '\x2', '\x2', '\x1C14', '\x60B', 
		'\x3', '\x2', '\x2', '\x2', '\x1C15', '\x1C16', '\a', '\xFD', '\x2', '\x2', 
		'\x1C16', '\x1C17', '\x5', '\x39E', '\x1D0', '\x2', '\x1C17', '\x60D', 
		'\x3', '\x2', '\x2', '\x2', '\x1C18', '\x1C19', '\a', '\v', '\x2', '\x2', 
		'\x1C19', '\x1C1B', '\a', '\xB0', '\x2', '\x2', '\x1C1A', '\x1C1C', '\x5', 
		'\x610', '\x309', '\x2', '\x1C1B', '\x1C1A', '\x3', '\x2', '\x2', '\x2', 
		'\x1C1B', '\x1C1C', '\x3', '\x2', '\x2', '\x2', '\x1C1C', '\x60F', '\x3', 
		'\x2', '\x2', '\x2', '\x1C1D', '\x1C1F', '\a', '\x24B', '\x2', '\x2', 
		'\x1C1E', '\x1C20', '\x5', '\x612', '\x30A', '\x2', '\x1C1F', '\x1C1E', 
		'\x3', '\x2', '\x2', '\x2', '\x1C20', '\x1C21', '\x3', '\x2', '\x2', '\x2', 
		'\x1C21', '\x1C1F', '\x3', '\x2', '\x2', '\x2', '\x1C21', '\x1C22', '\x3', 
		'\x2', '\x2', '\x2', '\x1C22', '\x1C23', '\x3', '\x2', '\x2', '\x2', '\x1C23', 
		'\x1C24', '\a', '\x24C', '\x2', '\x2', '\x1C24', '\x611', '\x3', '\x2', 
		'\x2', '\x2', '\x1C25', '\x1C26', '\a', '\x1DF', '\x2', '\x2', '\x1C26', 
		'\x1C2C', '\x5', '\x39E', '\x1D0', '\x2', '\x1C27', '\x1C28', '\a', 'n', 
		'\x2', '\x2', '\x1C28', '\x1C2C', '\x5', '\xA2', 'R', '\x2', '\x1C29', 
		'\x1C2A', '\a', '\xEC', '\x2', '\x2', '\x1C2A', '\x1C2C', '\x5', '(', 
		'\x15', '\x2', '\x1C2B', '\x1C25', '\x3', '\x2', '\x2', '\x2', '\x1C2B', 
		'\x1C27', '\x3', '\x2', '\x2', '\x2', '\x1C2B', '\x1C29', '\x3', '\x2', 
		'\x2', '\x2', '\x1C2C', '\x613', '\x3', '\x2', '\x2', '\x2', '\x1C2D', 
		'\x1C2E', '\a', '\x1DC', '\x2', '\x2', '\x1C2E', '\x1C30', '\a', '\x1E3', 
		'\x2', '\x2', '\x1C2F', '\x1C31', '\a', 'P', '\x2', '\x2', '\x1C30', '\x1C2F', 
		'\x3', '\x2', '\x2', '\x2', '\x1C30', '\x1C31', '\x3', '\x2', '\x2', '\x2', 
		'\x1C31', '\x1C33', '\x3', '\x2', '\x2', '\x2', '\x1C32', '\x1C34', '\a', 
		'\x38', '\x2', '\x2', '\x1C33', '\x1C32', '\x3', '\x2', '\x2', '\x2', 
		'\x1C33', '\x1C34', '\x3', '\x2', '\x2', '\x2', '\x1C34', '\x615', '\x3', 
		'\x2', '\x2', '\x2', '\x1C35', '\x1C36', '\a', '\x183', '\x2', '\x2', 
		'\x1C36', '\x1C3F', '\x5', '(', '\x15', '\x2', '\x1C37', '\x1C38', '\a', 
		'\x186', '\x2', '\x2', '\x1C38', '\x1C3F', '\x5', '(', '\x15', '\x2', 
		'\x1C39', '\x1C3A', '\a', '\xE9', '\x2', '\x2', '\x1C3A', '\x1C3F', '\x5', 
		'(', '\x15', '\x2', '\x1C3B', '\x1C3C', '\a', '\x124', '\x2', '\x2', '\x1C3C', 
		'\x1C3F', '\x5', '(', '\x15', '\x2', '\x1C3D', '\x1C3F', '\x5', '\x37C', 
		'\x1BF', '\x2', '\x1C3E', '\x1C35', '\x3', '\x2', '\x2', '\x2', '\x1C3E', 
		'\x1C37', '\x3', '\x2', '\x2', '\x2', '\x1C3E', '\x1C39', '\x3', '\x2', 
		'\x2', '\x2', '\x1C3E', '\x1C3B', '\x3', '\x2', '\x2', '\x2', '\x1C3E', 
		'\x1C3D', '\x3', '\x2', '\x2', '\x2', '\x1C3F', '\x617', '\x3', '\x2', 
		'\x2', '\x2', '\x1C40', '\x1C47', '\a', '\x1A2', '\x2', '\x2', '\x1C41', 
		'\x1C42', '\a', '\x17E', '\x2', '\x2', '\x1C42', '\x1C48', '\x5', '^', 
		'\x30', '\x2', '\x1C43', '\x1C44', '\a', '\x1F2', '\x2', '\x2', '\x1C44', 
		'\x1C48', '\x5', '^', '\x30', '\x2', '\x1C45', '\x1C48', '\a', '\x1B7', 
		'\x2', '\x2', '\x1C46', '\x1C48', '\a', '\x155', '\x2', '\x2', '\x1C47', 
		'\x1C41', '\x3', '\x2', '\x2', '\x2', '\x1C47', '\x1C43', '\x3', '\x2', 
		'\x2', '\x2', '\x1C47', '\x1C45', '\x3', '\x2', '\x2', '\x2', '\x1C47', 
		'\x1C46', '\x3', '\x2', '\x2', '\x2', '\x1C47', '\x1C48', '\x3', '\x2', 
		'\x2', '\x2', '\x1C48', '\x1C4C', '\x3', '\x2', '\x2', '\x2', '\x1C49', 
		'\x1C4B', '\x5', '\x61A', '\x30E', '\x2', '\x1C4A', '\x1C49', '\x3', '\x2', 
		'\x2', '\x2', '\x1C4B', '\x1C4E', '\x3', '\x2', '\x2', '\x2', '\x1C4C', 
		'\x1C4A', '\x3', '\x2', '\x2', '\x2', '\x1C4C', '\x1C4D', '\x3', '\x2', 
		'\x2', '\x2', '\x1C4D', '\x619', '\x3', '\x2', '\x2', '\x2', '\x1C4E', 
		'\x1C4C', '\x3', '\x2', '\x2', '\x2', '\x1C4F', '\x1C59', '\x5', '\x270', 
		'\x139', '\x2', '\x1C50', '\x1C59', '\x5', '\x378', '\x1BD', '\x2', '\x1C51', 
		'\x1C59', '\x5', '\x61E', '\x310', '\x2', '\x1C52', '\x1C59', '\a', '\x168', 
		'\x2', '\x2', '\x1C53', '\x1C54', '\a', 'V', '\x2', '\x2', '\x1C54', '\x1C59', 
		'\a', '\x1EA', '\x2', '\x2', '\x1C55', '\x1C59', '\x5', '\x616', '\x30C', 
		'\x2', '\x1C56', '\x1C59', '\x5', '\x61C', '\x30F', '\x2', '\x1C57', '\x1C59', 
		'\x5', '\x376', '\x1BC', '\x2', '\x1C58', '\x1C4F', '\x3', '\x2', '\x2', 
		'\x2', '\x1C58', '\x1C50', '\x3', '\x2', '\x2', '\x2', '\x1C58', '\x1C51', 
		'\x3', '\x2', '\x2', '\x2', '\x1C58', '\x1C52', '\x3', '\x2', '\x2', '\x2', 
		'\x1C58', '\x1C53', '\x3', '\x2', '\x2', '\x2', '\x1C58', '\x1C55', '\x3', 
		'\x2', '\x2', '\x2', '\x1C58', '\x1C56', '\x3', '\x2', '\x2', '\x2', '\x1C58', 
		'\x1C57', '\x3', '\x2', '\x2', '\x2', '\x1C59', '\x61B', '\x3', '\x2', 
		'\x2', '\x2', '\x1C5A', '\x1C5C', '\a', 'T', '\x2', '\x2', '\x1C5B', '\x1C5D', 
		'\x5', '(', '\x15', '\x2', '\x1C5C', '\x1C5B', '\x3', '\x2', '\x2', '\x2', 
		'\x1C5C', '\x1C5D', '\x3', '\x2', '\x2', '\x2', '\x1C5D', '\x1C60', '\x3', 
		'\x2', '\x2', '\x2', '\x1C5E', '\x1C60', '\a', '\x145', '\x2', '\x2', 
		'\x1C5F', '\x1C5A', '\x3', '\x2', '\x2', '\x2', '\x1C5F', '\x1C5E', '\x3', 
		'\x2', '\x2', '\x2', '\x1C60', '\x61D', '\x3', '\x2', '\x2', '\x2', '\x1C61', 
		'\x1C62', '\a', '\x17B', '\x2', '\x2', '\x1C62', '\x1C63', '\x5', '\xA2', 
		'R', '\x2', '\x1C63', '\x61F', '\x3', '\x2', '\x2', '\x2', '\x1C64', '\x1C6D', 
		'\x5', '\x622', '\x312', '\x2', '\x1C65', '\x1C6D', '\x5', '\x626', '\x314', 
		'\x2', '\x1C66', '\x1C6D', '\x5', '\x62A', '\x316', '\x2', '\x1C67', '\x1C6D', 
		'\x5', '\x62E', '\x318', '\x2', '\x1C68', '\x1C6D', '\x5', '\x630', '\x319', 
		'\x2', '\x1C69', '\x1C6D', '\x5', '\x632', '\x31A', '\x2', '\x1C6A', '\x1C6D', 
		'\x5', '\x628', '\x315', '\x2', '\x1C6B', '\x1C6D', '\x5', '\x63A', '\x31E', 
		'\x2', '\x1C6C', '\x1C64', '\x3', '\x2', '\x2', '\x2', '\x1C6C', '\x1C65', 
		'\x3', '\x2', '\x2', '\x2', '\x1C6C', '\x1C66', '\x3', '\x2', '\x2', '\x2', 
		'\x1C6C', '\x1C67', '\x3', '\x2', '\x2', '\x2', '\x1C6C', '\x1C68', '\x3', 
		'\x2', '\x2', '\x2', '\x1C6C', '\x1C69', '\x3', '\x2', '\x2', '\x2', '\x1C6C', 
		'\x1C6A', '\x3', '\x2', '\x2', '\x2', '\x1C6C', '\x1C6B', '\x3', '\x2', 
		'\x2', '\x2', '\x1C6D', '\x621', '\x3', '\x2', '\x2', '\x2', '\x1C6E', 
		'\x1C6F', '\a', '\x132', '\x2', '\x2', '\x1C6F', '\x1C70', '\a', 'y', 
		'\x2', '\x2', '\x1C70', '\x1C74', '\a', '\x1A', '\x2', '\x2', '\x1C71', 
		'\x1C72', '\a', '\xBE', '\x2', '\x2', '\x1C72', '\x1C73', '\a', '\x17E', 
		'\x2', '\x2', '\x1C73', '\x1C75', '\x5', '^', '\x30', '\x2', '\x1C74', 
		'\x1C71', '\x3', '\x2', '\x2', '\x2', '\x1C74', '\x1C75', '\x3', '\x2', 
		'\x2', '\x2', '\x1C75', '\x1C77', '\x3', '\x2', '\x2', '\x2', '\x1C76', 
		'\x1C78', '\x5', '\x624', '\x313', '\x2', '\x1C77', '\x1C76', '\x3', '\x2', 
		'\x2', '\x2', '\x1C78', '\x1C79', '\x3', '\x2', '\x2', '\x2', '\x1C79', 
		'\x1C77', '\x3', '\x2', '\x2', '\x2', '\x1C79', '\x1C7A', '\x3', '\x2', 
		'\x2', '\x2', '\x1C7A', '\x623', '\x3', '\x2', '\x2', '\x2', '\x1C7B', 
		'\x1C7F', '\x5', '\x616', '\x30C', '\x2', '\x1C7C', '\x1C7F', '\x5', '\x378', 
		'\x1BD', '\x2', '\x1C7D', '\x1C7F', '\x5', '\x376', '\x1BC', '\x2', '\x1C7E', 
		'\x1C7B', '\x3', '\x2', '\x2', '\x2', '\x1C7E', '\x1C7C', '\x3', '\x2', 
		'\x2', '\x2', '\x1C7E', '\x1C7D', '\x3', '\x2', '\x2', '\x2', '\x1C7F', 
		'\x625', '\x3', '\x2', '\x2', '\x2', '\x1C80', '\x1C81', '\a', '\x5', 
		'\x2', '\x2', '\x1C81', '\x1C83', '\a', '\x17E', '\x2', '\x2', '\x1C82', 
		'\x1C84', '\x5', '^', '\x30', '\x2', '\x1C83', '\x1C82', '\x3', '\x2', 
		'\x2', '\x2', '\x1C83', '\x1C84', '\x3', '\x2', '\x2', '\x2', '\x1C84', 
		'\x1C86', '\x3', '\x2', '\x2', '\x2', '\x1C85', '\x1C87', '\x5', '\x378', 
		'\x1BD', '\x2', '\x1C86', '\x1C85', '\x3', '\x2', '\x2', '\x2', '\x1C86', 
		'\x1C87', '\x3', '\x2', '\x2', '\x2', '\x1C87', '\x1C89', '\x3', '\x2', 
		'\x2', '\x2', '\x1C88', '\x1C8A', '\x5', '\x270', '\x139', '\x2', '\x1C89', 
		'\x1C88', '\x3', '\x2', '\x2', '\x2', '\x1C89', '\x1C8A', '\x3', '\x2', 
		'\x2', '\x2', '\x1C8A', '\x627', '\x3', '\x2', '\x2', '\x2', '\x1C8B', 
		'\x1C8C', '\a', '\x46', '\x2', '\x2', '\x1C8C', '\x1C8E', '\a', '\x17E', 
		'\x2', '\x2', '\x1C8D', '\x1C8F', '\x5', '\x270', '\x139', '\x2', '\x1C8E', 
		'\x1C8D', '\x3', '\x2', '\x2', '\x2', '\x1C8E', '\x1C8F', '\x3', '\x2', 
		'\x2', '\x2', '\x1C8F', '\x629', '\x3', '\x2', '\x2', '\x2', '\x1C90', 
		'\x1C91', '\a', '\x132', '\x2', '\x2', '\x1C91', '\x1C92', '\a', '\x17E', 
		'\x2', '\x2', '\x1C92', '\x1C9A', '\x5', '^', '\x30', '\x2', '\x1C93', 
		'\x1C9B', '\x5', '\x62C', '\x317', '\x2', '\x1C94', '\x1C9B', '\x5', '\x61E', 
		'\x310', '\x2', '\x1C95', '\x1C9B', '\a', '\x46', '\x2', '\x2', '\x1C96', 
		'\x1C97', '\a', '\x21E', '\x2', '\x2', '\x1C97', '\x1C98', '\a', ')', 
		'\x2', '\x2', '\x1C98', '\x1C9B', '\a', '\x1A7', '\x2', '\x2', '\x1C99', 
		'\x1C9B', '\a', '\x21C', '\x2', '\x2', '\x1C9A', '\x1C93', '\x3', '\x2', 
		'\x2', '\x2', '\x1C9A', '\x1C94', '\x3', '\x2', '\x2', '\x2', '\x1C9A', 
		'\x1C95', '\x3', '\x2', '\x2', '\x2', '\x1C9A', '\x1C96', '\x3', '\x2', 
		'\x2', '\x2', '\x1C9A', '\x1C99', '\x3', '\x2', '\x2', '\x2', '\x1C9B', 
		'\x62B', '\x3', '\x2', '\x2', '\x2', '\x1C9C', '\x1CA2', '\x5', '\x60A', 
		'\x306', '\x2', '\x1C9D', '\x1CA2', '\x5', '\x60E', '\x308', '\x2', '\x1C9E', 
		'\x1CA2', '\x5', '\x616', '\x30C', '\x2', '\x1C9F', '\x1CA2', '\x5', '\x376', 
		'\x1BC', '\x2', '\x1CA0', '\x1CA2', '\x5', '\x61C', '\x30F', '\x2', '\x1CA1', 
		'\x1C9C', '\x3', '\x2', '\x2', '\x2', '\x1CA1', '\x1C9D', '\x3', '\x2', 
		'\x2', '\x2', '\x1CA1', '\x1C9E', '\x3', '\x2', '\x2', '\x2', '\x1CA1', 
		'\x1C9F', '\x3', '\x2', '\x2', '\x2', '\x1CA1', '\x1CA0', '\x3', '\x2', 
		'\x2', '\x2', '\x1CA2', '\x1CA5', '\x3', '\x2', '\x2', '\x2', '\x1CA3', 
		'\x1CA1', '\x3', '\x2', '\x2', '\x2', '\x1CA3', '\x1CA4', '\x3', '\x2', 
		'\x2', '\x2', '\x1CA4', '\x62D', '\x3', '\x2', '\x2', '\x2', '\x1CA5', 
		'\x1CA3', '\x3', '\x2', '\x2', '\x2', '\x1CA6', '\x1CA7', '\a', '\x1AE', 
		'\x2', '\x2', '\x1CA7', '\x1CA8', '\t', 'R', '\x2', '\x2', '\x1CA8', '\x1CA9', 
		'\x5', '^', '\x30', '\x2', '\x1CA9', '\x1CAA', '\a', '\x209', '\x2', '\x2', 
		'\x1CAA', '\x1CAB', '\x5', '^', '\x30', '\x2', '\x1CAB', '\x62F', '\x3', 
		'\x2', '\x2', '\x2', '\x1CAC', '\x1CAD', '\a', '\x8F', '\x2', '\x2', '\x1CAD', 
		'\x1CAE', '\a', '\x17E', '\x2', '\x2', '\x1CAE', '\x1CAF', '\x5', '^', 
		'\x30', '\x2', '\x1CAF', '\x631', '\x3', '\x2', '\x2', '\x2', '\x1CB0', 
		'\x1CB1', '\a', '\x1E5', '\x2', '\x2', '\x1CB1', '\x1CB2', '\a', '\x17E', 
		'\x2', '\x2', '\x1CB2', '\x1CB3', '\x5', '^', '\x30', '\x2', '\x1CB3', 
		'\x1CB5', '\x5', '\x634', '\x31B', '\x2', '\x1CB4', '\x1CB6', '\x5', '\x636', 
		'\x31C', '\x2', '\x1CB5', '\x1CB4', '\x3', '\x2', '\x2', '\x2', '\x1CB5', 
		'\x1CB6', '\x3', '\x2', '\x2', '\x2', '\x1CB6', '\x1CB8', '\x3', '\x2', 
		'\x2', '\x2', '\x1CB7', '\x1CB9', '\x5', '\x270', '\x139', '\x2', '\x1CB8', 
		'\x1CB7', '\x3', '\x2', '\x2', '\x2', '\x1CB8', '\x1CB9', '\x3', '\x2', 
		'\x2', '\x2', '\x1CB9', '\x633', '\x3', '\x2', '\x2', '\x2', '\x1CBA', 
		'\x1CBB', '\a', '\x18', '\x2', '\x2', '\x1CBB', '\x1CBC', '\x5', '\x34E', 
		'\x1A8', '\x2', '\x1CBC', '\x635', '\x3', '\x2', '\x2', '\x2', '\x1CBD', 
		'\x1CBE', '\a', '\xF2', '\x2', '\x2', '\x1CBE', '\x1CBF', '\a', '\x24B', 
		'\x2', '\x2', '\x1CBF', '\x1CC0', '\x5', '\x638', '\x31D', '\x2', '\x1CC0', 
		'\x1CC1', '\a', '\x24D', '\x2', '\x2', '\x1CC1', '\x1CC2', '\x5', '\x638', 
		'\x31D', '\x2', '\x1CC2', '\x1CC3', '\a', '\x24C', '\x2', '\x2', '\x1CC3', 
		'\x637', '\x3', '\x2', '\x2', '\x2', '\x1CC4', '\x1CCD', '\a', '\x17E', 
		'\x2', '\x2', '\x1CC5', '\x1CCA', '\x5', '^', '\x30', '\x2', '\x1CC6', 
		'\x1CC9', '\x5', '\x2DC', '\x16F', '\x2', '\x1CC7', '\x1CC9', '\x5', '\x61C', 
		'\x30F', '\x2', '\x1CC8', '\x1CC6', '\x3', '\x2', '\x2', '\x2', '\x1CC8', 
		'\x1CC7', '\x3', '\x2', '\x2', '\x2', '\x1CC9', '\x1CCC', '\x3', '\x2', 
		'\x2', '\x2', '\x1CCA', '\x1CC8', '\x3', '\x2', '\x2', '\x2', '\x1CCA', 
		'\x1CCB', '\x3', '\x2', '\x2', '\x2', '\x1CCB', '\x1CCE', '\x3', '\x2', 
		'\x2', '\x2', '\x1CCC', '\x1CCA', '\x3', '\x2', '\x2', '\x2', '\x1CCD', 
		'\x1CC5', '\x3', '\x2', '\x2', '\x2', '\x1CCD', '\x1CCE', '\x3', '\x2', 
		'\x2', '\x2', '\x1CCE', '\x639', '\x3', '\x2', '\x2', '\x2', '\x1CCF', 
		'\x1CD0', '\a', '\x132', '\x2', '\x2', '\x1CD0', '\x1CD1', '\a', '\x1F2', 
		'\x2', '\x2', '\x1CD1', '\x1CD5', '\x5', '^', '\x30', '\x2', '\x1CD2', 
		'\x1CD6', '\a', '\x21C', '\x2', '\x2', '\x1CD3', '\x1CD6', '\x5', '\x60E', 
		'\x308', '\x2', '\x1CD4', '\x1CD6', '\x5', '\x60A', '\x306', '\x2', '\x1CD5', 
		'\x1CD2', '\x3', '\x2', '\x2', '\x2', '\x1CD5', '\x1CD3', '\x3', '\x2', 
		'\x2', '\x2', '\x1CD5', '\x1CD4', '\x3', '\x2', '\x2', '\x2', '\x1CD6', 
		'\x63B', '\x3', '\x2', '\x2', '\x2', '\x1CD7', '\x1CD9', '\a', 'Q', '\x2', 
		'\x2', '\x1CD8', '\x1CDA', '\a', 't', '\x2', '\x2', '\x1CD9', '\x1CD8', 
		'\x3', '\x2', '\x2', '\x2', '\x1CD9', '\x1CDA', '\x3', '\x2', '\x2', '\x2', 
		'\x1CDA', '\x1CDC', '\x3', '\x2', '\x2', '\x2', '\x1CDB', '\x1CDD', '\t', 
		'\x63', '\x2', '\x2', '\x1CDC', '\x1CDB', '\x3', '\x2', '\x2', '\x2', 
		'\x1CDC', '\x1CDD', '\x3', '\x2', '\x2', '\x2', '\x1CDD', '\x1CDF', '\x3', 
		'\x2', '\x2', '\x2', '\x1CDE', '\x1CE0', '\x5', '\x63E', '\x320', '\x2', 
		'\x1CDF', '\x1CDE', '\x3', '\x2', '\x2', '\x2', '\x1CDF', '\x1CE0', '\x3', 
		'\x2', '\x2', '\x2', '\x1CE0', '\x1CE3', '\x3', '\x2', '\x2', '\x2', '\x1CE1', 
		'\x1CE2', '\a', '\x1B6', '\x2', '\x2', '\x1CE2', '\x1CE4', '\a', '\x1DA', 
		'\x2', '\x2', '\x1CE3', '\x1CE1', '\x3', '\x2', '\x2', '\x2', '\x1CE3', 
		'\x1CE4', '\x3', '\x2', '\x2', '\x2', '\x1CE4', '\x63D', '\x3', '\x2', 
		'\x2', '\x2', '\x1CE5', '\x1CE6', '\x5', '^', '\x30', '\x2', '\x1CE6', 
		'\x1CE7', '\a', '\x253', '\x2', '\x2', '\x1CE7', '\x1CE8', '\x5', '\xA2', 
		'R', '\x2', '\x1CE8', '\x63F', '\x3', '\x2', '\x2', '\x2', '\x1CE9', '\x1CEA', 
		'\a', '\x1AF', '\x2', '\x2', '\x1CEA', '\x1CEB', '\x5', '\x682', '\x342', 
		'\x2', '\x1CEB', '\x641', '\x3', '\x2', '\x2', '\x2', '\x1CEC', '\x1CF1', 
		'\x5', '\x644', '\x323', '\x2', '\x1CED', '\x1CEE', '\a', '\x24D', '\x2', 
		'\x2', '\x1CEE', '\x1CF0', '\x5', '\x644', '\x323', '\x2', '\x1CEF', '\x1CED', 
		'\x3', '\x2', '\x2', '\x2', '\x1CF0', '\x1CF3', '\x3', '\x2', '\x2', '\x2', 
		'\x1CF1', '\x1CEF', '\x3', '\x2', '\x2', '\x2', '\x1CF1', '\x1CF2', '\x3', 
		'\x2', '\x2', '\x2', '\x1CF2', '\x643', '\x3', '\x2', '\x2', '\x2', '\x1CF3', 
		'\x1CF1', '\x3', '\x2', '\x2', '\x2', '\x1CF4', '\x1CF7', '\t', '\x64', 
		'\x2', '\x2', '\x1CF5', '\x1CF8', '\x5', '\x6A2', '\x352', '\x2', '\x1CF6', 
		'\x1CF8', '\x5', '\x69A', '\x34E', '\x2', '\x1CF7', '\x1CF5', '\x3', '\x2', 
		'\x2', '\x2', '\x1CF7', '\x1CF6', '\x3', '\x2', '\x2', '\x2', '\x1CF8', 
		'\x645', '\x3', '\x2', '\x2', '\x2', '\x1CF9', '\x1CFC', '\x5', '\x648', 
		'\x325', '\x2', '\x1CFA', '\x1CFC', '\x5', '\x64E', '\x328', '\x2', '\x1CFB', 
		'\x1CF9', '\x3', '\x2', '\x2', '\x2', '\x1CFB', '\x1CFA', '\x3', '\x2', 
		'\x2', '\x2', '\x1CFC', '\x647', '\x3', '\x2', '\x2', '\x2', '\x1CFD', 
		'\x1CFE', '\t', '\x65', '\x2', '\x2', '\x1CFE', '\x1D01', '\a', '\x19', 
		'\x2', '\x2', '\x1CFF', '\x1D02', '\x5', '\x64A', '\x326', '\x2', '\x1D00', 
		'\x1D02', '\x5', '\x64C', '\x327', '\x2', '\x1D01', '\x1CFF', '\x3', '\x2', 
		'\x2', '\x2', '\x1D01', '\x1D00', '\x3', '\x2', '\x2', '\x2', '\x1D02', 
		'\x649', '\x3', '\x2', '\x2', '\x2', '\x1D03', '\x1D05', '\x5', 'P', ')', 
		'\x2', '\x1D04', '\x1D06', '\x5', '\x62', '\x32', '\x2', '\x1D05', '\x1D04', 
		'\x3', '\x2', '\x2', '\x2', '\x1D05', '\x1D06', '\x3', '\x2', '\x2', '\x2', 
		'\x1D06', '\x64B', '\x3', '\x2', '\x2', '\x2', '\x1D07', '\x1D08', '\a', 
		'\x24B', '\x2', '\x2', '\x1D08', '\x1D0D', '\x5', '\x68C', '\x347', '\x2', 
		'\x1D09', '\x1D0A', '\a', '\x24D', '\x2', '\x2', '\x1D0A', '\x1D0C', '\x5', 
		'\x68C', '\x347', '\x2', '\x1D0B', '\x1D09', '\x3', '\x2', '\x2', '\x2', 
		'\x1D0C', '\x1D0F', '\x3', '\x2', '\x2', '\x2', '\x1D0D', '\x1D0B', '\x3', 
		'\x2', '\x2', '\x2', '\x1D0D', '\x1D0E', '\x3', '\x2', '\x2', '\x2', '\x1D0E', 
		'\x1D10', '\x3', '\x2', '\x2', '\x2', '\x1D0F', '\x1D0D', '\x3', '\x2', 
		'\x2', '\x2', '\x1D10', '\x1D11', '\a', '\x24C', '\x2', '\x2', '\x1D11', 
		'\x64D', '\x3', '\x2', '\x2', '\x2', '\x1D12', '\x1D13', '\a', '\x8F', 
		'\x2', '\x2', '\x1D13', '\x1D14', '\a', '\x19', '\x2', '\x2', '\x1D14', 
		'\x1D15', '\x5', '^', '\x30', '\x2', '\x1D15', '\x1D16', '\x5', '\x364', 
		'\x1B3', '\x2', '\x1D16', '\x64F', '\x3', '\x2', '\x2', '\x2', '\x1D17', 
		'\x1D1D', '\a', '\x132', '\x2', '\x2', '\x1D18', '\x1D19', '\a', '\x10C', 
		'\x2', '\x2', '\x1D19', '\x1D1E', '\x5', '(', '\x15', '\x2', '\x1D1A', 
		'\x1D1B', '\a', '\x96', '\x2', '\x2', '\x1D1B', '\x1D1C', '\a', '\x213', 
		'\x2', '\x2', '\x1D1C', '\x1D1E', '\x5', '\x62', '\x32', '\x2', '\x1D1D', 
		'\x1D18', '\x3', '\x2', '\x2', '\x2', '\x1D1D', '\x1D1A', '\x3', '\x2', 
		'\x2', '\x2', '\x1D1E', '\x651', '\x3', '\x2', '\x2', '\x2', '\x1D1F', 
		'\x1D22', '\x5', '\x654', '\x32B', '\x2', '\x1D20', '\x1D22', '\x5', '\x656', 
		'\x32C', '\x2', '\x1D21', '\x1D1F', '\x3', '\x2', '\x2', '\x2', '\x1D21', 
		'\x1D20', '\x3', '\x2', '\x2', '\x2', '\x1D22', '\x653', '\x3', '\x2', 
		'\x2', '\x2', '\x1D23', '\x1D24', '\a', '\xF3', '\x2', '\x2', '\x1D24', 
		'\x655', '\x3', '\x2', '\x2', '\x2', '\x1D25', '\x1D27', '\a', '\x38', 
		'\x2', '\x2', '\x1D26', '\x1D28', '\x5', '\x658', '\x32D', '\x2', '\x1D27', 
		'\x1D26', '\x3', '\x2', '\x2', '\x2', '\x1D27', '\x1D28', '\x3', '\x2', 
		'\x2', '\x2', '\x1D28', '\x1D2A', '\x3', '\x2', '\x2', '\x2', '\x1D29', 
		'\x1D2B', '\x5', '\x65E', '\x330', '\x2', '\x1D2A', '\x1D29', '\x3', '\x2', 
		'\x2', '\x2', '\x1D2A', '\x1D2B', '\x3', '\x2', '\x2', '\x2', '\x1D2B', 
		'\x657', '\x3', '\x2', '\x2', '\x2', '\x1D2C', '\x1D2F', '\x5', '\x65A', 
		'\x32E', '\x2', '\x1D2D', '\x1D2F', '\x5', '\x65C', '\x32F', '\x2', '\x1D2E', 
		'\x1D2C', '\x3', '\x2', '\x2', '\x2', '\x1D2E', '\x1D2D', '\x3', '\x2', 
		'\x2', '\x2', '\x1D2F', '\x659', '\x3', '\x2', '\x2', '\x2', '\x1D30', 
		'\x1D32', '\a', '\x15A', '\x2', '\x2', '\x1D31', '\x1D30', '\x3', '\x2', 
		'\x2', '\x2', '\x1D31', '\x1D32', '\x3', '\x2', '\x2', '\x2', '\x1D32', 
		'\x1D33', '\x3', '\x2', '\x2', '\x2', '\x1D33', '\x1D34', '\a', '\xE0', 
		'\x2', '\x2', '\x1D34', '\x1D35', '\a', '\x1FB', '\x2', '\x2', '\x1D35', 
		'\x1D36', '\a', 'l', '\x2', '\x2', '\x1D36', '\x65B', '\x3', '\x2', '\x2', 
		'\x2', '\x1D37', '\x1D38', '\a', '\x62', '\x2', '\x2', '\x1D38', '\x1D39', 
		'\a', '\x209', '\x2', '\x2', '\x1D39', '\x1D3A', '\a', '\x1F4', '\x2', 
		'\x2', '\x1D3A', '\x65D', '\x3', '\x2', '\x2', '\x2', '\x1D3B', '\x1D3D', 
		'\a', '\xC0', '\x2', '\x2', '\x1D3C', '\x1D3B', '\x3', '\x2', '\x2', '\x2', 
		'\x1D3C', '\x1D3D', '\x3', '\x2', '\x2', '\x2', '\x1D3D', '\x1D3E', '\x3', 
		'\x2', '\x2', '\x2', '\x1D3E', '\x1D3F', '\x5', '\x39C', '\x1CF', '\x2', 
		'\x1D3F', '\x65F', '\x3', '\x2', '\x2', '\x2', '\x1D40', '\x1D41', '\a', 
		'\x1D2', '\x2', '\x2', '\x1D41', '\x1D43', '\x5', '\x46', '$', '\x2', 
		'\x1D42', '\x1D44', '\x5', '\x662', '\x332', '\x2', '\x1D43', '\x1D42', 
		'\x3', '\x2', '\x2', '\x2', '\x1D44', '\x1D45', '\x3', '\x2', '\x2', '\x2', 
		'\x1D45', '\x1D43', '\x3', '\x2', '\x2', '\x2', '\x1D45', '\x1D46', '\x3', 
		'\x2', '\x2', '\x2', '\x1D46', '\x661', '\x3', '\x2', '\x2', '\x2', '\x1D47', 
		'\x1D53', '\x5', '\x666', '\x334', '\x2', '\x1D48', '\x1D53', '\x5', '\x668', 
		'\x335', '\x2', '\x1D49', '\x1D53', '\x5', '\x66A', '\x336', '\x2', '\x1D4A', 
		'\x1D53', '\x5', '\x66C', '\x337', '\x2', '\x1D4B', '\x1D53', '\x5', '\x66E', 
		'\x338', '\x2', '\x1D4C', '\x1D53', '\x5', '\x670', '\x339', '\x2', '\x1D4D', 
		'\x1D53', '\x5', '\x672', '\x33A', '\x2', '\x1D4E', '\x1D53', '\x5', '\x674', 
		'\x33B', '\x2', '\x1D4F', '\x1D53', '\x5', '\x676', '\x33C', '\x2', '\x1D50', 
		'\x1D53', '\x5', '\x678', '\x33D', '\x2', '\x1D51', '\x1D53', '\x5', '\x67A', 
		'\x33E', '\x2', '\x1D52', '\x1D47', '\x3', '\x2', '\x2', '\x2', '\x1D52', 
		'\x1D48', '\x3', '\x2', '\x2', '\x2', '\x1D52', '\x1D49', '\x3', '\x2', 
		'\x2', '\x2', '\x1D52', '\x1D4A', '\x3', '\x2', '\x2', '\x2', '\x1D52', 
		'\x1D4B', '\x3', '\x2', '\x2', '\x2', '\x1D52', '\x1D4C', '\x3', '\x2', 
		'\x2', '\x2', '\x1D52', '\x1D4D', '\x3', '\x2', '\x2', '\x2', '\x1D52', 
		'\x1D4E', '\x3', '\x2', '\x2', '\x2', '\x1D52', '\x1D4F', '\x3', '\x2', 
		'\x2', '\x2', '\x1D52', '\x1D50', '\x3', '\x2', '\x2', '\x2', '\x1D52', 
		'\x1D51', '\x3', '\x2', '\x2', '\x2', '\x1D53', '\x663', '\x3', '\x2', 
		'\x2', '\x2', '\x1D54', '\x1D5E', '\x5', '\x666', '\x334', '\x2', '\x1D55', 
		'\x1D5E', '\x5', '\x668', '\x335', '\x2', '\x1D56', '\x1D5E', '\x5', '\x66A', 
		'\x336', '\x2', '\x1D57', '\x1D5E', '\x5', '\x66C', '\x337', '\x2', '\x1D58', 
		'\x1D5E', '\x5', '\x66E', '\x338', '\x2', '\x1D59', '\x1D5E', '\x5', '\x670', 
		'\x339', '\x2', '\x1D5A', '\x1D5E', '\x5', '\x672', '\x33A', '\x2', '\x1D5B', 
		'\x1D5E', '\x5', '\x674', '\x33B', '\x2', '\x1D5C', '\x1D5E', '\x5', '\x676', 
		'\x33C', '\x2', '\x1D5D', '\x1D54', '\x3', '\x2', '\x2', '\x2', '\x1D5D', 
		'\x1D55', '\x3', '\x2', '\x2', '\x2', '\x1D5D', '\x1D56', '\x3', '\x2', 
		'\x2', '\x2', '\x1D5D', '\x1D57', '\x3', '\x2', '\x2', '\x2', '\x1D5D', 
		'\x1D58', '\x3', '\x2', '\x2', '\x2', '\x1D5D', '\x1D59', '\x3', '\x2', 
		'\x2', '\x2', '\x1D5D', '\x1D5A', '\x3', '\x2', '\x2', '\x2', '\x1D5D', 
		'\x1D5B', '\x3', '\x2', '\x2', '\x2', '\x1D5D', '\x1D5C', '\x3', '\x2', 
		'\x2', '\x2', '\x1D5E', '\x665', '\x3', '\x2', '\x2', '\x2', '\x1D5F', 
		'\x1D60', '\a', '\xE1', '\x2', '\x2', '\x1D60', '\x1D62', '\a', '\x33', 
		'\x2', '\x2', '\x1D61', '\x1D63', '\a', '\x257', '\x2', '\x2', '\x1D62', 
		'\x1D61', '\x3', '\x2', '\x2', '\x2', '\x1D62', '\x1D63', '\x3', '\x2', 
		'\x2', '\x2', '\x1D63', '\x1D64', '\x3', '\x2', '\x2', '\x2', '\x1D64', 
		'\x1D65', '\a', '\x245', '\x2', '\x2', '\x1D65', '\x667', '\x3', '\x2', 
		'\x2', '\x2', '\x1D66', '\x1D67', '\a', '\x1E6', '\x2', '\x2', '\x1D67', 
		'\x1D6E', '\a', '\x234', '\x2', '\x2', '\x1D68', '\x1D6A', '\a', '\x257', 
		'\x2', '\x2', '\x1D69', '\x1D68', '\x3', '\x2', '\x2', '\x2', '\x1D69', 
		'\x1D6A', '\x3', '\x2', '\x2', '\x2', '\x1D6A', '\x1D6B', '\x3', '\x2', 
		'\x2', '\x2', '\x1D6B', '\x1D6F', '\a', '\x245', '\x2', '\x2', '\x1D6C', 
		'\x1D6D', '\a', '\x10C', '\x2', '\x2', '\x1D6D', '\x1D6F', '\a', '\x225', 
		'\x2', '\x2', '\x1D6E', '\x1D69', '\x3', '\x2', '\x2', '\x2', '\x1D6E', 
		'\x1D6C', '\x3', '\x2', '\x2', '\x2', '\x1D6F', '\x669', '\x3', '\x2', 
		'\x2', '\x2', '\x1D70', '\x1D72', '\a', '\x125', '\x2', '\x2', '\x1D71', 
		'\x1D73', '\a', '\x257', '\x2', '\x2', '\x1D72', '\x1D71', '\x3', '\x2', 
		'\x2', '\x2', '\x1D72', '\x1D73', '\x3', '\x2', '\x2', '\x2', '\x1D73', 
		'\x1D74', '\x3', '\x2', '\x2', '\x2', '\x1D74', '\x1D77', '\a', '\x245', 
		'\x2', '\x2', '\x1D75', '\x1D77', '\a', '\x14C', '\x2', '\x2', '\x1D76', 
		'\x1D70', '\x3', '\x2', '\x2', '\x2', '\x1D76', '\x1D75', '\x3', '\x2', 
		'\x2', '\x2', '\x1D77', '\x66B', '\x3', '\x2', '\x2', '\x2', '\x1D78', 
		'\x1D7A', '\a', '\x12F', '\x2', '\x2', '\x1D79', '\x1D7B', '\a', '\x257', 
		'\x2', '\x2', '\x1D7A', '\x1D79', '\x3', '\x2', '\x2', '\x2', '\x1D7A', 
		'\x1D7B', '\x3', '\x2', '\x2', '\x2', '\x1D7B', '\x1D7C', '\x3', '\x2', 
		'\x2', '\x2', '\x1D7C', '\x1D7F', '\a', '\x245', '\x2', '\x2', '\x1D7D', 
		'\x1D7F', '\a', '\x14D', '\x2', '\x2', '\x1D7E', '\x1D78', '\x3', '\x2', 
		'\x2', '\x2', '\x1D7E', '\x1D7D', '\x3', '\x2', '\x2', '\x2', '\x1D7F', 
		'\x66D', '\x3', '\x2', '\x2', '\x2', '\x1D80', '\x1D81', '\t', '\x66', 
		'\x2', '\x2', '\x1D81', '\x66F', '\x3', '\x2', '\x2', '\x2', '\x1D82', 
		'\x1D84', '\a', '\x36', '\x2', '\x2', '\x1D83', '\x1D85', '\a', '\x257', 
		'\x2', '\x2', '\x1D84', '\x1D83', '\x3', '\x2', '\x2', '\x2', '\x1D84', 
		'\x1D85', '\x3', '\x2', '\x2', '\x2', '\x1D85', '\x1D86', '\x3', '\x2', 
		'\x2', '\x2', '\x1D86', '\x1D89', '\a', '\x245', '\x2', '\x2', '\x1D87', 
		'\x1D89', '\a', '\x144', '\x2', '\x2', '\x1D88', '\x1D82', '\x3', '\x2', 
		'\x2', '\x2', '\x1D88', '\x1D87', '\x3', '\x2', '\x2', '\x2', '\x1D89', 
		'\x671', '\x3', '\x2', '\x2', '\x2', '\x1D8A', '\x1D8B', '\t', 'g', '\x2', 
		'\x2', '\x1D8B', '\x673', '\x3', '\x2', '\x2', '\x2', '\x1D8C', '\x1D8E', 
		'\a', '\x1C7', '\x2', '\x2', '\x1D8D', '\x1D8F', '\t', 'h', '\x2', '\x2', 
		'\x1D8E', '\x1D8D', '\x3', '\x2', '\x2', '\x2', '\x1D8E', '\x1D8F', '\x3', 
		'\x2', '\x2', '\x2', '\x1D8F', '\x1D92', '\x3', '\x2', '\x2', '\x2', '\x1D90', 
		'\x1D92', '\a', '\x157', '\x2', '\x2', '\x1D91', '\x1D8C', '\x3', '\x2', 
		'\x2', '\x2', '\x1D91', '\x1D90', '\x3', '\x2', '\x2', '\x2', '\x1D92', 
		'\x675', '\x3', '\x2', '\x2', '\x2', '\x1D93', '\x1D94', '\t', 'i', '\x2', 
		'\x2', '\x1D94', '\x677', '\x3', '\x2', '\x2', '\x2', '\x1D95', '\x1D97', 
		'\a', '\x1EE', '\x2', '\x2', '\x1D96', '\x1D98', '\t', 'h', '\x2', '\x2', 
		'\x1D97', '\x1D96', '\x3', '\x2', '\x2', '\x2', '\x1D97', '\x1D98', '\x3', 
		'\x2', '\x2', '\x2', '\x1D98', '\x1D9B', '\x3', '\x2', '\x2', '\x2', '\x1D99', 
		'\x1D9B', '\a', '\x158', '\x2', '\x2', '\x1D9A', '\x1D95', '\x3', '\x2', 
		'\x2', '\x2', '\x1D9A', '\x1D99', '\x3', '\x2', '\x2', '\x2', '\x1D9B', 
		'\x679', '\x3', '\x2', '\x2', '\x2', '\x1D9C', '\x1D9D', '\t', 'j', '\x2', 
		'\x2', '\x1D9D', '\x67B', '\x3', '\x2', '\x2', '\x2', '\x1D9E', '\x1D9F', 
		'\a', '\x213', '\x2', '\x2', '\x1D9F', '\x1DA1', '\x5', '\x46', '$', '\x2', 
		'\x1DA0', '\x1DA2', '\x5', '\x692', '\x34A', '\x2', '\x1DA1', '\x1DA0', 
		'\x3', '\x2', '\x2', '\x2', '\x1DA1', '\x1DA2', '\x3', '\x2', '\x2', '\x2', 
		'\x1DA2', '\x1DA4', '\x3', '\x2', '\x2', '\x2', '\x1DA3', '\x1DA5', '\x5', 
		'\x680', '\x341', '\x2', '\x1DA4', '\x1DA3', '\x3', '\x2', '\x2', '\x2', 
		'\x1DA4', '\x1DA5', '\x3', '\x2', '\x2', '\x2', '\x1DA5', '\x1DA9', '\x3', 
		'\x2', '\x2', '\x2', '\x1DA6', '\x1DA8', '\x5', '\x67E', '\x340', '\x2', 
		'\x1DA7', '\x1DA6', '\x3', '\x2', '\x2', '\x2', '\x1DA8', '\x1DAB', '\x3', 
		'\x2', '\x2', '\x2', '\x1DA9', '\x1DA7', '\x3', '\x2', '\x2', '\x2', '\x1DA9', 
		'\x1DAA', '\x3', '\x2', '\x2', '\x2', '\x1DAA', '\x67D', '\x3', '\x2', 
		'\x2', '\x2', '\x1DAB', '\x1DA9', '\x3', '\x2', '\x2', '\x2', '\x1DAC', 
		'\x1DAD', '\a', '\r', '\x2', '\x2', '\x1DAD', '\x1DAE', '\x5', '\x5FC', 
		'\x2FF', '\x2', '\x1DAE', '\x67F', '\x3', '\x2', '\x2', '\x2', '\x1DAF', 
		'\x1DB3', '\x5', '\x682', '\x342', '\x2', '\x1DB0', '\x1DB3', '\x5', '\x68E', 
		'\x348', '\x2', '\x1DB1', '\x1DB3', '\x5', '\x690', '\x349', '\x2', '\x1DB2', 
		'\x1DAF', '\x3', '\x2', '\x2', '\x2', '\x1DB2', '\x1DB0', '\x3', '\x2', 
		'\x2', '\x2', '\x1DB2', '\x1DB1', '\x3', '\x2', '\x2', '\x2', '\x1DB3', 
		'\x681', '\x3', '\x2', '\x2', '\x2', '\x1DB4', '\x1DB6', '\x5', '\x1EE', 
		'\xF8', '\x2', '\x1DB5', '\x1DB4', '\x3', '\x2', '\x2', '\x2', '\x1DB5', 
		'\x1DB6', '\x3', '\x2', '\x2', '\x2', '\x1DB6', '\x1DB9', '\x3', '\x2', 
		'\x2', '\x2', '\x1DB7', '\x1DBA', '\x5', '\x684', '\x343', '\x2', '\x1DB8', 
		'\x1DBA', '\x5', '\x686', '\x344', '\x2', '\x1DB9', '\x1DB7', '\x3', '\x2', 
		'\x2', '\x2', '\x1DB9', '\x1DB8', '\x3', '\x2', '\x2', '\x2', '\x1DBA', 
		'\x1DBC', '\x3', '\x2', '\x2', '\x2', '\x1DBB', '\x1DBD', '\x5', '\x688', 
		'\x345', '\x2', '\x1DBC', '\x1DBB', '\x3', '\x2', '\x2', '\x2', '\x1DBC', 
		'\x1DBD', '\x3', '\x2', '\x2', '\x2', '\x1DBD', '\x1DC1', '\x3', '\x2', 
		'\x2', '\x2', '\x1DBE', '\x1DC0', '\x5', '\x6A4', '\x353', '\x2', '\x1DBF', 
		'\x1DBE', '\x3', '\x2', '\x2', '\x2', '\x1DC0', '\x1DC3', '\x3', '\x2', 
		'\x2', '\x2', '\x1DC1', '\x1DBF', '\x3', '\x2', '\x2', '\x2', '\x1DC1', 
		'\x1DC2', '\x3', '\x2', '\x2', '\x2', '\x1DC2', '\x683', '\x3', '\x2', 
		'\x2', '\x2', '\x1DC3', '\x1DC1', '\x3', '\x2', '\x2', '\x2', '\x1DC4', 
		'\x1DC5', '\x5', '\x1EC', '\xF7', '\x2', '\x1DC5', '\x1DC6', '\a', '\x161', 
		'\x2', '\x2', '\x1DC6', '\x685', '\x3', '\x2', '\x2', '\x2', '\x1DC7', 
		'\x1DC8', '\x5', '\x34A', '\x1A6', '\x2', '\x1DC8', '\x687', '\x3', '\x2', 
		'\x2', '\x2', '\x1DC9', '\x1DCA', '\a', '\x24B', '\x2', '\x2', '\x1DCA', 
		'\x1DCF', '\x5', '\x68A', '\x346', '\x2', '\x1DCB', '\x1DCC', '\a', '\x24D', 
		'\x2', '\x2', '\x1DCC', '\x1DCE', '\x5', '\x68A', '\x346', '\x2', '\x1DCD', 
		'\x1DCB', '\x3', '\x2', '\x2', '\x2', '\x1DCE', '\x1DD1', '\x3', '\x2', 
		'\x2', '\x2', '\x1DCF', '\x1DCD', '\x3', '\x2', '\x2', '\x2', '\x1DCF', 
		'\x1DD0', '\x3', '\x2', '\x2', '\x2', '\x1DD0', '\x1DD2', '\x3', '\x2', 
		'\x2', '\x2', '\x1DD1', '\x1DCF', '\x3', '\x2', '\x2', '\x2', '\x1DD2', 
		'\x1DD3', '\a', '\x24C', '\x2', '\x2', '\x1DD3', '\x689', '\x3', '\x2', 
		'\x2', '\x2', '\x1DD4', '\x1DD7', '\x5', '\x698', '\x34D', '\x2', '\x1DD5', 
		'\x1DD7', '\x5', '\x68C', '\x347', '\x2', '\x1DD6', '\x1DD4', '\x3', '\x2', 
		'\x2', '\x2', '\x1DD6', '\x1DD5', '\x3', '\x2', '\x2', '\x2', '\x1DD7', 
		'\x68B', '\x3', '\x2', '\x2', '\x2', '\x1DD8', '\x1DD9', '\x5', 'P', ')', 
		'\x2', '\x1DD9', '\x1DDA', '\x5', '\x62', '\x32', '\x2', '\x1DDA', '\x68D', 
		'\x3', '\x2', '\x2', '\x2', '\x1DDB', '\x1DDC', '\x5', '\x1EC', '\xF7', 
		'\x2', '\x1DDC', '\x1DDD', '\x5', '\x5C2', '\x2E2', '\x2', '\x1DDD', '\x68F', 
		'\x3', '\x2', '\x2', '\x2', '\x1DDE', '\x1DDF', '\x5', '\x1EC', '\xF7', 
		'\x2', '\x1DDF', '\x1DE0', '\x5', '\x5C8', '\x2E5', '\x2', '\x1DE0', '\x691', 
		'\x3', '\x2', '\x2', '\x2', '\x1DE1', '\x1DE2', '\a', '\x163', '\x2', 
		'\x2', '\x1DE2', '\x1DE3', '\x5', ',', '\x17', '\x2', '\x1DE3', '\x693', 
		'\x3', '\x2', '\x2', '\x2', '\x1DE4', '\x1DE5', '\a', '\x213', '\x2', 
		'\x2', '\x1DE5', '\x1DE6', '\a', '*', '\x2', '\x2', '\x1DE6', '\x1DE7', 
		'\x5', '\x46', '$', '\x2', '\x1DE7', '\x1DE8', '\x5', '\x1EC', '\xF7', 
		'\x2', '\x1DE8', '\x1DE9', '\x5', '\x696', '\x34C', '\x2', '\x1DE9', '\x1DEA', 
		'\a', '\x9C', '\x2', '\x2', '\x1DEA', '\x695', '\x3', '\x2', '\x2', '\x2', 
		'\x1DEB', '\x1DEC', '\x5', '\x698', '\x34D', '\x2', '\x1DEC', '\x1DF2', 
		'\a', '\x24E', '\x2', '\x2', '\x1DED', '\x1DEE', '\x5', '\x698', '\x34D', 
		'\x2', '\x1DEE', '\x1DEF', '\a', '\x24E', '\x2', '\x2', '\x1DEF', '\x1DF1', 
		'\x3', '\x2', '\x2', '\x2', '\x1DF0', '\x1DED', '\x3', '\x2', '\x2', '\x2', 
		'\x1DF1', '\x1DF4', '\x3', '\x2', '\x2', '\x2', '\x1DF2', '\x1DF0', '\x3', 
		'\x2', '\x2', '\x2', '\x1DF2', '\x1DF3', '\x3', '\x2', '\x2', '\x2', '\x1DF3', 
		'\x697', '\x3', '\x2', '\x2', '\x2', '\x1DF4', '\x1DF2', '\x3', '\x2', 
		'\x2', '\x2', '\x1DF5', '\x1DF7', '\x5', '\x6A4', '\x353', '\x2', '\x1DF6', 
		'\x1DF5', '\x3', '\x2', '\x2', '\x2', '\x1DF6', '\x1DF7', '\x3', '\x2', 
		'\x2', '\x2', '\x1DF7', '\x1DFB', '\x3', '\x2', '\x2', '\x2', '\x1DF8', 
		'\x1DFC', '\x5', '\x69A', '\x34E', '\x2', '\x1DF9', '\x1DFC', '\x5', '\x69C', 
		'\x34F', '\x2', '\x1DFA', '\x1DFC', '\x5', '\x6A2', '\x352', '\x2', '\x1DFB', 
		'\x1DF8', '\x3', '\x2', '\x2', '\x2', '\x1DFB', '\x1DF9', '\x3', '\x2', 
		'\x2', '\x2', '\x1DFB', '\x1DFA', '\x3', '\x2', '\x2', '\x2', '\x1DFC', 
		'\x699', '\x3', '\x2', '\x2', '\x2', '\x1DFD', '\x1E00', '\t', 'k', '\x2', 
		'\x2', '\x1DFE', '\x1E01', '\x5', '\x1E2', '\xF2', '\x2', '\x1DFF', '\x1E01', 
		'\x5', '\x20A', '\x106', '\x2', '\x1E00', '\x1DFE', '\x3', '\x2', '\x2', 
		'\x2', '\x1E00', '\x1DFF', '\x3', '\x2', '\x2', '\x2', '\x1E01', '\x69B', 
		'\x3', '\x2', '\x2', '\x2', '\x1E02', '\x1E03', '\x5', '\x69E', '\x350', 
		'\x2', '\x1E03', '\x1E06', '\x5', '\x6A0', '\x351', '\x2', '\x1E04', '\x1E07', 
		'\x5', '\x1EA', '\xF6', '\x2', '\x1E05', '\x1E07', '\x5', '\x1F0', '\xF9', 
		'\x2', '\x1E06', '\x1E04', '\x3', '\x2', '\x2', '\x2', '\x1E06', '\x1E05', 
		'\x3', '\x2', '\x2', '\x2', '\x1E06', '\x1E07', '\x3', '\x2', '\x2', '\x2', 
		'\x1E07', '\x69D', '\x3', '\x2', '\x2', '\x2', '\x1E08', '\x1E09', '\a', 
		']', '\x2', '\x2', '\x1E09', '\x1E0A', '\a', '\xCA', '\x2', '\x2', '\x1E0A', 
		'\x1E0C', '\x5', '\x46', '$', '\x2', '\x1E0B', '\x1E0D', '\x5', '\x200', 
		'\x101', '\x2', '\x1E0C', '\x1E0B', '\x3', '\x2', '\x2', '\x2', '\x1E0C', 
		'\x1E0D', '\x3', '\x2', '\x2', '\x2', '\x1E0D', '\x69F', '\x3', '\x2', 
		'\x2', '\x2', '\x1E0E', '\x1E0F', '\a', '\x1B4', '\x2', '\x2', '\x1E0F', 
		'\x1E10', '\a', '\x1D1', '\x2', '\x2', '\x1E10', '\x1E11', '\a', '\x15', 
		'\x2', '\x2', '\x1E11', '\x1E12', '\a', '\x1B1', '\x2', '\x2', '\x1E12', 
		'\x6A1', '\x3', '\x2', '\x2', '\x2', '\x1E13', '\x1E14', '\t', 'l', '\x2', 
		'\x2', '\x1E14', '\x1E15', '\a', '\x127', '\x2', '\x2', '\x1E15', '\x1E16', 
		'\x5', '\x20A', '\x106', '\x2', '\x1E16', '\x6A3', '\x3', '\x2', '\x2', 
		'\x2', '\x1E17', '\x1E19', '\a', '\x15A', '\x2', '\x2', '\x1E18', '\x1E17', 
		'\x3', '\x2', '\x2', '\x2', '\x1E18', '\x1E19', '\x3', '\x2', '\x2', '\x2', 
		'\x1E19', '\x1E1A', '\x3', '\x2', '\x2', '\x2', '\x1E1A', '\x1E1B', '\t', 
		'm', '\x2', '\x2', '\x1E1B', '\x6A5', '\x3', '\x2', '\x2', '\x2', '\x1E1C', 
		'\x1E1E', '\a', '\x198', '\x2', '\x2', '\x1E1D', '\x1E1C', '\x3', '\x2', 
		'\x2', '\x2', '\x1E1D', '\x1E1E', '\x3', '\x2', '\x2', '\x2', '\x1E1E', 
		'\x1E1F', '\x3', '\x2', '\x2', '\x2', '\x1E1F', '\x1E20', '\a', '\x1F8', 
		'\x2', '\x2', '\x1E20', '\x1E22', '\x5', '\x46', '$', '\x2', '\x1E21', 
		'\x1E23', '\x5', '\x6A8', '\x355', '\x2', '\x1E22', '\x1E21', '\x3', '\x2', 
		'\x2', '\x2', '\x1E22', '\x1E23', '\x3', '\x2', '\x2', '\x2', '\x1E23', 
		'\x1E24', '\x3', '\x2', '\x2', '\x2', '\x1E24', '\x1E25', '\a', '\xBE', 
		'\x2', '\x2', '\x1E25', '\x1E26', '\x5', 'H', '%', '\x2', '\x1E26', '\x6A7', 
		'\x3', '\x2', '\x2', '\x2', '\x1E27', '\x1E28', '\a', '\x1F0', '\x2', 
		'\x2', '\x1E28', '\x1E29', '\a', '\x253', '\x2', '\x2', '\x1E29', '\x1E2A', 
		'\t', 'n', '\x2', '\x2', '\x1E2A', '\x6A9', '\x3', '\x2', '\x2', '\x2', 
		'\x386', '\x6B7', '\x6BE', '\x6CB', '\x6D9', '\x6DC', '\x6E0', '\x6E5', 
		'\x6E7', '\x6F0', '\x6FD', '\x705', '\x707', '\x70D', '\x721', '\x723', 
		'\x729', '\x72D', '\x749', '\x74F', '\x752', '\x758', '\x75F', '\x76B', 
		'\x782', '\x786', '\x78C', '\x794', '\x79C', '\x79F', '\x7A1', '\x7A7', 
		'\x7AF', '\x7B8', '\x7BC', '\x7C4', '\x7CB', '\x7D0', '\x7D4', '\x7D9', 
		'\x7DC', '\x7DF', '\x7EE', '\x7F3', '\x7F7', '\x7FA', '\x800', '\x804', 
		'\x807', '\x819', '\x81C', '\x820', '\x824', '\x828', '\x82C', '\x830', 
		'\x834', '\x838', '\x83C', '\x840', '\x848', '\x84C', '\x84F', '\x852', 
		'\x857', '\x85A', '\x85D', '\x861', '\x864', '\x867', '\x86B', '\x86E', 
		'\x872', '\x875', '\x879', '\x87C', '\x880', '\x883', '\x888', '\x88E', 
		'\x892', '\x897', '\x8A5', '\x8AD', '\x8B2', '\x8B8', '\x8D1', '\x8D9', 
		'\x8DD', '\x8E1', '\x8EA', '\x8F6', '\x8FA', '\x8FD', '\x902', '\x90B', 
		'\x910', '\x915', '\x918', '\x921', '\x923', '\x939', '\x93D', '\x943', 
		'\x94A', '\x951', '\x959', '\x962', '\x98C', '\x98F', '\x999', '\x9A5', 
		'\x9AB', '\x9B2', '\x9BE', '\x9C7', '\x9D4', '\x9DA', '\x9DF', '\x9E8', 
		'\x9ED', '\x9F9', '\xA07', '\xA0B', '\xA0D', '\xA18', '\xA28', '\xA34', 
		'\xA3D', '\xA49', '\xA52', '\xA60', '\xA68', '\xA6B', '\xA78', '\xA7B', 
		'\xA8E', '\xA95', '\xA98', '\xAA3', '\xAB5', '\xAC1', '\xACC', '\xAD0', 
		'\xAD4', '\xAD6', '\xAE3', '\xAE6', '\xAEE', '\xAF1', '\xAF8', '\xB00', 
		'\xB07', '\xB23', '\xB37', '\xB3B', '\xB42', '\xB4A', '\xB51', '\xB59', 
		'\xB5E', '\xB62', '\xB65', '\xB6B', '\xB73', '\xB7C', '\xB84', '\xB8D', 
		'\xB96', '\xBA2', '\xBA9', '\xBAF', '\xBB4', '\xBB9', '\xBC7', '\xBD2', 
		'\xBDB', '\xBF1', '\xBF9', '\xBFC', '\xC00', '\xC07', '\xC0C', '\xC14', 
		'\xC19', '\xC1D', '\xC29', '\xC2E', '\xC33', '\xC38', '\xC3C', '\xC41', 
		'\xC43', '\xC46', '\xC4F', '\xC57', '\xC5E', '\xC62', '\xC64', '\xC68', 
		'\xC71', '\xC76', '\xC7A', '\xC7D', '\xC80', '\xC85', '\xC8D', '\xC9C', 
		'\xCA1', '\xCA5', '\xCA8', '\xCAB', '\xCBB', '\xCC6', '\xCC9', '\xCCC', 
		'\xCD9', '\xCE6', '\xCEB', '\xCF3', '\xCFD', '\xD07', '\xD0B', '\xD11', 
		'\xD1A', '\xD21', '\xD23', '\xD26', '\xD2A', '\xD2E', '\xD32', '\xD37', 
		'\xD3B', '\xD47', '\xD4F', '\xD53', '\xD56', '\xD59', '\xD73', '\xD76', 
		'\xD7C', '\xD7F', '\xD83', '\xD8B', '\xD92', '\xD9C', '\xD9E', '\xDA3', 
		'\xDA8', '\xDAB', '\xDB4', '\xDC3', '\xDC5', '\xDD4', '\xDDD', '\xDE9', 
		'\xDED', '\xDF3', '\xDF6', '\xDF9', '\xE01', '\xE0C', '\xE0E', '\xE12', 
		'\xE15', '\xE18', '\xE1B', '\xE1E', '\xE27', '\xE2E', '\xE35', '\xE37', 
		'\xE42', '\xE47', '\xE4A', '\xE4D', '\xE50', '\xE53', '\xE5A', '\xE5D', 
		'\xE60', '\xE63', '\xE66', '\xE69', '\xE6C', '\xE71', '\xE75', '\xE78', 
		'\xE7E', '\xE81', '\xE83', '\xE87', '\xE8B', '\xE90', '\xE94', '\xE9A', 
		'\xEA0', '\xEA5', '\xEA8', '\xEAB', '\xEBF', '\xEC3', '\xEC6', '\xECC', 
		'\xED2', '\xEDC', '\xEE6', '\xEE9', '\xEEF', '\xEF1', '\xEF3', '\xEFC', 
		'\xEFE', '\xF09', '\xF0E', '\xF11', '\xF14', '\xF17', '\xF1A', '\xF27', 
		'\xF2A', '\xF32', '\xF38', '\xF42', '\xF47', '\xF4E', '\xF54', '\xF5C', 
		'\xF64', '\xF67', '\xF71', '\xF76', '\xF79', '\xF81', '\xF8A', '\xF8C', 
		'\xF97', '\xF9E', '\xFA2', '\xFA7', '\xFAA', '\xFAD', '\xFB1', '\xFB3', 
		'\xFB7', '\xFBB', '\xFC3', '\xFCC', '\xFD0', '\xFD3', '\xFD5', '\xFDB', 
		'\xFDD', '\xFE5', '\xFF1', '\xFF9', '\xFFC', '\x1000', '\x1003', '\x100B', 
		'\x1010', '\x1014', '\x101E', '\x1024', '\x1026', '\x102C', '\x102E', 
		'\x1034', '\x1036', '\x1052', '\x106A', '\x1071', '\x107A', '\x108C', 
		'\x1093', '\x1099', '\x109D', '\x10A1', '\x10A3', '\x10A6', '\x10B0', 
		'\x10B2', '\x10B7', '\x10B9', '\x10BC', '\x10BE', '\x10C9', '\x10CC', 
		'\x10D0', '\x10D4', '\x10D7', '\x10E2', '\x10E6', '\x10E9', '\x10EF', 
		'\x10F7', '\x10F9', '\x10FC', '\x1101', '\x1104', '\x110A', '\x110C', 
		'\x110F', '\x1118', '\x111D', '\x112A', '\x1133', '\x1139', '\x113F', 
		'\x1148', '\x1154', '\x1159', '\x115E', '\x1164', '\x1166', '\x116E', 
		'\x1170', '\x1178', '\x117F', '\x1182', '\x1187', '\x118D', '\x1194', 
		'\x1197', '\x119E', '\x11AC', '\x11B0', '\x11B3', '\x11B7', '\x11C5', 
		'\x11CA', '\x11CD', '\x11D7', '\x11DA', '\x11DD', '\x11E3', '\x11E6', 
		'\x11E9', '\x11EC', '\x11EF', '\x11F2', '\x11FD', '\x1207', '\x120C', 
		'\x120F', '\x1212', '\x1215', '\x1218', '\x1224', '\x1226', '\x122A', 
		'\x122C', '\x1232', '\x123A', '\x123C', '\x1246', '\x124E', '\x1253', 
		'\x1258', '\x125D', '\x126B', '\x1276', '\x1279', '\x1281', '\x128C', 
		'\x128F', '\x1292', '\x1295', '\x129F', '\x12A2', '\x12AC', '\x12AF', 
		'\x12B2', '\x12B5', '\x12B8', '\x12C1', '\x12CD', '\x12D0', '\x12DA', 
		'\x12E1', '\x12EA', '\x12ED', '\x12F5', '\x12FC', '\x1302', '\x130B', 
		'\x1312', '\x1318', '\x131B', '\x1321', '\x1324', '\x1329', '\x132E', 
		'\x1332', '\x1338', '\x133F', '\x1342', '\x134B', '\x134D', '\x1350', 
		'\x135F', '\x1366', '\x1368', '\x136E', '\x1372', '\x137B', '\x138B', 
		'\x1390', '\x139A', '\x139C', '\x13A4', '\x13C8', '\x13CE', '\x13D3', 
		'\x13DE', '\x13E1', '\x13E5', '\x13EA', '\x13F1', '\x13F9', '\x13FE', 
		'\x1402', '\x1408', '\x140D', '\x1414', '\x1419', '\x141E', '\x1423', 
		'\x1433', '\x1437', '\x143C', '\x1445', '\x1448', '\x1457', '\x145F', 
		'\x1472', '\x147B', '\x1480', '\x1483', '\x148A', '\x148F', '\x1499', 
		'\x14A4', '\x14A8', '\x14B4', '\x14BC', '\x14C4', '\x14C9', '\x14CD', 
		'\x14CF', '\x14D2', '\x14D9', '\x14E0', '\x14EA', '\x14F1', '\x14F8', 
		'\x1502', '\x1507', '\x150A', '\x1516', '\x151A', '\x1521', '\x152C', 
		'\x1531', '\x1535', '\x1538', '\x1556', '\x155B', '\x155F', '\x1563', 
		'\x1568', '\x156C', '\x1570', '\x1572', '\x1587', '\x158C', '\x1594', 
		'\x159D', '\x15AD', '\x15B3', '\x15B7', '\x15BF', '\x15CE', '\x15D3', 
		'\x15DB', '\x15E3', '\x15F4', '\x15F9', '\x15FD', '\x1603', '\x1608', 
		'\x160A', '\x1612', '\x1615', '\x1619', '\x161F', '\x162B', '\x163E', 
		'\x1641', '\x164B', '\x164E', '\x1652', '\x1655', '\x165C', '\x1660', 
		'\x1665', '\x1673', '\x167C', '\x1686', '\x168A', '\x168F', '\x1694', 
		'\x169F', '\x16A2', '\x16A7', '\x16AB', '\x16B0', '\x16B5', '\x16B8', 
		'\x16BB', '\x16C6', '\x16C8', '\x16CE', '\x16D1', '\x16D5', '\x16DA', 
		'\x16E4', '\x16EA', '\x16F5', '\x16F9', '\x16FB', '\x1702', '\x170B', 
		'\x170F', '\x1714', '\x171C', '\x171F', '\x1724', '\x172E', '\x1732', 
		'\x1734', '\x1738', '\x173C', '\x174B', '\x1754', '\x175C', '\x1764', 
		'\x1766', '\x176C', '\x1777', '\x178A', '\x1791', '\x1798', '\x17A0', 
		'\x17A7', '\x17AF', '\x17B5', '\x17C0', '\x17C6', '\x17CA', '\x17D4', 
		'\x17E4', '\x17EC', '\x17F1', '\x17F5', '\x17F8', '\x17FB', '\x1801', 
		'\x1808', '\x180B', '\x180E', '\x1811', '\x1816', '\x1819', '\x1825', 
		'\x182B', '\x1834', '\x1837', '\x1845', '\x184B', '\x1851', '\x185A', 
		'\x185E', '\x1861', '\x1864', '\x1868', '\x186C', '\x186F', '\x1872', 
		'\x1875', '\x187E', '\x1881', '\x1891', '\x1897', '\x1899', '\x18A1', 
		'\x18A8', '\x18AE', '\x18B2', '\x18B6', '\x18BD', '\x18C0', '\x18C6', 
		'\x18CD', '\x18D0', '\x18D3', '\x18DA', '\x18E1', '\x18EA', '\x18ED', 
		'\x18F1', '\x18FF', '\x1902', '\x1905', '\x1912', '\x191A', '\x191D', 
		'\x1921', '\x1925', '\x1927', '\x1937', '\x193A', '\x1945', '\x1949', 
		'\x1950', '\x1953', '\x1956', '\x1963', '\x1969', '\x196C', '\x1979', 
		'\x1983', '\x198A', '\x1994', '\x1997', '\x19B0', '\x19B8', '\x19BE', 
		'\x19C5', '\x19CB', '\x19D1', '\x19D7', '\x19EA', '\x19EE', '\x1A03', 
		'\x1A07', '\x1A0E', '\x1A10', '\x1A16', '\x1A18', '\x1A31', '\x1A3A', 
		'\x1A3F', '\x1A43', '\x1A48', '\x1A4E', '\x1A54', '\x1A57', '\x1A5C', 
		'\x1A5F', '\x1A66', '\x1A6D', '\x1A74', '\x1A7A', '\x1A85', '\x1A97', 
		'\x1A9D', '\x1AA2', '\x1AA4', '\x1AAC', '\x1AB2', '\x1AB5', '\x1AC0', 
		'\x1AC4', '\x1AD8', '\x1ADB', '\x1AE3', '\x1AF0', '\x1AF8', '\x1AFD', 
		'\x1AFF', '\x1B08', '\x1B10', '\x1B15', '\x1B17', '\x1B1C', '\x1B29', 
		'\x1B2E', '\x1B35', '\x1B3A', '\x1B42', '\x1B46', '\x1B49', '\x1B4C', 
		'\x1B5E', '\x1B6E', '\x1B75', '\x1B7C', '\x1B83', '\x1B8A', '\x1B91', 
		'\x1B97', '\x1B9B', '\x1BA0', '\x1BA2', '\x1BAB', '\x1BB0', '\x1BBE', 
		'\x1BC5', '\x1BCD', '\x1BCF', '\x1BD7', '\x1BDA', '\x1BE2', '\x1BEA', 
		'\x1BED', '\x1BF1', '\x1C03', '\x1C0B', '\x1C0D', '\x1C13', '\x1C1B', 
		'\x1C21', '\x1C2B', '\x1C30', '\x1C33', '\x1C3E', '\x1C47', '\x1C4C', 
		'\x1C58', '\x1C5C', '\x1C5F', '\x1C6C', '\x1C74', '\x1C79', '\x1C7E', 
		'\x1C83', '\x1C86', '\x1C89', '\x1C8E', '\x1C9A', '\x1CA1', '\x1CA3', 
		'\x1CB5', '\x1CB8', '\x1CC8', '\x1CCA', '\x1CCD', '\x1CD5', '\x1CD9', 
		'\x1CDC', '\x1CDF', '\x1CE3', '\x1CF1', '\x1CF7', '\x1CFB', '\x1D01', 
		'\x1D05', '\x1D0D', '\x1D1D', '\x1D21', '\x1D27', '\x1D2A', '\x1D2E', 
		'\x1D31', '\x1D3C', '\x1D45', '\x1D52', '\x1D5D', '\x1D62', '\x1D69', 
		'\x1D6E', '\x1D72', '\x1D76', '\x1D7A', '\x1D7E', '\x1D84', '\x1D88', 
		'\x1D8E', '\x1D91', '\x1D97', '\x1D9A', '\x1DA1', '\x1DA4', '\x1DA9', 
		'\x1DB2', '\x1DB5', '\x1DB9', '\x1DBC', '\x1DC1', '\x1DCF', '\x1DD6', 
		'\x1DF2', '\x1DF6', '\x1DFB', '\x1E00', '\x1E06', '\x1E0C', '\x1E18', 
		'\x1E1D', '\x1E22',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
