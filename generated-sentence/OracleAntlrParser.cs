//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.9.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from grammars/OracleAntlrParser.g4 by ANTLR 4.9.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.9.2")]
[System.CLSCompliant(false)]
public partial class OracleAntlrParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		A_=1, ACCOUNT=2, ADD=3, ADVANCED=4, AFTER=5, AGENT=6, AGGREGATE=7, ALL=8, 
		ALLOCATE=9, ALLOW=10, ALTER=11, ALWAYS=12, ANALYZE=13, AND=14, ANY=15, 
		ANYSCHEMA=16, ARCHIVE=17, ARRAY=18, AS=19, ASC=20, ASSOCIATE=21, AT=22, 
		ATTRIBUTE=23, ATTRIBUTES=24, AUDIT=25, AUTHENTICATION=26, AUTHID=27, AUTO=28, 
		AUTONOMOUS_TRANSACTION=29, BASIC=30, BASICFILE=31, BATCH=32, BEFORE=33, 
		BEGIN=34, BEGINNING=35, BETWEEN=36, BINARY=37, BITMAP=38, BLOCK=39, BODY=40, 
		BOTH=41, BREADTH=42, BUFFER_POOL=43, BUILD=44, BUILTIN=45, BULK=46, BULK_EXCEPTIONS=47, 
		BULK_ROWCOUNT=48, BY=49, BYTE=50, C_=51, CACHE=52, CALL=53, CASCADE=54, 
		CASE=55, CAST=56, CELL_FLASH_CACHE=57, CHAR=58, CHAR_CS=59, CHARACTER=60, 
		CHARSET=61, CHECK=62, CHR=63, CHUNK=64, CLOB=65, CLOSE=66, CLUSTER=67, 
		COALESCE=68, COLLATE=69, COLLATION=70, COLLECT=71, COLUMN=72, COLUMN_VALUE=73, 
		COLUMNS=74, COMMENT=75, COMMIT=76, COMMITTED=77, COMPACT=78, COMPILE=79, 
		COMPLETE=80, COMPOUND=81, COMPRESS=82, COMPUTATION=83, COMPUTE=84, CONDITIONAL=85, 
		CONNECT=86, CONNECT_BY_ROOT=87, CONSTANT=88, CONSTRAINT=89, CONSTRAINTS=90, 
		CONSTRUCTOR=91, CONTAINER=92, CONTENT=93, CONTEXT=94, CONTINUE=95, CONVERT=96, 
		COUNT=97, CREATE=98, CREATION=99, CROSS=100, CUBE=101, CURRENT=102, CURRENT_USER=103, 
		CURSOR=104, CYCLE=105, DATA=106, DATABASE=107, DATAFILE=108, DATE=109, 
		DAY=110, DBTIMEZONE=111, DDL=112, DEALLOCATE=113, DEBUG=114, DECLARE=115, 
		DECODE=116, DECRYPT=117, DEDUPLICATE=118, DEFAULT=119, DEFERRABLE=120, 
		DEFERRED=121, DEFINER=122, DELETE=123, DEMAND=124, DENSE_RANK=125, DEPTH=126, 
		DESC=127, DETERMINISTIC=128, DIRECT_LOAD=129, DIRECTIVE_ELSE=130, DIRECTIVE_ELSIF=131, 
		DIRECTIVE_END=132, DIRECTIVE_ERROR=133, DIRECTIVE_IF=134, DIRECTIVE_THEN=135, 
		DISABLE=136, DISALLOW=137, DISASSOCIATE=138, DISTINCT=139, DOUBLE=140, 
		DROP=141, DUPLICATED=142, EACH=143, EDITION=144, EDITIONABLE=145, EDITIONING=146, 
		EDITIONS=147, ELEMENT=148, ELSE=149, ELSIF=150, EMPTY_KEYWORD=151, ENABLE=152, 
		ENCRYPT=153, END=154, ENFORCED=155, ERROR_CODE=156, ERROR_INDEX=157, ERROR=158, 
		ERRORS=159, ESCAPE=160, EVALUATE=161, EXCEPT=162, EXCEPTION=163, EXCEPTION_INIT=164, 
		EXCEPTIONS=165, EXCLUDE=166, EXCLUSIVE=167, EXECUTE=168, EXISTS=169, EXIT=170, 
		EXPIRE=171, EXTEND=172, EXTENDED=173, EXTENT=174, EXTERNALLY=175, EXTRACT=176, 
		EXTRACTVALUE=177, FALSE=178, FAST=179, FETCH=180, FILESYSTEM_LIKE_LOGGING=181, 
		FINAL=182, FIPSFLAG=183, FIRST=184, FIRST_ROWS=185, FIXED=186, FOLLOWING=187, 
		FOR=188, FORALL=189, FORCE=190, FOREIGN=191, FORMAT=192, FOUND=193, FLASH_CACHE=194, 
		FREELIST=195, FREELISTS=196, FREEPOOLS=197, FROM=198, FULL=199, FUNCTION=200, 
		GENERATED=201, GLOBAL=202, GLOBALLY=203, GOTO=204, GRANT=205, GROUP=206, 
		GROUPING=207, GROUPS=208, HASH=209, HAVING=210, HEAP=211, HIGH=212, HOUR=213, 
		ID=214, IDENTIFIED=215, IDENTIFIER=216, IDENTITY=217, IF=218, IMMEDIATE=219, 
		IN=220, INCLUDE=221, INCLUDING=222, INCREMENT=223, INDEX=224, INDEXING=225, 
		INDEXTYPE=226, INDICATOR=227, INDICES=228, INFINITE=229, INITIAL=230, 
		INITIALLY=231, INITRANS=232, INNER=233, INSERT=234, INSTANCE=235, INSTANTIABLE=236, 
		INSTEAD=237, INTERFACE=238, INTERSECT=239, INTERVAL=240, INTO=241, INVALIDATE=242, 
		INVALIDATION=243, INVISIBLE=244, IS=245, ISOLATION=246, ISOPEN=247, JAVA=248, 
		JOIN=249, JSON=250, JSON_TABLE=251, KEEP=252, KEEP_DUPLICATES=253, KEY=254, 
		LANGUAGE=255, LAST=256, LEADING=257, LEFT=258, LESS=259, LEVEL=260, LEVELS=261, 
		LIBRARY=262, LIKE=263, LIKE2=264, LIKE4=265, LIKEC=266, LIMIT=267, LIST=268, 
		LOB=269, LOBS=270, LOCAL=271, LOCATOR=272, LOCK=273, LOCKED=274, LOCKING=275, 
		LOG=276, LOGGING=277, LOGOFF=278, LOGON=279, LONG=280, LOOP=281, LOW=282, 
		MAP=283, MAPPING=284, MASTER=285, MATCHED=286, MATERIALIZED=287, MAX=288, 
		MAXEXTENTS=289, MAXSIZE=290, MAXTRANS=291, MAXVALUE=292, MEDIUM=293, MEMBER=294, 
		MEMOPTIMIZE=295, MERGE=296, METADATA=297, MIN=298, MINEXTENTS=299, MINUS=300, 
		MINUTE=301, MINVALUE=302, MOD=303, MODE=304, MODIFY=305, MONITORING=306, 
		MONTH=307, MOVEMENT=308, MULTISET=309, NAME=310, NAN=311, NATIONAL=312, 
		NATURAL=313, NCHAR=314, NCHAR_CS=315, NCHR=316, NESTED=317, NEVER=318, 
		NEW=319, NEW_NAMES=320, NEXT=321, NO=322, NOAUDIT=323, NOCACHE=324, NOCOMPRESS=325, 
		NOCOPY=326, NOCYCLE=327, NOEXTEND=328, NOKEEP=329, NOLOGGING=330, NOMAPPING=331, 
		NOMAXVALUE=332, NOMINVALUE=333, NOMONITORING=334, NOORDER=335, NONE=336, 
		NONEDITIONABLE=337, NONSCHEMA=338, NOPARALLEL=339, NORELY=340, NOREVERSE=341, 
		NOROWDEPENDENCIES=342, NOSCALE=343, NOSHARD=344, NOSORT=345, NOT=346, 
		NOTFOUND=347, NOVALIDATE=348, NOWAIT=349, NULL=350, NULLS=351, NVARCHAR2=352, 
		OBJECT=353, OF=354, OID=355, OIDINDEX=356, OLD=357, ON=358, ONLY=359, 
		ONLINE=360, OPAQUE=361, OPEN=362, OPERATIONS=363, OPTIMAL=364, OPTION=365, 
		OR=366, ORDER=367, ORDINALITY=368, ORGANIZATION=369, OUT=370, OUTER=371, 
		OVER=372, OVERFLOW=373, OVERLAPS=374, OVERRIDING=375, PACKAGE=376, PARALLEL=377, 
		PARALLEL_ENABLE=378, PARAMETERS=379, PARENT=380, PARTIAL=381, PARTITION=382, 
		PARTITIONS=383, PASSING=384, PASSWORD=385, PATH=386, PCTFREE=387, PCTINCREASE=388, 
		PCTTHRESHOLD=389, PCTUSED=390, PCTVERSION=391, PERCENTILE_DISC=392, PERIOD=393, 
		PIPE=394, PIPELINED=395, PIVOT=396, POLYMORPHIC=397, PRAGMA=398, PREBUILT=399, 
		PRECEDING=400, PRECISION=401, PRESERVE=402, PRIMARY=403, PRIOR=404, PRIVATE=405, 
		PROCEDURE=406, PROFILE=407, PUBLIC=408, PURGE=409, QUERY=410, QUOTA=411, 
		RAISE=412, RAISE_APPLICATION_ERROR=413, RANGE=414, RAW=415, READ=416, 
		READS=417, REBUILD=418, RECORD=419, RECYCLE=420, REDUCED=421, REF=422, 
		REFERENCES=423, REFERENCING=424, REFRESH=425, REJECT=426, RELATIONAL=427, 
		RELIES_ON=428, RELY=429, RENAME=430, REPLACE=431, RESTRICT_REFERENCES=432, 
		RESULT=433, RESULT_CACHE=434, RETENTION=435, RETURN=436, RETURNING=437, 
		REUSE=438, REVERSE=439, REVOKE=440, REWRITE=441, RIGHT=442, ROLLBACK=443, 
		ROLLUP=444, ROW=445, ROWCOUNT=446, ROWDEPENDENCIES=447, ROWID=448, ROWS=449, 
		ROWTYPE=450, SALT=451, SAMPLE=452, SAVE=453, SAVEPOINT=454, SCALE=455, 
		SCHEMA=456, SCN=457, SCOPE=458, SEARCH=459, SECOND=460, SECUREFILE=461, 
		SEED=462, SEGMENT=463, SELECT=464, SELF=465, SEQUENCE=466, SERIALIZABLE=467, 
		SERIALLY_REUSABLE=468, SERVERERROR=469, SESSION=470, SESSIONTIMEZONE=471, 
		SET=472, SETS=473, SETTINGS=474, SHARE=475, SHRINK=476, SHUTDOWN=477, 
		SIBLINGS=478, SIZE=479, SKIP_=480, SOME=481, SORT=482, SPACE=483, SPECIFICATION=484, 
		SPLIT=485, START=486, STARTUP=487, STATEMENT=488, STATIC=489, STATISTICS=490, 
		STORAGE=491, STORE=492, STRING=493, SHARD=494, SHARDED=495, SHARING=496, 
		SUBMULTISET=497, SUBPARTITION=498, SUBPARTITIONS=499, SUBSTITUTABLE=500, 
		SUBTYPE=501, SUPPLEMENTAL=502, SUSPEND=503, SYNONYM=504, SYS_CONNECT_BY_PATH=505, 
		SYSTEM=506, TABLE=507, TABLES=508, TABLESPACE=509, TEMPLATE=510, TEMPORARY=511, 
		THAN=512, THE=513, THEN=514, TIME=515, TIMESTAMP=516, TIMEZONE_ABBR=517, 
		TIMEZONE_HOUR=518, TIMEZONE_MINUTE=519, TIMEZONE_REGION=520, TO=521, TRAILING=522, 
		TRANSACTION=523, TRANSLATE=524, TREAT=525, TRIGGER=526, TRIM=527, TRUE=528, 
		TRUNCATE=529, TRUSTED=530, TYPE=531, UNBOUNDED=532, UNCONDITIONAL=533, 
		UNDER=534, UNION=535, UNIQUE=536, UNLIMITED=537, UNLOCK=538, UNPIVOT=539, 
		UNUSABLE=540, UNUSED=541, UPDATE=542, USABLE=543, USAGE=544, USE=545, 
		USER=546, USING=547, VALIDATE=548, VALUE=549, VALUES=550, VARCHAR=551, 
		VARCHAR2=552, VARRAY=553, VARRAYS=554, VARYING=555, VERSIONS=556, VIEW=557, 
		VIRTUAL=558, VISIBLE=559, WAIT=560, WHEN=561, WHERE=562, WHILE=563, WITH=564, 
		WITHIN=565, WITHOUT=566, WORK=567, WRAPPED=568, WRAPPER=569, WRITE=570, 
		XML=571, XMLAGG=572, XMLCAST=573, XMLNAMESPACES=574, XMLQUERY=575, XMLSCHEMA=576, 
		XMLTABLE=577, XMLTYPE=578, YEAR=579, ZONE=580, INTEGER_LITERAL=581, ASSIGN_OPERATOR=582, 
		ASSOC_OPERATOR=583, CONCAT_OPERATOR=584, POWER_OPERATOR=585, DOUBLE_DOT_OPERATOR=586, 
		LPAREN=587, RPAREN=588, COMMA=589, SEMI=590, FSLASH=591, BSLASH=592, GREATER_THAN=593, 
		LESS_THAN=594, EQUAL_SIGN=595, PERCENT_SIGN=596, AT_SIGN=597, PLUS_SIGN=598, 
		MINUS_SIGN=599, POUND_SIGN=600, QUESTION_MARK=601, BANG=602, ASTERISK=603, 
		DOT=604, CARET=605, TILDE=606, FLOATING_POINT_LITERAL=607, FLOATING_POINT_BINARY_LITERAL=608, 
		UNICODE_CHARACTER_STRING_LITERAL=609, BINARY_STRING_LITERAL=610, CHARACTER_STRING_LITERAL=611, 
		BYTE_SIZE_LITERAL=612, MONEY_LITERAL=613, REGULAR_IDENTIFIER=614, QUOTED_IDENTIFIER=615, 
		WHITESPACES=616, WHITESPACE=617, LINE_COMMENT=618, COMMENTS=619, QUOTE_CHARACTER_STRING_LITERAL=620, 
		INVALID_CHAR=621;
	public const int
		RULE_expressionInputFile = 0, RULE_conditionInputFile = 1, RULE_hintInputFile = 2, 
		RULE_dynamicSqlInputFile = 3, RULE_computedColumnExpressionInputFile = 4, 
		RULE_expressionListInputFile = 5, RULE_hintsList = 6, RULE_hintItem = 7, 
		RULE_hintParams = 8, RULE_complexIndexHint = 9, RULE_queryBlock = 10, 
		RULE_sqlInputFile = 11, RULE_sqlStatementBatch = 12, RULE_sqlStatement = 13, 
		RULE_plSqlStatementBatch = 14, RULE_plSqlStatement = 15, RULE_routineSignature = 16, 
		RULE_procedureOrFunctionSignature = 17, RULE_literal = 18, RULE_quoteCharacterStringLiteral = 19, 
		RULE_characterStringLiteral = 20, RULE_unicodeCharacterStringLiteral = 21, 
		RULE_binaryStringLiteral = 22, RULE_booleanLiteral = 23, RULE_dateLiteral = 24, 
		RULE_timestampLiteral = 25, RULE_intervalLiteral = 26, RULE_intervalLiteralFieldClause = 27, 
		RULE_intervalLiteralFieldPrecision = 28, RULE_floatingPointBinaryLiteral = 29, 
		RULE_simpleIdentifierRegularIdentifier = 30, RULE_dotInIdentifier = 31, 
		RULE_identifier = 32, RULE_plainIdentifier = 33, RULE_plainRemoteIdentifier = 34, 
		RULE_multipartPlainIdentifier = 35, RULE_asterisk = 36, RULE_dbLink = 37, 
		RULE_simpleIdentifier = 38, RULE_nestedCollectionSimpleIdentifier = 39, 
		RULE_plainIdentifierAsStringLiteral = 40, RULE_typeReferenceOpaqueFixed = 41, 
		RULE_plainSimpleIdentifierAsStringLiteral = 42, RULE_simpleIdentifierParams = 43, 
		RULE_localSimpleIdentifierWithoutParentheses = 44, RULE_simpleIdentifierWithoutParentheses = 45, 
		RULE_bindParameter = 46, RULE_typeReference = 47, RULE_identifierTimestamp = 48, 
		RULE_identifierTime = 49, RULE_identifierWith = 50, RULE_identifierLocal = 51, 
		RULE_identifierZone = 52, RULE_identifierInterval = 53, RULE_identifierTo = 54, 
		RULE_identifierLong = 55, RULE_identifierRaw = 56, RULE_identifierLongRaw = 57, 
		RULE_identifierDoublePrecision = 58, RULE_identifierCharacter = 59, RULE_identifierNationalCharacter = 60, 
		RULE_identifierNChar = 61, RULE_identifierNVarChar2 = 62, RULE_identifierVarChar = 63, 
		RULE_identifierVarChar2 = 64, RULE_identifierString = 65, RULE_charIdentifierParams = 66, 
		RULE_typeReferenceTimestampCase = 67, RULE_typeReferenceIntervalCase = 68, 
		RULE_typeReferenceCharCase = 69, RULE_collationSpecClause = 70, RULE_typeReferenceLongAndRawCase = 71, 
		RULE_typeReferenceAttributes = 72, RULE_typeReferenceCharacterSetAttribute = 73, 
		RULE_typeReferenceCharacterSetModifier = 74, RULE_typeReferenceRangeAttribute = 75, 
		RULE_delimiterDoubleDot = 76, RULE_typeReferenceModifierAttribute = 77, 
		RULE_typeReferenceRefCase = 78, RULE_fullExpression = 79, RULE_fullOrCondition = 80, 
		RULE_fullAndCondition = 81, RULE_fullUnaryCondition = 82, RULE_fullAtomicCondition = 83, 
		RULE_delimiterCurrentOf = 84, RULE_delimiterExists = 85, RULE_fullAtomicCondition1 = 86, 
		RULE_inPureExpression = 87, RULE_delimiterAny = 88, RULE_delimiterSome = 89, 
		RULE_delimiterAll = 90, RULE_delimiterNot = 91, RULE_delimiterIs = 92, 
		RULE_delimiterIn = 93, RULE_delimiterLParen = 94, RULE_delimiterRParen = 95, 
		RULE_typesComparison = 96, RULE_typeComparisonNames = 97, RULE_pureExpression = 98, 
		RULE_bitwiseLevelExpression = 99, RULE_addLevelExpression = 100, RULE_addLevelOperator = 101, 
		RULE_divideLevelOperator = 102, RULE_unaryExpression = 103, RULE_xmlQuery = 104, 
		RULE_xmlQueryDelegate = 105, RULE_xmlPassingParameterList = 106, RULE_xmlPassingParameterListItem = 107, 
		RULE_xmlCast = 108, RULE_newExpression = 109, RULE_treatExpression = 110, 
		RULE_treatExpressionParameters = 111, RULE_treatExpressionAsClause = 112, 
		RULE_treatExpressionReturnValue = 113, RULE_multisetExpression = 114, 
		RULE_multisetOperator = 115, RULE_dateTimeAtClause = 116, RULE_dateTimeAtLocalClause = 117, 
		RULE_dateTimeAtTimeZoneClause = 118, RULE_keepExpression = 119, RULE_keepClause = 120, 
		RULE_withinExpression = 121, RULE_withinExpressionParams = 122, RULE_overExpression = 123, 
		RULE_overExpressionParams = 124, RULE_overExpressionPartitionClause = 125, 
		RULE_overExpressionWindowingClause = 126, RULE_overExpressionWindowingClauseBetween = 127, 
		RULE_overExpressionWindowingClauseSingle = 128, RULE_overExpressionWindowingClauseItem = 129, 
		RULE_overExpressionWindowingClauseItemExpression = 130, RULE_cursorAttributeExpression = 131, 
		RULE_bulkExpression = 132, RULE_bulkExceptionExpression = 133, RULE_bulkRowCountExpression = 134, 
		RULE_collectionIndex = 135, RULE_powerExpression = 136, RULE_delimiterNull = 137, 
		RULE_delimiterNan = 138, RULE_delimiterInfinite = 139, RULE_delimiterOperandOfIs = 140, 
		RULE_castExpression = 141, RULE_cursorExpression = 142, RULE_caseExpression = 143, 
		RULE_simpleCaseExpression = 144, RULE_simpleCaseWhenEntry = 145, RULE_caseElseEntry = 146, 
		RULE_searchedCaseExpression = 147, RULE_searchedCaseWhenEntry = 148, RULE_priorExpression = 149, 
		RULE_connectByRootExpression = 150, RULE_sysConnectByPathExpression = 151, 
		RULE_trimExpression = 152, RULE_trimExtClause = 153, RULE_decodeExpression = 154, 
		RULE_extractDatetimeExpression = 155, RULE_extractXMLExpression = 156, 
		RULE_xmlTypeInstance = 157, RULE_xpathString = 158, RULE_xmlNamespace = 159, 
		RULE_extractDatetimeFromClause = 160, RULE_delimiterDate = 161, RULE_multiColumnCondition = 162, 
		RULE_overlapsCondition = 163, RULE_comparisonList = 164, RULE_collectionsComparison = 165, 
		RULE_collectionsComparisonSubmultiset = 166, RULE_collectionsComparisonMemberOf = 167, 
		RULE_collectionsComparisonIsASet = 168, RULE_collectionsComparisonIsEmpty = 169, 
		RULE_likeOperator = 170, RULE_escapeClause = 171, RULE_betweenOperator = 172, 
		RULE_betweenAndOperator = 173, RULE_comparisonPairOperator = 174, RULE_flattenedQuery = 175, 
		RULE_asFlattenedQuery = 176, RULE_flattenedQueryNestedTable = 177, RULE_fullExpressionList = 178, 
		RULE_fullExpressionListItem = 179, RULE_expressionList = 180, RULE_multiItemExpressionList = 181, 
		RULE_defaultExpression = 182, RULE_expressionListItem = 183, RULE_xmlaggExpression = 184, 
		RULE_parameterName = 185, RULE_alias = 186, RULE_identifierList = 187, 
		RULE_columnListElementClause = 188, RULE_columnListItem = 189, RULE_complexColumnListItem = 190, 
		RULE_createStatement = 191, RULE_createStatementReplaceClause = 192, RULE_createUserStatement = 193, 
		RULE_createUserIdentificationClause = 194, RULE_createUserPasswordIdentificationClause = 195, 
		RULE_createUserExternalIdentificationClause = 196, RULE_createUserGlobalIdentificationClause = 197, 
		RULE_createUserNoAuthenticationClause = 198, RULE_createUserOption = 199, 
		RULE_defaultCollationOption = 200, RULE_createUserDefaultTablespaceOption = 201, 
		RULE_createUserTemporaryTablespaceOption = 202, RULE_createUserTablespaceQuotaOption = 203, 
		RULE_createUserProfileOption = 204, RULE_createUserPasswordExpireOption = 205, 
		RULE_createUserAccountOption = 206, RULE_createUserEnableEditionsOption = 207, 
		RULE_createUserContainerOption = 208, RULE_createIndexStatement = 209, 
		RULE_clusterIndexClause = 210, RULE_tableIndexClause = 211, RULE_tableIndexExpression = 212, 
		RULE_bitmapJoinIndexClause = 213, RULE_bitmapJoinIndexExpression = 214, 
		RULE_bitmapJoinIndexFromClauseItem = 215, RULE_indexProperties = 216, 
		RULE_globalPartitionedIndex = 217, RULE_localPartitionedIndex = 218, RULE_indexOnSimplePartitionedTableClause = 219, 
		RULE_indexOnSimplePartitionedTableClauseItem = 220, RULE_indexOnHashPartitionedTable = 221, 
		RULE_indexOnHashPartitionedTableClauseItem = 222, RULE_indexOnCompPartitionedTable = 223, 
		RULE_indexOnCompPartitionedTableClauseItem = 224, RULE_indexSubpartitionClause = 225, 
		RULE_indexSubpartitionClauseItem = 226, RULE_indexAttribute = 227, RULE_visibilityClause = 228, 
		RULE_partialIndexClause = 229, RULE_indexTypeClause = 230, RULE_localIndexClause = 231, 
		RULE_localIndexClauseItem = 232, RULE_unstructuredIndexParametersClause = 233, 
		RULE_simpleTablespaceClause = 234, RULE_createSequenceStatement = 235, 
		RULE_createSequenceSharingClause = 236, RULE_createEditionableBatchWideStatement = 237, 
		RULE_editionOptionClause = 238, RULE_packageStatement = 239, RULE_packageBodyStatement = 240, 
		RULE_packageDeclarationBlock = 241, RULE_procedureStatement = 242, RULE_procedureSignature = 243, 
		RULE_procedureImplementation = 244, RULE_procedureHeader = 245, RULE_routineBody = 246, 
		RULE_routineBodyAsIsClause = 247, RULE_invokerRightsClause = 248, RULE_procedureCallSpecClause = 249, 
		RULE_javaDeclarationClause = 250, RULE_cDeclarationClause = 251, RULE_cDeclarationNameClause = 252, 
		RULE_cDeclarationLibraryClause = 253, RULE_cDeclarationAgentClause = 254, 
		RULE_cDeclarationContextClause = 255, RULE_cDeclarationParametersClause = 256, 
		RULE_argumentList = 257, RULE_argument = 258, RULE_argumentNoCopyClause = 259, 
		RULE_argumentModeClause = 260, RULE_argumentDefaultValue = 261, RULE_functionStatement = 262, 
		RULE_functionSignature = 263, RULE_functionImplementation = 264, RULE_functionHeader = 265, 
		RULE_functionReturnClause = 266, RULE_functionDeterministicClause = 267, 
		RULE_functionParallelEnableClause = 268, RULE_parallelOnPartitionOption = 269, 
		RULE_parallelOnPartitionBy = 270, RULE_columnListItemInParen = 271, RULE_parallelOnPartitionStreamingClause = 272, 
		RULE_parallelOnPartitionStreamingClauseBy = 273, RULE_resultCacheClause = 274, 
		RULE_resultCacheReliesOnClause = 275, RULE_functionAggregateClause = 276, 
		RULE_functionPipelinedClause = 277, RULE_createTableStatement = 278, RULE_tableHeader = 279, 
		RULE_createObjectTableStatement = 280, RULE_memOptimizeClause = 281, RULE_parentClause = 282, 
		RULE_oidIndexClause = 283, RULE_oidIndexClauseList = 284, RULE_objectIdentifierIsClause = 285, 
		RULE_objectTableOfClause = 286, RULE_createRelationTableStatement = 287, 
		RULE_createXMLTypeTableStatement = 288, RULE_tablePropertiesClause = 289, 
		RULE_columnProperties = 290, RULE_xmlTypeColumnProperties = 291, RULE_xmlTypeStorageClause = 292, 
		RULE_xmlTypeStoreAsClause = 293, RULE_xmlTypeStoreAsObjectRelationalClause = 294, 
		RULE_xmlTypeStoreAsLobClause = 295, RULE_xmlTypeStoreAllClause = 296, 
		RULE_objectTypeColProperties = 297, RULE_varrayColProperties = 298, RULE_nestedTableColProperties = 299, 
		RULE_nestedTableObjectProperties = 300, RULE_returnAsClause = 301, RULE_objectPropertiesListClause = 302, 
		RULE_objectProperties = 303, RULE_storeAsClause = 304, RULE_nestedItemClause = 305, 
		RULE_asSubqueryClause = 306, RULE_rowMovementClause = 307, RULE_enableDisableConstraintClause = 308, 
		RULE_keepDropIndexClause = 309, RULE_cascadeClause = 310, RULE_monitoringClause = 311, 
		RULE_rowdependenciesClause = 312, RULE_parallelClause = 313, RULE_partitioningDefinitionClause = 314, 
		RULE_compositePartitioning = 315, RULE_subPartitionByHash = 316, RULE_subpartitionsStoreInClause = 317, 
		RULE_subPartitionByList = 318, RULE_subPartitionTemplate = 319, RULE_subPartitionDefinitionListClause = 320, 
		RULE_subPartitionDefinitionClause = 321, RULE_partitionByListClause = 322, 
		RULE_partitionByHashClause = 323, RULE_partitionsSimpleClause = 324, RULE_partitionSimpleListClause = 325, 
		RULE_partitionSimpleClause = 326, RULE_partitionByRangeClause = 327, RULE_partitionDefinitionListClause = 328, 
		RULE_partitionDefinitionClause = 329, RULE_tablePartitionDescription = 330, 
		RULE_partitionLevelSubpartitioningClause = 331, RULE_subpartitionSpecList = 332, 
		RULE_subpartitionSpec = 333, RULE_partitioningStorageClause = 334, RULE_listValuesClause = 335, 
		RULE_subpartitionsSimpleClause = 336, RULE_partitionsStoreInClause = 337, 
		RULE_tablespaceListClause = 338, RULE_varrayStorageClause = 339, RULE_substitutableColumnClause = 340, 
		RULE_notSubstitutableClause = 341, RULE_elementIsOfTypeClause = 342, RULE_delimiterOnly = 343, 
		RULE_storeAsLobClause = 344, RULE_lOBStorageClause = 345, RULE_lOBPropertiesListClause = 346, 
		RULE_lobPropertiesListElementClause = 347, RULE_lobStoreAsClause = 348, 
		RULE_rangeValuesClause = 349, RULE_valuesLessThanListClause = 350, RULE_valuesLessThanListItem = 351, 
		RULE_partitionByRangeColumnList = 352, RULE_physicalPropertiesClause = 353, 
		RULE_physicalPropertiesClusterClause = 354, RULE_physicalPropertiesOrganizationClause = 355, 
		RULE_deferredSegmentCreationClause = 356, RULE_heapOrganizedTableClauseElement = 357, 
		RULE_indexOrganizedTableClauseElement = 358, RULE_indexOrganizedOverflowClause = 359, 
		RULE_overflowClause = 360, RULE_includingOverflowClause = 361, RULE_pCTThresholdClause = 362, 
		RULE_mappingTableClause = 363, RULE_tableCompressionClause = 364, RULE_indexCompressionClause = 365, 
		RULE_compressionOperations = 366, RULE_segmentAttributesClause = 367, 
		RULE_segmentAttributesClauseElement = 368, RULE_onCommitClause = 369, 
		RULE_relationPropertiesListClause = 370, RULE_relationPropertiesClause = 371, 
		RULE_supplementalLoggingPropsClause = 372, RULE_supplementalLogGrpClause = 373, 
		RULE_supplementalIdKeyClause = 374, RULE_supplementalIdKeyClauseItem = 375, 
		RULE_columnDeclarationClause = 376, RULE_columnIdentityClause = 377, RULE_columnDefaultValueClause = 378, 
		RULE_virtualColumnDefinition = 379, RULE_computedColumnExpression = 380, 
		RULE_tableRefConstraintClause = 381, RULE_tableRefWithRowidClause = 382, 
		RULE_tableRefScopeForClause = 383, RULE_columnRefConstraintClause = 384, 
		RULE_withRowidClause = 385, RULE_scopeIsClause = 386, RULE_foreignKeyClause = 387, 
		RULE_tableRefForeignKeyClause = 388, RULE_materializedViewStatement = 389, 
		RULE_materializedViewHeader = 390, RULE_objectMaterializedViewClause = 391, 
		RULE_materializedViewPrebuiltTableClause = 392, RULE_materializedViewPhysicalClusterProperties = 393, 
		RULE_materializedViewPhysicalClusterColumnList = 394, RULE_materializedViewProperties = 395, 
		RULE_materializedViewPropertiesCacheClause = 396, RULE_materializedViewPropertiesBuildClause = 397, 
		RULE_materializedViewUsingIndexClause = 398, RULE_materializedViewUsingIndexAttributesListClause = 399, 
		RULE_materializedViewRefreshClause = 400, RULE_materializedViewRefreshOptions = 401, 
		RULE_materializedViewRefreshType = 402, RULE_materializedViewRefreshTrigger = 403, 
		RULE_materializedViewRefreshSchedule = 404, RULE_materializedViewRefreshRowIdentificationClause = 405, 
		RULE_materializedViewRefreshRollbackSegmentClause = 406, RULE_materializedViewRefreshUsingConstraints = 407, 
		RULE_evaluationEditionClause = 408, RULE_materializedViewQueryComputationClause = 409, 
		RULE_materializedViewQueryRewriteClause = 410, RULE_unusableEditionsBeforeClause = 411, 
		RULE_unusableEditionsBeginningWithClause = 412, RULE_viewStatement = 413, 
		RULE_viewHeader = 414, RULE_xmlTypeViewClause = 415, RULE_xmlSchemaSpec = 416, 
		RULE_xmlSchemaClause = 417, RULE_xmlSchemaElementClause = 418, RULE_xmlSchemaSpecNonschemaClause = 419, 
		RULE_xmlSchemaSpecAnyschemaClause = 420, RULE_objectViewClause = 421, 
		RULE_underClause = 422, RULE_withObjectIdentifierClause = 423, RULE_parenthesizedExpressionList = 424, 
		RULE_forceNoForceClause = 425, RULE_viewBody = 426, RULE_subqueryRestrictionClause = 427, 
		RULE_viewAliasOrConstraintList = 428, RULE_viewAliasOrTableConstraint = 429, 
		RULE_viewAlias = 430, RULE_attributeOrConstraintList = 431, RULE_attributeOrTableConstraint = 432, 
		RULE_attributeConstraintClause = 433, RULE_tableConstraintClause = 434, 
		RULE_columnListInParenElementClause = 435, RULE_columnConstraintClause = 436, 
		RULE_constraintStateClause = 437, RULE_deferrableConstraintClause = 438, 
		RULE_initiallyConstraintClause = 439, RULE_enableClause = 440, RULE_relyConstraintClause = 441, 
		RULE_usingIndexConstraintClause = 442, RULE_usingIndexAttributesListConstraintClause = 443, 
		RULE_indexCompression = 444, RULE_prefixCompression = 445, RULE_loggingClause = 446, 
		RULE_tablespaceClause = 447, RULE_sortNoSortClause = 448, RULE_storageAttributesClause = 449, 
		RULE_storageAttributeClause = 450, RULE_maxSizeClause = 451, RULE_encryptClause = 452, 
		RULE_nextInitialStorageClause = 453, RULE_optimalStorageClause = 454, 
		RULE_minextentsStorageClause = 455, RULE_maxextentsStorageClause = 456, 
		RULE_pctIncreaseStorageClause = 457, RULE_freeListsStorageClause = 458, 
		RULE_freeListGroupsStorageClause = 459, RULE_bufferPoolStorageClause = 460, 
		RULE_flashCacheStorageClause = 461, RULE_cellFlashCacheStorageClause = 462, 
		RULE_computeStatisticsClause = 463, RULE_validateClause = 464, RULE_exceptionsIntoConstraintClause = 465, 
		RULE_byteSizeLiteral = 466, RULE_constraintNameClause = 467, RULE_constraintNullNotNullClause = 468, 
		RULE_constraintUniqueClause = 469, RULE_constraintPrimaryKeyClause = 470, 
		RULE_constraintCheckClause = 471, RULE_conditionInParens = 472, RULE_constraintForeignKeyClause = 473, 
		RULE_constraintForeignKeyRefClause = 474, RULE_onDeleteActionClause = 475, 
		RULE_triggerStatement = 476, RULE_simpleDmlTrigger = 477, RULE_insteadOfDmlTrigger = 478, 
		RULE_compoundDmlTrigger = 479, RULE_systemTrigger = 480, RULE_compoundTriggerBlock = 481, 
		RULE_timingPointSection = 482, RULE_timingPoint = 483, RULE_callStatement = 484, 
		RULE_callStatementWithExpression = 485, RULE_callIntoClause = 486, RULE_indicatorClause = 487, 
		RULE_createTriggerWhenClause = 488, RULE_triggerStatementOnClause = 489, 
		RULE_ddlEventsListClause = 490, RULE_databaseEventsListClause = 491, RULE_ddlEvent = 492, 
		RULE_databaseEvent = 493, RULE_triggerCallTypeClause = 494, RULE_dmlTriggerEventClause = 495, 
		RULE_dmlTriggerEventsList = 496, RULE_dmlTriggerEvent = 497, RULE_ofColumnListClause = 498, 
		RULE_dmlTriggerEventOnClause = 499, RULE_nestedTableClause = 500, RULE_referencingClause = 501, 
		RULE_referencingItem = 502, RULE_forEachRowClause = 503, RULE_returningClause = 504, 
		RULE_onlyClause = 505, RULE_selectStatement = 506, RULE_selectStatementMember = 507, 
		RULE_unionOperator = 508, RULE_withCheckOption = 509, RULE_withReadOnly = 510, 
		RULE_overOrderByClause = 511, RULE_withinGroupOrderByClause = 512, RULE_orderByClause = 513, 
		RULE_orderByList = 514, RULE_orderByListItem = 515, RULE_ascDescSortAtrtributeClause = 516, 
		RULE_orderByNullsAttributeClause = 517, RULE_forUpdateClause = 518, RULE_delimiterOf = 519, 
		RULE_waitOrNowaitClause = 520, RULE_skipLockedClause = 521, RULE_subqueryFactoringClause = 522, 
		RULE_subqueryFactoringClauseItem = 523, RULE_subqueryFactoringColumnsList = 524, 
		RULE_searchClause = 525, RULE_subqueryFactoringSetClause = 526, RULE_cycleClause = 527, 
		RULE_toCycleClause = 528, RULE_defaultCycleClause = 529, RULE_basicSelectStatement = 530, 
		RULE_selectExpressionList = 531, RULE_intoClause = 532, RULE_whereClause = 533, 
		RULE_groupByClause = 534, RULE_groupByClauseExpressionList = 535, RULE_groupByComplexExpressionList = 536, 
		RULE_groupByComplexListExpressionItem = 537, RULE_groupByComplexExpressionListWithParenthesis = 538, 
		RULE_groupByClauseExpressionListItem = 539, RULE_grandTotal = 540, RULE_groupingSetsClause = 541, 
		RULE_groupingSetsList = 542, RULE_groupingSet = 543, RULE_groupingSetItem = 544, 
		RULE_groupingSetItemList = 545, RULE_rollupCubeClause = 546, RULE_groupingExpressionList = 547, 
		RULE_groupingExpressionListItem = 548, RULE_groupingExpressionNestedItem = 549, 
		RULE_connectByClause = 550, RULE_startWithClause = 551, RULE_havingClause = 552, 
		RULE_fromClause = 553, RULE_complexFromClauseItem = 554, RULE_complexFromClauseItemInner = 555, 
		RULE_crossOrNaturalJoin = 556, RULE_normalJoinType = 557, RULE_outerJoinType = 558, 
		RULE_onCondition = 559, RULE_usingCondition = 560, RULE_queryPartitionClause = 561, 
		RULE_fromClauseItemPartitionClause = 562, RULE_fromClauseItem = 563, RULE_jsonTable = 564, 
		RULE_jsonTableOnClause = 565, RULE_jsonTableOnCondition = 566, RULE_jsonExpression = 567, 
		RULE_jsonColumnsClause = 568, RULE_jsonColumnDefinition = 569, RULE_jsonExistsColumn = 570, 
		RULE_jsonExistsOnClause = 571, RULE_jsonExistsOnCondition = 572, RULE_jsonQueryColumn = 573, 
		RULE_jsonQueryWrapperClause = 574, RULE_jsonQueryOnClause = 575, RULE_jsonQueryOnCondition = 576, 
		RULE_jsonValueColumn = 577, RULE_jsonValueOnClause = 578, RULE_jsonValueOnCondition = 579, 
		RULE_jsonNestedPath = 580, RULE_ordinalityColumn = 581, RULE_flashbackAndPivotClauses = 582, 
		RULE_xmlTableItem = 583, RULE_xmlNamespacesClause = 584, RULE_xmlTableOptions = 585, 
		RULE_xmlParsingClause = 586, RULE_xmlTableColumn = 587, RULE_pivotUnpivotClause = 588, 
		RULE_pivotClause = 589, RULE_pivotBody = 590, RULE_pivotForClause = 591, 
		RULE_identifierOrIdentifierList = 592, RULE_pivotUnpivotIdentifierList = 593, 
		RULE_pivotInClause = 594, RULE_pivotInExpressionList = 595, RULE_pivotInExpressionListItem = 596, 
		RULE_pivotAny = 597, RULE_expressionOrExpressionList = 598, RULE_pivotExpressionList = 599, 
		RULE_unpivotClause = 600, RULE_unpivotBody = 601, RULE_unpivotInClause = 602, 
		RULE_unpivotInExpressionList = 603, RULE_unpivotInExpressionListItem = 604, 
		RULE_literalOrLiteralListAlias = 605, RULE_literalOrLiteralList = 606, 
		RULE_literalListWithParenthesis = 607, RULE_periodSpecification = 608, 
		RULE_periodAsOfClause = 609, RULE_periodBetweenClause = 610, RULE_periodForTimeColumn = 611, 
		RULE_flashBackType = 612, RULE_sampleClause = 613, RULE_sampleSeedClause = 614, 
		RULE_sampleClauseValues = 615, RULE_aliasIdentifier = 616, RULE_simpleAliasIdentifier = 617, 
		RULE_insertColumnListClause = 618, RULE_valuesClause = 619, RULE_insertExpressionList = 620, 
		RULE_insertStatement = 621, RULE_singleTableInsertStatement = 622, RULE_multiTableInsertStatement = 623, 
		RULE_multiTableInsertItem = 624, RULE_conditionalInsertStatement = 625, 
		RULE_conditionalInsertWhenEntry = 626, RULE_conditionalInsertThenClause = 627, 
		RULE_conditionalInsertElseClause = 628, RULE_setClause = 629, RULE_setClauseValueClause = 630, 
		RULE_setList = 631, RULE_setColumnListClause = 632, RULE_updateStatement = 633, 
		RULE_deleteStatement = 634, RULE_closeStatement = 635, RULE_fetchStatement = 636, 
		RULE_fetchTargetList = 637, RULE_bulkCollectIntoClause = 638, RULE_fetchLimitClause = 639, 
		RULE_openStatement = 640, RULE_openForClause = 641, RULE_usingList = 642, 
		RULE_usingListItem = 643, RULE_commitWorkStatement = 644, RULE_commitWorkCommentClause = 645, 
		RULE_commitWorkWriteClause = 646, RULE_commitWorkForceClause = 647, RULE_setTransactionStatement = 648, 
		RULE_setTransactionName = 649, RULE_setTransactionReadClause = 650, RULE_isolationLevelClause = 651, 
		RULE_useRollbackSegmentClause = 652, RULE_rollbackWorkStatement = 653, 
		RULE_toSavepointClause = 654, RULE_savepointStatement = 655, RULE_assignmentStatement = 656, 
		RULE_errorLoggingClause = 657, RULE_errorLoggingIntoClause = 658, RULE_errorLoggingTagExpression = 659, 
		RULE_errorLoggingRejectLimit = 660, RULE_mergeStatement = 661, RULE_mergeUpdateOrInsertClause = 662, 
		RULE_mergeUsingClause = 663, RULE_mergeConditionClause = 664, RULE_mergeUpdateClause = 665, 
		RULE_deleteWhereClause = 666, RULE_mergeInsertClause = 667, RULE_executeImmediateStatement = 668, 
		RULE_executeReturningClause = 669, RULE_pipeRowStatement = 670, RULE_raiseStatement = 671, 
		RULE_truncateTableStatement = 672, RULE_truncateTableLogClause = 673, 
		RULE_preservePurgeClause = 674, RULE_truncateClusterStatement = 675, RULE_truncateStatementStorageClause = 676, 
		RULE_lockTableStatement = 677, RULE_lockTableItemList = 678, RULE_lockTableModeClause = 679, 
		RULE_lockTableNowaitClause = 680, RULE_translateExpression = 681, RULE_charExpression = 682, 
		RULE_controlStructure = 683, RULE_forAllStatement = 684, RULE_forAllInClause = 685, 
		RULE_forAllIndicesClause = 686, RULE_forAllIndeciesBoundsClause = 687, 
		RULE_forAllValuesClause = 688, RULE_forAllLowerUpperBoundClause = 689, 
		RULE_forAllSaveExceptionsClause = 690, RULE_ifStatement = 691, RULE_thenBlock = 692, 
		RULE_elseBlock = 693, RULE_elsIfBlock = 694, RULE_ifDirectiveStatement = 695, 
		RULE_thenDirectiveBlock = 696, RULE_elseDirectiveBlock = 697, RULE_elsIfDirectiveBlock = 698, 
		RULE_errorDirectiveBlock = 699, RULE_loopStatement = 700, RULE_loopBlock = 701, 
		RULE_whileStatement = 702, RULE_endLoopClause = 703, RULE_forStatement = 704, 
		RULE_forStatementInClause = 705, RULE_continueStatement = 706, RULE_caseStatement = 707, 
		RULE_simpleCaseStatement = 708, RULE_searchedCaseStatement = 709, RULE_caseStatementWhenEntry = 710, 
		RULE_blockStatement = 711, RULE_blockBody = 712, RULE_endClause = 713, 
		RULE_exceptionBlock = 714, RULE_exceptionHandler = 715, RULE_exceptionNameList = 716, 
		RULE_gotoStatement = 717, RULE_label = 718, RULE_labelBody = 719, RULE_nullStatement = 720, 
		RULE_returnStatement = 721, RULE_procedureCall = 722, RULE_exitStatement = 723, 
		RULE_optionalLabelWhenCondition = 724, RULE_whenCondition = 725, RULE_declarationBlock = 726, 
		RULE_declarationBlockItem = 727, RULE_notNullClause = 728, RULE_nullClause = 729, 
		RULE_defaultValueClause = 730, RULE_cursorReturnClause = 731, RULE_exceptionDeclaration = 732, 
		RULE_typeDeclaration = 733, RULE_delimiterAs = 734, RULE_newType = 735, 
		RULE_recordTypeDeclaration = 736, RULE_recordFieldDeclaration = 737, RULE_objectTypeDeclaration = 738, 
		RULE_objectFieldDeclaration = 739, RULE_varrayTypeDeclaration = 740, RULE_varraySizeLimitClause = 741, 
		RULE_typeDeclararionElementTypeClause = 742, RULE_tableTypeDeclaration = 743, 
		RULE_tableTypeIndexByClause = 744, RULE_refCursorTypeDeclaration = 745, 
		RULE_subtypeDeclaration = 746, RULE_cursorDeclaration = 747, RULE_cursorHeader = 748, 
		RULE_cursorSelect = 749, RULE_declarationPragma = 750, RULE_exceptionInitPragma = 751, 
		RULE_autonomousTransactionPragma = 752, RULE_seriallyReusablePragma = 753, 
		RULE_restrictReferencesPragma = 754, RULE_builtinPragma = 755, RULE_fipsflagPragma = 756, 
		RULE_interfacePragma = 757, RULE_timestampPragma = 758, RULE_newNamesPragma = 759, 
		RULE_variableDeclaration = 760, RULE_variableConstantClause = 761, RULE_dropStatement = 762, 
		RULE_dropTypeStatement = 763, RULE_forceValidateClause = 764, RULE_dropTypeBodyStatement = 765, 
		RULE_dropTriggerStatement = 766, RULE_dropIndexStatement = 767, RULE_alterStatement = 768, 
		RULE_alterTypeStatement = 769, RULE_alterTypeSpecifications = 770, RULE_alterTriggerStatement = 771, 
		RULE_renameClause = 772, RULE_compileClause = 773, RULE_alterIndexStatement = 774, 
		RULE_indexOptions = 775, RULE_deallocateUnusedClause = 776, RULE_keepSizeClause = 777, 
		RULE_allocateExtentClause = 778, RULE_extentOptions = 779, RULE_extentOption = 780, 
		RULE_shrinkClause = 781, RULE_physicalAttribute = 782, RULE_rebuildClause = 783, 
		RULE_rebuildOptions = 784, RULE_keyCompression = 785, RULE_parametersClause = 786, 
		RULE_alterIndexPartitioning = 787, RULE_modifyIndexDefaultAttributes = 788, 
		RULE_modifyIndexAttributes = 789, RULE_addHashIndexPartition = 790, RULE_coalesceIndexPartition = 791, 
		RULE_modifyIndexPartition = 792, RULE_modifyIndexPartitionOptions = 793, 
		RULE_renameIndexPartition = 794, RULE_dropIndexPartition = 795, RULE_splitIndexPartition = 796, 
		RULE_splitIndexPartitionAtClause = 797, RULE_splitIndexPartitionIntoClause = 798, 
		RULE_indexPartitionDescription = 799, RULE_modifyIndexSubpartition = 800, 
		RULE_compileTypeClause = 801, RULE_compilerParametersClause = 802, RULE_replaceTypeClause = 803, 
		RULE_alterMethodSpecifications = 804, RULE_alterMethodSpecification = 805, 
		RULE_alterAttributeDefinition = 806, RULE_addOrModifyAttributeDefinition = 807, 
		RULE_alterTypeDeclaration = 808, RULE_alterTypeDeclarationInParen = 809, 
		RULE_dropAttributeDefinition = 810, RULE_alterCollectionClauses = 811, 
		RULE_dependentHandlingClause = 812, RULE_invalidateHandlingClause = 813, 
		RULE_cascadeHandlingClause = 814, RULE_dependentTypesClause = 815, RULE_includingTableData = 816, 
		RULE_convertToSubstitutable = 817, RULE_forceExceptionsClause = 818, RULE_alterSequenceStatement = 819, 
		RULE_sequenceOption = 820, RULE_identityOption = 821, RULE_sequenceIncrementClause = 822, 
		RULE_sequenceStartWithClause = 823, RULE_sequenceMaxValueClause = 824, 
		RULE_sequenceMinValueClause = 825, RULE_sequenceCycleClause = 826, RULE_sequenceCacheClause = 827, 
		RULE_sequenceOrderClause = 828, RULE_sequenceScaleClause = 829, RULE_sequenceKeepClause = 830, 
		RULE_sequenceShardClause = 831, RULE_sequenceScopeClause = 832, RULE_createTypeStatement = 833, 
		RULE_alterTypeEmbeddedStatement = 834, RULE_completeTypeStatement = 835, 
		RULE_objectTypeStatement = 836, RULE_topLevelObjectType = 837, RULE_subType = 838, 
		RULE_objectTypeDeclarationItems = 839, RULE_objectTypeDeclarationItem = 840, 
		RULE_objectTypeAttributeDeclaration = 841, RULE_varrayTypeStatement = 842, 
		RULE_nestedTableTypeStatement = 843, RULE_oidClause = 844, RULE_createTypeBodyStatement = 845, 
		RULE_objectTypeBodyDeclarationItems = 846, RULE_objectTypeRoutine = 847, 
		RULE_objectTypeMemberStaticRoutine = 848, RULE_objectTypeConstructor = 849, 
		RULE_constructorHeader = 850, RULE_constructorReturnClause = 851, RULE_objectTypeMapOrderFunction = 852, 
		RULE_inheritanceClause = 853, RULE_createSynonymStatement = 854, RULE_createSynonymSharingClause = 855;
	public static readonly string[] ruleNames = {
		"expressionInputFile", "conditionInputFile", "hintInputFile", "dynamicSqlInputFile", 
		"computedColumnExpressionInputFile", "expressionListInputFile", "hintsList", 
		"hintItem", "hintParams", "complexIndexHint", "queryBlock", "sqlInputFile", 
		"sqlStatementBatch", "sqlStatement", "plSqlStatementBatch", "plSqlStatement", 
		"routineSignature", "procedureOrFunctionSignature", "literal", "quoteCharacterStringLiteral", 
		"characterStringLiteral", "unicodeCharacterStringLiteral", "binaryStringLiteral", 
		"booleanLiteral", "dateLiteral", "timestampLiteral", "intervalLiteral", 
		"intervalLiteralFieldClause", "intervalLiteralFieldPrecision", "floatingPointBinaryLiteral", 
		"simpleIdentifierRegularIdentifier", "dotInIdentifier", "identifier", 
		"plainIdentifier", "plainRemoteIdentifier", "multipartPlainIdentifier", 
		"asterisk", "dbLink", "simpleIdentifier", "nestedCollectionSimpleIdentifier", 
		"plainIdentifierAsStringLiteral", "typeReferenceOpaqueFixed", "plainSimpleIdentifierAsStringLiteral", 
		"simpleIdentifierParams", "localSimpleIdentifierWithoutParentheses", "simpleIdentifierWithoutParentheses", 
		"bindParameter", "typeReference", "identifierTimestamp", "identifierTime", 
		"identifierWith", "identifierLocal", "identifierZone", "identifierInterval", 
		"identifierTo", "identifierLong", "identifierRaw", "identifierLongRaw", 
		"identifierDoublePrecision", "identifierCharacter", "identifierNationalCharacter", 
		"identifierNChar", "identifierNVarChar2", "identifierVarChar", "identifierVarChar2", 
		"identifierString", "charIdentifierParams", "typeReferenceTimestampCase", 
		"typeReferenceIntervalCase", "typeReferenceCharCase", "collationSpecClause", 
		"typeReferenceLongAndRawCase", "typeReferenceAttributes", "typeReferenceCharacterSetAttribute", 
		"typeReferenceCharacterSetModifier", "typeReferenceRangeAttribute", "delimiterDoubleDot", 
		"typeReferenceModifierAttribute", "typeReferenceRefCase", "fullExpression", 
		"fullOrCondition", "fullAndCondition", "fullUnaryCondition", "fullAtomicCondition", 
		"delimiterCurrentOf", "delimiterExists", "fullAtomicCondition1", "inPureExpression", 
		"delimiterAny", "delimiterSome", "delimiterAll", "delimiterNot", "delimiterIs", 
		"delimiterIn", "delimiterLParen", "delimiterRParen", "typesComparison", 
		"typeComparisonNames", "pureExpression", "bitwiseLevelExpression", "addLevelExpression", 
		"addLevelOperator", "divideLevelOperator", "unaryExpression", "xmlQuery", 
		"xmlQueryDelegate", "xmlPassingParameterList", "xmlPassingParameterListItem", 
		"xmlCast", "newExpression", "treatExpression", "treatExpressionParameters", 
		"treatExpressionAsClause", "treatExpressionReturnValue", "multisetExpression", 
		"multisetOperator", "dateTimeAtClause", "dateTimeAtLocalClause", "dateTimeAtTimeZoneClause", 
		"keepExpression", "keepClause", "withinExpression", "withinExpressionParams", 
		"overExpression", "overExpressionParams", "overExpressionPartitionClause", 
		"overExpressionWindowingClause", "overExpressionWindowingClauseBetween", 
		"overExpressionWindowingClauseSingle", "overExpressionWindowingClauseItem", 
		"overExpressionWindowingClauseItemExpression", "cursorAttributeExpression", 
		"bulkExpression", "bulkExceptionExpression", "bulkRowCountExpression", 
		"collectionIndex", "powerExpression", "delimiterNull", "delimiterNan", 
		"delimiterInfinite", "delimiterOperandOfIs", "castExpression", "cursorExpression", 
		"caseExpression", "simpleCaseExpression", "simpleCaseWhenEntry", "caseElseEntry", 
		"searchedCaseExpression", "searchedCaseWhenEntry", "priorExpression", 
		"connectByRootExpression", "sysConnectByPathExpression", "trimExpression", 
		"trimExtClause", "decodeExpression", "extractDatetimeExpression", "extractXMLExpression", 
		"xmlTypeInstance", "xpathString", "xmlNamespace", "extractDatetimeFromClause", 
		"delimiterDate", "multiColumnCondition", "overlapsCondition", "comparisonList", 
		"collectionsComparison", "collectionsComparisonSubmultiset", "collectionsComparisonMemberOf", 
		"collectionsComparisonIsASet", "collectionsComparisonIsEmpty", "likeOperator", 
		"escapeClause", "betweenOperator", "betweenAndOperator", "comparisonPairOperator", 
		"flattenedQuery", "asFlattenedQuery", "flattenedQueryNestedTable", "fullExpressionList", 
		"fullExpressionListItem", "expressionList", "multiItemExpressionList", 
		"defaultExpression", "expressionListItem", "xmlaggExpression", "parameterName", 
		"alias", "identifierList", "columnListElementClause", "columnListItem", 
		"complexColumnListItem", "createStatement", "createStatementReplaceClause", 
		"createUserStatement", "createUserIdentificationClause", "createUserPasswordIdentificationClause", 
		"createUserExternalIdentificationClause", "createUserGlobalIdentificationClause", 
		"createUserNoAuthenticationClause", "createUserOption", "defaultCollationOption", 
		"createUserDefaultTablespaceOption", "createUserTemporaryTablespaceOption", 
		"createUserTablespaceQuotaOption", "createUserProfileOption", "createUserPasswordExpireOption", 
		"createUserAccountOption", "createUserEnableEditionsOption", "createUserContainerOption", 
		"createIndexStatement", "clusterIndexClause", "tableIndexClause", "tableIndexExpression", 
		"bitmapJoinIndexClause", "bitmapJoinIndexExpression", "bitmapJoinIndexFromClauseItem", 
		"indexProperties", "globalPartitionedIndex", "localPartitionedIndex", 
		"indexOnSimplePartitionedTableClause", "indexOnSimplePartitionedTableClauseItem", 
		"indexOnHashPartitionedTable", "indexOnHashPartitionedTableClauseItem", 
		"indexOnCompPartitionedTable", "indexOnCompPartitionedTableClauseItem", 
		"indexSubpartitionClause", "indexSubpartitionClauseItem", "indexAttribute", 
		"visibilityClause", "partialIndexClause", "indexTypeClause", "localIndexClause", 
		"localIndexClauseItem", "unstructuredIndexParametersClause", "simpleTablespaceClause", 
		"createSequenceStatement", "createSequenceSharingClause", "createEditionableBatchWideStatement", 
		"editionOptionClause", "packageStatement", "packageBodyStatement", "packageDeclarationBlock", 
		"procedureStatement", "procedureSignature", "procedureImplementation", 
		"procedureHeader", "routineBody", "routineBodyAsIsClause", "invokerRightsClause", 
		"procedureCallSpecClause", "javaDeclarationClause", "cDeclarationClause", 
		"cDeclarationNameClause", "cDeclarationLibraryClause", "cDeclarationAgentClause", 
		"cDeclarationContextClause", "cDeclarationParametersClause", "argumentList", 
		"argument", "argumentNoCopyClause", "argumentModeClause", "argumentDefaultValue", 
		"functionStatement", "functionSignature", "functionImplementation", "functionHeader", 
		"functionReturnClause", "functionDeterministicClause", "functionParallelEnableClause", 
		"parallelOnPartitionOption", "parallelOnPartitionBy", "columnListItemInParen", 
		"parallelOnPartitionStreamingClause", "parallelOnPartitionStreamingClauseBy", 
		"resultCacheClause", "resultCacheReliesOnClause", "functionAggregateClause", 
		"functionPipelinedClause", "createTableStatement", "tableHeader", "createObjectTableStatement", 
		"memOptimizeClause", "parentClause", "oidIndexClause", "oidIndexClauseList", 
		"objectIdentifierIsClause", "objectTableOfClause", "createRelationTableStatement", 
		"createXMLTypeTableStatement", "tablePropertiesClause", "columnProperties", 
		"xmlTypeColumnProperties", "xmlTypeStorageClause", "xmlTypeStoreAsClause", 
		"xmlTypeStoreAsObjectRelationalClause", "xmlTypeStoreAsLobClause", "xmlTypeStoreAllClause", 
		"objectTypeColProperties", "varrayColProperties", "nestedTableColProperties", 
		"nestedTableObjectProperties", "returnAsClause", "objectPropertiesListClause", 
		"objectProperties", "storeAsClause", "nestedItemClause", "asSubqueryClause", 
		"rowMovementClause", "enableDisableConstraintClause", "keepDropIndexClause", 
		"cascadeClause", "monitoringClause", "rowdependenciesClause", "parallelClause", 
		"partitioningDefinitionClause", "compositePartitioning", "subPartitionByHash", 
		"subpartitionsStoreInClause", "subPartitionByList", "subPartitionTemplate", 
		"subPartitionDefinitionListClause", "subPartitionDefinitionClause", "partitionByListClause", 
		"partitionByHashClause", "partitionsSimpleClause", "partitionSimpleListClause", 
		"partitionSimpleClause", "partitionByRangeClause", "partitionDefinitionListClause", 
		"partitionDefinitionClause", "tablePartitionDescription", "partitionLevelSubpartitioningClause", 
		"subpartitionSpecList", "subpartitionSpec", "partitioningStorageClause", 
		"listValuesClause", "subpartitionsSimpleClause", "partitionsStoreInClause", 
		"tablespaceListClause", "varrayStorageClause", "substitutableColumnClause", 
		"notSubstitutableClause", "elementIsOfTypeClause", "delimiterOnly", "storeAsLobClause", 
		"lOBStorageClause", "lOBPropertiesListClause", "lobPropertiesListElementClause", 
		"lobStoreAsClause", "rangeValuesClause", "valuesLessThanListClause", "valuesLessThanListItem", 
		"partitionByRangeColumnList", "physicalPropertiesClause", "physicalPropertiesClusterClause", 
		"physicalPropertiesOrganizationClause", "deferredSegmentCreationClause", 
		"heapOrganizedTableClauseElement", "indexOrganizedTableClauseElement", 
		"indexOrganizedOverflowClause", "overflowClause", "includingOverflowClause", 
		"pCTThresholdClause", "mappingTableClause", "tableCompressionClause", 
		"indexCompressionClause", "compressionOperations", "segmentAttributesClause", 
		"segmentAttributesClauseElement", "onCommitClause", "relationPropertiesListClause", 
		"relationPropertiesClause", "supplementalLoggingPropsClause", "supplementalLogGrpClause", 
		"supplementalIdKeyClause", "supplementalIdKeyClauseItem", "columnDeclarationClause", 
		"columnIdentityClause", "columnDefaultValueClause", "virtualColumnDefinition", 
		"computedColumnExpression", "tableRefConstraintClause", "tableRefWithRowidClause", 
		"tableRefScopeForClause", "columnRefConstraintClause", "withRowidClause", 
		"scopeIsClause", "foreignKeyClause", "tableRefForeignKeyClause", "materializedViewStatement", 
		"materializedViewHeader", "objectMaterializedViewClause", "materializedViewPrebuiltTableClause", 
		"materializedViewPhysicalClusterProperties", "materializedViewPhysicalClusterColumnList", 
		"materializedViewProperties", "materializedViewPropertiesCacheClause", 
		"materializedViewPropertiesBuildClause", "materializedViewUsingIndexClause", 
		"materializedViewUsingIndexAttributesListClause", "materializedViewRefreshClause", 
		"materializedViewRefreshOptions", "materializedViewRefreshType", "materializedViewRefreshTrigger", 
		"materializedViewRefreshSchedule", "materializedViewRefreshRowIdentificationClause", 
		"materializedViewRefreshRollbackSegmentClause", "materializedViewRefreshUsingConstraints", 
		"evaluationEditionClause", "materializedViewQueryComputationClause", "materializedViewQueryRewriteClause", 
		"unusableEditionsBeforeClause", "unusableEditionsBeginningWithClause", 
		"viewStatement", "viewHeader", "xmlTypeViewClause", "xmlSchemaSpec", "xmlSchemaClause", 
		"xmlSchemaElementClause", "xmlSchemaSpecNonschemaClause", "xmlSchemaSpecAnyschemaClause", 
		"objectViewClause", "underClause", "withObjectIdentifierClause", "parenthesizedExpressionList", 
		"forceNoForceClause", "viewBody", "subqueryRestrictionClause", "viewAliasOrConstraintList", 
		"viewAliasOrTableConstraint", "viewAlias", "attributeOrConstraintList", 
		"attributeOrTableConstraint", "attributeConstraintClause", "tableConstraintClause", 
		"columnListInParenElementClause", "columnConstraintClause", "constraintStateClause", 
		"deferrableConstraintClause", "initiallyConstraintClause", "enableClause", 
		"relyConstraintClause", "usingIndexConstraintClause", "usingIndexAttributesListConstraintClause", 
		"indexCompression", "prefixCompression", "loggingClause", "tablespaceClause", 
		"sortNoSortClause", "storageAttributesClause", "storageAttributeClause", 
		"maxSizeClause", "encryptClause", "nextInitialStorageClause", "optimalStorageClause", 
		"minextentsStorageClause", "maxextentsStorageClause", "pctIncreaseStorageClause", 
		"freeListsStorageClause", "freeListGroupsStorageClause", "bufferPoolStorageClause", 
		"flashCacheStorageClause", "cellFlashCacheStorageClause", "computeStatisticsClause", 
		"validateClause", "exceptionsIntoConstraintClause", "byteSizeLiteral", 
		"constraintNameClause", "constraintNullNotNullClause", "constraintUniqueClause", 
		"constraintPrimaryKeyClause", "constraintCheckClause", "conditionInParens", 
		"constraintForeignKeyClause", "constraintForeignKeyRefClause", "onDeleteActionClause", 
		"triggerStatement", "simpleDmlTrigger", "insteadOfDmlTrigger", "compoundDmlTrigger", 
		"systemTrigger", "compoundTriggerBlock", "timingPointSection", "timingPoint", 
		"callStatement", "callStatementWithExpression", "callIntoClause", "indicatorClause", 
		"createTriggerWhenClause", "triggerStatementOnClause", "ddlEventsListClause", 
		"databaseEventsListClause", "ddlEvent", "databaseEvent", "triggerCallTypeClause", 
		"dmlTriggerEventClause", "dmlTriggerEventsList", "dmlTriggerEvent", "ofColumnListClause", 
		"dmlTriggerEventOnClause", "nestedTableClause", "referencingClause", "referencingItem", 
		"forEachRowClause", "returningClause", "onlyClause", "selectStatement", 
		"selectStatementMember", "unionOperator", "withCheckOption", "withReadOnly", 
		"overOrderByClause", "withinGroupOrderByClause", "orderByClause", "orderByList", 
		"orderByListItem", "ascDescSortAtrtributeClause", "orderByNullsAttributeClause", 
		"forUpdateClause", "delimiterOf", "waitOrNowaitClause", "skipLockedClause", 
		"subqueryFactoringClause", "subqueryFactoringClauseItem", "subqueryFactoringColumnsList", 
		"searchClause", "subqueryFactoringSetClause", "cycleClause", "toCycleClause", 
		"defaultCycleClause", "basicSelectStatement", "selectExpressionList", 
		"intoClause", "whereClause", "groupByClause", "groupByClauseExpressionList", 
		"groupByComplexExpressionList", "groupByComplexListExpressionItem", "groupByComplexExpressionListWithParenthesis", 
		"groupByClauseExpressionListItem", "grandTotal", "groupingSetsClause", 
		"groupingSetsList", "groupingSet", "groupingSetItem", "groupingSetItemList", 
		"rollupCubeClause", "groupingExpressionList", "groupingExpressionListItem", 
		"groupingExpressionNestedItem", "connectByClause", "startWithClause", 
		"havingClause", "fromClause", "complexFromClauseItem", "complexFromClauseItemInner", 
		"crossOrNaturalJoin", "normalJoinType", "outerJoinType", "onCondition", 
		"usingCondition", "queryPartitionClause", "fromClauseItemPartitionClause", 
		"fromClauseItem", "jsonTable", "jsonTableOnClause", "jsonTableOnCondition", 
		"jsonExpression", "jsonColumnsClause", "jsonColumnDefinition", "jsonExistsColumn", 
		"jsonExistsOnClause", "jsonExistsOnCondition", "jsonQueryColumn", "jsonQueryWrapperClause", 
		"jsonQueryOnClause", "jsonQueryOnCondition", "jsonValueColumn", "jsonValueOnClause", 
		"jsonValueOnCondition", "jsonNestedPath", "ordinalityColumn", "flashbackAndPivotClauses", 
		"xmlTableItem", "xmlNamespacesClause", "xmlTableOptions", "xmlParsingClause", 
		"xmlTableColumn", "pivotUnpivotClause", "pivotClause", "pivotBody", "pivotForClause", 
		"identifierOrIdentifierList", "pivotUnpivotIdentifierList", "pivotInClause", 
		"pivotInExpressionList", "pivotInExpressionListItem", "pivotAny", "expressionOrExpressionList", 
		"pivotExpressionList", "unpivotClause", "unpivotBody", "unpivotInClause", 
		"unpivotInExpressionList", "unpivotInExpressionListItem", "literalOrLiteralListAlias", 
		"literalOrLiteralList", "literalListWithParenthesis", "periodSpecification", 
		"periodAsOfClause", "periodBetweenClause", "periodForTimeColumn", "flashBackType", 
		"sampleClause", "sampleSeedClause", "sampleClauseValues", "aliasIdentifier", 
		"simpleAliasIdentifier", "insertColumnListClause", "valuesClause", "insertExpressionList", 
		"insertStatement", "singleTableInsertStatement", "multiTableInsertStatement", 
		"multiTableInsertItem", "conditionalInsertStatement", "conditionalInsertWhenEntry", 
		"conditionalInsertThenClause", "conditionalInsertElseClause", "setClause", 
		"setClauseValueClause", "setList", "setColumnListClause", "updateStatement", 
		"deleteStatement", "closeStatement", "fetchStatement", "fetchTargetList", 
		"bulkCollectIntoClause", "fetchLimitClause", "openStatement", "openForClause", 
		"usingList", "usingListItem", "commitWorkStatement", "commitWorkCommentClause", 
		"commitWorkWriteClause", "commitWorkForceClause", "setTransactionStatement", 
		"setTransactionName", "setTransactionReadClause", "isolationLevelClause", 
		"useRollbackSegmentClause", "rollbackWorkStatement", "toSavepointClause", 
		"savepointStatement", "assignmentStatement", "errorLoggingClause", "errorLoggingIntoClause", 
		"errorLoggingTagExpression", "errorLoggingRejectLimit", "mergeStatement", 
		"mergeUpdateOrInsertClause", "mergeUsingClause", "mergeConditionClause", 
		"mergeUpdateClause", "deleteWhereClause", "mergeInsertClause", "executeImmediateStatement", 
		"executeReturningClause", "pipeRowStatement", "raiseStatement", "truncateTableStatement", 
		"truncateTableLogClause", "preservePurgeClause", "truncateClusterStatement", 
		"truncateStatementStorageClause", "lockTableStatement", "lockTableItemList", 
		"lockTableModeClause", "lockTableNowaitClause", "translateExpression", 
		"charExpression", "controlStructure", "forAllStatement", "forAllInClause", 
		"forAllIndicesClause", "forAllIndeciesBoundsClause", "forAllValuesClause", 
		"forAllLowerUpperBoundClause", "forAllSaveExceptionsClause", "ifStatement", 
		"thenBlock", "elseBlock", "elsIfBlock", "ifDirectiveStatement", "thenDirectiveBlock", 
		"elseDirectiveBlock", "elsIfDirectiveBlock", "errorDirectiveBlock", "loopStatement", 
		"loopBlock", "whileStatement", "endLoopClause", "forStatement", "forStatementInClause", 
		"continueStatement", "caseStatement", "simpleCaseStatement", "searchedCaseStatement", 
		"caseStatementWhenEntry", "blockStatement", "blockBody", "endClause", 
		"exceptionBlock", "exceptionHandler", "exceptionNameList", "gotoStatement", 
		"label", "labelBody", "nullStatement", "returnStatement", "procedureCall", 
		"exitStatement", "optionalLabelWhenCondition", "whenCondition", "declarationBlock", 
		"declarationBlockItem", "notNullClause", "nullClause", "defaultValueClause", 
		"cursorReturnClause", "exceptionDeclaration", "typeDeclaration", "delimiterAs", 
		"newType", "recordTypeDeclaration", "recordFieldDeclaration", "objectTypeDeclaration", 
		"objectFieldDeclaration", "varrayTypeDeclaration", "varraySizeLimitClause", 
		"typeDeclararionElementTypeClause", "tableTypeDeclaration", "tableTypeIndexByClause", 
		"refCursorTypeDeclaration", "subtypeDeclaration", "cursorDeclaration", 
		"cursorHeader", "cursorSelect", "declarationPragma", "exceptionInitPragma", 
		"autonomousTransactionPragma", "seriallyReusablePragma", "restrictReferencesPragma", 
		"builtinPragma", "fipsflagPragma", "interfacePragma", "timestampPragma", 
		"newNamesPragma", "variableDeclaration", "variableConstantClause", "dropStatement", 
		"dropTypeStatement", "forceValidateClause", "dropTypeBodyStatement", "dropTriggerStatement", 
		"dropIndexStatement", "alterStatement", "alterTypeStatement", "alterTypeSpecifications", 
		"alterTriggerStatement", "renameClause", "compileClause", "alterIndexStatement", 
		"indexOptions", "deallocateUnusedClause", "keepSizeClause", "allocateExtentClause", 
		"extentOptions", "extentOption", "shrinkClause", "physicalAttribute", 
		"rebuildClause", "rebuildOptions", "keyCompression", "parametersClause", 
		"alterIndexPartitioning", "modifyIndexDefaultAttributes", "modifyIndexAttributes", 
		"addHashIndexPartition", "coalesceIndexPartition", "modifyIndexPartition", 
		"modifyIndexPartitionOptions", "renameIndexPartition", "dropIndexPartition", 
		"splitIndexPartition", "splitIndexPartitionAtClause", "splitIndexPartitionIntoClause", 
		"indexPartitionDescription", "modifyIndexSubpartition", "compileTypeClause", 
		"compilerParametersClause", "replaceTypeClause", "alterMethodSpecifications", 
		"alterMethodSpecification", "alterAttributeDefinition", "addOrModifyAttributeDefinition", 
		"alterTypeDeclaration", "alterTypeDeclarationInParen", "dropAttributeDefinition", 
		"alterCollectionClauses", "dependentHandlingClause", "invalidateHandlingClause", 
		"cascadeHandlingClause", "dependentTypesClause", "includingTableData", 
		"convertToSubstitutable", "forceExceptionsClause", "alterSequenceStatement", 
		"sequenceOption", "identityOption", "sequenceIncrementClause", "sequenceStartWithClause", 
		"sequenceMaxValueClause", "sequenceMinValueClause", "sequenceCycleClause", 
		"sequenceCacheClause", "sequenceOrderClause", "sequenceScaleClause", "sequenceKeepClause", 
		"sequenceShardClause", "sequenceScopeClause", "createTypeStatement", "alterTypeEmbeddedStatement", 
		"completeTypeStatement", "objectTypeStatement", "topLevelObjectType", 
		"subType", "objectTypeDeclarationItems", "objectTypeDeclarationItem", 
		"objectTypeAttributeDeclaration", "varrayTypeStatement", "nestedTableTypeStatement", 
		"oidClause", "createTypeBodyStatement", "objectTypeBodyDeclarationItems", 
		"objectTypeRoutine", "objectTypeMemberStaticRoutine", "objectTypeConstructor", 
		"constructorHeader", "constructorReturnClause", "objectTypeMapOrderFunction", 
		"inheritanceClause", "createSynonymStatement", "createSynonymSharingClause"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, "':='", "'=>'", "'||'", "'**'", "'..'", 
		null, null, null, "';'", "'/'", "'\\'", "'>'", "'<'", "'='", "'%'", "'@'", 
		"'+'", "'-'", "'#'", "'?'", null, "'*'", "'.'", "'^'", "'~'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "A_", "ACCOUNT", "ADD", "ADVANCED", "AFTER", "AGENT", "AGGREGATE", 
		"ALL", "ALLOCATE", "ALLOW", "ALTER", "ALWAYS", "ANALYZE", "AND", "ANY", 
		"ANYSCHEMA", "ARCHIVE", "ARRAY", "AS", "ASC", "ASSOCIATE", "AT", "ATTRIBUTE", 
		"ATTRIBUTES", "AUDIT", "AUTHENTICATION", "AUTHID", "AUTO", "AUTONOMOUS_TRANSACTION", 
		"BASIC", "BASICFILE", "BATCH", "BEFORE", "BEGIN", "BEGINNING", "BETWEEN", 
		"BINARY", "BITMAP", "BLOCK", "BODY", "BOTH", "BREADTH", "BUFFER_POOL", 
		"BUILD", "BUILTIN", "BULK", "BULK_EXCEPTIONS", "BULK_ROWCOUNT", "BY", 
		"BYTE", "C_", "CACHE", "CALL", "CASCADE", "CASE", "CAST", "CELL_FLASH_CACHE", 
		"CHAR", "CHAR_CS", "CHARACTER", "CHARSET", "CHECK", "CHR", "CHUNK", "CLOB", 
		"CLOSE", "CLUSTER", "COALESCE", "COLLATE", "COLLATION", "COLLECT", "COLUMN", 
		"COLUMN_VALUE", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "COMPACT", 
		"COMPILE", "COMPLETE", "COMPOUND", "COMPRESS", "COMPUTATION", "COMPUTE", 
		"CONDITIONAL", "CONNECT", "CONNECT_BY_ROOT", "CONSTANT", "CONSTRAINT", 
		"CONSTRAINTS", "CONSTRUCTOR", "CONTAINER", "CONTENT", "CONTEXT", "CONTINUE", 
		"CONVERT", "COUNT", "CREATE", "CREATION", "CROSS", "CUBE", "CURRENT", 
		"CURRENT_USER", "CURSOR", "CYCLE", "DATA", "DATABASE", "DATAFILE", "DATE", 
		"DAY", "DBTIMEZONE", "DDL", "DEALLOCATE", "DEBUG", "DECLARE", "DECODE", 
		"DECRYPT", "DEDUPLICATE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DEFINER", 
		"DELETE", "DEMAND", "DENSE_RANK", "DEPTH", "DESC", "DETERMINISTIC", "DIRECT_LOAD", 
		"DIRECTIVE_ELSE", "DIRECTIVE_ELSIF", "DIRECTIVE_END", "DIRECTIVE_ERROR", 
		"DIRECTIVE_IF", "DIRECTIVE_THEN", "DISABLE", "DISALLOW", "DISASSOCIATE", 
		"DISTINCT", "DOUBLE", "DROP", "DUPLICATED", "EACH", "EDITION", "EDITIONABLE", 
		"EDITIONING", "EDITIONS", "ELEMENT", "ELSE", "ELSIF", "EMPTY_KEYWORD", 
		"ENABLE", "ENCRYPT", "END", "ENFORCED", "ERROR_CODE", "ERROR_INDEX", "ERROR", 
		"ERRORS", "ESCAPE", "EVALUATE", "EXCEPT", "EXCEPTION", "EXCEPTION_INIT", 
		"EXCEPTIONS", "EXCLUDE", "EXCLUSIVE", "EXECUTE", "EXISTS", "EXIT", "EXPIRE", 
		"EXTEND", "EXTENDED", "EXTENT", "EXTERNALLY", "EXTRACT", "EXTRACTVALUE", 
		"FALSE", "FAST", "FETCH", "FILESYSTEM_LIKE_LOGGING", "FINAL", "FIPSFLAG", 
		"FIRST", "FIRST_ROWS", "FIXED", "FOLLOWING", "FOR", "FORALL", "FORCE", 
		"FOREIGN", "FORMAT", "FOUND", "FLASH_CACHE", "FREELIST", "FREELISTS", 
		"FREEPOOLS", "FROM", "FULL", "FUNCTION", "GENERATED", "GLOBAL", "GLOBALLY", 
		"GOTO", "GRANT", "GROUP", "GROUPING", "GROUPS", "HASH", "HAVING", "HEAP", 
		"HIGH", "HOUR", "ID", "IDENTIFIED", "IDENTIFIER", "IDENTITY", "IF", "IMMEDIATE", 
		"IN", "INCLUDE", "INCLUDING", "INCREMENT", "INDEX", "INDEXING", "INDEXTYPE", 
		"INDICATOR", "INDICES", "INFINITE", "INITIAL", "INITIALLY", "INITRANS", 
		"INNER", "INSERT", "INSTANCE", "INSTANTIABLE", "INSTEAD", "INTERFACE", 
		"INTERSECT", "INTERVAL", "INTO", "INVALIDATE", "INVALIDATION", "INVISIBLE", 
		"IS", "ISOLATION", "ISOPEN", "JAVA", "JOIN", "JSON", "JSON_TABLE", "KEEP", 
		"KEEP_DUPLICATES", "KEY", "LANGUAGE", "LAST", "LEADING", "LEFT", "LESS", 
		"LEVEL", "LEVELS", "LIBRARY", "LIKE", "LIKE2", "LIKE4", "LIKEC", "LIMIT", 
		"LIST", "LOB", "LOBS", "LOCAL", "LOCATOR", "LOCK", "LOCKED", "LOCKING", 
		"LOG", "LOGGING", "LOGOFF", "LOGON", "LONG", "LOOP", "LOW", "MAP", "MAPPING", 
		"MASTER", "MATCHED", "MATERIALIZED", "MAX", "MAXEXTENTS", "MAXSIZE", "MAXTRANS", 
		"MAXVALUE", "MEDIUM", "MEMBER", "MEMOPTIMIZE", "MERGE", "METADATA", "MIN", 
		"MINEXTENTS", "MINUS", "MINUTE", "MINVALUE", "MOD", "MODE", "MODIFY", 
		"MONITORING", "MONTH", "MOVEMENT", "MULTISET", "NAME", "NAN", "NATIONAL", 
		"NATURAL", "NCHAR", "NCHAR_CS", "NCHR", "NESTED", "NEVER", "NEW", "NEW_NAMES", 
		"NEXT", "NO", "NOAUDIT", "NOCACHE", "NOCOMPRESS", "NOCOPY", "NOCYCLE", 
		"NOEXTEND", "NOKEEP", "NOLOGGING", "NOMAPPING", "NOMAXVALUE", "NOMINVALUE", 
		"NOMONITORING", "NOORDER", "NONE", "NONEDITIONABLE", "NONSCHEMA", "NOPARALLEL", 
		"NORELY", "NOREVERSE", "NOROWDEPENDENCIES", "NOSCALE", "NOSHARD", "NOSORT", 
		"NOT", "NOTFOUND", "NOVALIDATE", "NOWAIT", "NULL", "NULLS", "NVARCHAR2", 
		"OBJECT", "OF", "OID", "OIDINDEX", "OLD", "ON", "ONLY", "ONLINE", "OPAQUE", 
		"OPEN", "OPERATIONS", "OPTIMAL", "OPTION", "OR", "ORDER", "ORDINALITY", 
		"ORGANIZATION", "OUT", "OUTER", "OVER", "OVERFLOW", "OVERLAPS", "OVERRIDING", 
		"PACKAGE", "PARALLEL", "PARALLEL_ENABLE", "PARAMETERS", "PARENT", "PARTIAL", 
		"PARTITION", "PARTITIONS", "PASSING", "PASSWORD", "PATH", "PCTFREE", "PCTINCREASE", 
		"PCTTHRESHOLD", "PCTUSED", "PCTVERSION", "PERCENTILE_DISC", "PERIOD", 
		"PIPE", "PIPELINED", "PIVOT", "POLYMORPHIC", "PRAGMA", "PREBUILT", "PRECEDING", 
		"PRECISION", "PRESERVE", "PRIMARY", "PRIOR", "PRIVATE", "PROCEDURE", "PROFILE", 
		"PUBLIC", "PURGE", "QUERY", "QUOTA", "RAISE", "RAISE_APPLICATION_ERROR", 
		"RANGE", "RAW", "READ", "READS", "REBUILD", "RECORD", "RECYCLE", "REDUCED", 
		"REF", "REFERENCES", "REFERENCING", "REFRESH", "REJECT", "RELATIONAL", 
		"RELIES_ON", "RELY", "RENAME", "REPLACE", "RESTRICT_REFERENCES", "RESULT", 
		"RESULT_CACHE", "RETENTION", "RETURN", "RETURNING", "REUSE", "REVERSE", 
		"REVOKE", "REWRITE", "RIGHT", "ROLLBACK", "ROLLUP", "ROW", "ROWCOUNT", 
		"ROWDEPENDENCIES", "ROWID", "ROWS", "ROWTYPE", "SALT", "SAMPLE", "SAVE", 
		"SAVEPOINT", "SCALE", "SCHEMA", "SCN", "SCOPE", "SEARCH", "SECOND", "SECUREFILE", 
		"SEED", "SEGMENT", "SELECT", "SELF", "SEQUENCE", "SERIALIZABLE", "SERIALLY_REUSABLE", 
		"SERVERERROR", "SESSION", "SESSIONTIMEZONE", "SET", "SETS", "SETTINGS", 
		"SHARE", "SHRINK", "SHUTDOWN", "SIBLINGS", "SIZE", "SKIP_", "SOME", "SORT", 
		"SPACE", "SPECIFICATION", "SPLIT", "START", "STARTUP", "STATEMENT", "STATIC", 
		"STATISTICS", "STORAGE", "STORE", "STRING", "SHARD", "SHARDED", "SHARING", 
		"SUBMULTISET", "SUBPARTITION", "SUBPARTITIONS", "SUBSTITUTABLE", "SUBTYPE", 
		"SUPPLEMENTAL", "SUSPEND", "SYNONYM", "SYS_CONNECT_BY_PATH", "SYSTEM", 
		"TABLE", "TABLES", "TABLESPACE", "TEMPLATE", "TEMPORARY", "THAN", "THE", 
		"THEN", "TIME", "TIMESTAMP", "TIMEZONE_ABBR", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", 
		"TIMEZONE_REGION", "TO", "TRAILING", "TRANSACTION", "TRANSLATE", "TREAT", 
		"TRIGGER", "TRIM", "TRUE", "TRUNCATE", "TRUSTED", "TYPE", "UNBOUNDED", 
		"UNCONDITIONAL", "UNDER", "UNION", "UNIQUE", "UNLIMITED", "UNLOCK", "UNPIVOT", 
		"UNUSABLE", "UNUSED", "UPDATE", "USABLE", "USAGE", "USE", "USER", "USING", 
		"VALIDATE", "VALUE", "VALUES", "VARCHAR", "VARCHAR2", "VARRAY", "VARRAYS", 
		"VARYING", "VERSIONS", "VIEW", "VIRTUAL", "VISIBLE", "WAIT", "WHEN", "WHERE", 
		"WHILE", "WITH", "WITHIN", "WITHOUT", "WORK", "WRAPPED", "WRAPPER", "WRITE", 
		"XML", "XMLAGG", "XMLCAST", "XMLNAMESPACES", "XMLQUERY", "XMLSCHEMA", 
		"XMLTABLE", "XMLTYPE", "YEAR", "ZONE", "INTEGER_LITERAL", "ASSIGN_OPERATOR", 
		"ASSOC_OPERATOR", "CONCAT_OPERATOR", "POWER_OPERATOR", "DOUBLE_DOT_OPERATOR", 
		"LPAREN", "RPAREN", "COMMA", "SEMI", "FSLASH", "BSLASH", "GREATER_THAN", 
		"LESS_THAN", "EQUAL_SIGN", "PERCENT_SIGN", "AT_SIGN", "PLUS_SIGN", "MINUS_SIGN", 
		"POUND_SIGN", "QUESTION_MARK", "BANG", "ASTERISK", "DOT", "CARET", "TILDE", 
		"FLOATING_POINT_LITERAL", "FLOATING_POINT_BINARY_LITERAL", "UNICODE_CHARACTER_STRING_LITERAL", 
		"BINARY_STRING_LITERAL", "CHARACTER_STRING_LITERAL", "BYTE_SIZE_LITERAL", 
		"MONEY_LITERAL", "REGULAR_IDENTIFIER", "QUOTED_IDENTIFIER", "WHITESPACES", 
		"WHITESPACE", "LINE_COMMENT", "COMMENTS", "QUOTE_CHARACTER_STRING_LITERAL", 
		"INVALID_CHAR"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "OracleAntlrParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static OracleAntlrParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public OracleAntlrParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public OracleAntlrParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ExpressionInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public ExpressionInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExpressionInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExpressionInputFile(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionInputFileContext expressionInputFile() {
		ExpressionInputFileContext _localctx = new ExpressionInputFileContext(Context, State);
		EnterRule(_localctx, 0, RULE_expressionInputFile);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1712;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public ConditionInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConditionInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConditionInputFile(this);
		}
	}

	[RuleVersion(0)]
	public ConditionInputFileContext conditionInputFile() {
		ConditionInputFileContext _localctx = new ConditionInputFileContext(Context, State);
		EnterRule(_localctx, 2, RULE_conditionInputFile);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1714;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HintInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public HintsListContext hintsList() {
			return GetRuleContext<HintsListContext>(0);
		}
		public HintInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hintInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterHintInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitHintInputFile(this);
		}
	}

	[RuleVersion(0)]
	public HintInputFileContext hintInputFile() {
		HintInputFileContext _localctx = new HintInputFileContext(Context, State);
		EnterRule(_localctx, 4, RULE_hintInputFile);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1716;
			hintsList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DynamicSqlInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SqlStatementContext sqlStatement() {
			return GetRuleContext<SqlStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PlSqlStatementContext plSqlStatement() {
			return GetRuleContext<PlSqlStatementContext>(0);
		}
		public DynamicSqlInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dynamicSqlInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDynamicSqlInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDynamicSqlInputFile(this);
		}
	}

	[RuleVersion(0)]
	public DynamicSqlInputFileContext dynamicSqlInputFile() {
		DynamicSqlInputFileContext _localctx = new DynamicSqlInputFileContext(Context, State);
		EnterRule(_localctx, 6, RULE_dynamicSqlInputFile);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1720;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,0,Context) ) {
			case 1:
				{
				State = 1718;
				sqlStatement();
				}
				break;
			case 2:
				{
				State = 1719;
				plSqlStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComputedColumnExpressionInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ComputedColumnExpressionContext computedColumnExpression() {
			return GetRuleContext<ComputedColumnExpressionContext>(0);
		}
		public ComputedColumnExpressionInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_computedColumnExpressionInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterComputedColumnExpressionInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitComputedColumnExpressionInputFile(this);
		}
	}

	[RuleVersion(0)]
	public ComputedColumnExpressionInputFileContext computedColumnExpressionInputFile() {
		ComputedColumnExpressionInputFileContext _localctx = new ComputedColumnExpressionInputFileContext(Context, State);
		EnterRule(_localctx, 8, RULE_computedColumnExpressionInputFile);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1722;
			computedColumnExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionListInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionListContext fullExpressionList() {
			return GetRuleContext<FullExpressionListContext>(0);
		}
		public ExpressionListInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionListInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExpressionListInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExpressionListInputFile(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListInputFileContext expressionListInputFile() {
		ExpressionListInputFileContext _localctx = new ExpressionListInputFileContext(Context, State);
		EnterRule(_localctx, 10, RULE_expressionListInputFile);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1724;
			fullExpressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HintsListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public HintItemContext[] hintItem() {
			return GetRuleContexts<HintItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public HintItemContext hintItem(int i) {
			return GetRuleContext<HintItemContext>(i);
		}
		public HintsListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hintsList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterHintsList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitHintsList(this);
		}
	}

	[RuleVersion(0)]
	public HintsListContext hintsList() {
		HintsListContext _localctx = new HintsListContext(Context, State);
		EnterRule(_localctx, 12, RULE_hintsList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1729;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEX - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				{
				State = 1726;
				hintItem();
				}
				}
				State = 1731;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HintItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIRST_ROWS() { return GetToken(OracleAntlrParser.FIRST_ROWS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FULL() { return GetToken(OracleAntlrParser.FULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(OracleAntlrParser.HASH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MERGE() { return GetToken(OracleAntlrParser.MERGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARALLEL() { return GetToken(OracleAntlrParser.PARALLEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CACHE() { return GetToken(OracleAntlrParser.CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCACHE() { return GetToken(OracleAntlrParser.NOCACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public HintParamsContext hintParams() {
			return GetRuleContext<HintParamsContext>(0);
		}
		public HintItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hintItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterHintItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitHintItem(this);
		}
	}

	[RuleVersion(0)]
	public HintItemContext hintItem() {
		HintItemContext _localctx = new HintItemContext(Context, State);
		EnterRule(_localctx, 14, RULE_hintItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1741;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
			case 1:
				{
				State = 1732;
				Match(FIRST_ROWS);
				}
				break;
			case 2:
				{
				State = 1733;
				Match(INDEX);
				}
				break;
			case 3:
				{
				State = 1734;
				Match(FULL);
				}
				break;
			case 4:
				{
				State = 1735;
				Match(HASH);
				}
				break;
			case 5:
				{
				State = 1736;
				Match(MERGE);
				}
				break;
			case 6:
				{
				State = 1737;
				Match(PARALLEL);
				}
				break;
			case 7:
				{
				State = 1738;
				Match(CACHE);
				}
				break;
			case 8:
				{
				State = 1739;
				Match(NOCACHE);
				}
				break;
			case 9:
				{
				State = 1740;
				simpleIdentifier();
				}
				break;
			}
			State = 1744;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 1743;
				hintParams();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HintParamsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public QueryBlockContext queryBlock() {
			return GetRuleContext<QueryBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext[] literal() {
			return GetRuleContexts<LiteralContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal(int i) {
			return GetRuleContext<LiteralContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComplexIndexHintContext[] complexIndexHint() {
			return GetRuleContexts<ComplexIndexHintContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComplexIndexHintContext complexIndexHint(int i) {
			return GetRuleContext<ComplexIndexHintContext>(i);
		}
		public HintParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hintParams; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterHintParams(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitHintParams(this);
		}
	}

	[RuleVersion(0)]
	public HintParamsContext hintParams() {
		HintParamsContext _localctx = new HintParamsContext(Context, State);
		EnterRule(_localctx, 16, RULE_hintParams);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1746;
			Match(LPAREN);
			State = 1748;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AT_SIGN) {
				{
				State = 1747;
				queryBlock();
				}
			}

			State = 1755;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (INTEGER_LITERAL - 576)) | (1L << (LPAREN - 576)) | (1L << (FLOATING_POINT_LITERAL - 576)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 576)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 576)) | (1L << (BINARY_STRING_LITERAL - 576)) | (1L << (CHARACTER_STRING_LITERAL - 576)) | (1L << (MONEY_LITERAL - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 576)))) != 0)) {
				{
				State = 1753;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
				case 1:
					{
					State = 1750;
					literal();
					}
					break;
				case 2:
					{
					State = 1751;
					identifier();
					}
					break;
				case 3:
					{
					State = 1752;
					complexIndexHint();
					}
					break;
				}
				}
				State = 1757;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1758;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComplexIndexHintContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ComplexIndexHintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_complexIndexHint; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterComplexIndexHint(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitComplexIndexHint(this);
		}
	}

	[RuleVersion(0)]
	public ComplexIndexHintContext complexIndexHint() {
		ComplexIndexHintContext _localctx = new ComplexIndexHintContext(Context, State);
		EnterRule(_localctx, 18, RULE_complexIndexHint);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1760;
			Match(LPAREN);
			State = 1764;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				{
				State = 1761;
				identifier();
				}
				}
				State = 1766;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1767;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT_SIGN() { return GetToken(OracleAntlrParser.AT_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public QueryBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterQueryBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitQueryBlock(this);
		}
	}

	[RuleVersion(0)]
	public QueryBlockContext queryBlock() {
		QueryBlockContext _localctx = new QueryBlockContext(Context, State);
		EnterRule(_localctx, 20, RULE_queryBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1769;
			Match(AT_SIGN);
			State = 1770;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SqlInputFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SqlStatementBatchContext[] sqlStatementBatch() {
			return GetRuleContexts<SqlStatementBatchContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SqlStatementBatchContext sqlStatementBatch(int i) {
			return GetRuleContext<SqlStatementBatchContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] FSLASH() { return GetTokens(OracleAntlrParser.FSLASH); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FSLASH(int i) {
			return GetToken(OracleAntlrParser.FSLASH, i);
		}
		public SqlInputFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlInputFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSqlInputFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSqlInputFile(this);
		}
	}

	[RuleVersion(0)]
	public SqlInputFileContext sqlInputFile() {
		SqlInputFileContext _localctx = new SqlInputFileContext(Context, State);
		EnterRule(_localctx, 22, RULE_sqlInputFile);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1772;
			sqlStatementBatch();
			State = 1777;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==FSLASH) {
				{
				{
				State = 1773;
				Match(FSLASH);
				State = 1774;
				sqlStatementBatch();
				}
				}
				State = 1779;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SqlStatementBatchContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SqlStatementContext sqlStatement() {
			return GetRuleContext<SqlStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI() { return GetToken(OracleAntlrParser.SEMI, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SqlStatementBatchContext sqlStatementBatch() {
			return GetRuleContext<SqlStatementBatchContext>(0);
		}
		public SqlStatementBatchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlStatementBatch; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSqlStatementBatch(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSqlStatementBatch(this);
		}
	}

	[RuleVersion(0)]
	public SqlStatementBatchContext sqlStatementBatch() {
		SqlStatementBatchContext _localctx = new SqlStatementBatchContext(Context, State);
		EnterRule(_localctx, 24, RULE_sqlStatementBatch);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1780;
			sqlStatement();
			State = 1785;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SEMI) {
				{
				State = 1781;
				Match(SEMI);
				State = 1783;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALTER) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECLARE - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DIRECTIVE_IF - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DROP - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FETCH - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GOTO - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSERT - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLBACK - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELECT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (UPDATE - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITH - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (LPAREN - 576)) | (1L << (LESS_THAN - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
					{
					State = 1782;
					sqlStatementBatch();
					}
				}

				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SqlStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CreateStatementContext createStatement() {
			return GetRuleContext<CreateStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterStatementContext alterStatement() {
			return GetRuleContext<AlterStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropStatementContext dropStatement() {
			return GetRuleContext<DropStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeleteStatementContext deleteStatement() {
			return GetRuleContext<DeleteStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CloseStatementContext closeStatement() {
			return GetRuleContext<CloseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpenStatementContext openStatement() {
			return GetRuleContext<OpenStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExecuteImmediateStatementContext executeImmediateStatement() {
			return GetRuleContext<ExecuteImmediateStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetTransactionStatementContext setTransactionStatement() {
			return GetRuleContext<SetTransactionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RaiseStatementContext raiseStatement() {
			return GetRuleContext<RaiseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TruncateTableStatementContext truncateTableStatement() {
			return GetRuleContext<TruncateTableStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TruncateClusterStatementContext truncateClusterStatement() {
			return GetRuleContext<TruncateClusterStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockStatementContext blockStatement() {
			return GetRuleContext<BlockStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertStatementContext insertStatement() {
			return GetRuleContext<InsertStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UpdateStatementContext updateStatement() {
			return GetRuleContext<UpdateStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GotoStatementContext gotoStatement() {
			return GetRuleContext<GotoStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FetchStatementContext fetchStatement() {
			return GetRuleContext<FetchStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommitWorkStatementContext commitWorkStatement() {
			return GetRuleContext<CommitWorkStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RollbackWorkStatementContext rollbackWorkStatement() {
			return GetRuleContext<RollbackWorkStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SavepointStatementContext savepointStatement() {
			return GetRuleContext<SavepointStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeStatementContext mergeStatement() {
			return GetRuleContext<MergeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelContext label() {
			return GetRuleContext<LabelContext>(0);
		}
		public SqlStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSqlStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSqlStatement(this);
		}
	}

	[RuleVersion(0)]
	public SqlStatementContext sqlStatement() {
		SqlStatementContext _localctx = new SqlStatementContext(Context, State);
		EnterRule(_localctx, 26, RULE_sqlStatement);
		int _la;
		try {
			State = 1813;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CREATE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1787;
				createStatement();
				}
				break;
			case ALTER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1788;
				alterStatement();
				}
				break;
			case DROP:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1789;
				dropStatement();
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECLARE:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DIRECTIVE_IF:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FETCH:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GOTO:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSERT:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case UPDATE:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITH:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case LPAREN:
			case LESS_THAN:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1791;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LESS_THAN) {
					{
					State = 1790;
					label();
					}
				}

				State = 1811;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
				case 1:
					{
					State = 1793;
					deleteStatement();
					}
					break;
				case 2:
					{
					State = 1794;
					closeStatement();
					}
					break;
				case 3:
					{
					State = 1795;
					openStatement();
					}
					break;
				case 4:
					{
					State = 1796;
					executeImmediateStatement();
					}
					break;
				case 5:
					{
					State = 1797;
					setTransactionStatement();
					}
					break;
				case 6:
					{
					State = 1798;
					raiseStatement();
					}
					break;
				case 7:
					{
					State = 1799;
					truncateTableStatement();
					}
					break;
				case 8:
					{
					State = 1800;
					truncateClusterStatement();
					}
					break;
				case 9:
					{
					State = 1801;
					blockStatement();
					}
					break;
				case 10:
					{
					State = 1802;
					selectStatement();
					}
					break;
				case 11:
					{
					State = 1803;
					insertStatement();
					}
					break;
				case 12:
					{
					State = 1804;
					updateStatement();
					}
					break;
				case 13:
					{
					State = 1805;
					gotoStatement();
					}
					break;
				case 14:
					{
					State = 1806;
					fetchStatement();
					}
					break;
				case 15:
					{
					State = 1807;
					commitWorkStatement();
					}
					break;
				case 16:
					{
					State = 1808;
					rollbackWorkStatement();
					}
					break;
				case 17:
					{
					State = 1809;
					savepointStatement();
					}
					break;
				case 18:
					{
					State = 1810;
					mergeStatement();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlSqlStatementBatchContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlSqlStatementContext[] plSqlStatement() {
			return GetRuleContexts<PlSqlStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PlSqlStatementContext plSqlStatement(int i) {
			return GetRuleContext<PlSqlStatementContext>(i);
		}
		public PlSqlStatementBatchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plSqlStatementBatch; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPlSqlStatementBatch(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPlSqlStatementBatch(this);
		}
	}

	[RuleVersion(0)]
	public PlSqlStatementBatchContext plSqlStatementBatch() {
		PlSqlStatementBatchContext _localctx = new PlSqlStatementBatchContext(Context, State);
		EnterRule(_localctx, 28, RULE_plSqlStatementBatch);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1819;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,14,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1815;
					if (!(IsSqlStatement())) throw new FailedPredicateException(this, "IsSqlStatement()");
					State = 1816;
					plSqlStatement();
					}
					} 
				}
				State = 1821;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,14,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlSqlStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI() { return GetToken(OracleAntlrParser.SEMI, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ControlStructureContext controlStructure() {
			return GetRuleContext<ControlStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ContinueStatementContext continueStatement() {
			return GetRuleContext<ContinueStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeleteStatementContext deleteStatement() {
			return GetRuleContext<DeleteStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExecuteImmediateStatementContext executeImmediateStatement() {
			return GetRuleContext<ExecuteImmediateStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentStatementContext assignmentStatement() {
			return GetRuleContext<AssignmentStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RaiseStatementContext raiseStatement() {
			return GetRuleContext<RaiseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommitWorkStatementContext commitWorkStatement() {
			return GetRuleContext<CommitWorkStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExitStatementContext exitStatement() {
			return GetRuleContext<ExitStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureCallContext procedureCall() {
			return GetRuleContext<ProcedureCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CloseStatementContext closeStatement() {
			return GetRuleContext<CloseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpenStatementContext openStatement() {
			return GetRuleContext<OpenStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetTransactionStatementContext setTransactionStatement() {
			return GetRuleContext<SetTransactionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationPragmaContext declarationPragma() {
			return GetRuleContext<DeclarationPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockStatementContext blockStatement() {
			return GetRuleContext<BlockStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertStatementContext insertStatement() {
			return GetRuleContext<InsertStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UpdateStatementContext updateStatement() {
			return GetRuleContext<UpdateStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GotoStatementContext gotoStatement() {
			return GetRuleContext<GotoStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FetchStatementContext fetchStatement() {
			return GetRuleContext<FetchStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RollbackWorkStatementContext rollbackWorkStatement() {
			return GetRuleContext<RollbackWorkStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SavepointStatementContext savepointStatement() {
			return GetRuleContext<SavepointStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturnStatementContext returnStatement() {
			return GetRuleContext<ReturnStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullStatementContext nullStatement() {
			return GetRuleContext<NullStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LockTableStatementContext lockTableStatement() {
			return GetRuleContext<LockTableStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeStatementContext mergeStatement() {
			return GetRuleContext<MergeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PipeRowStatementContext pipeRowStatement() {
			return GetRuleContext<PipeRowStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelContext label() {
			return GetRuleContext<LabelContext>(0);
		}
		public PlSqlStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plSqlStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPlSqlStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPlSqlStatement(this);
		}
	}

	[RuleVersion(0)]
	public PlSqlStatementContext plSqlStatement() {
		PlSqlStatementContext _localctx = new PlSqlStatementContext(Context, State);
		EnterRule(_localctx, 30, RULE_plSqlStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1823;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LESS_THAN) {
				{
				State = 1822;
				label();
				}
			}

			State = 1851;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 1825;
				controlStructure();
				}
				break;
			case 2:
				{
				State = 1826;
				continueStatement();
				}
				break;
			case 3:
				{
				State = 1827;
				deleteStatement();
				}
				break;
			case 4:
				{
				State = 1828;
				executeImmediateStatement();
				}
				break;
			case 5:
				{
				State = 1829;
				assignmentStatement();
				}
				break;
			case 6:
				{
				State = 1830;
				raiseStatement();
				}
				break;
			case 7:
				{
				State = 1831;
				commitWorkStatement();
				}
				break;
			case 8:
				{
				State = 1832;
				exitStatement();
				}
				break;
			case 9:
				{
				State = 1833;
				procedureCall();
				}
				break;
			case 10:
				{
				State = 1834;
				closeStatement();
				}
				break;
			case 11:
				{
				State = 1835;
				openStatement();
				}
				break;
			case 12:
				{
				State = 1836;
				setTransactionStatement();
				}
				break;
			case 13:
				{
				State = 1837;
				declarationPragma();
				}
				break;
			case 14:
				{
				State = 1838;
				blockStatement();
				}
				break;
			case 15:
				{
				State = 1839;
				selectStatement();
				}
				break;
			case 16:
				{
				State = 1840;
				insertStatement();
				}
				break;
			case 17:
				{
				State = 1841;
				updateStatement();
				}
				break;
			case 18:
				{
				State = 1842;
				gotoStatement();
				}
				break;
			case 19:
				{
				State = 1843;
				fetchStatement();
				}
				break;
			case 20:
				{
				State = 1844;
				rollbackWorkStatement();
				}
				break;
			case 21:
				{
				State = 1845;
				savepointStatement();
				}
				break;
			case 22:
				{
				State = 1846;
				returnStatement();
				}
				break;
			case 23:
				{
				State = 1847;
				nullStatement();
				}
				break;
			case 24:
				{
				State = 1848;
				lockTableStatement();
				}
				break;
			case 25:
				{
				State = 1849;
				mergeStatement();
				}
				break;
			case 26:
				{
				State = 1850;
				pipeRowStatement();
				}
				break;
			}
			State = 1853;
			Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RoutineSignatureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATE() { return GetToken(OracleAntlrParser.CREATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureOrFunctionSignatureContext procedureOrFunctionSignature() {
			return GetRuleContext<ProcedureOrFunctionSignatureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateStatementReplaceClauseContext createStatementReplaceClause() {
			return GetRuleContext<CreateStatementReplaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EditionOptionClauseContext editionOptionClause() {
			return GetRuleContext<EditionOptionClauseContext>(0);
		}
		public RoutineSignatureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routineSignature; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRoutineSignature(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRoutineSignature(this);
		}
	}

	[RuleVersion(0)]
	public RoutineSignatureContext routineSignature() {
		RoutineSignatureContext _localctx = new RoutineSignatureContext(Context, State);
		EnterRule(_localctx, 32, RULE_routineSignature);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1855;
			Match(CREATE);
			State = 1857;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 1856;
				createStatementReplaceClause();
				}
			}

			State = 1860;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EDITIONABLE || _la==NONEDITIONABLE) {
				{
				State = 1859;
				editionOptionClause();
				}
			}

			State = 1862;
			procedureOrFunctionSignature();
			State = 1866;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,19,Context);
			while ( _alt!=1 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1+1 ) {
					{
					{
					State = 1863;
					MatchWildcard();
					}
					} 
				}
				State = 1868;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,19,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureOrFunctionSignatureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureSignatureContext procedureSignature() {
			return GetRuleContext<ProcedureSignatureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionSignatureContext functionSignature() {
			return GetRuleContext<FunctionSignatureContext>(0);
		}
		public ProcedureOrFunctionSignatureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureOrFunctionSignature; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterProcedureOrFunctionSignature(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitProcedureOrFunctionSignature(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureOrFunctionSignatureContext procedureOrFunctionSignature() {
		ProcedureOrFunctionSignatureContext _localctx = new ProcedureOrFunctionSignatureContext(Context, State);
		EnterRule(_localctx, 34, RULE_procedureOrFunctionSignature);
		try {
			State = 1871;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PROCEDURE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1869;
				procedureSignature();
				}
				break;
			case FUNCTION:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1870;
				functionSignature();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		public IToken numberLiteral;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOATING_POINT_LITERAL() { return GetToken(OracleAntlrParser.FLOATING_POINT_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MONEY_LITERAL() { return GetToken(OracleAntlrParser.MONEY_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharacterStringLiteralContext characterStringLiteral() {
			return GetRuleContext<CharacterStringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public QuoteCharacterStringLiteralContext quoteCharacterStringLiteral() {
			return GetRuleContext<QuoteCharacterStringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnicodeCharacterStringLiteralContext unicodeCharacterStringLiteral() {
			return GetRuleContext<UnicodeCharacterStringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BinaryStringLiteralContext binaryStringLiteral() {
			return GetRuleContext<BinaryStringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BooleanLiteralContext booleanLiteral() {
			return GetRuleContext<BooleanLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DateLiteralContext dateLiteral() {
			return GetRuleContext<DateLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TimestampLiteralContext timestampLiteral() {
			return GetRuleContext<TimestampLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntervalLiteralContext intervalLiteral() {
			return GetRuleContext<IntervalLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FloatingPointBinaryLiteralContext floatingPointBinaryLiteral() {
			return GetRuleContext<FloatingPointBinaryLiteralContext>(0);
		}
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 36, RULE_literal);
		int _la;
		try {
			State = 1883;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INTEGER_LITERAL:
			case FLOATING_POINT_LITERAL:
			case MONEY_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1873;
				_localctx.numberLiteral = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 581)) & ~0x3f) == 0 && ((1L << (_la - 581)) & ((1L << (INTEGER_LITERAL - 581)) | (1L << (FLOATING_POINT_LITERAL - 581)) | (1L << (MONEY_LITERAL - 581)))) != 0)) ) {
					_localctx.numberLiteral = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case CHARACTER_STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1874;
				characterStringLiteral();
				}
				break;
			case QUOTE_CHARACTER_STRING_LITERAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1875;
				quoteCharacterStringLiteral();
				}
				break;
			case UNICODE_CHARACTER_STRING_LITERAL:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1876;
				unicodeCharacterStringLiteral();
				}
				break;
			case BINARY_STRING_LITERAL:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1877;
				binaryStringLiteral();
				}
				break;
			case FALSE:
			case TRUE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1878;
				booleanLiteral();
				}
				break;
			case DATE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1879;
				dateLiteral();
				}
				break;
			case TIMESTAMP:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1880;
				timestampLiteral();
				}
				break;
			case INTERVAL:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1881;
				intervalLiteral();
				}
				break;
			case FLOATING_POINT_BINARY_LITERAL:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1882;
				floatingPointBinaryLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QuoteCharacterStringLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTE_CHARACTER_STRING_LITERAL() { return GetToken(OracleAntlrParser.QUOTE_CHARACTER_STRING_LITERAL, 0); }
		public QuoteCharacterStringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quoteCharacterStringLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterQuoteCharacterStringLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitQuoteCharacterStringLiteral(this);
		}
	}

	[RuleVersion(0)]
	public QuoteCharacterStringLiteralContext quoteCharacterStringLiteral() {
		QuoteCharacterStringLiteralContext _localctx = new QuoteCharacterStringLiteralContext(Context, State);
		EnterRule(_localctx, 38, RULE_quoteCharacterStringLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1885;
			Match(QUOTE_CHARACTER_STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CharacterStringLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER_STRING_LITERAL() { return GetToken(OracleAntlrParser.CHARACTER_STRING_LITERAL, 0); }
		public CharacterStringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_characterStringLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCharacterStringLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCharacterStringLiteral(this);
		}
	}

	[RuleVersion(0)]
	public CharacterStringLiteralContext characterStringLiteral() {
		CharacterStringLiteralContext _localctx = new CharacterStringLiteralContext(Context, State);
		EnterRule(_localctx, 40, RULE_characterStringLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1887;
			Match(CHARACTER_STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnicodeCharacterStringLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNICODE_CHARACTER_STRING_LITERAL() { return GetToken(OracleAntlrParser.UNICODE_CHARACTER_STRING_LITERAL, 0); }
		public UnicodeCharacterStringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unicodeCharacterStringLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUnicodeCharacterStringLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUnicodeCharacterStringLiteral(this);
		}
	}

	[RuleVersion(0)]
	public UnicodeCharacterStringLiteralContext unicodeCharacterStringLiteral() {
		UnicodeCharacterStringLiteralContext _localctx = new UnicodeCharacterStringLiteralContext(Context, State);
		EnterRule(_localctx, 42, RULE_unicodeCharacterStringLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1889;
			Match(UNICODE_CHARACTER_STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BinaryStringLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BINARY_STRING_LITERAL() { return GetToken(OracleAntlrParser.BINARY_STRING_LITERAL, 0); }
		public BinaryStringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_binaryStringLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBinaryStringLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBinaryStringLiteral(this);
		}
	}

	[RuleVersion(0)]
	public BinaryStringLiteralContext binaryStringLiteral() {
		BinaryStringLiteralContext _localctx = new BinaryStringLiteralContext(Context, State);
		EnterRule(_localctx, 44, RULE_binaryStringLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1891;
			Match(BINARY_STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooleanLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUE() { return GetToken(OracleAntlrParser.TRUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FALSE() { return GetToken(OracleAntlrParser.FALSE, 0); }
		public BooleanLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_booleanLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBooleanLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBooleanLiteral(this);
		}
	}

	[RuleVersion(0)]
	public BooleanLiteralContext booleanLiteral() {
		BooleanLiteralContext _localctx = new BooleanLiteralContext(Context, State);
		EnterRule(_localctx, 46, RULE_booleanLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1893;
			_la = TokenStream.LA(1);
			if ( !(_la==FALSE || _la==TRUE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DateLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATE() { return GetToken(OracleAntlrParser.DATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER_STRING_LITERAL() { return GetToken(OracleAntlrParser.CHARACTER_STRING_LITERAL, 0); }
		public DateLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dateLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDateLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDateLiteral(this);
		}
	}

	[RuleVersion(0)]
	public DateLiteralContext dateLiteral() {
		DateLiteralContext _localctx = new DateLiteralContext(Context, State);
		EnterRule(_localctx, 48, RULE_dateLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1895;
			Match(DATE);
			State = 1896;
			Match(CHARACTER_STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimestampLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMESTAMP() { return GetToken(OracleAntlrParser.TIMESTAMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER_STRING_LITERAL() { return GetToken(OracleAntlrParser.CHARACTER_STRING_LITERAL, 0); }
		public TimestampLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timestampLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTimestampLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTimestampLiteral(this);
		}
	}

	[RuleVersion(0)]
	public TimestampLiteralContext timestampLiteral() {
		TimestampLiteralContext _localctx = new TimestampLiteralContext(Context, State);
		EnterRule(_localctx, 50, RULE_timestampLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1898;
			Match(TIMESTAMP);
			State = 1899;
			Match(CHARACTER_STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERVAL() { return GetToken(OracleAntlrParser.INTERVAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER_STRING_LITERAL() { return GetToken(OracleAntlrParser.CHARACTER_STRING_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IntervalLiteralFieldClauseContext[] intervalLiteralFieldClause() {
			return GetRuleContexts<IntervalLiteralFieldClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntervalLiteralFieldClauseContext intervalLiteralFieldClause(int i) {
			return GetRuleContext<IntervalLiteralFieldClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(OracleAntlrParser.TO, 0); }
		public IntervalLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIntervalLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIntervalLiteral(this);
		}
	}

	[RuleVersion(0)]
	public IntervalLiteralContext intervalLiteral() {
		IntervalLiteralContext _localctx = new IntervalLiteralContext(Context, State);
		EnterRule(_localctx, 52, RULE_intervalLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1901;
			Match(INTERVAL);
			State = 1902;
			Match(CHARACTER_STRING_LITERAL);
			State = 1903;
			intervalLiteralFieldClause();
			State = 1906;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,22,Context) ) {
			case 1:
				{
				State = 1904;
				Match(TO);
				State = 1905;
				intervalLiteralFieldClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalLiteralFieldClauseContext : ParserRuleContext {
		public IToken interval;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode YEAR() { return GetToken(OracleAntlrParser.YEAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MONTH() { return GetToken(OracleAntlrParser.MONTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DAY() { return GetToken(OracleAntlrParser.DAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HOUR() { return GetToken(OracleAntlrParser.HOUR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUTE() { return GetToken(OracleAntlrParser.MINUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECOND() { return GetToken(OracleAntlrParser.SECOND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IntervalLiteralFieldPrecisionContext intervalLiteralFieldPrecision() {
			return GetRuleContext<IntervalLiteralFieldPrecisionContext>(0);
		}
		public IntervalLiteralFieldClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalLiteralFieldClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIntervalLiteralFieldClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIntervalLiteralFieldClause(this);
		}
	}

	[RuleVersion(0)]
	public IntervalLiteralFieldClauseContext intervalLiteralFieldClause() {
		IntervalLiteralFieldClauseContext _localctx = new IntervalLiteralFieldClauseContext(Context, State);
		EnterRule(_localctx, 54, RULE_intervalLiteralFieldClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1908;
			_localctx.interval = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DAY || _la==HOUR || _la==MINUTE || _la==MONTH || _la==SECOND || _la==YEAR) ) {
				_localctx.interval = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1910;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 1909;
				intervalLiteralFieldPrecision();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalLiteralFieldPrecisionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext[] literal() {
			return GetRuleContexts<LiteralContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal(int i) {
			return GetRuleContext<LiteralContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		public IntervalLiteralFieldPrecisionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalLiteralFieldPrecision; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIntervalLiteralFieldPrecision(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIntervalLiteralFieldPrecision(this);
		}
	}

	[RuleVersion(0)]
	public IntervalLiteralFieldPrecisionContext intervalLiteralFieldPrecision() {
		IntervalLiteralFieldPrecisionContext _localctx = new IntervalLiteralFieldPrecisionContext(Context, State);
		EnterRule(_localctx, 56, RULE_intervalLiteralFieldPrecision);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1912;
			Match(LPAREN);
			State = 1913;
			literal();
			State = 1916;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 1914;
				Match(COMMA);
				State = 1915;
				literal();
				}
			}

			State = 1918;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FloatingPointBinaryLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOATING_POINT_BINARY_LITERAL() { return GetToken(OracleAntlrParser.FLOATING_POINT_BINARY_LITERAL, 0); }
		public FloatingPointBinaryLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_floatingPointBinaryLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFloatingPointBinaryLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFloatingPointBinaryLiteral(this);
		}
	}

	[RuleVersion(0)]
	public FloatingPointBinaryLiteralContext floatingPointBinaryLiteral() {
		FloatingPointBinaryLiteralContext _localctx = new FloatingPointBinaryLiteralContext(Context, State);
		EnterRule(_localctx, 58, RULE_floatingPointBinaryLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1920;
			Match(FLOATING_POINT_BINARY_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleIdentifierRegularIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REGULAR_IDENTIFIER() { return GetToken(OracleAntlrParser.REGULAR_IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT() { return GetToken(OracleAntlrParser.AT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode A_() { return GetToken(OracleAntlrParser.A_, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ACCOUNT() { return GetToken(OracleAntlrParser.ACCOUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADVANCED() { return GetToken(OracleAntlrParser.ADVANCED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AFTER() { return GetToken(OracleAntlrParser.AFTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AGENT() { return GetToken(OracleAntlrParser.AGENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AGGREGATE() { return GetToken(OracleAntlrParser.AGGREGATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALLOCATE() { return GetToken(OracleAntlrParser.ALLOCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALLOW() { return GetToken(OracleAntlrParser.ALLOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALWAYS() { return GetToken(OracleAntlrParser.ALWAYS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANALYZE() { return GetToken(OracleAntlrParser.ANALYZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANYSCHEMA() { return GetToken(OracleAntlrParser.ANYSCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARCHIVE() { return GetToken(OracleAntlrParser.ARCHIVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARRAY() { return GetToken(OracleAntlrParser.ARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSOCIATE() { return GetToken(OracleAntlrParser.ASSOCIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ATTRIBUTE() { return GetToken(OracleAntlrParser.ATTRIBUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ATTRIBUTES() { return GetToken(OracleAntlrParser.ATTRIBUTES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTHENTICATION() { return GetToken(OracleAntlrParser.AUTHENTICATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTHID() { return GetToken(OracleAntlrParser.AUTHID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTO() { return GetToken(OracleAntlrParser.AUTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTONOMOUS_TRANSACTION() { return GetToken(OracleAntlrParser.AUTONOMOUS_TRANSACTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BASIC() { return GetToken(OracleAntlrParser.BASIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BASICFILE() { return GetToken(OracleAntlrParser.BASICFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BATCH() { return GetToken(OracleAntlrParser.BATCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEFORE() { return GetToken(OracleAntlrParser.BEFORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEGINNING() { return GetToken(OracleAntlrParser.BEGINNING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BINARY() { return GetToken(OracleAntlrParser.BINARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BITMAP() { return GetToken(OracleAntlrParser.BITMAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BLOCK() { return GetToken(OracleAntlrParser.BLOCK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BODY() { return GetToken(OracleAntlrParser.BODY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOTH() { return GetToken(OracleAntlrParser.BOTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BREADTH() { return GetToken(OracleAntlrParser.BREADTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUFFER_POOL() { return GetToken(OracleAntlrParser.BUFFER_POOL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUILD() { return GetToken(OracleAntlrParser.BUILD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUILTIN() { return GetToken(OracleAntlrParser.BUILTIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BULK() { return GetToken(OracleAntlrParser.BULK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BULK_EXCEPTIONS() { return GetToken(OracleAntlrParser.BULK_EXCEPTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BULK_ROWCOUNT() { return GetToken(OracleAntlrParser.BULK_ROWCOUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BYTE() { return GetToken(OracleAntlrParser.BYTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode C_() { return GetToken(OracleAntlrParser.C_, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CACHE() { return GetToken(OracleAntlrParser.CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CALL() { return GetToken(OracleAntlrParser.CALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASCADE() { return GetToken(OracleAntlrParser.CASCADE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CAST() { return GetToken(OracleAntlrParser.CAST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CELL_FLASH_CACHE() { return GetToken(OracleAntlrParser.CELL_FLASH_CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAR() { return GetToken(OracleAntlrParser.CHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAR_CS() { return GetToken(OracleAntlrParser.CHAR_CS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER() { return GetToken(OracleAntlrParser.CHARACTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARSET() { return GetToken(OracleAntlrParser.CHARSET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHR() { return GetToken(OracleAntlrParser.CHR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHUNK() { return GetToken(OracleAntlrParser.CHUNK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOB() { return GetToken(OracleAntlrParser.CLOB, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE() { return GetToken(OracleAntlrParser.CLOSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COALESCE() { return GetToken(OracleAntlrParser.COALESCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLLATION() { return GetToken(OracleAntlrParser.COLLATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLLECT() { return GetToken(OracleAntlrParser.COLLECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMN_VALUE() { return GetToken(OracleAntlrParser.COLUMN_VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMIT() { return GetToken(OracleAntlrParser.COMMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMITTED() { return GetToken(OracleAntlrParser.COMMITTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPACT() { return GetToken(OracleAntlrParser.COMPACT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPILE() { return GetToken(OracleAntlrParser.COMPILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPLETE() { return GetToken(OracleAntlrParser.COMPLETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPOUND() { return GetToken(OracleAntlrParser.COMPOUND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPUTATION() { return GetToken(OracleAntlrParser.COMPUTATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPUTE() { return GetToken(OracleAntlrParser.COMPUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONDITIONAL() { return GetToken(OracleAntlrParser.CONDITIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTAINER() { return GetToken(OracleAntlrParser.CONTAINER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTEXT() { return GetToken(OracleAntlrParser.CONTEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTINUE() { return GetToken(OracleAntlrParser.CONTINUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTANT() { return GetToken(OracleAntlrParser.CONSTANT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINT() { return GetToken(OracleAntlrParser.CONSTRAINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINTS() { return GetToken(OracleAntlrParser.CONSTRAINTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRUCTOR() { return GetToken(OracleAntlrParser.CONSTRUCTOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONVERT() { return GetToken(OracleAntlrParser.CONVERT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COUNT() { return GetToken(OracleAntlrParser.COUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATION() { return GetToken(OracleAntlrParser.CREATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CROSS() { return GetToken(OracleAntlrParser.CROSS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CUBE() { return GetToken(OracleAntlrParser.CUBE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT_USER() { return GetToken(OracleAntlrParser.CURRENT_USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CYCLE() { return GetToken(OracleAntlrParser.CYCLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATA() { return GetToken(OracleAntlrParser.DATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(OracleAntlrParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATAFILE() { return GetToken(OracleAntlrParser.DATAFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATE() { return GetToken(OracleAntlrParser.DATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DAY() { return GetToken(OracleAntlrParser.DAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DBTIMEZONE() { return GetToken(OracleAntlrParser.DBTIMEZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DDL() { return GetToken(OracleAntlrParser.DDL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEALLOCATE() { return GetToken(OracleAntlrParser.DEALLOCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEBUG() { return GetToken(OracleAntlrParser.DEBUG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECODE() { return GetToken(OracleAntlrParser.DECODE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECRYPT() { return GetToken(OracleAntlrParser.DECRYPT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEDUPLICATE() { return GetToken(OracleAntlrParser.DEDUPLICATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFERRABLE() { return GetToken(OracleAntlrParser.DEFERRABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFERRED() { return GetToken(OracleAntlrParser.DEFERRED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFINER() { return GetToken(OracleAntlrParser.DEFINER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(OracleAntlrParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEMAND() { return GetToken(OracleAntlrParser.DEMAND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DENSE_RANK() { return GetToken(OracleAntlrParser.DENSE_RANK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEPTH() { return GetToken(OracleAntlrParser.DEPTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DETERMINISTIC() { return GetToken(OracleAntlrParser.DETERMINISTIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECT_LOAD() { return GetToken(OracleAntlrParser.DIRECT_LOAD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISABLE() { return GetToken(OracleAntlrParser.DISABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISALLOW() { return GetToken(OracleAntlrParser.DISALLOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISASSOCIATE() { return GetToken(OracleAntlrParser.DISASSOCIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOUBLE() { return GetToken(OracleAntlrParser.DOUBLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DUPLICATED() { return GetToken(OracleAntlrParser.DUPLICATED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EACH() { return GetToken(OracleAntlrParser.EACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITION() { return GetToken(OracleAntlrParser.EDITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITIONABLE() { return GetToken(OracleAntlrParser.EDITIONABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITIONING() { return GetToken(OracleAntlrParser.EDITIONING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITIONS() { return GetToken(OracleAntlrParser.EDITIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELEMENT() { return GetToken(OracleAntlrParser.ELEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSIF() { return GetToken(OracleAntlrParser.ELSIF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EMPTY_KEYWORD() { return GetToken(OracleAntlrParser.EMPTY_KEYWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENCRYPT() { return GetToken(OracleAntlrParser.ENCRYPT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENFORCED() { return GetToken(OracleAntlrParser.ENFORCED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR_CODE() { return GetToken(OracleAntlrParser.ERROR_CODE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR_INDEX() { return GetToken(OracleAntlrParser.ERROR_INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERRORS() { return GetToken(OracleAntlrParser.ERRORS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ESCAPE() { return GetToken(OracleAntlrParser.ESCAPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EVALUATE() { return GetToken(OracleAntlrParser.EVALUATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPT() { return GetToken(OracleAntlrParser.EXCEPT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPTION_INIT() { return GetToken(OracleAntlrParser.EXCEPTION_INIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPTIONS() { return GetToken(OracleAntlrParser.EXCEPTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLUDE() { return GetToken(OracleAntlrParser.EXCLUDE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXECUTE() { return GetToken(OracleAntlrParser.EXECUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(OracleAntlrParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXIT() { return GetToken(OracleAntlrParser.EXIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXPIRE() { return GetToken(OracleAntlrParser.EXPIRE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTEND() { return GetToken(OracleAntlrParser.EXTEND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTENDED() { return GetToken(OracleAntlrParser.EXTENDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTENT() { return GetToken(OracleAntlrParser.EXTENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTERNALLY() { return GetToken(OracleAntlrParser.EXTERNALLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTRACT() { return GetToken(OracleAntlrParser.EXTRACT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FALSE() { return GetToken(OracleAntlrParser.FALSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FAST() { return GetToken(OracleAntlrParser.FAST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FILESYSTEM_LIKE_LOGGING() { return GetToken(OracleAntlrParser.FILESYSTEM_LIKE_LOGGING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FINAL() { return GetToken(OracleAntlrParser.FINAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIPSFLAG() { return GetToken(OracleAntlrParser.FIPSFLAG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIRST() { return GetToken(OracleAntlrParser.FIRST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIXED() { return GetToken(OracleAntlrParser.FIXED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIRST_ROWS() { return GetToken(OracleAntlrParser.FIRST_ROWS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLASH_CACHE() { return GetToken(OracleAntlrParser.FLASH_CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOLLOWING() { return GetToken(OracleAntlrParser.FOLLOWING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORALL() { return GetToken(OracleAntlrParser.FORALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORCE() { return GetToken(OracleAntlrParser.FORCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOREIGN() { return GetToken(OracleAntlrParser.FOREIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORMAT() { return GetToken(OracleAntlrParser.FORMAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOUND() { return GetToken(OracleAntlrParser.FOUND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FREELIST() { return GetToken(OracleAntlrParser.FREELIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FREELISTS() { return GetToken(OracleAntlrParser.FREELISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FREEPOOLS() { return GetToken(OracleAntlrParser.FREEPOOLS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FULL() { return GetToken(OracleAntlrParser.FULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTION() { return GetToken(OracleAntlrParser.FUNCTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GENERATED() { return GetToken(OracleAntlrParser.GENERATED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GLOBAL() { return GetToken(OracleAntlrParser.GLOBAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GLOBALLY() { return GetToken(OracleAntlrParser.GLOBALLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUPING() { return GetToken(OracleAntlrParser.GROUPING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUPS() { return GetToken(OracleAntlrParser.GROUPS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(OracleAntlrParser.HASH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HEAP() { return GetToken(OracleAntlrParser.HEAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HIGH() { return GetToken(OracleAntlrParser.HIGH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HOUR() { return GetToken(OracleAntlrParser.HOUR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(OracleAntlrParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(OracleAntlrParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTITY() { return GetToken(OracleAntlrParser.IDENTITY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDE() { return GetToken(OracleAntlrParser.INCLUDE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDING() { return GetToken(OracleAntlrParser.INCLUDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEXING() { return GetToken(OracleAntlrParser.INDEXING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDICATOR() { return GetToken(OracleAntlrParser.INDICATOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDICES() { return GetToken(OracleAntlrParser.INDICES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INITIALLY() { return GetToken(OracleAntlrParser.INITIALLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INITRANS() { return GetToken(OracleAntlrParser.INITRANS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INNER() { return GetToken(OracleAntlrParser.INNER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSTANCE() { return GetToken(OracleAntlrParser.INSTANCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSTANTIABLE() { return GetToken(OracleAntlrParser.INSTANTIABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSTEAD() { return GetToken(OracleAntlrParser.INSTEAD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERFACE() { return GetToken(OracleAntlrParser.INTERFACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERVAL() { return GetToken(OracleAntlrParser.INTERVAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALIDATE() { return GetToken(OracleAntlrParser.INVALIDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALIDATION() { return GetToken(OracleAntlrParser.INVALIDATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVISIBLE() { return GetToken(OracleAntlrParser.INVISIBLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ISOLATION() { return GetToken(OracleAntlrParser.ISOLATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ISOPEN() { return GetToken(OracleAntlrParser.ISOPEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JAVA() { return GetToken(OracleAntlrParser.JAVA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JOIN() { return GetToken(OracleAntlrParser.JOIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JSON() { return GetToken(OracleAntlrParser.JSON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JSON_TABLE() { return GetToken(OracleAntlrParser.JSON_TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP_DUPLICATES() { return GetToken(OracleAntlrParser.KEEP_DUPLICATES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(OracleAntlrParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LANGUAGE() { return GetToken(OracleAntlrParser.LANGUAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LAST() { return GetToken(OracleAntlrParser.LAST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEADING() { return GetToken(OracleAntlrParser.LEADING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEFT() { return GetToken(OracleAntlrParser.LEFT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS() { return GetToken(OracleAntlrParser.LESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEVEL() { return GetToken(OracleAntlrParser.LEVEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEVELS() { return GetToken(OracleAntlrParser.LEVELS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIBRARY() { return GetToken(OracleAntlrParser.LIBRARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKE2() { return GetToken(OracleAntlrParser.LIKE2, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKE4() { return GetToken(OracleAntlrParser.LIKE4, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKEC() { return GetToken(OracleAntlrParser.LIKEC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIMIT() { return GetToken(OracleAntlrParser.LIMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIST() { return GetToken(OracleAntlrParser.LIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOB() { return GetToken(OracleAntlrParser.LOB, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOBS() { return GetToken(OracleAntlrParser.LOBS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(OracleAntlrParser.LOCAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCATOR() { return GetToken(OracleAntlrParser.LOCATOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCKED() { return GetToken(OracleAntlrParser.LOCKED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCKING() { return GetToken(OracleAntlrParser.LOCKING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOG() { return GetToken(OracleAntlrParser.LOG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOGGING() { return GetToken(OracleAntlrParser.LOGGING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOGOFF() { return GetToken(OracleAntlrParser.LOGOFF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOGON() { return GetToken(OracleAntlrParser.LOGON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LONG() { return GetToken(OracleAntlrParser.LONG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOW() { return GetToken(OracleAntlrParser.LOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAP() { return GetToken(OracleAntlrParser.MAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAPPING() { return GetToken(OracleAntlrParser.MAPPING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MASTER() { return GetToken(OracleAntlrParser.MASTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATCHED() { return GetToken(OracleAntlrParser.MATCHED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATERIALIZED() { return GetToken(OracleAntlrParser.MATERIALIZED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAX() { return GetToken(OracleAntlrParser.MAX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXSIZE() { return GetToken(OracleAntlrParser.MAXSIZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXTRANS() { return GetToken(OracleAntlrParser.MAXTRANS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXVALUE() { return GetToken(OracleAntlrParser.MAXVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEDIUM() { return GetToken(OracleAntlrParser.MEDIUM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEMBER() { return GetToken(OracleAntlrParser.MEMBER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEMOPTIMIZE() { return GetToken(OracleAntlrParser.MEMOPTIMIZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MERGE() { return GetToken(OracleAntlrParser.MERGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode METADATA() { return GetToken(OracleAntlrParser.METADATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MIN() { return GetToken(OracleAntlrParser.MIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINEXTENTS() { return GetToken(OracleAntlrParser.MINEXTENTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUTE() { return GetToken(OracleAntlrParser.MINUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINVALUE() { return GetToken(OracleAntlrParser.MINVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MOD() { return GetToken(OracleAntlrParser.MOD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MONITORING() { return GetToken(OracleAntlrParser.MONITORING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MONTH() { return GetToken(OracleAntlrParser.MONTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MOVEMENT() { return GetToken(OracleAntlrParser.MOVEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MULTISET() { return GetToken(OracleAntlrParser.MULTISET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAME() { return GetToken(OracleAntlrParser.NAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NATIONAL() { return GetToken(OracleAntlrParser.NATIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NATURAL() { return GetToken(OracleAntlrParser.NATURAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NCHAR() { return GetToken(OracleAntlrParser.NCHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NCHAR_CS() { return GetToken(OracleAntlrParser.NCHAR_CS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NCHR() { return GetToken(OracleAntlrParser.NCHR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NESTED() { return GetToken(OracleAntlrParser.NESTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEVER() { return GetToken(OracleAntlrParser.NEVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(OracleAntlrParser.NEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW_NAMES() { return GetToken(OracleAntlrParser.NEW_NAMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEXT() { return GetToken(OracleAntlrParser.NEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NO() { return GetToken(OracleAntlrParser.NO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCACHE() { return GetToken(OracleAntlrParser.NOCACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCOPY() { return GetToken(OracleAntlrParser.NOCOPY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCYCLE() { return GetToken(OracleAntlrParser.NOCYCLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOEXTEND() { return GetToken(OracleAntlrParser.NOEXTEND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOKEEP() { return GetToken(OracleAntlrParser.NOKEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOLOGGING() { return GetToken(OracleAntlrParser.NOLOGGING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMAPPING() { return GetToken(OracleAntlrParser.NOMAPPING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMAXVALUE() { return GetToken(OracleAntlrParser.NOMAXVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMINVALUE() { return GetToken(OracleAntlrParser.NOMINVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMONITORING() { return GetToken(OracleAntlrParser.NOMONITORING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(OracleAntlrParser.NONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONEDITIONABLE() { return GetToken(OracleAntlrParser.NONEDITIONABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONSCHEMA() { return GetToken(OracleAntlrParser.NONSCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOORDER() { return GetToken(OracleAntlrParser.NOORDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOPARALLEL() { return GetToken(OracleAntlrParser.NOPARALLEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NORELY() { return GetToken(OracleAntlrParser.NORELY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOREVERSE() { return GetToken(OracleAntlrParser.NOREVERSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOROWDEPENDENCIES() { return GetToken(OracleAntlrParser.NOROWDEPENDENCIES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOSCALE() { return GetToken(OracleAntlrParser.NOSCALE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOSHARD() { return GetToken(OracleAntlrParser.NOSHARD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOSORT() { return GetToken(OracleAntlrParser.NOSORT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOTFOUND() { return GetToken(OracleAntlrParser.NOTFOUND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOVALIDATE() { return GetToken(OracleAntlrParser.NOVALIDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULLS() { return GetToken(OracleAntlrParser.NULLS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(OracleAntlrParser.OBJECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OID() { return GetToken(OracleAntlrParser.OID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OIDINDEX() { return GetToken(OracleAntlrParser.OIDINDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OLD() { return GetToken(OracleAntlrParser.OLD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLINE() { return GetToken(OracleAntlrParser.ONLINE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLY() { return GetToken(OracleAntlrParser.ONLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPAQUE() { return GetToken(OracleAntlrParser.OPAQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN() { return GetToken(OracleAntlrParser.OPEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPERATIONS() { return GetToken(OracleAntlrParser.OPERATIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTIMAL() { return GetToken(OracleAntlrParser.OPTIMAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDINALITY() { return GetToken(OracleAntlrParser.ORDINALITY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORGANIZATION() { return GetToken(OracleAntlrParser.ORGANIZATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OUT() { return GetToken(OracleAntlrParser.OUT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OUTER() { return GetToken(OracleAntlrParser.OUTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVER() { return GetToken(OracleAntlrParser.OVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVERFLOW() { return GetToken(OracleAntlrParser.OVERFLOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVERRIDING() { return GetToken(OracleAntlrParser.OVERRIDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVERLAPS() { return GetToken(OracleAntlrParser.OVERLAPS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PACKAGE() { return GetToken(OracleAntlrParser.PACKAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARALLEL() { return GetToken(OracleAntlrParser.PARALLEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARALLEL_ENABLE() { return GetToken(OracleAntlrParser.PARALLEL_ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARAMETERS() { return GetToken(OracleAntlrParser.PARAMETERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARENT() { return GetToken(OracleAntlrParser.PARENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTIAL() { return GetToken(OracleAntlrParser.PARTIAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITIONS() { return GetToken(OracleAntlrParser.PARTITIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSING() { return GetToken(OracleAntlrParser.PASSING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORD() { return GetToken(OracleAntlrParser.PASSWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(OracleAntlrParser.PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTINCREASE() { return GetToken(OracleAntlrParser.PCTINCREASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTTHRESHOLD() { return GetToken(OracleAntlrParser.PCTTHRESHOLD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTUSED() { return GetToken(OracleAntlrParser.PCTUSED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTVERSION() { return GetToken(OracleAntlrParser.PCTVERSION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENTILE_DISC() { return GetToken(OracleAntlrParser.PERCENTILE_DISC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERIOD() { return GetToken(OracleAntlrParser.PERIOD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PIPE() { return GetToken(OracleAntlrParser.PIPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PIPELINED() { return GetToken(OracleAntlrParser.PIPELINED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POLYMORPHIC() { return GetToken(OracleAntlrParser.POLYMORPHIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRAGMA() { return GetToken(OracleAntlrParser.PRAGMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PREBUILT() { return GetToken(OracleAntlrParser.PREBUILT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRECEDING() { return GetToken(OracleAntlrParser.PRECEDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRECISION() { return GetToken(OracleAntlrParser.PRECISION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRESERVE() { return GetToken(OracleAntlrParser.PRESERVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIMARY() { return GetToken(OracleAntlrParser.PRIMARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIOR() { return GetToken(OracleAntlrParser.PRIOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIVATE() { return GetToken(OracleAntlrParser.PRIVATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROCEDURE() { return GetToken(OracleAntlrParser.PROCEDURE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROFILE() { return GetToken(OracleAntlrParser.PROFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PUBLIC() { return GetToken(OracleAntlrParser.PUBLIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PURGE() { return GetToken(OracleAntlrParser.PURGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUERY() { return GetToken(OracleAntlrParser.QUERY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTA() { return GetToken(OracleAntlrParser.QUOTA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RAISE() { return GetToken(OracleAntlrParser.RAISE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RAISE_APPLICATION_ERROR() { return GetToken(OracleAntlrParser.RAISE_APPLICATION_ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(OracleAntlrParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RAW() { return GetToken(OracleAntlrParser.RAW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READ() { return GetToken(OracleAntlrParser.READ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READS() { return GetToken(OracleAntlrParser.READS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REBUILD() { return GetToken(OracleAntlrParser.REBUILD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RECORD() { return GetToken(OracleAntlrParser.RECORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RECYCLE() { return GetToken(OracleAntlrParser.RECYCLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REDUCED() { return GetToken(OracleAntlrParser.REDUCED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REF() { return GetToken(OracleAntlrParser.REF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFERENCES() { return GetToken(OracleAntlrParser.REFERENCES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFERENCING() { return GetToken(OracleAntlrParser.REFERENCING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFRESH() { return GetToken(OracleAntlrParser.REFRESH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REJECT() { return GetToken(OracleAntlrParser.REJECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONAL() { return GetToken(OracleAntlrParser.RELATIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELIES_ON() { return GetToken(OracleAntlrParser.RELIES_ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELY() { return GetToken(OracleAntlrParser.RELY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RENAME() { return GetToken(OracleAntlrParser.RENAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPLACE() { return GetToken(OracleAntlrParser.REPLACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RESTRICT_REFERENCES() { return GetToken(OracleAntlrParser.RESTRICT_REFERENCES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RESULT() { return GetToken(OracleAntlrParser.RESULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RESULT_CACHE() { return GetToken(OracleAntlrParser.RESULT_CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETENTION() { return GetToken(OracleAntlrParser.RETENTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURNING() { return GetToken(OracleAntlrParser.RETURNING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REUSE() { return GetToken(OracleAntlrParser.REUSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REVERSE() { return GetToken(OracleAntlrParser.REVERSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REWRITE() { return GetToken(OracleAntlrParser.REWRITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RIGHT() { return GetToken(OracleAntlrParser.RIGHT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLLUP() { return GetToken(OracleAntlrParser.ROLLUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWCOUNT() { return GetToken(OracleAntlrParser.ROWCOUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWDEPENDENCIES() { return GetToken(OracleAntlrParser.ROWDEPENDENCIES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWID() { return GetToken(OracleAntlrParser.ROWID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWTYPE() { return GetToken(OracleAntlrParser.ROWTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SALT() { return GetToken(OracleAntlrParser.SALT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SAMPLE() { return GetToken(OracleAntlrParser.SAMPLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SAVE() { return GetToken(OracleAntlrParser.SAVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SAVEPOINT() { return GetToken(OracleAntlrParser.SAVEPOINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCALE() { return GetToken(OracleAntlrParser.SCALE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCHEMA() { return GetToken(OracleAntlrParser.SCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCN() { return GetToken(OracleAntlrParser.SCN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCOPE() { return GetToken(OracleAntlrParser.SCOPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEARCH() { return GetToken(OracleAntlrParser.SEARCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECOND() { return GetToken(OracleAntlrParser.SECOND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECUREFILE() { return GetToken(OracleAntlrParser.SECUREFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEED() { return GetToken(OracleAntlrParser.SEED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEGMENT() { return GetToken(OracleAntlrParser.SEGMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SELF() { return GetToken(OracleAntlrParser.SELF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEQUENCE() { return GetToken(OracleAntlrParser.SEQUENCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERIALIZABLE() { return GetToken(OracleAntlrParser.SERIALIZABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERIALLY_REUSABLE() { return GetToken(OracleAntlrParser.SERIALLY_REUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVERERROR() { return GetToken(OracleAntlrParser.SERVERERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SESSION() { return GetToken(OracleAntlrParser.SESSION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SESSIONTIMEZONE() { return GetToken(OracleAntlrParser.SESSIONTIMEZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETS() { return GetToken(OracleAntlrParser.SETS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETTINGS() { return GetToken(OracleAntlrParser.SETTINGS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARD() { return GetToken(OracleAntlrParser.SHARD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARDED() { return GetToken(OracleAntlrParser.SHARDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARING() { return GetToken(OracleAntlrParser.SHARING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHRINK() { return GetToken(OracleAntlrParser.SHRINK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHUTDOWN() { return GetToken(OracleAntlrParser.SHUTDOWN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIBLINGS() { return GetToken(OracleAntlrParser.SIBLINGS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIZE() { return GetToken(OracleAntlrParser.SIZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SKIP_() { return GetToken(OracleAntlrParser.SKIP_, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SOME() { return GetToken(OracleAntlrParser.SOME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SORT() { return GetToken(OracleAntlrParser.SORT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SPACE() { return GetToken(OracleAntlrParser.SPACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SPECIFICATION() { return GetToken(OracleAntlrParser.SPECIFICATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SPLIT() { return GetToken(OracleAntlrParser.SPLIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STARTUP() { return GetToken(OracleAntlrParser.STARTUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATEMENT() { return GetToken(OracleAntlrParser.STATEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATIC() { return GetToken(OracleAntlrParser.STATIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATISTICS() { return GetToken(OracleAntlrParser.STATISTICS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORAGE() { return GetToken(OracleAntlrParser.STORAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING() { return GetToken(OracleAntlrParser.STRING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBMULTISET() { return GetToken(OracleAntlrParser.SUBMULTISET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITIONS() { return GetToken(OracleAntlrParser.SUBPARTITIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBSTITUTABLE() { return GetToken(OracleAntlrParser.SUBSTITUTABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBTYPE() { return GetToken(OracleAntlrParser.SUBTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUPPLEMENTAL() { return GetToken(OracleAntlrParser.SUPPLEMENTAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUSPEND() { return GetToken(OracleAntlrParser.SUSPEND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SYNONYM() { return GetToken(OracleAntlrParser.SYNONYM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SYSTEM() { return GetToken(OracleAntlrParser.SYSTEM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLES() { return GetToken(OracleAntlrParser.TABLES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLESPACE() { return GetToken(OracleAntlrParser.TABLESPACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEMPLATE() { return GetToken(OracleAntlrParser.TEMPLATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEMPORARY() { return GetToken(OracleAntlrParser.TEMPORARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THAN() { return GetToken(OracleAntlrParser.THAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIME() { return GetToken(OracleAntlrParser.TIME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMESTAMP() { return GetToken(OracleAntlrParser.TIMESTAMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_ABBR() { return GetToken(OracleAntlrParser.TIMEZONE_ABBR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_HOUR() { return GetToken(OracleAntlrParser.TIMEZONE_HOUR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_MINUTE() { return GetToken(OracleAntlrParser.TIMEZONE_MINUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_REGION() { return GetToken(OracleAntlrParser.TIMEZONE_REGION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRAILING() { return GetToken(OracleAntlrParser.TRAILING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRANSACTION() { return GetToken(OracleAntlrParser.TRANSACTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRANSLATE() { return GetToken(OracleAntlrParser.TRANSLATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TREAT() { return GetToken(OracleAntlrParser.TREAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIM() { return GetToken(OracleAntlrParser.TRIM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUE() { return GetToken(OracleAntlrParser.TRUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUNCATE() { return GetToken(OracleAntlrParser.TRUNCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUSTED() { return GetToken(OracleAntlrParser.TRUSTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNBOUNDED() { return GetToken(OracleAntlrParser.UNBOUNDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNCONDITIONAL() { return GetToken(OracleAntlrParser.UNCONDITIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNDER() { return GetToken(OracleAntlrParser.UNDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNLIMITED() { return GetToken(OracleAntlrParser.UNLIMITED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNLOCK() { return GetToken(OracleAntlrParser.UNLOCK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSED() { return GetToken(OracleAntlrParser.UNUSED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USABLE() { return GetToken(OracleAntlrParser.USABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USAGE() { return GetToken(OracleAntlrParser.USAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USE() { return GetToken(OracleAntlrParser.USE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(OracleAntlrParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALIDATE() { return GetToken(OracleAntlrParser.VALIDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(OracleAntlrParser.VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARCHAR() { return GetToken(OracleAntlrParser.VARCHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARCHAR2() { return GetToken(OracleAntlrParser.VARCHAR2, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARRAY() { return GetToken(OracleAntlrParser.VARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARRAYS() { return GetToken(OracleAntlrParser.VARRAYS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARYING() { return GetToken(OracleAntlrParser.VARYING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VERSIONS() { return GetToken(OracleAntlrParser.VERSIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VIRTUAL() { return GetToken(OracleAntlrParser.VIRTUAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VISIBLE() { return GetToken(OracleAntlrParser.VISIBLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WAIT() { return GetToken(OracleAntlrParser.WAIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITHIN() { return GetToken(OracleAntlrParser.WITHIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITHOUT() { return GetToken(OracleAntlrParser.WITHOUT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WORK() { return GetToken(OracleAntlrParser.WORK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRAPPED() { return GetToken(OracleAntlrParser.WRAPPED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRAPPER() { return GetToken(OracleAntlrParser.WRAPPER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRITE() { return GetToken(OracleAntlrParser.WRITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XML() { return GetToken(OracleAntlrParser.XML, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLNAMESPACES() { return GetToken(OracleAntlrParser.XMLNAMESPACES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLSCHEMA() { return GetToken(OracleAntlrParser.XMLSCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLTABLE() { return GetToken(OracleAntlrParser.XMLTABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLTYPE() { return GetToken(OracleAntlrParser.XMLTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode YEAR() { return GetToken(OracleAntlrParser.YEAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ZONE() { return GetToken(OracleAntlrParser.ZONE, 0); }
		public SimpleIdentifierRegularIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleIdentifierRegularIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSimpleIdentifierRegularIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSimpleIdentifierRegularIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier() {
		SimpleIdentifierRegularIdentifierContext _localctx = new SimpleIdentifierRegularIdentifierContext(Context, State);
		EnterRule(_localctx, 60, RULE_simpleIdentifierRegularIdentifier);
		int _la;
		try {
			State = 1924;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case REGULAR_IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1922;
				Match(REGULAR_IDENTIFIER);
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1923;
				_la = TokenStream.LA(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DotInIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(OracleAntlrParser.DOT, 0); }
		public DotInIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dotInIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDotInIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDotInIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public DotInIdentifierContext dotInIdentifier() {
		DotInIdentifierContext _localctx = new DotInIdentifierContext(Context, State);
		EnterRule(_localctx, 62, RULE_dotInIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1926;
			Match(DOT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext[] simpleIdentifier() {
			return GetRuleContexts<SimpleIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier(int i) {
			return GetRuleContext<SimpleIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext[] dotInIdentifier() {
			return GetRuleContexts<DotInIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext dotInIdentifier(int i) {
			return GetRuleContext<DotInIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NestedCollectionSimpleIdentifierContext[] nestedCollectionSimpleIdentifier() {
			return GetRuleContexts<NestedCollectionSimpleIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NestedCollectionSimpleIdentifierContext nestedCollectionSimpleIdentifier(int i) {
			return GetRuleContext<NestedCollectionSimpleIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS_SIGN() { return GetToken(OracleAntlrParser.PLUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AsteriskContext[] asterisk() {
			return GetRuleContexts<AsteriskContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AsteriskContext asterisk(int i) {
			return GetRuleContext<AsteriskContext>(i);
		}
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(Context, State);
		EnterRule(_localctx, 64, RULE_identifier);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1928;
			simpleIdentifier();
			State = 1937;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,28,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 1935;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case DOT:
						{
						State = 1929;
						dotInIdentifier();
						State = 1932;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case A_:
						case ACCOUNT:
						case ADVANCED:
						case AFTER:
						case AGENT:
						case AGGREGATE:
						case ALLOCATE:
						case ALLOW:
						case ALWAYS:
						case ANALYZE:
						case ANYSCHEMA:
						case ARCHIVE:
						case ARRAY:
						case ASSOCIATE:
						case AT:
						case ATTRIBUTE:
						case ATTRIBUTES:
						case AUTHENTICATION:
						case AUTHID:
						case AUTO:
						case AUTONOMOUS_TRANSACTION:
						case BASIC:
						case BASICFILE:
						case BATCH:
						case BEFORE:
						case BEGINNING:
						case BINARY:
						case BITMAP:
						case BLOCK:
						case BODY:
						case BOTH:
						case BREADTH:
						case BUFFER_POOL:
						case BUILD:
						case BUILTIN:
						case BULK:
						case BULK_EXCEPTIONS:
						case BULK_ROWCOUNT:
						case BYTE:
						case C_:
						case CACHE:
						case CALL:
						case CASCADE:
						case CAST:
						case CELL_FLASH_CACHE:
						case CHAR:
						case CHAR_CS:
						case CHARACTER:
						case CHARSET:
						case CHR:
						case CHUNK:
						case CLOB:
						case CLOSE:
						case COALESCE:
						case COLLATION:
						case COLLECT:
						case COLUMN_VALUE:
						case COMMIT:
						case COMMITTED:
						case COMPACT:
						case COMPILE:
						case COMPLETE:
						case COMPOUND:
						case COMPUTATION:
						case COMPUTE:
						case CONDITIONAL:
						case CONSTANT:
						case CONSTRAINT:
						case CONSTRAINTS:
						case CONSTRUCTOR:
						case CONTAINER:
						case CONTEXT:
						case CONTINUE:
						case CONVERT:
						case COUNT:
						case CREATION:
						case CROSS:
						case CUBE:
						case CURRENT_USER:
						case CYCLE:
						case DATA:
						case DATABASE:
						case DATAFILE:
						case DATE:
						case DAY:
						case DBTIMEZONE:
						case DDL:
						case DEALLOCATE:
						case DEBUG:
						case DECODE:
						case DECRYPT:
						case DEDUPLICATE:
						case DEFERRABLE:
						case DEFERRED:
						case DEFINER:
						case DELETE:
						case DEMAND:
						case DENSE_RANK:
						case DEPTH:
						case DETERMINISTIC:
						case DIRECT_LOAD:
						case DISABLE:
						case DISALLOW:
						case DISASSOCIATE:
						case DOUBLE:
						case DUPLICATED:
						case EACH:
						case EDITION:
						case EDITIONABLE:
						case EDITIONING:
						case EDITIONS:
						case ELEMENT:
						case ELSIF:
						case EMPTY_KEYWORD:
						case ENABLE:
						case ENCRYPT:
						case ENFORCED:
						case ERROR_CODE:
						case ERROR_INDEX:
						case ERROR:
						case ERRORS:
						case ESCAPE:
						case EVALUATE:
						case EXCEPT:
						case EXCEPTION_INIT:
						case EXCEPTIONS:
						case EXCLUDE:
						case EXECUTE:
						case EXISTS:
						case EXIT:
						case EXPIRE:
						case EXTEND:
						case EXTENDED:
						case EXTENT:
						case EXTERNALLY:
						case EXTRACT:
						case FALSE:
						case FAST:
						case FILESYSTEM_LIKE_LOGGING:
						case FINAL:
						case FIPSFLAG:
						case FIRST:
						case FIRST_ROWS:
						case FIXED:
						case FOLLOWING:
						case FORALL:
						case FORCE:
						case FOREIGN:
						case FORMAT:
						case FOUND:
						case FLASH_CACHE:
						case FREELIST:
						case FREELISTS:
						case FREEPOOLS:
						case FULL:
						case FUNCTION:
						case GENERATED:
						case GLOBAL:
						case GLOBALLY:
						case GROUPING:
						case GROUPS:
						case HASH:
						case HEAP:
						case HIGH:
						case HOUR:
						case ID:
						case IDENTIFIER:
						case IDENTITY:
						case INCLUDE:
						case INCLUDING:
						case INDEXING:
						case INDICATOR:
						case INDICES:
						case INITIALLY:
						case INITRANS:
						case INNER:
						case INSTANCE:
						case INSTANTIABLE:
						case INSTEAD:
						case INTERFACE:
						case INTERVAL:
						case INVALIDATE:
						case INVALIDATION:
						case INVISIBLE:
						case ISOLATION:
						case ISOPEN:
						case JAVA:
						case JOIN:
						case JSON:
						case JSON_TABLE:
						case KEEP:
						case KEEP_DUPLICATES:
						case KEY:
						case LANGUAGE:
						case LAST:
						case LEADING:
						case LEFT:
						case LESS:
						case LEVEL:
						case LEVELS:
						case LIBRARY:
						case LIKE2:
						case LIKE4:
						case LIKEC:
						case LIMIT:
						case LIST:
						case LOB:
						case LOBS:
						case LOCAL:
						case LOCATOR:
						case LOCKED:
						case LOCKING:
						case LOG:
						case LOGGING:
						case LOGOFF:
						case LOGON:
						case LONG:
						case LOW:
						case MAP:
						case MAPPING:
						case MASTER:
						case MATCHED:
						case MATERIALIZED:
						case MAX:
						case MAXSIZE:
						case MAXTRANS:
						case MAXVALUE:
						case MEDIUM:
						case MEMBER:
						case MEMOPTIMIZE:
						case MERGE:
						case METADATA:
						case MIN:
						case MINEXTENTS:
						case MINUTE:
						case MINVALUE:
						case MOD:
						case MONITORING:
						case MONTH:
						case MOVEMENT:
						case MULTISET:
						case NAME:
						case NATIONAL:
						case NATURAL:
						case NCHAR:
						case NCHAR_CS:
						case NCHR:
						case NESTED:
						case NEVER:
						case NEW:
						case NEW_NAMES:
						case NEXT:
						case NO:
						case NOCACHE:
						case NOCOPY:
						case NOCYCLE:
						case NOEXTEND:
						case NOKEEP:
						case NOLOGGING:
						case NOMAPPING:
						case NOMAXVALUE:
						case NOMINVALUE:
						case NOMONITORING:
						case NOORDER:
						case NONE:
						case NONEDITIONABLE:
						case NONSCHEMA:
						case NOPARALLEL:
						case NORELY:
						case NOREVERSE:
						case NOROWDEPENDENCIES:
						case NOSCALE:
						case NOSHARD:
						case NOSORT:
						case NOTFOUND:
						case NOVALIDATE:
						case NULLS:
						case OBJECT:
						case OID:
						case OIDINDEX:
						case OLD:
						case ONLY:
						case ONLINE:
						case OPAQUE:
						case OPEN:
						case OPERATIONS:
						case OPTIMAL:
						case ORDINALITY:
						case ORGANIZATION:
						case OUT:
						case OUTER:
						case OVER:
						case OVERFLOW:
						case OVERLAPS:
						case OVERRIDING:
						case PACKAGE:
						case PARALLEL:
						case PARALLEL_ENABLE:
						case PARAMETERS:
						case PARENT:
						case PARTIAL:
						case PARTITION:
						case PARTITIONS:
						case PASSING:
						case PASSWORD:
						case PATH:
						case PCTINCREASE:
						case PCTTHRESHOLD:
						case PCTUSED:
						case PCTVERSION:
						case PERCENTILE_DISC:
						case PERIOD:
						case PIPE:
						case PIPELINED:
						case POLYMORPHIC:
						case PRAGMA:
						case PREBUILT:
						case PRECEDING:
						case PRECISION:
						case PRESERVE:
						case PRIMARY:
						case PRIOR:
						case PRIVATE:
						case PROCEDURE:
						case PROFILE:
						case PUBLIC:
						case PURGE:
						case QUERY:
						case QUOTA:
						case RAISE:
						case RAISE_APPLICATION_ERROR:
						case RANGE:
						case RAW:
						case READ:
						case READS:
						case REBUILD:
						case RECORD:
						case RECYCLE:
						case REDUCED:
						case REF:
						case REFERENCES:
						case REFERENCING:
						case REFRESH:
						case REJECT:
						case RELATIONAL:
						case RELIES_ON:
						case RELY:
						case RENAME:
						case REPLACE:
						case RESTRICT_REFERENCES:
						case RESULT:
						case RESULT_CACHE:
						case RETENTION:
						case RETURNING:
						case REUSE:
						case REVERSE:
						case REWRITE:
						case RIGHT:
						case ROLLUP:
						case ROW:
						case ROWCOUNT:
						case ROWDEPENDENCIES:
						case ROWID:
						case ROWTYPE:
						case SALT:
						case SAMPLE:
						case SAVE:
						case SAVEPOINT:
						case SCALE:
						case SCHEMA:
						case SCN:
						case SCOPE:
						case SEARCH:
						case SECOND:
						case SECUREFILE:
						case SEED:
						case SEGMENT:
						case SELF:
						case SEQUENCE:
						case SERIALIZABLE:
						case SERIALLY_REUSABLE:
						case SERVERERROR:
						case SESSION:
						case SESSIONTIMEZONE:
						case SET:
						case SETS:
						case SETTINGS:
						case SHRINK:
						case SHUTDOWN:
						case SIBLINGS:
						case SIZE:
						case SKIP_:
						case SOME:
						case SORT:
						case SPACE:
						case SPECIFICATION:
						case SPLIT:
						case STARTUP:
						case STATEMENT:
						case STATIC:
						case STATISTICS:
						case STORAGE:
						case STORE:
						case STRING:
						case SHARD:
						case SHARDED:
						case SHARING:
						case SUBMULTISET:
						case SUBPARTITION:
						case SUBPARTITIONS:
						case SUBSTITUTABLE:
						case SUBTYPE:
						case SUPPLEMENTAL:
						case SUSPEND:
						case SYNONYM:
						case SYSTEM:
						case TABLES:
						case TABLESPACE:
						case TEMPLATE:
						case TEMPORARY:
						case THAN:
						case TIME:
						case TIMESTAMP:
						case TIMEZONE_ABBR:
						case TIMEZONE_HOUR:
						case TIMEZONE_MINUTE:
						case TIMEZONE_REGION:
						case TRAILING:
						case TRANSACTION:
						case TRANSLATE:
						case TREAT:
						case TRIM:
						case TRUE:
						case TRUNCATE:
						case TRUSTED:
						case TYPE:
						case UNBOUNDED:
						case UNCONDITIONAL:
						case UNDER:
						case UNLIMITED:
						case UNLOCK:
						case UNUSABLE:
						case UNUSED:
						case USABLE:
						case USAGE:
						case USE:
						case USER:
						case USING:
						case VALIDATE:
						case VALUE:
						case VARCHAR:
						case VARCHAR2:
						case VARRAY:
						case VARRAYS:
						case VARYING:
						case VERSIONS:
						case VIRTUAL:
						case VISIBLE:
						case WAIT:
						case WHEN:
						case WITHIN:
						case WITHOUT:
						case WORK:
						case WRAPPED:
						case WRAPPER:
						case WRITE:
						case XML:
						case XMLNAMESPACES:
						case XMLSCHEMA:
						case XMLTABLE:
						case XMLTYPE:
						case YEAR:
						case ZONE:
						case REGULAR_IDENTIFIER:
						case QUOTED_IDENTIFIER:
							{
							State = 1930;
							simpleIdentifier();
							}
							break;
						case ASTERISK:
							{
							State = 1931;
							asterisk();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						break;
					case LPAREN:
						{
						State = 1934;
						nestedCollectionSimpleIdentifier();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 1939;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,28,Context);
			}
			State = 1943;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,29,Context) ) {
			case 1:
				{
				State = 1940;
				Match(LPAREN);
				State = 1941;
				Match(PLUS_SIGN);
				State = 1942;
				Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlainIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext[] simpleIdentifierWithoutParentheses() {
			return GetRuleContexts<SimpleIdentifierWithoutParenthesesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses(int i) {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext[] dotInIdentifier() {
			return GetRuleContexts<DotInIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext dotInIdentifier(int i) {
			return GetRuleContext<DotInIdentifierContext>(i);
		}
		public PlainIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plainIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPlainIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPlainIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public PlainIdentifierContext plainIdentifier() {
		PlainIdentifierContext _localctx = new PlainIdentifierContext(Context, State);
		EnterRule(_localctx, 66, RULE_plainIdentifier);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1945;
			simpleIdentifierWithoutParentheses();
			State = 1951;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,30,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1946;
					dotInIdentifier();
					State = 1947;
					simpleIdentifierWithoutParentheses();
					}
					} 
				}
				State = 1953;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,30,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlainRemoteIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext[] simpleIdentifierWithoutParentheses() {
			return GetRuleContexts<SimpleIdentifierWithoutParenthesesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses(int i) {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext[] dotInIdentifier() {
			return GetRuleContexts<DotInIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext dotInIdentifier(int i) {
			return GetRuleContext<DotInIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DbLinkContext dbLink() {
			return GetRuleContext<DbLinkContext>(0);
		}
		public PlainRemoteIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plainRemoteIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPlainRemoteIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPlainRemoteIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public PlainRemoteIdentifierContext plainRemoteIdentifier() {
		PlainRemoteIdentifierContext _localctx = new PlainRemoteIdentifierContext(Context, State);
		EnterRule(_localctx, 68, RULE_plainRemoteIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1954;
			simpleIdentifierWithoutParentheses();
			State = 1960;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DOT) {
				{
				{
				State = 1955;
				dotInIdentifier();
				State = 1956;
				simpleIdentifierWithoutParentheses();
				}
				}
				State = 1962;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1964;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AT_SIGN) {
				{
				State = 1963;
				dbLink();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultipartPlainIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext[] simpleIdentifierWithoutParentheses() {
			return GetRuleContexts<SimpleIdentifierWithoutParenthesesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses(int i) {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext[] dotInIdentifier() {
			return GetRuleContexts<DotInIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotInIdentifierContext dotInIdentifier(int i) {
			return GetRuleContext<DotInIdentifierContext>(i);
		}
		public MultipartPlainIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multipartPlainIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMultipartPlainIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMultipartPlainIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public MultipartPlainIdentifierContext multipartPlainIdentifier() {
		MultipartPlainIdentifierContext _localctx = new MultipartPlainIdentifierContext(Context, State);
		EnterRule(_localctx, 70, RULE_multipartPlainIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1966;
			simpleIdentifierWithoutParentheses();
			State = 1970;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 1967;
				dotInIdentifier();
				State = 1968;
				simpleIdentifierWithoutParentheses();
				}
				}
				State = 1972;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==DOT );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsteriskContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASTERISK() { return GetToken(OracleAntlrParser.ASTERISK, 0); }
		public AsteriskContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asterisk; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAsterisk(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAsterisk(this);
		}
	}

	[RuleVersion(0)]
	public AsteriskContext asterisk() {
		AsteriskContext _localctx = new AsteriskContext(Context, State);
		EnterRule(_localctx, 72, RULE_asterisk);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1974;
			Match(ASTERISK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DbLinkContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] AT_SIGN() { return GetTokens(OracleAntlrParser.AT_SIGN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT_SIGN(int i) {
			return GetToken(OracleAntlrParser.AT_SIGN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext[] simpleIdentifierRegularIdentifier() {
			return GetRuleContexts<SimpleIdentifierRegularIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier(int i) {
			return GetRuleContext<SimpleIdentifierRegularIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] QUOTED_IDENTIFIER() { return GetTokens(OracleAntlrParser.QUOTED_IDENTIFIER); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTED_IDENTIFIER(int i) {
			return GetToken(OracleAntlrParser.QUOTED_IDENTIFIER, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] DOT() { return GetTokens(OracleAntlrParser.DOT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT(int i) {
			return GetToken(OracleAntlrParser.DOT, i);
		}
		public DbLinkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dbLink; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDbLink(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDbLink(this);
		}
	}

	[RuleVersion(0)]
	public DbLinkContext dbLink() {
		DbLinkContext _localctx = new DbLinkContext(Context, State);
		EnterRule(_localctx, 74, RULE_dbLink);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1976;
			Match(AT_SIGN);
			State = 1979;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
				{
				State = 1977;
				simpleIdentifierRegularIdentifier();
				}
				break;
			case QUOTED_IDENTIFIER:
				{
				State = 1978;
				Match(QUOTED_IDENTIFIER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1988;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,36,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1981;
					_la = TokenStream.LA(1);
					if ( !(_la==AT_SIGN || _la==DOT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 1984;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case A_:
					case ACCOUNT:
					case ADVANCED:
					case AFTER:
					case AGENT:
					case AGGREGATE:
					case ALLOCATE:
					case ALLOW:
					case ALWAYS:
					case ANALYZE:
					case ANYSCHEMA:
					case ARCHIVE:
					case ARRAY:
					case ASSOCIATE:
					case AT:
					case ATTRIBUTE:
					case ATTRIBUTES:
					case AUTHENTICATION:
					case AUTHID:
					case AUTO:
					case AUTONOMOUS_TRANSACTION:
					case BASIC:
					case BASICFILE:
					case BATCH:
					case BEFORE:
					case BEGINNING:
					case BINARY:
					case BITMAP:
					case BLOCK:
					case BODY:
					case BOTH:
					case BREADTH:
					case BUFFER_POOL:
					case BUILD:
					case BUILTIN:
					case BULK:
					case BULK_EXCEPTIONS:
					case BULK_ROWCOUNT:
					case BYTE:
					case C_:
					case CACHE:
					case CALL:
					case CASCADE:
					case CAST:
					case CELL_FLASH_CACHE:
					case CHAR:
					case CHAR_CS:
					case CHARACTER:
					case CHARSET:
					case CHR:
					case CHUNK:
					case CLOB:
					case CLOSE:
					case COALESCE:
					case COLLATION:
					case COLLECT:
					case COLUMN_VALUE:
					case COMMIT:
					case COMMITTED:
					case COMPACT:
					case COMPILE:
					case COMPLETE:
					case COMPOUND:
					case COMPUTATION:
					case COMPUTE:
					case CONDITIONAL:
					case CONSTANT:
					case CONSTRAINT:
					case CONSTRAINTS:
					case CONSTRUCTOR:
					case CONTAINER:
					case CONTEXT:
					case CONTINUE:
					case CONVERT:
					case COUNT:
					case CREATION:
					case CROSS:
					case CUBE:
					case CURRENT_USER:
					case CYCLE:
					case DATA:
					case DATABASE:
					case DATAFILE:
					case DATE:
					case DAY:
					case DBTIMEZONE:
					case DDL:
					case DEALLOCATE:
					case DEBUG:
					case DECODE:
					case DECRYPT:
					case DEDUPLICATE:
					case DEFERRABLE:
					case DEFERRED:
					case DEFINER:
					case DELETE:
					case DEMAND:
					case DENSE_RANK:
					case DEPTH:
					case DETERMINISTIC:
					case DIRECT_LOAD:
					case DISABLE:
					case DISALLOW:
					case DISASSOCIATE:
					case DOUBLE:
					case DUPLICATED:
					case EACH:
					case EDITION:
					case EDITIONABLE:
					case EDITIONING:
					case EDITIONS:
					case ELEMENT:
					case ELSIF:
					case EMPTY_KEYWORD:
					case ENABLE:
					case ENCRYPT:
					case ENFORCED:
					case ERROR_CODE:
					case ERROR_INDEX:
					case ERROR:
					case ERRORS:
					case ESCAPE:
					case EVALUATE:
					case EXCEPT:
					case EXCEPTION_INIT:
					case EXCEPTIONS:
					case EXCLUDE:
					case EXECUTE:
					case EXISTS:
					case EXIT:
					case EXPIRE:
					case EXTEND:
					case EXTENDED:
					case EXTENT:
					case EXTERNALLY:
					case EXTRACT:
					case FALSE:
					case FAST:
					case FILESYSTEM_LIKE_LOGGING:
					case FINAL:
					case FIPSFLAG:
					case FIRST:
					case FIRST_ROWS:
					case FIXED:
					case FOLLOWING:
					case FORALL:
					case FORCE:
					case FOREIGN:
					case FORMAT:
					case FOUND:
					case FLASH_CACHE:
					case FREELIST:
					case FREELISTS:
					case FREEPOOLS:
					case FULL:
					case FUNCTION:
					case GENERATED:
					case GLOBAL:
					case GLOBALLY:
					case GROUPING:
					case GROUPS:
					case HASH:
					case HEAP:
					case HIGH:
					case HOUR:
					case ID:
					case IDENTIFIER:
					case IDENTITY:
					case INCLUDE:
					case INCLUDING:
					case INDEXING:
					case INDICATOR:
					case INDICES:
					case INITIALLY:
					case INITRANS:
					case INNER:
					case INSTANCE:
					case INSTANTIABLE:
					case INSTEAD:
					case INTERFACE:
					case INTERVAL:
					case INVALIDATE:
					case INVALIDATION:
					case INVISIBLE:
					case ISOLATION:
					case ISOPEN:
					case JAVA:
					case JOIN:
					case JSON:
					case JSON_TABLE:
					case KEEP:
					case KEEP_DUPLICATES:
					case KEY:
					case LANGUAGE:
					case LAST:
					case LEADING:
					case LEFT:
					case LESS:
					case LEVEL:
					case LEVELS:
					case LIBRARY:
					case LIKE2:
					case LIKE4:
					case LIKEC:
					case LIMIT:
					case LIST:
					case LOB:
					case LOBS:
					case LOCAL:
					case LOCATOR:
					case LOCKED:
					case LOCKING:
					case LOG:
					case LOGGING:
					case LOGOFF:
					case LOGON:
					case LONG:
					case LOW:
					case MAP:
					case MAPPING:
					case MASTER:
					case MATCHED:
					case MATERIALIZED:
					case MAX:
					case MAXSIZE:
					case MAXTRANS:
					case MAXVALUE:
					case MEDIUM:
					case MEMBER:
					case MEMOPTIMIZE:
					case MERGE:
					case METADATA:
					case MIN:
					case MINEXTENTS:
					case MINUTE:
					case MINVALUE:
					case MOD:
					case MONITORING:
					case MONTH:
					case MOVEMENT:
					case MULTISET:
					case NAME:
					case NATIONAL:
					case NATURAL:
					case NCHAR:
					case NCHAR_CS:
					case NCHR:
					case NESTED:
					case NEVER:
					case NEW:
					case NEW_NAMES:
					case NEXT:
					case NO:
					case NOCACHE:
					case NOCOPY:
					case NOCYCLE:
					case NOEXTEND:
					case NOKEEP:
					case NOLOGGING:
					case NOMAPPING:
					case NOMAXVALUE:
					case NOMINVALUE:
					case NOMONITORING:
					case NOORDER:
					case NONE:
					case NONEDITIONABLE:
					case NONSCHEMA:
					case NOPARALLEL:
					case NORELY:
					case NOREVERSE:
					case NOROWDEPENDENCIES:
					case NOSCALE:
					case NOSHARD:
					case NOSORT:
					case NOTFOUND:
					case NOVALIDATE:
					case NULLS:
					case OBJECT:
					case OID:
					case OIDINDEX:
					case OLD:
					case ONLY:
					case ONLINE:
					case OPAQUE:
					case OPEN:
					case OPERATIONS:
					case OPTIMAL:
					case ORDINALITY:
					case ORGANIZATION:
					case OUT:
					case OUTER:
					case OVER:
					case OVERFLOW:
					case OVERLAPS:
					case OVERRIDING:
					case PACKAGE:
					case PARALLEL:
					case PARALLEL_ENABLE:
					case PARAMETERS:
					case PARENT:
					case PARTIAL:
					case PARTITION:
					case PARTITIONS:
					case PASSING:
					case PASSWORD:
					case PATH:
					case PCTINCREASE:
					case PCTTHRESHOLD:
					case PCTUSED:
					case PCTVERSION:
					case PERCENTILE_DISC:
					case PERIOD:
					case PIPE:
					case PIPELINED:
					case POLYMORPHIC:
					case PRAGMA:
					case PREBUILT:
					case PRECEDING:
					case PRECISION:
					case PRESERVE:
					case PRIMARY:
					case PRIOR:
					case PRIVATE:
					case PROCEDURE:
					case PROFILE:
					case PUBLIC:
					case PURGE:
					case QUERY:
					case QUOTA:
					case RAISE:
					case RAISE_APPLICATION_ERROR:
					case RANGE:
					case RAW:
					case READ:
					case READS:
					case REBUILD:
					case RECORD:
					case RECYCLE:
					case REDUCED:
					case REF:
					case REFERENCES:
					case REFERENCING:
					case REFRESH:
					case REJECT:
					case RELATIONAL:
					case RELIES_ON:
					case RELY:
					case RENAME:
					case REPLACE:
					case RESTRICT_REFERENCES:
					case RESULT:
					case RESULT_CACHE:
					case RETENTION:
					case RETURNING:
					case REUSE:
					case REVERSE:
					case REWRITE:
					case RIGHT:
					case ROLLUP:
					case ROW:
					case ROWCOUNT:
					case ROWDEPENDENCIES:
					case ROWID:
					case ROWTYPE:
					case SALT:
					case SAMPLE:
					case SAVE:
					case SAVEPOINT:
					case SCALE:
					case SCHEMA:
					case SCN:
					case SCOPE:
					case SEARCH:
					case SECOND:
					case SECUREFILE:
					case SEED:
					case SEGMENT:
					case SELF:
					case SEQUENCE:
					case SERIALIZABLE:
					case SERIALLY_REUSABLE:
					case SERVERERROR:
					case SESSION:
					case SESSIONTIMEZONE:
					case SET:
					case SETS:
					case SETTINGS:
					case SHRINK:
					case SHUTDOWN:
					case SIBLINGS:
					case SIZE:
					case SKIP_:
					case SOME:
					case SORT:
					case SPACE:
					case SPECIFICATION:
					case SPLIT:
					case STARTUP:
					case STATEMENT:
					case STATIC:
					case STATISTICS:
					case STORAGE:
					case STORE:
					case STRING:
					case SHARD:
					case SHARDED:
					case SHARING:
					case SUBMULTISET:
					case SUBPARTITION:
					case SUBPARTITIONS:
					case SUBSTITUTABLE:
					case SUBTYPE:
					case SUPPLEMENTAL:
					case SUSPEND:
					case SYNONYM:
					case SYSTEM:
					case TABLES:
					case TABLESPACE:
					case TEMPLATE:
					case TEMPORARY:
					case THAN:
					case TIME:
					case TIMESTAMP:
					case TIMEZONE_ABBR:
					case TIMEZONE_HOUR:
					case TIMEZONE_MINUTE:
					case TIMEZONE_REGION:
					case TRAILING:
					case TRANSACTION:
					case TRANSLATE:
					case TREAT:
					case TRIM:
					case TRUE:
					case TRUNCATE:
					case TRUSTED:
					case TYPE:
					case UNBOUNDED:
					case UNCONDITIONAL:
					case UNDER:
					case UNLIMITED:
					case UNLOCK:
					case UNUSABLE:
					case UNUSED:
					case USABLE:
					case USAGE:
					case USE:
					case USER:
					case USING:
					case VALIDATE:
					case VALUE:
					case VARCHAR:
					case VARCHAR2:
					case VARRAY:
					case VARRAYS:
					case VARYING:
					case VERSIONS:
					case VIRTUAL:
					case VISIBLE:
					case WAIT:
					case WHEN:
					case WITHIN:
					case WITHOUT:
					case WORK:
					case WRAPPED:
					case WRAPPER:
					case WRITE:
					case XML:
					case XMLNAMESPACES:
					case XMLSCHEMA:
					case XMLTABLE:
					case XMLTYPE:
					case YEAR:
					case ZONE:
					case REGULAR_IDENTIFIER:
						{
						State = 1982;
						simpleIdentifierRegularIdentifier();
						}
						break;
					case QUOTED_IDENTIFIER:
						{
						State = 1983;
						Match(QUOTED_IDENTIFIER);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					} 
				}
				State = 1990;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,36,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier() {
			return GetRuleContext<SimpleIdentifierRegularIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTED_IDENTIFIER() { return GetToken(OracleAntlrParser.QUOTED_IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DbLinkContext dbLink() {
			return GetRuleContext<DbLinkContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public SimpleIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSimpleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSimpleIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public SimpleIdentifierContext simpleIdentifier() {
		SimpleIdentifierContext _localctx = new SimpleIdentifierContext(Context, State);
		EnterRule(_localctx, 76, RULE_simpleIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1993;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
				{
				State = 1991;
				simpleIdentifierRegularIdentifier();
				}
				break;
			case QUOTED_IDENTIFIER:
				{
				State = 1992;
				Match(QUOTED_IDENTIFIER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1996;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,38,Context) ) {
			case 1:
				{
				State = 1995;
				dbLink();
				}
				break;
			}
			State = 1999;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,39,Context) ) {
			case 1:
				{
				State = 1998;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NestedCollectionSimpleIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public NestedCollectionSimpleIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nestedCollectionSimpleIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNestedCollectionSimpleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNestedCollectionSimpleIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public NestedCollectionSimpleIdentifierContext nestedCollectionSimpleIdentifier() {
		NestedCollectionSimpleIdentifierContext _localctx = new NestedCollectionSimpleIdentifierContext(Context, State);
		EnterRule(_localctx, 78, RULE_nestedCollectionSimpleIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2001;
			simpleIdentifierParams();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlainIdentifierAsStringLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainSimpleIdentifierAsStringLiteralContext plainSimpleIdentifierAsStringLiteral() {
			return GetRuleContext<PlainSimpleIdentifierAsStringLiteralContext>(0);
		}
		public PlainIdentifierAsStringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plainIdentifierAsStringLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPlainIdentifierAsStringLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPlainIdentifierAsStringLiteral(this);
		}
	}

	[RuleVersion(0)]
	public PlainIdentifierAsStringLiteralContext plainIdentifierAsStringLiteral() {
		PlainIdentifierAsStringLiteralContext _localctx = new PlainIdentifierAsStringLiteralContext(Context, State);
		EnterRule(_localctx, 80, RULE_plainIdentifierAsStringLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2003;
			plainSimpleIdentifierAsStringLiteral();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceOpaqueFixedContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPAQUE() { return GetToken(OracleAntlrParser.OPAQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIXED() { return GetToken(OracleAntlrParser.FIXED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIBRARY() { return GetToken(OracleAntlrParser.LIBRARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SEMI() { return GetTokens(OracleAntlrParser.SEMI); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI(int i) {
			return GetToken(OracleAntlrParser.SEMI, i);
		}
		public TypeReferenceOpaqueFixedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceOpaqueFixed; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeReferenceOpaqueFixed(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeReferenceOpaqueFixed(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceOpaqueFixedContext typeReferenceOpaqueFixed() {
		TypeReferenceOpaqueFixedContext _localctx = new TypeReferenceOpaqueFixedContext(Context, State);
		EnterRule(_localctx, 82, RULE_typeReferenceOpaqueFixed);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2005;
			Match(OPAQUE);
			State = 2006;
			Match(FIXED);
			State = 2007;
			simpleIdentifierParams();
			State = 2008;
			Match(USING);
			State = 2009;
			Match(LIBRARY);
			State = 2010;
			identifier();
			State = 2014;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,40,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2011;
					_la = TokenStream.LA(1);
					if ( _la <= 0 || (_la==SEMI) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					} 
				}
				State = 2016;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,40,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlainSimpleIdentifierAsStringLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER_STRING_LITERAL() { return GetToken(OracleAntlrParser.CHARACTER_STRING_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public PlainSimpleIdentifierAsStringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plainSimpleIdentifierAsStringLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPlainSimpleIdentifierAsStringLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPlainSimpleIdentifierAsStringLiteral(this);
		}
	}

	[RuleVersion(0)]
	public PlainSimpleIdentifierAsStringLiteralContext plainSimpleIdentifierAsStringLiteral() {
		PlainSimpleIdentifierAsStringLiteralContext _localctx = new PlainSimpleIdentifierAsStringLiteralContext(Context, State);
		EnterRule(_localctx, 84, RULE_plainSimpleIdentifierAsStringLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2017;
			Match(CHARACTER_STRING_LITERAL);
			State = 2019;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,41,Context) ) {
			case 1:
				{
				State = 2018;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleIdentifierParamsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISTINCT() { return GetToken(OracleAntlrParser.DISTINCT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUE() { return GetToken(OracleAntlrParser.UNIQUE, 0); }
		public SimpleIdentifierParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleIdentifierParams; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSimpleIdentifierParams(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSimpleIdentifierParams(this);
		}
	}

	[RuleVersion(0)]
	public SimpleIdentifierParamsContext simpleIdentifierParams() {
		SimpleIdentifierParamsContext _localctx = new SimpleIdentifierParamsContext(Context, State);
		EnterRule(_localctx, 86, RULE_simpleIdentifierParams);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2021;
			Match(LPAREN);
			State = 2023;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==DISTINCT || _la==UNIQUE) {
				{
				State = 2022;
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==DISTINCT || _la==UNIQUE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2026;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLAGG - 512)) | (1L << (XMLCAST - 512)) | (1L << (XMLNAMESPACES - 512)) | (1L << (XMLQUERY - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (INTEGER_LITERAL - 576)) | (1L << (LPAREN - 576)) | (1L << (PLUS_SIGN - 576)) | (1L << (MINUS_SIGN - 576)) | (1L << (QUESTION_MARK - 576)) | (1L << (ASTERISK - 576)) | (1L << (FLOATING_POINT_LITERAL - 576)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 576)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 576)) | (1L << (BINARY_STRING_LITERAL - 576)) | (1L << (CHARACTER_STRING_LITERAL - 576)) | (1L << (MONEY_LITERAL - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 576)))) != 0)) {
				{
				State = 2025;
				expressionList();
				}
			}

			State = 2028;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LocalSimpleIdentifierWithoutParenthesesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier() {
			return GetRuleContext<SimpleIdentifierRegularIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTED_IDENTIFIER() { return GetToken(OracleAntlrParser.QUOTED_IDENTIFIER, 0); }
		public LocalSimpleIdentifierWithoutParenthesesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_localSimpleIdentifierWithoutParentheses; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLocalSimpleIdentifierWithoutParentheses(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLocalSimpleIdentifierWithoutParentheses(this);
		}
	}

	[RuleVersion(0)]
	public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
		LocalSimpleIdentifierWithoutParenthesesContext _localctx = new LocalSimpleIdentifierWithoutParenthesesContext(Context, State);
		EnterRule(_localctx, 88, RULE_localSimpleIdentifierWithoutParentheses);
		try {
			State = 2032;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2030;
				simpleIdentifierRegularIdentifier();
				}
				break;
			case QUOTED_IDENTIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2031;
				Match(QUOTED_IDENTIFIER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleIdentifierWithoutParenthesesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier() {
			return GetRuleContext<SimpleIdentifierRegularIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTED_IDENTIFIER() { return GetToken(OracleAntlrParser.QUOTED_IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DbLinkContext dbLink() {
			return GetRuleContext<DbLinkContext>(0);
		}
		public SimpleIdentifierWithoutParenthesesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleIdentifierWithoutParentheses; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSimpleIdentifierWithoutParentheses(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSimpleIdentifierWithoutParentheses(this);
		}
	}

	[RuleVersion(0)]
	public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
		SimpleIdentifierWithoutParenthesesContext _localctx = new SimpleIdentifierWithoutParenthesesContext(Context, State);
		EnterRule(_localctx, 90, RULE_simpleIdentifierWithoutParentheses);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2036;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
				{
				State = 2034;
				simpleIdentifierRegularIdentifier();
				}
				break;
			case QUOTED_IDENTIFIER:
				{
				State = 2035;
				Match(QUOTED_IDENTIFIER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2039;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,46,Context) ) {
			case 1:
				{
				State = 2038;
				dbLink();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BindParameterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUESTION_MARK() { return GetToken(OracleAntlrParser.QUESTION_MARK, 0); }
		public BindParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bindParameter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBindParameter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBindParameter(this);
		}
	}

	[RuleVersion(0)]
	public BindParameterContext bindParameter() {
		BindParameterContext _localctx = new BindParameterContext(Context, State);
		EnterRule(_localctx, 92, RULE_bindParameter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2041;
			Match(QUESTION_MARK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceTimestampCaseContext typeReferenceTimestampCase() {
			return GetRuleContext<TypeReferenceTimestampCaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceIntervalCaseContext typeReferenceIntervalCase() {
			return GetRuleContext<TypeReferenceIntervalCaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceCharCaseContext typeReferenceCharCase() {
			return GetRuleContext<TypeReferenceCharCaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceLongAndRawCaseContext typeReferenceLongAndRawCase() {
			return GetRuleContext<TypeReferenceLongAndRawCaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceRefCaseContext typeReferenceRefCase() {
			return GetRuleContext<TypeReferenceRefCaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BooleanLiteralContext[] booleanLiteral() {
			return GetRuleContexts<BooleanLiteralContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BooleanLiteralContext booleanLiteral(int i) {
			return GetRuleContext<BooleanLiteralContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceOpaqueFixedContext typeReferenceOpaqueFixed() {
			return GetRuleContext<TypeReferenceOpaqueFixedContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierDoublePrecisionContext identifierDoublePrecision() {
			return GetRuleContext<IdentifierDoublePrecisionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceAttributesContext typeReferenceAttributes() {
			return GetRuleContext<TypeReferenceAttributesContext>(0);
		}
		public TypeReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReference; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeReference(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeReference(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceContext typeReference() {
		TypeReferenceContext _localctx = new TypeReferenceContext(Context, State);
		EnterRule(_localctx, 94, RULE_typeReference);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2057;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,47,Context) ) {
			case 1:
				{
				State = 2043;
				typeReferenceTimestampCase();
				}
				break;
			case 2:
				{
				State = 2044;
				typeReferenceIntervalCase();
				}
				break;
			case 3:
				{
				State = 2045;
				typeReferenceCharCase();
				}
				break;
			case 4:
				{
				State = 2046;
				typeReferenceLongAndRawCase();
				}
				break;
			case 5:
				{
				State = 2047;
				typeReferenceRefCase();
				}
				break;
			case 6:
				{
				State = 2048;
				Match(LPAREN);
				State = 2049;
				booleanLiteral();
				State = 2050;
				Match(COMMA);
				State = 2051;
				booleanLiteral();
				State = 2052;
				Match(RPAREN);
				}
				break;
			case 7:
				{
				State = 2054;
				typeReferenceOpaqueFixed();
				}
				break;
			case 8:
				{
				State = 2055;
				identifierDoublePrecision();
				}
				break;
			case 9:
				{
				State = 2056;
				identifier();
				}
				break;
			}
			State = 2060;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,48,Context) ) {
			case 1:
				{
				State = 2059;
				typeReferenceAttributes();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierTimestampContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMESTAMP() { return GetToken(OracleAntlrParser.TIMESTAMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierTimestampContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierTimestamp; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierTimestamp(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierTimestamp(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierTimestampContext identifierTimestamp() {
		IdentifierTimestampContext _localctx = new IdentifierTimestampContext(Context, State);
		EnterRule(_localctx, 96, RULE_identifierTimestamp);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2062;
			Match(TIMESTAMP);
			State = 2064;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,49,Context) ) {
			case 1:
				{
				State = 2063;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierTimeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIME() { return GetToken(OracleAntlrParser.TIME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierTimeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierTime; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierTime(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierTime(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierTimeContext identifierTime() {
		IdentifierTimeContext _localctx = new IdentifierTimeContext(Context, State);
		EnterRule(_localctx, 98, RULE_identifierTime);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2066;
			Match(TIME);
			State = 2068;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,50,Context) ) {
			case 1:
				{
				State = 2067;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierWithContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierWithContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierWith; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierWith(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierWith(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierWithContext identifierWith() {
		IdentifierWithContext _localctx = new IdentifierWithContext(Context, State);
		EnterRule(_localctx, 100, RULE_identifierWith);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2070;
			Match(WITH);
			State = 2072;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 2071;
				simpleIdentifierParams();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierLocalContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(OracleAntlrParser.LOCAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierLocalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierLocal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierLocal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierLocal(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierLocalContext identifierLocal() {
		IdentifierLocalContext _localctx = new IdentifierLocalContext(Context, State);
		EnterRule(_localctx, 102, RULE_identifierLocal);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2074;
			Match(LOCAL);
			State = 2076;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 2075;
				simpleIdentifierParams();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierZoneContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ZONE() { return GetToken(OracleAntlrParser.ZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierZoneContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierZone; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierZone(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierZone(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierZoneContext identifierZone() {
		IdentifierZoneContext _localctx = new IdentifierZoneContext(Context, State);
		EnterRule(_localctx, 104, RULE_identifierZone);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2078;
			Match(ZONE);
			State = 2080;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,53,Context) ) {
			case 1:
				{
				State = 2079;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierIntervalContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERVAL() { return GetToken(OracleAntlrParser.INTERVAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierIntervalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierInterval; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierInterval(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierInterval(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierIntervalContext identifierInterval() {
		IdentifierIntervalContext _localctx = new IdentifierIntervalContext(Context, State);
		EnterRule(_localctx, 106, RULE_identifierInterval);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2082;
			Match(INTERVAL);
			State = 2084;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 2083;
				simpleIdentifierParams();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierToContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(OracleAntlrParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierToContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierTo; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierTo(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierTo(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierToContext identifierTo() {
		IdentifierToContext _localctx = new IdentifierToContext(Context, State);
		EnterRule(_localctx, 108, RULE_identifierTo);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2086;
			Match(TO);
			State = 2088;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 2087;
				simpleIdentifierParams();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierLongContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LONG() { return GetToken(OracleAntlrParser.LONG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierLongContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierLong; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierLong(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierLong(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierLongContext identifierLong() {
		IdentifierLongContext _localctx = new IdentifierLongContext(Context, State);
		EnterRule(_localctx, 110, RULE_identifierLong);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2090;
			Match(LONG);
			State = 2092;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,56,Context) ) {
			case 1:
				{
				State = 2091;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierRawContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RAW() { return GetToken(OracleAntlrParser.RAW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierRawContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierRaw; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierRaw(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierRaw(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierRawContext identifierRaw() {
		IdentifierRawContext _localctx = new IdentifierRawContext(Context, State);
		EnterRule(_localctx, 112, RULE_identifierRaw);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2094;
			Match(RAW);
			State = 2096;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,57,Context) ) {
			case 1:
				{
				State = 2095;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierLongRawContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LONG() { return GetToken(OracleAntlrParser.LONG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierRawContext identifierRaw() {
			return GetRuleContext<IdentifierRawContext>(0);
		}
		public IdentifierLongRawContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierLongRaw; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierLongRaw(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierLongRaw(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierLongRawContext identifierLongRaw() {
		IdentifierLongRawContext _localctx = new IdentifierLongRawContext(Context, State);
		EnterRule(_localctx, 114, RULE_identifierLongRaw);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2098;
			Match(LONG);
			State = 2099;
			identifierRaw();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierDoublePrecisionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOUBLE() { return GetToken(OracleAntlrParser.DOUBLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRECISION() { return GetToken(OracleAntlrParser.PRECISION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public IdentifierDoublePrecisionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierDoublePrecision; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierDoublePrecision(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierDoublePrecision(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierDoublePrecisionContext identifierDoublePrecision() {
		IdentifierDoublePrecisionContext _localctx = new IdentifierDoublePrecisionContext(Context, State);
		EnterRule(_localctx, 116, RULE_identifierDoublePrecision);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2101;
			Match(DOUBLE);
			State = 2102;
			Match(PRECISION);
			State = 2104;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,58,Context) ) {
			case 1:
				{
				State = 2103;
				simpleIdentifierParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierCharacterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAR() { return GetToken(OracleAntlrParser.CHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER() { return GetToken(OracleAntlrParser.CHARACTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARYING() { return GetToken(OracleAntlrParser.VARYING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharIdentifierParamsContext charIdentifierParams() {
			return GetRuleContext<CharIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollationSpecClauseContext collationSpecClause() {
			return GetRuleContext<CollationSpecClauseContext>(0);
		}
		public IdentifierCharacterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierCharacter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierCharacter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierCharacter(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierCharacterContext identifierCharacter() {
		IdentifierCharacterContext _localctx = new IdentifierCharacterContext(Context, State);
		EnterRule(_localctx, 118, RULE_identifierCharacter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2106;
			_la = TokenStream.LA(1);
			if ( !(_la==CHAR || _la==CHARACTER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2108;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,59,Context) ) {
			case 1:
				{
				State = 2107;
				Match(VARYING);
				}
				break;
			}
			State = 2111;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,60,Context) ) {
			case 1:
				{
				State = 2110;
				charIdentifierParams();
				}
				break;
			}
			State = 2114;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,61,Context) ) {
			case 1:
				{
				State = 2113;
				collationSpecClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierNationalCharacterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NATIONAL() { return GetToken(OracleAntlrParser.NATIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAR() { return GetToken(OracleAntlrParser.CHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER() { return GetToken(OracleAntlrParser.CHARACTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARYING() { return GetToken(OracleAntlrParser.VARYING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollationSpecClauseContext collationSpecClause() {
			return GetRuleContext<CollationSpecClauseContext>(0);
		}
		public IdentifierNationalCharacterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierNationalCharacter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierNationalCharacter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierNationalCharacter(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierNationalCharacterContext identifierNationalCharacter() {
		IdentifierNationalCharacterContext _localctx = new IdentifierNationalCharacterContext(Context, State);
		EnterRule(_localctx, 120, RULE_identifierNationalCharacter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2116;
			Match(NATIONAL);
			State = 2117;
			_la = TokenStream.LA(1);
			if ( !(_la==CHAR || _la==CHARACTER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2119;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,62,Context) ) {
			case 1:
				{
				State = 2118;
				Match(VARYING);
				}
				break;
			}
			State = 2122;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,63,Context) ) {
			case 1:
				{
				State = 2121;
				simpleIdentifierParams();
				}
				break;
			}
			State = 2125;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,64,Context) ) {
			case 1:
				{
				State = 2124;
				collationSpecClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierNCharContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NCHAR() { return GetToken(OracleAntlrParser.NCHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARYING() { return GetToken(OracleAntlrParser.VARYING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollationSpecClauseContext collationSpecClause() {
			return GetRuleContext<CollationSpecClauseContext>(0);
		}
		public IdentifierNCharContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierNChar; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierNChar(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierNChar(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierNCharContext identifierNChar() {
		IdentifierNCharContext _localctx = new IdentifierNCharContext(Context, State);
		EnterRule(_localctx, 122, RULE_identifierNChar);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2127;
			Match(NCHAR);
			State = 2129;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,65,Context) ) {
			case 1:
				{
				State = 2128;
				Match(VARYING);
				}
				break;
			}
			State = 2132;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,66,Context) ) {
			case 1:
				{
				State = 2131;
				simpleIdentifierParams();
				}
				break;
			}
			State = 2135;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,67,Context) ) {
			case 1:
				{
				State = 2134;
				collationSpecClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierNVarChar2Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NVARCHAR2() { return GetToken(OracleAntlrParser.NVARCHAR2, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollationSpecClauseContext collationSpecClause() {
			return GetRuleContext<CollationSpecClauseContext>(0);
		}
		public IdentifierNVarChar2Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierNVarChar2; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierNVarChar2(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierNVarChar2(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierNVarChar2Context identifierNVarChar2() {
		IdentifierNVarChar2Context _localctx = new IdentifierNVarChar2Context(Context, State);
		EnterRule(_localctx, 124, RULE_identifierNVarChar2);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2137;
			Match(NVARCHAR2);
			State = 2139;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,68,Context) ) {
			case 1:
				{
				State = 2138;
				simpleIdentifierParams();
				}
				break;
			}
			State = 2142;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,69,Context) ) {
			case 1:
				{
				State = 2141;
				collationSpecClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierVarCharContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARCHAR() { return GetToken(OracleAntlrParser.VARCHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharIdentifierParamsContext charIdentifierParams() {
			return GetRuleContext<CharIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollationSpecClauseContext collationSpecClause() {
			return GetRuleContext<CollationSpecClauseContext>(0);
		}
		public IdentifierVarCharContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierVarChar; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierVarChar(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierVarChar(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierVarCharContext identifierVarChar() {
		IdentifierVarCharContext _localctx = new IdentifierVarCharContext(Context, State);
		EnterRule(_localctx, 126, RULE_identifierVarChar);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2144;
			Match(VARCHAR);
			State = 2146;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,70,Context) ) {
			case 1:
				{
				State = 2145;
				charIdentifierParams();
				}
				break;
			}
			State = 2149;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,71,Context) ) {
			case 1:
				{
				State = 2148;
				collationSpecClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierVarChar2Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARCHAR2() { return GetToken(OracleAntlrParser.VARCHAR2, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharIdentifierParamsContext charIdentifierParams() {
			return GetRuleContext<CharIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollationSpecClauseContext collationSpecClause() {
			return GetRuleContext<CollationSpecClauseContext>(0);
		}
		public IdentifierVarChar2Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierVarChar2; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierVarChar2(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierVarChar2(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierVarChar2Context identifierVarChar2() {
		IdentifierVarChar2Context _localctx = new IdentifierVarChar2Context(Context, State);
		EnterRule(_localctx, 128, RULE_identifierVarChar2);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2151;
			Match(VARCHAR2);
			State = 2153;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,72,Context) ) {
			case 1:
				{
				State = 2152;
				charIdentifierParams();
				}
				break;
			}
			State = 2156;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,73,Context) ) {
			case 1:
				{
				State = 2155;
				collationSpecClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierStringContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING() { return GetToken(OracleAntlrParser.STRING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharIdentifierParamsContext charIdentifierParams() {
			return GetRuleContext<CharIdentifierParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollationSpecClauseContext collationSpecClause() {
			return GetRuleContext<CollationSpecClauseContext>(0);
		}
		public IdentifierStringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierString; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierString(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierStringContext identifierString() {
		IdentifierStringContext _localctx = new IdentifierStringContext(Context, State);
		EnterRule(_localctx, 130, RULE_identifierString);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2158;
			Match(STRING);
			State = 2160;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,74,Context) ) {
			case 1:
				{
				State = 2159;
				charIdentifierParams();
				}
				break;
			}
			State = 2163;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,75,Context) ) {
			case 1:
				{
				State = 2162;
				collationSpecClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CharIdentifierParamsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BYTE() { return GetToken(OracleAntlrParser.BYTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAR() { return GetToken(OracleAntlrParser.CHAR, 0); }
		public CharIdentifierParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_charIdentifierParams; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCharIdentifierParams(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCharIdentifierParams(this);
		}
	}

	[RuleVersion(0)]
	public CharIdentifierParamsContext charIdentifierParams() {
		CharIdentifierParamsContext _localctx = new CharIdentifierParamsContext(Context, State);
		EnterRule(_localctx, 132, RULE_charIdentifierParams);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2165;
			Match(LPAREN);
			State = 2166;
			fullExpression();
			State = 2168;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BYTE || _la==CHAR) {
				{
				State = 2167;
				_la = TokenStream.LA(1);
				if ( !(_la==BYTE || _la==CHAR) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2170;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceTimestampCaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierTimestampContext identifierTimestamp() {
			return GetRuleContext<IdentifierTimestampContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierTimeContext[] identifierTime() {
			return GetRuleContexts<IdentifierTimeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierTimeContext identifierTime(int i) {
			return GetRuleContext<IdentifierTimeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierWithContext identifierWith() {
			return GetRuleContext<IdentifierWithContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierZoneContext identifierZone() {
			return GetRuleContext<IdentifierZoneContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierLocalContext identifierLocal() {
			return GetRuleContext<IdentifierLocalContext>(0);
		}
		public TypeReferenceTimestampCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceTimestampCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeReferenceTimestampCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeReferenceTimestampCase(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceTimestampCaseContext typeReferenceTimestampCase() {
		TypeReferenceTimestampCaseContext _localctx = new TypeReferenceTimestampCaseContext(Context, State);
		EnterRule(_localctx, 134, RULE_typeReferenceTimestampCase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2174;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TIMESTAMP:
				{
				State = 2172;
				identifierTimestamp();
				}
				break;
			case TIME:
				{
				State = 2173;
				identifierTime();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2183;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,79,Context) ) {
			case 1:
				{
				State = 2176;
				identifierWith();
				State = 2178;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOCAL) {
					{
					State = 2177;
					identifierLocal();
					}
				}

				State = 2180;
				identifierTime();
				State = 2181;
				identifierZone();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceIntervalCaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierIntervalContext identifierInterval() {
			return GetRuleContext<IdentifierIntervalContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierToContext identifierTo() {
			return GetRuleContext<IdentifierToContext>(0);
		}
		public TypeReferenceIntervalCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceIntervalCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeReferenceIntervalCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeReferenceIntervalCase(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceIntervalCaseContext typeReferenceIntervalCase() {
		TypeReferenceIntervalCaseContext _localctx = new TypeReferenceIntervalCaseContext(Context, State);
		EnterRule(_localctx, 136, RULE_typeReferenceIntervalCase);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2185;
			identifierInterval();
			State = 2186;
			identifier();
			State = 2187;
			identifierTo();
			State = 2188;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceCharCaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierCharacterContext identifierCharacter() {
			return GetRuleContext<IdentifierCharacterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierVarCharContext identifierVarChar() {
			return GetRuleContext<IdentifierVarCharContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierVarChar2Context identifierVarChar2() {
			return GetRuleContext<IdentifierVarChar2Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierNCharContext identifierNChar() {
			return GetRuleContext<IdentifierNCharContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierNVarChar2Context identifierNVarChar2() {
			return GetRuleContext<IdentifierNVarChar2Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierStringContext identifierString() {
			return GetRuleContext<IdentifierStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierNationalCharacterContext identifierNationalCharacter() {
			return GetRuleContext<IdentifierNationalCharacterContext>(0);
		}
		public TypeReferenceCharCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceCharCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeReferenceCharCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeReferenceCharCase(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceCharCaseContext typeReferenceCharCase() {
		TypeReferenceCharCaseContext _localctx = new TypeReferenceCharCaseContext(Context, State);
		EnterRule(_localctx, 138, RULE_typeReferenceCharCase);
		try {
			State = 2197;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CHAR:
			case CHARACTER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2190;
				identifierCharacter();
				}
				break;
			case VARCHAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2191;
				identifierVarChar();
				}
				break;
			case VARCHAR2:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2192;
				identifierVarChar2();
				}
				break;
			case NCHAR:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2193;
				identifierNChar();
				}
				break;
			case NVARCHAR2:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2194;
				identifierNVarChar2();
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2195;
				identifierString();
				}
				break;
			case NATIONAL:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2196;
				identifierNationalCharacter();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollationSpecClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLLATE() { return GetToken(OracleAntlrParser.COLLATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public CollationSpecClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collationSpecClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCollationSpecClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCollationSpecClause(this);
		}
	}

	[RuleVersion(0)]
	public CollationSpecClauseContext collationSpecClause() {
		CollationSpecClauseContext _localctx = new CollationSpecClauseContext(Context, State);
		EnterRule(_localctx, 140, RULE_collationSpecClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2199;
			Match(COLLATE);
			State = 2200;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceLongAndRawCaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierRawContext identifierRaw() {
			return GetRuleContext<IdentifierRawContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierLongRawContext identifierLongRaw() {
			return GetRuleContext<IdentifierLongRawContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierLongContext identifierLong() {
			return GetRuleContext<IdentifierLongContext>(0);
		}
		public TypeReferenceLongAndRawCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceLongAndRawCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeReferenceLongAndRawCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeReferenceLongAndRawCase(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceLongAndRawCaseContext typeReferenceLongAndRawCase() {
		TypeReferenceLongAndRawCaseContext _localctx = new TypeReferenceLongAndRawCaseContext(Context, State);
		EnterRule(_localctx, 142, RULE_typeReferenceLongAndRawCase);
		try {
			State = 2205;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,81,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2202;
				identifierRaw();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2203;
				identifierLongRaw();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2204;
				identifierLong();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceAttributesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceCharacterSetAttributeContext typeReferenceCharacterSetAttribute() {
			return GetRuleContext<TypeReferenceCharacterSetAttributeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceRangeAttributeContext typeReferenceRangeAttribute() {
			return GetRuleContext<TypeReferenceRangeAttributeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceModifierAttributeContext typeReferenceModifierAttribute() {
			return GetRuleContext<TypeReferenceModifierAttributeContext>(0);
		}
		public TypeReferenceAttributesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceAttributes; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeReferenceAttributes(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeReferenceAttributes(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceAttributesContext typeReferenceAttributes() {
		TypeReferenceAttributesContext _localctx = new TypeReferenceAttributesContext(Context, State);
		EnterRule(_localctx, 144, RULE_typeReferenceAttributes);
		try {
			State = 2210;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CHARACTER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2207;
				typeReferenceCharacterSetAttribute();
				}
				break;
			case RANGE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2208;
				typeReferenceRangeAttribute();
				}
				break;
			case PERCENT_SIGN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2209;
				typeReferenceModifierAttribute();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceCharacterSetAttributeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARACTER() { return GetToken(OracleAntlrParser.CHARACTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceCharacterSetModifierContext typeReferenceCharacterSetModifier() {
			return GetRuleContext<TypeReferenceCharacterSetModifierContext>(0);
		}
		public TypeReferenceCharacterSetAttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceCharacterSetAttribute; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeReferenceCharacterSetAttribute(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeReferenceCharacterSetAttribute(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceCharacterSetAttributeContext typeReferenceCharacterSetAttribute() {
		TypeReferenceCharacterSetAttributeContext _localctx = new TypeReferenceCharacterSetAttributeContext(Context, State);
		EnterRule(_localctx, 146, RULE_typeReferenceCharacterSetAttribute);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2212;
			Match(CHARACTER);
			State = 2213;
			Match(SET);
			State = 2214;
			fullExpression();
			State = 2216;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,83,Context) ) {
			case 1:
				{
				State = 2215;
				typeReferenceCharacterSetModifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceCharacterSetModifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT_SIGN() { return GetToken(OracleAntlrParser.PERCENT_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARSET() { return GetToken(OracleAntlrParser.CHARSET, 0); }
		public TypeReferenceCharacterSetModifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceCharacterSetModifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeReferenceCharacterSetModifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeReferenceCharacterSetModifier(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceCharacterSetModifierContext typeReferenceCharacterSetModifier() {
		TypeReferenceCharacterSetModifierContext _localctx = new TypeReferenceCharacterSetModifierContext(Context, State);
		EnterRule(_localctx, 148, RULE_typeReferenceCharacterSetModifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2218;
			Match(PERCENT_SIGN);
			State = 2219;
			Match(CHARSET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceRangeAttributeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(OracleAntlrParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterDoubleDotContext delimiterDoubleDot() {
			return GetRuleContext<DelimiterDoubleDotContext>(0);
		}
		public TypeReferenceRangeAttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceRangeAttribute; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeReferenceRangeAttribute(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeReferenceRangeAttribute(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceRangeAttributeContext typeReferenceRangeAttribute() {
		TypeReferenceRangeAttributeContext _localctx = new TypeReferenceRangeAttributeContext(Context, State);
		EnterRule(_localctx, 150, RULE_typeReferenceRangeAttribute);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2221;
			Match(RANGE);
			State = 2222;
			fullExpression();
			State = 2223;
			delimiterDoubleDot();
			State = 2224;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterDoubleDotContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOUBLE_DOT_OPERATOR() { return GetToken(OracleAntlrParser.DOUBLE_DOT_OPERATOR, 0); }
		public DelimiterDoubleDotContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterDoubleDot; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterDoubleDot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterDoubleDot(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterDoubleDotContext delimiterDoubleDot() {
		DelimiterDoubleDotContext _localctx = new DelimiterDoubleDotContext(Context, State);
		EnterRule(_localctx, 152, RULE_delimiterDoubleDot);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2226;
			Match(DOUBLE_DOT_OPERATOR);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceModifierAttributeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT_SIGN() { return GetToken(OracleAntlrParser.PERCENT_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWTYPE() { return GetToken(OracleAntlrParser.ROWTYPE, 0); }
		public TypeReferenceModifierAttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceModifierAttribute; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeReferenceModifierAttribute(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeReferenceModifierAttribute(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceModifierAttributeContext typeReferenceModifierAttribute() {
		TypeReferenceModifierAttributeContext _localctx = new TypeReferenceModifierAttributeContext(Context, State);
		EnterRule(_localctx, 154, RULE_typeReferenceModifierAttribute);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2228;
			Match(PERCENT_SIGN);
			State = 2229;
			_la = TokenStream.LA(1);
			if ( !(_la==ROWTYPE || _la==TYPE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceRefCaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REF() { return GetToken(OracleAntlrParser.REF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public TypeReferenceRefCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReferenceRefCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeReferenceRefCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeReferenceRefCase(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceRefCaseContext typeReferenceRefCase() {
		TypeReferenceRefCaseContext _localctx = new TypeReferenceRefCaseContext(Context, State);
		EnterRule(_localctx, 156, RULE_typeReferenceRefCase);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2231;
			Match(REF);
			State = 2232;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullOrConditionContext fullOrCondition() {
			return GetRuleContext<FullOrConditionContext>(0);
		}
		public FullExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFullExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFullExpression(this);
		}
	}

	[RuleVersion(0)]
	public FullExpressionContext fullExpression() {
		FullExpressionContext _localctx = new FullExpressionContext(Context, State);
		EnterRule(_localctx, 158, RULE_fullExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2234;
			fullOrCondition();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullOrConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullAndConditionContext[] fullAndCondition() {
			return GetRuleContexts<FullAndConditionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullAndConditionContext fullAndCondition(int i) {
			return GetRuleContext<FullAndConditionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] OR() { return GetTokens(OracleAntlrParser.OR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR(int i) {
			return GetToken(OracleAntlrParser.OR, i);
		}
		public FullOrConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullOrCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFullOrCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFullOrCondition(this);
		}
	}

	[RuleVersion(0)]
	public FullOrConditionContext fullOrCondition() {
		FullOrConditionContext _localctx = new FullOrConditionContext(Context, State);
		EnterRule(_localctx, 160, RULE_fullOrCondition);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2236;
			fullAndCondition();
			State = 2241;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,84,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2237;
					Match(OR);
					State = 2238;
					fullAndCondition();
					}
					} 
				}
				State = 2243;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,84,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullAndConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullUnaryConditionContext[] fullUnaryCondition() {
			return GetRuleContexts<FullUnaryConditionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullUnaryConditionContext fullUnaryCondition(int i) {
			return GetRuleContext<FullUnaryConditionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] AND() { return GetTokens(OracleAntlrParser.AND); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND(int i) {
			return GetToken(OracleAntlrParser.AND, i);
		}
		public FullAndConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullAndCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFullAndCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFullAndCondition(this);
		}
	}

	[RuleVersion(0)]
	public FullAndConditionContext fullAndCondition() {
		FullAndConditionContext _localctx = new FullAndConditionContext(Context, State);
		EnterRule(_localctx, 162, RULE_fullAndCondition);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2244;
			fullUnaryCondition();
			State = 2249;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,85,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2245;
					Match(AND);
					State = 2246;
					fullUnaryCondition();
					}
					} 
				}
				State = 2251;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,85,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullUnaryConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullAtomicConditionContext fullAtomicCondition() {
			return GetRuleContext<FullAtomicConditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullAtomicCondition1Context fullAtomicCondition1() {
			return GetRuleContext<FullAtomicCondition1Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public FullUnaryConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullUnaryCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFullUnaryCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFullUnaryCondition(this);
		}
	}

	[RuleVersion(0)]
	public FullUnaryConditionContext fullUnaryCondition() {
		FullUnaryConditionContext _localctx = new FullUnaryConditionContext(Context, State);
		EnterRule(_localctx, 164, RULE_fullUnaryCondition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2253;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 2252;
				Match(NOT);
				}
			}

			State = 2257;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,87,Context) ) {
			case 1:
				{
				State = 2255;
				fullAtomicCondition();
				}
				break;
			case 2:
				{
				State = 2256;
				fullAtomicCondition1();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullAtomicConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterCurrentOfContext delimiterCurrentOf() {
			return GetRuleContext<DelimiterCurrentOfContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterExistsContext delimiterExists() {
			return GetRuleContext<DelimiterExistsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiColumnConditionContext multiColumnCondition() {
			return GetRuleContext<MultiColumnConditionContext>(0);
		}
		public FullAtomicConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullAtomicCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFullAtomicCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFullAtomicCondition(this);
		}
	}

	[RuleVersion(0)]
	public FullAtomicConditionContext fullAtomicCondition() {
		FullAtomicConditionContext _localctx = new FullAtomicConditionContext(Context, State);
		EnterRule(_localctx, 166, RULE_fullAtomicCondition);
		try {
			State = 2266;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2259;
				delimiterCurrentOf();
				State = 2260;
				identifier();
				}
				break;
			case EXISTS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2262;
				delimiterExists();
				State = 2263;
				flattenedQuery();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2265;
				multiColumnCondition();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterCurrentOfContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(OracleAntlrParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		public DelimiterCurrentOfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterCurrentOf; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterCurrentOf(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterCurrentOf(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterCurrentOfContext delimiterCurrentOf() {
		DelimiterCurrentOfContext _localctx = new DelimiterCurrentOfContext(Context, State);
		EnterRule(_localctx, 168, RULE_delimiterCurrentOf);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2268;
			Match(CURRENT);
			State = 2269;
			Match(OF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterExistsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(OracleAntlrParser.EXISTS, 0); }
		public DelimiterExistsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterExists; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterExists(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterExists(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterExistsContext delimiterExists() {
		DelimiterExistsContext _localctx = new DelimiterExistsContext(Context, State);
		EnterRule(_localctx, 170, RULE_delimiterExists);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2271;
			Match(EXISTS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullAtomicCondition1Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext[] pureExpression() {
			return GetRuleContexts<PureExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression(int i) {
			return GetRuleContext<PureExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonPairOperatorContext comparisonPairOperator() {
			return GetRuleContext<ComparisonPairOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollectionsComparisonContext collectionsComparison() {
			return GetRuleContext<CollectionsComparisonContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypesComparisonContext typesComparison() {
			return GetRuleContext<TypesComparisonContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BetweenOperatorContext betweenOperator() {
			return GetRuleContext<BetweenOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BetweenAndOperatorContext betweenAndOperator() {
			return GetRuleContext<BetweenAndOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterIsContext delimiterIs() {
			return GetRuleContext<DelimiterIsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterOperandOfIsContext delimiterOperandOfIs() {
			return GetRuleContext<DelimiterOperandOfIsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LikeOperatorContext likeOperator() {
			return GetRuleContext<LikeOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterInContext delimiterIn() {
			return GetRuleContext<DelimiterInContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InPureExpressionContext inPureExpression() {
			return GetRuleContext<InPureExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterLParenContext delimiterLParen() {
			return GetRuleContext<DelimiterLParenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterRParenContext delimiterRParen() {
			return GetRuleContext<DelimiterRParenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterNotContext delimiterNot() {
			return GetRuleContext<DelimiterNotContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EscapeClauseContext escapeClause() {
			return GetRuleContext<EscapeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterAnyContext delimiterAny() {
			return GetRuleContext<DelimiterAnyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterSomeContext delimiterSome() {
			return GetRuleContext<DelimiterSomeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterAllContext delimiterAll() {
			return GetRuleContext<DelimiterAllContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonListContext comparisonList() {
			return GetRuleContext<ComparisonListContext>(0);
		}
		public FullAtomicCondition1Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullAtomicCondition1; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFullAtomicCondition1(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFullAtomicCondition1(this);
		}
	}

	[RuleVersion(0)]
	public FullAtomicCondition1Context fullAtomicCondition1() {
		FullAtomicCondition1Context _localctx = new FullAtomicCondition1Context(Context, State);
		EnterRule(_localctx, 172, RULE_fullAtomicCondition1);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2273;
			pureExpression();
			State = 2323;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,98,Context) ) {
			case 1:
				{
				State = 2274;
				comparisonPairOperator();
				State = 2285;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,91,Context) ) {
				case 1:
					{
					State = 2278;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ANY:
						{
						State = 2275;
						delimiterAny();
						}
						break;
					case SOME:
						{
						State = 2276;
						delimiterSome();
						}
						break;
					case ALL:
						{
						State = 2277;
						delimiterAll();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2282;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,90,Context) ) {
					case 1:
						{
						State = 2280;
						flattenedQuery();
						}
						break;
					case 2:
						{
						State = 2281;
						comparisonList();
						}
						break;
					}
					}
					break;
				case 2:
					{
					State = 2284;
					pureExpression();
					}
					break;
				}
				}
				break;
			case 2:
				{
				State = 2287;
				collectionsComparison();
				}
				break;
			case 3:
				{
				State = 2288;
				typesComparison();
				}
				break;
			case 4:
				{
				State = 2290;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 2289;
					delimiterNot();
					}
				}

				State = 2292;
				betweenOperator();
				State = 2293;
				pureExpression();
				State = 2294;
				betweenAndOperator();
				State = 2295;
				pureExpression();
				}
				break;
			case 5:
				{
				State = 2297;
				delimiterIs();
				State = 2299;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 2298;
					delimiterNot();
					}
				}

				State = 2301;
				delimiterOperandOfIs();
				}
				break;
			case 6:
				{
				State = 2304;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 2303;
					delimiterNot();
					}
				}

				State = 2306;
				likeOperator();
				State = 2307;
				pureExpression();
				State = 2309;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,95,Context) ) {
				case 1:
					{
					State = 2308;
					escapeClause();
					}
					break;
				}
				}
				break;
			case 7:
				{
				State = 2312;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 2311;
					delimiterNot();
					}
				}

				State = 2314;
				delimiterIn();
				State = 2321;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,97,Context) ) {
				case 1:
					{
					State = 2315;
					flattenedQuery();
					}
					break;
				case 2:
					{
					State = 2316;
					inPureExpression();
					}
					break;
				case 3:
					{
					State = 2317;
					delimiterLParen();
					State = 2318;
					expressionList();
					State = 2319;
					delimiterRParen();
					}
					break;
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InPureExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		public InPureExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inPureExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterInPureExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitInPureExpression(this);
		}
	}

	[RuleVersion(0)]
	public InPureExpressionContext inPureExpression() {
		InPureExpressionContext _localctx = new InPureExpressionContext(Context, State);
		EnterRule(_localctx, 174, RULE_inPureExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2325;
			pureExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterAnyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY() { return GetToken(OracleAntlrParser.ANY, 0); }
		public DelimiterAnyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterAny; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterAny(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterAny(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterAnyContext delimiterAny() {
		DelimiterAnyContext _localctx = new DelimiterAnyContext(Context, State);
		EnterRule(_localctx, 176, RULE_delimiterAny);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2327;
			Match(ANY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterSomeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SOME() { return GetToken(OracleAntlrParser.SOME, 0); }
		public DelimiterSomeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterSome; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterSome(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterSome(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterSomeContext delimiterSome() {
		DelimiterSomeContext _localctx = new DelimiterSomeContext(Context, State);
		EnterRule(_localctx, 178, RULE_delimiterSome);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2329;
			Match(SOME);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterAllContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		public DelimiterAllContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterAll; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterAll(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterAll(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterAllContext delimiterAll() {
		DelimiterAllContext _localctx = new DelimiterAllContext(Context, State);
		EnterRule(_localctx, 180, RULE_delimiterAll);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2331;
			Match(ALL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterNotContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public DelimiterNotContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterNot; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterNot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterNot(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterNotContext delimiterNot() {
		DelimiterNotContext _localctx = new DelimiterNotContext(Context, State);
		EnterRule(_localctx, 182, RULE_delimiterNot);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2333;
			Match(NOT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterIsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		public DelimiterIsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterIs; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterIs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterIs(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterIsContext delimiterIs() {
		DelimiterIsContext _localctx = new DelimiterIsContext(Context, State);
		EnterRule(_localctx, 184, RULE_delimiterIs);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2335;
			Match(IS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterInContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		public DelimiterInContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterIn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterIn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterIn(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterInContext delimiterIn() {
		DelimiterInContext _localctx = new DelimiterInContext(Context, State);
		EnterRule(_localctx, 186, RULE_delimiterIn);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2337;
			Match(IN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterLParenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		public DelimiterLParenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterLParen; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterLParen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterLParen(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterLParenContext delimiterLParen() {
		DelimiterLParenContext _localctx = new DelimiterLParenContext(Context, State);
		EnterRule(_localctx, 188, RULE_delimiterLParen);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2339;
			Match(LPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterRParenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public DelimiterRParenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterRParen; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterRParen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterRParen(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterRParenContext delimiterRParen() {
		DelimiterRParenContext _localctx = new DelimiterRParenContext(Context, State);
		EnterRule(_localctx, 190, RULE_delimiterRParen);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2341;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypesComparisonContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeComparisonNamesContext typeComparisonNames() {
			return GetRuleContext<TypeComparisonNamesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		public TypesComparisonContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typesComparison; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypesComparison(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypesComparison(this);
		}
	}

	[RuleVersion(0)]
	public TypesComparisonContext typesComparison() {
		TypesComparisonContext _localctx = new TypesComparisonContext(Context, State);
		EnterRule(_localctx, 192, RULE_typesComparison);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2343;
			Match(IS);
			State = 2345;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 2344;
				Match(NOT);
				}
			}

			State = 2347;
			Match(OF);
			State = 2349;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TYPE) {
				{
				State = 2348;
				Match(TYPE);
				}
			}

			State = 2351;
			typeComparisonNames();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeComparisonNamesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext[] plainIdentifier() {
			return GetRuleContexts<PlainIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier(int i) {
			return GetRuleContext<PlainIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLY() { return GetToken(OracleAntlrParser.ONLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public TypeComparisonNamesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeComparisonNames; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeComparisonNames(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeComparisonNames(this);
		}
	}

	[RuleVersion(0)]
	public TypeComparisonNamesContext typeComparisonNames() {
		TypeComparisonNamesContext _localctx = new TypeComparisonNamesContext(Context, State);
		EnterRule(_localctx, 194, RULE_typeComparisonNames);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2353;
			Match(LPAREN);
			State = 2355;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,101,Context) ) {
			case 1:
				{
				State = 2354;
				Match(ONLY);
				}
				break;
			}
			State = 2357;
			plainIdentifier();
			State = 2362;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2358;
				Match(COMMA);
				State = 2359;
				plainIdentifier();
				}
				}
				State = 2364;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2365;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PureExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BitwiseLevelExpressionContext bitwiseLevelExpression() {
			return GetRuleContext<BitwiseLevelExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AsteriskContext asterisk() {
			return GetRuleContext<AsteriskContext>(0);
		}
		public PureExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pureExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPureExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPureExpression(this);
		}
	}

	[RuleVersion(0)]
	public PureExpressionContext pureExpression() {
		PureExpressionContext _localctx = new PureExpressionContext(Context, State);
		EnterRule(_localctx, 196, RULE_pureExpression);
		try {
			State = 2369;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CASE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case EXTRACTVALUE:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULL:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYS_CONNECT_BY_PATH:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLCAST:
			case XMLNAMESPACES:
			case XMLQUERY:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case INTEGER_LITERAL:
			case LPAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case QUESTION_MARK:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
			case QUOTE_CHARACTER_STRING_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2367;
				bitwiseLevelExpression();
				}
				break;
			case ASTERISK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2368;
				asterisk();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BitwiseLevelExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AddLevelExpressionContext[] addLevelExpression() {
			return GetRuleContexts<AddLevelExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AddLevelExpressionContext addLevelExpression(int i) {
			return GetRuleContext<AddLevelExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AddLevelOperatorContext[] addLevelOperator() {
			return GetRuleContexts<AddLevelOperatorContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AddLevelOperatorContext addLevelOperator(int i) {
			return GetRuleContext<AddLevelOperatorContext>(i);
		}
		public BitwiseLevelExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitwiseLevelExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBitwiseLevelExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBitwiseLevelExpression(this);
		}
	}

	[RuleVersion(0)]
	public BitwiseLevelExpressionContext bitwiseLevelExpression() {
		BitwiseLevelExpressionContext _localctx = new BitwiseLevelExpressionContext(Context, State);
		EnterRule(_localctx, 198, RULE_bitwiseLevelExpression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2371;
			addLevelExpression();
			State = 2377;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,104,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2372;
					addLevelOperator();
					State = 2373;
					addLevelExpression();
					}
					} 
				}
				State = 2379;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,104,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddLevelExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PowerExpressionContext[] powerExpression() {
			return GetRuleContexts<PowerExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PowerExpressionContext powerExpression(int i) {
			return GetRuleContext<PowerExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DivideLevelOperatorContext[] divideLevelOperator() {
			return GetRuleContexts<DivideLevelOperatorContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DivideLevelOperatorContext divideLevelOperator(int i) {
			return GetRuleContext<DivideLevelOperatorContext>(i);
		}
		public AddLevelExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addLevelExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAddLevelExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAddLevelExpression(this);
		}
	}

	[RuleVersion(0)]
	public AddLevelExpressionContext addLevelExpression() {
		AddLevelExpressionContext _localctx = new AddLevelExpressionContext(Context, State);
		EnterRule(_localctx, 200, RULE_addLevelExpression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2380;
			powerExpression();
			State = 2386;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,105,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2381;
					divideLevelOperator();
					State = 2382;
					powerExpression();
					}
					} 
				}
				State = 2388;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,105,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddLevelOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS_SIGN() { return GetToken(OracleAntlrParser.PLUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_SIGN() { return GetToken(OracleAntlrParser.MINUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONCAT_OPERATOR() { return GetToken(OracleAntlrParser.CONCAT_OPERATOR, 0); }
		public AddLevelOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addLevelOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAddLevelOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAddLevelOperator(this);
		}
	}

	[RuleVersion(0)]
	public AddLevelOperatorContext addLevelOperator() {
		AddLevelOperatorContext _localctx = new AddLevelOperatorContext(Context, State);
		EnterRule(_localctx, 202, RULE_addLevelOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2389;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 584)) & ~0x3f) == 0 && ((1L << (_la - 584)) & ((1L << (CONCAT_OPERATOR - 584)) | (1L << (PLUS_SIGN - 584)) | (1L << (MINUS_SIGN - 584)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DivideLevelOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASTERISK() { return GetToken(OracleAntlrParser.ASTERISK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FSLASH() { return GetToken(OracleAntlrParser.FSLASH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MOD() { return GetToken(OracleAntlrParser.MOD, 0); }
		public DivideLevelOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_divideLevelOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDivideLevelOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDivideLevelOperator(this);
		}
	}

	[RuleVersion(0)]
	public DivideLevelOperatorContext divideLevelOperator() {
		DivideLevelOperatorContext _localctx = new DivideLevelOperatorContext(Context, State);
		EnterRule(_localctx, 204, RULE_divideLevelOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2391;
			_la = TokenStream.LA(1);
			if ( !(_la==MOD || _la==FSLASH || _la==ASTERISK) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterNullContext delimiterNull() {
			return GetRuleContext<DelimiterNullContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CastExpressionContext castExpression() {
			return GetRuleContext<CastExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CursorExpressionContext cursorExpression() {
			return GetRuleContext<CursorExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TrimExpressionContext trimExpression() {
			return GetRuleContext<TrimExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TreatExpressionContext treatExpression() {
			return GetRuleContext<TreatExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseExpressionContext caseExpression() {
			return GetRuleContext<CaseExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DecodeExpressionContext decodeExpression() {
			return GetRuleContext<DecodeExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtractDatetimeExpressionContext extractDatetimeExpression() {
			return GetRuleContext<ExtractDatetimeExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtractXMLExpressionContext extractXMLExpression() {
			return GetRuleContext<ExtractXMLExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NewExpressionContext newExpression() {
			return GetRuleContext<NewExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_SIGN() { return GetToken(OracleAntlrParser.MINUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS_SIGN() { return GetToken(OracleAntlrParser.PLUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PriorExpressionContext priorExpression() {
			return GetRuleContext<PriorExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConnectByRootExpressionContext connectByRootExpression() {
			return GetRuleContext<ConnectByRootExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SysConnectByPathExpressionContext sysConnectByPathExpression() {
			return GetRuleContext<SysConnectByPathExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TranslateExpressionContext translateExpression() {
			return GetRuleContext<TranslateExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CharExpressionContext charExpression() {
			return GetRuleContext<CharExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlaggExpressionContext xmlaggExpression() {
			return GetRuleContext<XmlaggExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CursorAttributeExpressionContext cursorAttributeExpression() {
			return GetRuleContext<CursorAttributeExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BulkExpressionContext bulkExpression() {
			return GetRuleContext<BulkExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionContext overExpression() {
			return GetRuleContext<OverExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WithinExpressionContext withinExpression() {
			return GetRuleContext<WithinExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeepExpressionContext keepExpression() {
			return GetRuleContext<KeepExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BindParameterContext bindParameter() {
			return GetRuleContext<BindParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlQueryContext xmlQuery() {
			return GetRuleContext<XmlQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlCastContext xmlCast() {
			return GetRuleContext<XmlCastContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DateTimeAtClauseContext dateTimeAtClause() {
			return GetRuleContext<DateTimeAtClauseContext>(0);
		}
		public UnaryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUnaryExpression(this);
		}
	}

	[RuleVersion(0)]
	public UnaryExpressionContext unaryExpression() {
		UnaryExpressionContext _localctx = new UnaryExpressionContext(Context, State);
		EnterRule(_localctx, 206, RULE_unaryExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2428;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,106,Context) ) {
			case 1:
				{
				State = 2393;
				delimiterNull();
				}
				break;
			case 2:
				{
				State = 2394;
				literal();
				}
				break;
			case 3:
				{
				State = 2395;
				castExpression();
				}
				break;
			case 4:
				{
				State = 2396;
				cursorExpression();
				}
				break;
			case 5:
				{
				State = 2397;
				trimExpression();
				}
				break;
			case 6:
				{
				State = 2398;
				treatExpression();
				}
				break;
			case 7:
				{
				State = 2399;
				caseExpression();
				}
				break;
			case 8:
				{
				State = 2400;
				decodeExpression();
				}
				break;
			case 9:
				{
				State = 2401;
				extractDatetimeExpression();
				}
				break;
			case 10:
				{
				State = 2402;
				extractXMLExpression();
				}
				break;
			case 11:
				{
				State = 2403;
				newExpression();
				}
				break;
			case 12:
				{
				State = 2404;
				Match(MINUS_SIGN);
				State = 2405;
				unaryExpression();
				}
				break;
			case 13:
				{
				State = 2406;
				Match(PLUS_SIGN);
				State = 2407;
				unaryExpression();
				}
				break;
			case 14:
				{
				State = 2408;
				priorExpression();
				}
				break;
			case 15:
				{
				State = 2409;
				connectByRootExpression();
				}
				break;
			case 16:
				{
				State = 2410;
				sysConnectByPathExpression();
				}
				break;
			case 17:
				{
				State = 2411;
				translateExpression();
				}
				break;
			case 18:
				{
				State = 2412;
				charExpression();
				}
				break;
			case 19:
				{
				State = 2413;
				flattenedQuery();
				}
				break;
			case 20:
				{
				State = 2414;
				Match(LPAREN);
				State = 2415;
				fullExpression();
				State = 2416;
				Match(RPAREN);
				}
				break;
			case 21:
				{
				State = 2418;
				xmlaggExpression();
				}
				break;
			case 22:
				{
				State = 2419;
				cursorAttributeExpression();
				}
				break;
			case 23:
				{
				State = 2420;
				bulkExpression();
				}
				break;
			case 24:
				{
				State = 2421;
				overExpression();
				}
				break;
			case 25:
				{
				State = 2422;
				withinExpression();
				}
				break;
			case 26:
				{
				State = 2423;
				keepExpression();
				}
				break;
			case 27:
				{
				State = 2424;
				identifier();
				}
				break;
			case 28:
				{
				State = 2425;
				bindParameter();
				}
				break;
			case 29:
				{
				State = 2426;
				xmlQuery();
				}
				break;
			case 30:
				{
				State = 2427;
				xmlCast();
				}
				break;
			}
			State = 2431;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,107,Context) ) {
			case 1:
				{
				State = 2430;
				dateTimeAtClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlQueryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public XmlQueryDelegateContext xmlQueryDelegate() {
			return GetRuleContext<XmlQueryDelegateContext>(0);
		}
		public XmlQueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlQuery; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlQuery(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlQuery(this);
		}
	}

	[RuleVersion(0)]
	public XmlQueryContext xmlQuery() {
		XmlQueryContext _localctx = new XmlQueryContext(Context, State);
		EnterRule(_localctx, 208, RULE_xmlQuery);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2433;
			xmlQueryDelegate();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlQueryDelegateContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLQUERY() { return GetToken(OracleAntlrParser.XMLQUERY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSING() { return GetToken(OracleAntlrParser.PASSING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlPassingParameterListContext xmlPassingParameterList() {
			return GetRuleContext<XmlPassingParameterListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURNING() { return GetToken(OracleAntlrParser.RETURNING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTENT() { return GetToken(OracleAntlrParser.CONTENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(OracleAntlrParser.VALUE, 0); }
		public XmlQueryDelegateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlQueryDelegate; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlQueryDelegate(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlQueryDelegate(this);
		}
	}

	[RuleVersion(0)]
	public XmlQueryDelegateContext xmlQueryDelegate() {
		XmlQueryDelegateContext _localctx = new XmlQueryDelegateContext(Context, State);
		EnterRule(_localctx, 210, RULE_xmlQueryDelegate);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2435;
			Match(XMLQUERY);
			State = 2436;
			Match(LPAREN);
			State = 2437;
			pureExpression();
			State = 2438;
			Match(PASSING);
			State = 2441;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BY) {
				{
				State = 2439;
				Match(BY);
				State = 2440;
				Match(VALUE);
				}
			}

			State = 2443;
			xmlPassingParameterList();
			State = 2444;
			Match(RETURNING);
			State = 2445;
			Match(CONTENT);
			State = 2446;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlPassingParameterListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public XmlPassingParameterListItemContext[] xmlPassingParameterListItem() {
			return GetRuleContexts<XmlPassingParameterListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlPassingParameterListItemContext xmlPassingParameterListItem(int i) {
			return GetRuleContext<XmlPassingParameterListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public XmlPassingParameterListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlPassingParameterList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlPassingParameterList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlPassingParameterList(this);
		}
	}

	[RuleVersion(0)]
	public XmlPassingParameterListContext xmlPassingParameterList() {
		XmlPassingParameterListContext _localctx = new XmlPassingParameterListContext(Context, State);
		EnterRule(_localctx, 212, RULE_xmlPassingParameterList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2448;
			xmlPassingParameterListItem();
			State = 2453;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2449;
				Match(COMMA);
				State = 2450;
				xmlPassingParameterListItem();
				}
				}
				State = 2455;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlPassingParameterListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public XmlPassingParameterListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlPassingParameterListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlPassingParameterListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlPassingParameterListItem(this);
		}
	}

	[RuleVersion(0)]
	public XmlPassingParameterListItemContext xmlPassingParameterListItem() {
		XmlPassingParameterListItemContext _localctx = new XmlPassingParameterListItemContext(Context, State);
		EnterRule(_localctx, 214, RULE_xmlPassingParameterListItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2456;
			pureExpression();
			State = 2459;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 2457;
				Match(AS);
				State = 2458;
				identifier();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlCastContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLCAST() { return GetToken(OracleAntlrParser.XMLCAST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MULTISET() { return GetToken(OracleAntlrParser.MULTISET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public XmlCastContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlCast; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlCast(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlCast(this);
		}
	}

	[RuleVersion(0)]
	public XmlCastContext xmlCast() {
		XmlCastContext _localctx = new XmlCastContext(Context, State);
		EnterRule(_localctx, 216, RULE_xmlCast);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2461;
			Match(XMLCAST);
			State = 2462;
			Match(LPAREN);
			State = 2466;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,111,Context) ) {
			case 1:
				{
				State = 2463;
				Match(MULTISET);
				State = 2464;
				flattenedQuery();
				}
				break;
			case 2:
				{
				State = 2465;
				fullExpression();
				}
				break;
			}
			State = 2468;
			Match(AS);
			State = 2469;
			typeReference();
			State = 2470;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(OracleAntlrParser.NEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public NewExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNewExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNewExpression(this);
		}
	}

	[RuleVersion(0)]
	public NewExpressionContext newExpression() {
		NewExpressionContext _localctx = new NewExpressionContext(Context, State);
		EnterRule(_localctx, 218, RULE_newExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2472;
			Match(NEW);
			State = 2473;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TreatExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TREAT() { return GetToken(OracleAntlrParser.TREAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TreatExpressionParametersContext treatExpressionParameters() {
			return GetRuleContext<TreatExpressionParametersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TreatExpressionReturnValueContext treatExpressionReturnValue() {
			return GetRuleContext<TreatExpressionReturnValueContext>(0);
		}
		public TreatExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_treatExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTreatExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTreatExpression(this);
		}
	}

	[RuleVersion(0)]
	public TreatExpressionContext treatExpression() {
		TreatExpressionContext _localctx = new TreatExpressionContext(Context, State);
		EnterRule(_localctx, 220, RULE_treatExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2475;
			Match(TREAT);
			State = 2476;
			treatExpressionParameters();
			State = 2478;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,112,Context) ) {
			case 1:
				{
				State = 2477;
				treatExpressionReturnValue();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TreatExpressionParametersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TreatExpressionAsClauseContext treatExpressionAsClause() {
			return GetRuleContext<TreatExpressionAsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public TreatExpressionParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_treatExpressionParameters; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTreatExpressionParameters(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTreatExpressionParameters(this);
		}
	}

	[RuleVersion(0)]
	public TreatExpressionParametersContext treatExpressionParameters() {
		TreatExpressionParametersContext _localctx = new TreatExpressionParametersContext(Context, State);
		EnterRule(_localctx, 222, RULE_treatExpressionParameters);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2480;
			Match(LPAREN);
			State = 2481;
			fullExpression();
			State = 2482;
			treatExpressionAsClause();
			State = 2483;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TreatExpressionAsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REF() { return GetToken(OracleAntlrParser.REF, 0); }
		public TreatExpressionAsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_treatExpressionAsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTreatExpressionAsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTreatExpressionAsClause(this);
		}
	}

	[RuleVersion(0)]
	public TreatExpressionAsClauseContext treatExpressionAsClause() {
		TreatExpressionAsClauseContext _localctx = new TreatExpressionAsClauseContext(Context, State);
		EnterRule(_localctx, 224, RULE_treatExpressionAsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2485;
			Match(AS);
			State = 2487;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,113,Context) ) {
			case 1:
				{
				State = 2486;
				Match(REF);
				}
				break;
			}
			State = 2489;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TreatExpressionReturnValueContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(OracleAntlrParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public TreatExpressionReturnValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_treatExpressionReturnValue; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTreatExpressionReturnValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTreatExpressionReturnValue(this);
		}
	}

	[RuleVersion(0)]
	public TreatExpressionReturnValueContext treatExpressionReturnValue() {
		TreatExpressionReturnValueContext _localctx = new TreatExpressionReturnValueContext(Context, State);
		EnterRule(_localctx, 226, RULE_treatExpressionReturnValue);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2491;
			Match(DOT);
			State = 2492;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultisetExpressionContext : ParserRuleContext {
		public MultisetOperatorContext operators;
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext[] unaryExpression() {
			return GetRuleContexts<UnaryExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression(int i) {
			return GetRuleContext<UnaryExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultisetOperatorContext[] multisetOperator() {
			return GetRuleContexts<MultisetOperatorContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultisetOperatorContext multisetOperator(int i) {
			return GetRuleContext<MultisetOperatorContext>(i);
		}
		public MultisetExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multisetExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMultisetExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMultisetExpression(this);
		}
	}

	[RuleVersion(0)]
	public MultisetExpressionContext multisetExpression() {
		MultisetExpressionContext _localctx = new MultisetExpressionContext(Context, State);
		EnterRule(_localctx, 228, RULE_multisetExpression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2494;
			unaryExpression();
			State = 2500;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,114,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2495;
					_localctx.operators = multisetOperator();
					State = 2496;
					unaryExpression();
					}
					} 
				}
				State = 2502;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,114,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultisetOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MULTISET() { return GetToken(OracleAntlrParser.MULTISET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPT() { return GetToken(OracleAntlrParser.EXCEPT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERSECT() { return GetToken(OracleAntlrParser.INTERSECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNION() { return GetToken(OracleAntlrParser.UNION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISTINCT() { return GetToken(OracleAntlrParser.DISTINCT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		public MultisetOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multisetOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMultisetOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMultisetOperator(this);
		}
	}

	[RuleVersion(0)]
	public MultisetOperatorContext multisetOperator() {
		MultisetOperatorContext _localctx = new MultisetOperatorContext(Context, State);
		EnterRule(_localctx, 230, RULE_multisetOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2503;
			Match(MULTISET);
			State = 2504;
			_la = TokenStream.LA(1);
			if ( !(_la==EXCEPT || _la==INTERSECT || _la==UNION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2506;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==DISTINCT) {
				{
				State = 2505;
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==DISTINCT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DateTimeAtClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT() { return GetToken(OracleAntlrParser.AT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DateTimeAtLocalClauseContext dateTimeAtLocalClause() {
			return GetRuleContext<DateTimeAtLocalClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DateTimeAtTimeZoneClauseContext dateTimeAtTimeZoneClause() {
			return GetRuleContext<DateTimeAtTimeZoneClauseContext>(0);
		}
		public DateTimeAtClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dateTimeAtClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDateTimeAtClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDateTimeAtClause(this);
		}
	}

	[RuleVersion(0)]
	public DateTimeAtClauseContext dateTimeAtClause() {
		DateTimeAtClauseContext _localctx = new DateTimeAtClauseContext(Context, State);
		EnterRule(_localctx, 232, RULE_dateTimeAtClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2508;
			Match(AT);
			State = 2511;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LOCAL:
				{
				State = 2509;
				dateTimeAtLocalClause();
				}
				break;
			case TIME:
				{
				State = 2510;
				dateTimeAtTimeZoneClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DateTimeAtLocalClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(OracleAntlrParser.LOCAL, 0); }
		public DateTimeAtLocalClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dateTimeAtLocalClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDateTimeAtLocalClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDateTimeAtLocalClause(this);
		}
	}

	[RuleVersion(0)]
	public DateTimeAtLocalClauseContext dateTimeAtLocalClause() {
		DateTimeAtLocalClauseContext _localctx = new DateTimeAtLocalClauseContext(Context, State);
		EnterRule(_localctx, 234, RULE_dateTimeAtLocalClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2513;
			Match(LOCAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DateTimeAtTimeZoneClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIME() { return GetToken(OracleAntlrParser.TIME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ZONE() { return GetToken(OracleAntlrParser.ZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DBTIMEZONE() { return GetToken(OracleAntlrParser.DBTIMEZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SESSIONTIMEZONE() { return GetToken(OracleAntlrParser.SESSIONTIMEZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		public DateTimeAtTimeZoneClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dateTimeAtTimeZoneClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDateTimeAtTimeZoneClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDateTimeAtTimeZoneClause(this);
		}
	}

	[RuleVersion(0)]
	public DateTimeAtTimeZoneClauseContext dateTimeAtTimeZoneClause() {
		DateTimeAtTimeZoneClauseContext _localctx = new DateTimeAtTimeZoneClauseContext(Context, State);
		EnterRule(_localctx, 236, RULE_dateTimeAtTimeZoneClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2515;
			Match(TIME);
			State = 2516;
			Match(ZONE);
			State = 2520;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,117,Context) ) {
			case 1:
				{
				State = 2517;
				Match(DBTIMEZONE);
				}
				break;
			case 2:
				{
				State = 2518;
				Match(SESSIONTIMEZONE);
				}
				break;
			case 3:
				{
				State = 2519;
				unaryExpression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeepExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeepClauseContext keepClause() {
			return GetRuleContext<KeepClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionParamsContext overExpressionParams() {
			return GetRuleContext<OverExpressionParamsContext>(0);
		}
		public KeepExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keepExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterKeepExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitKeepExpression(this);
		}
	}

	[RuleVersion(0)]
	public KeepExpressionContext keepExpression() {
		KeepExpressionContext _localctx = new KeepExpressionContext(Context, State);
		EnterRule(_localctx, 238, RULE_keepExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2522;
			identifier();
			State = 2523;
			keepClause();
			State = 2525;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,118,Context) ) {
			case 1:
				{
				State = 2524;
				overExpressionParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeepClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DENSE_RANK() { return GetToken(OracleAntlrParser.DENSE_RANK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIRST() { return GetToken(OracleAntlrParser.FIRST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LAST() { return GetToken(OracleAntlrParser.LAST, 0); }
		public KeepClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keepClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterKeepClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitKeepClause(this);
		}
	}

	[RuleVersion(0)]
	public KeepClauseContext keepClause() {
		KeepClauseContext _localctx = new KeepClauseContext(Context, State);
		EnterRule(_localctx, 240, RULE_keepClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2527;
			Match(KEEP);
			State = 2528;
			Match(LPAREN);
			State = 2529;
			Match(DENSE_RANK);
			State = 2530;
			_la = TokenStream.LA(1);
			if ( !(_la==FIRST || _la==LAST) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2531;
			orderByClause();
			State = 2532;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithinExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WithinExpressionParamsContext withinExpressionParams() {
			return GetRuleContext<WithinExpressionParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionParamsContext overExpressionParams() {
			return GetRuleContext<OverExpressionParamsContext>(0);
		}
		public WithinExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withinExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterWithinExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitWithinExpression(this);
		}
	}

	[RuleVersion(0)]
	public WithinExpressionContext withinExpression() {
		WithinExpressionContext _localctx = new WithinExpressionContext(Context, State);
		EnterRule(_localctx, 242, RULE_withinExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2534;
			identifier();
			State = 2535;
			withinExpressionParams();
			State = 2537;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,119,Context) ) {
			case 1:
				{
				State = 2536;
				overExpressionParams();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithinExpressionParamsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITHIN() { return GetToken(OracleAntlrParser.WITHIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUP() { return GetToken(OracleAntlrParser.GROUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public WithinGroupOrderByClauseContext withinGroupOrderByClause() {
			return GetRuleContext<WithinGroupOrderByClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public WithinExpressionParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withinExpressionParams; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterWithinExpressionParams(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitWithinExpressionParams(this);
		}
	}

	[RuleVersion(0)]
	public WithinExpressionParamsContext withinExpressionParams() {
		WithinExpressionParamsContext _localctx = new WithinExpressionParamsContext(Context, State);
		EnterRule(_localctx, 244, RULE_withinExpressionParams);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2539;
			Match(WITHIN);
			State = 2540;
			Match(GROUP);
			State = 2541;
			Match(LPAREN);
			State = 2542;
			withinGroupOrderByClause();
			State = 2543;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionParamsContext overExpressionParams() {
			return GetRuleContext<OverExpressionParamsContext>(0);
		}
		public OverExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOverExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOverExpression(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionContext overExpression() {
		OverExpressionContext _localctx = new OverExpressionContext(Context, State);
		EnterRule(_localctx, 246, RULE_overExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2545;
			identifier();
			State = 2546;
			overExpressionParams();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionParamsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVER() { return GetToken(OracleAntlrParser.OVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionPartitionClauseContext overExpressionPartitionClause() {
			return GetRuleContext<OverExpressionPartitionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverOrderByClauseContext overOrderByClause() {
			return GetRuleContext<OverOrderByClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionWindowingClauseContext overExpressionWindowingClause() {
			return GetRuleContext<OverExpressionWindowingClauseContext>(0);
		}
		public OverExpressionParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpressionParams; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOverExpressionParams(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOverExpressionParams(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionParamsContext overExpressionParams() {
		OverExpressionParamsContext _localctx = new OverExpressionParamsContext(Context, State);
		EnterRule(_localctx, 248, RULE_overExpressionParams);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2548;
			Match(OVER);
			State = 2549;
			Match(LPAREN);
			State = 2551;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 2550;
				overExpressionPartitionClause();
				}
			}

			State = 2557;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 2553;
				overOrderByClause();
				State = 2555;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==RANGE || _la==ROWS) {
					{
					State = 2554;
					overExpressionWindowingClause();
					}
				}

				}
			}

			State = 2559;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionPartitionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public OverExpressionPartitionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpressionPartitionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOverExpressionPartitionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOverExpressionPartitionClause(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionPartitionClauseContext overExpressionPartitionClause() {
		OverExpressionPartitionClauseContext _localctx = new OverExpressionPartitionClauseContext(Context, State);
		EnterRule(_localctx, 250, RULE_overExpressionPartitionClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2561;
			Match(PARTITION);
			State = 2562;
			Match(BY);
			State = 2563;
			expressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionWindowingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWS() { return GetToken(OracleAntlrParser.ROWS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(OracleAntlrParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionWindowingClauseBetweenContext overExpressionWindowingClauseBetween() {
			return GetRuleContext<OverExpressionWindowingClauseBetweenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionWindowingClauseSingleContext overExpressionWindowingClauseSingle() {
			return GetRuleContext<OverExpressionWindowingClauseSingleContext>(0);
		}
		public OverExpressionWindowingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpressionWindowingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOverExpressionWindowingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOverExpressionWindowingClause(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionWindowingClauseContext overExpressionWindowingClause() {
		OverExpressionWindowingClauseContext _localctx = new OverExpressionWindowingClauseContext(Context, State);
		EnterRule(_localctx, 252, RULE_overExpressionWindowingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2565;
			_la = TokenStream.LA(1);
			if ( !(_la==RANGE || _la==ROWS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2568;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BETWEEN:
				{
				State = 2566;
				overExpressionWindowingClauseBetween();
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CASE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case EXTRACTVALUE:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULL:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYS_CONNECT_BY_PATH:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLCAST:
			case XMLNAMESPACES:
			case XMLQUERY:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case INTEGER_LITERAL:
			case LPAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case QUESTION_MARK:
			case ASTERISK:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
			case QUOTE_CHARACTER_STRING_LITERAL:
				{
				State = 2567;
				overExpressionWindowingClauseSingle();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionWindowingClauseBetweenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BETWEEN() { return GetToken(OracleAntlrParser.BETWEEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionWindowingClauseItemContext[] overExpressionWindowingClauseItem() {
			return GetRuleContexts<OverExpressionWindowingClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionWindowingClauseItemContext overExpressionWindowingClauseItem(int i) {
			return GetRuleContext<OverExpressionWindowingClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(OracleAntlrParser.AND, 0); }
		public OverExpressionWindowingClauseBetweenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpressionWindowingClauseBetween; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOverExpressionWindowingClauseBetween(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOverExpressionWindowingClauseBetween(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionWindowingClauseBetweenContext overExpressionWindowingClauseBetween() {
		OverExpressionWindowingClauseBetweenContext _localctx = new OverExpressionWindowingClauseBetweenContext(Context, State);
		EnterRule(_localctx, 254, RULE_overExpressionWindowingClauseBetween);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2570;
			Match(BETWEEN);
			State = 2571;
			overExpressionWindowingClauseItem();
			State = 2572;
			Match(AND);
			State = 2573;
			overExpressionWindowingClauseItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionWindowingClauseSingleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionWindowingClauseItemContext overExpressionWindowingClauseItem() {
			return GetRuleContext<OverExpressionWindowingClauseItemContext>(0);
		}
		public OverExpressionWindowingClauseSingleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpressionWindowingClauseSingle; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOverExpressionWindowingClauseSingle(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOverExpressionWindowingClauseSingle(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionWindowingClauseSingleContext overExpressionWindowingClauseSingle() {
		OverExpressionWindowingClauseSingleContext _localctx = new OverExpressionWindowingClauseSingleContext(Context, State);
		EnterRule(_localctx, 256, RULE_overExpressionWindowingClauseSingle);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2575;
			overExpressionWindowingClauseItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionWindowingClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNBOUNDED() { return GetToken(OracleAntlrParser.UNBOUNDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRECEDING() { return GetToken(OracleAntlrParser.PRECEDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOLLOWING() { return GetToken(OracleAntlrParser.FOLLOWING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(OracleAntlrParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OverExpressionWindowingClauseItemExpressionContext overExpressionWindowingClauseItemExpression() {
			return GetRuleContext<OverExpressionWindowingClauseItemExpressionContext>(0);
		}
		public OverExpressionWindowingClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpressionWindowingClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOverExpressionWindowingClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOverExpressionWindowingClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionWindowingClauseItemContext overExpressionWindowingClauseItem() {
		OverExpressionWindowingClauseItemContext _localctx = new OverExpressionWindowingClauseItemContext(Context, State);
		EnterRule(_localctx, 258, RULE_overExpressionWindowingClauseItem);
		int _la;
		try {
			State = 2584;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,124,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2577;
				Match(UNBOUNDED);
				State = 2578;
				_la = TokenStream.LA(1);
				if ( !(_la==FOLLOWING || _la==PRECEDING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2579;
				Match(CURRENT);
				State = 2580;
				Match(ROW);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2581;
				overExpressionWindowingClauseItemExpression();
				State = 2582;
				_la = TokenStream.LA(1);
				if ( !(_la==FOLLOWING || _la==PRECEDING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverExpressionWindowingClauseItemExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public OverExpressionWindowingClauseItemExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overExpressionWindowingClauseItemExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOverExpressionWindowingClauseItemExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOverExpressionWindowingClauseItemExpression(this);
		}
	}

	[RuleVersion(0)]
	public OverExpressionWindowingClauseItemExpressionContext overExpressionWindowingClauseItemExpression() {
		OverExpressionWindowingClauseItemExpressionContext _localctx = new OverExpressionWindowingClauseItemExpressionContext(Context, State);
		EnterRule(_localctx, 260, RULE_overExpressionWindowingClauseItemExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2586;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CursorAttributeExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT_SIGN() { return GetToken(OracleAntlrParser.PERCENT_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOUND() { return GetToken(OracleAntlrParser.FOUND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ISOPEN() { return GetToken(OracleAntlrParser.ISOPEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOTFOUND() { return GetToken(OracleAntlrParser.NOTFOUND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWCOUNT() { return GetToken(OracleAntlrParser.ROWCOUNT, 0); }
		public CursorAttributeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursorAttributeExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCursorAttributeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCursorAttributeExpression(this);
		}
	}

	[RuleVersion(0)]
	public CursorAttributeExpressionContext cursorAttributeExpression() {
		CursorAttributeExpressionContext _localctx = new CursorAttributeExpressionContext(Context, State);
		EnterRule(_localctx, 262, RULE_cursorAttributeExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2588;
			identifier();
			State = 2589;
			Match(PERCENT_SIGN);
			State = 2590;
			_la = TokenStream.LA(1);
			if ( !(_la==FOUND || _la==ISOPEN || _la==NOTFOUND || _la==ROWCOUNT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BulkExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT_SIGN() { return GetToken(OracleAntlrParser.PERCENT_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BulkExceptionExpressionContext bulkExceptionExpression() {
			return GetRuleContext<BulkExceptionExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BulkRowCountExpressionContext bulkRowCountExpression() {
			return GetRuleContext<BulkRowCountExpressionContext>(0);
		}
		public BulkExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bulkExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBulkExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBulkExpression(this);
		}
	}

	[RuleVersion(0)]
	public BulkExpressionContext bulkExpression() {
		BulkExpressionContext _localctx = new BulkExpressionContext(Context, State);
		EnterRule(_localctx, 264, RULE_bulkExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2592;
			identifier();
			State = 2593;
			Match(PERCENT_SIGN);
			State = 2596;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BULK_EXCEPTIONS:
				{
				State = 2594;
				bulkExceptionExpression();
				}
				break;
			case BULK_ROWCOUNT:
				{
				State = 2595;
				bulkRowCountExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BulkExceptionExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BULK_EXCEPTIONS() { return GetToken(OracleAntlrParser.BULK_EXCEPTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(OracleAntlrParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COUNT() { return GetToken(OracleAntlrParser.COUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CollectionIndexContext collectionIndex() {
			return GetRuleContext<CollectionIndexContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR_INDEX() { return GetToken(OracleAntlrParser.ERROR_INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR_CODE() { return GetToken(OracleAntlrParser.ERROR_CODE, 0); }
		public BulkExceptionExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bulkExceptionExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBulkExceptionExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBulkExceptionExpression(this);
		}
	}

	[RuleVersion(0)]
	public BulkExceptionExpressionContext bulkExceptionExpression() {
		BulkExceptionExpressionContext _localctx = new BulkExceptionExpressionContext(Context, State);
		EnterRule(_localctx, 266, RULE_bulkExceptionExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2598;
			Match(BULK_EXCEPTIONS);
			State = 2605;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DOT:
				{
				State = 2599;
				Match(DOT);
				State = 2600;
				Match(COUNT);
				}
				break;
			case LPAREN:
				{
				State = 2601;
				collectionIndex();
				State = 2602;
				Match(DOT);
				State = 2603;
				_la = TokenStream.LA(1);
				if ( !(_la==ERROR_CODE || _la==ERROR_INDEX) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BulkRowCountExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BULK_ROWCOUNT() { return GetToken(OracleAntlrParser.BULK_ROWCOUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CollectionIndexContext collectionIndex() {
			return GetRuleContext<CollectionIndexContext>(0);
		}
		public BulkRowCountExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bulkRowCountExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBulkRowCountExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBulkRowCountExpression(this);
		}
	}

	[RuleVersion(0)]
	public BulkRowCountExpressionContext bulkRowCountExpression() {
		BulkRowCountExpressionContext _localctx = new BulkRowCountExpressionContext(Context, State);
		EnterRule(_localctx, 268, RULE_bulkRowCountExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2607;
			Match(BULK_ROWCOUNT);
			State = 2608;
			collectionIndex();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectionIndexContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public CollectionIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectionIndex; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCollectionIndex(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCollectionIndex(this);
		}
	}

	[RuleVersion(0)]
	public CollectionIndexContext collectionIndex() {
		CollectionIndexContext _localctx = new CollectionIndexContext(Context, State);
		EnterRule(_localctx, 270, RULE_collectionIndex);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2610;
			Match(LPAREN);
			State = 2611;
			fullExpression();
			State = 2612;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PowerExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MultisetExpressionContext[] multisetExpression() {
			return GetRuleContexts<MultisetExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultisetExpressionContext multisetExpression(int i) {
			return GetRuleContext<MultisetExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POWER_OPERATOR() { return GetToken(OracleAntlrParser.POWER_OPERATOR, 0); }
		public PowerExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_powerExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPowerExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPowerExpression(this);
		}
	}

	[RuleVersion(0)]
	public PowerExpressionContext powerExpression() {
		PowerExpressionContext _localctx = new PowerExpressionContext(Context, State);
		EnterRule(_localctx, 272, RULE_powerExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2614;
			multisetExpression();
			State = 2617;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,127,Context) ) {
			case 1:
				{
				State = 2615;
				Match(POWER_OPERATOR);
				State = 2616;
				multisetExpression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterNullContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public DelimiterNullContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterNull; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterNull(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterNull(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterNullContext delimiterNull() {
		DelimiterNullContext _localctx = new DelimiterNullContext(Context, State);
		EnterRule(_localctx, 274, RULE_delimiterNull);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2619;
			Match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterNanContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAN() { return GetToken(OracleAntlrParser.NAN, 0); }
		public DelimiterNanContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterNan; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterNan(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterNan(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterNanContext delimiterNan() {
		DelimiterNanContext _localctx = new DelimiterNanContext(Context, State);
		EnterRule(_localctx, 276, RULE_delimiterNan);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2621;
			Match(NAN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterInfiniteContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INFINITE() { return GetToken(OracleAntlrParser.INFINITE, 0); }
		public DelimiterInfiniteContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterInfinite; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterInfinite(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterInfinite(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterInfiniteContext delimiterInfinite() {
		DelimiterInfiniteContext _localctx = new DelimiterInfiniteContext(Context, State);
		EnterRule(_localctx, 278, RULE_delimiterInfinite);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2623;
			Match(INFINITE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterOperandOfIsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterNullContext delimiterNull() {
			return GetRuleContext<DelimiterNullContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterNanContext delimiterNan() {
			return GetRuleContext<DelimiterNanContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterInfiniteContext delimiterInfinite() {
			return GetRuleContext<DelimiterInfiniteContext>(0);
		}
		public DelimiterOperandOfIsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterOperandOfIs; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterOperandOfIs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterOperandOfIs(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterOperandOfIsContext delimiterOperandOfIs() {
		DelimiterOperandOfIsContext _localctx = new DelimiterOperandOfIsContext(Context, State);
		EnterRule(_localctx, 280, RULE_delimiterOperandOfIs);
		try {
			State = 2628;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NULL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2625;
				delimiterNull();
				}
				break;
			case NAN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2626;
				delimiterNan();
				}
				break;
			case INFINITE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2627;
				delimiterInfinite();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CastExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CAST() { return GetToken(OracleAntlrParser.CAST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MULTISET() { return GetToken(OracleAntlrParser.MULTISET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public CastExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_castExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCastExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCastExpression(this);
		}
	}

	[RuleVersion(0)]
	public CastExpressionContext castExpression() {
		CastExpressionContext _localctx = new CastExpressionContext(Context, State);
		EnterRule(_localctx, 282, RULE_castExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2630;
			Match(CAST);
			State = 2631;
			Match(LPAREN);
			State = 2635;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,129,Context) ) {
			case 1:
				{
				State = 2632;
				Match(MULTISET);
				State = 2633;
				flattenedQuery();
				}
				break;
			case 2:
				{
				State = 2634;
				fullExpression();
				}
				break;
			}
			State = 2637;
			Match(AS);
			State = 2638;
			typeReference();
			State = 2639;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CursorExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURSOR() { return GetToken(OracleAntlrParser.CURSOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public CursorExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursorExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCursorExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCursorExpression(this);
		}
	}

	[RuleVersion(0)]
	public CursorExpressionContext cursorExpression() {
		CursorExpressionContext _localctx = new CursorExpressionContext(Context, State);
		EnterRule(_localctx, 284, RULE_cursorExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2641;
			Match(CURSOR);
			State = 2642;
			Match(LPAREN);
			State = 2643;
			selectStatement();
			State = 2644;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASE() { return GetToken(OracleAntlrParser.CASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(OracleAntlrParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SearchedCaseExpressionContext searchedCaseExpression() {
			return GetRuleContext<SearchedCaseExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleCaseExpressionContext simpleCaseExpression() {
			return GetRuleContext<SimpleCaseExpressionContext>(0);
		}
		public CaseExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCaseExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCaseExpression(this);
		}
	}

	[RuleVersion(0)]
	public CaseExpressionContext caseExpression() {
		CaseExpressionContext _localctx = new CaseExpressionContext(Context, State);
		EnterRule(_localctx, 286, RULE_caseExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2646;
			Match(CASE);
			State = 2649;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,130,Context) ) {
			case 1:
				{
				State = 2647;
				searchedCaseExpression();
				}
				break;
			case 2:
				{
				State = 2648;
				simpleCaseExpression();
				}
				break;
			}
			State = 2651;
			Match(END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleCaseExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleCaseWhenEntryContext[] simpleCaseWhenEntry() {
			return GetRuleContexts<SimpleCaseWhenEntryContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleCaseWhenEntryContext simpleCaseWhenEntry(int i) {
			return GetRuleContext<SimpleCaseWhenEntryContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseElseEntryContext caseElseEntry() {
			return GetRuleContext<CaseElseEntryContext>(0);
		}
		public SimpleCaseExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleCaseExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSimpleCaseExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSimpleCaseExpression(this);
		}
	}

	[RuleVersion(0)]
	public SimpleCaseExpressionContext simpleCaseExpression() {
		SimpleCaseExpressionContext _localctx = new SimpleCaseExpressionContext(Context, State);
		EnterRule(_localctx, 288, RULE_simpleCaseExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2653;
			fullExpression();
			State = 2655;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2654;
				simpleCaseWhenEntry();
				}
				}
				State = 2657;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 2660;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 2659;
				caseElseEntry();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleCaseWhenEntryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(OracleAntlrParser.THEN, 0); }
		public SimpleCaseWhenEntryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleCaseWhenEntry; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSimpleCaseWhenEntry(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSimpleCaseWhenEntry(this);
		}
	}

	[RuleVersion(0)]
	public SimpleCaseWhenEntryContext simpleCaseWhenEntry() {
		SimpleCaseWhenEntryContext _localctx = new SimpleCaseWhenEntryContext(Context, State);
		EnterRule(_localctx, 290, RULE_simpleCaseWhenEntry);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2662;
			Match(WHEN);
			State = 2663;
			fullExpression();
			State = 2664;
			Match(THEN);
			State = 2665;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseElseEntryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(OracleAntlrParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public CaseElseEntryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseElseEntry; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCaseElseEntry(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCaseElseEntry(this);
		}
	}

	[RuleVersion(0)]
	public CaseElseEntryContext caseElseEntry() {
		CaseElseEntryContext _localctx = new CaseElseEntryContext(Context, State);
		EnterRule(_localctx, 292, RULE_caseElseEntry);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2667;
			Match(ELSE);
			State = 2668;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SearchedCaseExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SearchedCaseWhenEntryContext[] searchedCaseWhenEntry() {
			return GetRuleContexts<SearchedCaseWhenEntryContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SearchedCaseWhenEntryContext searchedCaseWhenEntry(int i) {
			return GetRuleContext<SearchedCaseWhenEntryContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseElseEntryContext caseElseEntry() {
			return GetRuleContext<CaseElseEntryContext>(0);
		}
		public SearchedCaseExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searchedCaseExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSearchedCaseExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSearchedCaseExpression(this);
		}
	}

	[RuleVersion(0)]
	public SearchedCaseExpressionContext searchedCaseExpression() {
		SearchedCaseExpressionContext _localctx = new SearchedCaseExpressionContext(Context, State);
		EnterRule(_localctx, 294, RULE_searchedCaseExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2671;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2670;
				searchedCaseWhenEntry();
				}
				}
				State = 2673;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 2676;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 2675;
				caseElseEntry();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SearchedCaseWhenEntryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(OracleAntlrParser.THEN, 0); }
		public SearchedCaseWhenEntryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searchedCaseWhenEntry; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSearchedCaseWhenEntry(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSearchedCaseWhenEntry(this);
		}
	}

	[RuleVersion(0)]
	public SearchedCaseWhenEntryContext searchedCaseWhenEntry() {
		SearchedCaseWhenEntryContext _localctx = new SearchedCaseWhenEntryContext(Context, State);
		EnterRule(_localctx, 296, RULE_searchedCaseWhenEntry);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2678;
			Match(WHEN);
			State = 2679;
			fullExpression();
			State = 2680;
			Match(THEN);
			State = 2681;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PriorExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIOR() { return GetToken(OracleAntlrParser.PRIOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		public PriorExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_priorExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPriorExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPriorExpression(this);
		}
	}

	[RuleVersion(0)]
	public PriorExpressionContext priorExpression() {
		PriorExpressionContext _localctx = new PriorExpressionContext(Context, State);
		EnterRule(_localctx, 298, RULE_priorExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2683;
			Match(PRIOR);
			State = 2684;
			unaryExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConnectByRootExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONNECT_BY_ROOT() { return GetToken(OracleAntlrParser.CONNECT_BY_ROOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		public ConnectByRootExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_connectByRootExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConnectByRootExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConnectByRootExpression(this);
		}
	}

	[RuleVersion(0)]
	public ConnectByRootExpressionContext connectByRootExpression() {
		ConnectByRootExpressionContext _localctx = new ConnectByRootExpressionContext(Context, State);
		EnterRule(_localctx, 300, RULE_connectByRootExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2686;
			Match(CONNECT_BY_ROOT);
			State = 2687;
			unaryExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SysConnectByPathExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SYS_CONNECT_BY_PATH() { return GetToken(OracleAntlrParser.SYS_CONNECT_BY_PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierParamsContext simpleIdentifierParams() {
			return GetRuleContext<SimpleIdentifierParamsContext>(0);
		}
		public SysConnectByPathExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sysConnectByPathExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSysConnectByPathExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSysConnectByPathExpression(this);
		}
	}

	[RuleVersion(0)]
	public SysConnectByPathExpressionContext sysConnectByPathExpression() {
		SysConnectByPathExpressionContext _localctx = new SysConnectByPathExpressionContext(Context, State);
		EnterRule(_localctx, 302, RULE_sysConnectByPathExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2689;
			Match(SYS_CONNECT_BY_PATH);
			State = 2690;
			simpleIdentifierParams();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TrimExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIM() { return GetToken(OracleAntlrParser.TRIM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TrimExtClauseContext trimExtClause() {
			return GetRuleContext<TrimExtClauseContext>(0);
		}
		public TrimExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trimExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTrimExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTrimExpression(this);
		}
	}

	[RuleVersion(0)]
	public TrimExpressionContext trimExpression() {
		TrimExpressionContext _localctx = new TrimExpressionContext(Context, State);
		EnterRule(_localctx, 304, RULE_trimExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2692;
			Match(TRIM);
			State = 2693;
			Match(LPAREN);
			State = 2695;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,135,Context) ) {
			case 1:
				{
				State = 2694;
				trimExtClause();
				}
				break;
			}
			State = 2697;
			fullExpression();
			State = 2698;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TrimExtClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(OracleAntlrParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEADING() { return GetToken(OracleAntlrParser.LEADING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRAILING() { return GetToken(OracleAntlrParser.TRAILING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOTH() { return GetToken(OracleAntlrParser.BOTH, 0); }
		public TrimExtClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trimExtClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTrimExtClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTrimExtClause(this);
		}
	}

	[RuleVersion(0)]
	public TrimExtClauseContext trimExtClause() {
		TrimExtClauseContext _localctx = new TrimExtClauseContext(Context, State);
		EnterRule(_localctx, 306, RULE_trimExtClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2705;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,137,Context) ) {
			case 1:
				{
				State = 2700;
				_la = TokenStream.LA(1);
				if ( !(_la==BOTH || _la==LEADING || _la==TRAILING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2702;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLAGG - 512)) | (1L << (XMLCAST - 512)) | (1L << (XMLNAMESPACES - 512)) | (1L << (XMLQUERY - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (INTEGER_LITERAL - 576)) | (1L << (LPAREN - 576)) | (1L << (PLUS_SIGN - 576)) | (1L << (MINUS_SIGN - 576)) | (1L << (QUESTION_MARK - 576)) | (1L << (ASTERISK - 576)) | (1L << (FLOATING_POINT_LITERAL - 576)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 576)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 576)) | (1L << (BINARY_STRING_LITERAL - 576)) | (1L << (CHARACTER_STRING_LITERAL - 576)) | (1L << (MONEY_LITERAL - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 576)))) != 0)) {
					{
					State = 2701;
					fullExpression();
					}
				}

				}
				break;
			case 2:
				{
				State = 2704;
				fullExpression();
				}
				break;
			}
			State = 2707;
			Match(FROM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DecodeExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECODE() { return GetToken(OracleAntlrParser.DECODE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public DecodeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_decodeExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDecodeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDecodeExpression(this);
		}
	}

	[RuleVersion(0)]
	public DecodeExpressionContext decodeExpression() {
		DecodeExpressionContext _localctx = new DecodeExpressionContext(Context, State);
		EnterRule(_localctx, 308, RULE_decodeExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2709;
			Match(DECODE);
			State = 2710;
			Match(LPAREN);
			State = 2711;
			fullExpression();
			State = 2716;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2712;
				Match(COMMA);
				State = 2713;
				fullExpression();
				}
				}
				State = 2718;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2719;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtractDatetimeExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTRACT() { return GetToken(OracleAntlrParser.EXTRACT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExtractDatetimeFromClauseContext extractDatetimeFromClause() {
			return GetRuleContext<ExtractDatetimeFromClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode YEAR() { return GetToken(OracleAntlrParser.YEAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MONTH() { return GetToken(OracleAntlrParser.MONTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DAY() { return GetToken(OracleAntlrParser.DAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HOUR() { return GetToken(OracleAntlrParser.HOUR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUTE() { return GetToken(OracleAntlrParser.MINUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECOND() { return GetToken(OracleAntlrParser.SECOND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_HOUR() { return GetToken(OracleAntlrParser.TIMEZONE_HOUR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_MINUTE() { return GetToken(OracleAntlrParser.TIMEZONE_MINUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_REGION() { return GetToken(OracleAntlrParser.TIMEZONE_REGION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE_ABBR() { return GetToken(OracleAntlrParser.TIMEZONE_ABBR, 0); }
		public ExtractDatetimeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extractDatetimeExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExtractDatetimeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExtractDatetimeExpression(this);
		}
	}

	[RuleVersion(0)]
	public ExtractDatetimeExpressionContext extractDatetimeExpression() {
		ExtractDatetimeExpressionContext _localctx = new ExtractDatetimeExpressionContext(Context, State);
		EnterRule(_localctx, 310, RULE_extractDatetimeExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2721;
			Match(EXTRACT);
			State = 2722;
			Match(LPAREN);
			State = 2723;
			_la = TokenStream.LA(1);
			if ( !(_la==DAY || _la==HOUR || _la==MINUTE || _la==MONTH || ((((_la - 460)) & ~0x3f) == 0 && ((1L << (_la - 460)) & ((1L << (SECOND - 460)) | (1L << (TIMEZONE_ABBR - 460)) | (1L << (TIMEZONE_HOUR - 460)) | (1L << (TIMEZONE_MINUTE - 460)) | (1L << (TIMEZONE_REGION - 460)))) != 0) || _la==YEAR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2724;
			extractDatetimeFromClause();
			State = 2725;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtractXMLExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeInstanceContext xmlTypeInstance() {
			return GetRuleContext<XmlTypeInstanceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XpathStringContext xpathString() {
			return GetRuleContext<XpathStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTRACT() { return GetToken(OracleAntlrParser.EXTRACT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTRACTVALUE() { return GetToken(OracleAntlrParser.EXTRACTVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlNamespaceContext xmlNamespace() {
			return GetRuleContext<XmlNamespaceContext>(0);
		}
		public ExtractXMLExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extractXMLExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExtractXMLExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExtractXMLExpression(this);
		}
	}

	[RuleVersion(0)]
	public ExtractXMLExpressionContext extractXMLExpression() {
		ExtractXMLExpressionContext _localctx = new ExtractXMLExpressionContext(Context, State);
		EnterRule(_localctx, 312, RULE_extractXMLExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2727;
			_la = TokenStream.LA(1);
			if ( !(_la==EXTRACT || _la==EXTRACTVALUE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2728;
			Match(LPAREN);
			State = 2729;
			xmlTypeInstance();
			State = 2730;
			Match(COMMA);
			State = 2731;
			xpathString();
			State = 2734;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 2732;
				Match(COMMA);
				State = 2733;
				xmlNamespace();
				}
			}

			State = 2736;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeInstanceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListItemContext expressionListItem() {
			return GetRuleContext<ExpressionListItemContext>(0);
		}
		public XmlTypeInstanceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeInstance; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlTypeInstance(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlTypeInstance(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeInstanceContext xmlTypeInstance() {
		XmlTypeInstanceContext _localctx = new XmlTypeInstanceContext(Context, State);
		EnterRule(_localctx, 314, RULE_xmlTypeInstance);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2738;
			expressionListItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XpathStringContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		public XpathStringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xpathString; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXpathString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXpathString(this);
		}
	}

	[RuleVersion(0)]
	public XpathStringContext xpathString() {
		XpathStringContext _localctx = new XpathStringContext(Context, State);
		EnterRule(_localctx, 316, RULE_xpathString);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2740;
			pureExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlNamespaceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		public XmlNamespaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlNamespace; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlNamespace(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlNamespace(this);
		}
	}

	[RuleVersion(0)]
	public XmlNamespaceContext xmlNamespace() {
		XmlNamespaceContext _localctx = new XmlNamespaceContext(Context, State);
		EnterRule(_localctx, 318, RULE_xmlNamespace);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2742;
			pureExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtractDatetimeFromClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(OracleAntlrParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterDateContext delimiterDate() {
			return GetRuleContext<DelimiterDateContext>(0);
		}
		public ExtractDatetimeFromClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extractDatetimeFromClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExtractDatetimeFromClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExtractDatetimeFromClause(this);
		}
	}

	[RuleVersion(0)]
	public ExtractDatetimeFromClauseContext extractDatetimeFromClause() {
		ExtractDatetimeFromClauseContext _localctx = new ExtractDatetimeFromClauseContext(Context, State);
		EnterRule(_localctx, 320, RULE_extractDatetimeFromClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2744;
			Match(FROM);
			State = 2746;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,140,Context) ) {
			case 1:
				{
				State = 2745;
				delimiterDate();
				}
				break;
			}
			State = 2748;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterDateContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATE() { return GetToken(OracleAntlrParser.DATE, 0); }
		public DelimiterDateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterDate; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterDate(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterDate(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterDateContext delimiterDate() {
		DelimiterDateContext _localctx = new DelimiterDateContext(Context, State);
		EnterRule(_localctx, 322, RULE_delimiterDate);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2750;
			Match(DATE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiColumnConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public OverlapsConditionContext overlapsCondition() {
			return GetRuleContext<OverlapsConditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterLParenContext delimiterLParen() {
			return GetRuleContext<DelimiterLParenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiItemExpressionListContext multiItemExpressionList() {
			return GetRuleContext<MultiItemExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterRParenContext delimiterRParen() {
			return GetRuleContext<DelimiterRParenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterInContext delimiterIn() {
			return GetRuleContext<DelimiterInContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonPairOperatorContext comparisonPairOperator() {
			return GetRuleContext<ComparisonPairOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonListContext comparisonList() {
			return GetRuleContext<ComparisonListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterNotContext delimiterNot() {
			return GetRuleContext<DelimiterNotContext>(0);
		}
		public MultiColumnConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiColumnCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMultiColumnCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMultiColumnCondition(this);
		}
	}

	[RuleVersion(0)]
	public MultiColumnConditionContext multiColumnCondition() {
		MultiColumnConditionContext _localctx = new MultiColumnConditionContext(Context, State);
		EnterRule(_localctx, 324, RULE_multiColumnCondition);
		int _la;
		try {
			State = 2767;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,144,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2752;
				overlapsCondition();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2753;
				delimiterLParen();
				State = 2754;
				multiItemExpressionList();
				State = 2755;
				delimiterRParen();
				State = 2761;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case IN:
				case NOT:
					{
					State = 2757;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NOT) {
						{
						State = 2756;
						delimiterNot();
						}
					}

					State = 2759;
					delimiterIn();
					}
					break;
				case GREATER_THAN:
				case LESS_THAN:
				case EQUAL_SIGN:
				case BANG:
				case CARET:
				case TILDE:
					{
					State = 2760;
					comparisonPairOperator();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2765;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,143,Context) ) {
				case 1:
					{
					State = 2763;
					comparisonList();
					}
					break;
				case 2:
					{
					State = 2764;
					flattenedQuery();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverlapsConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ParenthesizedExpressionListContext[] parenthesizedExpressionList() {
			return GetRuleContexts<ParenthesizedExpressionListContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParenthesizedExpressionListContext parenthesizedExpressionList(int i) {
			return GetRuleContext<ParenthesizedExpressionListContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVERLAPS() { return GetToken(OracleAntlrParser.OVERLAPS, 0); }
		public OverlapsConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overlapsCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOverlapsCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOverlapsCondition(this);
		}
	}

	[RuleVersion(0)]
	public OverlapsConditionContext overlapsCondition() {
		OverlapsConditionContext _localctx = new OverlapsConditionContext(Context, State);
		EnterRule(_localctx, 326, RULE_overlapsCondition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2769;
			parenthesizedExpressionList();
			State = 2770;
			Match(OVERLAPS);
			State = 2771;
			parenthesizedExpressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComparisonListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonListContext[] comparisonList() {
			return GetRuleContexts<ComparisonListContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonListContext comparisonList(int i) {
			return GetRuleContext<ComparisonListContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ComparisonListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comparisonList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterComparisonList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitComparisonList(this);
		}
	}

	[RuleVersion(0)]
	public ComparisonListContext comparisonList() {
		ComparisonListContext _localctx = new ComparisonListContext(Context, State);
		EnterRule(_localctx, 328, RULE_comparisonList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2773;
			Match(LPAREN);
			State = 2783;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,146,Context) ) {
			case 1:
				{
				State = 2774;
				expressionList();
				}
				break;
			case 2:
				{
				State = 2775;
				comparisonList();
				State = 2780;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2776;
					Match(COMMA);
					State = 2777;
					comparisonList();
					}
					}
					State = 2782;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			State = 2785;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectionsComparisonContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CollectionsComparisonSubmultisetContext collectionsComparisonSubmultiset() {
			return GetRuleContext<CollectionsComparisonSubmultisetContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollectionsComparisonMemberOfContext collectionsComparisonMemberOf() {
			return GetRuleContext<CollectionsComparisonMemberOfContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollectionsComparisonIsASetContext collectionsComparisonIsASet() {
			return GetRuleContext<CollectionsComparisonIsASetContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollectionsComparisonIsEmptyContext collectionsComparisonIsEmpty() {
			return GetRuleContext<CollectionsComparisonIsEmptyContext>(0);
		}
		public CollectionsComparisonContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectionsComparison; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCollectionsComparison(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCollectionsComparison(this);
		}
	}

	[RuleVersion(0)]
	public CollectionsComparisonContext collectionsComparison() {
		CollectionsComparisonContext _localctx = new CollectionsComparisonContext(Context, State);
		EnterRule(_localctx, 330, RULE_collectionsComparison);
		try {
			State = 2791;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,147,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2787;
				collectionsComparisonSubmultiset();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2788;
				collectionsComparisonMemberOf();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2789;
				collectionsComparisonIsASet();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2790;
				collectionsComparisonIsEmpty();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectionsComparisonSubmultisetContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBMULTISET() { return GetToken(OracleAntlrParser.SUBMULTISET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public CollectionsComparisonSubmultisetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectionsComparisonSubmultiset; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCollectionsComparisonSubmultiset(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCollectionsComparisonSubmultiset(this);
		}
	}

	[RuleVersion(0)]
	public CollectionsComparisonSubmultisetContext collectionsComparisonSubmultiset() {
		CollectionsComparisonSubmultisetContext _localctx = new CollectionsComparisonSubmultisetContext(Context, State);
		EnterRule(_localctx, 332, RULE_collectionsComparisonSubmultiset);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2794;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 2793;
				Match(NOT);
				}
			}

			State = 2796;
			Match(SUBMULTISET);
			State = 2797;
			Match(OF);
			State = 2798;
			pureExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectionsComparisonMemberOfContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEMBER() { return GetToken(OracleAntlrParser.MEMBER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public CollectionsComparisonMemberOfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectionsComparisonMemberOf; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCollectionsComparisonMemberOf(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCollectionsComparisonMemberOf(this);
		}
	}

	[RuleVersion(0)]
	public CollectionsComparisonMemberOfContext collectionsComparisonMemberOf() {
		CollectionsComparisonMemberOfContext _localctx = new CollectionsComparisonMemberOfContext(Context, State);
		EnterRule(_localctx, 334, RULE_collectionsComparisonMemberOf);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2801;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 2800;
				Match(NOT);
				}
			}

			State = 2803;
			Match(MEMBER);
			State = 2804;
			Match(OF);
			State = 2805;
			pureExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectionsComparisonIsASetContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode A_() { return GetToken(OracleAntlrParser.A_, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public CollectionsComparisonIsASetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectionsComparisonIsASet; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCollectionsComparisonIsASet(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCollectionsComparisonIsASet(this);
		}
	}

	[RuleVersion(0)]
	public CollectionsComparisonIsASetContext collectionsComparisonIsASet() {
		CollectionsComparisonIsASetContext _localctx = new CollectionsComparisonIsASetContext(Context, State);
		EnterRule(_localctx, 336, RULE_collectionsComparisonIsASet);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2807;
			Match(IS);
			State = 2809;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 2808;
				Match(NOT);
				}
			}

			State = 2811;
			Match(A_);
			State = 2812;
			Match(SET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectionsComparisonIsEmptyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EMPTY_KEYWORD() { return GetToken(OracleAntlrParser.EMPTY_KEYWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public CollectionsComparisonIsEmptyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectionsComparisonIsEmpty; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCollectionsComparisonIsEmpty(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCollectionsComparisonIsEmpty(this);
		}
	}

	[RuleVersion(0)]
	public CollectionsComparisonIsEmptyContext collectionsComparisonIsEmpty() {
		CollectionsComparisonIsEmptyContext _localctx = new CollectionsComparisonIsEmptyContext(Context, State);
		EnterRule(_localctx, 338, RULE_collectionsComparisonIsEmpty);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2814;
			Match(IS);
			State = 2816;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 2815;
				Match(NOT);
				}
			}

			State = 2818;
			Match(EMPTY_KEYWORD);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LikeOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKE() { return GetToken(OracleAntlrParser.LIKE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKEC() { return GetToken(OracleAntlrParser.LIKEC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKE2() { return GetToken(OracleAntlrParser.LIKE2, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKE4() { return GetToken(OracleAntlrParser.LIKE4, 0); }
		public LikeOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_likeOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLikeOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLikeOperator(this);
		}
	}

	[RuleVersion(0)]
	public LikeOperatorContext likeOperator() {
		LikeOperatorContext _localctx = new LikeOperatorContext(Context, State);
		EnterRule(_localctx, 340, RULE_likeOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2820;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 263)) & ~0x3f) == 0 && ((1L << (_la - 263)) & ((1L << (LIKE - 263)) | (1L << (LIKE2 - 263)) | (1L << (LIKE4 - 263)) | (1L << (LIKEC - 263)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EscapeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ESCAPE() { return GetToken(OracleAntlrParser.ESCAPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public EscapeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_escapeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterEscapeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitEscapeClause(this);
		}
	}

	[RuleVersion(0)]
	public EscapeClauseContext escapeClause() {
		EscapeClauseContext _localctx = new EscapeClauseContext(Context, State);
		EnterRule(_localctx, 342, RULE_escapeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2822;
			Match(ESCAPE);
			State = 2823;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BetweenOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BETWEEN() { return GetToken(OracleAntlrParser.BETWEEN, 0); }
		public BetweenOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_betweenOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBetweenOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBetweenOperator(this);
		}
	}

	[RuleVersion(0)]
	public BetweenOperatorContext betweenOperator() {
		BetweenOperatorContext _localctx = new BetweenOperatorContext(Context, State);
		EnterRule(_localctx, 344, RULE_betweenOperator);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2825;
			Match(BETWEEN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BetweenAndOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(OracleAntlrParser.AND, 0); }
		public BetweenAndOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_betweenAndOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBetweenAndOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBetweenAndOperator(this);
		}
	}

	[RuleVersion(0)]
	public BetweenAndOperatorContext betweenAndOperator() {
		BetweenAndOperatorContext _localctx = new BetweenAndOperatorContext(Context, State);
		EnterRule(_localctx, 346, RULE_betweenAndOperator);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2827;
			Match(AND);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComparisonPairOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS_THAN() { return GetToken(OracleAntlrParser.LESS_THAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER_THAN() { return GetToken(OracleAntlrParser.GREATER_THAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BANG() { return GetToken(OracleAntlrParser.BANG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TILDE() { return GetToken(OracleAntlrParser.TILDE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CARET() { return GetToken(OracleAntlrParser.CARET, 0); }
		public ComparisonPairOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comparisonPairOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterComparisonPairOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitComparisonPairOperator(this);
		}
	}

	[RuleVersion(0)]
	public ComparisonPairOperatorContext comparisonPairOperator() {
		ComparisonPairOperatorContext _localctx = new ComparisonPairOperatorContext(Context, State);
		EnterRule(_localctx, 348, RULE_comparisonPairOperator);
		try {
			State = 2844;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,152,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2829;
				Match(LESS_THAN);
				State = 2830;
				Match(GREATER_THAN);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2831;
				Match(BANG);
				State = 2832;
				Match(EQUAL_SIGN);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2833;
				Match(TILDE);
				State = 2834;
				Match(EQUAL_SIGN);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2835;
				Match(GREATER_THAN);
				State = 2836;
				Match(EQUAL_SIGN);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2837;
				Match(LESS_THAN);
				State = 2838;
				Match(EQUAL_SIGN);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2839;
				Match(EQUAL_SIGN);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2840;
				Match(CARET);
				State = 2841;
				Match(EQUAL_SIGN);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2842;
				Match(GREATER_THAN);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2843;
				Match(LESS_THAN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlattenedQueryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public FlattenedQueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flattenedQuery; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFlattenedQuery(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFlattenedQuery(this);
		}
	}

	[RuleVersion(0)]
	public FlattenedQueryContext flattenedQuery() {
		FlattenedQueryContext _localctx = new FlattenedQueryContext(Context, State);
		EnterRule(_localctx, 350, RULE_flattenedQuery);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2846;
			Match(LPAREN);
			State = 2847;
			selectStatement();
			State = 2848;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsFlattenedQueryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public AsFlattenedQueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asFlattenedQuery; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAsFlattenedQuery(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAsFlattenedQuery(this);
		}
	}

	[RuleVersion(0)]
	public AsFlattenedQueryContext asFlattenedQuery() {
		AsFlattenedQueryContext _localctx = new AsFlattenedQueryContext(Context, State);
		EnterRule(_localctx, 352, RULE_asFlattenedQuery);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2850;
			Match(AS);
			State = 2851;
			Match(LPAREN);
			State = 2852;
			selectStatement();
			State = 2853;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlattenedQueryNestedTableContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THE() { return GetToken(OracleAntlrParser.THE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public FlattenedQueryNestedTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flattenedQueryNestedTable; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFlattenedQueryNestedTable(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFlattenedQueryNestedTable(this);
		}
	}

	[RuleVersion(0)]
	public FlattenedQueryNestedTableContext flattenedQueryNestedTable() {
		FlattenedQueryNestedTableContext _localctx = new FlattenedQueryNestedTableContext(Context, State);
		EnterRule(_localctx, 354, RULE_flattenedQueryNestedTable);
		try {
			State = 2868;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case THE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2855;
				Match(THE);
				State = 2856;
				Match(LPAREN);
				State = 2857;
				selectStatement();
				State = 2858;
				Match(RPAREN);
				}
				break;
			case TABLE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2860;
				Match(TABLE);
				State = 2861;
				Match(LPAREN);
				State = 2864;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,153,Context) ) {
				case 1:
					{
					State = 2862;
					selectStatement();
					}
					break;
				case 2:
					{
					State = 2863;
					fullExpression();
					}
					break;
				}
				State = 2866;
				Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionListItemContext[] fullExpressionListItem() {
			return GetRuleContexts<FullExpressionListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionListItemContext fullExpressionListItem(int i) {
			return GetRuleContext<FullExpressionListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public FullExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFullExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFullExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public FullExpressionListContext fullExpressionList() {
		FullExpressionListContext _localctx = new FullExpressionListContext(Context, State);
		EnterRule(_localctx, 356, RULE_fullExpressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2870;
			fullExpressionListItem();
			State = 2875;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2871;
				Match(COMMA);
				State = 2872;
				fullExpressionListItem();
				}
				}
				State = 2877;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullExpressionListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListItemContext expressionListItem() {
			return GetRuleContext<ExpressionListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionListContext fullExpressionList() {
			return GetRuleContext<FullExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public FullExpressionListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullExpressionListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFullExpressionListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFullExpressionListItem(this);
		}
	}

	[RuleVersion(0)]
	public FullExpressionListItemContext fullExpressionListItem() {
		FullExpressionListItemContext _localctx = new FullExpressionListItemContext(Context, State);
		EnterRule(_localctx, 358, RULE_fullExpressionListItem);
		try {
			State = 2883;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,156,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2878;
				expressionListItem();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2879;
				Match(LPAREN);
				State = 2880;
				fullExpressionList();
				State = 2881;
				Match(RPAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListItemContext[] expressionListItem() {
			return GetRuleContexts<ExpressionListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListItemContext expressionListItem(int i) {
			return GetRuleContext<ExpressionListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListContext expressionList() {
		ExpressionListContext _localctx = new ExpressionListContext(Context, State);
		EnterRule(_localctx, 360, RULE_expressionList);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2885;
			expressionListItem();
			State = 2890;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,157,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2886;
					Match(COMMA);
					State = 2887;
					expressionListItem();
					}
					} 
				}
				State = 2892;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,157,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiItemExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListItemContext[] expressionListItem() {
			return GetRuleContexts<ExpressionListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListItemContext expressionListItem(int i) {
			return GetRuleContext<ExpressionListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public MultiItemExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiItemExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMultiItemExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMultiItemExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public MultiItemExpressionListContext multiItemExpressionList() {
		MultiItemExpressionListContext _localctx = new MultiItemExpressionListContext(Context, State);
		EnterRule(_localctx, 362, RULE_multiItemExpressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2893;
			expressionListItem();
			State = 2896;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2894;
				Match(COMMA);
				State = 2895;
				expressionListItem();
				}
				}
				State = 2898;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COMMA );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefaultExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		public DefaultExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defaultExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDefaultExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDefaultExpression(this);
		}
	}

	[RuleVersion(0)]
	public DefaultExpressionContext defaultExpression() {
		DefaultExpressionContext _localctx = new DefaultExpressionContext(Context, State);
		EnterRule(_localctx, 364, RULE_defaultExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2900;
			Match(DEFAULT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultExpressionContext defaultExpression() {
			return GetRuleContext<DefaultExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterNameContext parameterName() {
			return GetRuleContext<ParameterNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AliasContext alias() {
			return GetRuleContext<AliasContext>(0);
		}
		public ExpressionListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExpressionListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExpressionListItem(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListItemContext expressionListItem() {
		ExpressionListItemContext _localctx = new ExpressionListItemContext(Context, State);
		EnterRule(_localctx, 366, RULE_expressionListItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2903;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,159,Context) ) {
			case 1:
				{
				State = 2902;
				parameterName();
				}
				break;
			}
			State = 2907;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CASE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case EXTRACTVALUE:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULL:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYS_CONNECT_BY_PATH:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLCAST:
			case XMLNAMESPACES:
			case XMLQUERY:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case INTEGER_LITERAL:
			case LPAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case QUESTION_MARK:
			case ASTERISK:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
			case QUOTE_CHARACTER_STRING_LITERAL:
				{
				State = 2905;
				fullExpression();
				}
				break;
			case DEFAULT:
				{
				State = 2906;
				defaultExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2910;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,161,Context) ) {
			case 1:
				{
				State = 2909;
				alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlaggExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLAGG() { return GetToken(OracleAntlrParser.XMLAGG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		public XmlaggExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlaggExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlaggExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlaggExpression(this);
		}
	}

	[RuleVersion(0)]
	public XmlaggExpressionContext xmlaggExpression() {
		XmlaggExpressionContext _localctx = new XmlaggExpressionContext(Context, State);
		EnterRule(_localctx, 368, RULE_xmlaggExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2912;
			Match(XMLAGG);
			State = 2913;
			Match(LPAREN);
			State = 2914;
			fullExpression();
			State = 2916;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 2915;
				orderByClause();
				}
			}

			State = 2918;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSOC_OPERATOR() { return GetToken(OracleAntlrParser.ASSOC_OPERATOR, 0); }
		public ParameterNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterParameterName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitParameterName(this);
		}
	}

	[RuleVersion(0)]
	public ParameterNameContext parameterName() {
		ParameterNameContext _localctx = new ParameterNameContext(Context, State);
		EnterRule(_localctx, 370, RULE_parameterName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2920;
			simpleIdentifier();
			State = 2921;
			Match(ASSOC_OPERATOR);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AliasContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		public AliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alias; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlias(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlias(this);
		}
	}

	[RuleVersion(0)]
	public AliasContext alias() {
		AliasContext _localctx = new AliasContext(Context, State);
		EnterRule(_localctx, 372, RULE_alias);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2924;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 2923;
				Match(AS);
				}
			}

			State = 2926;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public IdentifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierList(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierListContext identifierList() {
		IdentifierListContext _localctx = new IdentifierListContext(Context, State);
		EnterRule(_localctx, 374, RULE_identifierList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2928;
			identifier();
			State = 2933;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2929;
				Match(COMMA);
				State = 2930;
				identifier();
				}
				}
				State = 2935;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnListElementClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext[] columnListItem() {
			return GetRuleContexts<ColumnListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem(int i) {
			return GetRuleContext<ColumnListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ColumnListElementClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnListElementClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterColumnListElementClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitColumnListElementClause(this);
		}
	}

	[RuleVersion(0)]
	public ColumnListElementClauseContext columnListElementClause() {
		ColumnListElementClauseContext _localctx = new ColumnListElementClauseContext(Context, State);
		EnterRule(_localctx, 376, RULE_columnListElementClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2936;
			columnListItem();
			State = 2941;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2937;
				Match(COMMA);
				State = 2938;
				columnListItem();
				}
				}
				State = 2943;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public ColumnListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterColumnListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitColumnListItem(this);
		}
	}

	[RuleVersion(0)]
	public ColumnListItemContext columnListItem() {
		ColumnListItemContext _localctx = new ColumnListItemContext(Context, State);
		EnterRule(_localctx, 378, RULE_columnListItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2944;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComplexColumnListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MultipartPlainIdentifierContext multipartPlainIdentifier() {
			return GetRuleContext<MultipartPlainIdentifierContext>(0);
		}
		public ComplexColumnListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_complexColumnListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterComplexColumnListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitComplexColumnListItem(this);
		}
	}

	[RuleVersion(0)]
	public ComplexColumnListItemContext complexColumnListItem() {
		ComplexColumnListItemContext _localctx = new ComplexColumnListItemContext(Context, State);
		EnterRule(_localctx, 380, RULE_complexColumnListItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2946;
			multipartPlainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATE() { return GetToken(OracleAntlrParser.CREATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CreateTableStatementContext createTableStatement() {
			return GetRuleContext<CreateTableStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ViewStatementContext viewStatement() {
			return GetRuleContext<ViewStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewStatementContext materializedViewStatement() {
			return GetRuleContext<MaterializedViewStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateEditionableBatchWideStatementContext createEditionableBatchWideStatement() {
			return GetRuleContext<CreateEditionableBatchWideStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserStatementContext createUserStatement() {
			return GetRuleContext<CreateUserStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateIndexStatementContext createIndexStatement() {
			return GetRuleContext<CreateIndexStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateSequenceStatementContext createSequenceStatement() {
			return GetRuleContext<CreateSequenceStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateStatementReplaceClauseContext createStatementReplaceClause() {
			return GetRuleContext<CreateStatementReplaceClauseContext>(0);
		}
		public CreateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateStatementContext createStatement() {
		CreateStatementContext _localctx = new CreateStatementContext(Context, State);
		EnterRule(_localctx, 382, RULE_createStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2948;
			Match(CREATE);
			State = 2950;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 2949;
				createStatementReplaceClause();
				}
			}

			State = 2959;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,167,Context) ) {
			case 1:
				{
				State = 2952;
				createTableStatement();
				}
				break;
			case 2:
				{
				State = 2953;
				viewStatement();
				}
				break;
			case 3:
				{
				State = 2954;
				materializedViewStatement();
				}
				break;
			case 4:
				{
				State = 2955;
				createEditionableBatchWideStatement();
				}
				break;
			case 5:
				{
				State = 2956;
				createUserStatement();
				}
				break;
			case 6:
				{
				State = 2957;
				createIndexStatement();
				}
				break;
			case 7:
				{
				State = 2958;
				createSequenceStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateStatementReplaceClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(OracleAntlrParser.OR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPLACE() { return GetToken(OracleAntlrParser.REPLACE, 0); }
		public CreateStatementReplaceClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createStatementReplaceClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateStatementReplaceClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateStatementReplaceClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateStatementReplaceClauseContext createStatementReplaceClause() {
		CreateStatementReplaceClauseContext _localctx = new CreateStatementReplaceClauseContext(Context, State);
		EnterRule(_localctx, 384, RULE_createStatementReplaceClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2961;
			Match(OR);
			State = 2962;
			Match(REPLACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(OracleAntlrParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIED() { return GetToken(OracleAntlrParser.IDENTIFIED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserIdentificationClauseContext createUserIdentificationClause() {
			return GetRuleContext<CreateUserIdentificationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserOptionContext[] createUserOption() {
			return GetRuleContexts<CreateUserOptionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserOptionContext createUserOption(int i) {
			return GetRuleContext<CreateUserOptionContext>(i);
		}
		public CreateUserStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserStatementContext createUserStatement() {
		CreateUserStatementContext _localctx = new CreateUserStatementContext(Context, State);
		EnterRule(_localctx, 386, RULE_createUserStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2964;
			Match(USER);
			State = 2965;
			localSimpleIdentifierWithoutParentheses();
			State = 2966;
			Match(IDENTIFIED);
			State = 2967;
			createUserIdentificationClause();
			State = 2971;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ACCOUNT || ((((_la - 92)) & ~0x3f) == 0 && ((1L << (_la - 92)) & ((1L << (CONTAINER - 92)) | (1L << (DEFAULT - 92)) | (1L << (ENABLE - 92)))) != 0) || _la==LOCAL || ((((_la - 385)) & ~0x3f) == 0 && ((1L << (_la - 385)) & ((1L << (PASSWORD - 385)) | (1L << (PROFILE - 385)) | (1L << (QUOTA - 385)))) != 0) || _la==TEMPORARY) {
				{
				{
				State = 2968;
				createUserOption();
				}
				}
				State = 2973;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserIdentificationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserPasswordIdentificationClauseContext createUserPasswordIdentificationClause() {
			return GetRuleContext<CreateUserPasswordIdentificationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserExternalIdentificationClauseContext createUserExternalIdentificationClause() {
			return GetRuleContext<CreateUserExternalIdentificationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserGlobalIdentificationClauseContext createUserGlobalIdentificationClause() {
			return GetRuleContext<CreateUserGlobalIdentificationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserNoAuthenticationClauseContext createUserNoAuthenticationClause() {
			return GetRuleContext<CreateUserNoAuthenticationClauseContext>(0);
		}
		public CreateUserIdentificationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserIdentificationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserIdentificationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserIdentificationClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserIdentificationClauseContext createUserIdentificationClause() {
		CreateUserIdentificationClauseContext _localctx = new CreateUserIdentificationClauseContext(Context, State);
		EnterRule(_localctx, 388, RULE_createUserIdentificationClause);
		try {
			State = 2978;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2974;
				createUserPasswordIdentificationClause();
				}
				break;
			case EXTERNALLY:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2975;
				createUserExternalIdentificationClause();
				}
				break;
			case GLOBALLY:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2976;
				createUserGlobalIdentificationClause();
				}
				break;
			case NO:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2977;
				createUserNoAuthenticationClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserPasswordIdentificationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUES() { return GetToken(OracleAntlrParser.VALUES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharacterStringLiteralContext characterStringLiteral() {
			return GetRuleContext<CharacterStringLiteralContext>(0);
		}
		public CreateUserPasswordIdentificationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserPasswordIdentificationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserPasswordIdentificationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserPasswordIdentificationClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserPasswordIdentificationClauseContext createUserPasswordIdentificationClause() {
		CreateUserPasswordIdentificationClauseContext _localctx = new CreateUserPasswordIdentificationClauseContext(Context, State);
		EnterRule(_localctx, 390, RULE_createUserPasswordIdentificationClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2980;
			Match(BY);
			State = 2984;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 2981;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			case VALUES:
				{
				State = 2982;
				Match(VALUES);
				State = 2983;
				characterStringLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserExternalIdentificationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTERNALLY() { return GetToken(OracleAntlrParser.EXTERNALLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharacterStringLiteralContext characterStringLiteral() {
			return GetRuleContext<CharacterStringLiteralContext>(0);
		}
		public CreateUserExternalIdentificationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserExternalIdentificationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserExternalIdentificationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserExternalIdentificationClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserExternalIdentificationClauseContext createUserExternalIdentificationClause() {
		CreateUserExternalIdentificationClauseContext _localctx = new CreateUserExternalIdentificationClauseContext(Context, State);
		EnterRule(_localctx, 392, RULE_createUserExternalIdentificationClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2986;
			Match(EXTERNALLY);
			State = 2989;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 2987;
				Match(AS);
				State = 2988;
				characterStringLiteral();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserGlobalIdentificationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GLOBALLY() { return GetToken(OracleAntlrParser.GLOBALLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharacterStringLiteralContext characterStringLiteral() {
			return GetRuleContext<CharacterStringLiteralContext>(0);
		}
		public CreateUserGlobalIdentificationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserGlobalIdentificationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserGlobalIdentificationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserGlobalIdentificationClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserGlobalIdentificationClauseContext createUserGlobalIdentificationClause() {
		CreateUserGlobalIdentificationClauseContext _localctx = new CreateUserGlobalIdentificationClauseContext(Context, State);
		EnterRule(_localctx, 394, RULE_createUserGlobalIdentificationClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2991;
			Match(GLOBALLY);
			State = 2994;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 2992;
				Match(AS);
				State = 2993;
				characterStringLiteral();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserNoAuthenticationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NO() { return GetToken(OracleAntlrParser.NO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTHENTICATION() { return GetToken(OracleAntlrParser.AUTHENTICATION, 0); }
		public CreateUserNoAuthenticationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserNoAuthenticationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserNoAuthenticationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserNoAuthenticationClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserNoAuthenticationClauseContext createUserNoAuthenticationClause() {
		CreateUserNoAuthenticationClauseContext _localctx = new CreateUserNoAuthenticationClauseContext(Context, State);
		EnterRule(_localctx, 396, RULE_createUserNoAuthenticationClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2996;
			Match(NO);
			State = 2997;
			Match(AUTHENTICATION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DefaultCollationOptionContext defaultCollationOption() {
			return GetRuleContext<DefaultCollationOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserDefaultTablespaceOptionContext createUserDefaultTablespaceOption() {
			return GetRuleContext<CreateUserDefaultTablespaceOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserTemporaryTablespaceOptionContext createUserTemporaryTablespaceOption() {
			return GetRuleContext<CreateUserTemporaryTablespaceOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserTablespaceQuotaOptionContext createUserTablespaceQuotaOption() {
			return GetRuleContext<CreateUserTablespaceQuotaOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserProfileOptionContext createUserProfileOption() {
			return GetRuleContext<CreateUserProfileOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserPasswordExpireOptionContext createUserPasswordExpireOption() {
			return GetRuleContext<CreateUserPasswordExpireOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserAccountOptionContext createUserAccountOption() {
			return GetRuleContext<CreateUserAccountOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserEnableEditionsOptionContext createUserEnableEditionsOption() {
			return GetRuleContext<CreateUserEnableEditionsOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserContainerOptionContext createUserContainerOption() {
			return GetRuleContext<CreateUserContainerOptionContext>(0);
		}
		public CreateUserOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserOptionContext createUserOption() {
		CreateUserOptionContext _localctx = new CreateUserOptionContext(Context, State);
		EnterRule(_localctx, 398, RULE_createUserOption);
		try {
			State = 3008;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,173,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2999;
				defaultCollationOption();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3000;
				createUserDefaultTablespaceOption();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3001;
				createUserTemporaryTablespaceOption();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3002;
				createUserTablespaceQuotaOption();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3003;
				createUserProfileOption();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 3004;
				createUserPasswordExpireOption();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 3005;
				createUserAccountOption();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 3006;
				createUserEnableEditionsOption();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 3007;
				createUserContainerOption();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefaultCollationOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLLATION() { return GetToken(OracleAntlrParser.COLLATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public DefaultCollationOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defaultCollationOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDefaultCollationOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDefaultCollationOption(this);
		}
	}

	[RuleVersion(0)]
	public DefaultCollationOptionContext defaultCollationOption() {
		DefaultCollationOptionContext _localctx = new DefaultCollationOptionContext(Context, State);
		EnterRule(_localctx, 400, RULE_defaultCollationOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3010;
			Match(DEFAULT);
			State = 3011;
			Match(COLLATION);
			State = 3012;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserDefaultTablespaceOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLESPACE() { return GetToken(OracleAntlrParser.TABLESPACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public CreateUserDefaultTablespaceOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserDefaultTablespaceOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserDefaultTablespaceOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserDefaultTablespaceOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserDefaultTablespaceOptionContext createUserDefaultTablespaceOption() {
		CreateUserDefaultTablespaceOptionContext _localctx = new CreateUserDefaultTablespaceOptionContext(Context, State);
		EnterRule(_localctx, 402, RULE_createUserDefaultTablespaceOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3014;
			Match(DEFAULT);
			State = 3015;
			Match(TABLESPACE);
			State = 3016;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserTemporaryTablespaceOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEMPORARY() { return GetToken(OracleAntlrParser.TEMPORARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLESPACE() { return GetToken(OracleAntlrParser.TABLESPACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(OracleAntlrParser.LOCAL, 0); }
		public CreateUserTemporaryTablespaceOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserTemporaryTablespaceOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserTemporaryTablespaceOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserTemporaryTablespaceOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserTemporaryTablespaceOptionContext createUserTemporaryTablespaceOption() {
		CreateUserTemporaryTablespaceOptionContext _localctx = new CreateUserTemporaryTablespaceOptionContext(Context, State);
		EnterRule(_localctx, 404, RULE_createUserTemporaryTablespaceOption);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3019;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOCAL) {
				{
				State = 3018;
				Match(LOCAL);
				}
			}

			State = 3021;
			Match(TEMPORARY);
			State = 3022;
			Match(TABLESPACE);
			State = 3023;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserTablespaceQuotaOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTA() { return GetToken(OracleAntlrParser.QUOTA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNLIMITED() { return GetToken(OracleAntlrParser.UNLIMITED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ByteSizeLiteralContext byteSizeLiteral() {
			return GetRuleContext<ByteSizeLiteralContext>(0);
		}
		public CreateUserTablespaceQuotaOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserTablespaceQuotaOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserTablespaceQuotaOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserTablespaceQuotaOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserTablespaceQuotaOptionContext createUserTablespaceQuotaOption() {
		CreateUserTablespaceQuotaOptionContext _localctx = new CreateUserTablespaceQuotaOptionContext(Context, State);
		EnterRule(_localctx, 406, RULE_createUserTablespaceQuotaOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3025;
			Match(QUOTA);
			State = 3028;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNLIMITED:
				{
				State = 3026;
				Match(UNLIMITED);
				}
				break;
			case INTEGER_LITERAL:
			case BYTE_SIZE_LITERAL:
				{
				State = 3027;
				byteSizeLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3030;
			Match(ON);
			State = 3031;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserProfileOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROFILE() { return GetToken(OracleAntlrParser.PROFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public CreateUserProfileOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserProfileOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserProfileOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserProfileOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserProfileOptionContext createUserProfileOption() {
		CreateUserProfileOptionContext _localctx = new CreateUserProfileOptionContext(Context, State);
		EnterRule(_localctx, 408, RULE_createUserProfileOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3033;
			Match(PROFILE);
			State = 3034;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserPasswordExpireOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORD() { return GetToken(OracleAntlrParser.PASSWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXPIRE() { return GetToken(OracleAntlrParser.EXPIRE, 0); }
		public CreateUserPasswordExpireOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserPasswordExpireOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserPasswordExpireOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserPasswordExpireOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserPasswordExpireOptionContext createUserPasswordExpireOption() {
		CreateUserPasswordExpireOptionContext _localctx = new CreateUserPasswordExpireOptionContext(Context, State);
		EnterRule(_localctx, 410, RULE_createUserPasswordExpireOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3036;
			Match(PASSWORD);
			State = 3037;
			Match(EXPIRE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserAccountOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ACCOUNT() { return GetToken(OracleAntlrParser.ACCOUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCK() { return GetToken(OracleAntlrParser.LOCK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNLOCK() { return GetToken(OracleAntlrParser.UNLOCK, 0); }
		public CreateUserAccountOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserAccountOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserAccountOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserAccountOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserAccountOptionContext createUserAccountOption() {
		CreateUserAccountOptionContext _localctx = new CreateUserAccountOptionContext(Context, State);
		EnterRule(_localctx, 412, RULE_createUserAccountOption);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3039;
			Match(ACCOUNT);
			State = 3040;
			_la = TokenStream.LA(1);
			if ( !(_la==LOCK || _la==UNLOCK) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserEnableEditionsOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITIONS() { return GetToken(OracleAntlrParser.EDITIONS, 0); }
		public CreateUserEnableEditionsOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserEnableEditionsOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserEnableEditionsOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserEnableEditionsOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserEnableEditionsOptionContext createUserEnableEditionsOption() {
		CreateUserEnableEditionsOptionContext _localctx = new CreateUserEnableEditionsOptionContext(Context, State);
		EnterRule(_localctx, 414, RULE_createUserEnableEditionsOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3042;
			Match(ENABLE);
			State = 3043;
			Match(EDITIONS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserContainerOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTAINER() { return GetToken(OracleAntlrParser.CONTAINER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(OracleAntlrParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		public CreateUserContainerOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUserContainerOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateUserContainerOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateUserContainerOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserContainerOptionContext createUserContainerOption() {
		CreateUserContainerOptionContext _localctx = new CreateUserContainerOptionContext(Context, State);
		EnterRule(_localctx, 416, RULE_createUserContainerOption);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3045;
			Match(CONTAINER);
			State = 3046;
			Match(EQUAL_SIGN);
			State = 3047;
			_la = TokenStream.LA(1);
			if ( !(_la==ALL || _la==CURRENT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateIndexStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ClusterIndexClauseContext clusterIndexClause() {
			return GetRuleContext<ClusterIndexClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableIndexClauseContext tableIndexClause() {
			return GetRuleContext<TableIndexClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BitmapJoinIndexClauseContext bitmapJoinIndexClause() {
			return GetRuleContext<BitmapJoinIndexClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALIDATION() { return GetToken(OracleAntlrParser.INVALIDATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUE() { return GetToken(OracleAntlrParser.UNIQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BITMAP() { return GetToken(OracleAntlrParser.BITMAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USABLE() { return GetToken(OracleAntlrParser.USABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFERRED() { return GetToken(OracleAntlrParser.DEFERRED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMEDIATE() { return GetToken(OracleAntlrParser.IMMEDIATE, 0); }
		public CreateIndexStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createIndexStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateIndexStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateIndexStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateIndexStatementContext createIndexStatement() {
		CreateIndexStatementContext _localctx = new CreateIndexStatementContext(Context, State);
		EnterRule(_localctx, 418, RULE_createIndexStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3050;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BITMAP || _la==UNIQUE) {
				{
				State = 3049;
				_la = TokenStream.LA(1);
				if ( !(_la==BITMAP || _la==UNIQUE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3052;
			Match(INDEX);
			State = 3053;
			plainIdentifier();
			State = 3054;
			Match(ON);
			State = 3058;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,177,Context) ) {
			case 1:
				{
				State = 3055;
				clusterIndexClause();
				}
				break;
			case 2:
				{
				State = 3056;
				tableIndexClause();
				}
				break;
			case 3:
				{
				State = 3057;
				bitmapJoinIndexClause();
				}
				break;
			}
			State = 3061;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNUSABLE || _la==USABLE) {
				{
				State = 3060;
				_la = TokenStream.LA(1);
				if ( !(_la==UNUSABLE || _la==USABLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3065;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFERRED || _la==IMMEDIATE) {
				{
				State = 3063;
				_la = TokenStream.LA(1);
				if ( !(_la==DEFERRED || _la==IMMEDIATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3064;
				Match(INVALIDATION);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ClusterIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLUSTER() { return GetToken(OracleAntlrParser.CLUSTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexAttributeContext[] indexAttribute() {
			return GetRuleContexts<IndexAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexAttributeContext indexAttribute(int i) {
			return GetRuleContext<IndexAttributeContext>(i);
		}
		public ClusterIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_clusterIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterClusterIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitClusterIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public ClusterIndexClauseContext clusterIndexClause() {
		ClusterIndexClauseContext _localctx = new ClusterIndexClauseContext(Context, State);
		EnterRule(_localctx, 420, RULE_clusterIndexClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3067;
			Match(CLUSTER);
			State = 3068;
			plainIdentifier();
			State = 3072;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMPRESS || _la==COMPUTE || ((((_la - 181)) & ~0x3f) == 0 && ((1L << (_la - 181)) & ((1L << (FILESYSTEM_LIKE_LOGGING - 181)) | (1L << (INDEXING - 181)) | (1L << (INITRANS - 181)) | (1L << (INVISIBLE - 181)))) != 0) || ((((_la - 277)) & ~0x3f) == 0 && ((1L << (_la - 277)) & ((1L << (LOGGING - 277)) | (1L << (MAXTRANS - 277)) | (1L << (NOCOMPRESS - 277)) | (1L << (NOLOGGING - 277)) | (1L << (NOPARALLEL - 277)))) != 0) || ((((_la - 345)) & ~0x3f) == 0 && ((1L << (_la - 345)) & ((1L << (NOSORT - 345)) | (1L << (ONLINE - 345)) | (1L << (PARALLEL - 345)) | (1L << (PCTFREE - 345)) | (1L << (PCTUSED - 345)))) != 0) || ((((_la - 439)) & ~0x3f) == 0 && ((1L << (_la - 439)) & ((1L << (REVERSE - 439)) | (1L << (SORT - 439)) | (1L << (STORAGE - 439)))) != 0) || _la==TABLESPACE || _la==VISIBLE) {
				{
				{
				State = 3069;
				indexAttribute();
				}
				}
				State = 3074;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TableIndexExpressionContext[] tableIndexExpression() {
			return GetRuleContexts<TableIndexExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableIndexExpressionContext tableIndexExpression(int i) {
			return GetRuleContext<TableIndexExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleAliasIdentifierContext simpleAliasIdentifier() {
			return GetRuleContext<SimpleAliasIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexPropertiesContext indexProperties() {
			return GetRuleContext<IndexPropertiesContext>(0);
		}
		public TableIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTableIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTableIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public TableIndexClauseContext tableIndexClause() {
		TableIndexClauseContext _localctx = new TableIndexClauseContext(Context, State);
		EnterRule(_localctx, 422, RULE_tableIndexClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3075;
			plainIdentifier();
			State = 3077;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 3076;
				simpleAliasIdentifier();
				}
			}

			State = 3079;
			Match(LPAREN);
			State = 3080;
			tableIndexExpression();
			State = 3085;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3081;
				Match(COMMA);
				State = 3082;
				tableIndexExpression();
				}
				}
				State = 3087;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3088;
			Match(RPAREN);
			State = 3090;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMPRESS || _la==COMPUTE || ((((_la - 181)) & ~0x3f) == 0 && ((1L << (_la - 181)) & ((1L << (FILESYSTEM_LIKE_LOGGING - 181)) | (1L << (GLOBAL - 181)) | (1L << (INDEXING - 181)) | (1L << (INDEXTYPE - 181)) | (1L << (INITRANS - 181)) | (1L << (INVISIBLE - 181)))) != 0) || ((((_la - 271)) & ~0x3f) == 0 && ((1L << (_la - 271)) & ((1L << (LOCAL - 271)) | (1L << (LOGGING - 271)) | (1L << (MAXTRANS - 271)) | (1L << (NOCOMPRESS - 271)) | (1L << (NOLOGGING - 271)))) != 0) || ((((_la - 339)) & ~0x3f) == 0 && ((1L << (_la - 339)) & ((1L << (NOPARALLEL - 339)) | (1L << (NOSORT - 339)) | (1L << (ONLINE - 339)) | (1L << (PARALLEL - 339)) | (1L << (PCTFREE - 339)) | (1L << (PCTUSED - 339)))) != 0) || ((((_la - 439)) & ~0x3f) == 0 && ((1L << (_la - 439)) & ((1L << (REVERSE - 439)) | (1L << (SORT - 439)) | (1L << (STORAGE - 439)) | (1L << (STORE - 439)))) != 0) || _la==TABLESPACE || _la==VISIBLE || _la==LPAREN) {
				{
				State = 3089;
				indexProperties();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableIndexExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASC() { return GetToken(OracleAntlrParser.ASC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DESC() { return GetToken(OracleAntlrParser.DESC, 0); }
		public TableIndexExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableIndexExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTableIndexExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTableIndexExpression(this);
		}
	}

	[RuleVersion(0)]
	public TableIndexExpressionContext tableIndexExpression() {
		TableIndexExpressionContext _localctx = new TableIndexExpressionContext(Context, State);
		EnterRule(_localctx, 424, RULE_tableIndexExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3092;
			fullExpression();
			State = 3094;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASC || _la==DESC) {
				{
				State = 3093;
				_la = TokenStream.LA(1);
				if ( !(_la==ASC || _la==DESC) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BitmapJoinIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BitmapJoinIndexExpressionContext bitmapJoinIndexExpression() {
			return GetRuleContext<BitmapJoinIndexExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(OracleAntlrParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BitmapJoinIndexFromClauseItemContext[] bitmapJoinIndexFromClauseItem() {
			return GetRuleContexts<BitmapJoinIndexFromClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BitmapJoinIndexFromClauseItemContext bitmapJoinIndexFromClauseItem(int i) {
			return GetRuleContext<BitmapJoinIndexFromClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LocalPartitionedIndexContext localPartitionedIndex() {
			return GetRuleContext<LocalPartitionedIndexContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexAttributeContext[] indexAttribute() {
			return GetRuleContexts<IndexAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexAttributeContext indexAttribute(int i) {
			return GetRuleContext<IndexAttributeContext>(i);
		}
		public BitmapJoinIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitmapJoinIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBitmapJoinIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBitmapJoinIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public BitmapJoinIndexClauseContext bitmapJoinIndexClause() {
		BitmapJoinIndexClauseContext _localctx = new BitmapJoinIndexClauseContext(Context, State);
		EnterRule(_localctx, 426, RULE_bitmapJoinIndexClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3096;
			plainIdentifier();
			State = 3097;
			Match(LPAREN);
			State = 3098;
			bitmapJoinIndexExpression();
			State = 3099;
			Match(RPAREN);
			State = 3100;
			Match(FROM);
			State = 3101;
			bitmapJoinIndexFromClauseItem();
			State = 3106;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3102;
				Match(COMMA);
				State = 3103;
				bitmapJoinIndexFromClauseItem();
				}
				}
				State = 3108;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3109;
			whereClause();
			State = 3111;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOCAL || _la==STORE || _la==LPAREN) {
				{
				State = 3110;
				localPartitionedIndex();
				}
			}

			State = 3116;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMPRESS || _la==COMPUTE || ((((_la - 181)) & ~0x3f) == 0 && ((1L << (_la - 181)) & ((1L << (FILESYSTEM_LIKE_LOGGING - 181)) | (1L << (INDEXING - 181)) | (1L << (INITRANS - 181)) | (1L << (INVISIBLE - 181)))) != 0) || ((((_la - 277)) & ~0x3f) == 0 && ((1L << (_la - 277)) & ((1L << (LOGGING - 277)) | (1L << (MAXTRANS - 277)) | (1L << (NOCOMPRESS - 277)) | (1L << (NOLOGGING - 277)) | (1L << (NOPARALLEL - 277)))) != 0) || ((((_la - 345)) & ~0x3f) == 0 && ((1L << (_la - 345)) & ((1L << (NOSORT - 345)) | (1L << (ONLINE - 345)) | (1L << (PARALLEL - 345)) | (1L << (PCTFREE - 345)) | (1L << (PCTUSED - 345)))) != 0) || ((((_la - 439)) & ~0x3f) == 0 && ((1L << (_la - 439)) & ((1L << (REVERSE - 439)) | (1L << (SORT - 439)) | (1L << (STORAGE - 439)))) != 0) || _la==TABLESPACE || _la==VISIBLE) {
				{
				{
				State = 3113;
				indexAttribute();
				}
				}
				State = 3118;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BitmapJoinIndexExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASC() { return GetToken(OracleAntlrParser.ASC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DESC() { return GetToken(OracleAntlrParser.DESC, 0); }
		public BitmapJoinIndexExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitmapJoinIndexExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBitmapJoinIndexExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBitmapJoinIndexExpression(this);
		}
	}

	[RuleVersion(0)]
	public BitmapJoinIndexExpressionContext bitmapJoinIndexExpression() {
		BitmapJoinIndexExpressionContext _localctx = new BitmapJoinIndexExpressionContext(Context, State);
		EnterRule(_localctx, 428, RULE_bitmapJoinIndexExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3119;
			plainIdentifier();
			State = 3121;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASC || _la==DESC) {
				{
				State = 3120;
				_la = TokenStream.LA(1);
				if ( !(_la==ASC || _la==DESC) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BitmapJoinIndexFromClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleAliasIdentifierContext simpleAliasIdentifier() {
			return GetRuleContext<SimpleAliasIdentifierContext>(0);
		}
		public BitmapJoinIndexFromClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitmapJoinIndexFromClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBitmapJoinIndexFromClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBitmapJoinIndexFromClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public BitmapJoinIndexFromClauseItemContext bitmapJoinIndexFromClauseItem() {
		BitmapJoinIndexFromClauseItemContext _localctx = new BitmapJoinIndexFromClauseItemContext(Context, State);
		EnterRule(_localctx, 430, RULE_bitmapJoinIndexFromClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3123;
			plainIdentifier();
			State = 3125;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 3124;
				simpleAliasIdentifier();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GlobalPartitionedIndexContext[] globalPartitionedIndex() {
			return GetRuleContexts<GlobalPartitionedIndexContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public GlobalPartitionedIndexContext globalPartitionedIndex(int i) {
			return GetRuleContext<GlobalPartitionedIndexContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LocalPartitionedIndexContext[] localPartitionedIndex() {
			return GetRuleContexts<LocalPartitionedIndexContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LocalPartitionedIndexContext localPartitionedIndex(int i) {
			return GetRuleContext<LocalPartitionedIndexContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexAttributeContext[] indexAttribute() {
			return GetRuleContexts<IndexAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexAttributeContext indexAttribute(int i) {
			return GetRuleContext<IndexAttributeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexTypeClauseContext indexTypeClause() {
			return GetRuleContext<IndexTypeClauseContext>(0);
		}
		public IndexPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexProperties(this);
		}
	}

	[RuleVersion(0)]
	public IndexPropertiesContext indexProperties() {
		IndexPropertiesContext _localctx = new IndexPropertiesContext(Context, State);
		EnterRule(_localctx, 432, RULE_indexProperties);
		int _la;
		try {
			State = 3135;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPRESS:
			case COMPUTE:
			case FILESYSTEM_LIKE_LOGGING:
			case GLOBAL:
			case INDEXING:
			case INITRANS:
			case INVISIBLE:
			case LOCAL:
			case LOGGING:
			case MAXTRANS:
			case NOCOMPRESS:
			case NOLOGGING:
			case NOPARALLEL:
			case NOSORT:
			case ONLINE:
			case PARALLEL:
			case PCTFREE:
			case PCTUSED:
			case REVERSE:
			case SORT:
			case STORAGE:
			case STORE:
			case TABLESPACE:
			case VISIBLE:
			case LPAREN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3130;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					State = 3130;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case GLOBAL:
						{
						State = 3127;
						globalPartitionedIndex();
						}
						break;
					case LOCAL:
					case STORE:
					case LPAREN:
						{
						State = 3128;
						localPartitionedIndex();
						}
						break;
					case COMPRESS:
					case COMPUTE:
					case FILESYSTEM_LIKE_LOGGING:
					case INDEXING:
					case INITRANS:
					case INVISIBLE:
					case LOGGING:
					case MAXTRANS:
					case NOCOMPRESS:
					case NOLOGGING:
					case NOPARALLEL:
					case NOSORT:
					case ONLINE:
					case PARALLEL:
					case PCTFREE:
					case PCTUSED:
					case REVERSE:
					case SORT:
					case STORAGE:
					case TABLESPACE:
					case VISIBLE:
						{
						State = 3129;
						indexAttribute();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 3132;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==COMPRESS || _la==COMPUTE || ((((_la - 181)) & ~0x3f) == 0 && ((1L << (_la - 181)) & ((1L << (FILESYSTEM_LIKE_LOGGING - 181)) | (1L << (GLOBAL - 181)) | (1L << (INDEXING - 181)) | (1L << (INITRANS - 181)) | (1L << (INVISIBLE - 181)))) != 0) || ((((_la - 271)) & ~0x3f) == 0 && ((1L << (_la - 271)) & ((1L << (LOCAL - 271)) | (1L << (LOGGING - 271)) | (1L << (MAXTRANS - 271)) | (1L << (NOCOMPRESS - 271)) | (1L << (NOLOGGING - 271)))) != 0) || ((((_la - 339)) & ~0x3f) == 0 && ((1L << (_la - 339)) & ((1L << (NOPARALLEL - 339)) | (1L << (NOSORT - 339)) | (1L << (ONLINE - 339)) | (1L << (PARALLEL - 339)) | (1L << (PCTFREE - 339)) | (1L << (PCTUSED - 339)))) != 0) || ((((_la - 439)) & ~0x3f) == 0 && ((1L << (_la - 439)) & ((1L << (REVERSE - 439)) | (1L << (SORT - 439)) | (1L << (STORAGE - 439)) | (1L << (STORE - 439)))) != 0) || _la==TABLESPACE || _la==VISIBLE || _la==LPAREN );
				}
				break;
			case INDEXTYPE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3134;
				indexTypeClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GlobalPartitionedIndexContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GLOBAL() { return GetToken(OracleAntlrParser.GLOBAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartitioningDefinitionClauseContext partitioningDefinitionClause() {
			return GetRuleContext<PartitioningDefinitionClauseContext>(0);
		}
		public GlobalPartitionedIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_globalPartitionedIndex; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGlobalPartitionedIndex(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGlobalPartitionedIndex(this);
		}
	}

	[RuleVersion(0)]
	public GlobalPartitionedIndexContext globalPartitionedIndex() {
		GlobalPartitionedIndexContext _localctx = new GlobalPartitionedIndexContext(Context, State);
		EnterRule(_localctx, 434, RULE_globalPartitionedIndex);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3137;
			Match(GLOBAL);
			State = 3138;
			partitioningDefinitionClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LocalPartitionedIndexContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(OracleAntlrParser.LOCAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnSimplePartitionedTableClauseContext indexOnSimplePartitionedTableClause() {
			return GetRuleContext<IndexOnSimplePartitionedTableClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnHashPartitionedTableContext indexOnHashPartitionedTable() {
			return GetRuleContext<IndexOnHashPartitionedTableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnCompPartitionedTableContext indexOnCompPartitionedTable() {
			return GetRuleContext<IndexOnCompPartitionedTableContext>(0);
		}
		public LocalPartitionedIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_localPartitionedIndex; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLocalPartitionedIndex(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLocalPartitionedIndex(this);
		}
	}

	[RuleVersion(0)]
	public LocalPartitionedIndexContext localPartitionedIndex() {
		LocalPartitionedIndexContext _localctx = new LocalPartitionedIndexContext(Context, State);
		EnterRule(_localctx, 436, RULE_localPartitionedIndex);
		try {
			State = 3144;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,193,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3140;
				Match(LOCAL);
				State = 3141;
				indexOnSimplePartitionedTableClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3142;
				indexOnHashPartitionedTable();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3143;
				indexOnCompPartitionedTable();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOnSimplePartitionedTableClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnSimplePartitionedTableClauseItemContext[] indexOnSimplePartitionedTableClauseItem() {
			return GetRuleContexts<IndexOnSimplePartitionedTableClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnSimplePartitionedTableClauseItemContext indexOnSimplePartitionedTableClauseItem(int i) {
			return GetRuleContext<IndexOnSimplePartitionedTableClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public IndexOnSimplePartitionedTableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOnSimplePartitionedTableClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexOnSimplePartitionedTableClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexOnSimplePartitionedTableClause(this);
		}
	}

	[RuleVersion(0)]
	public IndexOnSimplePartitionedTableClauseContext indexOnSimplePartitionedTableClause() {
		IndexOnSimplePartitionedTableClauseContext _localctx = new IndexOnSimplePartitionedTableClauseContext(Context, State);
		EnterRule(_localctx, 438, RULE_indexOnSimplePartitionedTableClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3146;
			Match(LPAREN);
			State = 3147;
			indexOnSimplePartitionedTableClauseItem();
			State = 3152;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3148;
				Match(COMMA);
				State = 3149;
				indexOnSimplePartitionedTableClauseItem();
				}
				}
				State = 3154;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3155;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOnSimplePartitionedTableClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseContext[] segmentAttributesClause() {
			return GetRuleContexts<SegmentAttributesClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseContext segmentAttributesClause(int i) {
			return GetRuleContext<SegmentAttributesClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionClauseContext[] indexCompressionClause() {
			return GetRuleContexts<IndexCompressionClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionClauseContext indexCompressionClause(int i) {
			return GetRuleContext<IndexCompressionClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USABLE() { return GetToken(OracleAntlrParser.USABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		public IndexOnSimplePartitionedTableClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOnSimplePartitionedTableClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexOnSimplePartitionedTableClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexOnSimplePartitionedTableClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public IndexOnSimplePartitionedTableClauseItemContext indexOnSimplePartitionedTableClauseItem() {
		IndexOnSimplePartitionedTableClauseItemContext _localctx = new IndexOnSimplePartitionedTableClauseItemContext(Context, State);
		EnterRule(_localctx, 440, RULE_indexOnSimplePartitionedTableClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3157;
			Match(PARTITION);
			State = 3159;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,195,Context) ) {
			case 1:
				{
				State = 3158;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			}
			State = 3165;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 277)) & ~0x3f) == 0 && ((1L << (_la - 277)) & ((1L << (LOGGING - 277)) | (1L << (MAXTRANS - 277)) | (1L << (NOCOMPRESS - 277)) | (1L << (NOLOGGING - 277)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
				{
				State = 3163;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case FILESYSTEM_LIKE_LOGGING:
				case INITRANS:
				case LOGGING:
				case MAXTRANS:
				case NOLOGGING:
				case PCTFREE:
				case PCTUSED:
				case STORAGE:
				case TABLESPACE:
					{
					State = 3161;
					segmentAttributesClause();
					}
					break;
				case COMPRESS:
				case NOCOMPRESS:
					{
					State = 3162;
					indexCompressionClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 3167;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3169;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNUSABLE || _la==USABLE) {
				{
				State = 3168;
				_la = TokenStream.LA(1);
				if ( !(_la==UNUSABLE || _la==USABLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOnHashPartitionedTableContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsStoreInClauseContext partitionsStoreInClause() {
			return GetRuleContext<PartitionsStoreInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnHashPartitionedTableClauseItemContext[] indexOnHashPartitionedTableClauseItem() {
			return GetRuleContexts<IndexOnHashPartitionedTableClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnHashPartitionedTableClauseItemContext indexOnHashPartitionedTableClauseItem(int i) {
			return GetRuleContext<IndexOnHashPartitionedTableClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public IndexOnHashPartitionedTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOnHashPartitionedTable; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexOnHashPartitionedTable(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexOnHashPartitionedTable(this);
		}
	}

	[RuleVersion(0)]
	public IndexOnHashPartitionedTableContext indexOnHashPartitionedTable() {
		IndexOnHashPartitionedTableContext _localctx = new IndexOnHashPartitionedTableContext(Context, State);
		EnterRule(_localctx, 442, RULE_indexOnHashPartitionedTable);
		int _la;
		try {
			State = 3183;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STORE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3171;
				partitionsStoreInClause();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3172;
				Match(LPAREN);
				State = 3173;
				indexOnHashPartitionedTableClauseItem();
				State = 3178;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3174;
					Match(COMMA);
					State = 3175;
					indexOnHashPartitionedTableClauseItem();
					}
					}
					State = 3180;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3181;
				Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOnHashPartitionedTableClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USABLE() { return GetToken(OracleAntlrParser.USABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleTablespaceClauseContext simpleTablespaceClause() {
			return GetRuleContext<SimpleTablespaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionClauseContext indexCompressionClause() {
			return GetRuleContext<IndexCompressionClauseContext>(0);
		}
		public IndexOnHashPartitionedTableClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOnHashPartitionedTableClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexOnHashPartitionedTableClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexOnHashPartitionedTableClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public IndexOnHashPartitionedTableClauseItemContext indexOnHashPartitionedTableClauseItem() {
		IndexOnHashPartitionedTableClauseItemContext _localctx = new IndexOnHashPartitionedTableClauseItemContext(Context, State);
		EnterRule(_localctx, 444, RULE_indexOnHashPartitionedTableClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3185;
			Match(PARTITION);
			State = 3187;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,201,Context) ) {
			case 1:
				{
				State = 3186;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			}
			State = 3190;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLESPACE) {
				{
				State = 3189;
				simpleTablespaceClause();
				}
			}

			State = 3193;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMPRESS || _la==NOCOMPRESS) {
				{
				State = 3192;
				indexCompressionClause();
				}
			}

			State = 3195;
			_la = TokenStream.LA(1);
			if ( !(_la==UNUSABLE || _la==USABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOnCompPartitionedTableContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnCompPartitionedTableClauseItemContext[] indexOnCompPartitionedTableClauseItem() {
			return GetRuleContexts<IndexOnCompPartitionedTableClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnCompPartitionedTableClauseItemContext indexOnCompPartitionedTableClauseItem(int i) {
			return GetRuleContext<IndexOnCompPartitionedTableClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsStoreInClauseContext partitionsStoreInClause() {
			return GetRuleContext<PartitionsStoreInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public IndexOnCompPartitionedTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOnCompPartitionedTable; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexOnCompPartitionedTable(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexOnCompPartitionedTable(this);
		}
	}

	[RuleVersion(0)]
	public IndexOnCompPartitionedTableContext indexOnCompPartitionedTable() {
		IndexOnCompPartitionedTableContext _localctx = new IndexOnCompPartitionedTableContext(Context, State);
		EnterRule(_localctx, 446, RULE_indexOnCompPartitionedTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3198;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STORE) {
				{
				State = 3197;
				partitionsStoreInClause();
				}
			}

			State = 3200;
			Match(LPAREN);
			State = 3201;
			indexOnCompPartitionedTableClauseItem();
			State = 3206;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3202;
				Match(COMMA);
				State = 3203;
				indexOnCompPartitionedTableClauseItem();
				}
				}
				State = 3208;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3209;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOnCompPartitionedTableClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IndexOnSimplePartitionedTableClauseItemContext indexOnSimplePartitionedTableClauseItem() {
			return GetRuleContext<IndexOnSimplePartitionedTableClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexSubpartitionClauseContext indexSubpartitionClause() {
			return GetRuleContext<IndexSubpartitionClauseContext>(0);
		}
		public IndexOnCompPartitionedTableClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOnCompPartitionedTableClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexOnCompPartitionedTableClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexOnCompPartitionedTableClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public IndexOnCompPartitionedTableClauseItemContext indexOnCompPartitionedTableClauseItem() {
		IndexOnCompPartitionedTableClauseItemContext _localctx = new IndexOnCompPartitionedTableClauseItemContext(Context, State);
		EnterRule(_localctx, 448, RULE_indexOnCompPartitionedTableClauseItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3211;
			indexOnSimplePartitionedTableClauseItem();
			State = 3212;
			indexSubpartitionClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexSubpartitionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsStoreInClauseContext partitionsStoreInClause() {
			return GetRuleContext<PartitionsStoreInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexSubpartitionClauseItemContext[] indexSubpartitionClauseItem() {
			return GetRuleContexts<IndexSubpartitionClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexSubpartitionClauseItemContext indexSubpartitionClauseItem(int i) {
			return GetRuleContext<IndexSubpartitionClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public IndexSubpartitionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexSubpartitionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexSubpartitionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexSubpartitionClause(this);
		}
	}

	[RuleVersion(0)]
	public IndexSubpartitionClauseContext indexSubpartitionClause() {
		IndexSubpartitionClauseContext _localctx = new IndexSubpartitionClauseContext(Context, State);
		EnterRule(_localctx, 450, RULE_indexSubpartitionClause);
		int _la;
		try {
			State = 3226;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STORE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3214;
				partitionsStoreInClause();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3215;
				Match(LPAREN);
				State = 3216;
				indexSubpartitionClauseItem();
				State = 3221;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3217;
					Match(COMMA);
					State = 3218;
					indexSubpartitionClauseItem();
					}
					}
					State = 3223;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3224;
				Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexSubpartitionClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USABLE() { return GetToken(OracleAntlrParser.USABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleTablespaceClauseContext simpleTablespaceClause() {
			return GetRuleContext<SimpleTablespaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionClauseContext indexCompressionClause() {
			return GetRuleContext<IndexCompressionClauseContext>(0);
		}
		public IndexSubpartitionClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexSubpartitionClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexSubpartitionClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexSubpartitionClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public IndexSubpartitionClauseItemContext indexSubpartitionClauseItem() {
		IndexSubpartitionClauseItemContext _localctx = new IndexSubpartitionClauseItemContext(Context, State);
		EnterRule(_localctx, 452, RULE_indexSubpartitionClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3228;
			Match(SUBPARTITION);
			State = 3230;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,208,Context) ) {
			case 1:
				{
				State = 3229;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			}
			State = 3233;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLESPACE) {
				{
				State = 3232;
				simpleTablespaceClause();
				}
			}

			State = 3236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMPRESS || _la==NOCOMPRESS) {
				{
				State = 3235;
				indexCompressionClause();
				}
			}

			State = 3238;
			_la = TokenStream.LA(1);
			if ( !(_la==UNUSABLE || _la==USABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexAttributeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute() {
			return GetRuleContext<PhysicalAttributeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause() {
			return GetRuleContext<LoggingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLINE() { return GetToken(OracleAntlrParser.ONLINE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPUTE() { return GetToken(OracleAntlrParser.COMPUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATISTICS() { return GetToken(OracleAntlrParser.STATISTICS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause() {
			return GetRuleContext<TablespaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionClauseContext indexCompressionClause() {
			return GetRuleContext<IndexCompressionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SortNoSortClauseContext sortNoSortClause() {
			return GetRuleContext<SortNoSortClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REVERSE() { return GetToken(OracleAntlrParser.REVERSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VisibilityClauseContext visibilityClause() {
			return GetRuleContext<VisibilityClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartialIndexClauseContext partialIndexClause() {
			return GetRuleContext<PartialIndexClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		public IndexAttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexAttribute; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexAttribute(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexAttribute(this);
		}
	}

	[RuleVersion(0)]
	public IndexAttributeContext indexAttribute() {
		IndexAttributeContext _localctx = new IndexAttributeContext(Context, State);
		EnterRule(_localctx, 454, RULE_indexAttribute);
		try {
			State = 3252;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INITRANS:
			case MAXTRANS:
			case PCTFREE:
			case PCTUSED:
			case STORAGE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3240;
				physicalAttribute();
				}
				break;
			case FILESYSTEM_LIKE_LOGGING:
			case LOGGING:
			case NOLOGGING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3241;
				loggingClause();
				}
				break;
			case ONLINE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3242;
				Match(ONLINE);
				}
				break;
			case COMPUTE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3243;
				Match(COMPUTE);
				State = 3244;
				Match(STATISTICS);
				}
				break;
			case TABLESPACE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3245;
				tablespaceClause();
				}
				break;
			case COMPRESS:
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 6);
				{
				State = 3246;
				indexCompressionClause();
				}
				break;
			case NOSORT:
			case SORT:
				EnterOuterAlt(_localctx, 7);
				{
				State = 3247;
				sortNoSortClause();
				}
				break;
			case REVERSE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 3248;
				Match(REVERSE);
				}
				break;
			case INVISIBLE:
			case VISIBLE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 3249;
				visibilityClause();
				}
				break;
			case INDEXING:
				EnterOuterAlt(_localctx, 10);
				{
				State = 3250;
				partialIndexClause();
				}
				break;
			case NOPARALLEL:
			case PARALLEL:
				EnterOuterAlt(_localctx, 11);
				{
				State = 3251;
				parallelClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VisibilityClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VISIBLE() { return GetToken(OracleAntlrParser.VISIBLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVISIBLE() { return GetToken(OracleAntlrParser.INVISIBLE, 0); }
		public VisibilityClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_visibilityClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterVisibilityClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitVisibilityClause(this);
		}
	}

	[RuleVersion(0)]
	public VisibilityClauseContext visibilityClause() {
		VisibilityClauseContext _localctx = new VisibilityClauseContext(Context, State);
		EnterRule(_localctx, 456, RULE_visibilityClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3254;
			_la = TokenStream.LA(1);
			if ( !(_la==INVISIBLE || _la==VISIBLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartialIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEXING() { return GetToken(OracleAntlrParser.INDEXING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTIAL() { return GetToken(OracleAntlrParser.PARTIAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FULL() { return GetToken(OracleAntlrParser.FULL, 0); }
		public PartialIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partialIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPartialIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPartialIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public PartialIndexClauseContext partialIndexClause() {
		PartialIndexClauseContext _localctx = new PartialIndexClauseContext(Context, State);
		EnterRule(_localctx, 458, RULE_partialIndexClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3256;
			Match(INDEXING);
			State = 3257;
			_la = TokenStream.LA(1);
			if ( !(_la==FULL || _la==PARTIAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexTypeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEXTYPE() { return GetToken(OracleAntlrParser.INDEXTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LocalIndexClauseContext localIndexClause() {
			return GetRuleContext<LocalIndexClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnstructuredIndexParametersClauseContext unstructuredIndexParametersClause() {
			return GetRuleContext<UnstructuredIndexParametersClauseContext>(0);
		}
		public IndexTypeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexTypeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexTypeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexTypeClause(this);
		}
	}

	[RuleVersion(0)]
	public IndexTypeClauseContext indexTypeClause() {
		IndexTypeClauseContext _localctx = new IndexTypeClauseContext(Context, State);
		EnterRule(_localctx, 460, RULE_indexTypeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3259;
			Match(INDEXTYPE);
			State = 3260;
			Match(IS);
			State = 3261;
			plainIdentifier();
			State = 3263;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOCAL) {
				{
				State = 3262;
				localIndexClause();
				}
			}

			State = 3266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOPARALLEL || _la==PARALLEL) {
				{
				State = 3265;
				parallelClause();
				}
			}

			State = 3269;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARAMETERS) {
				{
				State = 3268;
				unstructuredIndexParametersClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LocalIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(OracleAntlrParser.LOCAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalIndexClauseItemContext[] localIndexClauseItem() {
			return GetRuleContexts<LocalIndexClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LocalIndexClauseItemContext localIndexClauseItem(int i) {
			return GetRuleContext<LocalIndexClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		public LocalIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_localIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLocalIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLocalIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public LocalIndexClauseContext localIndexClause() {
		LocalIndexClauseContext _localctx = new LocalIndexClauseContext(Context, State);
		EnterRule(_localctx, 462, RULE_localIndexClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3271;
			Match(LOCAL);
			State = 3272;
			Match(LPAREN);
			State = 3273;
			localIndexClauseItem();
			{
			State = 3274;
			Match(COMMA);
			State = 3275;
			localIndexClauseItem();
			}
			State = 3277;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LocalIndexClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnstructuredIndexParametersClauseContext unstructuredIndexParametersClause() {
			return GetRuleContext<UnstructuredIndexParametersClauseContext>(0);
		}
		public LocalIndexClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_localIndexClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLocalIndexClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLocalIndexClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public LocalIndexClauseItemContext localIndexClauseItem() {
		LocalIndexClauseItemContext _localctx = new LocalIndexClauseItemContext(Context, State);
		EnterRule(_localctx, 464, RULE_localIndexClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3279;
			Match(PARTITION);
			State = 3280;
			localSimpleIdentifierWithoutParentheses();
			State = 3282;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARAMETERS) {
				{
				State = 3281;
				unstructuredIndexParametersClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnstructuredIndexParametersClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARAMETERS() { return GetToken(OracleAntlrParser.PARAMETERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharacterStringLiteralContext characterStringLiteral() {
			return GetRuleContext<CharacterStringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public UnstructuredIndexParametersClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unstructuredIndexParametersClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUnstructuredIndexParametersClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUnstructuredIndexParametersClause(this);
		}
	}

	[RuleVersion(0)]
	public UnstructuredIndexParametersClauseContext unstructuredIndexParametersClause() {
		UnstructuredIndexParametersClauseContext _localctx = new UnstructuredIndexParametersClauseContext(Context, State);
		EnterRule(_localctx, 466, RULE_unstructuredIndexParametersClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3284;
			Match(PARAMETERS);
			State = 3285;
			Match(LPAREN);
			State = 3286;
			characterStringLiteral();
			State = 3287;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleTablespaceClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLESPACE() { return GetToken(OracleAntlrParser.TABLESPACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public SimpleTablespaceClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleTablespaceClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSimpleTablespaceClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSimpleTablespaceClause(this);
		}
	}

	[RuleVersion(0)]
	public SimpleTablespaceClauseContext simpleTablespaceClause() {
		SimpleTablespaceClauseContext _localctx = new SimpleTablespaceClauseContext(Context, State);
		EnterRule(_localctx, 468, RULE_simpleTablespaceClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3289;
			Match(TABLESPACE);
			State = 3290;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSequenceStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEQUENCE() { return GetToken(OracleAntlrParser.SEQUENCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateSequenceSharingClauseContext createSequenceSharingClause() {
			return GetRuleContext<CreateSequenceSharingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceOptionContext[] sequenceOption() {
			return GetRuleContexts<SequenceOptionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceOptionContext sequenceOption(int i) {
			return GetRuleContext<SequenceOptionContext>(i);
		}
		public CreateSequenceStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSequenceStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateSequenceStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateSequenceStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateSequenceStatementContext createSequenceStatement() {
		CreateSequenceStatementContext _localctx = new CreateSequenceStatementContext(Context, State);
		EnterRule(_localctx, 470, RULE_createSequenceStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3292;
			Match(SEQUENCE);
			State = 3293;
			plainIdentifier();
			State = 3295;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SHARING) {
				{
				State = 3294;
				createSequenceSharingClause();
				}
			}

			State = 3300;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==CACHE || _la==CYCLE || ((((_la - 202)) & ~0x3f) == 0 && ((1L << (_la - 202)) & ((1L << (GLOBAL - 202)) | (1L << (INCREMENT - 202)) | (1L << (KEEP - 202)))) != 0) || ((((_la - 292)) & ~0x3f) == 0 && ((1L << (_la - 292)) & ((1L << (MAXVALUE - 292)) | (1L << (MINVALUE - 292)) | (1L << (NOCACHE - 292)) | (1L << (NOCYCLE - 292)) | (1L << (NOKEEP - 292)) | (1L << (NOMAXVALUE - 292)) | (1L << (NOMINVALUE - 292)) | (1L << (NOORDER - 292)) | (1L << (NOSCALE - 292)) | (1L << (NOSHARD - 292)))) != 0) || _la==ORDER || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (SCALE - 455)) | (1L << (SESSION - 455)) | (1L << (START - 455)) | (1L << (SHARD - 455)))) != 0)) {
				{
				{
				State = 3297;
				sequenceOption();
				}
				}
				State = 3302;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSequenceSharingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARING() { return GetToken(OracleAntlrParser.SHARING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode METADATA() { return GetToken(OracleAntlrParser.METADATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATA() { return GetToken(OracleAntlrParser.DATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(OracleAntlrParser.NONE, 0); }
		public CreateSequenceSharingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSequenceSharingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateSequenceSharingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateSequenceSharingClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateSequenceSharingClauseContext createSequenceSharingClause() {
		CreateSequenceSharingClauseContext _localctx = new CreateSequenceSharingClauseContext(Context, State);
		EnterRule(_localctx, 472, RULE_createSequenceSharingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3303;
			Match(SHARING);
			State = 3304;
			Match(EQUAL_SIGN);
			State = 3305;
			_la = TokenStream.LA(1);
			if ( !(_la==DATA || _la==METADATA || _la==NONE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateEditionableBatchWideStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureStatementContext procedureStatement() {
			return GetRuleContext<ProcedureStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionStatementContext functionStatement() {
			return GetRuleContext<FunctionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TriggerStatementContext triggerStatement() {
			return GetRuleContext<TriggerStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PackageBodyStatementContext packageBodyStatement() {
			return GetRuleContext<PackageBodyStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PackageStatementContext packageStatement() {
			return GetRuleContext<PackageStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateTypeBodyStatementContext createTypeBodyStatement() {
			return GetRuleContext<CreateTypeBodyStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateTypeStatementContext createTypeStatement() {
			return GetRuleContext<CreateTypeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateSynonymStatementContext createSynonymStatement() {
			return GetRuleContext<CreateSynonymStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EditionOptionClauseContext editionOptionClause() {
			return GetRuleContext<EditionOptionClauseContext>(0);
		}
		public CreateEditionableBatchWideStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createEditionableBatchWideStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateEditionableBatchWideStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateEditionableBatchWideStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateEditionableBatchWideStatementContext createEditionableBatchWideStatement() {
		CreateEditionableBatchWideStatementContext _localctx = new CreateEditionableBatchWideStatementContext(Context, State);
		EnterRule(_localctx, 474, RULE_createEditionableBatchWideStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3308;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EDITIONABLE || _la==NONEDITIONABLE) {
				{
				State = 3307;
				editionOptionClause();
				}
			}

			State = 3318;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,219,Context) ) {
			case 1:
				{
				State = 3310;
				procedureStatement();
				}
				break;
			case 2:
				{
				State = 3311;
				functionStatement();
				}
				break;
			case 3:
				{
				State = 3312;
				triggerStatement();
				}
				break;
			case 4:
				{
				State = 3313;
				packageBodyStatement();
				}
				break;
			case 5:
				{
				State = 3314;
				packageStatement();
				}
				break;
			case 6:
				{
				State = 3315;
				createTypeBodyStatement();
				}
				break;
			case 7:
				{
				State = 3316;
				createTypeStatement();
				}
				break;
			case 8:
				{
				State = 3317;
				createSynonymStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EditionOptionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITIONABLE() { return GetToken(OracleAntlrParser.EDITIONABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONEDITIONABLE() { return GetToken(OracleAntlrParser.NONEDITIONABLE, 0); }
		public EditionOptionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_editionOptionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterEditionOptionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitEditionOptionClause(this);
		}
	}

	[RuleVersion(0)]
	public EditionOptionClauseContext editionOptionClause() {
		EditionOptionClauseContext _localctx = new EditionOptionClauseContext(Context, State);
		EnterRule(_localctx, 476, RULE_editionOptionClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3320;
			_la = TokenStream.LA(1);
			if ( !(_la==EDITIONABLE || _la==NONEDITIONABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PackageStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PACKAGE() { return GetToken(OracleAntlrParser.PACKAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRAPPED() { return GetToken(OracleAntlrParser.WRAPPED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
			return GetRuleContext<RoutineBodyAsIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PackageDeclarationBlockContext packageDeclarationBlock() {
			return GetRuleContext<PackageDeclarationBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndClauseContext endClause() {
			return GetRuleContext<EndClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InvokerRightsClauseContext invokerRightsClause() {
			return GetRuleContext<InvokerRightsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] FSLASH() { return GetTokens(OracleAntlrParser.FSLASH); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FSLASH(int i) {
			return GetToken(OracleAntlrParser.FSLASH, i);
		}
		public PackageStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_packageStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPackageStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPackageStatement(this);
		}
	}

	[RuleVersion(0)]
	public PackageStatementContext packageStatement() {
		PackageStatementContext _localctx = new PackageStatementContext(Context, State);
		EnterRule(_localctx, 478, RULE_packageStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3322;
			Match(PACKAGE);
			State = 3323;
			plainIdentifier();
			State = 3338;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WRAPPED:
				{
				State = 3324;
				Match(WRAPPED);
				State = 3328;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,220,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 3325;
						_la = TokenStream.LA(1);
						if ( _la <= 0 || (_la==FSLASH) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						} 
					}
					State = 3330;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,220,Context);
				}
				}
				break;
			case AS:
			case AUTHID:
			case IS:
				{
				State = 3332;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AUTHID) {
					{
					State = 3331;
					invokerRightsClause();
					}
				}

				State = 3334;
				routineBodyAsIsClause();
				State = 3335;
				packageDeclarationBlock();
				State = 3336;
				endClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PackageBodyStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PACKAGE() { return GetToken(OracleAntlrParser.PACKAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BODY() { return GetToken(OracleAntlrParser.BODY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRAPPED() { return GetToken(OracleAntlrParser.WRAPPED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
			return GetRuleContext<RoutineBodyAsIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PackageDeclarationBlockContext packageDeclarationBlock() {
			return GetRuleContext<PackageDeclarationBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockBodyContext blockBody() {
			return GetRuleContext<BlockBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndClauseContext endClause() {
			return GetRuleContext<EndClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] FSLASH() { return GetTokens(OracleAntlrParser.FSLASH); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FSLASH(int i) {
			return GetToken(OracleAntlrParser.FSLASH, i);
		}
		public PackageBodyStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_packageBodyStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPackageBodyStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPackageBodyStatement(this);
		}
	}

	[RuleVersion(0)]
	public PackageBodyStatementContext packageBodyStatement() {
		PackageBodyStatementContext _localctx = new PackageBodyStatementContext(Context, State);
		EnterRule(_localctx, 480, RULE_packageBodyStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3340;
			Match(PACKAGE);
			State = 3341;
			Match(BODY);
			State = 3342;
			plainIdentifier();
			State = 3356;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WRAPPED:
				{
				State = 3343;
				Match(WRAPPED);
				State = 3347;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,223,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 3344;
						_la = TokenStream.LA(1);
						if ( _la <= 0 || (_la==FSLASH) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						} 
					}
					State = 3349;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,223,Context);
				}
				}
				break;
			case AS:
			case IS:
				{
				State = 3350;
				routineBodyAsIsClause();
				State = 3351;
				packageDeclarationBlock();
				State = 3354;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case BEGIN:
					{
					State = 3352;
					blockBody();
					}
					break;
				case END:
					{
					State = 3353;
					endClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PackageDeclarationBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockContext declarationBlock() {
			return GetRuleContext<DeclarationBlockContext>(0);
		}
		public PackageDeclarationBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_packageDeclarationBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPackageDeclarationBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPackageDeclarationBlock(this);
		}
	}

	[RuleVersion(0)]
	public PackageDeclarationBlockContext packageDeclarationBlock() {
		PackageDeclarationBlockContext _localctx = new PackageDeclarationBlockContext(Context, State);
		EnterRule(_localctx, 482, RULE_packageDeclarationBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3359;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECLARE - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DIRECTIVE_IF - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 3358;
				declarationBlock();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureSignatureContext procedureSignature() {
			return GetRuleContext<ProcedureSignatureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureImplementationContext procedureImplementation() {
			return GetRuleContext<ProcedureImplementationContext>(0);
		}
		public ProcedureStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterProcedureStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitProcedureStatement(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureStatementContext procedureStatement() {
		ProcedureStatementContext _localctx = new ProcedureStatementContext(Context, State);
		EnterRule(_localctx, 484, RULE_procedureStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3361;
			procedureSignature();
			State = 3363;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS || _la==IS || _la==LANGUAGE) {
				{
				State = 3362;
				procedureImplementation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureSignatureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureHeaderContext procedureHeader() {
			return GetRuleContext<ProcedureHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InvokerRightsClauseContext invokerRightsClause() {
			return GetRuleContext<InvokerRightsClauseContext>(0);
		}
		public ProcedureSignatureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureSignature; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterProcedureSignature(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitProcedureSignature(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureSignatureContext procedureSignature() {
		ProcedureSignatureContext _localctx = new ProcedureSignatureContext(Context, State);
		EnterRule(_localctx, 486, RULE_procedureSignature);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3365;
			procedureHeader();
			State = 3367;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,228,Context) ) {
			case 1:
				{
				State = 3366;
				invokerRightsClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureImplementationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureCallSpecClauseContext procedureCallSpecClause() {
			return GetRuleContext<ProcedureCallSpecClauseContext>(0);
		}
		public ProcedureImplementationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureImplementation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterProcedureImplementation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitProcedureImplementation(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureImplementationContext procedureImplementation() {
		ProcedureImplementationContext _localctx = new ProcedureImplementationContext(Context, State);
		EnterRule(_localctx, 488, RULE_procedureImplementation);
		try {
			State = 3371;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
			case IS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3369;
				routineBody();
				}
				break;
			case LANGUAGE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3370;
				procedureCallSpecClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROCEDURE() { return GetToken(OracleAntlrParser.PROCEDURE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public ProcedureHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterProcedureHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitProcedureHeader(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureHeaderContext procedureHeader() {
		ProcedureHeaderContext _localctx = new ProcedureHeaderContext(Context, State);
		EnterRule(_localctx, 490, RULE_procedureHeader);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3373;
			Match(PROCEDURE);
			State = 3374;
			plainIdentifier();
			State = 3376;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,230,Context) ) {
			case 1:
				{
				State = 3375;
				argumentList();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RoutineBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
			return GetRuleContext<RoutineBodyAsIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockBodyContext blockBody() {
			return GetRuleContext<BlockBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockContext declarationBlock() {
			return GetRuleContext<DeclarationBlockContext>(0);
		}
		public RoutineBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routineBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRoutineBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRoutineBody(this);
		}
	}

	[RuleVersion(0)]
	public RoutineBodyContext routineBody() {
		RoutineBodyContext _localctx = new RoutineBodyContext(Context, State);
		EnterRule(_localctx, 492, RULE_routineBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3378;
			routineBodyAsIsClause();
			State = 3380;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECLARE - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DIRECTIVE_IF - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 3379;
				declarationBlock();
				}
			}

			State = 3382;
			blockBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RoutineBodyAsIsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		public RoutineBodyAsIsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routineBodyAsIsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRoutineBodyAsIsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRoutineBodyAsIsClause(this);
		}
	}

	[RuleVersion(0)]
	public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
		RoutineBodyAsIsClauseContext _localctx = new RoutineBodyAsIsClauseContext(Context, State);
		EnterRule(_localctx, 494, RULE_routineBodyAsIsClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3384;
			_la = TokenStream.LA(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InvokerRightsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTHID() { return GetToken(OracleAntlrParser.AUTHID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFINER() { return GetToken(OracleAntlrParser.DEFINER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT_USER() { return GetToken(OracleAntlrParser.CURRENT_USER, 0); }
		public InvokerRightsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_invokerRightsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterInvokerRightsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitInvokerRightsClause(this);
		}
	}

	[RuleVersion(0)]
	public InvokerRightsClauseContext invokerRightsClause() {
		InvokerRightsClauseContext _localctx = new InvokerRightsClauseContext(Context, State);
		EnterRule(_localctx, 496, RULE_invokerRightsClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3386;
			Match(AUTHID);
			State = 3387;
			_la = TokenStream.LA(1);
			if ( !(_la==CURRENT_USER || _la==DEFINER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureCallSpecClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LANGUAGE() { return GetToken(OracleAntlrParser.LANGUAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JavaDeclarationClauseContext javaDeclarationClause() {
			return GetRuleContext<JavaDeclarationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CDeclarationClauseContext cDeclarationClause() {
			return GetRuleContext<CDeclarationClauseContext>(0);
		}
		public ProcedureCallSpecClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureCallSpecClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterProcedureCallSpecClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitProcedureCallSpecClause(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureCallSpecClauseContext procedureCallSpecClause() {
		ProcedureCallSpecClauseContext _localctx = new ProcedureCallSpecClauseContext(Context, State);
		EnterRule(_localctx, 498, RULE_procedureCallSpecClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3389;
			Match(LANGUAGE);
			State = 3392;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case JAVA:
				{
				State = 3390;
				javaDeclarationClause();
				}
				break;
			case C_:
				{
				State = 3391;
				cDeclarationClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JavaDeclarationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JAVA() { return GetToken(OracleAntlrParser.JAVA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAME() { return GetToken(OracleAntlrParser.NAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public JavaDeclarationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_javaDeclarationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJavaDeclarationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJavaDeclarationClause(this);
		}
	}

	[RuleVersion(0)]
	public JavaDeclarationClauseContext javaDeclarationClause() {
		JavaDeclarationClauseContext _localctx = new JavaDeclarationClauseContext(Context, State);
		EnterRule(_localctx, 500, RULE_javaDeclarationClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3394;
			Match(JAVA);
			State = 3395;
			Match(NAME);
			State = 3396;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CDeclarationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode C_() { return GetToken(OracleAntlrParser.C_, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CDeclarationLibraryClauseContext cDeclarationLibraryClause() {
			return GetRuleContext<CDeclarationLibraryClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CDeclarationNameClauseContext cDeclarationNameClause() {
			return GetRuleContext<CDeclarationNameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CDeclarationAgentClauseContext cDeclarationAgentClause() {
			return GetRuleContext<CDeclarationAgentClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CDeclarationContextClauseContext cDeclarationContextClause() {
			return GetRuleContext<CDeclarationContextClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CDeclarationParametersClauseContext cDeclarationParametersClause() {
			return GetRuleContext<CDeclarationParametersClauseContext>(0);
		}
		public CDeclarationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cDeclarationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCDeclarationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCDeclarationClause(this);
		}
	}

	[RuleVersion(0)]
	public CDeclarationClauseContext cDeclarationClause() {
		CDeclarationClauseContext _localctx = new CDeclarationClauseContext(Context, State);
		EnterRule(_localctx, 502, RULE_cDeclarationClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3398;
			Match(C_);
			State = 3400;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NAME) {
				{
				State = 3399;
				cDeclarationNameClause();
				}
			}

			State = 3402;
			cDeclarationLibraryClause();
			State = 3404;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AGENT) {
				{
				State = 3403;
				cDeclarationAgentClause();
				}
			}

			State = 3407;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 3406;
				cDeclarationContextClause();
				}
			}

			State = 3410;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARAMETERS) {
				{
				State = 3409;
				cDeclarationParametersClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CDeclarationNameClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAME() { return GetToken(OracleAntlrParser.NAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public CDeclarationNameClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cDeclarationNameClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCDeclarationNameClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCDeclarationNameClause(this);
		}
	}

	[RuleVersion(0)]
	public CDeclarationNameClauseContext cDeclarationNameClause() {
		CDeclarationNameClauseContext _localctx = new CDeclarationNameClauseContext(Context, State);
		EnterRule(_localctx, 504, RULE_cDeclarationNameClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3412;
			Match(NAME);
			State = 3413;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CDeclarationLibraryClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIBRARY() { return GetToken(OracleAntlrParser.LIBRARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public CDeclarationLibraryClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cDeclarationLibraryClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCDeclarationLibraryClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCDeclarationLibraryClause(this);
		}
	}

	[RuleVersion(0)]
	public CDeclarationLibraryClauseContext cDeclarationLibraryClause() {
		CDeclarationLibraryClauseContext _localctx = new CDeclarationLibraryClauseContext(Context, State);
		EnterRule(_localctx, 506, RULE_cDeclarationLibraryClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3415;
			Match(LIBRARY);
			State = 3416;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CDeclarationAgentClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AGENT() { return GetToken(OracleAntlrParser.AGENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public CDeclarationAgentClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cDeclarationAgentClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCDeclarationAgentClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCDeclarationAgentClause(this);
		}
	}

	[RuleVersion(0)]
	public CDeclarationAgentClauseContext cDeclarationAgentClause() {
		CDeclarationAgentClauseContext _localctx = new CDeclarationAgentClauseContext(Context, State);
		EnterRule(_localctx, 508, RULE_cDeclarationAgentClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3418;
			Match(AGENT);
			State = 3419;
			Match(IN);
			State = 3420;
			argumentList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CDeclarationContextClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTEXT() { return GetToken(OracleAntlrParser.CONTEXT, 0); }
		public CDeclarationContextClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cDeclarationContextClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCDeclarationContextClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCDeclarationContextClause(this);
		}
	}

	[RuleVersion(0)]
	public CDeclarationContextClauseContext cDeclarationContextClause() {
		CDeclarationContextClauseContext _localctx = new CDeclarationContextClauseContext(Context, State);
		EnterRule(_localctx, 510, RULE_cDeclarationContextClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3422;
			Match(WITH);
			State = 3423;
			Match(CONTEXT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CDeclarationParametersClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARAMETERS() { return GetToken(OracleAntlrParser.PARAMETERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public CDeclarationParametersClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cDeclarationParametersClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCDeclarationParametersClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCDeclarationParametersClause(this);
		}
	}

	[RuleVersion(0)]
	public CDeclarationParametersClauseContext cDeclarationParametersClause() {
		CDeclarationParametersClauseContext _localctx = new CDeclarationParametersClauseContext(Context, State);
		EnterRule(_localctx, 512, RULE_cDeclarationParametersClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3425;
			Match(PARAMETERS);
			State = 3426;
			Match(LPAREN);
			State = 3427;
			identifierList();
			State = 3428;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentContext[] argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterArgumentList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitArgumentList(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentListContext argumentList() {
		ArgumentListContext _localctx = new ArgumentListContext(Context, State);
		EnterRule(_localctx, 514, RULE_argumentList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3430;
			Match(LPAREN);
			State = 3439;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 3431;
				argument();
				State = 3436;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3432;
					Match(COMMA);
					State = 3433;
					argument();
					}
					}
					State = 3438;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 3441;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentModeClauseContext argumentModeClause() {
			return GetRuleContext<ArgumentModeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentNoCopyClauseContext argumentNoCopyClause() {
			return GetRuleContext<ArgumentNoCopyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentDefaultValueContext argumentDefaultValue() {
			return GetRuleContext<ArgumentDefaultValueContext>(0);
		}
		public ArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterArgument(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitArgument(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentContext argument() {
		ArgumentContext _localctx = new ArgumentContext(Context, State);
		EnterRule(_localctx, 516, RULE_argument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3443;
			simpleIdentifier();
			State = 3445;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,239,Context) ) {
			case 1:
				{
				State = 3444;
				argumentModeClause();
				}
				break;
			}
			State = 3448;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,240,Context) ) {
			case 1:
				{
				State = 3447;
				argumentNoCopyClause();
				}
				break;
			}
			State = 3450;
			typeReference();
			State = 3452;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT || _la==ASSIGN_OPERATOR) {
				{
				State = 3451;
				argumentDefaultValue();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentNoCopyClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCOPY() { return GetToken(OracleAntlrParser.NOCOPY, 0); }
		public ArgumentNoCopyClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentNoCopyClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterArgumentNoCopyClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitArgumentNoCopyClause(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentNoCopyClauseContext argumentNoCopyClause() {
		ArgumentNoCopyClauseContext _localctx = new ArgumentNoCopyClauseContext(Context, State);
		EnterRule(_localctx, 518, RULE_argumentNoCopyClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3454;
			Match(NOCOPY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentModeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OUT() { return GetToken(OracleAntlrParser.OUT, 0); }
		public ArgumentModeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentModeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterArgumentModeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitArgumentModeClause(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentModeClauseContext argumentModeClause() {
		ArgumentModeClauseContext _localctx = new ArgumentModeClauseContext(Context, State);
		EnterRule(_localctx, 520, RULE_argumentModeClause);
		try {
			State = 3460;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,242,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3456;
				Match(IN);
				State = 3457;
				Match(OUT);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3458;
				Match(IN);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3459;
				Match(OUT);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentDefaultValueContext : ParserRuleContext {
		public IToken assignType;
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN_OPERATOR() { return GetToken(OracleAntlrParser.ASSIGN_OPERATOR, 0); }
		public ArgumentDefaultValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentDefaultValue; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterArgumentDefaultValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitArgumentDefaultValue(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentDefaultValueContext argumentDefaultValue() {
		ArgumentDefaultValueContext _localctx = new ArgumentDefaultValueContext(Context, State);
		EnterRule(_localctx, 522, RULE_argumentDefaultValue);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3462;
			_localctx.assignType = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DEFAULT || _la==ASSIGN_OPERATOR) ) {
				_localctx.assignType = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3463;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionSignatureContext functionSignature() {
			return GetRuleContext<FunctionSignatureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionImplementationContext functionImplementation() {
			return GetRuleContext<FunctionImplementationContext>(0);
		}
		public FunctionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFunctionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFunctionStatement(this);
		}
	}

	[RuleVersion(0)]
	public FunctionStatementContext functionStatement() {
		FunctionStatementContext _localctx = new FunctionStatementContext(Context, State);
		EnterRule(_localctx, 524, RULE_functionStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3465;
			functionSignature();
			State = 3467;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS || _la==IS || _la==LANGUAGE) {
				{
				State = 3466;
				functionImplementation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionSignatureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionReturnClauseContext functionReturnClause() {
			return GetRuleContext<FunctionReturnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InvokerRightsClauseContext[] invokerRightsClause() {
			return GetRuleContexts<InvokerRightsClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public InvokerRightsClauseContext invokerRightsClause(int i) {
			return GetRuleContext<InvokerRightsClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionDeterministicClauseContext[] functionDeterministicClause() {
			return GetRuleContexts<FunctionDeterministicClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionDeterministicClauseContext functionDeterministicClause(int i) {
			return GetRuleContext<FunctionDeterministicClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionParallelEnableClauseContext[] functionParallelEnableClause() {
			return GetRuleContexts<FunctionParallelEnableClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionParallelEnableClauseContext functionParallelEnableClause(int i) {
			return GetRuleContext<FunctionParallelEnableClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionAggregateClauseContext[] functionAggregateClause() {
			return GetRuleContexts<FunctionAggregateClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionAggregateClauseContext functionAggregateClause(int i) {
			return GetRuleContext<FunctionAggregateClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionPipelinedClauseContext[] functionPipelinedClause() {
			return GetRuleContexts<FunctionPipelinedClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionPipelinedClauseContext functionPipelinedClause(int i) {
			return GetRuleContext<FunctionPipelinedClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ResultCacheClauseContext[] resultCacheClause() {
			return GetRuleContexts<ResultCacheClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ResultCacheClauseContext resultCacheClause(int i) {
			return GetRuleContext<ResultCacheClauseContext>(i);
		}
		public FunctionSignatureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionSignature; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFunctionSignature(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFunctionSignature(this);
		}
	}

	[RuleVersion(0)]
	public FunctionSignatureContext functionSignature() {
		FunctionSignatureContext _localctx = new FunctionSignatureContext(Context, State);
		EnterRule(_localctx, 526, RULE_functionSignature);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3469;
			functionHeader();
			State = 3470;
			functionReturnClause();
			State = 3479;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,245,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 3477;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case AUTHID:
						{
						State = 3471;
						invokerRightsClause();
						}
						break;
					case DETERMINISTIC:
						{
						State = 3472;
						functionDeterministicClause();
						}
						break;
					case PARALLEL_ENABLE:
						{
						State = 3473;
						functionParallelEnableClause();
						}
						break;
					case AGGREGATE:
						{
						State = 3474;
						functionAggregateClause();
						}
						break;
					case PIPELINED:
						{
						State = 3475;
						functionPipelinedClause();
						}
						break;
					case RESULT_CACHE:
						{
						State = 3476;
						resultCacheClause();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 3481;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,245,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionImplementationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureCallSpecClauseContext procedureCallSpecClause() {
			return GetRuleContext<ProcedureCallSpecClauseContext>(0);
		}
		public FunctionImplementationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionImplementation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFunctionImplementation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFunctionImplementation(this);
		}
	}

	[RuleVersion(0)]
	public FunctionImplementationContext functionImplementation() {
		FunctionImplementationContext _localctx = new FunctionImplementationContext(Context, State);
		EnterRule(_localctx, 528, RULE_functionImplementation);
		try {
			State = 3484;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
			case IS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3482;
				routineBody();
				}
				break;
			case LANGUAGE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3483;
				procedureCallSpecClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTION() { return GetToken(OracleAntlrParser.FUNCTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierAsStringLiteralContext plainIdentifierAsStringLiteral() {
			return GetRuleContext<PlainIdentifierAsStringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public FunctionHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}
	}

	[RuleVersion(0)]
	public FunctionHeaderContext functionHeader() {
		FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State);
		EnterRule(_localctx, 530, RULE_functionHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3486;
			Match(FUNCTION);
			State = 3489;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 3487;
				plainIdentifier();
				}
				break;
			case CHARACTER_STRING_LITERAL:
				{
				State = 3488;
				plainIdentifierAsStringLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3492;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 3491;
				argumentList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionReturnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(OracleAntlrParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public FunctionReturnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionReturnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFunctionReturnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFunctionReturnClause(this);
		}
	}

	[RuleVersion(0)]
	public FunctionReturnClauseContext functionReturnClause() {
		FunctionReturnClauseContext _localctx = new FunctionReturnClauseContext(Context, State);
		EnterRule(_localctx, 532, RULE_functionReturnClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3494;
			Match(RETURN);
			State = 3495;
			typeReference();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionDeterministicClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DETERMINISTIC() { return GetToken(OracleAntlrParser.DETERMINISTIC, 0); }
		public FunctionDeterministicClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionDeterministicClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFunctionDeterministicClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFunctionDeterministicClause(this);
		}
	}

	[RuleVersion(0)]
	public FunctionDeterministicClauseContext functionDeterministicClause() {
		FunctionDeterministicClauseContext _localctx = new FunctionDeterministicClauseContext(Context, State);
		EnterRule(_localctx, 534, RULE_functionDeterministicClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3497;
			Match(DETERMINISTIC);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionParallelEnableClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARALLEL_ENABLE() { return GetToken(OracleAntlrParser.PARALLEL_ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParallelOnPartitionOptionContext parallelOnPartitionOption() {
			return GetRuleContext<ParallelOnPartitionOptionContext>(0);
		}
		public FunctionParallelEnableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionParallelEnableClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFunctionParallelEnableClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFunctionParallelEnableClause(this);
		}
	}

	[RuleVersion(0)]
	public FunctionParallelEnableClauseContext functionParallelEnableClause() {
		FunctionParallelEnableClauseContext _localctx = new FunctionParallelEnableClauseContext(Context, State);
		EnterRule(_localctx, 536, RULE_functionParallelEnableClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3499;
			Match(PARALLEL_ENABLE);
			State = 3501;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,249,Context) ) {
			case 1:
				{
				State = 3500;
				parallelOnPartitionOption();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParallelOnPartitionOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelOnPartitionByContext parallelOnPartitionBy() {
			return GetRuleContext<ParallelOnPartitionByContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public ParallelOnPartitionOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallelOnPartitionOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterParallelOnPartitionOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitParallelOnPartitionOption(this);
		}
	}

	[RuleVersion(0)]
	public ParallelOnPartitionOptionContext parallelOnPartitionOption() {
		ParallelOnPartitionOptionContext _localctx = new ParallelOnPartitionOptionContext(Context, State);
		EnterRule(_localctx, 538, RULE_parallelOnPartitionOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3503;
			Match(LPAREN);
			State = 3504;
			Match(PARTITION);
			State = 3505;
			simpleIdentifier();
			State = 3506;
			parallelOnPartitionBy();
			State = 3507;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParallelOnPartitionByContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY() { return GetToken(OracleAntlrParser.ANY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(OracleAntlrParser.VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemInParenContext columnListItemInParen() {
			return GetRuleContext<ColumnListItemInParenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(OracleAntlrParser.HASH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(OracleAntlrParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParallelOnPartitionStreamingClauseContext parallelOnPartitionStreamingClause() {
			return GetRuleContext<ParallelOnPartitionStreamingClauseContext>(0);
		}
		public ParallelOnPartitionByContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallelOnPartitionBy; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterParallelOnPartitionBy(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitParallelOnPartitionBy(this);
		}
	}

	[RuleVersion(0)]
	public ParallelOnPartitionByContext parallelOnPartitionBy() {
		ParallelOnPartitionByContext _localctx = new ParallelOnPartitionByContext(Context, State);
		EnterRule(_localctx, 540, RULE_parallelOnPartitionBy);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3509;
			Match(BY);
			State = 3518;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ANY:
				{
				State = 3510;
				Match(ANY);
				}
				break;
			case VALUE:
				{
				State = 3511;
				Match(VALUE);
				State = 3512;
				columnListItemInParen();
				}
				break;
			case HASH:
			case RANGE:
				{
				State = 3513;
				_la = TokenStream.LA(1);
				if ( !(_la==HASH || _la==RANGE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3514;
				columnListInParenElementClause();
				State = 3516;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CLUSTER || _la==ORDER) {
					{
					State = 3515;
					parallelOnPartitionStreamingClause();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnListItemInParenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem() {
			return GetRuleContext<ColumnListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public ColumnListItemInParenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnListItemInParen; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterColumnListItemInParen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitColumnListItemInParen(this);
		}
	}

	[RuleVersion(0)]
	public ColumnListItemInParenContext columnListItemInParen() {
		ColumnListItemInParenContext _localctx = new ColumnListItemInParenContext(Context, State);
		EnterRule(_localctx, 542, RULE_columnListItemInParen);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3520;
			Match(LPAREN);
			State = 3521;
			columnListItem();
			State = 3522;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParallelOnPartitionStreamingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelOnPartitionStreamingClauseByContext parallelOnPartitionStreamingClauseBy() {
			return GetRuleContext<ParallelOnPartitionStreamingClauseByContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDER() { return GetToken(OracleAntlrParser.ORDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLUSTER() { return GetToken(OracleAntlrParser.CLUSTER, 0); }
		public ParallelOnPartitionStreamingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallelOnPartitionStreamingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterParallelOnPartitionStreamingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitParallelOnPartitionStreamingClause(this);
		}
	}

	[RuleVersion(0)]
	public ParallelOnPartitionStreamingClauseContext parallelOnPartitionStreamingClause() {
		ParallelOnPartitionStreamingClauseContext _localctx = new ParallelOnPartitionStreamingClauseContext(Context, State);
		EnterRule(_localctx, 544, RULE_parallelOnPartitionStreamingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3524;
			_la = TokenStream.LA(1);
			if ( !(_la==CLUSTER || _la==ORDER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3525;
			pureExpression();
			State = 3526;
			parallelOnPartitionStreamingClauseBy();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParallelOnPartitionStreamingClauseByContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public ParallelOnPartitionStreamingClauseByContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallelOnPartitionStreamingClauseBy; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterParallelOnPartitionStreamingClauseBy(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitParallelOnPartitionStreamingClauseBy(this);
		}
	}

	[RuleVersion(0)]
	public ParallelOnPartitionStreamingClauseByContext parallelOnPartitionStreamingClauseBy() {
		ParallelOnPartitionStreamingClauseByContext _localctx = new ParallelOnPartitionStreamingClauseByContext(Context, State);
		EnterRule(_localctx, 546, RULE_parallelOnPartitionStreamingClauseBy);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3528;
			Match(BY);
			State = 3529;
			columnListInParenElementClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResultCacheClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RESULT_CACHE() { return GetToken(OracleAntlrParser.RESULT_CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ResultCacheReliesOnClauseContext resultCacheReliesOnClause() {
			return GetRuleContext<ResultCacheReliesOnClauseContext>(0);
		}
		public ResultCacheClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_resultCacheClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterResultCacheClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitResultCacheClause(this);
		}
	}

	[RuleVersion(0)]
	public ResultCacheClauseContext resultCacheClause() {
		ResultCacheClauseContext _localctx = new ResultCacheClauseContext(Context, State);
		EnterRule(_localctx, 548, RULE_resultCacheClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3531;
			Match(RESULT_CACHE);
			State = 3533;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,252,Context) ) {
			case 1:
				{
				State = 3532;
				resultCacheReliesOnClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResultCacheReliesOnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELIES_ON() { return GetToken(OracleAntlrParser.RELIES_ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ResultCacheReliesOnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_resultCacheReliesOnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterResultCacheReliesOnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitResultCacheReliesOnClause(this);
		}
	}

	[RuleVersion(0)]
	public ResultCacheReliesOnClauseContext resultCacheReliesOnClause() {
		ResultCacheReliesOnClauseContext _localctx = new ResultCacheReliesOnClauseContext(Context, State);
		EnterRule(_localctx, 550, RULE_resultCacheReliesOnClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3535;
			Match(RELIES_ON);
			State = 3536;
			Match(LPAREN);
			State = 3537;
			identifier();
			State = 3542;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3538;
				Match(COMMA);
				State = 3539;
				identifier();
				}
				}
				State = 3544;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3545;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionAggregateClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AGGREGATE() { return GetToken(OracleAntlrParser.AGGREGATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public FunctionAggregateClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionAggregateClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFunctionAggregateClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFunctionAggregateClause(this);
		}
	}

	[RuleVersion(0)]
	public FunctionAggregateClauseContext functionAggregateClause() {
		FunctionAggregateClauseContext _localctx = new FunctionAggregateClauseContext(Context, State);
		EnterRule(_localctx, 552, RULE_functionAggregateClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3547;
			Match(AGGREGATE);
			State = 3548;
			Match(USING);
			State = 3549;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionPipelinedClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PIPELINED() { return GetToken(OracleAntlrParser.PIPELINED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POLYMORPHIC() { return GetToken(OracleAntlrParser.POLYMORPHIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		public FunctionPipelinedClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionPipelinedClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFunctionPipelinedClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFunctionPipelinedClause(this);
		}
	}

	[RuleVersion(0)]
	public FunctionPipelinedClauseContext functionPipelinedClause() {
		FunctionPipelinedClauseContext _localctx = new FunctionPipelinedClauseContext(Context, State);
		EnterRule(_localctx, 554, RULE_functionPipelinedClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3551;
			Match(PIPELINED);
			State = 3554;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,254,Context) ) {
			case 1:
				{
				State = 3552;
				_la = TokenStream.LA(1);
				if ( !(_la==ROW || _la==TABLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3553;
				Match(POLYMORPHIC);
				}
				break;
			}
			State = 3558;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,255,Context) ) {
			case 1:
				{
				State = 3556;
				Match(USING);
				State = 3557;
				identifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTableStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TableHeaderContext tableHeader() {
			return GetRuleContext<TableHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateObjectTableStatementContext createObjectTableStatement() {
			return GetRuleContext<CreateObjectTableStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateRelationTableStatementContext createRelationTableStatement() {
			return GetRuleContext<CreateRelationTableStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateXMLTypeTableStatementContext createXMLTypeTableStatement() {
			return GetRuleContext<CreateXMLTypeTableStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MemOptimizeClauseContext memOptimizeClause() {
			return GetRuleContext<MemOptimizeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParentClauseContext parentClause() {
			return GetRuleContext<ParentClauseContext>(0);
		}
		public CreateTableStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTableStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateTableStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateTableStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateTableStatementContext createTableStatement() {
		CreateTableStatementContext _localctx = new CreateTableStatementContext(Context, State);
		EnterRule(_localctx, 556, RULE_createTableStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3560;
			tableHeader();
			State = 3564;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,256,Context) ) {
			case 1:
				{
				State = 3561;
				createObjectTableStatement();
				}
				break;
			case 2:
				{
				State = 3562;
				createRelationTableStatement();
				}
				break;
			case 3:
				{
				State = 3563;
				createXMLTypeTableStatement();
				}
				break;
			}
			State = 3567;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MEMOPTIMIZE) {
				{
				State = 3566;
				memOptimizeClause();
				}
			}

			State = 3570;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARENT) {
				{
				State = 3569;
				parentClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GLOBAL() { return GetToken(OracleAntlrParser.GLOBAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEMPORARY() { return GetToken(OracleAntlrParser.TEMPORARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIVATE() { return GetToken(OracleAntlrParser.PRIVATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARDED() { return GetToken(OracleAntlrParser.SHARDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DUPLICATED() { return GetToken(OracleAntlrParser.DUPLICATED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARING() { return GetToken(OracleAntlrParser.SHARING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode METADATA() { return GetToken(OracleAntlrParser.METADATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATA() { return GetToken(OracleAntlrParser.DATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTENDED() { return GetToken(OracleAntlrParser.EXTENDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(OracleAntlrParser.NONE, 0); }
		public TableHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTableHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTableHeader(this);
		}
	}

	[RuleVersion(0)]
	public TableHeaderContext tableHeader() {
		TableHeaderContext _localctx = new TableHeaderContext(Context, State);
		EnterRule(_localctx, 558, RULE_tableHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3578;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case GLOBAL:
				{
				State = 3572;
				Match(GLOBAL);
				State = 3573;
				Match(TEMPORARY);
				}
				break;
			case PRIVATE:
				{
				State = 3574;
				Match(PRIVATE);
				State = 3575;
				Match(TEMPORARY);
				}
				break;
			case SHARDED:
				{
				State = 3576;
				Match(SHARDED);
				}
				break;
			case DUPLICATED:
				{
				State = 3577;
				Match(DUPLICATED);
				}
				break;
			case TABLE:
				break;
			default:
				break;
			}
			State = 3580;
			Match(TABLE);
			State = 3581;
			plainIdentifier();
			State = 3591;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SHARING) {
				{
				State = 3582;
				Match(SHARING);
				State = 3583;
				Match(EQUAL_SIGN);
				State = 3589;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case METADATA:
					{
					State = 3584;
					Match(METADATA);
					}
					break;
				case DATA:
					{
					State = 3585;
					Match(DATA);
					}
					break;
				case EXTENDED:
					{
					State = 3586;
					Match(EXTENDED);
					State = 3587;
					Match(DATA);
					}
					break;
				case NONE:
					{
					State = 3588;
					Match(NONE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateObjectTableStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTableOfClauseContext objectTableOfClause() {
			return GetRuleContext<ObjectTableOfClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablePropertiesClauseContext tablePropertiesClause() {
			return GetRuleContext<TablePropertiesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectPropertiesListClauseContext objectPropertiesListClause() {
			return GetRuleContext<ObjectPropertiesListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnCommitClauseContext onCommitClause() {
			return GetRuleContext<OnCommitClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectIdentifierIsClauseContext objectIdentifierIsClause() {
			return GetRuleContext<ObjectIdentifierIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OidIndexClauseContext oidIndexClause() {
			return GetRuleContext<OidIndexClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalPropertiesClauseContext physicalPropertiesClause() {
			return GetRuleContext<PhysicalPropertiesClauseContext>(0);
		}
		public CreateObjectTableStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createObjectTableStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateObjectTableStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateObjectTableStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateObjectTableStatementContext createObjectTableStatement() {
		CreateObjectTableStatementContext _localctx = new CreateObjectTableStatementContext(Context, State);
		EnterRule(_localctx, 560, RULE_createObjectTableStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3593;
			objectTableOfClause();
			State = 3595;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 3594;
				objectPropertiesListClause();
				}
			}

			State = 3598;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 3597;
				onCommitClause();
				}
			}

			State = 3601;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OBJECT) {
				{
				State = 3600;
				objectIdentifierIsClause();
				}
			}

			State = 3604;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OIDINDEX) {
				{
				State = 3603;
				oidIndexClause();
				}
			}

			State = 3607;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,266,Context) ) {
			case 1:
				{
				State = 3606;
				physicalPropertiesClause();
				}
				break;
			}
			State = 3609;
			tablePropertiesClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MemOptimizeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] MEMOPTIMIZE() { return GetTokens(OracleAntlrParser.MEMOPTIMIZE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEMOPTIMIZE(int i) {
			return GetToken(OracleAntlrParser.MEMOPTIMIZE, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] FOR() { return GetTokens(OracleAntlrParser.FOR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR(int i) {
			return GetToken(OracleAntlrParser.FOR, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] READ() { return GetTokens(OracleAntlrParser.READ); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READ(int i) {
			return GetToken(OracleAntlrParser.READ, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] WRITE() { return GetTokens(OracleAntlrParser.WRITE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRITE(int i) {
			return GetToken(OracleAntlrParser.WRITE, i);
		}
		public MemOptimizeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_memOptimizeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMemOptimizeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMemOptimizeClause(this);
		}
	}

	[RuleVersion(0)]
	public MemOptimizeClauseContext memOptimizeClause() {
		MemOptimizeClauseContext _localctx = new MemOptimizeClauseContext(Context, State);
		EnterRule(_localctx, 562, RULE_memOptimizeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3614;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 3611;
				Match(MEMOPTIMIZE);
				State = 3612;
				Match(FOR);
				State = 3613;
				_la = TokenStream.LA(1);
				if ( !(_la==READ || _la==WRITE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				}
				State = 3616;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==MEMOPTIMIZE );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParentClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARENT() { return GetToken(OracleAntlrParser.PARENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public ParentClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parentClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterParentClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitParentClause(this);
		}
	}

	[RuleVersion(0)]
	public ParentClauseContext parentClause() {
		ParentClauseContext _localctx = new ParentClauseContext(Context, State);
		EnterRule(_localctx, 564, RULE_parentClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3618;
			Match(PARENT);
			State = 3619;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OidIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OIDINDEX() { return GetToken(OracleAntlrParser.OIDINDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OidIndexClauseListContext oidIndexClauseList() {
			return GetRuleContext<OidIndexClauseListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public OidIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_oidIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOidIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOidIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public OidIndexClauseContext oidIndexClause() {
		OidIndexClauseContext _localctx = new OidIndexClauseContext(Context, State);
		EnterRule(_localctx, 566, RULE_oidIndexClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3621;
			Match(OIDINDEX);
			State = 3623;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 3622;
				identifier();
				}
			}

			State = 3625;
			oidIndexClauseList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OidIndexClauseListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext[] physicalAttribute() {
			return GetRuleContexts<PhysicalAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute(int i) {
			return GetRuleContext<PhysicalAttributeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext[] tablespaceClause() {
			return GetRuleContexts<TablespaceClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause(int i) {
			return GetRuleContext<TablespaceClauseContext>(i);
		}
		public OidIndexClauseListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_oidIndexClauseList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOidIndexClauseList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOidIndexClauseList(this);
		}
	}

	[RuleVersion(0)]
	public OidIndexClauseListContext oidIndexClauseList() {
		OidIndexClauseListContext _localctx = new OidIndexClauseListContext(Context, State);
		EnterRule(_localctx, 568, RULE_oidIndexClauseList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3627;
			Match(LPAREN);
			State = 3630;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 3630;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case INITRANS:
				case MAXTRANS:
				case PCTFREE:
				case PCTUSED:
				case STORAGE:
					{
					State = 3628;
					physicalAttribute();
					}
					break;
				case TABLESPACE:
					{
					State = 3629;
					tablespaceClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 3632;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==INITRANS || _la==MAXTRANS || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE );
			State = 3634;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectIdentifierIsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(OracleAntlrParser.OBJECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(OracleAntlrParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SYSTEM() { return GetToken(OracleAntlrParser.SYSTEM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GENERATED() { return GetToken(OracleAntlrParser.GENERATED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIMARY() { return GetToken(OracleAntlrParser.PRIMARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(OracleAntlrParser.KEY, 0); }
		public ObjectIdentifierIsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectIdentifierIsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectIdentifierIsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectIdentifierIsClause(this);
		}
	}

	[RuleVersion(0)]
	public ObjectIdentifierIsClauseContext objectIdentifierIsClause() {
		ObjectIdentifierIsClauseContext _localctx = new ObjectIdentifierIsClauseContext(Context, State);
		EnterRule(_localctx, 570, RULE_objectIdentifierIsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3636;
			Match(OBJECT);
			State = 3637;
			Match(IDENTIFIER);
			State = 3638;
			Match(IS);
			State = 3643;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SYSTEM:
				{
				State = 3639;
				Match(SYSTEM);
				State = 3640;
				Match(GENERATED);
				}
				break;
			case PRIMARY:
				{
				State = 3641;
				Match(PRIMARY);
				State = 3642;
				Match(KEY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTableOfClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotSubstitutableClauseContext notSubstitutableClause() {
			return GetRuleContext<NotSubstitutableClauseContext>(0);
		}
		public ObjectTableOfClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTableOfClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectTableOfClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectTableOfClause(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTableOfClauseContext objectTableOfClause() {
		ObjectTableOfClauseContext _localctx = new ObjectTableOfClauseContext(Context, State);
		EnterRule(_localctx, 572, RULE_objectTableOfClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3645;
			Match(OF);
			State = 3646;
			plainIdentifier();
			State = 3648;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT || _la==SUBSTITUTABLE) {
				{
				State = 3647;
				notSubstitutableClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateRelationTableStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TablePropertiesClauseContext tablePropertiesClause() {
			return GetRuleContext<TablePropertiesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelationPropertiesListClauseContext relationPropertiesListClause() {
			return GetRuleContext<RelationPropertiesListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultCollationOptionContext defaultCollationOption() {
			return GetRuleContext<DefaultCollationOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnCommitClauseContext onCommitClause() {
			return GetRuleContext<OnCommitClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalPropertiesClauseContext physicalPropertiesClause() {
			return GetRuleContext<PhysicalPropertiesClauseContext>(0);
		}
		public CreateRelationTableStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createRelationTableStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateRelationTableStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateRelationTableStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateRelationTableStatementContext createRelationTableStatement() {
		CreateRelationTableStatementContext _localctx = new CreateRelationTableStatementContext(Context, State);
		EnterRule(_localctx, 574, RULE_createRelationTableStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3651;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 3650;
				relationPropertiesListClause();
				}
			}

			State = 3654;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT) {
				{
				State = 3653;
				defaultCollationOption();
				}
			}

			State = 3657;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 3656;
				onCommitClause();
				}
			}

			State = 3660;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,276,Context) ) {
			case 1:
				{
				State = 3659;
				physicalPropertiesClause();
				}
				break;
			}
			State = 3662;
			tablePropertiesClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateXMLTypeTableStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLTYPE() { return GetToken(OracleAntlrParser.XMLTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectPropertiesListClauseContext objectPropertiesListClause() {
			return GetRuleContext<ObjectPropertiesListClauseContext>(0);
		}
		public CreateXMLTypeTableStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createXMLTypeTableStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateXMLTypeTableStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateXMLTypeTableStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateXMLTypeTableStatementContext createXMLTypeTableStatement() {
		CreateXMLTypeTableStatementContext _localctx = new CreateXMLTypeTableStatementContext(Context, State);
		EnterRule(_localctx, 576, RULE_createXMLTypeTableStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3664;
			Match(OF);
			State = 3665;
			Match(XMLTYPE);
			State = 3667;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 3666;
				objectPropertiesListClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TablePropertiesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ColumnPropertiesContext columnProperties() {
			return GetRuleContext<ColumnPropertiesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitioningDefinitionClauseContext partitioningDefinitionClause() {
			return GetRuleContext<PartitioningDefinitionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LobPropertiesListElementClauseContext lobPropertiesListElementClause() {
			return GetRuleContext<LobPropertiesListElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RowdependenciesClauseContext rowdependenciesClause() {
			return GetRuleContext<RowdependenciesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MonitoringClauseContext monitoringClause() {
			return GetRuleContext<MonitoringClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnableDisableConstraintClauseContext[] enableDisableConstraintClause() {
			return GetRuleContexts<EnableDisableConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnableDisableConstraintClauseContext enableDisableConstraintClause(int i) {
			return GetRuleContext<EnableDisableConstraintClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RowMovementClauseContext rowMovementClause() {
			return GetRuleContext<RowMovementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AsSubqueryClauseContext asSubqueryClause() {
			return GetRuleContext<AsSubqueryClauseContext>(0);
		}
		public TablePropertiesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablePropertiesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTablePropertiesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTablePropertiesClause(this);
		}
	}

	[RuleVersion(0)]
	public TablePropertiesClauseContext tablePropertiesClause() {
		TablePropertiesClauseContext _localctx = new TablePropertiesClauseContext(Context, State);
		EnterRule(_localctx, 578, RULE_tablePropertiesClause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3670;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLUMN || _la==LOB || _la==NESTED || _la==VARRAY || _la==XMLTYPE) {
				{
				State = 3669;
				columnProperties();
				}
			}

			State = 3673;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 3672;
				partitioningDefinitionClause();
				}
			}

			State = 3676;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,280,Context) ) {
			case 1:
				{
				State = 3675;
				lobPropertiesListElementClause();
				}
				break;
			}
			State = 3679;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOPARALLEL || _la==PARALLEL) {
				{
				State = 3678;
				parallelClause();
				}
			}

			State = 3682;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOROWDEPENDENCIES || _la==ROWDEPENDENCIES) {
				{
				State = 3681;
				rowdependenciesClause();
				}
			}

			State = 3685;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MONITORING || _la==NOMONITORING) {
				{
				State = 3684;
				monitoringClause();
				}
			}

			State = 3690;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,284,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 3687;
					enableDisableConstraintClause();
					}
					} 
				}
				State = 3692;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,284,Context);
			}
			State = 3694;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DISABLE || _la==ENABLE) {
				{
				State = 3693;
				rowMovementClause();
				}
			}

			State = 3697;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 3696;
				asSubqueryClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NestedTableColPropertiesContext[] nestedTableColProperties() {
			return GetRuleContexts<NestedTableColPropertiesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NestedTableColPropertiesContext nestedTableColProperties(int i) {
			return GetRuleContext<NestedTableColPropertiesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeColPropertiesContext[] objectTypeColProperties() {
			return GetRuleContexts<ObjectTypeColPropertiesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeColPropertiesContext objectTypeColProperties(int i) {
			return GetRuleContext<ObjectTypeColPropertiesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeColumnPropertiesContext[] xmlTypeColumnProperties() {
			return GetRuleContexts<XmlTypeColumnPropertiesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeColumnPropertiesContext xmlTypeColumnProperties(int i) {
			return GetRuleContext<XmlTypeColumnPropertiesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayStorageClauseContext[] varrayStorageClause() {
			return GetRuleContexts<VarrayStorageClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayStorageClauseContext varrayStorageClause(int i) {
			return GetRuleContext<VarrayStorageClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBStorageClauseContext[] lOBStorageClause() {
			return GetRuleContexts<LOBStorageClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBStorageClauseContext lOBStorageClause(int i) {
			return GetRuleContext<LOBStorageClauseContext>(i);
		}
		public ColumnPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterColumnProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitColumnProperties(this);
		}
	}

	[RuleVersion(0)]
	public ColumnPropertiesContext columnProperties() {
		ColumnPropertiesContext _localctx = new ColumnPropertiesContext(Context, State);
		EnterRule(_localctx, 580, RULE_columnProperties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3706;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 3706;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case NESTED:
					{
					State = 3699;
					nestedTableColProperties();
					}
					break;
				case COLUMN:
					{
					State = 3700;
					objectTypeColProperties();
					}
					break;
				case LOB:
				case VARRAY:
					{
					State = 3703;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case VARRAY:
						{
						State = 3701;
						varrayStorageClause();
						}
						break;
					case LOB:
						{
						State = 3702;
						lOBStorageClause();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				case XMLTYPE:
					{
					State = 3705;
					xmlTypeColumnProperties();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 3708;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COLUMN || _la==LOB || _la==NESTED || _la==VARRAY || _la==XMLTYPE );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeColumnPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLTYPE() { return GetToken(OracleAntlrParser.XMLTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem() {
			return GetRuleContext<ColumnListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlSchemaSpecContext xmlSchemaSpec() {
			return GetRuleContext<XmlSchemaSpecContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMN() { return GetToken(OracleAntlrParser.COLUMN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeStorageClauseContext xmlTypeStorageClause() {
			return GetRuleContext<XmlTypeStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(OracleAntlrParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public XmlTypeColumnPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeColumnProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlTypeColumnProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlTypeColumnProperties(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeColumnPropertiesContext xmlTypeColumnProperties() {
		XmlTypeColumnPropertiesContext _localctx = new XmlTypeColumnPropertiesContext(Context, State);
		EnterRule(_localctx, 582, RULE_xmlTypeColumnProperties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3710;
			Match(XMLTYPE);
			State = 3712;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLUMN) {
				{
				State = 3711;
				Match(COLUMN);
				}
			}

			State = 3714;
			columnListItem();
			State = 3716;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,291,Context) ) {
			case 1:
				{
				State = 3715;
				xmlTypeStorageClause();
				}
				break;
			}
			State = 3718;
			xmlSchemaSpec();
			State = 3721;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ID) {
				{
				State = 3719;
				Match(ID);
				State = 3720;
				literal();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeStoreAsClauseContext xmlTypeStoreAsClause() {
			return GetRuleContext<XmlTypeStoreAsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeStoreAllClauseContext xmlTypeStoreAllClause() {
			return GetRuleContext<XmlTypeStoreAllClauseContext>(0);
		}
		public XmlTypeStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlTypeStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlTypeStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeStorageClauseContext xmlTypeStorageClause() {
		XmlTypeStorageClauseContext _localctx = new XmlTypeStorageClauseContext(Context, State);
		EnterRule(_localctx, 584, RULE_xmlTypeStorageClause);
		try {
			State = 3725;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,293,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3723;
				xmlTypeStoreAsClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3724;
				xmlTypeStoreAllClause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeStoreAsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeStoreAsObjectRelationalClauseContext xmlTypeStoreAsObjectRelationalClause() {
			return GetRuleContext<XmlTypeStoreAsObjectRelationalClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeStoreAsLobClauseContext xmlTypeStoreAsLobClause() {
			return GetRuleContext<XmlTypeStoreAsLobClauseContext>(0);
		}
		public XmlTypeStoreAsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeStoreAsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlTypeStoreAsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlTypeStoreAsClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeStoreAsClauseContext xmlTypeStoreAsClause() {
		XmlTypeStoreAsClauseContext _localctx = new XmlTypeStoreAsClauseContext(Context, State);
		EnterRule(_localctx, 586, RULE_xmlTypeStoreAsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3727;
			Match(STORE);
			State = 3728;
			Match(AS);
			State = 3731;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case OBJECT:
				{
				State = 3729;
				xmlTypeStoreAsObjectRelationalClause();
				}
				break;
			case BASICFILE:
			case BINARY:
			case CLOB:
			case SECUREFILE:
				{
				State = 3730;
				xmlTypeStoreAsLobClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeStoreAsObjectRelationalClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(OracleAntlrParser.OBJECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONAL() { return GetToken(OracleAntlrParser.RELATIONAL, 0); }
		public XmlTypeStoreAsObjectRelationalClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeStoreAsObjectRelationalClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlTypeStoreAsObjectRelationalClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlTypeStoreAsObjectRelationalClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeStoreAsObjectRelationalClauseContext xmlTypeStoreAsObjectRelationalClause() {
		XmlTypeStoreAsObjectRelationalClauseContext _localctx = new XmlTypeStoreAsObjectRelationalClauseContext(Context, State);
		EnterRule(_localctx, 588, RULE_xmlTypeStoreAsObjectRelationalClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3733;
			Match(OBJECT);
			State = 3734;
			Match(RELATIONAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeStoreAsLobClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOB() { return GetToken(OracleAntlrParser.CLOB, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BINARY() { return GetToken(OracleAntlrParser.BINARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XML() { return GetToken(OracleAntlrParser.XML, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBPropertiesListClauseContext lOBPropertiesListClause() {
			return GetRuleContext<LOBPropertiesListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECUREFILE() { return GetToken(OracleAntlrParser.SECUREFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BASICFILE() { return GetToken(OracleAntlrParser.BASICFILE, 0); }
		public XmlTypeStoreAsLobClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeStoreAsLobClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlTypeStoreAsLobClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlTypeStoreAsLobClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeStoreAsLobClauseContext xmlTypeStoreAsLobClause() {
		XmlTypeStoreAsLobClauseContext _localctx = new XmlTypeStoreAsLobClauseContext(Context, State);
		EnterRule(_localctx, 590, RULE_xmlTypeStoreAsLobClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3737;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BASICFILE || _la==SECUREFILE) {
				{
				State = 3736;
				_la = TokenStream.LA(1);
				if ( !(_la==BASICFILE || _la==SECUREFILE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3742;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CLOB:
				{
				State = 3739;
				Match(CLOB);
				}
				break;
			case BINARY:
				{
				State = 3740;
				Match(BINARY);
				State = 3741;
				Match(XML);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3745;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,297,Context) ) {
			case 1:
				{
				State = 3744;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			}
			State = 3748;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 3747;
				lOBPropertiesListClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeStoreAllClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARRAYS() { return GetToken(OracleAntlrParser.VARRAYS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOBS() { return GetToken(OracleAntlrParser.LOBS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLES() { return GetToken(OracleAntlrParser.TABLES, 0); }
		public XmlTypeStoreAllClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeStoreAllClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlTypeStoreAllClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlTypeStoreAllClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeStoreAllClauseContext xmlTypeStoreAllClause() {
		XmlTypeStoreAllClauseContext _localctx = new XmlTypeStoreAllClauseContext(Context, State);
		EnterRule(_localctx, 592, RULE_xmlTypeStoreAllClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3750;
			Match(STORE);
			State = 3751;
			Match(ALL);
			State = 3752;
			Match(VARRAYS);
			State = 3753;
			Match(AS);
			State = 3754;
			_la = TokenStream.LA(1);
			if ( !(_la==LOBS || _la==TABLES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeColPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMN() { return GetToken(OracleAntlrParser.COLUMN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem() {
			return GetRuleContext<ColumnListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubstitutableColumnClauseContext substitutableColumnClause() {
			return GetRuleContext<SubstitutableColumnClauseContext>(0);
		}
		public ObjectTypeColPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeColProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectTypeColProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectTypeColProperties(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeColPropertiesContext objectTypeColProperties() {
		ObjectTypeColPropertiesContext _localctx = new ObjectTypeColPropertiesContext(Context, State);
		EnterRule(_localctx, 594, RULE_objectTypeColProperties);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3756;
			Match(COLUMN);
			State = 3757;
			columnListItem();
			State = 3758;
			substitutableColumnClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarrayColPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARRAY() { return GetToken(OracleAntlrParser.VARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem() {
			return GetRuleContext<ColumnListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubstitutableColumnClauseContext substitutableColumnClause() {
			return GetRuleContext<SubstitutableColumnClauseContext>(0);
		}
		public VarrayColPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varrayColProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterVarrayColProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitVarrayColProperties(this);
		}
	}

	[RuleVersion(0)]
	public VarrayColPropertiesContext varrayColProperties() {
		VarrayColPropertiesContext _localctx = new VarrayColPropertiesContext(Context, State);
		EnterRule(_localctx, 596, RULE_varrayColProperties);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3760;
			Match(VARRAY);
			State = 3761;
			columnListItem();
			State = 3762;
			substitutableColumnClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NestedTableColPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NESTED() { return GetToken(OracleAntlrParser.NESTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NestedItemClauseContext nestedItemClause() {
			return GetRuleContext<NestedItemClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StoreAsClauseContext storeAsClause() {
			return GetRuleContext<StoreAsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubstitutableColumnClauseContext substitutableColumnClause() {
			return GetRuleContext<SubstitutableColumnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NestedTableObjectPropertiesContext nestedTableObjectProperties() {
			return GetRuleContext<NestedTableObjectPropertiesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturnAsClauseContext returnAsClause() {
			return GetRuleContext<ReturnAsClauseContext>(0);
		}
		public NestedTableColPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nestedTableColProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNestedTableColProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNestedTableColProperties(this);
		}
	}

	[RuleVersion(0)]
	public NestedTableColPropertiesContext nestedTableColProperties() {
		NestedTableColPropertiesContext _localctx = new NestedTableColPropertiesContext(Context, State);
		EnterRule(_localctx, 598, RULE_nestedTableColProperties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3764;
			Match(NESTED);
			State = 3765;
			Match(TABLE);
			State = 3766;
			nestedItemClause();
			State = 3768;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELEMENT || _la==IS || _la==NOT || _la==SUBSTITUTABLE) {
				{
				State = 3767;
				substitutableColumnClause();
				}
			}

			State = 3770;
			storeAsClause();
			State = 3772;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 3771;
				nestedTableObjectProperties();
				}
			}

			State = 3775;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURN) {
				{
				State = 3774;
				returnAsClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NestedTableObjectPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectPropertiesListClauseContext objectPropertiesListClause() {
			return GetRuleContext<ObjectPropertiesListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalPropertiesClauseContext physicalPropertiesClause() {
			return GetRuleContext<PhysicalPropertiesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnPropertiesContext columnProperties() {
			return GetRuleContext<ColumnPropertiesContext>(0);
		}
		public NestedTableObjectPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nestedTableObjectProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNestedTableObjectProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNestedTableObjectProperties(this);
		}
	}

	[RuleVersion(0)]
	public NestedTableObjectPropertiesContext nestedTableObjectProperties() {
		NestedTableObjectPropertiesContext _localctx = new NestedTableObjectPropertiesContext(Context, State);
		EnterRule(_localctx, 600, RULE_nestedTableObjectProperties);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3777;
			Match(LPAREN);
			State = 3781;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,302,Context) ) {
			case 1:
				{
				State = 3778;
				objectPropertiesListClause();
				}
				break;
			case 2:
				{
				State = 3779;
				physicalPropertiesClause();
				}
				break;
			case 3:
				{
				State = 3780;
				columnProperties();
				}
				break;
			}
			State = 3783;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnAsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(OracleAntlrParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCATOR() { return GetToken(OracleAntlrParser.LOCATOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(OracleAntlrParser.VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		public ReturnAsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnAsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterReturnAsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitReturnAsClause(this);
		}
	}

	[RuleVersion(0)]
	public ReturnAsClauseContext returnAsClause() {
		ReturnAsClauseContext _localctx = new ReturnAsClauseContext(Context, State);
		EnterRule(_localctx, 602, RULE_returnAsClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3785;
			Match(RETURN);
			State = 3787;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 3786;
				Match(AS);
				}
			}

			State = 3789;
			_la = TokenStream.LA(1);
			if ( !(_la==LOCATOR || _la==VALUE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectPropertiesListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectPropertiesContext[] objectProperties() {
			return GetRuleContexts<ObjectPropertiesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectPropertiesContext objectProperties(int i) {
			return GetRuleContext<ObjectPropertiesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ObjectPropertiesListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectPropertiesListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectPropertiesListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectPropertiesListClause(this);
		}
	}

	[RuleVersion(0)]
	public ObjectPropertiesListClauseContext objectPropertiesListClause() {
		ObjectPropertiesListClauseContext _localctx = new ObjectPropertiesListClauseContext(Context, State);
		EnterRule(_localctx, 604, RULE_objectPropertiesListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3791;
			Match(LPAREN);
			State = 3792;
			objectProperties();
			State = 3797;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3793;
				Match(COMMA);
				State = 3794;
				objectProperties();
				}
				}
				State = 3799;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3800;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TableRefConstraintClauseContext tableRefConstraintClause() {
			return GetRuleContext<TableRefConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableConstraintClauseContext tableConstraintClause() {
			return GetRuleContext<TableConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SupplementalLoggingPropsClauseContext supplementalLoggingPropsClause() {
			return GetRuleContext<SupplementalLoggingPropsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComplexColumnListItemContext complexColumnListItem() {
			return GetRuleContext<ComplexColumnListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem() {
			return GetRuleContext<ColumnListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultValueClauseContext defaultValueClause() {
			return GetRuleContext<DefaultValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnRefConstraintClauseContext columnRefConstraintClause() {
			return GetRuleContext<ColumnRefConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext[] columnConstraintClause() {
			return GetRuleContexts<ColumnConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext columnConstraintClause(int i) {
			return GetRuleContext<ColumnConstraintClauseContext>(i);
		}
		public ObjectPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectProperties(this);
		}
	}

	[RuleVersion(0)]
	public ObjectPropertiesContext objectProperties() {
		ObjectPropertiesContext _localctx = new ObjectPropertiesContext(Context, State);
		EnterRule(_localctx, 606, RULE_objectProperties);
		int _la;
		try {
			State = 3820;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,309,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3802;
				tableRefConstraintClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3803;
				tableConstraintClause();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3804;
				supplementalLoggingPropsClause();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3807;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,305,Context) ) {
				case 1:
					{
					State = 3805;
					complexColumnListItem();
					}
					break;
				case 2:
					{
					State = 3806;
					columnListItem();
					}
					break;
				}
				State = 3810;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT || _la==ASSIGN_OPERATOR) {
					{
					State = 3809;
					defaultValueClause();
					}
				}

				State = 3818;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,308,Context) ) {
				case 1:
					{
					State = 3812;
					columnRefConstraintClause();
					}
					break;
				case 2:
					{
					State = 3814;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 3813;
						columnConstraintClause();
						}
						}
						State = 3816;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( _la==CHECK || _la==CONSTRAINT || _la==FOREIGN || ((((_la - 346)) & ~0x3f) == 0 && ((1L << (_la - 346)) & ((1L << (NOT - 346)) | (1L << (NULL - 346)) | (1L << (PRIMARY - 346)))) != 0) || _la==REFERENCES || _la==UNIQUE || _la==LPAREN );
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StoreAsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public StoreAsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storeAsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterStoreAsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitStoreAsClause(this);
		}
	}

	[RuleVersion(0)]
	public StoreAsClauseContext storeAsClause() {
		StoreAsClauseContext _localctx = new StoreAsClauseContext(Context, State);
		EnterRule(_localctx, 608, RULE_storeAsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3822;
			Match(STORE);
			State = 3823;
			Match(AS);
			State = 3824;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NestedItemClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMN_VALUE() { return GetToken(OracleAntlrParser.COLUMN_VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ComplexColumnListItemContext complexColumnListItem() {
			return GetRuleContext<ComplexColumnListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem() {
			return GetRuleContext<ColumnListItemContext>(0);
		}
		public NestedItemClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nestedItemClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNestedItemClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNestedItemClause(this);
		}
	}

	[RuleVersion(0)]
	public NestedItemClauseContext nestedItemClause() {
		NestedItemClauseContext _localctx = new NestedItemClauseContext(Context, State);
		EnterRule(_localctx, 610, RULE_nestedItemClause);
		try {
			State = 3831;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,311,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3826;
				Match(COLUMN_VALUE);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3829;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,310,Context) ) {
				case 1:
					{
					State = 3827;
					complexColumnListItem();
					}
					break;
				case 2:
					{
					State = 3828;
					columnListItem();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsSubqueryClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public AsSubqueryClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asSubqueryClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAsSubqueryClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAsSubqueryClause(this);
		}
	}

	[RuleVersion(0)]
	public AsSubqueryClauseContext asSubqueryClause() {
		AsSubqueryClauseContext _localctx = new AsSubqueryClauseContext(Context, State);
		EnterRule(_localctx, 612, RULE_asSubqueryClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3833;
			Match(AS);
			State = 3834;
			selectStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RowMovementClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EnableClauseContext enableClause() {
			return GetRuleContext<EnableClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MOVEMENT() { return GetToken(OracleAntlrParser.MOVEMENT, 0); }
		public RowMovementClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rowMovementClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRowMovementClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRowMovementClause(this);
		}
	}

	[RuleVersion(0)]
	public RowMovementClauseContext rowMovementClause() {
		RowMovementClauseContext _localctx = new RowMovementClauseContext(Context, State);
		EnterRule(_localctx, 614, RULE_rowMovementClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3836;
			enableClause();
			State = 3837;
			Match(ROW);
			State = 3838;
			Match(MOVEMENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnableDisableConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EnableClauseContext enableClause() {
			return GetRuleContext<EnableClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintPrimaryKeyClauseContext constraintPrimaryKeyClause() {
			return GetRuleContext<ConstraintPrimaryKeyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintUniqueClauseContext constraintUniqueClause() {
			return GetRuleContext<ConstraintUniqueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintNameClauseContext constraintNameClause() {
			return GetRuleContext<ConstraintNameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ValidateClauseContext validateClause() {
			return GetRuleContext<ValidateClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingIndexConstraintClauseContext usingIndexConstraintClause() {
			return GetRuleContext<UsingIndexConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionsIntoConstraintClauseContext exceptionsIntoConstraintClause() {
			return GetRuleContext<ExceptionsIntoConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CascadeClauseContext cascadeClause() {
			return GetRuleContext<CascadeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeepDropIndexClauseContext keepDropIndexClause() {
			return GetRuleContext<KeepDropIndexClauseContext>(0);
		}
		public EnableDisableConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enableDisableConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterEnableDisableConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitEnableDisableConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public EnableDisableConstraintClauseContext enableDisableConstraintClause() {
		EnableDisableConstraintClauseContext _localctx = new EnableDisableConstraintClauseContext(Context, State);
		EnterRule(_localctx, 616, RULE_enableDisableConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3840;
			enableClause();
			State = 3842;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOVALIDATE || _la==VALIDATE) {
				{
				State = 3841;
				validateClause();
				}
			}

			State = 3847;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PRIMARY:
				{
				State = 3844;
				constraintPrimaryKeyClause();
				}
				break;
			case UNIQUE:
				{
				State = 3845;
				constraintUniqueClause();
				}
				break;
			case CONSTRAINT:
				{
				State = 3846;
				constraintNameClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3850;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 3849;
				usingIndexConstraintClause();
				}
			}

			State = 3853;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXCEPTIONS) {
				{
				State = 3852;
				exceptionsIntoConstraintClause();
				}
			}

			State = 3856;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CASCADE) {
				{
				State = 3855;
				cascadeClause();
				}
			}

			State = 3859;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DROP || _la==KEEP) {
				{
				State = 3858;
				keepDropIndexClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeepDropIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(OracleAntlrParser.DROP, 0); }
		public KeepDropIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keepDropIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterKeepDropIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitKeepDropIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public KeepDropIndexClauseContext keepDropIndexClause() {
		KeepDropIndexClauseContext _localctx = new KeepDropIndexClauseContext(Context, State);
		EnterRule(_localctx, 618, RULE_keepDropIndexClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3861;
			_la = TokenStream.LA(1);
			if ( !(_la==DROP || _la==KEEP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3862;
			Match(INDEX);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CascadeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASCADE() { return GetToken(OracleAntlrParser.CASCADE, 0); }
		public CascadeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cascadeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCascadeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCascadeClause(this);
		}
	}

	[RuleVersion(0)]
	public CascadeClauseContext cascadeClause() {
		CascadeClauseContext _localctx = new CascadeClauseContext(Context, State);
		EnterRule(_localctx, 620, RULE_cascadeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3864;
			Match(CASCADE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MonitoringClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MONITORING() { return GetToken(OracleAntlrParser.MONITORING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMONITORING() { return GetToken(OracleAntlrParser.NOMONITORING, 0); }
		public MonitoringClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_monitoringClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMonitoringClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMonitoringClause(this);
		}
	}

	[RuleVersion(0)]
	public MonitoringClauseContext monitoringClause() {
		MonitoringClauseContext _localctx = new MonitoringClauseContext(Context, State);
		EnterRule(_localctx, 622, RULE_monitoringClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3866;
			_la = TokenStream.LA(1);
			if ( !(_la==MONITORING || _la==NOMONITORING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RowdependenciesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWDEPENDENCIES() { return GetToken(OracleAntlrParser.ROWDEPENDENCIES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOROWDEPENDENCIES() { return GetToken(OracleAntlrParser.NOROWDEPENDENCIES, 0); }
		public RowdependenciesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rowdependenciesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRowdependenciesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRowdependenciesClause(this);
		}
	}

	[RuleVersion(0)]
	public RowdependenciesClauseContext rowdependenciesClause() {
		RowdependenciesClauseContext _localctx = new RowdependenciesClauseContext(Context, State);
		EnterRule(_localctx, 624, RULE_rowdependenciesClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3868;
			_la = TokenStream.LA(1);
			if ( !(_la==NOROWDEPENDENCIES || _la==ROWDEPENDENCIES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParallelClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARALLEL() { return GetToken(OracleAntlrParser.PARALLEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOPARALLEL() { return GetToken(OracleAntlrParser.NOPARALLEL, 0); }
		public ParallelClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallelClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterParallelClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitParallelClause(this);
		}
	}

	[RuleVersion(0)]
	public ParallelClauseContext parallelClause() {
		ParallelClauseContext _localctx = new ParallelClauseContext(Context, State);
		EnterRule(_localctx, 626, RULE_parallelClause);
		int _la;
		try {
			State = 3875;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PARALLEL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3870;
				Match(PARALLEL);
				State = 3872;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATE || _la==FALSE || _la==INTERVAL || _la==TIMESTAMP || _la==TRUE || ((((_la - 581)) & ~0x3f) == 0 && ((1L << (_la - 581)) & ((1L << (INTEGER_LITERAL - 581)) | (1L << (FLOATING_POINT_LITERAL - 581)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 581)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 581)) | (1L << (BINARY_STRING_LITERAL - 581)) | (1L << (CHARACTER_STRING_LITERAL - 581)) | (1L << (MONEY_LITERAL - 581)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 581)))) != 0)) {
					{
					State = 3871;
					literal();
					}
				}

				}
				break;
			case NOPARALLEL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3874;
				Match(NOPARALLEL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitioningDefinitionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartitionByHashClauseContext partitionByHashClause() {
			return GetRuleContext<PartitionByHashClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompositePartitioningContext compositePartitioning() {
			return GetRuleContext<CompositePartitioningContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionByRangeClauseContext partitionByRangeClause() {
			return GetRuleContext<PartitionByRangeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionByListClauseContext partitionByListClause() {
			return GetRuleContext<PartitionByListClauseContext>(0);
		}
		public PartitioningDefinitionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitioningDefinitionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPartitioningDefinitionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPartitioningDefinitionClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitioningDefinitionClauseContext partitioningDefinitionClause() {
		PartitioningDefinitionClauseContext _localctx = new PartitioningDefinitionClauseContext(Context, State);
		EnterRule(_localctx, 628, RULE_partitioningDefinitionClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3877;
			Match(PARTITION);
			State = 3878;
			Match(BY);
			State = 3883;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,320,Context) ) {
			case 1:
				{
				State = 3879;
				partitionByHashClause();
				}
				break;
			case 2:
				{
				State = 3880;
				compositePartitioning();
				}
				break;
			case 3:
				{
				State = 3881;
				partitionByRangeClause();
				}
				break;
			case 4:
				{
				State = 3882;
				partitionByListClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompositePartitioningContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(OracleAntlrParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionDefinitionListClauseContext partitionDefinitionListClause() {
			return GetRuleContext<PartitionDefinitionListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubPartitionByListContext subPartitionByList() {
			return GetRuleContext<SubPartitionByListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubPartitionByHashContext subPartitionByHash() {
			return GetRuleContext<SubPartitionByHashContext>(0);
		}
		public CompositePartitioningContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compositePartitioning; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCompositePartitioning(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCompositePartitioning(this);
		}
	}

	[RuleVersion(0)]
	public CompositePartitioningContext compositePartitioning() {
		CompositePartitioningContext _localctx = new CompositePartitioningContext(Context, State);
		EnterRule(_localctx, 630, RULE_compositePartitioning);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3885;
			Match(RANGE);
			State = 3886;
			columnListInParenElementClause();
			State = 3889;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,321,Context) ) {
			case 1:
				{
				State = 3887;
				subPartitionByList();
				}
				break;
			case 2:
				{
				State = 3888;
				subPartitionByHash();
				}
				break;
			}
			State = 3891;
			partitionDefinitionListClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubPartitionByHashContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(OracleAntlrParser.HASH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubpartitionsStoreInClauseContext subpartitionsStoreInClause() {
			return GetRuleContext<SubpartitionsStoreInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubPartitionTemplateContext subPartitionTemplate() {
			return GetRuleContext<SubPartitionTemplateContext>(0);
		}
		public SubPartitionByHashContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subPartitionByHash; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubPartitionByHash(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubPartitionByHash(this);
		}
	}

	[RuleVersion(0)]
	public SubPartitionByHashContext subPartitionByHash() {
		SubPartitionByHashContext _localctx = new SubPartitionByHashContext(Context, State);
		EnterRule(_localctx, 632, RULE_subPartitionByHash);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3893;
			Match(SUBPARTITION);
			State = 3894;
			Match(BY);
			State = 3895;
			Match(HASH);
			State = 3896;
			columnListInParenElementClause();
			State = 3899;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SUBPARTITIONS:
				{
				State = 3897;
				subpartitionsStoreInClause();
				}
				break;
			case SUBPARTITION:
				{
				State = 3898;
				subPartitionTemplate();
				}
				break;
			case LPAREN:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubpartitionsStoreInClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITIONS() { return GetToken(OracleAntlrParser.SUBPARTITIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsStoreInClauseContext partitionsStoreInClause() {
			return GetRuleContext<PartitionsStoreInClauseContext>(0);
		}
		public SubpartitionsStoreInClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartitionsStoreInClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubpartitionsStoreInClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubpartitionsStoreInClause(this);
		}
	}

	[RuleVersion(0)]
	public SubpartitionsStoreInClauseContext subpartitionsStoreInClause() {
		SubpartitionsStoreInClauseContext _localctx = new SubpartitionsStoreInClauseContext(Context, State);
		EnterRule(_localctx, 634, RULE_subpartitionsStoreInClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3901;
			Match(SUBPARTITIONS);
			State = 3902;
			literal();
			State = 3904;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STORE) {
				{
				State = 3903;
				partitionsStoreInClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubPartitionByListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIST() { return GetToken(OracleAntlrParser.LIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubPartitionTemplateContext subPartitionTemplate() {
			return GetRuleContext<SubPartitionTemplateContext>(0);
		}
		public SubPartitionByListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subPartitionByList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubPartitionByList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubPartitionByList(this);
		}
	}

	[RuleVersion(0)]
	public SubPartitionByListContext subPartitionByList() {
		SubPartitionByListContext _localctx = new SubPartitionByListContext(Context, State);
		EnterRule(_localctx, 636, RULE_subPartitionByList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3906;
			Match(SUBPARTITION);
			State = 3907;
			Match(BY);
			State = 3908;
			Match(LIST);
			State = 3909;
			columnListInParenElementClause();
			State = 3911;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SUBPARTITION) {
				{
				State = 3910;
				subPartitionTemplate();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubPartitionTemplateContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEMPLATE() { return GetToken(OracleAntlrParser.TEMPLATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SubPartitionDefinitionListClauseContext subPartitionDefinitionListClause() {
			return GetRuleContext<SubPartitionDefinitionListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public SubPartitionTemplateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subPartitionTemplate; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubPartitionTemplate(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubPartitionTemplate(this);
		}
	}

	[RuleVersion(0)]
	public SubPartitionTemplateContext subPartitionTemplate() {
		SubPartitionTemplateContext _localctx = new SubPartitionTemplateContext(Context, State);
		EnterRule(_localctx, 638, RULE_subPartitionTemplate);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3913;
			Match(SUBPARTITION);
			State = 3914;
			Match(TEMPLATE);
			State = 3917;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				{
				State = 3915;
				subPartitionDefinitionListClause();
				}
				break;
			case DATE:
			case FALSE:
			case INTERVAL:
			case TIMESTAMP:
			case TRUE:
			case INTEGER_LITERAL:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case QUOTE_CHARACTER_STRING_LITERAL:
				{
				State = 3916;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubPartitionDefinitionListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SubPartitionDefinitionClauseContext[] subPartitionDefinitionClause() {
			return GetRuleContexts<SubPartitionDefinitionClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubPartitionDefinitionClauseContext subPartitionDefinitionClause(int i) {
			return GetRuleContext<SubPartitionDefinitionClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public SubPartitionDefinitionListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subPartitionDefinitionListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubPartitionDefinitionListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubPartitionDefinitionListClause(this);
		}
	}

	[RuleVersion(0)]
	public SubPartitionDefinitionListClauseContext subPartitionDefinitionListClause() {
		SubPartitionDefinitionListClauseContext _localctx = new SubPartitionDefinitionListClauseContext(Context, State);
		EnterRule(_localctx, 640, RULE_subPartitionDefinitionListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3919;
			Match(LPAREN);
			State = 3920;
			subPartitionDefinitionClause();
			State = 3925;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3921;
				Match(COMMA);
				State = 3922;
				subPartitionDefinitionClause();
				}
				}
				State = 3927;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3928;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubPartitionDefinitionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListValuesClauseContext listValuesClause() {
			return GetRuleContext<ListValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitioningStorageClauseContext partitioningStorageClause() {
			return GetRuleContext<PartitioningStorageClauseContext>(0);
		}
		public SubPartitionDefinitionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subPartitionDefinitionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubPartitionDefinitionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubPartitionDefinitionClause(this);
		}
	}

	[RuleVersion(0)]
	public SubPartitionDefinitionClauseContext subPartitionDefinitionClause() {
		SubPartitionDefinitionClauseContext _localctx = new SubPartitionDefinitionClauseContext(Context, State);
		EnterRule(_localctx, 642, RULE_subPartitionDefinitionClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3930;
			Match(SUBPARTITION);
			State = 3931;
			simpleIdentifier();
			State = 3933;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==VALUES) {
				{
				State = 3932;
				listValuesClause();
				}
			}

			State = 3936;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOB || _la==OVERFLOW || _la==TABLESPACE || _la==VARRAY) {
				{
				State = 3935;
				partitioningStorageClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionByListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIST() { return GetToken(OracleAntlrParser.LIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionDefinitionListClauseContext partitionDefinitionListClause() {
			return GetRuleContext<PartitionDefinitionListClauseContext>(0);
		}
		public PartitionByListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionByListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPartitionByListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPartitionByListClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionByListClauseContext partitionByListClause() {
		PartitionByListClauseContext _localctx = new PartitionByListClauseContext(Context, State);
		EnterRule(_localctx, 644, RULE_partitionByListClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3938;
			Match(LIST);
			State = 3939;
			columnListInParenElementClause();
			State = 3940;
			partitionDefinitionListClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionByHashClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(OracleAntlrParser.HASH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsSimpleClauseContext partitionsSimpleClause() {
			return GetRuleContext<PartitionsSimpleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionSimpleListClauseContext partitionSimpleListClause() {
			return GetRuleContext<PartitionSimpleListClauseContext>(0);
		}
		public PartitionByHashClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionByHashClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPartitionByHashClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPartitionByHashClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionByHashClauseContext partitionByHashClause() {
		PartitionByHashClauseContext _localctx = new PartitionByHashClauseContext(Context, State);
		EnterRule(_localctx, 646, RULE_partitionByHashClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3942;
			Match(HASH);
			State = 3943;
			columnListInParenElementClause();
			State = 3946;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PARTITIONS:
				{
				State = 3944;
				partitionsSimpleClause();
				}
				break;
			case LPAREN:
				{
				State = 3945;
				partitionSimpleListClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionsSimpleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITIONS() { return GetToken(OracleAntlrParser.PARTITIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsStoreInClauseContext partitionsStoreInClause() {
			return GetRuleContext<PartitionsStoreInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverflowClauseContext overflowClause() {
			return GetRuleContext<OverflowClauseContext>(0);
		}
		public PartitionsSimpleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionsSimpleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPartitionsSimpleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPartitionsSimpleClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionsSimpleClauseContext partitionsSimpleClause() {
		PartitionsSimpleClauseContext _localctx = new PartitionsSimpleClauseContext(Context, State);
		EnterRule(_localctx, 648, RULE_partitionsSimpleClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3948;
			Match(PARTITIONS);
			State = 3949;
			literal();
			State = 3951;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,330,Context) ) {
			case 1:
				{
				State = 3950;
				partitionsStoreInClause();
				}
				break;
			}
			State = 3954;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OVERFLOW) {
				{
				State = 3953;
				overflowClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionSimpleListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartitionSimpleClauseContext[] partitionSimpleClause() {
			return GetRuleContexts<PartitionSimpleClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionSimpleClauseContext partitionSimpleClause(int i) {
			return GetRuleContext<PartitionSimpleClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public PartitionSimpleListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionSimpleListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPartitionSimpleListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPartitionSimpleListClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionSimpleListClauseContext partitionSimpleListClause() {
		PartitionSimpleListClauseContext _localctx = new PartitionSimpleListClauseContext(Context, State);
		EnterRule(_localctx, 650, RULE_partitionSimpleListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3956;
			Match(LPAREN);
			State = 3957;
			partitionSimpleClause();
			State = 3962;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3958;
				Match(COMMA);
				State = 3959;
				partitionSimpleClause();
				}
				}
				State = 3964;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3965;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionSimpleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartitioningStorageClauseContext partitioningStorageClause() {
			return GetRuleContext<PartitioningStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		public PartitionSimpleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionSimpleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPartitionSimpleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPartitionSimpleClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionSimpleClauseContext partitionSimpleClause() {
		PartitionSimpleClauseContext _localctx = new PartitionSimpleClauseContext(Context, State);
		EnterRule(_localctx, 652, RULE_partitionSimpleClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3967;
			Match(PARTITION);
			State = 3973;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,334,Context) ) {
			case 1:
				{
				State = 3968;
				partitioningStorageClause();
				}
				break;
			case 2:
				{
				State = 3969;
				simpleIdentifier();
				State = 3971;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOB || _la==OVERFLOW || _la==TABLESPACE || _la==VARRAY) {
					{
					State = 3970;
					partitioningStorageClause();
					}
				}

				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionByRangeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PartitionByRangeColumnListContext partitionByRangeColumnList() {
			return GetRuleContext<PartitionByRangeColumnListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionDefinitionListClauseContext partitionDefinitionListClause() {
			return GetRuleContext<PartitionDefinitionListClauseContext>(0);
		}
		public PartitionByRangeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionByRangeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPartitionByRangeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPartitionByRangeClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionByRangeClauseContext partitionByRangeClause() {
		PartitionByRangeClauseContext _localctx = new PartitionByRangeClauseContext(Context, State);
		EnterRule(_localctx, 654, RULE_partitionByRangeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3975;
			partitionByRangeColumnList();
			State = 3976;
			partitionDefinitionListClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionDefinitionListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartitionDefinitionClauseContext[] partitionDefinitionClause() {
			return GetRuleContexts<PartitionDefinitionClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionDefinitionClauseContext partitionDefinitionClause(int i) {
			return GetRuleContext<PartitionDefinitionClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public PartitionDefinitionListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionDefinitionListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPartitionDefinitionListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPartitionDefinitionListClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionDefinitionListClauseContext partitionDefinitionListClause() {
		PartitionDefinitionListClauseContext _localctx = new PartitionDefinitionListClauseContext(Context, State);
		EnterRule(_localctx, 656, RULE_partitionDefinitionListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3978;
			Match(LPAREN);
			State = 3979;
			partitionDefinitionClause();
			State = 3984;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3980;
				Match(COMMA);
				State = 3981;
				partitionDefinitionClause();
				}
				}
				State = 3986;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3987;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionDefinitionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TablePartitionDescriptionContext tablePartitionDescription() {
			return GetRuleContext<TablePartitionDescriptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RangeValuesClauseContext rangeValuesClause() {
			return GetRuleContext<RangeValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListValuesClauseContext listValuesClause() {
			return GetRuleContext<ListValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		public PartitionDefinitionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionDefinitionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPartitionDefinitionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPartitionDefinitionClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionDefinitionClauseContext partitionDefinitionClause() {
		PartitionDefinitionClauseContext _localctx = new PartitionDefinitionClauseContext(Context, State);
		EnterRule(_localctx, 658, RULE_partitionDefinitionClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3989;
			Match(PARTITION);
			State = 3991;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 3990;
				simpleIdentifier();
				}
			}

			State = 3995;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,337,Context) ) {
			case 1:
				{
				State = 3993;
				rangeValuesClause();
				}
				break;
			case 2:
				{
				State = 3994;
				listValuesClause();
				}
				break;
			}
			State = 3997;
			tablePartitionDescription();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TablePartitionDescriptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseContext segmentAttributesClause() {
			return GetRuleContext<SegmentAttributesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableCompressionClauseContext tableCompressionClause() {
			return GetRuleContext<TableCompressionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverflowClauseContext overflowClause() {
			return GetRuleContext<OverflowClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayStorageClauseContext[] varrayStorageClause() {
			return GetRuleContexts<VarrayStorageClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayStorageClauseContext varrayStorageClause(int i) {
			return GetRuleContext<VarrayStorageClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBStorageClauseContext[] lOBStorageClause() {
			return GetRuleContexts<LOBStorageClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBStorageClauseContext lOBStorageClause(int i) {
			return GetRuleContext<LOBStorageClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionLevelSubpartitioningClauseContext partitionLevelSubpartitioningClause() {
			return GetRuleContext<PartitionLevelSubpartitioningClauseContext>(0);
		}
		public TablePartitionDescriptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablePartitionDescription; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTablePartitionDescription(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTablePartitionDescription(this);
		}
	}

	[RuleVersion(0)]
	public TablePartitionDescriptionContext tablePartitionDescription() {
		TablePartitionDescriptionContext _localctx = new TablePartitionDescriptionContext(Context, State);
		EnterRule(_localctx, 660, RULE_tablePartitionDescription);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4000;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 277)) & ~0x3f) == 0 && ((1L << (_la - 277)) & ((1L << (LOGGING - 277)) | (1L << (MAXTRANS - 277)) | (1L << (NOLOGGING - 277)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
				{
				State = 3999;
				segmentAttributesClause();
				}
			}

			State = 4003;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLUMN || _la==COMPRESS || _la==NOCOMPRESS || _la==ROW) {
				{
				State = 4002;
				tableCompressionClause();
				}
			}

			State = 4006;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OVERFLOW) {
				{
				State = 4005;
				overflowClause();
				}
			}

			State = 4012;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==LOB || _la==VARRAY) {
				{
				State = 4010;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case VARRAY:
					{
					State = 4008;
					varrayStorageClause();
					}
					break;
				case LOB:
					{
					State = 4009;
					lOBStorageClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 4014;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4016;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SUBPARTITIONS || _la==LPAREN) {
				{
				State = 4015;
				partitionLevelSubpartitioningClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionLevelSubpartitioningClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SubpartitionsSimpleClauseContext subpartitionsSimpleClause() {
			return GetRuleContext<SubpartitionsSimpleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubpartitionSpecListContext subpartitionSpecList() {
			return GetRuleContext<SubpartitionSpecListContext>(0);
		}
		public PartitionLevelSubpartitioningClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionLevelSubpartitioningClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPartitionLevelSubpartitioningClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPartitionLevelSubpartitioningClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionLevelSubpartitioningClauseContext partitionLevelSubpartitioningClause() {
		PartitionLevelSubpartitioningClauseContext _localctx = new PartitionLevelSubpartitioningClauseContext(Context, State);
		EnterRule(_localctx, 662, RULE_partitionLevelSubpartitioningClause);
		try {
			State = 4020;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SUBPARTITIONS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4018;
				subpartitionsSimpleClause();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4019;
				subpartitionSpecList();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubpartitionSpecListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SubpartitionSpecContext[] subpartitionSpec() {
			return GetRuleContexts<SubpartitionSpecContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubpartitionSpecContext subpartitionSpec(int i) {
			return GetRuleContext<SubpartitionSpecContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public SubpartitionSpecListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartitionSpecList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubpartitionSpecList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubpartitionSpecList(this);
		}
	}

	[RuleVersion(0)]
	public SubpartitionSpecListContext subpartitionSpecList() {
		SubpartitionSpecListContext _localctx = new SubpartitionSpecListContext(Context, State);
		EnterRule(_localctx, 664, RULE_subpartitionSpecList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4022;
			Match(LPAREN);
			State = 4023;
			subpartitionSpec();
			State = 4028;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4024;
				Match(COMMA);
				State = 4025;
				subpartitionSpec();
				}
				}
				State = 4030;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4031;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubpartitionSpecContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartitioningStorageClauseContext partitioningStorageClause() {
			return GetRuleContext<PartitioningStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListValuesClauseContext listValuesClause() {
			return GetRuleContext<ListValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		public SubpartitionSpecContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartitionSpec; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubpartitionSpec(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubpartitionSpec(this);
		}
	}

	[RuleVersion(0)]
	public SubpartitionSpecContext subpartitionSpec() {
		SubpartitionSpecContext _localctx = new SubpartitionSpecContext(Context, State);
		EnterRule(_localctx, 666, RULE_subpartitionSpec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4033;
			Match(SUBPARTITION);
			State = 4046;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,349,Context) ) {
			case 1:
				{
				State = 4034;
				partitioningStorageClause();
				}
				break;
			case 2:
				{
				State = 4035;
				listValuesClause();
				State = 4037;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOB || _la==OVERFLOW || _la==TABLESPACE || _la==VARRAY) {
					{
					State = 4036;
					partitioningStorageClause();
					}
				}

				}
				break;
			case 3:
				{
				State = 4039;
				simpleIdentifier();
				State = 4041;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==VALUES) {
					{
					State = 4040;
					listValuesClause();
					}
				}

				State = 4044;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOB || _la==OVERFLOW || _la==TABLESPACE || _la==VARRAY) {
					{
					State = 4043;
					partitioningStorageClause();
					}
				}

				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitioningStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext[] tablespaceClause() {
			return GetRuleContexts<TablespaceClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause(int i) {
			return GetRuleContext<TablespaceClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverflowClauseContext[] overflowClause() {
			return GetRuleContexts<OverflowClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OverflowClauseContext overflowClause(int i) {
			return GetRuleContext<OverflowClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayStorageClauseContext[] varrayStorageClause() {
			return GetRuleContexts<VarrayStorageClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayStorageClauseContext varrayStorageClause(int i) {
			return GetRuleContext<VarrayStorageClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBStorageClauseContext[] lOBStorageClause() {
			return GetRuleContexts<LOBStorageClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBStorageClauseContext lOBStorageClause(int i) {
			return GetRuleContext<LOBStorageClauseContext>(i);
		}
		public PartitioningStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitioningStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPartitioningStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPartitioningStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitioningStorageClauseContext partitioningStorageClause() {
		PartitioningStorageClauseContext _localctx = new PartitioningStorageClauseContext(Context, State);
		EnterRule(_localctx, 668, RULE_partitioningStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4052;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 4052;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TABLESPACE:
					{
					State = 4048;
					tablespaceClause();
					}
					break;
				case OVERFLOW:
					{
					State = 4049;
					overflowClause();
					}
					break;
				case VARRAY:
					{
					State = 4050;
					varrayStorageClause();
					}
					break;
				case LOB:
					{
					State = 4051;
					lOBStorageClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 4054;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==LOB || _la==OVERFLOW || _la==TABLESPACE || _la==VARRAY );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ListValuesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUES() { return GetToken(OracleAntlrParser.VALUES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParenthesizedExpressionListContext parenthesizedExpressionList() {
			return GetRuleContext<ParenthesizedExpressionListContext>(0);
		}
		public ListValuesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_listValuesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterListValuesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitListValuesClause(this);
		}
	}

	[RuleVersion(0)]
	public ListValuesClauseContext listValuesClause() {
		ListValuesClauseContext _localctx = new ListValuesClauseContext(Context, State);
		EnterRule(_localctx, 670, RULE_listValuesClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4056;
			Match(VALUES);
			State = 4057;
			parenthesizedExpressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubpartitionsSimpleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITIONS() { return GetToken(OracleAntlrParser.SUBPARTITIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsStoreInClauseContext partitionsStoreInClause() {
			return GetRuleContext<PartitionsStoreInClauseContext>(0);
		}
		public SubpartitionsSimpleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartitionsSimpleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubpartitionsSimpleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubpartitionsSimpleClause(this);
		}
	}

	[RuleVersion(0)]
	public SubpartitionsSimpleClauseContext subpartitionsSimpleClause() {
		SubpartitionsSimpleClauseContext _localctx = new SubpartitionsSimpleClauseContext(Context, State);
		EnterRule(_localctx, 672, RULE_subpartitionsSimpleClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4059;
			Match(SUBPARTITIONS);
			State = 4060;
			literal();
			State = 4062;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STORE) {
				{
				State = 4061;
				partitionsStoreInClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionsStoreInClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceListClauseContext tablespaceListClause() {
			return GetRuleContext<TablespaceListClauseContext>(0);
		}
		public PartitionsStoreInClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionsStoreInClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPartitionsStoreInClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPartitionsStoreInClause(this);
		}
	}

	[RuleVersion(0)]
	public PartitionsStoreInClauseContext partitionsStoreInClause() {
		PartitionsStoreInClauseContext _localctx = new PartitionsStoreInClauseContext(Context, State);
		EnterRule(_localctx, 674, RULE_partitionsStoreInClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4064;
			Match(STORE);
			State = 4065;
			Match(IN);
			State = 4066;
			tablespaceListClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TablespaceListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext[] simpleIdentifierWithoutParentheses() {
			return GetRuleContexts<SimpleIdentifierWithoutParenthesesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses(int i) {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public TablespaceListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablespaceListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTablespaceListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTablespaceListClause(this);
		}
	}

	[RuleVersion(0)]
	public TablespaceListClauseContext tablespaceListClause() {
		TablespaceListClauseContext _localctx = new TablespaceListClauseContext(Context, State);
		EnterRule(_localctx, 676, RULE_tablespaceListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4068;
			Match(LPAREN);
			State = 4069;
			simpleIdentifierWithoutParentheses();
			State = 4074;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4070;
				Match(COMMA);
				State = 4071;
				simpleIdentifierWithoutParentheses();
				}
				}
				State = 4076;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4077;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarrayStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARRAY() { return GetToken(OracleAntlrParser.VARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubstitutableColumnClauseContext substitutableColumnClause() {
			return GetRuleContext<SubstitutableColumnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StoreAsLobClauseContext storeAsLobClause() {
			return GetRuleContext<StoreAsLobClauseContext>(0);
		}
		public VarrayStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varrayStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterVarrayStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitVarrayStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public VarrayStorageClauseContext varrayStorageClause() {
		VarrayStorageClauseContext _localctx = new VarrayStorageClauseContext(Context, State);
		EnterRule(_localctx, 678, RULE_varrayStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4079;
			Match(VARRAY);
			State = 4080;
			simpleIdentifier();
			State = 4082;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELEMENT || _la==IS || _la==NOT || _la==SUBSTITUTABLE) {
				{
				State = 4081;
				substitutableColumnClause();
				}
			}

			State = 4085;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STORE) {
				{
				State = 4084;
				storeAsLobClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubstitutableColumnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ElementIsOfTypeClauseContext elementIsOfTypeClause() {
			return GetRuleContext<ElementIsOfTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotSubstitutableClauseContext notSubstitutableClause() {
			return GetRuleContext<NotSubstitutableClauseContext>(0);
		}
		public SubstitutableColumnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_substitutableColumnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubstitutableColumnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubstitutableColumnClause(this);
		}
	}

	[RuleVersion(0)]
	public SubstitutableColumnClauseContext substitutableColumnClause() {
		SubstitutableColumnClauseContext _localctx = new SubstitutableColumnClauseContext(Context, State);
		EnterRule(_localctx, 680, RULE_substitutableColumnClause);
		try {
			State = 4089;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ELEMENT:
			case IS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4087;
				elementIsOfTypeClause();
				}
				break;
			case NOT:
			case SUBSTITUTABLE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4088;
				notSubstitutableClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NotSubstitutableClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBSTITUTABLE() { return GetToken(OracleAntlrParser.SUBSTITUTABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT() { return GetToken(OracleAntlrParser.AT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEVELS() { return GetToken(OracleAntlrParser.LEVELS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public NotSubstitutableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_notSubstitutableClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNotSubstitutableClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNotSubstitutableClause(this);
		}
	}

	[RuleVersion(0)]
	public NotSubstitutableClauseContext notSubstitutableClause() {
		NotSubstitutableClauseContext _localctx = new NotSubstitutableClauseContext(Context, State);
		EnterRule(_localctx, 682, RULE_notSubstitutableClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4092;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 4091;
				Match(NOT);
				}
			}

			State = 4094;
			Match(SUBSTITUTABLE);
			State = 4095;
			Match(AT);
			State = 4096;
			Match(ALL);
			State = 4097;
			Match(LEVELS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementIsOfTypeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELEMENT() { return GetToken(OracleAntlrParser.ELEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterOnlyContext delimiterOnly() {
			return GetRuleContext<DelimiterOnlyContext>(0);
		}
		public ElementIsOfTypeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementIsOfTypeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterElementIsOfTypeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitElementIsOfTypeClause(this);
		}
	}

	[RuleVersion(0)]
	public ElementIsOfTypeClauseContext elementIsOfTypeClause() {
		ElementIsOfTypeClauseContext _localctx = new ElementIsOfTypeClauseContext(Context, State);
		EnterRule(_localctx, 684, RULE_elementIsOfTypeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4100;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELEMENT) {
				{
				State = 4099;
				Match(ELEMENT);
				}
			}

			State = 4102;
			Match(IS);
			State = 4103;
			Match(OF);
			State = 4105;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TYPE) {
				{
				State = 4104;
				Match(TYPE);
				}
			}

			State = 4107;
			Match(LPAREN);
			State = 4109;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,360,Context) ) {
			case 1:
				{
				State = 4108;
				delimiterOnly();
				}
				break;
			}
			State = 4111;
			typeReference();
			State = 4112;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterOnlyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLY() { return GetToken(OracleAntlrParser.ONLY, 0); }
		public DelimiterOnlyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterOnly; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterOnly(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterOnly(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterOnlyContext delimiterOnly() {
		DelimiterOnlyContext _localctx = new DelimiterOnlyContext(Context, State);
		EnterRule(_localctx, 686, RULE_delimiterOnly);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4114;
			Match(ONLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StoreAsLobClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOB() { return GetToken(OracleAntlrParser.LOB, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LOBPropertiesListClauseContext lOBPropertiesListClause() {
			return GetRuleContext<LOBPropertiesListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECUREFILE() { return GetToken(OracleAntlrParser.SECUREFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BASICFILE() { return GetToken(OracleAntlrParser.BASICFILE, 0); }
		public StoreAsLobClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storeAsLobClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterStoreAsLobClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitStoreAsLobClause(this);
		}
	}

	[RuleVersion(0)]
	public StoreAsLobClauseContext storeAsLobClause() {
		StoreAsLobClauseContext _localctx = new StoreAsLobClauseContext(Context, State);
		EnterRule(_localctx, 688, RULE_storeAsLobClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4116;
			Match(STORE);
			State = 4117;
			Match(AS);
			State = 4119;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BASICFILE || _la==SECUREFILE) {
				{
				State = 4118;
				_la = TokenStream.LA(1);
				if ( !(_la==BASICFILE || _la==SECUREFILE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 4121;
			Match(LOB);
			State = 4127;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				{
				State = 4122;
				lOBPropertiesListClause();
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 4123;
				simpleIdentifierWithoutParentheses();
				State = 4125;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,362,Context) ) {
				case 1:
					{
					State = 4124;
					lOBPropertiesListClause();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LOBStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LobStoreAsClauseContext lobStoreAsClause() {
			return GetRuleContext<LobStoreAsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LOBPropertiesListClauseContext lOBPropertiesListClause() {
			return GetRuleContext<LOBPropertiesListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public LOBStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lOBStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLOBStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLOBStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public LOBStorageClauseContext lOBStorageClause() {
		LOBStorageClauseContext _localctx = new LOBStorageClauseContext(Context, State);
		EnterRule(_localctx, 690, RULE_lOBStorageClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4129;
			lobStoreAsClause();
			State = 4135;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				{
				State = 4130;
				lOBPropertiesListClause();
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 4131;
				simpleIdentifierWithoutParentheses();
				State = 4133;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,364,Context) ) {
				case 1:
					{
					State = 4132;
					lOBPropertiesListClause();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LOBPropertiesListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext[] tablespaceClause() {
			return GetRuleContexts<TablespaceClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause(int i) {
			return GetRuleContext<TablespaceClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StorageAttributesClauseContext[] storageAttributesClause() {
			return GetRuleContexts<StorageAttributesClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StorageAttributesClauseContext storageAttributesClause(int i) {
			return GetRuleContext<StorageAttributesClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LobPropertiesListElementClauseContext[] lobPropertiesListElementClause() {
			return GetRuleContexts<LobPropertiesListElementClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LobPropertiesListElementClauseContext lobPropertiesListElementClause(int i) {
			return GetRuleContext<LobPropertiesListElementClauseContext>(i);
		}
		public LOBPropertiesListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lOBPropertiesListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLOBPropertiesListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLOBPropertiesListClause(this);
		}
	}

	[RuleVersion(0)]
	public LOBPropertiesListClauseContext lOBPropertiesListClause() {
		LOBPropertiesListClauseContext _localctx = new LOBPropertiesListClauseContext(Context, State);
		EnterRule(_localctx, 692, RULE_lOBPropertiesListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4137;
			Match(LPAREN);
			State = 4141;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 4141;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TABLESPACE:
					{
					State = 4138;
					tablespaceClause();
					}
					break;
				case STORAGE:
					{
					State = 4139;
					storageAttributesClause();
					}
					break;
				case CACHE:
				case CHUNK:
				case COMPRESS:
				case DECRYPT:
				case DEDUPLICATE:
				case DISABLE:
				case ENABLE:
				case ENCRYPT:
				case FREEPOOLS:
				case KEEP_DUPLICATES:
				case NOCACHE:
				case NOCOMPRESS:
				case PCTVERSION:
				case RETENTION:
					{
					State = 4140;
					lobPropertiesListElementClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 4143;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( ((((_la - 52)) & ~0x3f) == 0 && ((1L << (_la - 52)) & ((1L << (CACHE - 52)) | (1L << (CHUNK - 52)) | (1L << (COMPRESS - 52)))) != 0) || ((((_la - 117)) & ~0x3f) == 0 && ((1L << (_la - 117)) & ((1L << (DECRYPT - 117)) | (1L << (DEDUPLICATE - 117)) | (1L << (DISABLE - 117)) | (1L << (ENABLE - 117)) | (1L << (ENCRYPT - 117)))) != 0) || _la==FREEPOOLS || _la==KEEP_DUPLICATES || _la==NOCACHE || _la==NOCOMPRESS || _la==PCTVERSION || _la==RETENTION || _la==STORAGE || _la==TABLESPACE );
			State = 4145;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LobPropertiesListElementClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETENTION() { return GetToken(OracleAntlrParser.RETENTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAX() { return GetToken(OracleAntlrParser.MAX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MIN() { return GetToken(OracleAntlrParser.MIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTO() { return GetToken(OracleAntlrParser.AUTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(OracleAntlrParser.NONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENCRYPT() { return GetToken(OracleAntlrParser.ENCRYPT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharacterStringLiteralContext characterStringLiteral() {
			return GetRuleContext<CharacterStringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIED() { return GetToken(OracleAntlrParser.IDENTIFIED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SALT() { return GetToken(OracleAntlrParser.SALT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NO() { return GetToken(OracleAntlrParser.NO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CACHE() { return GetToken(OracleAntlrParser.CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READS() { return GetToken(OracleAntlrParser.READS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause() {
			return GetRuleContext<LoggingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPRESS() { return GetToken(OracleAntlrParser.COMPRESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HIGH() { return GetToken(OracleAntlrParser.HIGH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEDIUM() { return GetToken(OracleAntlrParser.MEDIUM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORAGE() { return GetToken(OracleAntlrParser.STORAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISABLE() { return GetToken(OracleAntlrParser.DISABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHUNK() { return GetToken(OracleAntlrParser.CHUNK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTVERSION() { return GetToken(OracleAntlrParser.PCTVERSION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FREEPOOLS() { return GetToken(OracleAntlrParser.FREEPOOLS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCACHE() { return GetToken(OracleAntlrParser.NOCACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEDUPLICATE() { return GetToken(OracleAntlrParser.DEDUPLICATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP_DUPLICATES() { return GetToken(OracleAntlrParser.KEEP_DUPLICATES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECRYPT() { return GetToken(OracleAntlrParser.DECRYPT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCOMPRESS() { return GetToken(OracleAntlrParser.NOCOMPRESS, 0); }
		public LobPropertiesListElementClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lobPropertiesListElementClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLobPropertiesListElementClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLobPropertiesListElementClause(this);
		}
	}

	[RuleVersion(0)]
	public LobPropertiesListElementClauseContext lobPropertiesListElementClause() {
		LobPropertiesListElementClauseContext _localctx = new LobPropertiesListElementClauseContext(Context, State);
		EnterRule(_localctx, 694, RULE_lobPropertiesListElementClause);
		int _la;
		try {
			State = 4202;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,370,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4147;
				Match(RETENTION);
				State = 4148;
				Match(MAX);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4149;
				Match(RETENTION);
				State = 4150;
				Match(MIN);
				State = 4151;
				literal();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4152;
				Match(RETENTION);
				State = 4153;
				Match(AUTO);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4154;
				Match(RETENTION);
				State = 4155;
				Match(NONE);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4156;
				Match(ENCRYPT);
				State = 4157;
				Match(USING);
				State = 4158;
				characterStringLiteral();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4159;
				Match(ENCRYPT);
				State = 4160;
				Match(IDENTIFIED);
				State = 4161;
				Match(BY);
				State = 4162;
				simpleIdentifier();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 4163;
				Match(ENCRYPT);
				State = 4164;
				Match(SALT);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 4165;
				Match(ENCRYPT);
				State = 4166;
				Match(NO);
				State = 4167;
				Match(SALT);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 4168;
				Match(CACHE);
				State = 4169;
				Match(READS);
				State = 4171;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FILESYSTEM_LIKE_LOGGING || _la==LOGGING || _la==NOLOGGING) {
					{
					State = 4170;
					loggingClause();
					}
				}

				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 4173;
				Match(COMPRESS);
				State = 4174;
				Match(HIGH);
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 4175;
				Match(COMPRESS);
				State = 4176;
				Match(MEDIUM);
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 4177;
				Match(ENABLE);
				State = 4178;
				Match(STORAGE);
				State = 4179;
				Match(IN);
				State = 4180;
				Match(ROW);
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 4181;
				Match(DISABLE);
				State = 4182;
				Match(STORAGE);
				State = 4183;
				Match(IN);
				State = 4184;
				Match(ROW);
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 4185;
				Match(CACHE);
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 4186;
				Match(CHUNK);
				State = 4187;
				literal();
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 4188;
				Match(PCTVERSION);
				State = 4189;
				literal();
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 4190;
				Match(RETENTION);
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 4191;
				Match(FREEPOOLS);
				State = 4192;
				literal();
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 4193;
				Match(NOCACHE);
				State = 4195;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FILESYSTEM_LIKE_LOGGING || _la==LOGGING || _la==NOLOGGING) {
					{
					State = 4194;
					loggingClause();
					}
				}

				}
				break;
			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 4197;
				Match(DEDUPLICATE);
				}
				break;
			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 4198;
				Match(KEEP_DUPLICATES);
				}
				break;
			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 4199;
				Match(DECRYPT);
				}
				break;
			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 4200;
				Match(COMPRESS);
				}
				break;
			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 4201;
				Match(NOCOMPRESS);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LobStoreAsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOB() { return GetToken(OracleAntlrParser.LOB, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext[] simpleIdentifier() {
			return GetRuleContexts<SimpleIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier(int i) {
			return GetRuleContext<SimpleIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public LobStoreAsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lobStoreAsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLobStoreAsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLobStoreAsClause(this);
		}
	}

	[RuleVersion(0)]
	public LobStoreAsClauseContext lobStoreAsClause() {
		LobStoreAsClauseContext _localctx = new LobStoreAsClauseContext(Context, State);
		EnterRule(_localctx, 696, RULE_lobStoreAsClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4204;
			Match(LOB);
			State = 4205;
			Match(LPAREN);
			State = 4206;
			simpleIdentifier();
			State = 4211;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4207;
				Match(COMMA);
				State = 4208;
				simpleIdentifier();
				}
				}
				State = 4213;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4214;
			Match(RPAREN);
			State = 4215;
			Match(STORE);
			State = 4216;
			Match(AS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RangeValuesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUES() { return GetToken(OracleAntlrParser.VALUES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS() { return GetToken(OracleAntlrParser.LESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THAN() { return GetToken(OracleAntlrParser.THAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ValuesLessThanListClauseContext valuesLessThanListClause() {
			return GetRuleContext<ValuesLessThanListClauseContext>(0);
		}
		public RangeValuesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rangeValuesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRangeValuesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRangeValuesClause(this);
		}
	}

	[RuleVersion(0)]
	public RangeValuesClauseContext rangeValuesClause() {
		RangeValuesClauseContext _localctx = new RangeValuesClauseContext(Context, State);
		EnterRule(_localctx, 698, RULE_rangeValuesClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4218;
			Match(VALUES);
			State = 4219;
			Match(LESS);
			State = 4220;
			Match(THAN);
			State = 4221;
			valuesLessThanListClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ValuesLessThanListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ValuesLessThanListItemContext[] valuesLessThanListItem() {
			return GetRuleContexts<ValuesLessThanListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ValuesLessThanListItemContext valuesLessThanListItem(int i) {
			return GetRuleContext<ValuesLessThanListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ValuesLessThanListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_valuesLessThanListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterValuesLessThanListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitValuesLessThanListClause(this);
		}
	}

	[RuleVersion(0)]
	public ValuesLessThanListClauseContext valuesLessThanListClause() {
		ValuesLessThanListClauseContext _localctx = new ValuesLessThanListClauseContext(Context, State);
		EnterRule(_localctx, 700, RULE_valuesLessThanListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4223;
			Match(LPAREN);
			State = 4224;
			valuesLessThanListItem();
			State = 4229;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4225;
				Match(COMMA);
				State = 4226;
				valuesLessThanListItem();
				}
				}
				State = 4231;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4232;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ValuesLessThanListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXVALUE() { return GetToken(OracleAntlrParser.MAXVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ValuesLessThanListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_valuesLessThanListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterValuesLessThanListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitValuesLessThanListItem(this);
		}
	}

	[RuleVersion(0)]
	public ValuesLessThanListItemContext valuesLessThanListItem() {
		ValuesLessThanListItemContext _localctx = new ValuesLessThanListItemContext(Context, State);
		EnterRule(_localctx, 702, RULE_valuesLessThanListItem);
		try {
			State = 4236;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MAXVALUE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4234;
				Match(MAXVALUE);
				}
				break;
			case DATE:
			case FALSE:
			case INTERVAL:
			case TIMESTAMP:
			case TRUE:
			case INTEGER_LITERAL:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case QUOTE_CHARACTER_STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4235;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionByRangeColumnListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(OracleAntlrParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public PartitionByRangeColumnListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionByRangeColumnList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPartitionByRangeColumnList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPartitionByRangeColumnList(this);
		}
	}

	[RuleVersion(0)]
	public PartitionByRangeColumnListContext partitionByRangeColumnList() {
		PartitionByRangeColumnListContext _localctx = new PartitionByRangeColumnListContext(Context, State);
		EnterRule(_localctx, 704, RULE_partitionByRangeColumnList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4238;
			Match(RANGE);
			State = 4239;
			columnListInParenElementClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PhysicalPropertiesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalPropertiesOrganizationClauseContext physicalPropertiesOrganizationClause() {
			return GetRuleContext<PhysicalPropertiesOrganizationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeferredSegmentCreationClauseContext deferredSegmentCreationClause() {
			return GetRuleContext<DeferredSegmentCreationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseElementContext[] segmentAttributesClauseElement() {
			return GetRuleContexts<SegmentAttributesClauseElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseElementContext segmentAttributesClauseElement(int i) {
			return GetRuleContext<SegmentAttributesClauseElementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableCompressionClauseContext[] tableCompressionClause() {
			return GetRuleContexts<TableCompressionClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableCompressionClauseContext tableCompressionClause(int i) {
			return GetRuleContext<TableCompressionClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalPropertiesClusterClauseContext physicalPropertiesClusterClause() {
			return GetRuleContext<PhysicalPropertiesClusterClauseContext>(0);
		}
		public PhysicalPropertiesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_physicalPropertiesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPhysicalPropertiesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPhysicalPropertiesClause(this);
		}
	}

	[RuleVersion(0)]
	public PhysicalPropertiesClauseContext physicalPropertiesClause() {
		PhysicalPropertiesClauseContext _localctx = new PhysicalPropertiesClauseContext(Context, State);
		EnterRule(_localctx, 706, RULE_physicalPropertiesClause);
		int _la;
		try {
			int _alt;
			State = 4255;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,378,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4242;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SEGMENT) {
					{
					State = 4241;
					deferredSegmentCreationClause();
					}
				}

				State = 4244;
				physicalPropertiesOrganizationClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4246;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SEGMENT) {
					{
					State = 4245;
					deferredSegmentCreationClause();
					}
				}

				State = 4250;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						State = 4250;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case FILESYSTEM_LIKE_LOGGING:
						case INITRANS:
						case LOGGING:
						case MAXTRANS:
						case NOLOGGING:
						case PCTFREE:
						case PCTUSED:
						case STORAGE:
						case TABLESPACE:
							{
							State = 4248;
							segmentAttributesClauseElement();
							}
							break;
						case COLUMN:
						case COMPRESS:
						case NOCOMPRESS:
						case ROW:
							{
							State = 4249;
							tableCompressionClause();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 4252;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,377,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4254;
				physicalPropertiesClusterClause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PhysicalPropertiesClusterClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLUSTER() { return GetToken(OracleAntlrParser.CLUSTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public PhysicalPropertiesClusterClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_physicalPropertiesClusterClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPhysicalPropertiesClusterClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPhysicalPropertiesClusterClause(this);
		}
	}

	[RuleVersion(0)]
	public PhysicalPropertiesClusterClauseContext physicalPropertiesClusterClause() {
		PhysicalPropertiesClusterClauseContext _localctx = new PhysicalPropertiesClusterClauseContext(Context, State);
		EnterRule(_localctx, 708, RULE_physicalPropertiesClusterClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4257;
			Match(CLUSTER);
			State = 4258;
			simpleIdentifierWithoutParentheses();
			State = 4259;
			columnListInParenElementClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PhysicalPropertiesOrganizationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORGANIZATION() { return GetToken(OracleAntlrParser.ORGANIZATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HEAP() { return GetToken(OracleAntlrParser.HEAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseElementContext[] segmentAttributesClauseElement() {
			return GetRuleContexts<SegmentAttributesClauseElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseElementContext segmentAttributesClauseElement(int i) {
			return GetRuleContext<SegmentAttributesClauseElementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public HeapOrganizedTableClauseElementContext[] heapOrganizedTableClauseElement() {
			return GetRuleContexts<HeapOrganizedTableClauseElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public HeapOrganizedTableClauseElementContext heapOrganizedTableClauseElement(int i) {
			return GetRuleContext<HeapOrganizedTableClauseElementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOrganizedTableClauseElementContext[] indexOrganizedTableClauseElement() {
			return GetRuleContexts<IndexOrganizedTableClauseElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOrganizedTableClauseElementContext indexOrganizedTableClauseElement(int i) {
			return GetRuleContext<IndexOrganizedTableClauseElementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexOrganizedOverflowClauseContext indexOrganizedOverflowClause() {
			return GetRuleContext<IndexOrganizedOverflowClauseContext>(0);
		}
		public PhysicalPropertiesOrganizationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_physicalPropertiesOrganizationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPhysicalPropertiesOrganizationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPhysicalPropertiesOrganizationClause(this);
		}
	}

	[RuleVersion(0)]
	public PhysicalPropertiesOrganizationClauseContext physicalPropertiesOrganizationClause() {
		PhysicalPropertiesOrganizationClauseContext _localctx = new PhysicalPropertiesOrganizationClauseContext(Context, State);
		EnterRule(_localctx, 710, RULE_physicalPropertiesOrganizationClause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4261;
			Match(ORGANIZATION);
			State = 4279;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case HEAP:
				{
				State = 4262;
				Match(HEAP);
				State = 4265;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						State = 4265;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case FILESYSTEM_LIKE_LOGGING:
						case INITRANS:
						case LOGGING:
						case MAXTRANS:
						case NOLOGGING:
						case PCTFREE:
						case PCTUSED:
						case STORAGE:
						case TABLESPACE:
							{
							State = 4263;
							segmentAttributesClauseElement();
							}
							break;
						case COLUMN:
						case COMPRESS:
						case NOCOMPRESS:
						case ROW:
							{
							State = 4264;
							heapOrganizedTableClauseElement();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 4267;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,380,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case INDEX:
				{
				State = 4269;
				Match(INDEX);
				State = 4272;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						State = 4272;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case FILESYSTEM_LIKE_LOGGING:
						case INITRANS:
						case LOGGING:
						case MAXTRANS:
						case NOLOGGING:
						case PCTFREE:
						case PCTUSED:
						case STORAGE:
						case TABLESPACE:
							{
							State = 4270;
							segmentAttributesClauseElement();
							}
							break;
						case COMPRESS:
						case MAPPING:
						case NOCOMPRESS:
						case NOMAPPING:
						case PCTTHRESHOLD:
							{
							State = 4271;
							indexOrganizedTableClauseElement();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 4274;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,382,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				State = 4277;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INCLUDING || _la==OVERFLOW) {
					{
					State = 4276;
					indexOrganizedOverflowClause();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeferredSegmentCreationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEGMENT() { return GetToken(OracleAntlrParser.SEGMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATION() { return GetToken(OracleAntlrParser.CREATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMEDIATE() { return GetToken(OracleAntlrParser.IMMEDIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFERRED() { return GetToken(OracleAntlrParser.DEFERRED, 0); }
		public DeferredSegmentCreationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deferredSegmentCreationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDeferredSegmentCreationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDeferredSegmentCreationClause(this);
		}
	}

	[RuleVersion(0)]
	public DeferredSegmentCreationClauseContext deferredSegmentCreationClause() {
		DeferredSegmentCreationClauseContext _localctx = new DeferredSegmentCreationClauseContext(Context, State);
		EnterRule(_localctx, 712, RULE_deferredSegmentCreationClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4281;
			Match(SEGMENT);
			State = 4282;
			Match(CREATION);
			State = 4283;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFERRED || _la==IMMEDIATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HeapOrganizedTableClauseElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TableCompressionClauseContext tableCompressionClause() {
			return GetRuleContext<TableCompressionClauseContext>(0);
		}
		public HeapOrganizedTableClauseElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_heapOrganizedTableClauseElement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterHeapOrganizedTableClauseElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitHeapOrganizedTableClauseElement(this);
		}
	}

	[RuleVersion(0)]
	public HeapOrganizedTableClauseElementContext heapOrganizedTableClauseElement() {
		HeapOrganizedTableClauseElementContext _localctx = new HeapOrganizedTableClauseElementContext(Context, State);
		EnterRule(_localctx, 714, RULE_heapOrganizedTableClauseElement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4285;
			tableCompressionClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOrganizedTableClauseElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PCTThresholdClauseContext pCTThresholdClause() {
			return GetRuleContext<PCTThresholdClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionClauseContext indexCompressionClause() {
			return GetRuleContext<IndexCompressionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MappingTableClauseContext mappingTableClause() {
			return GetRuleContext<MappingTableClauseContext>(0);
		}
		public IndexOrganizedTableClauseElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOrganizedTableClauseElement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexOrganizedTableClauseElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexOrganizedTableClauseElement(this);
		}
	}

	[RuleVersion(0)]
	public IndexOrganizedTableClauseElementContext indexOrganizedTableClauseElement() {
		IndexOrganizedTableClauseElementContext _localctx = new IndexOrganizedTableClauseElementContext(Context, State);
		EnterRule(_localctx, 716, RULE_indexOrganizedTableClauseElement);
		try {
			State = 4290;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PCTTHRESHOLD:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4287;
				pCTThresholdClause();
				}
				break;
			case COMPRESS:
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4288;
				indexCompressionClause();
				}
				break;
			case MAPPING:
			case NOMAPPING:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4289;
				mappingTableClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOrganizedOverflowClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public OverflowClauseContext overflowClause() {
			return GetRuleContext<OverflowClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IncludingOverflowClauseContext includingOverflowClause() {
			return GetRuleContext<IncludingOverflowClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseContext segmentAttributesClause() {
			return GetRuleContext<SegmentAttributesClauseContext>(0);
		}
		public IndexOrganizedOverflowClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOrganizedOverflowClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexOrganizedOverflowClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexOrganizedOverflowClause(this);
		}
	}

	[RuleVersion(0)]
	public IndexOrganizedOverflowClauseContext indexOrganizedOverflowClause() {
		IndexOrganizedOverflowClauseContext _localctx = new IndexOrganizedOverflowClauseContext(Context, State);
		EnterRule(_localctx, 718, RULE_indexOrganizedOverflowClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4293;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INCLUDING) {
				{
				State = 4292;
				includingOverflowClause();
				}
			}

			State = 4295;
			overflowClause();
			State = 4297;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 277)) & ~0x3f) == 0 && ((1L << (_la - 277)) & ((1L << (LOGGING - 277)) | (1L << (MAXTRANS - 277)) | (1L << (NOLOGGING - 277)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
				{
				State = 4296;
				segmentAttributesClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverflowClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVERFLOW() { return GetToken(OracleAntlrParser.OVERFLOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseContext segmentAttributesClause() {
			return GetRuleContext<SegmentAttributesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitionsStoreInClauseContext partitionsStoreInClause() {
			return GetRuleContext<PartitionsStoreInClauseContext>(0);
		}
		public OverflowClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overflowClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOverflowClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOverflowClause(this);
		}
	}

	[RuleVersion(0)]
	public OverflowClauseContext overflowClause() {
		OverflowClauseContext _localctx = new OverflowClauseContext(Context, State);
		EnterRule(_localctx, 720, RULE_overflowClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4299;
			Match(OVERFLOW);
			State = 4301;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,388,Context) ) {
			case 1:
				{
				State = 4300;
				segmentAttributesClause();
				}
				break;
			}
			State = 4304;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,389,Context) ) {
			case 1:
				{
				State = 4303;
				partitionsStoreInClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IncludingOverflowClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDING() { return GetToken(OracleAntlrParser.INCLUDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public IncludingOverflowClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_includingOverflowClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIncludingOverflowClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIncludingOverflowClause(this);
		}
	}

	[RuleVersion(0)]
	public IncludingOverflowClauseContext includingOverflowClause() {
		IncludingOverflowClauseContext _localctx = new IncludingOverflowClauseContext(Context, State);
		EnterRule(_localctx, 722, RULE_includingOverflowClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4306;
			Match(INCLUDING);
			State = 4307;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PCTThresholdClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTTHRESHOLD() { return GetToken(OracleAntlrParser.PCTTHRESHOLD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public PCTThresholdClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pCTThresholdClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPCTThresholdClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPCTThresholdClause(this);
		}
	}

	[RuleVersion(0)]
	public PCTThresholdClauseContext pCTThresholdClause() {
		PCTThresholdClauseContext _localctx = new PCTThresholdClauseContext(Context, State);
		EnterRule(_localctx, 724, RULE_pCTThresholdClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4309;
			Match(PCTTHRESHOLD);
			State = 4310;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MappingTableClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAPPING() { return GetToken(OracleAntlrParser.MAPPING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMAPPING() { return GetToken(OracleAntlrParser.NOMAPPING, 0); }
		public MappingTableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mappingTableClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMappingTableClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMappingTableClause(this);
		}
	}

	[RuleVersion(0)]
	public MappingTableClauseContext mappingTableClause() {
		MappingTableClauseContext _localctx = new MappingTableClauseContext(Context, State);
		EnterRule(_localctx, 726, RULE_mappingTableClause);
		try {
			State = 4315;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MAPPING:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4312;
				Match(MAPPING);
				State = 4313;
				Match(TABLE);
				}
				break;
			case NOMAPPING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4314;
				Match(NOMAPPING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableCompressionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPRESS() { return GetToken(OracleAntlrParser.COMPRESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CompressionOperationsContext compressionOperations() {
			return GetRuleContext<CompressionOperationsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORE() { return GetToken(OracleAntlrParser.STORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BASIC() { return GetToken(OracleAntlrParser.BASIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADVANCED() { return GetToken(OracleAntlrParser.ADVANCED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMN() { return GetToken(OracleAntlrParser.COLUMN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEVEL() { return GetToken(OracleAntlrParser.LEVEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCKING() { return GetToken(OracleAntlrParser.LOCKING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUERY() { return GetToken(OracleAntlrParser.QUERY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARCHIVE() { return GetToken(OracleAntlrParser.ARCHIVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NO() { return GetToken(OracleAntlrParser.NO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOW() { return GetToken(OracleAntlrParser.LOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HIGH() { return GetToken(OracleAntlrParser.HIGH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCOMPRESS() { return GetToken(OracleAntlrParser.NOCOMPRESS, 0); }
		public TableCompressionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableCompressionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTableCompressionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTableCompressionClause(this);
		}
	}

	[RuleVersion(0)]
	public TableCompressionClauseContext tableCompressionClause() {
		TableCompressionClauseContext _localctx = new TableCompressionClauseContext(Context, State);
		EnterRule(_localctx, 728, RULE_tableCompressionClause);
		int _la;
		try {
			State = 4349;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPRESS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4317;
				Match(COMPRESS);
				State = 4319;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 4318;
					compressionOperations();
					}
				}

				State = 4322;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATE || _la==FALSE || _la==INTERVAL || _la==TIMESTAMP || _la==TRUE || ((((_la - 581)) & ~0x3f) == 0 && ((1L << (_la - 581)) & ((1L << (INTEGER_LITERAL - 581)) | (1L << (FLOATING_POINT_LITERAL - 581)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 581)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 581)) | (1L << (BINARY_STRING_LITERAL - 581)) | (1L << (CHARACTER_STRING_LITERAL - 581)) | (1L << (MONEY_LITERAL - 581)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 581)))) != 0)) {
					{
					State = 4321;
					literal();
					}
				}

				}
				break;
			case ROW:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4324;
				Match(ROW);
				State = 4325;
				Match(STORE);
				State = 4326;
				Match(COMPRESS);
				State = 4328;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ADVANCED || _la==BASIC) {
					{
					State = 4327;
					_la = TokenStream.LA(1);
					if ( !(_la==ADVANCED || _la==BASIC) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			case COLUMN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4330;
				Match(COLUMN);
				State = 4331;
				Match(STORE);
				State = 4332;
				Match(COMPRESS);
				State = 4338;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 4333;
					Match(FOR);
					State = 4334;
					_la = TokenStream.LA(1);
					if ( !(_la==ARCHIVE || _la==QUERY) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 4336;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==HIGH || _la==LOW) {
						{
						State = 4335;
						_la = TokenStream.LA(1);
						if ( !(_la==HIGH || _la==LOW) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
					}

					}
				}

				State = 4346;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,397,Context) ) {
				case 1:
					{
					State = 4341;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NO) {
						{
						State = 4340;
						Match(NO);
						}
					}

					State = 4343;
					Match(ROW);
					State = 4344;
					Match(LEVEL);
					State = 4345;
					Match(LOCKING);
					}
					break;
				}
				}
				break;
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4348;
				Match(NOCOMPRESS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexCompressionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPRESS() { return GetToken(OracleAntlrParser.COMPRESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADVANCED() { return GetToken(OracleAntlrParser.ADVANCED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOW() { return GetToken(OracleAntlrParser.LOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HIGH() { return GetToken(OracleAntlrParser.HIGH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCOMPRESS() { return GetToken(OracleAntlrParser.NOCOMPRESS, 0); }
		public IndexCompressionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexCompressionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexCompressionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexCompressionClause(this);
		}
	}

	[RuleVersion(0)]
	public IndexCompressionClauseContext indexCompressionClause() {
		IndexCompressionClauseContext _localctx = new IndexCompressionClauseContext(Context, State);
		EnterRule(_localctx, 730, RULE_indexCompressionClause);
		int _la;
		try {
			State = 4360;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPRESS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4351;
				Match(COMPRESS);
				State = 4357;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ADVANCED:
					{
					State = 4352;
					Match(ADVANCED);
					State = 4353;
					_la = TokenStream.LA(1);
					if ( !(_la==HIGH || _la==LOW) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				case Eof:
				case AS:
				case BUILD:
				case CACHE:
				case CASCADE:
				case CHECK:
				case CHUNK:
				case COLUMN:
				case COMPRESS:
				case COMPUTE:
				case CONSTRAINT:
				case DATE:
				case DECRYPT:
				case DEDUPLICATE:
				case DEFERRABLE:
				case DEFERRED:
				case DISABLE:
				case DROP:
				case ENABLE:
				case ENCRYPT:
				case EVALUATE:
				case EXCEPTIONS:
				case FALSE:
				case FILESYSTEM_LIKE_LOGGING:
				case FOREIGN:
				case FREEPOOLS:
				case GLOBAL:
				case IMMEDIATE:
				case INCLUDING:
				case INDEXING:
				case INITIALLY:
				case INITRANS:
				case INTERVAL:
				case INVISIBLE:
				case KEEP:
				case KEEP_DUPLICATES:
				case LOB:
				case LOCAL:
				case LOGGING:
				case MAPPING:
				case MAXTRANS:
				case MEMOPTIMIZE:
				case MONITORING:
				case NESTED:
				case NEVER:
				case NOCACHE:
				case NOCOMPRESS:
				case NOLOGGING:
				case NOMAPPING:
				case NOMONITORING:
				case NOPARALLEL:
				case NORELY:
				case NOROWDEPENDENCIES:
				case NOSORT:
				case NOT:
				case NOVALIDATE:
				case NULL:
				case ONLINE:
				case OVERFLOW:
				case PARALLEL:
				case PARENT:
				case PARTITION:
				case PCTFREE:
				case PCTTHRESHOLD:
				case PCTUSED:
				case PCTVERSION:
				case PRIMARY:
				case REFERENCES:
				case REFRESH:
				case RELY:
				case RETENTION:
				case REVERSE:
				case ROWDEPENDENCIES:
				case SORT:
				case STORAGE:
				case STORE:
				case TABLESPACE:
				case TIMESTAMP:
				case TRUE:
				case UNIQUE:
				case UNUSABLE:
				case USABLE:
				case USING:
				case VALIDATE:
				case VARRAY:
				case VISIBLE:
				case XMLTYPE:
				case INTEGER_LITERAL:
				case LPAREN:
				case RPAREN:
				case COMMA:
				case SEMI:
				case FSLASH:
				case FLOATING_POINT_LITERAL:
				case FLOATING_POINT_BINARY_LITERAL:
				case UNICODE_CHARACTER_STRING_LITERAL:
				case BINARY_STRING_LITERAL:
				case CHARACTER_STRING_LITERAL:
				case MONEY_LITERAL:
				case QUOTE_CHARACTER_STRING_LITERAL:
					{
					State = 4355;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATE || _la==FALSE || _la==INTERVAL || _la==TIMESTAMP || _la==TRUE || ((((_la - 581)) & ~0x3f) == 0 && ((1L << (_la - 581)) & ((1L << (INTEGER_LITERAL - 581)) | (1L << (FLOATING_POINT_LITERAL - 581)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 581)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 581)) | (1L << (BINARY_STRING_LITERAL - 581)) | (1L << (CHARACTER_STRING_LITERAL - 581)) | (1L << (MONEY_LITERAL - 581)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 581)))) != 0)) {
						{
						State = 4354;
						literal();
						}
					}

					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4359;
				Match(NOCOMPRESS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompressionOperationsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPERATIONS() { return GetToken(OracleAntlrParser.OPERATIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECT_LOAD() { return GetToken(OracleAntlrParser.DIRECT_LOAD, 0); }
		public CompressionOperationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compressionOperations; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCompressionOperations(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCompressionOperations(this);
		}
	}

	[RuleVersion(0)]
	public CompressionOperationsContext compressionOperations() {
		CompressionOperationsContext _localctx = new CompressionOperationsContext(Context, State);
		EnterRule(_localctx, 732, RULE_compressionOperations);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4362;
			Match(FOR);
			State = 4363;
			_la = TokenStream.LA(1);
			if ( !(_la==ALL || _la==DIRECT_LOAD) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4364;
			Match(OPERATIONS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SegmentAttributesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseElementContext[] segmentAttributesClauseElement() {
			return GetRuleContexts<SegmentAttributesClauseElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseElementContext segmentAttributesClauseElement(int i) {
			return GetRuleContext<SegmentAttributesClauseElementContext>(i);
		}
		public SegmentAttributesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_segmentAttributesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSegmentAttributesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSegmentAttributesClause(this);
		}
	}

	[RuleVersion(0)]
	public SegmentAttributesClauseContext segmentAttributesClause() {
		SegmentAttributesClauseContext _localctx = new SegmentAttributesClauseContext(Context, State);
		EnterRule(_localctx, 734, RULE_segmentAttributesClause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4367;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 4366;
					segmentAttributesClauseElement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4369;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,402,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SegmentAttributesClauseElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause() {
			return GetRuleContext<TablespaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause() {
			return GetRuleContext<LoggingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute() {
			return GetRuleContext<PhysicalAttributeContext>(0);
		}
		public SegmentAttributesClauseElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_segmentAttributesClauseElement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSegmentAttributesClauseElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSegmentAttributesClauseElement(this);
		}
	}

	[RuleVersion(0)]
	public SegmentAttributesClauseElementContext segmentAttributesClauseElement() {
		SegmentAttributesClauseElementContext _localctx = new SegmentAttributesClauseElementContext(Context, State);
		EnterRule(_localctx, 736, RULE_segmentAttributesClauseElement);
		try {
			State = 4374;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TABLESPACE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4371;
				tablespaceClause();
				}
				break;
			case FILESYSTEM_LIKE_LOGGING:
			case LOGGING:
			case NOLOGGING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4372;
				loggingClause();
				}
				break;
			case INITRANS:
			case MAXTRANS:
			case PCTFREE:
			case PCTUSED:
			case STORAGE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4373;
				physicalAttribute();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnCommitClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMIT() { return GetToken(OracleAntlrParser.COMMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWS() { return GetToken(OracleAntlrParser.ROWS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(OracleAntlrParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRESERVE() { return GetToken(OracleAntlrParser.PRESERVE, 0); }
		public OnCommitClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onCommitClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOnCommitClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOnCommitClause(this);
		}
	}

	[RuleVersion(0)]
	public OnCommitClauseContext onCommitClause() {
		OnCommitClauseContext _localctx = new OnCommitClauseContext(Context, State);
		EnterRule(_localctx, 738, RULE_onCommitClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4376;
			Match(ON);
			State = 4377;
			Match(COMMIT);
			State = 4378;
			_la = TokenStream.LA(1);
			if ( !(_la==DELETE || _la==PRESERVE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4379;
			Match(ROWS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelationPropertiesListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RelationPropertiesClauseContext[] relationPropertiesClause() {
			return GetRuleContexts<RelationPropertiesClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelationPropertiesClauseContext relationPropertiesClause(int i) {
			return GetRuleContext<RelationPropertiesClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public RelationPropertiesListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relationPropertiesListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRelationPropertiesListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRelationPropertiesListClause(this);
		}
	}

	[RuleVersion(0)]
	public RelationPropertiesListClauseContext relationPropertiesListClause() {
		RelationPropertiesListClauseContext _localctx = new RelationPropertiesListClauseContext(Context, State);
		EnterRule(_localctx, 740, RULE_relationPropertiesListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4381;
			Match(LPAREN);
			State = 4382;
			relationPropertiesClause();
			State = 4387;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4383;
				Match(COMMA);
				State = 4384;
				relationPropertiesClause();
				}
				}
				State = 4389;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4390;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelationPropertiesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TableRefConstraintClauseContext tableRefConstraintClause() {
			return GetRuleContext<TableRefConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableConstraintClauseContext tableConstraintClause() {
			return GetRuleContext<TableConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SupplementalLoggingPropsClauseContext supplementalLoggingPropsClause() {
			return GetRuleContext<SupplementalLoggingPropsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnDeclarationClauseContext columnDeclarationClause() {
			return GetRuleContext<ColumnDeclarationClauseContext>(0);
		}
		public RelationPropertiesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relationPropertiesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRelationPropertiesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRelationPropertiesClause(this);
		}
	}

	[RuleVersion(0)]
	public RelationPropertiesClauseContext relationPropertiesClause() {
		RelationPropertiesClauseContext _localctx = new RelationPropertiesClauseContext(Context, State);
		EnterRule(_localctx, 742, RULE_relationPropertiesClause);
		try {
			State = 4396;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,405,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4392;
				tableRefConstraintClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4393;
				tableConstraintClause();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4394;
				supplementalLoggingPropsClause();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4395;
				columnDeclarationClause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SupplementalLoggingPropsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUPPLEMENTAL() { return GetToken(OracleAntlrParser.SUPPLEMENTAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOG() { return GetToken(OracleAntlrParser.LOG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SupplementalLogGrpClauseContext supplementalLogGrpClause() {
			return GetRuleContext<SupplementalLogGrpClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SupplementalIdKeyClauseContext supplementalIdKeyClause() {
			return GetRuleContext<SupplementalIdKeyClauseContext>(0);
		}
		public SupplementalLoggingPropsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_supplementalLoggingPropsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSupplementalLoggingPropsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSupplementalLoggingPropsClause(this);
		}
	}

	[RuleVersion(0)]
	public SupplementalLoggingPropsClauseContext supplementalLoggingPropsClause() {
		SupplementalLoggingPropsClauseContext _localctx = new SupplementalLoggingPropsClauseContext(Context, State);
		EnterRule(_localctx, 744, RULE_supplementalLoggingPropsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4398;
			Match(SUPPLEMENTAL);
			State = 4399;
			Match(LOG);
			State = 4402;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case GROUP:
				{
				State = 4400;
				supplementalLogGrpClause();
				}
				break;
			case DATA:
				{
				State = 4401;
				supplementalIdKeyClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SupplementalLogGrpClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUP() { return GetToken(OracleAntlrParser.GROUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALWAYS() { return GetToken(OracleAntlrParser.ALWAYS, 0); }
		public SupplementalLogGrpClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_supplementalLogGrpClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSupplementalLogGrpClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSupplementalLogGrpClause(this);
		}
	}

	[RuleVersion(0)]
	public SupplementalLogGrpClauseContext supplementalLogGrpClause() {
		SupplementalLogGrpClauseContext _localctx = new SupplementalLogGrpClauseContext(Context, State);
		EnterRule(_localctx, 746, RULE_supplementalLogGrpClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4404;
			Match(GROUP);
			State = 4405;
			simpleIdentifierWithoutParentheses();
			State = 4406;
			columnListInParenElementClause();
			State = 4408;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALWAYS) {
				{
				State = 4407;
				Match(ALWAYS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SupplementalIdKeyClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATA() { return GetToken(OracleAntlrParser.DATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SupplementalIdKeyClauseItemContext[] supplementalIdKeyClauseItem() {
			return GetRuleContexts<SupplementalIdKeyClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SupplementalIdKeyClauseItemContext supplementalIdKeyClauseItem(int i) {
			return GetRuleContext<SupplementalIdKeyClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMNS() { return GetToken(OracleAntlrParser.COLUMNS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public SupplementalIdKeyClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_supplementalIdKeyClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSupplementalIdKeyClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSupplementalIdKeyClause(this);
		}
	}

	[RuleVersion(0)]
	public SupplementalIdKeyClauseContext supplementalIdKeyClause() {
		SupplementalIdKeyClauseContext _localctx = new SupplementalIdKeyClauseContext(Context, State);
		EnterRule(_localctx, 748, RULE_supplementalIdKeyClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4410;
			Match(DATA);
			State = 4411;
			Match(LPAREN);
			State = 4412;
			supplementalIdKeyClauseItem();
			State = 4417;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4413;
				Match(COMMA);
				State = 4414;
				supplementalIdKeyClauseItem();
				}
				}
				State = 4419;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4420;
			Match(RPAREN);
			State = 4421;
			Match(COLUMNS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SupplementalIdKeyClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIMARY() { return GetToken(OracleAntlrParser.PRIMARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(OracleAntlrParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUE() { return GetToken(OracleAntlrParser.UNIQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOREIGN() { return GetToken(OracleAntlrParser.FOREIGN, 0); }
		public SupplementalIdKeyClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_supplementalIdKeyClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSupplementalIdKeyClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSupplementalIdKeyClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public SupplementalIdKeyClauseItemContext supplementalIdKeyClauseItem() {
		SupplementalIdKeyClauseItemContext _localctx = new SupplementalIdKeyClauseItemContext(Context, State);
		EnterRule(_localctx, 750, RULE_supplementalIdKeyClauseItem);
		try {
			State = 4429;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4423;
				Match(ALL);
				}
				break;
			case PRIMARY:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4424;
				Match(PRIMARY);
				State = 4425;
				Match(KEY);
				}
				break;
			case UNIQUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4426;
				Match(UNIQUE);
				}
				break;
			case FOREIGN:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4427;
				Match(FOREIGN);
				State = 4428;
				Match(KEY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnDeclarationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SortNoSortClauseContext sortNoSortClause() {
			return GetRuleContext<SortNoSortClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnDefaultValueClauseContext columnDefaultValueClause() {
			return GetRuleContext<ColumnDefaultValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnIdentityClauseContext columnIdentityClause() {
			return GetRuleContext<ColumnIdentityClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VirtualColumnDefinitionContext virtualColumnDefinition() {
			return GetRuleContext<VirtualColumnDefinitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnRefConstraintClauseContext columnRefConstraintClause() {
			return GetRuleContext<ColumnRefConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext[] columnConstraintClause() {
			return GetRuleContexts<ColumnConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext columnConstraintClause(int i) {
			return GetRuleContext<ColumnConstraintClauseContext>(i);
		}
		public ColumnDeclarationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnDeclarationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterColumnDeclarationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitColumnDeclarationClause(this);
		}
	}

	[RuleVersion(0)]
	public ColumnDeclarationClauseContext columnDeclarationClause() {
		ColumnDeclarationClauseContext _localctx = new ColumnDeclarationClauseContext(Context, State);
		EnterRule(_localctx, 752, RULE_columnDeclarationClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4431;
			simpleIdentifierWithoutParentheses();
			State = 4432;
			typeReference();
			State = 4434;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOSORT || _la==SORT) {
				{
				State = 4433;
				sortNoSortClause();
				}
			}

			State = 4439;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,411,Context) ) {
			case 1:
				{
				State = 4436;
				columnDefaultValueClause();
				}
				break;
			case 2:
				{
				State = 4437;
				columnIdentityClause();
				}
				break;
			case 3:
				{
				State = 4438;
				virtualColumnDefinition();
				}
				break;
			}
			State = 4447;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,413,Context) ) {
			case 1:
				{
				State = 4441;
				columnRefConstraintClause();
				}
				break;
			case 2:
				{
				State = 4443;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 4442;
					columnConstraintClause();
					}
					}
					State = 4445;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==CHECK || _la==CONSTRAINT || _la==FOREIGN || ((((_la - 346)) & ~0x3f) == 0 && ((1L << (_la - 346)) & ((1L << (NOT - 346)) | (1L << (NULL - 346)) | (1L << (PRIMARY - 346)))) != 0) || _la==REFERENCES || _la==UNIQUE || _la==LPAREN );
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnIdentityClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GENERATED() { return GetToken(OracleAntlrParser.GENERATED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTITY() { return GetToken(OracleAntlrParser.IDENTITY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALWAYS() { return GetToken(OracleAntlrParser.ALWAYS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentityOptionContext[] identityOption() {
			return GetRuleContexts<IdentityOptionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentityOptionContext identityOption(int i) {
			return GetRuleContext<IdentityOptionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public ColumnIdentityClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnIdentityClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterColumnIdentityClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitColumnIdentityClause(this);
		}
	}

	[RuleVersion(0)]
	public ColumnIdentityClauseContext columnIdentityClause() {
		ColumnIdentityClauseContext _localctx = new ColumnIdentityClauseContext(Context, State);
		EnterRule(_localctx, 754, RULE_columnIdentityClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4449;
			Match(GENERATED);
			State = 4457;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALWAYS:
				{
				State = 4450;
				Match(ALWAYS);
				}
				break;
			case BY:
				{
				State = 4451;
				Match(BY);
				State = 4452;
				Match(DEFAULT);
				State = 4455;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ON) {
					{
					State = 4453;
					Match(ON);
					State = 4454;
					Match(NULL);
					}
				}

				}
				break;
			case AS:
				break;
			default:
				break;
			}
			State = 4459;
			Match(AS);
			State = 4460;
			Match(IDENTITY);
			State = 4475;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,418,Context) ) {
			case 1:
				{
				State = 4461;
				Match(LPAREN);
				State = 4465;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==CACHE || _la==CYCLE || _la==INCREMENT || _la==KEEP || ((((_la - 292)) & ~0x3f) == 0 && ((1L << (_la - 292)) & ((1L << (MAXVALUE - 292)) | (1L << (MINVALUE - 292)) | (1L << (NOCACHE - 292)) | (1L << (NOCYCLE - 292)) | (1L << (NOKEEP - 292)) | (1L << (NOMAXVALUE - 292)) | (1L << (NOMINVALUE - 292)) | (1L << (NOORDER - 292)) | (1L << (NOSCALE - 292)))) != 0) || _la==ORDER || _la==SCALE || _la==START) {
					{
					{
					State = 4462;
					identityOption();
					}
					}
					State = 4467;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4468;
				Match(RPAREN);
				}
				break;
			case 2:
				{
				State = 4472;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==CACHE || _la==CYCLE || _la==INCREMENT || _la==KEEP || ((((_la - 292)) & ~0x3f) == 0 && ((1L << (_la - 292)) & ((1L << (MAXVALUE - 292)) | (1L << (MINVALUE - 292)) | (1L << (NOCACHE - 292)) | (1L << (NOCYCLE - 292)) | (1L << (NOKEEP - 292)) | (1L << (NOMAXVALUE - 292)) | (1L << (NOMINVALUE - 292)) | (1L << (NOORDER - 292)) | (1L << (NOSCALE - 292)))) != 0) || _la==ORDER || _la==SCALE || _la==START) {
					{
					{
					State = 4469;
					identityOption();
					}
					}
					State = 4474;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnDefaultValueClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public ColumnDefaultValueClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnDefaultValueClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterColumnDefaultValueClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitColumnDefaultValueClause(this);
		}
	}

	[RuleVersion(0)]
	public ColumnDefaultValueClauseContext columnDefaultValueClause() {
		ColumnDefaultValueClauseContext _localctx = new ColumnDefaultValueClauseContext(Context, State);
		EnterRule(_localctx, 756, RULE_columnDefaultValueClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4477;
			Match(DEFAULT);
			State = 4480;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 4478;
				Match(ON);
				State = 4479;
				Match(NULL);
				}
			}

			State = 4482;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VirtualColumnDefinitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ComputedColumnExpressionContext computedColumnExpression() {
			return GetRuleContext<ComputedColumnExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GENERATED() { return GetToken(OracleAntlrParser.GENERATED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALWAYS() { return GetToken(OracleAntlrParser.ALWAYS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VIRTUAL() { return GetToken(OracleAntlrParser.VIRTUAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VisibilityClauseContext visibilityClause() {
			return GetRuleContext<VisibilityClauseContext>(0);
		}
		public VirtualColumnDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_virtualColumnDefinition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterVirtualColumnDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitVirtualColumnDefinition(this);
		}
	}

	[RuleVersion(0)]
	public VirtualColumnDefinitionContext virtualColumnDefinition() {
		VirtualColumnDefinitionContext _localctx = new VirtualColumnDefinitionContext(Context, State);
		EnterRule(_localctx, 758, RULE_virtualColumnDefinition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4486;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GENERATED) {
				{
				State = 4484;
				Match(GENERATED);
				State = 4485;
				Match(ALWAYS);
				}
			}

			State = 4488;
			Match(AS);
			State = 4489;
			Match(LPAREN);
			State = 4490;
			computedColumnExpression();
			State = 4491;
			Match(RPAREN);
			State = 4493;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==VIRTUAL) {
				{
				State = 4492;
				Match(VIRTUAL);
				}
			}

			State = 4496;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INVISIBLE || _la==VISIBLE) {
				{
				State = 4495;
				visibilityClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComputedColumnExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public ComputedColumnExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_computedColumnExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterComputedColumnExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitComputedColumnExpression(this);
		}
	}

	[RuleVersion(0)]
	public ComputedColumnExpressionContext computedColumnExpression() {
		ComputedColumnExpressionContext _localctx = new ComputedColumnExpressionContext(Context, State);
		EnterRule(_localctx, 760, RULE_computedColumnExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4498;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableRefConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TableRefWithRowidClauseContext tableRefWithRowidClause() {
			return GetRuleContext<TableRefWithRowidClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableRefForeignKeyClauseContext tableRefForeignKeyClause() {
			return GetRuleContext<TableRefForeignKeyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableRefScopeForClauseContext tableRefScopeForClause() {
			return GetRuleContext<TableRefScopeForClauseContext>(0);
		}
		public TableRefConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableRefConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTableRefConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTableRefConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public TableRefConstraintClauseContext tableRefConstraintClause() {
		TableRefConstraintClauseContext _localctx = new TableRefConstraintClauseContext(Context, State);
		EnterRule(_localctx, 762, RULE_tableRefConstraintClause);
		try {
			State = 4503;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case REF:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4500;
				tableRefWithRowidClause();
				}
				break;
			case CONSTRAINT:
			case FOREIGN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4501;
				tableRefForeignKeyClause();
				}
				break;
			case SCOPE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4502;
				tableRefScopeForClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableRefWithRowidClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REF() { return GetToken(OracleAntlrParser.REF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWID() { return GetToken(OracleAntlrParser.ROWID, 0); }
		public TableRefWithRowidClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableRefWithRowidClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTableRefWithRowidClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTableRefWithRowidClause(this);
		}
	}

	[RuleVersion(0)]
	public TableRefWithRowidClauseContext tableRefWithRowidClause() {
		TableRefWithRowidClauseContext _localctx = new TableRefWithRowidClauseContext(Context, State);
		EnterRule(_localctx, 764, RULE_tableRefWithRowidClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4505;
			Match(REF);
			State = 4506;
			columnListInParenElementClause();
			State = 4507;
			Match(WITH);
			State = 4508;
			Match(ROWID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableRefScopeForClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCOPE() { return GetToken(OracleAntlrParser.SCOPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public TableRefScopeForClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableRefScopeForClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTableRefScopeForClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTableRefScopeForClause(this);
		}
	}

	[RuleVersion(0)]
	public TableRefScopeForClauseContext tableRefScopeForClause() {
		TableRefScopeForClauseContext _localctx = new TableRefScopeForClauseContext(Context, State);
		EnterRule(_localctx, 766, RULE_tableRefScopeForClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4510;
			Match(SCOPE);
			State = 4511;
			Match(FOR);
			State = 4512;
			columnListInParenElementClause();
			State = 4513;
			Match(IS);
			State = 4514;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnRefConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintForeignKeyRefClauseContext constraintForeignKeyRefClause() {
			return GetRuleContext<ConstraintForeignKeyRefClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintNameClauseContext constraintNameClause() {
			return GetRuleContext<ConstraintNameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnDeleteActionClauseContext onDeleteActionClause() {
			return GetRuleContext<OnDeleteActionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintStateClauseContext constraintStateClause() {
			return GetRuleContext<ConstraintStateClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WithRowidClauseContext withRowidClause() {
			return GetRuleContext<WithRowidClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ScopeIsClauseContext scopeIsClause() {
			return GetRuleContext<ScopeIsClauseContext>(0);
		}
		public ColumnRefConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnRefConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterColumnRefConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitColumnRefConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public ColumnRefConstraintClauseContext columnRefConstraintClause() {
		ColumnRefConstraintClauseContext _localctx = new ColumnRefConstraintClauseContext(Context, State);
		EnterRule(_localctx, 768, RULE_columnRefConstraintClause);
		int _la;
		try {
			State = 4528;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CONSTRAINT:
			case REFERENCES:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4517;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 4516;
					constraintNameClause();
					}
				}

				State = 4519;
				constraintForeignKeyRefClause();
				State = 4521;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ON) {
					{
					State = 4520;
					onDeleteActionClause();
					}
				}

				State = 4524;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 120)) & ~0x3f) == 0 && ((1L << (_la - 120)) & ((1L << (DEFERRABLE - 120)) | (1L << (DISABLE - 120)) | (1L << (ENABLE - 120)) | (1L << (EXCEPTIONS - 120)))) != 0) || _la==INITIALLY || ((((_la - 340)) & ~0x3f) == 0 && ((1L << (_la - 340)) & ((1L << (NORELY - 340)) | (1L << (NOT - 340)) | (1L << (NOVALIDATE - 340)))) != 0) || _la==RELY || _la==USING || _la==VALIDATE) {
					{
					State = 4523;
					constraintStateClause();
					}
				}

				}
				break;
			case WITH:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4526;
				withRowidClause();
				}
				break;
			case SCOPE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4527;
				scopeIsClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithRowidClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWID() { return GetToken(OracleAntlrParser.ROWID, 0); }
		public WithRowidClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withRowidClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterWithRowidClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitWithRowidClause(this);
		}
	}

	[RuleVersion(0)]
	public WithRowidClauseContext withRowidClause() {
		WithRowidClauseContext _localctx = new WithRowidClauseContext(Context, State);
		EnterRule(_localctx, 770, RULE_withRowidClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4530;
			Match(WITH);
			State = 4531;
			Match(ROWID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScopeIsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCOPE() { return GetToken(OracleAntlrParser.SCOPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public ScopeIsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scopeIsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterScopeIsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitScopeIsClause(this);
		}
	}

	[RuleVersion(0)]
	public ScopeIsClauseContext scopeIsClause() {
		ScopeIsClauseContext _localctx = new ScopeIsClauseContext(Context, State);
		EnterRule(_localctx, 772, RULE_scopeIsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4533;
			Match(SCOPE);
			State = 4534;
			Match(IS);
			State = 4535;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForeignKeyClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOREIGN() { return GetToken(OracleAntlrParser.FOREIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(OracleAntlrParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public ForeignKeyClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_foreignKeyClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForeignKeyClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForeignKeyClause(this);
		}
	}

	[RuleVersion(0)]
	public ForeignKeyClauseContext foreignKeyClause() {
		ForeignKeyClauseContext _localctx = new ForeignKeyClauseContext(Context, State);
		EnterRule(_localctx, 774, RULE_foreignKeyClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4537;
			Match(FOREIGN);
			State = 4538;
			Match(KEY);
			State = 4539;
			columnListInParenElementClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableRefForeignKeyClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ForeignKeyClauseContext foreignKeyClause() {
			return GetRuleContext<ForeignKeyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintForeignKeyRefClauseContext constraintForeignKeyRefClause() {
			return GetRuleContext<ConstraintForeignKeyRefClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintNameClauseContext constraintNameClause() {
			return GetRuleContext<ConstraintNameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnDeleteActionClauseContext onDeleteActionClause() {
			return GetRuleContext<OnDeleteActionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintStateClauseContext constraintStateClause() {
			return GetRuleContext<ConstraintStateClauseContext>(0);
		}
		public TableRefForeignKeyClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableRefForeignKeyClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTableRefForeignKeyClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTableRefForeignKeyClause(this);
		}
	}

	[RuleVersion(0)]
	public TableRefForeignKeyClauseContext tableRefForeignKeyClause() {
		TableRefForeignKeyClauseContext _localctx = new TableRefForeignKeyClauseContext(Context, State);
		EnterRule(_localctx, 776, RULE_tableRefForeignKeyClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4542;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONSTRAINT) {
				{
				State = 4541;
				constraintNameClause();
				}
			}

			State = 4544;
			foreignKeyClause();
			State = 4545;
			constraintForeignKeyRefClause();
			State = 4547;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 4546;
				onDeleteActionClause();
				}
			}

			State = 4550;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 120)) & ~0x3f) == 0 && ((1L << (_la - 120)) & ((1L << (DEFERRABLE - 120)) | (1L << (DISABLE - 120)) | (1L << (ENABLE - 120)) | (1L << (EXCEPTIONS - 120)))) != 0) || _la==INITIALLY || ((((_la - 340)) & ~0x3f) == 0 && ((1L << (_la - 340)) & ((1L << (NORELY - 340)) | (1L << (NOT - 340)) | (1L << (NOVALIDATE - 340)))) != 0) || _la==RELY || _la==USING || _la==VALIDATE) {
				{
				State = 4549;
				constraintStateClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewHeaderContext materializedViewHeader() {
			return GetRuleContext<MaterializedViewHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ViewBodyContext viewBody() {
			return GetRuleContext<ViewBodyContext>(0);
		}
		public MaterializedViewStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewStatement(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewStatementContext materializedViewStatement() {
		MaterializedViewStatementContext _localctx = new MaterializedViewStatementContext(Context, State);
		EnterRule(_localctx, 778, RULE_materializedViewStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4552;
			materializedViewHeader();
			State = 4553;
			Match(AS);
			State = 4554;
			viewBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATERIALIZED() { return GetToken(OracleAntlrParser.MATERIALIZED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VIEW() { return GetToken(OracleAntlrParser.VIEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectMaterializedViewClauseContext objectMaterializedViewClause() {
			return GetRuleContext<ObjectMaterializedViewClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ViewAliasOrConstraintListContext viewAliasOrConstraintList() {
			return GetRuleContext<ViewAliasOrConstraintListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultCollationOptionContext defaultCollationOption() {
			return GetRuleContext<DefaultCollationOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewPrebuiltTableClauseContext materializedViewPrebuiltTableClause() {
			return GetRuleContext<MaterializedViewPrebuiltTableClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalPropertiesClauseContext physicalPropertiesClause() {
			return GetRuleContext<PhysicalPropertiesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewPropertiesContext materializedViewProperties() {
			return GetRuleContext<MaterializedViewPropertiesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewUsingIndexClauseContext materializedViewUsingIndexClause() {
			return GetRuleContext<MaterializedViewUsingIndexClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshClauseContext materializedViewRefreshClause() {
			return GetRuleContext<MaterializedViewRefreshClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EvaluationEditionClauseContext evaluationEditionClause() {
			return GetRuleContext<EvaluationEditionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewQueryComputationClauseContext materializedViewQueryComputationClause() {
			return GetRuleContext<MaterializedViewQueryComputationClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewQueryRewriteClauseContext materializedViewQueryRewriteClause() {
			return GetRuleContext<MaterializedViewQueryRewriteClauseContext>(0);
		}
		public MaterializedViewHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewHeader(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewHeaderContext materializedViewHeader() {
		MaterializedViewHeaderContext _localctx = new MaterializedViewHeaderContext(Context, State);
		EnterRule(_localctx, 780, RULE_materializedViewHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4556;
			Match(MATERIALIZED);
			State = 4557;
			Match(VIEW);
			State = 4558;
			plainIdentifier();
			State = 4560;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OF) {
				{
				State = 4559;
				objectMaterializedViewClause();
				}
			}

			State = 4563;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 4562;
				viewAliasOrConstraintList();
				}
			}

			State = 4566;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT) {
				{
				State = 4565;
				defaultCollationOption();
				}
			}

			State = 4572;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ON:
				{
				State = 4568;
				materializedViewPrebuiltTableClause();
				}
				break;
			case CLUSTER:
			case COLUMN:
			case COMPRESS:
			case FILESYSTEM_LIKE_LOGGING:
			case INITRANS:
			case LOGGING:
			case MAXTRANS:
			case NOCOMPRESS:
			case NOLOGGING:
			case ORGANIZATION:
			case PCTFREE:
			case PCTUSED:
			case ROW:
			case SEGMENT:
			case STORAGE:
			case TABLESPACE:
				{
				State = 4569;
				physicalPropertiesClause();
				State = 4570;
				materializedViewProperties();
				}
				break;
			case AS:
			case DISABLE:
			case ENABLE:
			case EVALUATE:
			case NEVER:
			case REFRESH:
			case USING:
				break;
			default:
				break;
			}
			State = 4575;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 4574;
				materializedViewUsingIndexClause();
				}
			}

			State = 4578;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NEVER || _la==REFRESH) {
				{
				State = 4577;
				materializedViewRefreshClause();
				}
			}

			State = 4581;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EVALUATE) {
				{
				State = 4580;
				evaluationEditionClause();
				}
			}

			State = 4584;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,438,Context) ) {
			case 1:
				{
				State = 4583;
				materializedViewQueryComputationClause();
				}
				break;
			}
			State = 4587;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DISABLE || _la==ENABLE) {
				{
				State = 4586;
				materializedViewQueryRewriteClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectMaterializedViewClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public ObjectMaterializedViewClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectMaterializedViewClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectMaterializedViewClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectMaterializedViewClause(this);
		}
	}

	[RuleVersion(0)]
	public ObjectMaterializedViewClauseContext objectMaterializedViewClause() {
		ObjectMaterializedViewClauseContext _localctx = new ObjectMaterializedViewClauseContext(Context, State);
		EnterRule(_localctx, 782, RULE_objectMaterializedViewClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4589;
			Match(OF);
			State = 4590;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewPrebuiltTableClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PREBUILT() { return GetToken(OracleAntlrParser.PREBUILT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REDUCED() { return GetToken(OracleAntlrParser.REDUCED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRECISION() { return GetToken(OracleAntlrParser.PRECISION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITHOUT() { return GetToken(OracleAntlrParser.WITHOUT, 0); }
		public MaterializedViewPrebuiltTableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewPrebuiltTableClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewPrebuiltTableClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewPrebuiltTableClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewPrebuiltTableClauseContext materializedViewPrebuiltTableClause() {
		MaterializedViewPrebuiltTableClauseContext _localctx = new MaterializedViewPrebuiltTableClauseContext(Context, State);
		EnterRule(_localctx, 784, RULE_materializedViewPrebuiltTableClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4592;
			Match(ON);
			State = 4593;
			Match(PREBUILT);
			State = 4594;
			Match(TABLE);
			State = 4598;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH || _la==WITHOUT) {
				{
				State = 4595;
				_la = TokenStream.LA(1);
				if ( !(_la==WITH || _la==WITHOUT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4596;
				Match(REDUCED);
				State = 4597;
				Match(PRECISION);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewPhysicalClusterPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLUSTER() { return GetToken(OracleAntlrParser.CLUSTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewPhysicalClusterColumnListContext materializedViewPhysicalClusterColumnList() {
			return GetRuleContext<MaterializedViewPhysicalClusterColumnListContext>(0);
		}
		public MaterializedViewPhysicalClusterPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewPhysicalClusterProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewPhysicalClusterProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewPhysicalClusterProperties(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewPhysicalClusterPropertiesContext materializedViewPhysicalClusterProperties() {
		MaterializedViewPhysicalClusterPropertiesContext _localctx = new MaterializedViewPhysicalClusterPropertiesContext(Context, State);
		EnterRule(_localctx, 786, RULE_materializedViewPhysicalClusterProperties);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4600;
			Match(CLUSTER);
			State = 4601;
			localSimpleIdentifierWithoutParentheses();
			State = 4602;
			materializedViewPhysicalClusterColumnList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewPhysicalClusterColumnListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext[] localSimpleIdentifierWithoutParentheses() {
			return GetRuleContexts<LocalSimpleIdentifierWithoutParenthesesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses(int i) {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(i);
		}
		public MaterializedViewPhysicalClusterColumnListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewPhysicalClusterColumnList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewPhysicalClusterColumnList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewPhysicalClusterColumnList(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewPhysicalClusterColumnListContext materializedViewPhysicalClusterColumnList() {
		MaterializedViewPhysicalClusterColumnListContext _localctx = new MaterializedViewPhysicalClusterColumnListContext(Context, State);
		EnterRule(_localctx, 788, RULE_materializedViewPhysicalClusterColumnList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4604;
			Match(LPAREN);
			State = 4606;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 4605;
				localSimpleIdentifierWithoutParentheses();
				}
				}
				State = 4608;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0) );
			State = 4610;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ColumnPropertiesContext columnProperties() {
			return GetRuleContext<ColumnPropertiesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartitioningDefinitionClauseContext partitioningDefinitionClause() {
			return GetRuleContext<PartitioningDefinitionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewPropertiesCacheClauseContext materializedViewPropertiesCacheClause() {
			return GetRuleContext<MaterializedViewPropertiesCacheClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewPropertiesBuildClauseContext materializedViewPropertiesBuildClause() {
			return GetRuleContext<MaterializedViewPropertiesBuildClauseContext>(0);
		}
		public MaterializedViewPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewProperties(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewProperties(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewPropertiesContext materializedViewProperties() {
		MaterializedViewPropertiesContext _localctx = new MaterializedViewPropertiesContext(Context, State);
		EnterRule(_localctx, 790, RULE_materializedViewProperties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4613;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLUMN || _la==LOB || _la==NESTED || _la==VARRAY || _la==XMLTYPE) {
				{
				State = 4612;
				columnProperties();
				}
			}

			State = 4616;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 4615;
				partitioningDefinitionClause();
				}
			}

			State = 4619;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CACHE || _la==NOCACHE) {
				{
				State = 4618;
				materializedViewPropertiesCacheClause();
				}
			}

			State = 4622;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOPARALLEL || _la==PARALLEL) {
				{
				State = 4621;
				parallelClause();
				}
			}

			State = 4625;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BUILD) {
				{
				State = 4624;
				materializedViewPropertiesBuildClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewPropertiesCacheClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CACHE() { return GetToken(OracleAntlrParser.CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCACHE() { return GetToken(OracleAntlrParser.NOCACHE, 0); }
		public MaterializedViewPropertiesCacheClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewPropertiesCacheClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewPropertiesCacheClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewPropertiesCacheClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewPropertiesCacheClauseContext materializedViewPropertiesCacheClause() {
		MaterializedViewPropertiesCacheClauseContext _localctx = new MaterializedViewPropertiesCacheClauseContext(Context, State);
		EnterRule(_localctx, 792, RULE_materializedViewPropertiesCacheClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4627;
			_la = TokenStream.LA(1);
			if ( !(_la==CACHE || _la==NOCACHE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewPropertiesBuildClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUILD() { return GetToken(OracleAntlrParser.BUILD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMEDIATE() { return GetToken(OracleAntlrParser.IMMEDIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFERRED() { return GetToken(OracleAntlrParser.DEFERRED, 0); }
		public MaterializedViewPropertiesBuildClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewPropertiesBuildClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewPropertiesBuildClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewPropertiesBuildClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewPropertiesBuildClauseContext materializedViewPropertiesBuildClause() {
		MaterializedViewPropertiesBuildClauseContext _localctx = new MaterializedViewPropertiesBuildClauseContext(Context, State);
		EnterRule(_localctx, 794, RULE_materializedViewPropertiesBuildClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4629;
			Match(BUILD);
			State = 4630;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFERRED || _la==IMMEDIATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewUsingIndexClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NO() { return GetToken(OracleAntlrParser.NO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewUsingIndexAttributesListClauseContext materializedViewUsingIndexAttributesListClause() {
			return GetRuleContext<MaterializedViewUsingIndexAttributesListClauseContext>(0);
		}
		public MaterializedViewUsingIndexClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewUsingIndexClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewUsingIndexClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewUsingIndexClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewUsingIndexClauseContext materializedViewUsingIndexClause() {
		MaterializedViewUsingIndexClauseContext _localctx = new MaterializedViewUsingIndexClauseContext(Context, State);
		EnterRule(_localctx, 796, RULE_materializedViewUsingIndexClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4632;
			Match(USING);
			State = 4639;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NO:
				{
				State = 4633;
				Match(NO);
				State = 4634;
				Match(INDEX);
				}
				break;
			case INDEX:
				{
				State = 4635;
				Match(INDEX);
				State = 4637;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INITRANS || _la==MAXTRANS || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
					{
					State = 4636;
					materializedViewUsingIndexAttributesListClause();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewUsingIndexAttributesListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext[] tablespaceClause() {
			return GetRuleContexts<TablespaceClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause(int i) {
			return GetRuleContext<TablespaceClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext[] physicalAttribute() {
			return GetRuleContexts<PhysicalAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute(int i) {
			return GetRuleContext<PhysicalAttributeContext>(i);
		}
		public MaterializedViewUsingIndexAttributesListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewUsingIndexAttributesListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewUsingIndexAttributesListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewUsingIndexAttributesListClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewUsingIndexAttributesListClauseContext materializedViewUsingIndexAttributesListClause() {
		MaterializedViewUsingIndexAttributesListClauseContext _localctx = new MaterializedViewUsingIndexAttributesListClauseContext(Context, State);
		EnterRule(_localctx, 798, RULE_materializedViewUsingIndexAttributesListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4643;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 4643;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TABLESPACE:
					{
					State = 4641;
					tablespaceClause();
					}
					break;
				case INITRANS:
				case MAXTRANS:
				case PCTFREE:
				case PCTUSED:
				case STORAGE:
					{
					State = 4642;
					physicalAttribute();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 4645;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==INITRANS || _la==MAXTRANS || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFRESH() { return GetToken(OracleAntlrParser.REFRESH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshOptionsContext materializedViewRefreshOptions() {
			return GetRuleContext<MaterializedViewRefreshOptionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEVER() { return GetToken(OracleAntlrParser.NEVER, 0); }
		public MaterializedViewRefreshClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshClauseContext materializedViewRefreshClause() {
		MaterializedViewRefreshClauseContext _localctx = new MaterializedViewRefreshClauseContext(Context, State);
		EnterRule(_localctx, 800, RULE_materializedViewRefreshClause);
		try {
			State = 4651;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case REFRESH:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4647;
				Match(REFRESH);
				State = 4648;
				materializedViewRefreshOptions();
				}
				break;
			case NEVER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4649;
				Match(NEVER);
				State = 4650;
				Match(REFRESH);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshOptionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshTypeContext[] materializedViewRefreshType() {
			return GetRuleContexts<MaterializedViewRefreshTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshTypeContext materializedViewRefreshType(int i) {
			return GetRuleContext<MaterializedViewRefreshTypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshTriggerContext[] materializedViewRefreshTrigger() {
			return GetRuleContexts<MaterializedViewRefreshTriggerContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshTriggerContext materializedViewRefreshTrigger(int i) {
			return GetRuleContext<MaterializedViewRefreshTriggerContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshScheduleContext[] materializedViewRefreshSchedule() {
			return GetRuleContexts<MaterializedViewRefreshScheduleContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshScheduleContext materializedViewRefreshSchedule(int i) {
			return GetRuleContext<MaterializedViewRefreshScheduleContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshRowIdentificationClauseContext[] materializedViewRefreshRowIdentificationClause() {
			return GetRuleContexts<MaterializedViewRefreshRowIdentificationClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshRowIdentificationClauseContext materializedViewRefreshRowIdentificationClause(int i) {
			return GetRuleContext<MaterializedViewRefreshRowIdentificationClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshRollbackSegmentClauseContext[] materializedViewRefreshRollbackSegmentClause() {
			return GetRuleContexts<MaterializedViewRefreshRollbackSegmentClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshRollbackSegmentClauseContext materializedViewRefreshRollbackSegmentClause(int i) {
			return GetRuleContext<MaterializedViewRefreshRollbackSegmentClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshUsingConstraintsContext[] materializedViewRefreshUsingConstraints() {
			return GetRuleContexts<MaterializedViewRefreshUsingConstraintsContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaterializedViewRefreshUsingConstraintsContext materializedViewRefreshUsingConstraints(int i) {
			return GetRuleContext<MaterializedViewRefreshUsingConstraintsContext>(i);
		}
		public MaterializedViewRefreshOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshOptions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshOptions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshOptions(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshOptionsContext materializedViewRefreshOptions() {
		MaterializedViewRefreshOptionsContext _localctx = new MaterializedViewRefreshOptionsContext(Context, State);
		EnterRule(_localctx, 802, RULE_materializedViewRefreshOptions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4659;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 4659;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,452,Context) ) {
				case 1:
					{
					State = 4653;
					materializedViewRefreshType();
					}
					break;
				case 2:
					{
					State = 4654;
					materializedViewRefreshTrigger();
					}
					break;
				case 3:
					{
					State = 4655;
					materializedViewRefreshSchedule();
					}
					break;
				case 4:
					{
					State = 4656;
					materializedViewRefreshRowIdentificationClause();
					}
					break;
				case 5:
					{
					State = 4657;
					materializedViewRefreshRollbackSegmentClause();
					}
					break;
				case 6:
					{
					State = 4658;
					materializedViewRefreshUsingConstraints();
					}
					break;
				}
				}
				State = 4661;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COMPLETE || _la==FAST || _la==FORCE || _la==NEXT || _la==ON || _la==START || _la==USING || _la==WITH );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FAST() { return GetToken(OracleAntlrParser.FAST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPLETE() { return GetToken(OracleAntlrParser.COMPLETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORCE() { return GetToken(OracleAntlrParser.FORCE, 0); }
		public MaterializedViewRefreshTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshType(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshTypeContext materializedViewRefreshType() {
		MaterializedViewRefreshTypeContext _localctx = new MaterializedViewRefreshTypeContext(Context, State);
		EnterRule(_localctx, 804, RULE_materializedViewRefreshType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4663;
			_la = TokenStream.LA(1);
			if ( !(_la==COMPLETE || _la==FAST || _la==FORCE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshTriggerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEMAND() { return GetToken(OracleAntlrParser.DEMAND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMIT() { return GetToken(OracleAntlrParser.COMMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATEMENT() { return GetToken(OracleAntlrParser.STATEMENT, 0); }
		public MaterializedViewRefreshTriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshTrigger; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshTrigger(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshTrigger(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshTriggerContext materializedViewRefreshTrigger() {
		MaterializedViewRefreshTriggerContext _localctx = new MaterializedViewRefreshTriggerContext(Context, State);
		EnterRule(_localctx, 806, RULE_materializedViewRefreshTrigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4665;
			Match(ON);
			State = 4666;
			_la = TokenStream.LA(1);
			if ( !(_la==COMMIT || _la==DEMAND || _la==STATEMENT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshScheduleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode START() { return GetToken(OracleAntlrParser.START, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEXT() { return GetToken(OracleAntlrParser.NEXT, 0); }
		public MaterializedViewRefreshScheduleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshSchedule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshSchedule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshSchedule(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshScheduleContext materializedViewRefreshSchedule() {
		MaterializedViewRefreshScheduleContext _localctx = new MaterializedViewRefreshScheduleContext(Context, State);
		EnterRule(_localctx, 808, RULE_materializedViewRefreshSchedule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4671;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case START:
				{
				State = 4668;
				Match(START);
				State = 4669;
				Match(WITH);
				}
				break;
			case NEXT:
				{
				State = 4670;
				Match(NEXT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 4673;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshRowIdentificationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIMARY() { return GetToken(OracleAntlrParser.PRIMARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(OracleAntlrParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWID() { return GetToken(OracleAntlrParser.ROWID, 0); }
		public MaterializedViewRefreshRowIdentificationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshRowIdentificationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshRowIdentificationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshRowIdentificationClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshRowIdentificationClauseContext materializedViewRefreshRowIdentificationClause() {
		MaterializedViewRefreshRowIdentificationClauseContext _localctx = new MaterializedViewRefreshRowIdentificationClauseContext(Context, State);
		EnterRule(_localctx, 810, RULE_materializedViewRefreshRowIdentificationClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4675;
			Match(WITH);
			State = 4679;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PRIMARY:
				{
				State = 4676;
				Match(PRIMARY);
				State = 4677;
				Match(KEY);
				}
				break;
			case ROWID:
				{
				State = 4678;
				Match(ROWID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshRollbackSegmentClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLLBACK() { return GetToken(OracleAntlrParser.ROLLBACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEGMENT() { return GetToken(OracleAntlrParser.SEGMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MASTER() { return GetToken(OracleAntlrParser.MASTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(OracleAntlrParser.LOCAL, 0); }
		public MaterializedViewRefreshRollbackSegmentClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshRollbackSegmentClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshRollbackSegmentClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshRollbackSegmentClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshRollbackSegmentClauseContext materializedViewRefreshRollbackSegmentClause() {
		MaterializedViewRefreshRollbackSegmentClauseContext _localctx = new MaterializedViewRefreshRollbackSegmentClauseContext(Context, State);
		EnterRule(_localctx, 812, RULE_materializedViewRefreshRollbackSegmentClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4681;
			Match(USING);
			State = 4694;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEFAULT:
				{
				State = 4682;
				Match(DEFAULT);
				State = 4684;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOCAL || _la==MASTER) {
					{
					State = 4683;
					_la = TokenStream.LA(1);
					if ( !(_la==LOCAL || _la==MASTER) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 4686;
				Match(ROLLBACK);
				State = 4687;
				Match(SEGMENT);
				}
				break;
			case LOCAL:
			case MASTER:
			case ROLLBACK:
				{
				State = 4689;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOCAL || _la==MASTER) {
					{
					State = 4688;
					_la = TokenStream.LA(1);
					if ( !(_la==LOCAL || _la==MASTER) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 4691;
				Match(ROLLBACK);
				State = 4692;
				Match(SEGMENT);
				State = 4693;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewRefreshUsingConstraintsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINTS() { return GetToken(OracleAntlrParser.CONSTRAINTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENFORCED() { return GetToken(OracleAntlrParser.ENFORCED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUSTED() { return GetToken(OracleAntlrParser.TRUSTED, 0); }
		public MaterializedViewRefreshUsingConstraintsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewRefreshUsingConstraints; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewRefreshUsingConstraints(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewRefreshUsingConstraints(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewRefreshUsingConstraintsContext materializedViewRefreshUsingConstraints() {
		MaterializedViewRefreshUsingConstraintsContext _localctx = new MaterializedViewRefreshUsingConstraintsContext(Context, State);
		EnterRule(_localctx, 814, RULE_materializedViewRefreshUsingConstraints);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4696;
			Match(USING);
			State = 4697;
			_la = TokenStream.LA(1);
			if ( !(_la==ENFORCED || _la==TRUSTED) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4698;
			Match(CONSTRAINTS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EvaluationEditionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EVALUATE() { return GetToken(OracleAntlrParser.EVALUATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(OracleAntlrParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITION() { return GetToken(OracleAntlrParser.EDITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public EvaluationEditionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_evaluationEditionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterEvaluationEditionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitEvaluationEditionClause(this);
		}
	}

	[RuleVersion(0)]
	public EvaluationEditionClauseContext evaluationEditionClause() {
		EvaluationEditionClauseContext _localctx = new EvaluationEditionClauseContext(Context, State);
		EnterRule(_localctx, 816, RULE_evaluationEditionClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4700;
			Match(EVALUATE);
			State = 4701;
			Match(USING);
			State = 4708;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT:
				{
				State = 4702;
				Match(CURRENT);
				State = 4703;
				Match(EDITION);
				}
				break;
			case EDITION:
				{
				State = 4704;
				Match(EDITION);
				State = 4705;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			case NULL:
				{
				State = 4706;
				Match(NULL);
				State = 4707;
				Match(EDITION);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewQueryComputationClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUERY() { return GetToken(OracleAntlrParser.QUERY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPUTATION() { return GetToken(OracleAntlrParser.COMPUTATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISABLE() { return GetToken(OracleAntlrParser.DISABLE, 0); }
		public MaterializedViewQueryComputationClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewQueryComputationClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewQueryComputationClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewQueryComputationClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewQueryComputationClauseContext materializedViewQueryComputationClause() {
		MaterializedViewQueryComputationClauseContext _localctx = new MaterializedViewQueryComputationClauseContext(Context, State);
		EnterRule(_localctx, 818, RULE_materializedViewQueryComputationClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4710;
			_la = TokenStream.LA(1);
			if ( !(_la==DISABLE || _la==ENABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4711;
			Match(ON);
			State = 4712;
			Match(QUERY);
			State = 4713;
			Match(COMPUTATION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaterializedViewQueryRewriteClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUERY() { return GetToken(OracleAntlrParser.QUERY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REWRITE() { return GetToken(OracleAntlrParser.REWRITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISABLE() { return GetToken(OracleAntlrParser.DISABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnusableEditionsBeforeClauseContext unusableEditionsBeforeClause() {
			return GetRuleContext<UnusableEditionsBeforeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnusableEditionsBeginningWithClauseContext unusableEditionsBeginningWithClause() {
			return GetRuleContext<UnusableEditionsBeginningWithClauseContext>(0);
		}
		public MaterializedViewQueryRewriteClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_materializedViewQueryRewriteClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaterializedViewQueryRewriteClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaterializedViewQueryRewriteClause(this);
		}
	}

	[RuleVersion(0)]
	public MaterializedViewQueryRewriteClauseContext materializedViewQueryRewriteClause() {
		MaterializedViewQueryRewriteClauseContext _localctx = new MaterializedViewQueryRewriteClauseContext(Context, State);
		EnterRule(_localctx, 820, RULE_materializedViewQueryRewriteClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4715;
			_la = TokenStream.LA(1);
			if ( !(_la==DISABLE || _la==ENABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4716;
			Match(QUERY);
			State = 4717;
			Match(REWRITE);
			State = 4719;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,460,Context) ) {
			case 1:
				{
				State = 4718;
				unusableEditionsBeforeClause();
				}
				break;
			}
			State = 4722;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNUSABLE) {
				{
				State = 4721;
				unusableEditionsBeginningWithClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnusableEditionsBeforeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEFORE() { return GetToken(OracleAntlrParser.BEFORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(OracleAntlrParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITION() { return GetToken(OracleAntlrParser.EDITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public UnusableEditionsBeforeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unusableEditionsBeforeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUnusableEditionsBeforeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUnusableEditionsBeforeClause(this);
		}
	}

	[RuleVersion(0)]
	public UnusableEditionsBeforeClauseContext unusableEditionsBeforeClause() {
		UnusableEditionsBeforeClauseContext _localctx = new UnusableEditionsBeforeClauseContext(Context, State);
		EnterRule(_localctx, 822, RULE_unusableEditionsBeforeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4724;
			Match(UNUSABLE);
			State = 4725;
			Match(BEFORE);
			State = 4730;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT:
				{
				State = 4726;
				Match(CURRENT);
				State = 4727;
				Match(EDITION);
				}
				break;
			case EDITION:
				{
				State = 4728;
				Match(EDITION);
				State = 4729;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnusableEditionsBeginningWithClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEGINNING() { return GetToken(OracleAntlrParser.BEGINNING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(OracleAntlrParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITION() { return GetToken(OracleAntlrParser.EDITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public UnusableEditionsBeginningWithClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unusableEditionsBeginningWithClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUnusableEditionsBeginningWithClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUnusableEditionsBeginningWithClause(this);
		}
	}

	[RuleVersion(0)]
	public UnusableEditionsBeginningWithClauseContext unusableEditionsBeginningWithClause() {
		UnusableEditionsBeginningWithClauseContext _localctx = new UnusableEditionsBeginningWithClauseContext(Context, State);
		EnterRule(_localctx, 824, RULE_unusableEditionsBeginningWithClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4732;
			Match(UNUSABLE);
			State = 4733;
			Match(BEGINNING);
			State = 4734;
			Match(WITH);
			State = 4741;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT:
				{
				State = 4735;
				Match(CURRENT);
				State = 4736;
				Match(EDITION);
				}
				break;
			case EDITION:
				{
				State = 4737;
				Match(EDITION);
				State = 4738;
				localSimpleIdentifierWithoutParentheses();
				}
				break;
			case NULL:
				{
				State = 4739;
				Match(NULL);
				State = 4740;
				Match(EDITION);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ViewHeaderContext viewHeader() {
			return GetRuleContext<ViewHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ViewBodyContext viewBody() {
			return GetRuleContext<ViewBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForceNoForceClauseContext forceNoForceClause() {
			return GetRuleContext<ForceNoForceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EditionOptionClauseContext editionOptionClause() {
			return GetRuleContext<EditionOptionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDITIONING() { return GetToken(OracleAntlrParser.EDITIONING, 0); }
		public ViewStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterViewStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitViewStatement(this);
		}
	}

	[RuleVersion(0)]
	public ViewStatementContext viewStatement() {
		ViewStatementContext _localctx = new ViewStatementContext(Context, State);
		EnterRule(_localctx, 826, RULE_viewStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4744;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FORCE || _la==NO) {
				{
				State = 4743;
				forceNoForceClause();
				}
			}

			State = 4747;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EDITIONABLE || _la==NONEDITIONABLE) {
				{
				State = 4746;
				editionOptionClause();
				}
			}

			State = 4750;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EDITIONING) {
				{
				State = 4749;
				Match(EDITIONING);
				}
			}

			State = 4752;
			viewHeader();
			State = 4753;
			viewBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VIEW() { return GetToken(OracleAntlrParser.VIEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ViewAliasOrConstraintListContext viewAliasOrConstraintList() {
			return GetRuleContext<ViewAliasOrConstraintListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeViewClauseContext xmlTypeViewClause() {
			return GetRuleContext<XmlTypeViewClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectViewClauseContext objectViewClause() {
			return GetRuleContext<ObjectViewClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultCollationOptionContext defaultCollationOption() {
			return GetRuleContext<DefaultCollationOptionContext>(0);
		}
		public ViewHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterViewHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitViewHeader(this);
		}
	}

	[RuleVersion(0)]
	public ViewHeaderContext viewHeader() {
		ViewHeaderContext _localctx = new ViewHeaderContext(Context, State);
		EnterRule(_localctx, 828, RULE_viewHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4755;
			Match(VIEW);
			State = 4756;
			plainIdentifier();
			State = 4760;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,467,Context) ) {
			case 1:
				{
				State = 4757;
				viewAliasOrConstraintList();
				}
				break;
			case 2:
				{
				State = 4758;
				xmlTypeViewClause();
				}
				break;
			case 3:
				{
				State = 4759;
				objectViewClause();
				}
				break;
			}
			State = 4763;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT) {
				{
				State = 4762;
				defaultCollationOption();
				}
			}

			State = 4765;
			Match(AS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTypeViewClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLTYPE() { return GetToken(OracleAntlrParser.XMLTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlSchemaSpecContext xmlSchemaSpec() {
			return GetRuleContext<XmlSchemaSpecContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WithObjectIdentifierClauseContext withObjectIdentifierClause() {
			return GetRuleContext<WithObjectIdentifierClauseContext>(0);
		}
		public XmlTypeViewClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTypeViewClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlTypeViewClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlTypeViewClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlTypeViewClauseContext xmlTypeViewClause() {
		XmlTypeViewClauseContext _localctx = new XmlTypeViewClauseContext(Context, State);
		EnterRule(_localctx, 830, RULE_xmlTypeViewClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4767;
			Match(OF);
			State = 4768;
			Match(XMLTYPE);
			State = 4769;
			xmlSchemaSpec();
			State = 4770;
			withObjectIdentifierClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlSchemaSpecContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public XmlSchemaClauseContext xmlSchemaClause() {
			return GetRuleContext<XmlSchemaClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlSchemaElementClauseContext xmlSchemaElementClause() {
			return GetRuleContext<XmlSchemaElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTypeStoreAllClauseContext xmlTypeStoreAllClause() {
			return GetRuleContext<XmlTypeStoreAllClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlSchemaSpecNonschemaClauseContext xmlSchemaSpecNonschemaClause() {
			return GetRuleContext<XmlSchemaSpecNonschemaClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlSchemaSpecAnyschemaClauseContext xmlSchemaSpecAnyschemaClause() {
			return GetRuleContext<XmlSchemaSpecAnyschemaClauseContext>(0);
		}
		public XmlSchemaSpecContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlSchemaSpec; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlSchemaSpec(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlSchemaSpec(this);
		}
	}

	[RuleVersion(0)]
	public XmlSchemaSpecContext xmlSchemaSpec() {
		XmlSchemaSpecContext _localctx = new XmlSchemaSpecContext(Context, State);
		EnterRule(_localctx, 832, RULE_xmlSchemaSpec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4773;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==XMLSCHEMA) {
				{
				State = 4772;
				xmlSchemaClause();
				}
			}

			State = 4776;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELEMENT) {
				{
				State = 4775;
				xmlSchemaElementClause();
				}
			}

			State = 4779;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STORE) {
				{
				State = 4778;
				xmlTypeStoreAllClause();
				}
			}

			State = 4782;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,472,Context) ) {
			case 1:
				{
				State = 4781;
				xmlSchemaSpecNonschemaClause();
				}
				break;
			}
			State = 4785;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALLOW || _la==DISALLOW) {
				{
				State = 4784;
				xmlSchemaSpecAnyschemaClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlSchemaClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLSCHEMA() { return GetToken(OracleAntlrParser.XMLSCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public XmlSchemaClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlSchemaClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlSchemaClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlSchemaClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlSchemaClauseContext xmlSchemaClause() {
		XmlSchemaClauseContext _localctx = new XmlSchemaClauseContext(Context, State);
		EnterRule(_localctx, 834, RULE_xmlSchemaClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4787;
			Match(XMLSCHEMA);
			State = 4788;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlSchemaElementClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELEMENT() { return GetToken(OracleAntlrParser.ELEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext[] localSimpleIdentifierWithoutParentheses() {
			return GetRuleContexts<LocalSimpleIdentifierWithoutParenthesesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses(int i) {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POUND_SIGN() { return GetToken(OracleAntlrParser.POUND_SIGN, 0); }
		public XmlSchemaElementClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlSchemaElementClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlSchemaElementClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlSchemaElementClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlSchemaElementClauseContext xmlSchemaElementClause() {
		XmlSchemaElementClauseContext _localctx = new XmlSchemaElementClauseContext(Context, State);
		EnterRule(_localctx, 836, RULE_xmlSchemaElementClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4790;
			Match(ELEMENT);
			State = 4791;
			localSimpleIdentifierWithoutParentheses();
			State = 4794;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==POUND_SIGN) {
				{
				State = 4792;
				Match(POUND_SIGN);
				State = 4793;
				localSimpleIdentifierWithoutParentheses();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlSchemaSpecNonschemaClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONSCHEMA() { return GetToken(OracleAntlrParser.NONSCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALLOW() { return GetToken(OracleAntlrParser.ALLOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISALLOW() { return GetToken(OracleAntlrParser.DISALLOW, 0); }
		public XmlSchemaSpecNonschemaClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlSchemaSpecNonschemaClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlSchemaSpecNonschemaClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlSchemaSpecNonschemaClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlSchemaSpecNonschemaClauseContext xmlSchemaSpecNonschemaClause() {
		XmlSchemaSpecNonschemaClauseContext _localctx = new XmlSchemaSpecNonschemaClauseContext(Context, State);
		EnterRule(_localctx, 838, RULE_xmlSchemaSpecNonschemaClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4796;
			_la = TokenStream.LA(1);
			if ( !(_la==ALLOW || _la==DISALLOW) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4797;
			Match(NONSCHEMA);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlSchemaSpecAnyschemaClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANYSCHEMA() { return GetToken(OracleAntlrParser.ANYSCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALLOW() { return GetToken(OracleAntlrParser.ALLOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISALLOW() { return GetToken(OracleAntlrParser.DISALLOW, 0); }
		public XmlSchemaSpecAnyschemaClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlSchemaSpecAnyschemaClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlSchemaSpecAnyschemaClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlSchemaSpecAnyschemaClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlSchemaSpecAnyschemaClauseContext xmlSchemaSpecAnyschemaClause() {
		XmlSchemaSpecAnyschemaClauseContext _localctx = new XmlSchemaSpecAnyschemaClauseContext(Context, State);
		EnterRule(_localctx, 840, RULE_xmlSchemaSpecAnyschemaClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4799;
			_la = TokenStream.LA(1);
			if ( !(_la==ALLOW || _la==DISALLOW) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4800;
			Match(ANYSCHEMA);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectViewClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WithObjectIdentifierClauseContext withObjectIdentifierClause() {
			return GetRuleContext<WithObjectIdentifierClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnderClauseContext underClause() {
			return GetRuleContext<UnderClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AttributeOrConstraintListContext attributeOrConstraintList() {
			return GetRuleContext<AttributeOrConstraintListContext>(0);
		}
		public ObjectViewClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectViewClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectViewClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectViewClause(this);
		}
	}

	[RuleVersion(0)]
	public ObjectViewClauseContext objectViewClause() {
		ObjectViewClauseContext _localctx = new ObjectViewClauseContext(Context, State);
		EnterRule(_localctx, 842, RULE_objectViewClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4802;
			Match(OF);
			State = 4803;
			plainIdentifier();
			State = 4806;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WITH:
				{
				State = 4804;
				withObjectIdentifierClause();
				}
				break;
			case UNDER:
				{
				State = 4805;
				underClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 4809;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 4808;
				attributeOrConstraintList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnderClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNDER() { return GetToken(OracleAntlrParser.UNDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public UnderClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_underClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUnderClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUnderClause(this);
		}
	}

	[RuleVersion(0)]
	public UnderClauseContext underClause() {
		UnderClauseContext _localctx = new UnderClauseContext(Context, State);
		EnterRule(_localctx, 844, RULE_underClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4811;
			Match(UNDER);
			State = 4812;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithObjectIdentifierClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(OracleAntlrParser.OBJECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(OracleAntlrParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OID() { return GetToken(OracleAntlrParser.OID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParenthesizedExpressionListContext parenthesizedExpressionList() {
			return GetRuleContext<ParenthesizedExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		public WithObjectIdentifierClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withObjectIdentifierClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterWithObjectIdentifierClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitWithObjectIdentifierClause(this);
		}
	}

	[RuleVersion(0)]
	public WithObjectIdentifierClauseContext withObjectIdentifierClause() {
		WithObjectIdentifierClauseContext _localctx = new WithObjectIdentifierClauseContext(Context, State);
		EnterRule(_localctx, 846, RULE_withObjectIdentifierClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4814;
			Match(WITH);
			State = 4815;
			Match(OBJECT);
			State = 4816;
			_la = TokenStream.LA(1);
			if ( !(_la==IDENTIFIER || _la==OID) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4819;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				{
				State = 4817;
				parenthesizedExpressionList();
				}
				break;
			case DEFAULT:
				{
				State = 4818;
				Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParenthesizedExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public ParenthesizedExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parenthesizedExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterParenthesizedExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitParenthesizedExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public ParenthesizedExpressionListContext parenthesizedExpressionList() {
		ParenthesizedExpressionListContext _localctx = new ParenthesizedExpressionListContext(Context, State);
		EnterRule(_localctx, 848, RULE_parenthesizedExpressionList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4821;
			Match(LPAREN);
			State = 4822;
			expressionList();
			State = 4823;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForceNoForceClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORCE() { return GetToken(OracleAntlrParser.FORCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NO() { return GetToken(OracleAntlrParser.NO, 0); }
		public ForceNoForceClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forceNoForceClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForceNoForceClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForceNoForceClause(this);
		}
	}

	[RuleVersion(0)]
	public ForceNoForceClauseContext forceNoForceClause() {
		ForceNoForceClauseContext _localctx = new ForceNoForceClauseContext(Context, State);
		EnterRule(_localctx, 850, RULE_forceNoForceClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4826;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NO) {
				{
				State = 4825;
				Match(NO);
				}
			}

			State = 4828;
			Match(FORCE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ViewBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterViewBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitViewBody(this);
		}
	}

	[RuleVersion(0)]
	public ViewBodyContext viewBody() {
		ViewBodyContext _localctx = new ViewBodyContext(Context, State);
		EnterRule(_localctx, 852, RULE_viewBody);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4830;
			selectStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryRestrictionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public WithCheckOptionContext withCheckOption() {
			return GetRuleContext<WithCheckOptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WithReadOnlyContext withReadOnly() {
			return GetRuleContext<WithReadOnlyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintNameClauseContext constraintNameClause() {
			return GetRuleContext<ConstraintNameClauseContext>(0);
		}
		public SubqueryRestrictionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryRestrictionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubqueryRestrictionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubqueryRestrictionClause(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryRestrictionClauseContext subqueryRestrictionClause() {
		SubqueryRestrictionClauseContext _localctx = new SubqueryRestrictionClauseContext(Context, State);
		EnterRule(_localctx, 854, RULE_subqueryRestrictionClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4832;
			Match(WITH);
			State = 4835;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CHECK:
				{
				State = 4833;
				withCheckOption();
				}
				break;
			case READ:
				{
				State = 4834;
				withReadOnly();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 4838;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONSTRAINT) {
				{
				State = 4837;
				constraintNameClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewAliasOrConstraintListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ViewAliasOrTableConstraintContext[] viewAliasOrTableConstraint() {
			return GetRuleContexts<ViewAliasOrTableConstraintContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ViewAliasOrTableConstraintContext viewAliasOrTableConstraint(int i) {
			return GetRuleContext<ViewAliasOrTableConstraintContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ViewAliasOrConstraintListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewAliasOrConstraintList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterViewAliasOrConstraintList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitViewAliasOrConstraintList(this);
		}
	}

	[RuleVersion(0)]
	public ViewAliasOrConstraintListContext viewAliasOrConstraintList() {
		ViewAliasOrConstraintListContext _localctx = new ViewAliasOrConstraintListContext(Context, State);
		EnterRule(_localctx, 856, RULE_viewAliasOrConstraintList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4840;
			Match(LPAREN);
			State = 4841;
			viewAliasOrTableConstraint();
			State = 4846;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4842;
				Match(COMMA);
				State = 4843;
				viewAliasOrTableConstraint();
				}
				}
				State = 4848;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4849;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewAliasOrTableConstraintContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ViewAliasContext viewAlias() {
			return GetRuleContext<ViewAliasContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableConstraintClauseContext tableConstraintClause() {
			return GetRuleContext<TableConstraintClauseContext>(0);
		}
		public ViewAliasOrTableConstraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewAliasOrTableConstraint; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterViewAliasOrTableConstraint(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitViewAliasOrTableConstraint(this);
		}
	}

	[RuleVersion(0)]
	public ViewAliasOrTableConstraintContext viewAliasOrTableConstraint() {
		ViewAliasOrTableConstraintContext _localctx = new ViewAliasOrTableConstraintContext(Context, State);
		EnterRule(_localctx, 858, RULE_viewAliasOrTableConstraint);
		try {
			State = 4853;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,482,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4851;
				viewAlias();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4852;
				tableConstraintClause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewAliasContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext[] columnConstraintClause() {
			return GetRuleContexts<ColumnConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext columnConstraintClause(int i) {
			return GetRuleContext<ColumnConstraintClauseContext>(i);
		}
		public ViewAliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewAlias; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterViewAlias(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitViewAlias(this);
		}
	}

	[RuleVersion(0)]
	public ViewAliasContext viewAlias() {
		ViewAliasContext _localctx = new ViewAliasContext(Context, State);
		EnterRule(_localctx, 860, RULE_viewAlias);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4855;
			plainIdentifier();
			State = 4859;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==CHECK || _la==CONSTRAINT || _la==FOREIGN || ((((_la - 346)) & ~0x3f) == 0 && ((1L << (_la - 346)) & ((1L << (NOT - 346)) | (1L << (NULL - 346)) | (1L << (PRIMARY - 346)))) != 0) || _la==REFERENCES || _la==UNIQUE || _la==LPAREN) {
				{
				{
				State = 4856;
				columnConstraintClause();
				}
				}
				State = 4861;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AttributeOrConstraintListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AttributeOrTableConstraintContext[] attributeOrTableConstraint() {
			return GetRuleContexts<AttributeOrTableConstraintContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AttributeOrTableConstraintContext attributeOrTableConstraint(int i) {
			return GetRuleContext<AttributeOrTableConstraintContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public AttributeOrConstraintListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attributeOrConstraintList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAttributeOrConstraintList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAttributeOrConstraintList(this);
		}
	}

	[RuleVersion(0)]
	public AttributeOrConstraintListContext attributeOrConstraintList() {
		AttributeOrConstraintListContext _localctx = new AttributeOrConstraintListContext(Context, State);
		EnterRule(_localctx, 862, RULE_attributeOrConstraintList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4862;
			Match(LPAREN);
			State = 4863;
			attributeOrTableConstraint();
			State = 4868;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4864;
				Match(COMMA);
				State = 4865;
				attributeOrTableConstraint();
				}
				}
				State = 4870;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4871;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AttributeOrTableConstraintContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AttributeConstraintClauseContext attributeConstraintClause() {
			return GetRuleContext<AttributeConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableConstraintClauseContext tableConstraintClause() {
			return GetRuleContext<TableConstraintClauseContext>(0);
		}
		public AttributeOrTableConstraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attributeOrTableConstraint; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAttributeOrTableConstraint(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAttributeOrTableConstraint(this);
		}
	}

	[RuleVersion(0)]
	public AttributeOrTableConstraintContext attributeOrTableConstraint() {
		AttributeOrTableConstraintContext _localctx = new AttributeOrTableConstraintContext(Context, State);
		EnterRule(_localctx, 864, RULE_attributeOrTableConstraint);
		try {
			State = 4875;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,485,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4873;
				attributeConstraintClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4874;
				tableConstraintClause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AttributeConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext[] columnConstraintClause() {
			return GetRuleContexts<ColumnConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnConstraintClauseContext columnConstraintClause(int i) {
			return GetRuleContext<ColumnConstraintClauseContext>(i);
		}
		public AttributeConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attributeConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAttributeConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAttributeConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public AttributeConstraintClauseContext attributeConstraintClause() {
		AttributeConstraintClauseContext _localctx = new AttributeConstraintClauseContext(Context, State);
		EnterRule(_localctx, 866, RULE_attributeConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4877;
			identifier();
			State = 4879;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 4878;
				columnConstraintClause();
				}
				}
				State = 4881;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==CHECK || _la==CONSTRAINT || _la==FOREIGN || ((((_la - 346)) & ~0x3f) == 0 && ((1L << (_la - 346)) & ((1L << (NOT - 346)) | (1L << (NULL - 346)) | (1L << (PRIMARY - 346)))) != 0) || _la==REFERENCES || _la==UNIQUE || _la==LPAREN );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintUniqueClauseContext constraintUniqueClause() {
			return GetRuleContext<ConstraintUniqueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintPrimaryKeyClauseContext constraintPrimaryKeyClause() {
			return GetRuleContext<ConstraintPrimaryKeyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintForeignKeyClauseContext constraintForeignKeyClause() {
			return GetRuleContext<ConstraintForeignKeyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintCheckClauseContext constraintCheckClause() {
			return GetRuleContext<ConstraintCheckClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintNameClauseContext constraintNameClause() {
			return GetRuleContext<ConstraintNameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintStateClauseContext constraintStateClause() {
			return GetRuleContext<ConstraintStateClauseContext>(0);
		}
		public TableConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTableConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTableConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public TableConstraintClauseContext tableConstraintClause() {
		TableConstraintClauseContext _localctx = new TableConstraintClauseContext(Context, State);
		EnterRule(_localctx, 868, RULE_tableConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4884;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONSTRAINT) {
				{
				State = 4883;
				constraintNameClause();
				}
			}

			State = 4890;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNIQUE:
				{
				State = 4886;
				constraintUniqueClause();
				}
				break;
			case PRIMARY:
				{
				State = 4887;
				constraintPrimaryKeyClause();
				}
				break;
			case FOREIGN:
			case REFERENCES:
			case LPAREN:
				{
				State = 4888;
				constraintForeignKeyClause();
				}
				break;
			case CHECK:
				{
				State = 4889;
				constraintCheckClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 4893;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 120)) & ~0x3f) == 0 && ((1L << (_la - 120)) & ((1L << (DEFERRABLE - 120)) | (1L << (DISABLE - 120)) | (1L << (ENABLE - 120)) | (1L << (EXCEPTIONS - 120)))) != 0) || _la==INITIALLY || ((((_la - 340)) & ~0x3f) == 0 && ((1L << (_la - 340)) & ((1L << (NORELY - 340)) | (1L << (NOT - 340)) | (1L << (NOVALIDATE - 340)))) != 0) || _la==RELY || _la==USING || _la==VALIDATE) {
				{
				State = 4892;
				constraintStateClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnListInParenElementClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ComplexColumnListItemContext[] complexColumnListItem() {
			return GetRuleContexts<ComplexColumnListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComplexColumnListItemContext complexColumnListItem(int i) {
			return GetRuleContext<ComplexColumnListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext[] columnListItem() {
			return GetRuleContexts<ColumnListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListItemContext columnListItem(int i) {
			return GetRuleContext<ColumnListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ColumnListInParenElementClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnListInParenElementClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterColumnListInParenElementClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitColumnListInParenElementClause(this);
		}
	}

	[RuleVersion(0)]
	public ColumnListInParenElementClauseContext columnListInParenElementClause() {
		ColumnListInParenElementClauseContext _localctx = new ColumnListInParenElementClauseContext(Context, State);
		EnterRule(_localctx, 870, RULE_columnListInParenElementClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4895;
			Match(LPAREN);
			State = 4898;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,490,Context) ) {
			case 1:
				{
				State = 4896;
				complexColumnListItem();
				}
				break;
			case 2:
				{
				State = 4897;
				columnListItem();
				}
				break;
			}
			State = 4907;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4900;
				Match(COMMA);
				State = 4903;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,491,Context) ) {
				case 1:
					{
					State = 4901;
					complexColumnListItem();
					}
					break;
				case 2:
					{
					State = 4902;
					columnListItem();
					}
					break;
				}
				}
				}
				State = 4909;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4910;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintNullNotNullClauseContext constraintNullNotNullClause() {
			return GetRuleContext<ConstraintNullNotNullClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintUniqueClauseContext constraintUniqueClause() {
			return GetRuleContext<ConstraintUniqueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintPrimaryKeyClauseContext constraintPrimaryKeyClause() {
			return GetRuleContext<ConstraintPrimaryKeyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintForeignKeyClauseContext constraintForeignKeyClause() {
			return GetRuleContext<ConstraintForeignKeyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintCheckClauseContext constraintCheckClause() {
			return GetRuleContext<ConstraintCheckClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintNameClauseContext constraintNameClause() {
			return GetRuleContext<ConstraintNameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintStateClauseContext constraintStateClause() {
			return GetRuleContext<ConstraintStateClauseContext>(0);
		}
		public ColumnConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterColumnConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitColumnConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public ColumnConstraintClauseContext columnConstraintClause() {
		ColumnConstraintClauseContext _localctx = new ColumnConstraintClauseContext(Context, State);
		EnterRule(_localctx, 872, RULE_columnConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4913;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONSTRAINT) {
				{
				State = 4912;
				constraintNameClause();
				}
			}

			State = 4920;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOT:
			case NULL:
				{
				State = 4915;
				constraintNullNotNullClause();
				}
				break;
			case UNIQUE:
				{
				State = 4916;
				constraintUniqueClause();
				}
				break;
			case PRIMARY:
				{
				State = 4917;
				constraintPrimaryKeyClause();
				}
				break;
			case FOREIGN:
			case REFERENCES:
			case LPAREN:
				{
				State = 4918;
				constraintForeignKeyClause();
				}
				break;
			case CHECK:
				{
				State = 4919;
				constraintCheckClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 4923;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,495,Context) ) {
			case 1:
				{
				State = 4922;
				constraintStateClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintStateClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeferrableConstraintClauseContext[] deferrableConstraintClause() {
			return GetRuleContexts<DeferrableConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeferrableConstraintClauseContext deferrableConstraintClause(int i) {
			return GetRuleContext<DeferrableConstraintClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InitiallyConstraintClauseContext[] initiallyConstraintClause() {
			return GetRuleContexts<InitiallyConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public InitiallyConstraintClauseContext initiallyConstraintClause(int i) {
			return GetRuleContext<InitiallyConstraintClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelyConstraintClauseContext[] relyConstraintClause() {
			return GetRuleContexts<RelyConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelyConstraintClauseContext relyConstraintClause(int i) {
			return GetRuleContext<RelyConstraintClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingIndexConstraintClauseContext[] usingIndexConstraintClause() {
			return GetRuleContexts<UsingIndexConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingIndexConstraintClauseContext usingIndexConstraintClause(int i) {
			return GetRuleContext<UsingIndexConstraintClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnableClauseContext[] enableClause() {
			return GetRuleContexts<EnableClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnableClauseContext enableClause(int i) {
			return GetRuleContext<EnableClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ValidateClauseContext[] validateClause() {
			return GetRuleContexts<ValidateClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ValidateClauseContext validateClause(int i) {
			return GetRuleContext<ValidateClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionsIntoConstraintClauseContext[] exceptionsIntoConstraintClause() {
			return GetRuleContexts<ExceptionsIntoConstraintClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionsIntoConstraintClauseContext exceptionsIntoConstraintClause(int i) {
			return GetRuleContext<ExceptionsIntoConstraintClauseContext>(i);
		}
		public ConstraintStateClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintStateClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConstraintStateClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConstraintStateClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintStateClauseContext constraintStateClause() {
		ConstraintStateClauseContext _localctx = new ConstraintStateClauseContext(Context, State);
		EnterRule(_localctx, 874, RULE_constraintStateClause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4932;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					State = 4932;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case DEFERRABLE:
					case NOT:
						{
						State = 4925;
						deferrableConstraintClause();
						}
						break;
					case INITIALLY:
						{
						State = 4926;
						initiallyConstraintClause();
						}
						break;
					case NORELY:
					case RELY:
						{
						State = 4927;
						relyConstraintClause();
						}
						break;
					case USING:
						{
						State = 4928;
						usingIndexConstraintClause();
						}
						break;
					case DISABLE:
					case ENABLE:
						{
						State = 4929;
						enableClause();
						}
						break;
					case NOVALIDATE:
					case VALIDATE:
						{
						State = 4930;
						validateClause();
						}
						break;
					case EXCEPTIONS:
						{
						State = 4931;
						exceptionsIntoConstraintClause();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4934;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,497,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeferrableConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFERRABLE() { return GetToken(OracleAntlrParser.DEFERRABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public DeferrableConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deferrableConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDeferrableConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDeferrableConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public DeferrableConstraintClauseContext deferrableConstraintClause() {
		DeferrableConstraintClauseContext _localctx = new DeferrableConstraintClauseContext(Context, State);
		EnterRule(_localctx, 876, RULE_deferrableConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4937;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 4936;
				Match(NOT);
				}
			}

			State = 4939;
			Match(DEFERRABLE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InitiallyConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INITIALLY() { return GetToken(OracleAntlrParser.INITIALLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMEDIATE() { return GetToken(OracleAntlrParser.IMMEDIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFERRED() { return GetToken(OracleAntlrParser.DEFERRED, 0); }
		public InitiallyConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initiallyConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterInitiallyConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitInitiallyConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public InitiallyConstraintClauseContext initiallyConstraintClause() {
		InitiallyConstraintClauseContext _localctx = new InitiallyConstraintClauseContext(Context, State);
		EnterRule(_localctx, 878, RULE_initiallyConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4941;
			Match(INITIALLY);
			State = 4942;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFERRED || _la==IMMEDIATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnableClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISABLE() { return GetToken(OracleAntlrParser.DISABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		public EnableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enableClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterEnableClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitEnableClause(this);
		}
	}

	[RuleVersion(0)]
	public EnableClauseContext enableClause() {
		EnableClauseContext _localctx = new EnableClauseContext(Context, State);
		EnterRule(_localctx, 880, RULE_enableClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4944;
			_la = TokenStream.LA(1);
			if ( !(_la==DISABLE || _la==ENABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelyConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NORELY() { return GetToken(OracleAntlrParser.NORELY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELY() { return GetToken(OracleAntlrParser.RELY, 0); }
		public RelyConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relyConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRelyConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRelyConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public RelyConstraintClauseContext relyConstraintClause() {
		RelyConstraintClauseContext _localctx = new RelyConstraintClauseContext(Context, State);
		EnterRule(_localctx, 882, RULE_relyConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4946;
			_la = TokenStream.LA(1);
			if ( !(_la==NORELY || _la==RELY) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingIndexConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UsingIndexAttributesListConstraintClauseContext usingIndexAttributesListConstraintClause() {
			return GetRuleContext<UsingIndexAttributesListConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public UsingIndexConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingIndexConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUsingIndexConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUsingIndexConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public UsingIndexConstraintClauseContext usingIndexConstraintClause() {
		UsingIndexConstraintClauseContext _localctx = new UsingIndexConstraintClauseContext(Context, State);
		EnterRule(_localctx, 884, RULE_usingIndexConstraintClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4948;
			Match(USING);
			State = 4949;
			Match(INDEX);
			State = 4952;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,499,Context) ) {
			case 1:
				{
				State = 4950;
				usingIndexAttributesListConstraintClause();
				}
				break;
			case 2:
				{
				State = 4951;
				plainIdentifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingIndexAttributesListConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext[] loggingClause() {
			return GetRuleContexts<LoggingClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause(int i) {
			return GetRuleContext<LoggingClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext[] tablespaceClause() {
			return GetRuleContexts<TablespaceClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause(int i) {
			return GetRuleContext<TablespaceClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SortNoSortClauseContext[] sortNoSortClause() {
			return GetRuleContexts<SortNoSortClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SortNoSortClauseContext sortNoSortClause(int i) {
			return GetRuleContext<SortNoSortClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext[] physicalAttribute() {
			return GetRuleContexts<PhysicalAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute(int i) {
			return GetRuleContext<PhysicalAttributeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionContext[] indexCompression() {
			return GetRuleContexts<IndexCompressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionContext indexCompression(int i) {
			return GetRuleContext<IndexCompressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComputeStatisticsClauseContext[] computeStatisticsClause() {
			return GetRuleContexts<ComputeStatisticsClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComputeStatisticsClauseContext computeStatisticsClause(int i) {
			return GetRuleContext<ComputeStatisticsClauseContext>(i);
		}
		public UsingIndexAttributesListConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingIndexAttributesListConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUsingIndexAttributesListConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUsingIndexAttributesListConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public UsingIndexAttributesListConstraintClauseContext usingIndexAttributesListConstraintClause() {
		UsingIndexAttributesListConstraintClauseContext _localctx = new UsingIndexAttributesListConstraintClauseContext(Context, State);
		EnterRule(_localctx, 886, RULE_usingIndexAttributesListConstraintClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4960;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 4960;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case FILESYSTEM_LIKE_LOGGING:
				case LOGGING:
				case NOLOGGING:
					{
					State = 4954;
					loggingClause();
					}
					break;
				case TABLESPACE:
					{
					State = 4955;
					tablespaceClause();
					}
					break;
				case NOSORT:
				case SORT:
					{
					State = 4956;
					sortNoSortClause();
					}
					break;
				case INITRANS:
				case MAXTRANS:
				case PCTFREE:
				case PCTUSED:
				case STORAGE:
					{
					State = 4957;
					physicalAttribute();
					}
					break;
				case COMPRESS:
				case NOCOMPRESS:
					{
					State = 4958;
					indexCompression();
					}
					break;
				case COMPUTE:
					{
					State = 4959;
					computeStatisticsClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 4962;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COMPRESS || _la==COMPUTE || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 277)) & ~0x3f) == 0 && ((1L << (_la - 277)) & ((1L << (LOGGING - 277)) | (1L << (MAXTRANS - 277)) | (1L << (NOCOMPRESS - 277)) | (1L << (NOLOGGING - 277)))) != 0) || ((((_la - 345)) & ~0x3f) == 0 && ((1L << (_la - 345)) & ((1L << (NOSORT - 345)) | (1L << (PCTFREE - 345)) | (1L << (PCTUSED - 345)))) != 0) || ((((_la - 482)) & ~0x3f) == 0 && ((1L << (_la - 482)) & ((1L << (SORT - 482)) | (1L << (STORAGE - 482)) | (1L << (TABLESPACE - 482)))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexCompressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PrefixCompressionContext prefixCompression() {
			return GetRuleContext<PrefixCompressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexCompressionClauseContext indexCompressionClause() {
			return GetRuleContext<IndexCompressionClauseContext>(0);
		}
		public IndexCompressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexCompression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexCompression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexCompression(this);
		}
	}

	[RuleVersion(0)]
	public IndexCompressionContext indexCompression() {
		IndexCompressionContext _localctx = new IndexCompressionContext(Context, State);
		EnterRule(_localctx, 888, RULE_indexCompression);
		try {
			State = 4966;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,502,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4964;
				prefixCompression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4965;
				indexCompressionClause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrefixCompressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPRESS() { return GetToken(OracleAntlrParser.COMPRESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCOMPRESS() { return GetToken(OracleAntlrParser.NOCOMPRESS, 0); }
		public PrefixCompressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prefixCompression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPrefixCompression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPrefixCompression(this);
		}
	}

	[RuleVersion(0)]
	public PrefixCompressionContext prefixCompression() {
		PrefixCompressionContext _localctx = new PrefixCompressionContext(Context, State);
		EnterRule(_localctx, 890, RULE_prefixCompression);
		try {
			State = 4971;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPRESS:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 4968;
				Match(COMPRESS);
				State = 4969;
				Match(INTEGER_LITERAL);
				}
				}
				break;
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4970;
				Match(NOCOMPRESS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoggingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOGGING() { return GetToken(OracleAntlrParser.LOGGING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOLOGGING() { return GetToken(OracleAntlrParser.NOLOGGING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FILESYSTEM_LIKE_LOGGING() { return GetToken(OracleAntlrParser.FILESYSTEM_LIKE_LOGGING, 0); }
		public LoggingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loggingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLoggingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLoggingClause(this);
		}
	}

	[RuleVersion(0)]
	public LoggingClauseContext loggingClause() {
		LoggingClauseContext _localctx = new LoggingClauseContext(Context, State);
		EnterRule(_localctx, 892, RULE_loggingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4973;
			_la = TokenStream.LA(1);
			if ( !(_la==FILESYSTEM_LIKE_LOGGING || _la==LOGGING || _la==NOLOGGING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TablespaceClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLESPACE() { return GetToken(OracleAntlrParser.TABLESPACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		public TablespaceClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablespaceClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTablespaceClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTablespaceClause(this);
		}
	}

	[RuleVersion(0)]
	public TablespaceClauseContext tablespaceClause() {
		TablespaceClauseContext _localctx = new TablespaceClauseContext(Context, State);
		EnterRule(_localctx, 894, RULE_tablespaceClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4975;
			Match(TABLESPACE);
			State = 4977;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,504,Context) ) {
			case 1:
				{
				State = 4976;
				Match(SET);
				}
				break;
			}
			State = 4981;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEFAULT:
				{
				State = 4979;
				Match(DEFAULT);
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 4980;
				simpleIdentifierWithoutParentheses();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SortNoSortClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOSORT() { return GetToken(OracleAntlrParser.NOSORT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SORT() { return GetToken(OracleAntlrParser.SORT, 0); }
		public SortNoSortClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sortNoSortClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSortNoSortClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSortNoSortClause(this);
		}
	}

	[RuleVersion(0)]
	public SortNoSortClauseContext sortNoSortClause() {
		SortNoSortClauseContext _localctx = new SortNoSortClauseContext(Context, State);
		EnterRule(_localctx, 896, RULE_sortNoSortClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4983;
			_la = TokenStream.LA(1);
			if ( !(_la==NOSORT || _la==SORT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StorageAttributesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORAGE() { return GetToken(OracleAntlrParser.STORAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StorageAttributeClauseContext[] storageAttributeClause() {
			return GetRuleContexts<StorageAttributeClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StorageAttributeClauseContext storageAttributeClause(int i) {
			return GetRuleContext<StorageAttributeClauseContext>(i);
		}
		public StorageAttributesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storageAttributesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterStorageAttributesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitStorageAttributesClause(this);
		}
	}

	[RuleVersion(0)]
	public StorageAttributesClauseContext storageAttributesClause() {
		StorageAttributesClauseContext _localctx = new StorageAttributesClauseContext(Context, State);
		EnterRule(_localctx, 898, RULE_storageAttributesClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4985;
			Match(STORAGE);
			State = 4986;
			Match(LPAREN);
			State = 4988;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 4987;
				storageAttributeClause();
				}
				}
				State = 4990;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==BUFFER_POOL || _la==CELL_FLASH_CACHE || ((((_la - 153)) & ~0x3f) == 0 && ((1L << (_la - 153)) & ((1L << (ENCRYPT - 153)) | (1L << (FLASH_CACHE - 153)) | (1L << (FREELIST - 153)) | (1L << (FREELISTS - 153)))) != 0) || ((((_la - 230)) & ~0x3f) == 0 && ((1L << (_la - 230)) & ((1L << (INITIAL - 230)) | (1L << (MAXEXTENTS - 230)) | (1L << (MAXSIZE - 230)))) != 0) || _la==MINEXTENTS || _la==NEXT || _la==OPTIMAL || _la==PCTINCREASE );
			State = 4992;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StorageAttributeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NextInitialStorageClauseContext nextInitialStorageClause() {
			return GetRuleContext<NextInitialStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MinextentsStorageClauseContext minextentsStorageClause() {
			return GetRuleContext<MinextentsStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PctIncreaseStorageClauseContext pctIncreaseStorageClause() {
			return GetRuleContext<PctIncreaseStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FreeListsStorageClauseContext freeListsStorageClause() {
			return GetRuleContext<FreeListsStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FreeListGroupsStorageClauseContext freeListGroupsStorageClause() {
			return GetRuleContext<FreeListGroupsStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OptimalStorageClauseContext optimalStorageClause() {
			return GetRuleContext<OptimalStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaxextentsStorageClauseContext maxextentsStorageClause() {
			return GetRuleContext<MaxextentsStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BufferPoolStorageClauseContext bufferPoolStorageClause() {
			return GetRuleContext<BufferPoolStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlashCacheStorageClauseContext flashCacheStorageClause() {
			return GetRuleContext<FlashCacheStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CellFlashCacheStorageClauseContext cellFlashCacheStorageClause() {
			return GetRuleContext<CellFlashCacheStorageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MaxSizeClauseContext maxSizeClause() {
			return GetRuleContext<MaxSizeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EncryptClauseContext encryptClause() {
			return GetRuleContext<EncryptClauseContext>(0);
		}
		public StorageAttributeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storageAttributeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterStorageAttributeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitStorageAttributeClause(this);
		}
	}

	[RuleVersion(0)]
	public StorageAttributeClauseContext storageAttributeClause() {
		StorageAttributeClauseContext _localctx = new StorageAttributeClauseContext(Context, State);
		EnterRule(_localctx, 900, RULE_storageAttributeClause);
		try {
			State = 5006;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INITIAL:
			case NEXT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4994;
				nextInitialStorageClause();
				}
				break;
			case MINEXTENTS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4995;
				minextentsStorageClause();
				}
				break;
			case PCTINCREASE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4996;
				pctIncreaseStorageClause();
				}
				break;
			case FREELISTS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4997;
				freeListsStorageClause();
				}
				break;
			case FREELIST:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4998;
				freeListGroupsStorageClause();
				}
				break;
			case OPTIMAL:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4999;
				optimalStorageClause();
				}
				break;
			case MAXEXTENTS:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5000;
				maxextentsStorageClause();
				}
				break;
			case BUFFER_POOL:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5001;
				bufferPoolStorageClause();
				}
				break;
			case FLASH_CACHE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5002;
				flashCacheStorageClause();
				}
				break;
			case CELL_FLASH_CACHE:
				EnterOuterAlt(_localctx, 10);
				{
				State = 5003;
				cellFlashCacheStorageClause();
				}
				break;
			case MAXSIZE:
				EnterOuterAlt(_localctx, 11);
				{
				State = 5004;
				maxSizeClause();
				}
				break;
			case ENCRYPT:
				EnterOuterAlt(_localctx, 12);
				{
				State = 5005;
				encryptClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaxSizeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXSIZE() { return GetToken(OracleAntlrParser.MAXSIZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNLIMITED() { return GetToken(OracleAntlrParser.UNLIMITED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ByteSizeLiteralContext byteSizeLiteral() {
			return GetRuleContext<ByteSizeLiteralContext>(0);
		}
		public MaxSizeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_maxSizeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaxSizeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaxSizeClause(this);
		}
	}

	[RuleVersion(0)]
	public MaxSizeClauseContext maxSizeClause() {
		MaxSizeClauseContext _localctx = new MaxSizeClauseContext(Context, State);
		EnterRule(_localctx, 902, RULE_maxSizeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5008;
			Match(MAXSIZE);
			State = 5011;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNLIMITED:
				{
				State = 5009;
				Match(UNLIMITED);
				}
				break;
			case INTEGER_LITERAL:
			case BYTE_SIZE_LITERAL:
				{
				State = 5010;
				byteSizeLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EncryptClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENCRYPT() { return GetToken(OracleAntlrParser.ENCRYPT, 0); }
		public EncryptClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_encryptClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterEncryptClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitEncryptClause(this);
		}
	}

	[RuleVersion(0)]
	public EncryptClauseContext encryptClause() {
		EncryptClauseContext _localctx = new EncryptClauseContext(Context, State);
		EnterRule(_localctx, 904, RULE_encryptClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5013;
			Match(ENCRYPT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NextInitialStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ByteSizeLiteralContext byteSizeLiteral() {
			return GetRuleContext<ByteSizeLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INITIAL() { return GetToken(OracleAntlrParser.INITIAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEXT() { return GetToken(OracleAntlrParser.NEXT, 0); }
		public NextInitialStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nextInitialStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNextInitialStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNextInitialStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public NextInitialStorageClauseContext nextInitialStorageClause() {
		NextInitialStorageClauseContext _localctx = new NextInitialStorageClauseContext(Context, State);
		EnterRule(_localctx, 906, RULE_nextInitialStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5015;
			_la = TokenStream.LA(1);
			if ( !(_la==INITIAL || _la==NEXT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5016;
			byteSizeLiteral();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptimalStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTIMAL() { return GetToken(OracleAntlrParser.OPTIMAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ByteSizeLiteralContext byteSizeLiteral() {
			return GetRuleContext<ByteSizeLiteralContext>(0);
		}
		public OptimalStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optimalStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOptimalStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOptimalStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public OptimalStorageClauseContext optimalStorageClause() {
		OptimalStorageClauseContext _localctx = new OptimalStorageClauseContext(Context, State);
		EnterRule(_localctx, 908, RULE_optimalStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5018;
			Match(OPTIMAL);
			State = 5023;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NULL:
				{
				State = 5019;
				Match(NULL);
				}
				break;
			case BUFFER_POOL:
			case CELL_FLASH_CACHE:
			case ENCRYPT:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case INITIAL:
			case MAXEXTENTS:
			case MAXSIZE:
			case MINEXTENTS:
			case NEXT:
			case OPTIMAL:
			case PCTINCREASE:
			case INTEGER_LITERAL:
			case RPAREN:
			case BYTE_SIZE_LITERAL:
				{
				State = 5021;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INTEGER_LITERAL || _la==BYTE_SIZE_LITERAL) {
					{
					State = 5020;
					byteSizeLiteral();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MinextentsStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINEXTENTS() { return GetToken(OracleAntlrParser.MINEXTENTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public MinextentsStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_minextentsStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMinextentsStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMinextentsStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public MinextentsStorageClauseContext minextentsStorageClause() {
		MinextentsStorageClauseContext _localctx = new MinextentsStorageClauseContext(Context, State);
		EnterRule(_localctx, 910, RULE_minextentsStorageClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5025;
			Match(MINEXTENTS);
			State = 5026;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaxextentsStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXEXTENTS() { return GetToken(OracleAntlrParser.MAXEXTENTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNLIMITED() { return GetToken(OracleAntlrParser.UNLIMITED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public MaxextentsStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_maxextentsStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMaxextentsStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMaxextentsStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public MaxextentsStorageClauseContext maxextentsStorageClause() {
		MaxextentsStorageClauseContext _localctx = new MaxextentsStorageClauseContext(Context, State);
		EnterRule(_localctx, 912, RULE_maxextentsStorageClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5028;
			Match(MAXEXTENTS);
			State = 5031;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNLIMITED:
				{
				State = 5029;
				Match(UNLIMITED);
				}
				break;
			case DATE:
			case FALSE:
			case INTERVAL:
			case TIMESTAMP:
			case TRUE:
			case INTEGER_LITERAL:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case QUOTE_CHARACTER_STRING_LITERAL:
				{
				State = 5030;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PctIncreaseStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTINCREASE() { return GetToken(OracleAntlrParser.PCTINCREASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public PctIncreaseStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pctIncreaseStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPctIncreaseStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPctIncreaseStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public PctIncreaseStorageClauseContext pctIncreaseStorageClause() {
		PctIncreaseStorageClauseContext _localctx = new PctIncreaseStorageClauseContext(Context, State);
		EnterRule(_localctx, 914, RULE_pctIncreaseStorageClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5033;
			Match(PCTINCREASE);
			State = 5034;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FreeListsStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FREELISTS() { return GetToken(OracleAntlrParser.FREELISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public FreeListsStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_freeListsStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFreeListsStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFreeListsStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public FreeListsStorageClauseContext freeListsStorageClause() {
		FreeListsStorageClauseContext _localctx = new FreeListsStorageClauseContext(Context, State);
		EnterRule(_localctx, 916, RULE_freeListsStorageClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5036;
			Match(FREELISTS);
			State = 5037;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FreeListGroupsStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FREELIST() { return GetToken(OracleAntlrParser.FREELIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUPS() { return GetToken(OracleAntlrParser.GROUPS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public FreeListGroupsStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_freeListGroupsStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFreeListGroupsStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFreeListGroupsStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public FreeListGroupsStorageClauseContext freeListGroupsStorageClause() {
		FreeListGroupsStorageClauseContext _localctx = new FreeListGroupsStorageClauseContext(Context, State);
		EnterRule(_localctx, 918, RULE_freeListGroupsStorageClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5039;
			Match(FREELIST);
			State = 5040;
			Match(GROUPS);
			State = 5041;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BufferPoolStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUFFER_POOL() { return GetToken(OracleAntlrParser.BUFFER_POOL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RECYCLE() { return GetToken(OracleAntlrParser.RECYCLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		public BufferPoolStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bufferPoolStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBufferPoolStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBufferPoolStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public BufferPoolStorageClauseContext bufferPoolStorageClause() {
		BufferPoolStorageClauseContext _localctx = new BufferPoolStorageClauseContext(Context, State);
		EnterRule(_localctx, 920, RULE_bufferPoolStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5043;
			Match(BUFFER_POOL);
			State = 5044;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFAULT || _la==KEEP || _la==RECYCLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlashCacheStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLASH_CACHE() { return GetToken(OracleAntlrParser.FLASH_CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(OracleAntlrParser.NONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		public FlashCacheStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flashCacheStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFlashCacheStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFlashCacheStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public FlashCacheStorageClauseContext flashCacheStorageClause() {
		FlashCacheStorageClauseContext _localctx = new FlashCacheStorageClauseContext(Context, State);
		EnterRule(_localctx, 922, RULE_flashCacheStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5046;
			Match(FLASH_CACHE);
			State = 5047;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFAULT || _la==KEEP || _la==NONE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CellFlashCacheStorageClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CELL_FLASH_CACHE() { return GetToken(OracleAntlrParser.CELL_FLASH_CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(OracleAntlrParser.NONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		public CellFlashCacheStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cellFlashCacheStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCellFlashCacheStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCellFlashCacheStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public CellFlashCacheStorageClauseContext cellFlashCacheStorageClause() {
		CellFlashCacheStorageClauseContext _localctx = new CellFlashCacheStorageClauseContext(Context, State);
		EnterRule(_localctx, 924, RULE_cellFlashCacheStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5049;
			Match(CELL_FLASH_CACHE);
			State = 5050;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFAULT || _la==KEEP || _la==NONE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComputeStatisticsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPUTE() { return GetToken(OracleAntlrParser.COMPUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATISTICS() { return GetToken(OracleAntlrParser.STATISTICS, 0); }
		public ComputeStatisticsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_computeStatisticsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterComputeStatisticsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitComputeStatisticsClause(this);
		}
	}

	[RuleVersion(0)]
	public ComputeStatisticsClauseContext computeStatisticsClause() {
		ComputeStatisticsClauseContext _localctx = new ComputeStatisticsClauseContext(Context, State);
		EnterRule(_localctx, 926, RULE_computeStatisticsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5052;
			Match(COMPUTE);
			State = 5053;
			Match(STATISTICS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ValidateClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALIDATE() { return GetToken(OracleAntlrParser.VALIDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOVALIDATE() { return GetToken(OracleAntlrParser.NOVALIDATE, 0); }
		public ValidateClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_validateClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterValidateClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitValidateClause(this);
		}
	}

	[RuleVersion(0)]
	public ValidateClauseContext validateClause() {
		ValidateClauseContext _localctx = new ValidateClauseContext(Context, State);
		EnterRule(_localctx, 928, RULE_validateClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5055;
			_la = TokenStream.LA(1);
			if ( !(_la==NOVALIDATE || _la==VALIDATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExceptionsIntoConstraintClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPTIONS() { return GetToken(OracleAntlrParser.EXCEPTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public ExceptionsIntoConstraintClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exceptionsIntoConstraintClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExceptionsIntoConstraintClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExceptionsIntoConstraintClause(this);
		}
	}

	[RuleVersion(0)]
	public ExceptionsIntoConstraintClauseContext exceptionsIntoConstraintClause() {
		ExceptionsIntoConstraintClauseContext _localctx = new ExceptionsIntoConstraintClauseContext(Context, State);
		EnterRule(_localctx, 930, RULE_exceptionsIntoConstraintClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5057;
			Match(EXCEPTIONS);
			State = 5058;
			Match(INTO);
			State = 5059;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ByteSizeLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BYTE_SIZE_LITERAL() { return GetToken(OracleAntlrParser.BYTE_SIZE_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		public ByteSizeLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_byteSizeLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterByteSizeLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitByteSizeLiteral(this);
		}
	}

	[RuleVersion(0)]
	public ByteSizeLiteralContext byteSizeLiteral() {
		ByteSizeLiteralContext _localctx = new ByteSizeLiteralContext(Context, State);
		EnterRule(_localctx, 932, RULE_byteSizeLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5061;
			_la = TokenStream.LA(1);
			if ( !(_la==INTEGER_LITERAL || _la==BYTE_SIZE_LITERAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintNameClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINT() { return GetToken(OracleAntlrParser.CONSTRAINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		public ConstraintNameClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintNameClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConstraintNameClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConstraintNameClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintNameClauseContext constraintNameClause() {
		ConstraintNameClauseContext _localctx = new ConstraintNameClauseContext(Context, State);
		EnterRule(_localctx, 934, RULE_constraintNameClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5063;
			Match(CONSTRAINT);
			State = 5064;
			simpleIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintNullNotNullClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public ConstraintNullNotNullClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintNullNotNullClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConstraintNullNotNullClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConstraintNullNotNullClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintNullNotNullClauseContext constraintNullNotNullClause() {
		ConstraintNullNotNullClauseContext _localctx = new ConstraintNullNotNullClauseContext(Context, State);
		EnterRule(_localctx, 936, RULE_constraintNullNotNullClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5067;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 5066;
				Match(NOT);
				}
			}

			State = 5069;
			Match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintUniqueClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUE() { return GetToken(OracleAntlrParser.UNIQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public ConstraintUniqueClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintUniqueClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConstraintUniqueClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConstraintUniqueClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintUniqueClauseContext constraintUniqueClause() {
		ConstraintUniqueClauseContext _localctx = new ConstraintUniqueClauseContext(Context, State);
		EnterRule(_localctx, 938, RULE_constraintUniqueClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5071;
			Match(UNIQUE);
			State = 5073;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,513,Context) ) {
			case 1:
				{
				State = 5072;
				columnListInParenElementClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintPrimaryKeyClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIMARY() { return GetToken(OracleAntlrParser.PRIMARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(OracleAntlrParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public ConstraintPrimaryKeyClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintPrimaryKeyClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConstraintPrimaryKeyClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConstraintPrimaryKeyClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintPrimaryKeyClauseContext constraintPrimaryKeyClause() {
		ConstraintPrimaryKeyClauseContext _localctx = new ConstraintPrimaryKeyClauseContext(Context, State);
		EnterRule(_localctx, 940, RULE_constraintPrimaryKeyClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5075;
			Match(PRIMARY);
			State = 5076;
			Match(KEY);
			State = 5078;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,514,Context) ) {
			case 1:
				{
				State = 5077;
				columnListInParenElementClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintCheckClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHECK() { return GetToken(OracleAntlrParser.CHECK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConditionInParensContext conditionInParens() {
			return GetRuleContext<ConditionInParensContext>(0);
		}
		public ConstraintCheckClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintCheckClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConstraintCheckClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConstraintCheckClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintCheckClauseContext constraintCheckClause() {
		ConstraintCheckClauseContext _localctx = new ConstraintCheckClauseContext(Context, State);
		EnterRule(_localctx, 942, RULE_constraintCheckClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5080;
			Match(CHECK);
			State = 5081;
			conditionInParens();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionInParensContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public ConditionInParensContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionInParens; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConditionInParens(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConditionInParens(this);
		}
	}

	[RuleVersion(0)]
	public ConditionInParensContext conditionInParens() {
		ConditionInParensContext _localctx = new ConditionInParensContext(Context, State);
		EnterRule(_localctx, 944, RULE_conditionInParens);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5083;
			Match(LPAREN);
			State = 5084;
			fullExpression();
			State = 5085;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintForeignKeyClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintForeignKeyRefClauseContext constraintForeignKeyRefClause() {
			return GetRuleContext<ConstraintForeignKeyRefClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOREIGN() { return GetToken(OracleAntlrParser.FOREIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(OracleAntlrParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnDeleteActionClauseContext onDeleteActionClause() {
			return GetRuleContext<OnDeleteActionClauseContext>(0);
		}
		public ConstraintForeignKeyClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintForeignKeyClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConstraintForeignKeyClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConstraintForeignKeyClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintForeignKeyClauseContext constraintForeignKeyClause() {
		ConstraintForeignKeyClauseContext _localctx = new ConstraintForeignKeyClauseContext(Context, State);
		EnterRule(_localctx, 946, RULE_constraintForeignKeyClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5089;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOREIGN) {
				{
				State = 5087;
				Match(FOREIGN);
				State = 5088;
				Match(KEY);
				}
			}

			State = 5092;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 5091;
				columnListInParenElementClause();
				}
			}

			State = 5094;
			constraintForeignKeyRefClause();
			State = 5096;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 5095;
				onDeleteActionClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintForeignKeyRefClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFERENCES() { return GetToken(OracleAntlrParser.REFERENCES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public ConstraintForeignKeyRefClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintForeignKeyRefClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConstraintForeignKeyRefClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConstraintForeignKeyRefClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintForeignKeyRefClauseContext constraintForeignKeyRefClause() {
		ConstraintForeignKeyRefClauseContext _localctx = new ConstraintForeignKeyRefClauseContext(Context, State);
		EnterRule(_localctx, 948, RULE_constraintForeignKeyRefClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5098;
			Match(REFERENCES);
			State = 5099;
			plainIdentifier();
			State = 5101;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,518,Context) ) {
			case 1:
				{
				State = 5100;
				columnListInParenElementClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnDeleteActionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(OracleAntlrParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASCADE() { return GetToken(OracleAntlrParser.CASCADE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public OnDeleteActionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onDeleteActionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOnDeleteActionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOnDeleteActionClause(this);
		}
	}

	[RuleVersion(0)]
	public OnDeleteActionClauseContext onDeleteActionClause() {
		OnDeleteActionClauseContext _localctx = new OnDeleteActionClauseContext(Context, State);
		EnterRule(_localctx, 950, RULE_onDeleteActionClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5103;
			Match(ON);
			State = 5104;
			Match(DELETE);
			State = 5108;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CASCADE:
				{
				State = 5105;
				Match(CASCADE);
				}
				break;
			case SET:
				{
				State = 5106;
				Match(SET);
				State = 5107;
				Match(NULL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TriggerStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIGGER() { return GetToken(OracleAntlrParser.TRIGGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleDmlTriggerContext simpleDmlTrigger() {
			return GetRuleContext<SimpleDmlTriggerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsteadOfDmlTriggerContext insteadOfDmlTrigger() {
			return GetRuleContext<InsteadOfDmlTriggerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompoundDmlTriggerContext compoundDmlTrigger() {
			return GetRuleContext<CompoundDmlTriggerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SystemTriggerContext systemTrigger() {
			return GetRuleContext<SystemTriggerContext>(0);
		}
		public TriggerStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_triggerStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTriggerStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTriggerStatement(this);
		}
	}

	[RuleVersion(0)]
	public TriggerStatementContext triggerStatement() {
		TriggerStatementContext _localctx = new TriggerStatementContext(Context, State);
		EnterRule(_localctx, 952, RULE_triggerStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5110;
			Match(TRIGGER);
			State = 5111;
			plainIdentifier();
			State = 5116;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,520,Context) ) {
			case 1:
				{
				State = 5112;
				simpleDmlTrigger();
				}
				break;
			case 2:
				{
				State = 5113;
				insteadOfDmlTrigger();
				}
				break;
			case 3:
				{
				State = 5114;
				compoundDmlTrigger();
				}
				break;
			case 4:
				{
				State = 5115;
				systemTrigger();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleDmlTriggerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TriggerCallTypeClauseContext triggerCallTypeClause() {
			return GetRuleContext<TriggerCallTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DmlTriggerEventClauseContext dmlTriggerEventClause() {
			return GetRuleContext<DmlTriggerEventClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CallStatementContext callStatement() {
			return GetRuleContext<CallStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockStatementContext blockStatement() {
			return GetRuleContext<BlockStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateTriggerWhenClauseContext createTriggerWhenClause() {
			return GetRuleContext<CreateTriggerWhenClauseContext>(0);
		}
		public SimpleDmlTriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleDmlTrigger; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSimpleDmlTrigger(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSimpleDmlTrigger(this);
		}
	}

	[RuleVersion(0)]
	public SimpleDmlTriggerContext simpleDmlTrigger() {
		SimpleDmlTriggerContext _localctx = new SimpleDmlTriggerContext(Context, State);
		EnterRule(_localctx, 954, RULE_simpleDmlTrigger);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5118;
			triggerCallTypeClause();
			State = 5119;
			dmlTriggerEventClause();
			State = 5121;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,521,Context) ) {
			case 1:
				{
				State = 5120;
				createTriggerWhenClause();
				}
				break;
			}
			State = 5125;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,522,Context) ) {
			case 1:
				{
				State = 5123;
				callStatement();
				}
				break;
			case 2:
				{
				State = 5124;
				blockStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsteadOfDmlTriggerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TriggerCallTypeClauseContext triggerCallTypeClause() {
			return GetRuleContext<TriggerCallTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DmlTriggerEventClauseContext dmlTriggerEventClause() {
			return GetRuleContext<DmlTriggerEventClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CallStatementContext callStatement() {
			return GetRuleContext<CallStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockStatementContext blockStatement() {
			return GetRuleContext<BlockStatementContext>(0);
		}
		public InsteadOfDmlTriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insteadOfDmlTrigger; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterInsteadOfDmlTrigger(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitInsteadOfDmlTrigger(this);
		}
	}

	[RuleVersion(0)]
	public InsteadOfDmlTriggerContext insteadOfDmlTrigger() {
		InsteadOfDmlTriggerContext _localctx = new InsteadOfDmlTriggerContext(Context, State);
		EnterRule(_localctx, 956, RULE_insteadOfDmlTrigger);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5127;
			triggerCallTypeClause();
			State = 5128;
			dmlTriggerEventClause();
			State = 5131;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,523,Context) ) {
			case 1:
				{
				State = 5129;
				callStatement();
				}
				break;
			case 2:
				{
				State = 5130;
				blockStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompoundDmlTriggerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TriggerCallTypeClauseContext triggerCallTypeClause() {
			return GetRuleContext<TriggerCallTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DmlTriggerEventClauseContext dmlTriggerEventClause() {
			return GetRuleContext<DmlTriggerEventClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompoundTriggerBlockContext compoundTriggerBlock() {
			return GetRuleContext<CompoundTriggerBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateTriggerWhenClauseContext createTriggerWhenClause() {
			return GetRuleContext<CreateTriggerWhenClauseContext>(0);
		}
		public CompoundDmlTriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compoundDmlTrigger; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCompoundDmlTrigger(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCompoundDmlTrigger(this);
		}
	}

	[RuleVersion(0)]
	public CompoundDmlTriggerContext compoundDmlTrigger() {
		CompoundDmlTriggerContext _localctx = new CompoundDmlTriggerContext(Context, State);
		EnterRule(_localctx, 958, RULE_compoundDmlTrigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5133;
			triggerCallTypeClause();
			State = 5134;
			dmlTriggerEventClause();
			State = 5136;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHEN) {
				{
				State = 5135;
				createTriggerWhenClause();
				}
			}

			State = 5138;
			compoundTriggerBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SystemTriggerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TriggerCallTypeClauseContext triggerCallTypeClause() {
			return GetRuleContext<TriggerCallTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TriggerStatementOnClauseContext triggerStatementOnClause() {
			return GetRuleContext<TriggerStatementOnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DdlEventsListClauseContext ddlEventsListClause() {
			return GetRuleContext<DdlEventsListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DatabaseEventsListClauseContext databaseEventsListClause() {
			return GetRuleContext<DatabaseEventsListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CallStatementContext callStatement() {
			return GetRuleContext<CallStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockStatementContext blockStatement() {
			return GetRuleContext<BlockStatementContext>(0);
		}
		public SystemTriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_systemTrigger; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSystemTrigger(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSystemTrigger(this);
		}
	}

	[RuleVersion(0)]
	public SystemTriggerContext systemTrigger() {
		SystemTriggerContext _localctx = new SystemTriggerContext(Context, State);
		EnterRule(_localctx, 960, RULE_systemTrigger);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5140;
			triggerCallTypeClause();
			State = 5143;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALTER:
			case ANALYZE:
			case ASSOCIATE:
			case AUDIT:
			case COMMENT:
			case CREATE:
			case DDL:
			case DISASSOCIATE:
			case DROP:
			case GRANT:
			case NOAUDIT:
			case RENAME:
			case REVOKE:
			case TRUNCATE:
				{
				State = 5141;
				ddlEventsListClause();
				}
				break;
			case LOGOFF:
			case LOGON:
			case SERVERERROR:
			case SHUTDOWN:
			case STARTUP:
			case SUSPEND:
				{
				State = 5142;
				databaseEventsListClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5145;
			triggerStatementOnClause();
			State = 5148;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,526,Context) ) {
			case 1:
				{
				State = 5146;
				callStatement();
				}
				break;
			case 2:
				{
				State = 5147;
				blockStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompoundTriggerBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPOUND() { return GetToken(OracleAntlrParser.COMPOUND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIGGER() { return GetToken(OracleAntlrParser.TRIGGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndClauseContext endClause() {
			return GetRuleContext<EndClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockContext declarationBlock() {
			return GetRuleContext<DeclarationBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TimingPointSectionContext[] timingPointSection() {
			return GetRuleContexts<TimingPointSectionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TimingPointSectionContext timingPointSection(int i) {
			return GetRuleContext<TimingPointSectionContext>(i);
		}
		public CompoundTriggerBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compoundTriggerBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCompoundTriggerBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCompoundTriggerBlock(this);
		}
	}

	[RuleVersion(0)]
	public CompoundTriggerBlockContext compoundTriggerBlock() {
		CompoundTriggerBlockContext _localctx = new CompoundTriggerBlockContext(Context, State);
		EnterRule(_localctx, 962, RULE_compoundTriggerBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5150;
			Match(COMPOUND);
			State = 5151;
			Match(TRIGGER);
			State = 5153;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,527,Context) ) {
			case 1:
				{
				State = 5152;
				declarationBlock();
				}
				break;
			}
			State = 5156;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 5155;
				timingPointSection();
				}
				}
				State = 5158;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==AFTER || _la==BEFORE || _la==INSTEAD );
			State = 5160;
			endClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimingPointSectionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TimingPointContext[] timingPoint() {
			return GetRuleContexts<TimingPointContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TimingPointContext timingPoint(int i) {
			return GetRuleContext<TimingPointContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockBodyContext blockBody() {
			return GetRuleContext<BlockBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI() { return GetToken(OracleAntlrParser.SEMI, 0); }
		public TimingPointSectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timingPointSection; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTimingPointSection(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTimingPointSection(this);
		}
	}

	[RuleVersion(0)]
	public TimingPointSectionContext timingPointSection() {
		TimingPointSectionContext _localctx = new TimingPointSectionContext(Context, State);
		EnterRule(_localctx, 964, RULE_timingPointSection);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5162;
			timingPoint();
			State = 5163;
			Match(IS);
			State = 5164;
			blockBody();
			State = 5165;
			timingPoint();
			State = 5166;
			Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimingPointContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATEMENT() { return GetToken(OracleAntlrParser.STATEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEFORE() { return GetToken(OracleAntlrParser.BEFORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AFTER() { return GetToken(OracleAntlrParser.AFTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EACH() { return GetToken(OracleAntlrParser.EACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSTEAD() { return GetToken(OracleAntlrParser.INSTEAD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		public TimingPointContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timingPoint; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTimingPoint(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTimingPoint(this);
		}
	}

	[RuleVersion(0)]
	public TimingPointContext timingPoint() {
		TimingPointContext _localctx = new TimingPointContext(Context, State);
		EnterRule(_localctx, 966, RULE_timingPoint);
		int _la;
		try {
			State = 5178;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,530,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 5168;
				_la = TokenStream.LA(1);
				if ( !(_la==AFTER || _la==BEFORE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5169;
				Match(STATEMENT);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 5174;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case BEFORE:
					{
					State = 5170;
					Match(BEFORE);
					}
					break;
				case AFTER:
					{
					State = 5171;
					Match(AFTER);
					}
					break;
				case INSTEAD:
					{
					State = 5172;
					Match(INSTEAD);
					State = 5173;
					Match(OF);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5176;
				Match(EACH);
				State = 5177;
				Match(ROW);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CALL() { return GetToken(OracleAntlrParser.CALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CallIntoClauseContext callIntoClause() {
			return GetRuleContext<CallIntoClauseContext>(0);
		}
		public CallStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCallStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCallStatement(this);
		}
	}

	[RuleVersion(0)]
	public CallStatementContext callStatement() {
		CallStatementContext _localctx = new CallStatementContext(Context, State);
		EnterRule(_localctx, 968, RULE_callStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5180;
			Match(CALL);
			State = 5181;
			identifier();
			State = 5183;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTO) {
				{
				State = 5182;
				callIntoClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallStatementWithExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(OracleAntlrParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public CallStatementWithExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callStatementWithExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCallStatementWithExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCallStatementWithExpression(this);
		}
	}

	[RuleVersion(0)]
	public CallStatementWithExpressionContext callStatementWithExpression() {
		CallStatementWithExpressionContext _localctx = new CallStatementWithExpressionContext(Context, State);
		EnterRule(_localctx, 970, RULE_callStatementWithExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5185;
			fullExpression();
			State = 5186;
			Match(DOT);
			State = 5187;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallIntoClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndicatorClauseContext indicatorClause() {
			return GetRuleContext<IndicatorClauseContext>(0);
		}
		public CallIntoClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callIntoClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCallIntoClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCallIntoClause(this);
		}
	}

	[RuleVersion(0)]
	public CallIntoClauseContext callIntoClause() {
		CallIntoClauseContext _localctx = new CallIntoClauseContext(Context, State);
		EnterRule(_localctx, 972, RULE_callIntoClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5189;
			Match(INTO);
			State = 5190;
			simpleIdentifier();
			State = 5192;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 5191;
				indicatorClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndicatorClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDICATOR() { return GetToken(OracleAntlrParser.INDICATOR, 0); }
		public IndicatorClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indicatorClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndicatorClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndicatorClause(this);
		}
	}

	[RuleVersion(0)]
	public IndicatorClauseContext indicatorClause() {
		IndicatorClauseContext _localctx = new IndicatorClauseContext(Context, State);
		EnterRule(_localctx, 974, RULE_indicatorClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5195;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,533,Context) ) {
			case 1:
				{
				State = 5194;
				Match(INDICATOR);
				}
				break;
			}
			State = 5197;
			simpleIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTriggerWhenClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConditionInParensContext conditionInParens() {
			return GetRuleContext<ConditionInParensContext>(0);
		}
		public CreateTriggerWhenClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTriggerWhenClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateTriggerWhenClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateTriggerWhenClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateTriggerWhenClauseContext createTriggerWhenClause() {
		CreateTriggerWhenClauseContext _localctx = new CreateTriggerWhenClauseContext(Context, State);
		EnterRule(_localctx, 976, RULE_createTriggerWhenClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5199;
			Match(WHEN);
			State = 5200;
			conditionInParens();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TriggerStatementOnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCHEMA() { return GetToken(OracleAntlrParser.SCHEMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(OracleAntlrParser.DATABASE, 0); }
		public TriggerStatementOnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_triggerStatementOnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTriggerStatementOnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTriggerStatementOnClause(this);
		}
	}

	[RuleVersion(0)]
	public TriggerStatementOnClauseContext triggerStatementOnClause() {
		TriggerStatementOnClauseContext _localctx = new TriggerStatementOnClauseContext(Context, State);
		EnterRule(_localctx, 978, RULE_triggerStatementOnClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5202;
			Match(ON);
			State = 5203;
			_la = TokenStream.LA(1);
			if ( !(_la==DATABASE || _la==SCHEMA) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DdlEventsListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DdlEventContext[] ddlEvent() {
			return GetRuleContexts<DdlEventContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DdlEventContext ddlEvent(int i) {
			return GetRuleContext<DdlEventContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] OR() { return GetTokens(OracleAntlrParser.OR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR(int i) {
			return GetToken(OracleAntlrParser.OR, i);
		}
		public DdlEventsListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ddlEventsListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDdlEventsListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDdlEventsListClause(this);
		}
	}

	[RuleVersion(0)]
	public DdlEventsListClauseContext ddlEventsListClause() {
		DdlEventsListClauseContext _localctx = new DdlEventsListClauseContext(Context, State);
		EnterRule(_localctx, 980, RULE_ddlEventsListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5205;
			ddlEvent();
			State = 5210;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR) {
				{
				{
				State = 5206;
				Match(OR);
				State = 5207;
				ddlEvent();
				}
				}
				State = 5212;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DatabaseEventsListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DatabaseEventContext[] databaseEvent() {
			return GetRuleContexts<DatabaseEventContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DatabaseEventContext databaseEvent(int i) {
			return GetRuleContext<DatabaseEventContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] OR() { return GetTokens(OracleAntlrParser.OR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR(int i) {
			return GetToken(OracleAntlrParser.OR, i);
		}
		public DatabaseEventsListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_databaseEventsListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDatabaseEventsListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDatabaseEventsListClause(this);
		}
	}

	[RuleVersion(0)]
	public DatabaseEventsListClauseContext databaseEventsListClause() {
		DatabaseEventsListClauseContext _localctx = new DatabaseEventsListClauseContext(Context, State);
		EnterRule(_localctx, 982, RULE_databaseEventsListClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5213;
			databaseEvent();
			State = 5218;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR) {
				{
				{
				State = 5214;
				Match(OR);
				State = 5215;
				databaseEvent();
				}
				}
				State = 5220;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DdlEventContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALTER() { return GetToken(OracleAntlrParser.ALTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANALYZE() { return GetToken(OracleAntlrParser.ANALYZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSOCIATE() { return GetToken(OracleAntlrParser.ASSOCIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATISTICS() { return GetToken(OracleAntlrParser.STATISTICS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUDIT() { return GetToken(OracleAntlrParser.AUDIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMENT() { return GetToken(OracleAntlrParser.COMMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATE() { return GetToken(OracleAntlrParser.CREATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISASSOCIATE() { return GetToken(OracleAntlrParser.DISASSOCIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(OracleAntlrParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRANT() { return GetToken(OracleAntlrParser.GRANT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOAUDIT() { return GetToken(OracleAntlrParser.NOAUDIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RENAME() { return GetToken(OracleAntlrParser.RENAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REVOKE() { return GetToken(OracleAntlrParser.REVOKE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUNCATE() { return GetToken(OracleAntlrParser.TRUNCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DDL() { return GetToken(OracleAntlrParser.DDL, 0); }
		public DdlEventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ddlEvent; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDdlEvent(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDdlEvent(this);
		}
	}

	[RuleVersion(0)]
	public DdlEventContext ddlEvent() {
		DdlEventContext _localctx = new DdlEventContext(Context, State);
		EnterRule(_localctx, 984, RULE_ddlEvent);
		try {
			State = 5237;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALTER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5221;
				Match(ALTER);
				}
				break;
			case ANALYZE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5222;
				Match(ANALYZE);
				}
				break;
			case ASSOCIATE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5223;
				Match(ASSOCIATE);
				State = 5224;
				Match(STATISTICS);
				}
				break;
			case AUDIT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5225;
				Match(AUDIT);
				}
				break;
			case COMMENT:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5226;
				Match(COMMENT);
				}
				break;
			case CREATE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5227;
				Match(CREATE);
				}
				break;
			case DISASSOCIATE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5228;
				Match(DISASSOCIATE);
				State = 5229;
				Match(STATISTICS);
				}
				break;
			case DROP:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5230;
				Match(DROP);
				}
				break;
			case GRANT:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5231;
				Match(GRANT);
				}
				break;
			case NOAUDIT:
				EnterOuterAlt(_localctx, 10);
				{
				State = 5232;
				Match(NOAUDIT);
				}
				break;
			case RENAME:
				EnterOuterAlt(_localctx, 11);
				{
				State = 5233;
				Match(RENAME);
				}
				break;
			case REVOKE:
				EnterOuterAlt(_localctx, 12);
				{
				State = 5234;
				Match(REVOKE);
				}
				break;
			case TRUNCATE:
				EnterOuterAlt(_localctx, 13);
				{
				State = 5235;
				Match(TRUNCATE);
				}
				break;
			case DDL:
				EnterOuterAlt(_localctx, 14);
				{
				State = 5236;
				Match(DDL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DatabaseEventContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVERERROR() { return GetToken(OracleAntlrParser.SERVERERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOGON() { return GetToken(OracleAntlrParser.LOGON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOGOFF() { return GetToken(OracleAntlrParser.LOGOFF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STARTUP() { return GetToken(OracleAntlrParser.STARTUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHUTDOWN() { return GetToken(OracleAntlrParser.SHUTDOWN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUSPEND() { return GetToken(OracleAntlrParser.SUSPEND, 0); }
		public DatabaseEventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_databaseEvent; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDatabaseEvent(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDatabaseEvent(this);
		}
	}

	[RuleVersion(0)]
	public DatabaseEventContext databaseEvent() {
		DatabaseEventContext _localctx = new DatabaseEventContext(Context, State);
		EnterRule(_localctx, 986, RULE_databaseEvent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5239;
			_la = TokenStream.LA(1);
			if ( !(_la==LOGOFF || _la==LOGON || ((((_la - 469)) & ~0x3f) == 0 && ((1L << (_la - 469)) & ((1L << (SERVERERROR - 469)) | (1L << (SHUTDOWN - 469)) | (1L << (STARTUP - 469)) | (1L << (SUSPEND - 469)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TriggerCallTypeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEFORE() { return GetToken(OracleAntlrParser.BEFORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AFTER() { return GetToken(OracleAntlrParser.AFTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSTEAD() { return GetToken(OracleAntlrParser.INSTEAD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		public TriggerCallTypeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_triggerCallTypeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTriggerCallTypeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTriggerCallTypeClause(this);
		}
	}

	[RuleVersion(0)]
	public TriggerCallTypeClauseContext triggerCallTypeClause() {
		TriggerCallTypeClauseContext _localctx = new TriggerCallTypeClauseContext(Context, State);
		EnterRule(_localctx, 988, RULE_triggerCallTypeClause);
		try {
			State = 5246;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BEFORE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5241;
				Match(BEFORE);
				}
				break;
			case AFTER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5242;
				Match(AFTER);
				}
				break;
			case INSTEAD:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5243;
				Match(INSTEAD);
				State = 5244;
				Match(OF);
				}
				break;
			case FOR:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5245;
				Match(FOR);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DmlTriggerEventClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DmlTriggerEventsListContext dmlTriggerEventsList() {
			return GetRuleContext<DmlTriggerEventsListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DmlTriggerEventOnClauseContext dmlTriggerEventOnClause() {
			return GetRuleContext<DmlTriggerEventOnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReferencingClauseContext referencingClause() {
			return GetRuleContext<ReferencingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForEachRowClauseContext forEachRowClause() {
			return GetRuleContext<ForEachRowClauseContext>(0);
		}
		public DmlTriggerEventClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dmlTriggerEventClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDmlTriggerEventClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDmlTriggerEventClause(this);
		}
	}

	[RuleVersion(0)]
	public DmlTriggerEventClauseContext dmlTriggerEventClause() {
		DmlTriggerEventClauseContext _localctx = new DmlTriggerEventClauseContext(Context, State);
		EnterRule(_localctx, 990, RULE_dmlTriggerEventClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5248;
			dmlTriggerEventsList();
			State = 5249;
			dmlTriggerEventOnClause();
			State = 5251;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,538,Context) ) {
			case 1:
				{
				State = 5250;
				referencingClause();
				}
				break;
			}
			State = 5254;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 5253;
				forEachRowClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DmlTriggerEventsListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DmlTriggerEventContext[] dmlTriggerEvent() {
			return GetRuleContexts<DmlTriggerEventContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DmlTriggerEventContext dmlTriggerEvent(int i) {
			return GetRuleContext<DmlTriggerEventContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] OR() { return GetTokens(OracleAntlrParser.OR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR(int i) {
			return GetToken(OracleAntlrParser.OR, i);
		}
		public DmlTriggerEventsListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dmlTriggerEventsList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDmlTriggerEventsList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDmlTriggerEventsList(this);
		}
	}

	[RuleVersion(0)]
	public DmlTriggerEventsListContext dmlTriggerEventsList() {
		DmlTriggerEventsListContext _localctx = new DmlTriggerEventsListContext(Context, State);
		EnterRule(_localctx, 992, RULE_dmlTriggerEventsList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5256;
			dmlTriggerEvent();
			State = 5261;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR) {
				{
				{
				State = 5257;
				Match(OR);
				State = 5258;
				dmlTriggerEvent();
				}
				}
				State = 5263;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DmlTriggerEventContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSERT() { return GetToken(OracleAntlrParser.INSERT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(OracleAntlrParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UPDATE() { return GetToken(OracleAntlrParser.UPDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OfColumnListClauseContext ofColumnListClause() {
			return GetRuleContext<OfColumnListClauseContext>(0);
		}
		public DmlTriggerEventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dmlTriggerEvent; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDmlTriggerEvent(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDmlTriggerEvent(this);
		}
	}

	[RuleVersion(0)]
	public DmlTriggerEventContext dmlTriggerEvent() {
		DmlTriggerEventContext _localctx = new DmlTriggerEventContext(Context, State);
		EnterRule(_localctx, 994, RULE_dmlTriggerEvent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5264;
			_la = TokenStream.LA(1);
			if ( !(_la==DELETE || _la==INSERT || _la==UPDATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OF) {
				{
				State = 5265;
				ofColumnListClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OfColumnListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListElementClauseContext columnListElementClause() {
			return GetRuleContext<ColumnListElementClauseContext>(0);
		}
		public OfColumnListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ofColumnListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOfColumnListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOfColumnListClause(this);
		}
	}

	[RuleVersion(0)]
	public OfColumnListClauseContext ofColumnListClause() {
		OfColumnListClauseContext _localctx = new OfColumnListClauseContext(Context, State);
		EnterRule(_localctx, 996, RULE_ofColumnListClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5268;
			Match(OF);
			State = 5269;
			columnListElementClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DmlTriggerEventOnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NestedTableClauseContext nestedTableClause() {
			return GetRuleContext<NestedTableClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public DmlTriggerEventOnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dmlTriggerEventOnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDmlTriggerEventOnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDmlTriggerEventOnClause(this);
		}
	}

	[RuleVersion(0)]
	public DmlTriggerEventOnClauseContext dmlTriggerEventOnClause() {
		DmlTriggerEventOnClauseContext _localctx = new DmlTriggerEventOnClauseContext(Context, State);
		EnterRule(_localctx, 998, RULE_dmlTriggerEventOnClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5271;
			Match(ON);
			State = 5276;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,542,Context) ) {
			case 1:
				{
				State = 5272;
				nestedTableClause();
				State = 5273;
				plainIdentifier();
				}
				break;
			case 2:
				{
				State = 5275;
				plainIdentifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NestedTableClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NESTED() { return GetToken(OracleAntlrParser.NESTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		public NestedTableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nestedTableClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNestedTableClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNestedTableClause(this);
		}
	}

	[RuleVersion(0)]
	public NestedTableClauseContext nestedTableClause() {
		NestedTableClauseContext _localctx = new NestedTableClauseContext(Context, State);
		EnterRule(_localctx, 1000, RULE_nestedTableClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5278;
			Match(NESTED);
			State = 5279;
			Match(TABLE);
			State = 5280;
			simpleIdentifierWithoutParentheses();
			State = 5281;
			Match(OF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReferencingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFERENCING() { return GetToken(OracleAntlrParser.REFERENCING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ReferencingItemContext[] referencingItem() {
			return GetRuleContexts<ReferencingItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReferencingItemContext referencingItem(int i) {
			return GetRuleContext<ReferencingItemContext>(i);
		}
		public ReferencingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referencingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterReferencingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitReferencingClause(this);
		}
	}

	[RuleVersion(0)]
	public ReferencingClauseContext referencingClause() {
		ReferencingClauseContext _localctx = new ReferencingClauseContext(Context, State);
		EnterRule(_localctx, 1002, RULE_referencingClause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5283;
			Match(REFERENCING);
			State = 5285;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 5284;
					referencingItem();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5287;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,543,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReferencingItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(OracleAntlrParser.NEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OLD() { return GetToken(OracleAntlrParser.OLD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARENT() { return GetToken(OracleAntlrParser.PARENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		public ReferencingItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referencingItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterReferencingItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitReferencingItem(this);
		}
	}

	[RuleVersion(0)]
	public ReferencingItemContext referencingItem() {
		ReferencingItemContext _localctx = new ReferencingItemContext(Context, State);
		EnterRule(_localctx, 1004, RULE_referencingItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5289;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 319)) & ~0x3f) == 0 && ((1L << (_la - 319)) & ((1L << (NEW - 319)) | (1L << (OLD - 319)) | (1L << (PARENT - 319)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5291;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 5290;
				Match(AS);
				}
			}

			State = 5293;
			simpleIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForEachRowClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EACH() { return GetToken(OracleAntlrParser.EACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		public ForEachRowClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forEachRowClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForEachRowClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForEachRowClause(this);
		}
	}

	[RuleVersion(0)]
	public ForEachRowClauseContext forEachRowClause() {
		ForEachRowClauseContext _localctx = new ForEachRowClauseContext(Context, State);
		EnterRule(_localctx, 1006, RULE_forEachRowClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5295;
			Match(FOR);
			State = 5296;
			Match(EACH);
			State = 5297;
			Match(ROW);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturningClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURNING() { return GetToken(OracleAntlrParser.RETURNING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntoClauseContext intoClause() {
			return GetRuleContext<IntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BulkCollectIntoClauseContext bulkCollectIntoClause() {
			return GetRuleContext<BulkCollectIntoClauseContext>(0);
		}
		public ReturningClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returningClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterReturningClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitReturningClause(this);
		}
	}

	[RuleVersion(0)]
	public ReturningClauseContext returningClause() {
		ReturningClauseContext _localctx = new ReturningClauseContext(Context, State);
		EnterRule(_localctx, 1008, RULE_returningClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5299;
			Match(RETURNING);
			State = 5300;
			expressionList();
			State = 5303;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INTO:
				{
				State = 5301;
				intoClause();
				}
				break;
			case BULK:
				{
				State = 5302;
				bulkCollectIntoClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnlyClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLY() { return GetToken(OracleAntlrParser.ONLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public OnlyClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onlyClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOnlyClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOnlyClause(this);
		}
	}

	[RuleVersion(0)]
	public OnlyClauseContext onlyClause() {
		OnlyClauseContext _localctx = new OnlyClauseContext(Context, State);
		EnterRule(_localctx, 1010, RULE_onlyClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5305;
			Match(ONLY);
			State = 5306;
			Match(LPAREN);
			State = 5307;
			fromClauseItem();
			State = 5308;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementMemberContext[] selectStatementMember() {
			return GetRuleContexts<SelectStatementMemberContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementMemberContext selectStatementMember(int i) {
			return GetRuleContext<SelectStatementMemberContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryFactoringClauseContext subqueryFactoringClause() {
			return GetRuleContext<SubqueryFactoringClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnionOperatorContext[] unionOperator() {
			return GetRuleContexts<UnionOperatorContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnionOperatorContext unionOperator(int i) {
			return GetRuleContext<UnionOperatorContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForUpdateClauseContext forUpdateClause() {
			return GetRuleContext<ForUpdateClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryRestrictionClauseContext subqueryRestrictionClause() {
			return GetRuleContext<SubqueryRestrictionClauseContext>(0);
		}
		public SelectStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSelectStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSelectStatement(this);
		}
	}

	[RuleVersion(0)]
	public SelectStatementContext selectStatement() {
		SelectStatementContext _localctx = new SelectStatementContext(Context, State);
		EnterRule(_localctx, 1012, RULE_selectStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5311;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 5310;
				subqueryFactoringClause();
				}
			}

			State = 5313;
			selectStatementMember();
			State = 5319;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==INTERSECT || _la==MINUS || _la==UNION) {
				{
				{
				State = 5314;
				unionOperator();
				State = 5315;
				selectStatementMember();
				}
				}
				State = 5321;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5330;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ORDER:
				{
				State = 5322;
				orderByClause();
				State = 5324;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 5323;
					forUpdateClause();
					}
				}

				}
				break;
			case FOR:
				{
				State = 5326;
				forUpdateClause();
				State = 5328;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ORDER) {
					{
					State = 5327;
					orderByClause();
					}
				}

				}
				break;
			case Eof:
			case LOG:
			case MEMOPTIMIZE:
			case PARENT:
			case RETURNING:
			case WITH:
			case RPAREN:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			State = 5333;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 5332;
				subqueryRestrictionClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectStatementMemberContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BasicSelectStatementContext basicSelectStatement() {
			return GetRuleContext<BasicSelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public SelectStatementMemberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectStatementMember; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSelectStatementMember(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSelectStatementMember(this);
		}
	}

	[RuleVersion(0)]
	public SelectStatementMemberContext selectStatementMember() {
		SelectStatementMemberContext _localctx = new SelectStatementMemberContext(Context, State);
		EnterRule(_localctx, 1014, RULE_selectStatementMember);
		try {
			State = 5340;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5335;
				basicSelectStatement();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5336;
				Match(LPAREN);
				State = 5337;
				selectStatement();
				State = 5338;
				Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnionOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNION() { return GetToken(OracleAntlrParser.UNION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(OracleAntlrParser.MINUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERSECT() { return GetToken(OracleAntlrParser.INTERSECT, 0); }
		public UnionOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unionOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUnionOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUnionOperator(this);
		}
	}

	[RuleVersion(0)]
	public UnionOperatorContext unionOperator() {
		UnionOperatorContext _localctx = new UnionOperatorContext(Context, State);
		EnterRule(_localctx, 1016, RULE_unionOperator);
		try {
			State = 5347;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,553,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5342;
				Match(UNION);
				State = 5343;
				Match(ALL);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5344;
				Match(UNION);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5345;
				Match(MINUS);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5346;
				Match(INTERSECT);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithCheckOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHECK() { return GetToken(OracleAntlrParser.CHECK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTION() { return GetToken(OracleAntlrParser.OPTION, 0); }
		public WithCheckOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withCheckOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterWithCheckOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitWithCheckOption(this);
		}
	}

	[RuleVersion(0)]
	public WithCheckOptionContext withCheckOption() {
		WithCheckOptionContext _localctx = new WithCheckOptionContext(Context, State);
		EnterRule(_localctx, 1018, RULE_withCheckOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5349;
			Match(CHECK);
			State = 5350;
			Match(OPTION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithReadOnlyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READ() { return GetToken(OracleAntlrParser.READ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLY() { return GetToken(OracleAntlrParser.ONLY, 0); }
		public WithReadOnlyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withReadOnly; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterWithReadOnly(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitWithReadOnly(this);
		}
	}

	[RuleVersion(0)]
	public WithReadOnlyContext withReadOnly() {
		WithReadOnlyContext _localctx = new WithReadOnlyContext(Context, State);
		EnterRule(_localctx, 1020, RULE_withReadOnly);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5352;
			Match(READ);
			State = 5353;
			Match(ONLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OverOrderByClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDER() { return GetToken(OracleAntlrParser.ORDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OrderByListContext orderByList() {
			return GetRuleContext<OrderByListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIBLINGS() { return GetToken(OracleAntlrParser.SIBLINGS, 0); }
		public OverOrderByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_overOrderByClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOverOrderByClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOverOrderByClause(this);
		}
	}

	[RuleVersion(0)]
	public OverOrderByClauseContext overOrderByClause() {
		OverOrderByClauseContext _localctx = new OverOrderByClauseContext(Context, State);
		EnterRule(_localctx, 1022, RULE_overOrderByClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5355;
			Match(ORDER);
			State = 5357;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SIBLINGS) {
				{
				State = 5356;
				Match(SIBLINGS);
				}
			}

			State = 5359;
			Match(BY);
			State = 5360;
			orderByList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithinGroupOrderByClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDER() { return GetToken(OracleAntlrParser.ORDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OrderByListContext orderByList() {
			return GetRuleContext<OrderByListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIBLINGS() { return GetToken(OracleAntlrParser.SIBLINGS, 0); }
		public WithinGroupOrderByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withinGroupOrderByClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterWithinGroupOrderByClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitWithinGroupOrderByClause(this);
		}
	}

	[RuleVersion(0)]
	public WithinGroupOrderByClauseContext withinGroupOrderByClause() {
		WithinGroupOrderByClauseContext _localctx = new WithinGroupOrderByClauseContext(Context, State);
		EnterRule(_localctx, 1024, RULE_withinGroupOrderByClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5362;
			Match(ORDER);
			State = 5364;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SIBLINGS) {
				{
				State = 5363;
				Match(SIBLINGS);
				}
			}

			State = 5366;
			Match(BY);
			State = 5367;
			orderByList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDER() { return GetToken(OracleAntlrParser.ORDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OrderByListContext orderByList() {
			return GetRuleContext<OrderByListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIBLINGS() { return GetToken(OracleAntlrParser.SIBLINGS, 0); }
		public OrderByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOrderByClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOrderByClause(this);
		}
	}

	[RuleVersion(0)]
	public OrderByClauseContext orderByClause() {
		OrderByClauseContext _localctx = new OrderByClauseContext(Context, State);
		EnterRule(_localctx, 1026, RULE_orderByClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5369;
			Match(ORDER);
			State = 5371;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SIBLINGS) {
				{
				State = 5370;
				Match(SIBLINGS);
				}
			}

			State = 5373;
			Match(BY);
			State = 5374;
			orderByList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public OrderByListItemContext[] orderByListItem() {
			return GetRuleContexts<OrderByListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OrderByListItemContext orderByListItem(int i) {
			return GetRuleContext<OrderByListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public OrderByListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOrderByList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOrderByList(this);
		}
	}

	[RuleVersion(0)]
	public OrderByListContext orderByList() {
		OrderByListContext _localctx = new OrderByListContext(Context, State);
		EnterRule(_localctx, 1028, RULE_orderByList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5376;
			orderByListItem();
			State = 5381;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5377;
				Match(COMMA);
				State = 5378;
				orderByListItem();
				}
				}
				State = 5383;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AscDescSortAtrtributeClauseContext ascDescSortAtrtributeClause() {
			return GetRuleContext<AscDescSortAtrtributeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OrderByNullsAttributeClauseContext orderByNullsAttributeClause() {
			return GetRuleContext<OrderByNullsAttributeClauseContext>(0);
		}
		public OrderByListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOrderByListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOrderByListItem(this);
		}
	}

	[RuleVersion(0)]
	public OrderByListItemContext orderByListItem() {
		OrderByListItemContext _localctx = new OrderByListItemContext(Context, State);
		EnterRule(_localctx, 1030, RULE_orderByListItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5384;
			fullExpression();
			State = 5386;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASC || _la==DESC) {
				{
				State = 5385;
				ascDescSortAtrtributeClause();
				}
			}

			State = 5389;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NULLS) {
				{
				State = 5388;
				orderByNullsAttributeClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AscDescSortAtrtributeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASC() { return GetToken(OracleAntlrParser.ASC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DESC() { return GetToken(OracleAntlrParser.DESC, 0); }
		public AscDescSortAtrtributeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ascDescSortAtrtributeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAscDescSortAtrtributeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAscDescSortAtrtributeClause(this);
		}
	}

	[RuleVersion(0)]
	public AscDescSortAtrtributeClauseContext ascDescSortAtrtributeClause() {
		AscDescSortAtrtributeClauseContext _localctx = new AscDescSortAtrtributeClauseContext(Context, State);
		EnterRule(_localctx, 1032, RULE_ascDescSortAtrtributeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5391;
			_la = TokenStream.LA(1);
			if ( !(_la==ASC || _la==DESC) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByNullsAttributeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULLS() { return GetToken(OracleAntlrParser.NULLS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIRST() { return GetToken(OracleAntlrParser.FIRST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LAST() { return GetToken(OracleAntlrParser.LAST, 0); }
		public OrderByNullsAttributeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByNullsAttributeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOrderByNullsAttributeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOrderByNullsAttributeClause(this);
		}
	}

	[RuleVersion(0)]
	public OrderByNullsAttributeClauseContext orderByNullsAttributeClause() {
		OrderByNullsAttributeClauseContext _localctx = new OrderByNullsAttributeClauseContext(Context, State);
		EnterRule(_localctx, 1034, RULE_orderByNullsAttributeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5393;
			Match(NULLS);
			State = 5394;
			_la = TokenStream.LA(1);
			if ( !(_la==FIRST || _la==LAST) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForUpdateClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UPDATE() { return GetToken(OracleAntlrParser.UPDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterOfContext delimiterOf() {
			return GetRuleContext<DelimiterOfContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WaitOrNowaitClauseContext waitOrNowaitClause() {
			return GetRuleContext<WaitOrNowaitClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SkipLockedClauseContext skipLockedClause() {
			return GetRuleContext<SkipLockedClauseContext>(0);
		}
		public ForUpdateClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forUpdateClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForUpdateClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForUpdateClause(this);
		}
	}

	[RuleVersion(0)]
	public ForUpdateClauseContext forUpdateClause() {
		ForUpdateClauseContext _localctx = new ForUpdateClauseContext(Context, State);
		EnterRule(_localctx, 1036, RULE_forUpdateClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5396;
			Match(FOR);
			State = 5397;
			Match(UPDATE);
			State = 5401;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OF) {
				{
				State = 5398;
				delimiterOf();
				State = 5399;
				identifierList();
				}
			}

			State = 5405;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOWAIT:
			case WAIT:
				{
				State = 5403;
				waitOrNowaitClause();
				}
				break;
			case SKIP_:
				{
				State = 5404;
				skipLockedClause();
				}
				break;
			case Eof:
			case LOG:
			case MEMOPTIMIZE:
			case ORDER:
			case PARENT:
			case RETURNING:
			case WITH:
			case RPAREN:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterOfContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		public DelimiterOfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterOf; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterOf(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterOf(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterOfContext delimiterOf() {
		DelimiterOfContext _localctx = new DelimiterOfContext(Context, State);
		EnterRule(_localctx, 1038, RULE_delimiterOf);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5407;
			Match(OF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WaitOrNowaitClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOWAIT() { return GetToken(OracleAntlrParser.NOWAIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WAIT() { return GetToken(OracleAntlrParser.WAIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public WaitOrNowaitClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_waitOrNowaitClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterWaitOrNowaitClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitWaitOrNowaitClause(this);
		}
	}

	[RuleVersion(0)]
	public WaitOrNowaitClauseContext waitOrNowaitClause() {
		WaitOrNowaitClauseContext _localctx = new WaitOrNowaitClauseContext(Context, State);
		EnterRule(_localctx, 1040, RULE_waitOrNowaitClause);
		try {
			State = 5412;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOWAIT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5409;
				Match(NOWAIT);
				}
				break;
			case WAIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5410;
				Match(WAIT);
				State = 5411;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SkipLockedClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SKIP_() { return GetToken(OracleAntlrParser.SKIP_, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCKED() { return GetToken(OracleAntlrParser.LOCKED, 0); }
		public SkipLockedClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_skipLockedClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSkipLockedClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSkipLockedClause(this);
		}
	}

	[RuleVersion(0)]
	public SkipLockedClauseContext skipLockedClause() {
		SkipLockedClauseContext _localctx = new SkipLockedClauseContext(Context, State);
		EnterRule(_localctx, 1042, RULE_skipLockedClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5414;
			Match(SKIP_);
			State = 5415;
			Match(LOCKED);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryFactoringClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryFactoringClauseItemContext[] subqueryFactoringClauseItem() {
			return GetRuleContexts<SubqueryFactoringClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryFactoringClauseItemContext subqueryFactoringClauseItem(int i) {
			return GetRuleContext<SubqueryFactoringClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public SubqueryFactoringClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryFactoringClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubqueryFactoringClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubqueryFactoringClause(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryFactoringClauseContext subqueryFactoringClause() {
		SubqueryFactoringClauseContext _localctx = new SubqueryFactoringClauseContext(Context, State);
		EnterRule(_localctx, 1044, RULE_subqueryFactoringClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5417;
			Match(WITH);
			State = 5418;
			subqueryFactoringClauseItem();
			State = 5423;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5419;
				Match(COMMA);
				State = 5420;
				subqueryFactoringClauseItem();
				}
				}
				State = 5425;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryFactoringClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AsFlattenedQueryContext asFlattenedQuery() {
			return GetRuleContext<AsFlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryFactoringColumnsListContext subqueryFactoringColumnsList() {
			return GetRuleContext<SubqueryFactoringColumnsListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SearchClauseContext searchClause() {
			return GetRuleContext<SearchClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CycleClauseContext cycleClause() {
			return GetRuleContext<CycleClauseContext>(0);
		}
		public SubqueryFactoringClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryFactoringClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubqueryFactoringClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubqueryFactoringClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryFactoringClauseItemContext subqueryFactoringClauseItem() {
		SubqueryFactoringClauseItemContext _localctx = new SubqueryFactoringClauseItemContext(Context, State);
		EnterRule(_localctx, 1046, RULE_subqueryFactoringClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5426;
			plainIdentifier();
			State = 5428;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 5427;
				subqueryFactoringColumnsList();
				}
			}

			State = 5430;
			asFlattenedQuery();
			State = 5432;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SEARCH) {
				{
				State = 5431;
				searchClause();
				}
			}

			State = 5435;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CYCLE) {
				{
				State = 5434;
				cycleClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryFactoringColumnsListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public SubqueryFactoringColumnsListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryFactoringColumnsList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubqueryFactoringColumnsList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubqueryFactoringColumnsList(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryFactoringColumnsListContext subqueryFactoringColumnsList() {
		SubqueryFactoringColumnsListContext _localctx = new SubqueryFactoringColumnsListContext(Context, State);
		EnterRule(_localctx, 1048, RULE_subqueryFactoringColumnsList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5437;
			Match(LPAREN);
			State = 5438;
			identifierList();
			State = 5439;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SearchClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEARCH() { return GetToken(OracleAntlrParser.SEARCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIRST() { return GetToken(OracleAntlrParser.FIRST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OrderByListContext orderByList() {
			return GetRuleContext<OrderByListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryFactoringSetClauseContext subqueryFactoringSetClause() {
			return GetRuleContext<SubqueryFactoringSetClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEPTH() { return GetToken(OracleAntlrParser.DEPTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BREADTH() { return GetToken(OracleAntlrParser.BREADTH, 0); }
		public SearchClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searchClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSearchClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSearchClause(this);
		}
	}

	[RuleVersion(0)]
	public SearchClauseContext searchClause() {
		SearchClauseContext _localctx = new SearchClauseContext(Context, State);
		EnterRule(_localctx, 1050, RULE_searchClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5441;
			Match(SEARCH);
			State = 5442;
			_la = TokenStream.LA(1);
			if ( !(_la==BREADTH || _la==DEPTH) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5443;
			Match(FIRST);
			State = 5444;
			Match(BY);
			State = 5445;
			orderByList();
			State = 5446;
			subqueryFactoringSetClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryFactoringSetClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public SubqueryFactoringSetClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryFactoringSetClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubqueryFactoringSetClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubqueryFactoringSetClause(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryFactoringSetClauseContext subqueryFactoringSetClause() {
		SubqueryFactoringSetClauseContext _localctx = new SubqueryFactoringSetClauseContext(Context, State);
		EnterRule(_localctx, 1052, RULE_subqueryFactoringSetClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5448;
			Match(SET);
			State = 5449;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CycleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CYCLE() { return GetToken(OracleAntlrParser.CYCLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryFactoringSetClauseContext subqueryFactoringSetClause() {
			return GetRuleContext<SubqueryFactoringSetClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ToCycleClauseContext toCycleClause() {
			return GetRuleContext<ToCycleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultCycleClauseContext defaultCycleClause() {
			return GetRuleContext<DefaultCycleClauseContext>(0);
		}
		public CycleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cycleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCycleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCycleClause(this);
		}
	}

	[RuleVersion(0)]
	public CycleClauseContext cycleClause() {
		CycleClauseContext _localctx = new CycleClauseContext(Context, State);
		EnterRule(_localctx, 1054, RULE_cycleClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5451;
			Match(CYCLE);
			State = 5452;
			identifierList();
			State = 5453;
			subqueryFactoringSetClause();
			State = 5454;
			toCycleClause();
			State = 5455;
			defaultCycleClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ToCycleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(OracleAntlrParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ToCycleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_toCycleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterToCycleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitToCycleClause(this);
		}
	}

	[RuleVersion(0)]
	public ToCycleClauseContext toCycleClause() {
		ToCycleClauseContext _localctx = new ToCycleClauseContext(Context, State);
		EnterRule(_localctx, 1056, RULE_toCycleClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5457;
			Match(TO);
			State = 5458;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefaultCycleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public DefaultCycleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defaultCycleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDefaultCycleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDefaultCycleClause(this);
		}
	}

	[RuleVersion(0)]
	public DefaultCycleClauseContext defaultCycleClause() {
		DefaultCycleClauseContext _localctx = new DefaultCycleClauseContext(Context, State);
		EnterRule(_localctx, 1058, RULE_defaultCycleClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5460;
			Match(DEFAULT);
			State = 5461;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BasicSelectStatementContext : ParserRuleContext {
		public HavingClauseContext havingFirst;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SELECT() { return GetToken(OracleAntlrParser.SELECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectExpressionListContext selectExpressionList() {
			return GetRuleContext<SelectExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseContext fromClause() {
			return GetRuleContext<FromClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntoClauseContext intoClause() {
			return GetRuleContext<IntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BulkCollectIntoClauseContext bulkCollectIntoClause() {
			return GetRuleContext<BulkCollectIntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConnectByClauseContext connectByClause() {
			return GetRuleContext<ConnectByClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StartWithClauseContext startWithClause() {
			return GetRuleContext<StartWithClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupByClauseContext groupByClause() {
			return GetRuleContext<GroupByClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISTINCT() { return GetToken(OracleAntlrParser.DISTINCT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUE() { return GetToken(OracleAntlrParser.UNIQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public HavingClauseContext havingClause() {
			return GetRuleContext<HavingClauseContext>(0);
		}
		public BasicSelectStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_basicSelectStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBasicSelectStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBasicSelectStatement(this);
		}
	}

	[RuleVersion(0)]
	public BasicSelectStatementContext basicSelectStatement() {
		BasicSelectStatementContext _localctx = new BasicSelectStatementContext(Context, State);
		EnterRule(_localctx, 1060, RULE_basicSelectStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5463;
			Match(SELECT);
			State = 5465;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==DISTINCT || _la==UNIQUE) {
				{
				State = 5464;
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==DISTINCT || _la==UNIQUE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 5467;
			selectExpressionList();
			State = 5470;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INTO:
				{
				State = 5468;
				intoClause();
				}
				break;
			case BULK:
				{
				State = 5469;
				bulkCollectIntoClause();
				}
				break;
			case FROM:
				break;
			default:
				break;
			}
			State = 5472;
			fromClause();
			State = 5474;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 5473;
				whereClause();
				}
			}

			State = 5483;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CONNECT:
				{
				State = 5476;
				connectByClause();
				State = 5478;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==START) {
					{
					State = 5477;
					startWithClause();
					}
				}

				}
				break;
			case START:
				{
				State = 5480;
				startWithClause();
				State = 5481;
				connectByClause();
				}
				break;
			case Eof:
			case FOR:
			case GROUP:
			case HAVING:
			case INTERSECT:
			case LOG:
			case MEMOPTIMIZE:
			case MINUS:
			case ORDER:
			case PARENT:
			case RETURNING:
			case UNION:
			case WITH:
			case RPAREN:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			State = 5493;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case GROUP:
				{
				State = 5485;
				groupByClause();
				State = 5487;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==HAVING) {
					{
					State = 5486;
					havingClause();
					}
				}

				}
				break;
			case HAVING:
				{
				State = 5489;
				_localctx.havingFirst = havingClause();
				State = 5491;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==GROUP) {
					{
					State = 5490;
					groupByClause();
					}
				}

				}
				break;
			case Eof:
			case FOR:
			case INTERSECT:
			case LOG:
			case MEMOPTIMIZE:
			case MINUS:
			case ORDER:
			case PARENT:
			case RETURNING:
			case UNION:
			case WITH:
			case RPAREN:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public SelectExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSelectExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSelectExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public SelectExpressionListContext selectExpressionList() {
		SelectExpressionListContext _localctx = new SelectExpressionListContext(Context, State);
		EnterRule(_localctx, 1062, RULE_selectExpressionList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5495;
			expressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntoClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		public IntoClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intoClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIntoClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIntoClause(this);
		}
	}

	[RuleVersion(0)]
	public IntoClauseContext intoClause() {
		IntoClauseContext _localctx = new IntoClauseContext(Context, State);
		EnterRule(_localctx, 1064, RULE_intoClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5497;
			Match(INTO);
			State = 5498;
			identifierList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhereClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHERE() { return GetToken(OracleAntlrParser.WHERE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public WhereClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whereClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterWhereClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitWhereClause(this);
		}
	}

	[RuleVersion(0)]
	public WhereClauseContext whereClause() {
		WhereClauseContext _localctx = new WhereClauseContext(Context, State);
		EnterRule(_localctx, 1066, RULE_whereClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5500;
			Match(WHERE);
			State = 5501;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUP() { return GetToken(OracleAntlrParser.GROUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GroupByClauseExpressionListContext groupByClauseExpressionList() {
			return GetRuleContext<GroupByClauseExpressionListContext>(0);
		}
		public GroupByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGroupByClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGroupByClause(this);
		}
	}

	[RuleVersion(0)]
	public GroupByClauseContext groupByClause() {
		GroupByClauseContext _localctx = new GroupByClauseContext(Context, State);
		EnterRule(_localctx, 1068, RULE_groupByClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5503;
			Match(GROUP);
			State = 5504;
			Match(BY);
			State = 5505;
			groupByClauseExpressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByClauseExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GroupByComplexExpressionListContext groupByComplexExpressionList() {
			return GetRuleContext<GroupByComplexExpressionListContext>(0);
		}
		public GroupByClauseExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByClauseExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGroupByClauseExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGroupByClauseExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public GroupByClauseExpressionListContext groupByClauseExpressionList() {
		GroupByClauseExpressionListContext _localctx = new GroupByClauseExpressionListContext(Context, State);
		EnterRule(_localctx, 1070, RULE_groupByClauseExpressionList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5507;
			groupByComplexExpressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByComplexExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GroupByComplexListExpressionItemContext[] groupByComplexListExpressionItem() {
			return GetRuleContexts<GroupByComplexListExpressionItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupByComplexListExpressionItemContext groupByComplexListExpressionItem(int i) {
			return GetRuleContext<GroupByComplexListExpressionItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public GroupByComplexExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByComplexExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGroupByComplexExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGroupByComplexExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public GroupByComplexExpressionListContext groupByComplexExpressionList() {
		GroupByComplexExpressionListContext _localctx = new GroupByComplexExpressionListContext(Context, State);
		EnterRule(_localctx, 1072, RULE_groupByComplexExpressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5509;
			groupByComplexListExpressionItem();
			State = 5514;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5510;
				Match(COMMA);
				State = 5511;
				groupByComplexListExpressionItem();
				}
				}
				State = 5516;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByComplexListExpressionItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GroupByClauseExpressionListItemContext groupByClauseExpressionListItem() {
			return GetRuleContext<GroupByClauseExpressionListItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupByComplexExpressionListWithParenthesisContext groupByComplexExpressionListWithParenthesis() {
			return GetRuleContext<GroupByComplexExpressionListWithParenthesisContext>(0);
		}
		public GroupByComplexListExpressionItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByComplexListExpressionItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGroupByComplexListExpressionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGroupByComplexListExpressionItem(this);
		}
	}

	[RuleVersion(0)]
	public GroupByComplexListExpressionItemContext groupByComplexListExpressionItem() {
		GroupByComplexListExpressionItemContext _localctx = new GroupByComplexListExpressionItemContext(Context, State);
		EnterRule(_localctx, 1074, RULE_groupByComplexListExpressionItem);
		try {
			State = 5519;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,576,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5517;
				groupByClauseExpressionListItem();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5518;
				groupByComplexExpressionListWithParenthesis();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByComplexExpressionListWithParenthesisContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GroupByComplexListExpressionItemContext[] groupByComplexListExpressionItem() {
			return GetRuleContexts<GroupByComplexListExpressionItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupByComplexListExpressionItemContext groupByComplexListExpressionItem(int i) {
			return GetRuleContext<GroupByComplexListExpressionItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public GroupByComplexExpressionListWithParenthesisContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByComplexExpressionListWithParenthesis; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGroupByComplexExpressionListWithParenthesis(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGroupByComplexExpressionListWithParenthesis(this);
		}
	}

	[RuleVersion(0)]
	public GroupByComplexExpressionListWithParenthesisContext groupByComplexExpressionListWithParenthesis() {
		GroupByComplexExpressionListWithParenthesisContext _localctx = new GroupByComplexExpressionListWithParenthesisContext(Context, State);
		EnterRule(_localctx, 1076, RULE_groupByComplexExpressionListWithParenthesis);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5521;
			Match(LPAREN);
			State = 5522;
			groupByComplexListExpressionItem();
			State = 5527;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5523;
				Match(COMMA);
				State = 5524;
				groupByComplexListExpressionItem();
				}
				}
				State = 5529;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5530;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByClauseExpressionListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RollupCubeClauseContext rollupCubeClause() {
			return GetRuleContext<RollupCubeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupingSetsClauseContext groupingSetsClause() {
			return GetRuleContext<GroupingSetsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GrandTotalContext grandTotal() {
			return GetRuleContext<GrandTotalContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public GroupByClauseExpressionListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByClauseExpressionListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGroupByClauseExpressionListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGroupByClauseExpressionListItem(this);
		}
	}

	[RuleVersion(0)]
	public GroupByClauseExpressionListItemContext groupByClauseExpressionListItem() {
		GroupByClauseExpressionListItemContext _localctx = new GroupByClauseExpressionListItemContext(Context, State);
		EnterRule(_localctx, 1078, RULE_groupByClauseExpressionListItem);
		try {
			State = 5536;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,578,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5532;
				rollupCubeClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5533;
				groupingSetsClause();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5534;
				grandTotal();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5535;
				fullExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GrandTotalContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public GrandTotalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grandTotal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGrandTotal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGrandTotal(this);
		}
	}

	[RuleVersion(0)]
	public GrandTotalContext grandTotal() {
		GrandTotalContext _localctx = new GrandTotalContext(Context, State);
		EnterRule(_localctx, 1080, RULE_grandTotal);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5538;
			Match(LPAREN);
			State = 5539;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingSetsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUPING() { return GetToken(OracleAntlrParser.GROUPING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETS() { return GetToken(OracleAntlrParser.SETS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GroupingSetsListContext groupingSetsList() {
			return GetRuleContext<GroupingSetsListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public GroupingSetsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingSetsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGroupingSetsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGroupingSetsClause(this);
		}
	}

	[RuleVersion(0)]
	public GroupingSetsClauseContext groupingSetsClause() {
		GroupingSetsClauseContext _localctx = new GroupingSetsClauseContext(Context, State);
		EnterRule(_localctx, 1082, RULE_groupingSetsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5541;
			Match(GROUPING);
			State = 5542;
			Match(SETS);
			State = 5543;
			Match(LPAREN);
			State = 5544;
			groupingSetsList();
			State = 5545;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingSetsListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GroupingSetContext[] groupingSet() {
			return GetRuleContexts<GroupingSetContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupingSetContext groupingSet(int i) {
			return GetRuleContext<GroupingSetContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public GroupingSetsListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingSetsList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGroupingSetsList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGroupingSetsList(this);
		}
	}

	[RuleVersion(0)]
	public GroupingSetsListContext groupingSetsList() {
		GroupingSetsListContext _localctx = new GroupingSetsListContext(Context, State);
		EnterRule(_localctx, 1084, RULE_groupingSetsList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5547;
			groupingSet();
			State = 5552;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5548;
				Match(COMMA);
				State = 5549;
				groupingSet();
				}
				}
				State = 5554;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingSetContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GrandTotalContext grandTotal() {
			return GetRuleContext<GrandTotalContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupingSetItemListContext groupingSetItemList() {
			return GetRuleContext<GroupingSetItemListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupingSetItemContext groupingSetItem() {
			return GetRuleContext<GroupingSetItemContext>(0);
		}
		public GroupingSetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingSet; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGroupingSet(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGroupingSet(this);
		}
	}

	[RuleVersion(0)]
	public GroupingSetContext groupingSet() {
		GroupingSetContext _localctx = new GroupingSetContext(Context, State);
		EnterRule(_localctx, 1086, RULE_groupingSet);
		try {
			State = 5558;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,580,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5555;
				grandTotal();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5556;
				groupingSetItemList();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5557;
				groupingSetItem();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingSetItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RollupCubeClauseContext rollupCubeClause() {
			return GetRuleContext<RollupCubeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public GroupingSetItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingSetItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGroupingSetItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGroupingSetItem(this);
		}
	}

	[RuleVersion(0)]
	public GroupingSetItemContext groupingSetItem() {
		GroupingSetItemContext _localctx = new GroupingSetItemContext(Context, State);
		EnterRule(_localctx, 1088, RULE_groupingSetItem);
		try {
			State = 5562;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,581,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5560;
				rollupCubeClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5561;
				fullExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingSetItemListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public GroupingSetItemListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingSetItemList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGroupingSetItemList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGroupingSetItemList(this);
		}
	}

	[RuleVersion(0)]
	public GroupingSetItemListContext groupingSetItemList() {
		GroupingSetItemListContext _localctx = new GroupingSetItemListContext(Context, State);
		EnterRule(_localctx, 1090, RULE_groupingSetItemList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5564;
			Match(LPAREN);
			State = 5565;
			fullExpression();
			State = 5570;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5566;
				Match(COMMA);
				State = 5567;
				fullExpression();
				}
				}
				State = 5572;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5573;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RollupCubeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GroupingExpressionListContext groupingExpressionList() {
			return GetRuleContext<GroupingExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLLUP() { return GetToken(OracleAntlrParser.ROLLUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CUBE() { return GetToken(OracleAntlrParser.CUBE, 0); }
		public RollupCubeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollupCubeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRollupCubeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRollupCubeClause(this);
		}
	}

	[RuleVersion(0)]
	public RollupCubeClauseContext rollupCubeClause() {
		RollupCubeClauseContext _localctx = new RollupCubeClauseContext(Context, State);
		EnterRule(_localctx, 1092, RULE_rollupCubeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5575;
			_la = TokenStream.LA(1);
			if ( !(_la==CUBE || _la==ROLLUP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5576;
			Match(LPAREN);
			State = 5577;
			groupingExpressionList();
			State = 5578;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GroupingExpressionListItemContext[] groupingExpressionListItem() {
			return GetRuleContexts<GroupingExpressionListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupingExpressionListItemContext groupingExpressionListItem(int i) {
			return GetRuleContext<GroupingExpressionListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public GroupingExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGroupingExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGroupingExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public GroupingExpressionListContext groupingExpressionList() {
		GroupingExpressionListContext _localctx = new GroupingExpressionListContext(Context, State);
		EnterRule(_localctx, 1094, RULE_groupingExpressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5580;
			groupingExpressionListItem();
			State = 5585;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5581;
				Match(COMMA);
				State = 5582;
				groupingExpressionListItem();
				}
				}
				State = 5587;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingExpressionListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GroupingExpressionNestedItemContext groupingExpressionNestedItem() {
			return GetRuleContext<GroupingExpressionNestedItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public GroupingExpressionListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingExpressionListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGroupingExpressionListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGroupingExpressionListItem(this);
		}
	}

	[RuleVersion(0)]
	public GroupingExpressionListItemContext groupingExpressionListItem() {
		GroupingExpressionListItemContext _localctx = new GroupingExpressionListItemContext(Context, State);
		EnterRule(_localctx, 1096, RULE_groupingExpressionListItem);
		try {
			State = 5590;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,584,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5588;
				groupingExpressionNestedItem();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5589;
				fullExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupingExpressionNestedItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public GroupingExpressionNestedItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupingExpressionNestedItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGroupingExpressionNestedItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGroupingExpressionNestedItem(this);
		}
	}

	[RuleVersion(0)]
	public GroupingExpressionNestedItemContext groupingExpressionNestedItem() {
		GroupingExpressionNestedItemContext _localctx = new GroupingExpressionNestedItemContext(Context, State);
		EnterRule(_localctx, 1098, RULE_groupingExpressionNestedItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5592;
			Match(LPAREN);
			State = 5593;
			fullExpression();
			State = 5598;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5594;
				Match(COMMA);
				State = 5595;
				fullExpression();
				}
				}
				State = 5600;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5601;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConnectByClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONNECT() { return GetToken(OracleAntlrParser.CONNECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCYCLE() { return GetToken(OracleAntlrParser.NOCYCLE, 0); }
		public ConnectByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_connectByClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConnectByClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConnectByClause(this);
		}
	}

	[RuleVersion(0)]
	public ConnectByClauseContext connectByClause() {
		ConnectByClauseContext _localctx = new ConnectByClauseContext(Context, State);
		EnterRule(_localctx, 1100, RULE_connectByClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5603;
			Match(CONNECT);
			State = 5604;
			Match(BY);
			State = 5606;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,586,Context) ) {
			case 1:
				{
				State = 5605;
				Match(NOCYCLE);
				}
				break;
			}
			State = 5608;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartWithClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode START() { return GetToken(OracleAntlrParser.START, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public StartWithClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startWithClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterStartWithClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitStartWithClause(this);
		}
	}

	[RuleVersion(0)]
	public StartWithClauseContext startWithClause() {
		StartWithClauseContext _localctx = new StartWithClauseContext(Context, State);
		EnterRule(_localctx, 1102, RULE_startWithClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5610;
			Match(START);
			State = 5611;
			Match(WITH);
			State = 5612;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HavingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HAVING() { return GetToken(OracleAntlrParser.HAVING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public HavingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_havingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterHavingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitHavingClause(this);
		}
	}

	[RuleVersion(0)]
	public HavingClauseContext havingClause() {
		HavingClauseContext _localctx = new HavingClauseContext(Context, State);
		EnterRule(_localctx, 1104, RULE_havingClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5614;
			Match(HAVING);
			State = 5615;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FromClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(OracleAntlrParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ComplexFromClauseItemContext[] complexFromClauseItem() {
			return GetRuleContexts<ComplexFromClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComplexFromClauseItemContext complexFromClauseItem(int i) {
			return GetRuleContext<ComplexFromClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public FromClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fromClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFromClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFromClause(this);
		}
	}

	[RuleVersion(0)]
	public FromClauseContext fromClause() {
		FromClauseContext _localctx = new FromClauseContext(Context, State);
		EnterRule(_localctx, 1106, RULE_fromClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5617;
			Match(FROM);
			State = 5618;
			complexFromClauseItem();
			State = 5623;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5619;
				Match(COMMA);
				State = 5620;
				complexFromClauseItem();
				}
				}
				State = 5625;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComplexFromClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ComplexFromClauseItemInnerContext complexFromClauseItemInner() {
			return GetRuleContext<ComplexFromClauseItemInnerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PivotUnpivotClauseContext pivotUnpivotClause() {
			return GetRuleContext<PivotUnpivotClauseContext>(0);
		}
		public ComplexFromClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_complexFromClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterComplexFromClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitComplexFromClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public ComplexFromClauseItemContext complexFromClauseItem() {
		ComplexFromClauseItemContext _localctx = new ComplexFromClauseItemContext(Context, State);
		EnterRule(_localctx, 1108, RULE_complexFromClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5626;
			complexFromClauseItemInner();
			State = 5628;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PIVOT || _la==UNPIVOT) {
				{
				State = 5627;
				pivotUnpivotClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComplexFromClauseItemInnerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public QueryPartitionClauseContext queryPartitionClause() {
			return GetRuleContext<QueryPartitionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NormalJoinTypeContext[] normalJoinType() {
			return GetRuleContexts<NormalJoinTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NormalJoinTypeContext normalJoinType(int i) {
			return GetRuleContext<NormalJoinTypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComplexFromClauseItemInnerContext[] complexFromClauseItemInner() {
			return GetRuleContexts<ComplexFromClauseItemInnerContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComplexFromClauseItemInnerContext complexFromClauseItemInner(int i) {
			return GetRuleContext<ComplexFromClauseItemInnerContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CrossOrNaturalJoinContext[] crossOrNaturalJoin() {
			return GetRuleContexts<CrossOrNaturalJoinContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CrossOrNaturalJoinContext crossOrNaturalJoin(int i) {
			return GetRuleContext<CrossOrNaturalJoinContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnConditionContext[] onCondition() {
			return GetRuleContexts<OnConditionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnConditionContext onCondition(int i) {
			return GetRuleContext<OnConditionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingConditionContext[] usingCondition() {
			return GetRuleContexts<UsingConditionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingConditionContext usingCondition(int i) {
			return GetRuleContext<UsingConditionContext>(i);
		}
		public ComplexFromClauseItemInnerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_complexFromClauseItemInner; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterComplexFromClauseItemInner(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitComplexFromClauseItemInner(this);
		}
	}

	[RuleVersion(0)]
	public ComplexFromClauseItemInnerContext complexFromClauseItemInner() {
		ComplexFromClauseItemInnerContext _localctx = new ComplexFromClauseItemInnerContext(Context, State);
		EnterRule(_localctx, 1110, RULE_complexFromClauseItemInner);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5630;
			fromClauseItem();
			State = 5632;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 5631;
				queryPartitionClause();
				}
			}

			State = 5645;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,592,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 5643;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case FULL:
					case INNER:
					case JOIN:
					case LEFT:
					case RIGHT:
						{
						State = 5634;
						normalJoinType();
						State = 5635;
						complexFromClauseItemInner();
						State = 5638;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,590,Context) ) {
						case 1:
							{
							State = 5636;
							onCondition();
							}
							break;
						case 2:
							{
							State = 5637;
							usingCondition();
							}
							break;
						}
						}
						break;
					case CROSS:
					case NATURAL:
						{
						State = 5640;
						crossOrNaturalJoin();
						State = 5641;
						complexFromClauseItemInner();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 5647;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,592,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CrossOrNaturalJoinContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CROSS() { return GetToken(OracleAntlrParser.CROSS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JOIN() { return GetToken(OracleAntlrParser.JOIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NATURAL() { return GetToken(OracleAntlrParser.NATURAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INNER() { return GetToken(OracleAntlrParser.INNER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OuterJoinTypeContext outerJoinType() {
			return GetRuleContext<OuterJoinTypeContext>(0);
		}
		public CrossOrNaturalJoinContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_crossOrNaturalJoin; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCrossOrNaturalJoin(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCrossOrNaturalJoin(this);
		}
	}

	[RuleVersion(0)]
	public CrossOrNaturalJoinContext crossOrNaturalJoin() {
		CrossOrNaturalJoinContext _localctx = new CrossOrNaturalJoinContext(Context, State);
		EnterRule(_localctx, 1112, RULE_crossOrNaturalJoin);
		try {
			State = 5656;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CROSS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5648;
				Match(CROSS);
				State = 5649;
				Match(JOIN);
				}
				break;
			case NATURAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5650;
				Match(NATURAL);
				State = 5653;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case INNER:
					{
					State = 5651;
					Match(INNER);
					}
					break;
				case FULL:
				case LEFT:
				case RIGHT:
					{
					State = 5652;
					outerJoinType();
					}
					break;
				case JOIN:
					break;
				default:
					break;
				}
				State = 5655;
				Match(JOIN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NormalJoinTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JOIN() { return GetToken(OracleAntlrParser.JOIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OuterJoinTypeContext outerJoinType() {
			return GetRuleContext<OuterJoinTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INNER() { return GetToken(OracleAntlrParser.INNER, 0); }
		public NormalJoinTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_normalJoinType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNormalJoinType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNormalJoinType(this);
		}
	}

	[RuleVersion(0)]
	public NormalJoinTypeContext normalJoinType() {
		NormalJoinTypeContext _localctx = new NormalJoinTypeContext(Context, State);
		EnterRule(_localctx, 1114, RULE_normalJoinType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5660;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FULL:
			case LEFT:
			case RIGHT:
				{
				State = 5658;
				outerJoinType();
				}
				break;
			case INNER:
				{
				State = 5659;
				Match(INNER);
				}
				break;
			case JOIN:
				break;
			default:
				break;
			}
			State = 5662;
			Match(JOIN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OuterJoinTypeContext : ParserRuleContext {
		public IToken type;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEFT() { return GetToken(OracleAntlrParser.LEFT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RIGHT() { return GetToken(OracleAntlrParser.RIGHT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FULL() { return GetToken(OracleAntlrParser.FULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OUTER() { return GetToken(OracleAntlrParser.OUTER, 0); }
		public OuterJoinTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outerJoinType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOuterJoinType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOuterJoinType(this);
		}
	}

	[RuleVersion(0)]
	public OuterJoinTypeContext outerJoinType() {
		OuterJoinTypeContext _localctx = new OuterJoinTypeContext(Context, State);
		EnterRule(_localctx, 1116, RULE_outerJoinType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5664;
			_localctx.type = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==FULL || _la==LEFT || _la==RIGHT) ) {
				_localctx.type = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5666;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OUTER) {
				{
				State = 5665;
				Match(OUTER);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public OnConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOnCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOnCondition(this);
		}
	}

	[RuleVersion(0)]
	public OnConditionContext onCondition() {
		OnConditionContext _localctx = new OnConditionContext(Context, State);
		EnterRule(_localctx, 1118, RULE_onCondition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5668;
			Match(ON);
			State = 5669;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public UsingConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUsingCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUsingCondition(this);
		}
	}

	[RuleVersion(0)]
	public UsingConditionContext usingCondition() {
		UsingConditionContext _localctx = new UsingConditionContext(Context, State);
		EnterRule(_localctx, 1120, RULE_usingCondition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5671;
			Match(USING);
			State = 5672;
			Match(LPAREN);
			State = 5673;
			identifier();
			State = 5678;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5674;
				Match(COMMA);
				State = 5675;
				identifier();
				}
				}
				State = 5680;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5681;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryPartitionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public QueryPartitionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryPartitionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterQueryPartitionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitQueryPartitionClause(this);
		}
	}

	[RuleVersion(0)]
	public QueryPartitionClauseContext queryPartitionClause() {
		QueryPartitionClauseContext _localctx = new QueryPartitionClauseContext(Context, State);
		EnterRule(_localctx, 1122, RULE_queryPartitionClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5683;
			Match(PARTITION);
			State = 5684;
			Match(BY);
			State = 5685;
			Match(LPAREN);
			State = 5686;
			expressionList();
			State = 5687;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FromClauseItemPartitionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		public FromClauseItemPartitionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fromClauseItemPartitionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFromClauseItemPartitionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFromClauseItemPartitionClause(this);
		}
	}

	[RuleVersion(0)]
	public FromClauseItemPartitionClauseContext fromClauseItemPartitionClause() {
		FromClauseItemPartitionClauseContext _localctx = new FromClauseItemPartitionClauseContext(Context, State);
		EnterRule(_localctx, 1124, RULE_fromClauseItemPartitionClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5689;
			_la = TokenStream.LA(1);
			if ( !(_la==PARTITION || _la==SUBPARTITION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5690;
			Match(LPAREN);
			State = 5691;
			identifier();
			State = 5692;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FromClauseItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ComplexFromClauseItemContext complexFromClauseItem() {
			return GetRuleContext<ComplexFromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlTableItemContext xmlTableItem() {
			return GetRuleContext<XmlTableItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryNestedTableContext flattenedQueryNestedTable() {
			return GetRuleContext<FlattenedQueryNestedTableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonTableContext jsonTable() {
			return GetRuleContext<JsonTableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FlashbackAndPivotClausesContext flashbackAndPivotClauses() {
			return GetRuleContext<FlashbackAndPivotClausesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemPartitionClauseContext fromClauseItemPartitionClause() {
			return GetRuleContext<FromClauseItemPartitionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SampleClauseContext sampleClause() {
			return GetRuleContext<SampleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AliasIdentifierContext aliasIdentifier() {
			return GetRuleContext<AliasIdentifierContext>(0);
		}
		public FromClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fromClauseItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFromClauseItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFromClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public FromClauseItemContext fromClauseItem() {
		FromClauseItemContext _localctx = new FromClauseItemContext(Context, State);
		EnterRule(_localctx, 1126, RULE_fromClauseItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5710;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,600,Context) ) {
			case 1:
				{
				State = 5694;
				plainIdentifier();
				State = 5700;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,599,Context) ) {
				case 1:
					{
					State = 5695;
					fromClauseItemPartitionClause();
					State = 5697;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,598,Context) ) {
					case 1:
						{
						State = 5696;
						sampleClause();
						}
						break;
					}
					}
					break;
				case 2:
					{
					State = 5699;
					sampleClause();
					}
					break;
				}
				}
				break;
			case 2:
				{
				State = 5702;
				Match(LPAREN);
				State = 5703;
				complexFromClauseItem();
				State = 5704;
				Match(RPAREN);
				}
				break;
			case 3:
				{
				State = 5706;
				xmlTableItem();
				}
				break;
			case 4:
				{
				State = 5707;
				flattenedQueryNestedTable();
				}
				break;
			case 5:
				{
				State = 5708;
				flattenedQuery();
				}
				break;
			case 6:
				{
				State = 5709;
				jsonTable();
				}
				break;
			}
			State = 5713;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,601,Context) ) {
			case 1:
				{
				State = 5712;
				flashbackAndPivotClauses();
				}
				break;
			}
			State = 5720;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,603,Context) ) {
			case 1:
				{
				State = 5715;
				if (!(IsAliasIdentifier())) throw new FailedPredicateException(this, "IsAliasIdentifier()");
				State = 5717;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,602,Context) ) {
				case 1:
					{
					State = 5716;
					aliasIdentifier();
					}
					break;
				}
				}
				break;
			case 2:
				{
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonTableContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JSON_TABLE() { return GetToken(OracleAntlrParser.JSON_TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonColumnsClauseContext jsonColumnsClause() {
			return GetRuleContext<JsonColumnsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORMAT() { return GetToken(OracleAntlrParser.FORMAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JSON() { return GetToken(OracleAntlrParser.JSON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonExpressionContext jsonExpression() {
			return GetRuleContext<JsonExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonTableOnClauseContext[] jsonTableOnClause() {
			return GetRuleContexts<JsonTableOnClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonTableOnClauseContext jsonTableOnClause(int i) {
			return GetRuleContext<JsonTableOnClauseContext>(i);
		}
		public JsonTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonTable; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonTable(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonTable(this);
		}
	}

	[RuleVersion(0)]
	public JsonTableContext jsonTable() {
		JsonTableContext _localctx = new JsonTableContext(Context, State);
		EnterRule(_localctx, 1128, RULE_jsonTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5722;
			Match(JSON_TABLE);
			State = 5723;
			Match(LPAREN);
			State = 5724;
			fullExpression();
			State = 5727;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FORMAT) {
				{
				State = 5725;
				Match(FORMAT);
				State = 5726;
				Match(JSON);
				}
			}

			State = 5731;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 5729;
				Match(COMMA);
				State = 5730;
				jsonExpression();
				}
			}

			State = 5736;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ERROR || _la==NULL) {
				{
				{
				State = 5733;
				jsonTableOnClause();
				}
				}
				State = 5738;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5739;
			jsonColumnsClause();
			State = 5740;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonTableOnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public JsonTableOnConditionContext jsonTableOnCondition() {
			return GetRuleContext<JsonTableOnConditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EMPTY_KEYWORD() { return GetToken(OracleAntlrParser.EMPTY_KEYWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		public JsonTableOnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonTableOnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonTableOnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonTableOnClause(this);
		}
	}

	[RuleVersion(0)]
	public JsonTableOnClauseContext jsonTableOnClause() {
		JsonTableOnClauseContext _localctx = new JsonTableOnClauseContext(Context, State);
		EnterRule(_localctx, 1130, RULE_jsonTableOnClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5742;
			jsonTableOnCondition();
			State = 5743;
			_la = TokenStream.LA(1);
			if ( !(_la==EMPTY_KEYWORD || _la==ERROR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonTableOnConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public JsonTableOnConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonTableOnCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonTableOnCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonTableOnCondition(this);
		}
	}

	[RuleVersion(0)]
	public JsonTableOnConditionContext jsonTableOnCondition() {
		JsonTableOnConditionContext _localctx = new JsonTableOnConditionContext(Context, State);
		EnterRule(_localctx, 1132, RULE_jsonTableOnCondition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5745;
			_la = TokenStream.LA(1);
			if ( !(_la==ERROR || _la==NULL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5746;
			Match(ON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public JsonExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonExpression(this);
		}
	}

	[RuleVersion(0)]
	public JsonExpressionContext jsonExpression() {
		JsonExpressionContext _localctx = new JsonExpressionContext(Context, State);
		EnterRule(_localctx, 1134, RULE_jsonExpression);
		try {
			State = 5750;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,607,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5748;
				plainIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5749;
				literal();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonColumnsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMNS() { return GetToken(OracleAntlrParser.COLUMNS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonColumnDefinitionContext[] jsonColumnDefinition() {
			return GetRuleContexts<JsonColumnDefinitionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonColumnDefinitionContext jsonColumnDefinition(int i) {
			return GetRuleContext<JsonColumnDefinitionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public JsonColumnsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonColumnsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonColumnsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonColumnsClause(this);
		}
	}

	[RuleVersion(0)]
	public JsonColumnsClauseContext jsonColumnsClause() {
		JsonColumnsClauseContext _localctx = new JsonColumnsClauseContext(Context, State);
		EnterRule(_localctx, 1136, RULE_jsonColumnsClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5752;
			Match(COLUMNS);
			State = 5753;
			Match(LPAREN);
			State = 5754;
			jsonColumnDefinition();
			State = 5759;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5755;
				Match(COMMA);
				State = 5756;
				jsonColumnDefinition();
				}
				}
				State = 5761;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5762;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonColumnDefinitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public JsonExistsColumnContext jsonExistsColumn() {
			return GetRuleContext<JsonExistsColumnContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonQueryColumnContext jsonQueryColumn() {
			return GetRuleContext<JsonQueryColumnContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonValueColumnContext jsonValueColumn() {
			return GetRuleContext<JsonValueColumnContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonNestedPathContext jsonNestedPath() {
			return GetRuleContext<JsonNestedPathContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OrdinalityColumnContext ordinalityColumn() {
			return GetRuleContext<OrdinalityColumnContext>(0);
		}
		public JsonColumnDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonColumnDefinition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonColumnDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonColumnDefinition(this);
		}
	}

	[RuleVersion(0)]
	public JsonColumnDefinitionContext jsonColumnDefinition() {
		JsonColumnDefinitionContext _localctx = new JsonColumnDefinitionContext(Context, State);
		EnterRule(_localctx, 1138, RULE_jsonColumnDefinition);
		try {
			State = 5769;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,609,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5764;
				jsonExistsColumn();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5765;
				jsonQueryColumn();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5766;
				jsonValueColumn();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5767;
				jsonNestedPath();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5768;
				ordinalityColumn();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonExistsColumnContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(OracleAntlrParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(OracleAntlrParser.PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonExpressionContext jsonExpression() {
			return GetRuleContext<JsonExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonExistsOnClauseContext[] jsonExistsOnClause() {
			return GetRuleContexts<JsonExistsOnClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonExistsOnClauseContext jsonExistsOnClause(int i) {
			return GetRuleContext<JsonExistsOnClauseContext>(i);
		}
		public JsonExistsColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonExistsColumn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonExistsColumn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonExistsColumn(this);
		}
	}

	[RuleVersion(0)]
	public JsonExistsColumnContext jsonExistsColumn() {
		JsonExistsColumnContext _localctx = new JsonExistsColumnContext(Context, State);
		EnterRule(_localctx, 1140, RULE_jsonExistsColumn);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5771;
			plainIdentifier();
			State = 5773;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,610,Context) ) {
			case 1:
				{
				State = 5772;
				typeReference();
				}
				break;
			}
			State = 5775;
			Match(EXISTS);
			State = 5778;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PATH) {
				{
				State = 5776;
				Match(PATH);
				State = 5777;
				jsonExpression();
				}
			}

			State = 5783;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ERROR || _la==FALSE || _la==TRUE) {
				{
				{
				State = 5780;
				jsonExistsOnClause();
				}
				}
				State = 5785;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonExistsOnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public JsonExistsOnConditionContext jsonExistsOnCondition() {
			return GetRuleContext<JsonExistsOnConditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EMPTY_KEYWORD() { return GetToken(OracleAntlrParser.EMPTY_KEYWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		public JsonExistsOnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonExistsOnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonExistsOnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonExistsOnClause(this);
		}
	}

	[RuleVersion(0)]
	public JsonExistsOnClauseContext jsonExistsOnClause() {
		JsonExistsOnClauseContext _localctx = new JsonExistsOnClauseContext(Context, State);
		EnterRule(_localctx, 1142, RULE_jsonExistsOnClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5786;
			jsonExistsOnCondition();
			State = 5787;
			_la = TokenStream.LA(1);
			if ( !(_la==EMPTY_KEYWORD || _la==ERROR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonExistsOnConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUE() { return GetToken(OracleAntlrParser.TRUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FALSE() { return GetToken(OracleAntlrParser.FALSE, 0); }
		public JsonExistsOnConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonExistsOnCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonExistsOnCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonExistsOnCondition(this);
		}
	}

	[RuleVersion(0)]
	public JsonExistsOnConditionContext jsonExistsOnCondition() {
		JsonExistsOnConditionContext _localctx = new JsonExistsOnConditionContext(Context, State);
		EnterRule(_localctx, 1144, RULE_jsonExistsOnCondition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5789;
			_la = TokenStream.LA(1);
			if ( !(_la==ERROR || _la==FALSE || _la==TRUE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5790;
			Match(ON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonQueryColumnContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORMAT() { return GetToken(OracleAntlrParser.FORMAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JSON() { return GetToken(OracleAntlrParser.JSON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUNCATE() { return GetToken(OracleAntlrParser.TRUNCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonQueryWrapperClauseContext jsonQueryWrapperClause() {
			return GetRuleContext<JsonQueryWrapperClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(OracleAntlrParser.PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonExpressionContext jsonExpression() {
			return GetRuleContext<JsonExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonQueryOnClauseContext[] jsonQueryOnClause() {
			return GetRuleContexts<JsonQueryOnClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonQueryOnClauseContext jsonQueryOnClause(int i) {
			return GetRuleContext<JsonQueryOnClauseContext>(i);
		}
		public JsonQueryColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonQueryColumn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonQueryColumn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonQueryColumn(this);
		}
	}

	[RuleVersion(0)]
	public JsonQueryColumnContext jsonQueryColumn() {
		JsonQueryColumnContext _localctx = new JsonQueryColumnContext(Context, State);
		EnterRule(_localctx, 1146, RULE_jsonQueryColumn);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5792;
			plainIdentifier();
			State = 5794;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,613,Context) ) {
			case 1:
				{
				State = 5793;
				typeReference();
				}
				break;
			}
			State = 5797;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TRUNCATE) {
				{
				State = 5796;
				Match(TRUNCATE);
				}
			}

			State = 5799;
			Match(FORMAT);
			State = 5800;
			Match(JSON);
			State = 5802;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH || _la==WITHOUT) {
				{
				State = 5801;
				jsonQueryWrapperClause();
				}
			}

			State = 5806;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PATH) {
				{
				State = 5804;
				Match(PATH);
				State = 5805;
				jsonExpression();
				}
			}

			State = 5811;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==EMPTY_KEYWORD || _la==ERROR || _la==NULL) {
				{
				{
				State = 5808;
				jsonQueryOnClause();
				}
				}
				State = 5813;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonQueryWrapperClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRAPPER() { return GetToken(OracleAntlrParser.WRAPPER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITHOUT() { return GetToken(OracleAntlrParser.WITHOUT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARRAY() { return GetToken(OracleAntlrParser.ARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONDITIONAL() { return GetToken(OracleAntlrParser.CONDITIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNCONDITIONAL() { return GetToken(OracleAntlrParser.UNCONDITIONAL, 0); }
		public JsonQueryWrapperClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonQueryWrapperClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonQueryWrapperClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonQueryWrapperClause(this);
		}
	}

	[RuleVersion(0)]
	public JsonQueryWrapperClauseContext jsonQueryWrapperClause() {
		JsonQueryWrapperClauseContext _localctx = new JsonQueryWrapperClauseContext(Context, State);
		EnterRule(_localctx, 1148, RULE_jsonQueryWrapperClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5819;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WITH:
				{
				State = 5814;
				Match(WITH);
				State = 5816;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONDITIONAL || _la==UNCONDITIONAL) {
					{
					State = 5815;
					_la = TokenStream.LA(1);
					if ( !(_la==CONDITIONAL || _la==UNCONDITIONAL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			case WITHOUT:
				{
				State = 5818;
				Match(WITHOUT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5822;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ARRAY) {
				{
				State = 5821;
				Match(ARRAY);
				}
			}

			State = 5824;
			Match(WRAPPER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonQueryOnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public JsonQueryOnConditionContext jsonQueryOnCondition() {
			return GetRuleContext<JsonQueryOnConditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EMPTY_KEYWORD() { return GetToken(OracleAntlrParser.EMPTY_KEYWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		public JsonQueryOnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonQueryOnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonQueryOnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonQueryOnClause(this);
		}
	}

	[RuleVersion(0)]
	public JsonQueryOnClauseContext jsonQueryOnClause() {
		JsonQueryOnClauseContext _localctx = new JsonQueryOnClauseContext(Context, State);
		EnterRule(_localctx, 1150, RULE_jsonQueryOnClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5826;
			jsonQueryOnCondition();
			State = 5827;
			_la = TokenStream.LA(1);
			if ( !(_la==EMPTY_KEYWORD || _la==ERROR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonQueryOnConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EMPTY_KEYWORD() { return GetToken(OracleAntlrParser.EMPTY_KEYWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARRAY() { return GetToken(OracleAntlrParser.ARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(OracleAntlrParser.OBJECT, 0); }
		public JsonQueryOnConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonQueryOnCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonQueryOnCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonQueryOnCondition(this);
		}
	}

	[RuleVersion(0)]
	public JsonQueryOnConditionContext jsonQueryOnCondition() {
		JsonQueryOnConditionContext _localctx = new JsonQueryOnConditionContext(Context, State);
		EnterRule(_localctx, 1152, RULE_jsonQueryOnCondition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5835;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ERROR:
				{
				State = 5829;
				Match(ERROR);
				}
				break;
			case NULL:
				{
				State = 5830;
				Match(NULL);
				}
				break;
			case EMPTY_KEYWORD:
				{
				State = 5831;
				Match(EMPTY_KEYWORD);
				State = 5833;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ARRAY || _la==OBJECT) {
					{
					State = 5832;
					_la = TokenStream.LA(1);
					if ( !(_la==ARRAY || _la==OBJECT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5837;
			Match(ON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonValueColumnContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUNCATE() { return GetToken(OracleAntlrParser.TRUNCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(OracleAntlrParser.PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonExpressionContext jsonExpression() {
			return GetRuleContext<JsonExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonValueOnClauseContext[] jsonValueOnClause() {
			return GetRuleContexts<JsonValueOnClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonValueOnClauseContext jsonValueOnClause(int i) {
			return GetRuleContext<JsonValueOnClauseContext>(i);
		}
		public JsonValueColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonValueColumn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonValueColumn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonValueColumn(this);
		}
	}

	[RuleVersion(0)]
	public JsonValueColumnContext jsonValueColumn() {
		JsonValueColumnContext _localctx = new JsonValueColumnContext(Context, State);
		EnterRule(_localctx, 1154, RULE_jsonValueColumn);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5839;
			plainIdentifier();
			State = 5841;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,623,Context) ) {
			case 1:
				{
				State = 5840;
				typeReference();
				}
				break;
			}
			State = 5844;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TRUNCATE) {
				{
				State = 5843;
				Match(TRUNCATE);
				}
			}

			State = 5848;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PATH) {
				{
				State = 5846;
				Match(PATH);
				State = 5847;
				jsonExpression();
				}
			}

			State = 5853;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DEFAULT || _la==ERROR || _la==NULL) {
				{
				{
				State = 5850;
				jsonValueOnClause();
				}
				}
				State = 5855;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonValueOnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public JsonValueOnConditionContext jsonValueOnCondition() {
			return GetRuleContext<JsonValueOnConditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EMPTY_KEYWORD() { return GetToken(OracleAntlrParser.EMPTY_KEYWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		public JsonValueOnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonValueOnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonValueOnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonValueOnClause(this);
		}
	}

	[RuleVersion(0)]
	public JsonValueOnClauseContext jsonValueOnClause() {
		JsonValueOnClauseContext _localctx = new JsonValueOnClauseContext(Context, State);
		EnterRule(_localctx, 1156, RULE_jsonValueOnClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5856;
			jsonValueOnCondition();
			State = 5857;
			_la = TokenStream.LA(1);
			if ( !(_la==EMPTY_KEYWORD || _la==ERROR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonValueOnConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(OracleAntlrParser.ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public JsonValueOnConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonValueOnCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonValueOnCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonValueOnCondition(this);
		}
	}

	[RuleVersion(0)]
	public JsonValueOnConditionContext jsonValueOnCondition() {
		JsonValueOnConditionContext _localctx = new JsonValueOnConditionContext(Context, State);
		EnterRule(_localctx, 1158, RULE_jsonValueOnCondition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5863;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ERROR:
				{
				State = 5859;
				Match(ERROR);
				}
				break;
			case NULL:
				{
				State = 5860;
				Match(NULL);
				}
				break;
			case DEFAULT:
				{
				State = 5861;
				Match(DEFAULT);
				State = 5862;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5865;
			Match(ON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonNestedPathContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NESTED() { return GetToken(OracleAntlrParser.NESTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonExpressionContext jsonExpression() {
			return GetRuleContext<JsonExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonColumnsClauseContext jsonColumnsClause() {
			return GetRuleContext<JsonColumnsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(OracleAntlrParser.PATH, 0); }
		public JsonNestedPathContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonNestedPath; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterJsonNestedPath(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitJsonNestedPath(this);
		}
	}

	[RuleVersion(0)]
	public JsonNestedPathContext jsonNestedPath() {
		JsonNestedPathContext _localctx = new JsonNestedPathContext(Context, State);
		EnterRule(_localctx, 1160, RULE_jsonNestedPath);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5867;
			Match(NESTED);
			State = 5869;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,628,Context) ) {
			case 1:
				{
				State = 5868;
				Match(PATH);
				}
				break;
			}
			State = 5871;
			jsonExpression();
			State = 5872;
			jsonColumnsClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrdinalityColumnContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDINALITY() { return GetToken(OracleAntlrParser.ORDINALITY, 0); }
		public OrdinalityColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ordinalityColumn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOrdinalityColumn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOrdinalityColumn(this);
		}
	}

	[RuleVersion(0)]
	public OrdinalityColumnContext ordinalityColumn() {
		OrdinalityColumnContext _localctx = new OrdinalityColumnContext(Context, State);
		EnterRule(_localctx, 1162, RULE_ordinalityColumn);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5874;
			plainIdentifier();
			State = 5875;
			Match(FOR);
			State = 5876;
			Match(ORDINALITY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlashbackAndPivotClausesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PivotUnpivotClauseContext pivotUnpivotClause() {
			return GetRuleContext<PivotUnpivotClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PeriodSpecificationContext periodSpecification() {
			return GetRuleContext<PeriodSpecificationContext>(0);
		}
		public FlashbackAndPivotClausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flashbackAndPivotClauses; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFlashbackAndPivotClauses(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFlashbackAndPivotClauses(this);
		}
	}

	[RuleVersion(0)]
	public FlashbackAndPivotClausesContext flashbackAndPivotClauses() {
		FlashbackAndPivotClausesContext _localctx = new FlashbackAndPivotClausesContext(Context, State);
		EnterRule(_localctx, 1164, RULE_flashbackAndPivotClauses);
		try {
			State = 5886;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PIVOT:
			case UNPIVOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5878;
				pivotUnpivotClause();
				State = 5880;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,629,Context) ) {
				case 1:
					{
					State = 5879;
					periodSpecification();
					}
					break;
				}
				}
				break;
			case AS:
			case VERSIONS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5882;
				periodSpecification();
				State = 5884;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,630,Context) ) {
				case 1:
					{
					State = 5883;
					pivotUnpivotClause();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTableItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLTABLE() { return GetToken(OracleAntlrParser.XMLTABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTableOptionsContext xmlTableOptions() {
			return GetRuleContext<XmlTableOptionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlNamespacesClauseContext xmlNamespacesClause() {
			return GetRuleContext<XmlNamespacesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		public XmlTableItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTableItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlTableItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlTableItem(this);
		}
	}

	[RuleVersion(0)]
	public XmlTableItemContext xmlTableItem() {
		XmlTableItemContext _localctx = new XmlTableItemContext(Context, State);
		EnterRule(_localctx, 1166, RULE_xmlTableItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5888;
			Match(XMLTABLE);
			State = 5889;
			Match(LPAREN);
			State = 5893;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==XMLNAMESPACES) {
				{
				State = 5890;
				xmlNamespacesClause();
				State = 5891;
				Match(COMMA);
				}
			}

			State = 5895;
			literal();
			State = 5896;
			xmlTableOptions();
			State = 5897;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlNamespacesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XMLNAMESPACES() { return GetToken(OracleAntlrParser.XMLNAMESPACES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public XmlNamespacesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlNamespacesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlNamespacesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlNamespacesClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlNamespacesClauseContext xmlNamespacesClause() {
		XmlNamespacesClauseContext _localctx = new XmlNamespacesClauseContext(Context, State);
		EnterRule(_localctx, 1168, RULE_xmlNamespacesClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5899;
			Match(XMLNAMESPACES);
			State = 5900;
			Match(LPAREN);
			State = 5902;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,633,Context) ) {
			case 1:
				{
				State = 5901;
				expressionList();
				}
				break;
			}
			State = 5906;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT) {
				{
				State = 5904;
				Match(DEFAULT);
				State = 5905;
				literal();
				}
			}

			State = 5908;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTableOptionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public XmlParsingClauseContext xmlParsingClause() {
			return GetRuleContext<XmlParsingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLUMNS() { return GetToken(OracleAntlrParser.COLUMNS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public XmlTableColumnContext[] xmlTableColumn() {
			return GetRuleContexts<XmlTableColumnContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public XmlTableColumnContext xmlTableColumn(int i) {
			return GetRuleContext<XmlTableColumnContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public XmlTableOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTableOptions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlTableOptions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlTableOptions(this);
		}
	}

	[RuleVersion(0)]
	public XmlTableOptionsContext xmlTableOptions() {
		XmlTableOptionsContext _localctx = new XmlTableOptionsContext(Context, State);
		EnterRule(_localctx, 1170, RULE_xmlTableOptions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5911;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PASSING) {
				{
				State = 5910;
				xmlParsingClause();
				}
			}

			State = 5922;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLUMNS) {
				{
				State = 5913;
				Match(COLUMNS);
				State = 5914;
				xmlTableColumn();
				State = 5919;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 5915;
					Match(COMMA);
					State = 5916;
					xmlTableColumn();
					}
					}
					State = 5921;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlParsingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSING() { return GetToken(OracleAntlrParser.PASSING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(OracleAntlrParser.VALUE, 0); }
		public XmlParsingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlParsingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlParsingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlParsingClause(this);
		}
	}

	[RuleVersion(0)]
	public XmlParsingClauseContext xmlParsingClause() {
		XmlParsingClauseContext _localctx = new XmlParsingClauseContext(Context, State);
		EnterRule(_localctx, 1172, RULE_xmlParsingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5924;
			Match(PASSING);
			State = 5927;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BY) {
				{
				State = 5925;
				Match(BY);
				State = 5926;
				Match(VALUE);
				}
			}

			State = 5929;
			expressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XmlTableColumnContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDINALITY() { return GetToken(OracleAntlrParser.ORDINALITY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(OracleAntlrParser.PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		public XmlTableColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlTableColumn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterXmlTableColumn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitXmlTableColumn(this);
		}
	}

	[RuleVersion(0)]
	public XmlTableColumnContext xmlTableColumn() {
		XmlTableColumnContext _localctx = new XmlTableColumnContext(Context, State);
		EnterRule(_localctx, 1174, RULE_xmlTableColumn);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5931;
			fullExpression();
			State = 5943;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FOR:
				{
				State = 5932;
				Match(FOR);
				State = 5933;
				Match(ORDINALITY);
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case NVARCHAR2:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case LPAREN:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 5934;
				typeReference();
				State = 5937;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PATH) {
					{
					State = 5935;
					Match(PATH);
					State = 5936;
					literal();
					}
				}

				State = 5941;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 5939;
					Match(DEFAULT);
					State = 5940;
					fullExpression();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotUnpivotClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PivotClauseContext pivotClause() {
			return GetRuleContext<PivotClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnpivotClauseContext unpivotClause() {
			return GetRuleContext<UnpivotClauseContext>(0);
		}
		public PivotUnpivotClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotUnpivotClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPivotUnpivotClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPivotUnpivotClause(this);
		}
	}

	[RuleVersion(0)]
	public PivotUnpivotClauseContext pivotUnpivotClause() {
		PivotUnpivotClauseContext _localctx = new PivotUnpivotClauseContext(Context, State);
		EnterRule(_localctx, 1176, RULE_pivotUnpivotClause);
		try {
			State = 5947;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PIVOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5945;
				pivotClause();
				}
				break;
			case UNPIVOT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5946;
				unpivotClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PIVOT() { return GetToken(OracleAntlrParser.PIVOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PivotBodyContext pivotBody() {
			return GetRuleContext<PivotBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XML() { return GetToken(OracleAntlrParser.XML, 0); }
		public PivotClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPivotClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPivotClause(this);
		}
	}

	[RuleVersion(0)]
	public PivotClauseContext pivotClause() {
		PivotClauseContext _localctx = new PivotClauseContext(Context, State);
		EnterRule(_localctx, 1178, RULE_pivotClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5949;
			Match(PIVOT);
			State = 5951;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==XML) {
				{
				State = 5950;
				Match(XML);
				}
			}

			State = 5953;
			pivotBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PivotForClauseContext pivotForClause() {
			return GetRuleContext<PivotForClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PivotInClauseContext pivotInClause() {
			return GetRuleContext<PivotInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public PivotBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPivotBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPivotBody(this);
		}
	}

	[RuleVersion(0)]
	public PivotBodyContext pivotBody() {
		PivotBodyContext _localctx = new PivotBodyContext(Context, State);
		EnterRule(_localctx, 1180, RULE_pivotBody);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5955;
			Match(LPAREN);
			State = 5956;
			expressionList();
			State = 5957;
			pivotForClause();
			State = 5958;
			pivotInClause();
			State = 5959;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotForClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierOrIdentifierListContext identifierOrIdentifierList() {
			return GetRuleContext<IdentifierOrIdentifierListContext>(0);
		}
		public PivotForClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotForClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPivotForClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPivotForClause(this);
		}
	}

	[RuleVersion(0)]
	public PivotForClauseContext pivotForClause() {
		PivotForClauseContext _localctx = new PivotForClauseContext(Context, State);
		EnterRule(_localctx, 1182, RULE_pivotForClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5961;
			Match(FOR);
			State = 5962;
			identifierOrIdentifierList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierOrIdentifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PivotUnpivotIdentifierListContext pivotUnpivotIdentifierList() {
			return GetRuleContext<PivotUnpivotIdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public IdentifierOrIdentifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierOrIdentifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentifierOrIdentifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentifierOrIdentifierList(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierOrIdentifierListContext identifierOrIdentifierList() {
		IdentifierOrIdentifierListContext _localctx = new IdentifierOrIdentifierListContext(Context, State);
		EnterRule(_localctx, 1184, RULE_identifierOrIdentifierList);
		try {
			State = 5966;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5964;
				pivotUnpivotIdentifierList();
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5965;
				identifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotUnpivotIdentifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public PivotUnpivotIdentifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotUnpivotIdentifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPivotUnpivotIdentifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPivotUnpivotIdentifierList(this);
		}
	}

	[RuleVersion(0)]
	public PivotUnpivotIdentifierListContext pivotUnpivotIdentifierList() {
		PivotUnpivotIdentifierListContext _localctx = new PivotUnpivotIdentifierListContext(Context, State);
		EnterRule(_localctx, 1186, RULE_pivotUnpivotIdentifierList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5968;
			Match(LPAREN);
			State = 5969;
			identifierList();
			State = 5970;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotInClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PivotInExpressionListContext pivotInExpressionList() {
			return GetRuleContext<PivotInExpressionListContext>(0);
		}
		public PivotInClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotInClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPivotInClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPivotInClause(this);
		}
	}

	[RuleVersion(0)]
	public PivotInClauseContext pivotInClause() {
		PivotInClauseContext _localctx = new PivotInClauseContext(Context, State);
		EnterRule(_localctx, 1188, RULE_pivotInClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5972;
			Match(IN);
			State = 5975;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,645,Context) ) {
			case 1:
				{
				State = 5973;
				flattenedQuery();
				}
				break;
			case 2:
				{
				State = 5974;
				pivotInExpressionList();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotInExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PivotInExpressionListItemContext[] pivotInExpressionListItem() {
			return GetRuleContexts<PivotInExpressionListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PivotInExpressionListItemContext pivotInExpressionListItem(int i) {
			return GetRuleContext<PivotInExpressionListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public PivotInExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotInExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPivotInExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPivotInExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public PivotInExpressionListContext pivotInExpressionList() {
		PivotInExpressionListContext _localctx = new PivotInExpressionListContext(Context, State);
		EnterRule(_localctx, 1190, RULE_pivotInExpressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5977;
			Match(LPAREN);
			State = 5978;
			pivotInExpressionListItem();
			State = 5983;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5979;
				Match(COMMA);
				State = 5980;
				pivotInExpressionListItem();
				}
				}
				State = 5985;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5986;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotInExpressionListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PivotAnyContext pivotAny() {
			return GetRuleContext<PivotAnyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionOrExpressionListContext expressionOrExpressionList() {
			return GetRuleContext<ExpressionOrExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AliasContext alias() {
			return GetRuleContext<AliasContext>(0);
		}
		public PivotInExpressionListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotInExpressionListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPivotInExpressionListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPivotInExpressionListItem(this);
		}
	}

	[RuleVersion(0)]
	public PivotInExpressionListItemContext pivotInExpressionListItem() {
		PivotInExpressionListItemContext _localctx = new PivotInExpressionListItemContext(Context, State);
		EnterRule(_localctx, 1192, RULE_pivotInExpressionListItem);
		int _la;
		try {
			State = 5993;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ANY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5988;
				pivotAny();
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CASE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case EXTRACTVALUE:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULL:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYS_CONNECT_BY_PATH:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLCAST:
			case XMLNAMESPACES:
			case XMLQUERY:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case INTEGER_LITERAL:
			case LPAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case QUESTION_MARK:
			case ASTERISK:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
			case QUOTE_CHARACTER_STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5989;
				expressionOrExpressionList();
				State = 5991;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
					{
					State = 5990;
					alias();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotAnyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY() { return GetToken(OracleAntlrParser.ANY, 0); }
		public PivotAnyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotAny; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPivotAny(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPivotAny(this);
		}
	}

	[RuleVersion(0)]
	public PivotAnyContext pivotAny() {
		PivotAnyContext _localctx = new PivotAnyContext(Context, State);
		EnterRule(_localctx, 1194, RULE_pivotAny);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5995;
			Match(ANY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionOrExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PivotExpressionListContext pivotExpressionList() {
			return GetRuleContext<PivotExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public ExpressionOrExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionOrExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExpressionOrExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExpressionOrExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionOrExpressionListContext expressionOrExpressionList() {
		ExpressionOrExpressionListContext _localctx = new ExpressionOrExpressionListContext(Context, State);
		EnterRule(_localctx, 1196, RULE_expressionOrExpressionList);
		try {
			State = 5999;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,649,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5997;
				pivotExpressionList();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5998;
				fullExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PivotExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public PivotExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivotExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPivotExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPivotExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public PivotExpressionListContext pivotExpressionList() {
		PivotExpressionListContext _localctx = new PivotExpressionListContext(Context, State);
		EnterRule(_localctx, 1198, RULE_pivotExpressionList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6001;
			Match(LPAREN);
			State = 6002;
			expressionList();
			State = 6003;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnpivotClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNPIVOT() { return GetToken(OracleAntlrParser.UNPIVOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnpivotBodyContext unpivotBody() {
			return GetRuleContext<UnpivotBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDE() { return GetToken(OracleAntlrParser.INCLUDE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULLS() { return GetToken(OracleAntlrParser.NULLS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLUDE() { return GetToken(OracleAntlrParser.EXCLUDE, 0); }
		public UnpivotClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivotClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUnpivotClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUnpivotClause(this);
		}
	}

	[RuleVersion(0)]
	public UnpivotClauseContext unpivotClause() {
		UnpivotClauseContext _localctx = new UnpivotClauseContext(Context, State);
		EnterRule(_localctx, 1200, RULE_unpivotClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6005;
			Match(UNPIVOT);
			State = 6010;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INCLUDE:
				{
				State = 6006;
				Match(INCLUDE);
				State = 6007;
				Match(NULLS);
				}
				break;
			case EXCLUDE:
				{
				State = 6008;
				Match(EXCLUDE);
				State = 6009;
				Match(NULLS);
				}
				break;
			case LPAREN:
				break;
			default:
				break;
			}
			State = 6012;
			unpivotBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnpivotBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierOrIdentifierListContext identifierOrIdentifierList() {
			return GetRuleContext<IdentifierOrIdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PivotForClauseContext pivotForClause() {
			return GetRuleContext<PivotForClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnpivotInClauseContext unpivotInClause() {
			return GetRuleContext<UnpivotInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public UnpivotBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivotBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUnpivotBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUnpivotBody(this);
		}
	}

	[RuleVersion(0)]
	public UnpivotBodyContext unpivotBody() {
		UnpivotBodyContext _localctx = new UnpivotBodyContext(Context, State);
		EnterRule(_localctx, 1202, RULE_unpivotBody);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6014;
			Match(LPAREN);
			State = 6015;
			identifierOrIdentifierList();
			State = 6016;
			pivotForClause();
			State = 6017;
			unpivotInClause();
			State = 6018;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnpivotInClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnpivotInExpressionListContext unpivotInExpressionList() {
			return GetRuleContext<UnpivotInExpressionListContext>(0);
		}
		public UnpivotInClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivotInClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUnpivotInClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUnpivotInClause(this);
		}
	}

	[RuleVersion(0)]
	public UnpivotInClauseContext unpivotInClause() {
		UnpivotInClauseContext _localctx = new UnpivotInClauseContext(Context, State);
		EnterRule(_localctx, 1204, RULE_unpivotInClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6020;
			Match(IN);
			State = 6021;
			unpivotInExpressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnpivotInExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnpivotInExpressionListItemContext[] unpivotInExpressionListItem() {
			return GetRuleContexts<UnpivotInExpressionListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnpivotInExpressionListItemContext unpivotInExpressionListItem(int i) {
			return GetRuleContext<UnpivotInExpressionListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public UnpivotInExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivotInExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUnpivotInExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUnpivotInExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public UnpivotInExpressionListContext unpivotInExpressionList() {
		UnpivotInExpressionListContext _localctx = new UnpivotInExpressionListContext(Context, State);
		EnterRule(_localctx, 1206, RULE_unpivotInExpressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6023;
			Match(LPAREN);
			State = 6024;
			unpivotInExpressionListItem();
			State = 6029;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 6025;
				Match(COMMA);
				State = 6026;
				unpivotInExpressionListItem();
				}
				}
				State = 6031;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6032;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnpivotInExpressionListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierOrIdentifierListContext identifierOrIdentifierList() {
			return GetRuleContext<IdentifierOrIdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralOrLiteralListAliasContext literalOrLiteralListAlias() {
			return GetRuleContext<LiteralOrLiteralListAliasContext>(0);
		}
		public UnpivotInExpressionListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivotInExpressionListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUnpivotInExpressionListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUnpivotInExpressionListItem(this);
		}
	}

	[RuleVersion(0)]
	public UnpivotInExpressionListItemContext unpivotInExpressionListItem() {
		UnpivotInExpressionListItemContext _localctx = new UnpivotInExpressionListItemContext(Context, State);
		EnterRule(_localctx, 1208, RULE_unpivotInExpressionListItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6034;
			identifierOrIdentifierList();
			State = 6036;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 6035;
				literalOrLiteralListAlias();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralOrLiteralListAliasContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralOrLiteralListContext literalOrLiteralList() {
			return GetRuleContext<LiteralOrLiteralListContext>(0);
		}
		public LiteralOrLiteralListAliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalOrLiteralListAlias; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLiteralOrLiteralListAlias(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLiteralOrLiteralListAlias(this);
		}
	}

	[RuleVersion(0)]
	public LiteralOrLiteralListAliasContext literalOrLiteralListAlias() {
		LiteralOrLiteralListAliasContext _localctx = new LiteralOrLiteralListAliasContext(Context, State);
		EnterRule(_localctx, 1210, RULE_literalOrLiteralListAlias);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6038;
			Match(AS);
			State = 6039;
			literalOrLiteralList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralOrLiteralListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LiteralListWithParenthesisContext literalListWithParenthesis() {
			return GetRuleContext<LiteralListWithParenthesisContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public LiteralOrLiteralListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalOrLiteralList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLiteralOrLiteralList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLiteralOrLiteralList(this);
		}
	}

	[RuleVersion(0)]
	public LiteralOrLiteralListContext literalOrLiteralList() {
		LiteralOrLiteralListContext _localctx = new LiteralOrLiteralListContext(Context, State);
		EnterRule(_localctx, 1212, RULE_literalOrLiteralList);
		try {
			State = 6043;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6041;
				literalListWithParenthesis();
				}
				break;
			case DATE:
			case FALSE:
			case INTERVAL:
			case TIMESTAMP:
			case TRUE:
			case INTEGER_LITERAL:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case QUOTE_CHARACTER_STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6042;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralListWithParenthesisContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext[] literal() {
			return GetRuleContexts<LiteralContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal(int i) {
			return GetRuleContext<LiteralContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public LiteralListWithParenthesisContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalListWithParenthesis; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLiteralListWithParenthesis(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLiteralListWithParenthesis(this);
		}
	}

	[RuleVersion(0)]
	public LiteralListWithParenthesisContext literalListWithParenthesis() {
		LiteralListWithParenthesisContext _localctx = new LiteralListWithParenthesisContext(Context, State);
		EnterRule(_localctx, 1214, RULE_literalListWithParenthesis);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6045;
			Match(LPAREN);
			State = 6046;
			literal();
			State = 6051;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 6047;
				Match(COMMA);
				State = 6048;
				literal();
				}
				}
				State = 6053;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6054;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PeriodSpecificationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PeriodAsOfClauseContext periodAsOfClause() {
			return GetRuleContext<PeriodAsOfClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PeriodBetweenClauseContext periodBetweenClause() {
			return GetRuleContext<PeriodBetweenClauseContext>(0);
		}
		public PeriodSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_periodSpecification; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPeriodSpecification(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPeriodSpecification(this);
		}
	}

	[RuleVersion(0)]
	public PeriodSpecificationContext periodSpecification() {
		PeriodSpecificationContext _localctx = new PeriodSpecificationContext(Context, State);
		EnterRule(_localctx, 1216, RULE_periodSpecification);
		try {
			State = 6058;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6056;
				periodAsOfClause();
				}
				break;
			case VERSIONS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6057;
				periodBetweenClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PeriodAsOfClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FlashBackTypeContext flashBackType() {
			return GetRuleContext<FlashBackTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PeriodForTimeColumnContext periodForTimeColumn() {
			return GetRuleContext<PeriodForTimeColumnContext>(0);
		}
		public PeriodAsOfClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_periodAsOfClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPeriodAsOfClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPeriodAsOfClause(this);
		}
	}

	[RuleVersion(0)]
	public PeriodAsOfClauseContext periodAsOfClause() {
		PeriodAsOfClauseContext _localctx = new PeriodAsOfClauseContext(Context, State);
		EnterRule(_localctx, 1218, RULE_periodAsOfClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6060;
			Match(AS);
			State = 6061;
			Match(OF);
			State = 6066;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SCN:
			case TIMESTAMP:
				{
				State = 6062;
				flashBackType();
				State = 6063;
				expressionList();
				}
				break;
			case PERIOD:
				{
				State = 6065;
				periodForTimeColumn();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PeriodBetweenClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VERSIONS() { return GetToken(OracleAntlrParser.VERSIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext[] pureExpression() {
			return GetRuleContexts<PureExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression(int i) {
			return GetRuleContext<PureExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(OracleAntlrParser.AND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BETWEEN() { return GetToken(OracleAntlrParser.BETWEEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FlashBackTypeContext flashBackType() {
			return GetRuleContext<FlashBackTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PeriodForTimeColumnContext periodForTimeColumn() {
			return GetRuleContext<PeriodForTimeColumnContext>(0);
		}
		public PeriodBetweenClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_periodBetweenClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPeriodBetweenClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPeriodBetweenClause(this);
		}
	}

	[RuleVersion(0)]
	public PeriodBetweenClauseContext periodBetweenClause() {
		PeriodBetweenClauseContext _localctx = new PeriodBetweenClauseContext(Context, State);
		EnterRule(_localctx, 1220, RULE_periodBetweenClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6068;
			Match(VERSIONS);
			State = 6072;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BETWEEN:
				{
				State = 6069;
				Match(BETWEEN);
				State = 6070;
				flashBackType();
				}
				break;
			case PERIOD:
				{
				State = 6071;
				periodForTimeColumn();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6074;
			pureExpression();
			State = 6075;
			Match(AND);
			State = 6076;
			pureExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PeriodForTimeColumnContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERIOD() { return GetToken(OracleAntlrParser.PERIOD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BETWEEN() { return GetToken(OracleAntlrParser.BETWEEN, 0); }
		public PeriodForTimeColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_periodForTimeColumn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPeriodForTimeColumn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPeriodForTimeColumn(this);
		}
	}

	[RuleVersion(0)]
	public PeriodForTimeColumnContext periodForTimeColumn() {
		PeriodForTimeColumnContext _localctx = new PeriodForTimeColumnContext(Context, State);
		EnterRule(_localctx, 1222, RULE_periodForTimeColumn);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6078;
			Match(PERIOD);
			State = 6079;
			Match(FOR);
			State = 6080;
			identifier();
			State = 6083;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CASE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case EXTRACTVALUE:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULL:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYS_CONNECT_BY_PATH:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLCAST:
			case XMLNAMESPACES:
			case XMLQUERY:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case INTEGER_LITERAL:
			case LPAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case QUESTION_MARK:
			case ASTERISK:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
			case QUOTE_CHARACTER_STRING_LITERAL:
				{
				State = 6081;
				fullExpression();
				}
				break;
			case BETWEEN:
				{
				State = 6082;
				Match(BETWEEN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlashBackTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMESTAMP() { return GetToken(OracleAntlrParser.TIMESTAMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCN() { return GetToken(OracleAntlrParser.SCN, 0); }
		public FlashBackTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flashBackType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFlashBackType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFlashBackType(this);
		}
	}

	[RuleVersion(0)]
	public FlashBackTypeContext flashBackType() {
		FlashBackTypeContext _localctx = new FlashBackTypeContext(Context, State);
		EnterRule(_localctx, 1224, RULE_flashBackType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6085;
			_la = TokenStream.LA(1);
			if ( !(_la==SCN || _la==TIMESTAMP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SampleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SAMPLE() { return GetToken(OracleAntlrParser.SAMPLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SampleClauseValuesContext sampleClauseValues() {
			return GetRuleContext<SampleClauseValuesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BLOCK() { return GetToken(OracleAntlrParser.BLOCK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SampleSeedClauseContext sampleSeedClause() {
			return GetRuleContext<SampleSeedClauseContext>(0);
		}
		public SampleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sampleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSampleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSampleClause(this);
		}
	}

	[RuleVersion(0)]
	public SampleClauseContext sampleClause() {
		SampleClauseContext _localctx = new SampleClauseContext(Context, State);
		EnterRule(_localctx, 1226, RULE_sampleClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6087;
			Match(SAMPLE);
			State = 6089;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BLOCK) {
				{
				State = 6088;
				Match(BLOCK);
				}
			}

			State = 6091;
			sampleClauseValues();
			State = 6093;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,660,Context) ) {
			case 1:
				{
				State = 6092;
				sampleSeedClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SampleSeedClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEED() { return GetToken(OracleAntlrParser.SEED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SampleClauseValuesContext sampleClauseValues() {
			return GetRuleContext<SampleClauseValuesContext>(0);
		}
		public SampleSeedClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sampleSeedClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSampleSeedClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSampleSeedClause(this);
		}
	}

	[RuleVersion(0)]
	public SampleSeedClauseContext sampleSeedClause() {
		SampleSeedClauseContext _localctx = new SampleSeedClauseContext(Context, State);
		EnterRule(_localctx, 1228, RULE_sampleSeedClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6095;
			Match(SEED);
			State = 6096;
			sampleClauseValues();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SampleClauseValuesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public SampleClauseValuesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sampleClauseValues; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSampleClauseValues(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSampleClauseValues(this);
		}
	}

	[RuleVersion(0)]
	public SampleClauseValuesContext sampleClauseValues() {
		SampleClauseValuesContext _localctx = new SampleClauseValuesContext(Context, State);
		EnterRule(_localctx, 1230, RULE_sampleClauseValues);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6098;
			Match(LPAREN);
			State = 6099;
			fullExpression();
			State = 6100;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AliasIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		public AliasIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aliasIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAliasIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAliasIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public AliasIdentifierContext aliasIdentifier() {
		AliasIdentifierContext _localctx = new AliasIdentifierContext(Context, State);
		EnterRule(_localctx, 1232, RULE_aliasIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6103;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 6102;
				Match(AS);
				}
			}

			State = 6105;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleAliasIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LocalSimpleIdentifierWithoutParenthesesContext localSimpleIdentifierWithoutParentheses() {
			return GetRuleContext<LocalSimpleIdentifierWithoutParenthesesContext>(0);
		}
		public SimpleAliasIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleAliasIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSimpleAliasIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSimpleAliasIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public SimpleAliasIdentifierContext simpleAliasIdentifier() {
		SimpleAliasIdentifierContext _localctx = new SimpleAliasIdentifierContext(Context, State);
		EnterRule(_localctx, 1234, RULE_simpleAliasIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6107;
			localSimpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertColumnListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public InsertColumnListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertColumnListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterInsertColumnListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitInsertColumnListClause(this);
		}
	}

	[RuleVersion(0)]
	public InsertColumnListClauseContext insertColumnListClause() {
		InsertColumnListClauseContext _localctx = new InsertColumnListClauseContext(Context, State);
		EnterRule(_localctx, 1236, RULE_insertColumnListClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6109;
			Match(LPAREN);
			State = 6110;
			identifierList();
			State = 6111;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ValuesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUES() { return GetToken(OracleAntlrParser.VALUES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InsertExpressionListContext insertExpressionList() {
			return GetRuleContext<InsertExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ValuesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_valuesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterValuesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitValuesClause(this);
		}
	}

	[RuleVersion(0)]
	public ValuesClauseContext valuesClause() {
		ValuesClauseContext _localctx = new ValuesClauseContext(Context, State);
		EnterRule(_localctx, 1238, RULE_valuesClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6113;
			Match(VALUES);
			State = 6119;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				{
				State = 6114;
				Match(LPAREN);
				State = 6115;
				insertExpressionList();
				State = 6116;
				Match(RPAREN);
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 6118;
				identifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public InsertExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterInsertExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitInsertExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public InsertExpressionListContext insertExpressionList() {
		InsertExpressionListContext _localctx = new InsertExpressionListContext(Context, State);
		EnterRule(_localctx, 1240, RULE_insertExpressionList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6121;
			expressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSERT() { return GetToken(OracleAntlrParser.INSERT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleTableInsertStatementContext singleTableInsertStatement() {
			return GetRuleContext<SingleTableInsertStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiTableInsertStatementContext multiTableInsertStatement() {
			return GetRuleContext<MultiTableInsertStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalInsertStatementContext conditionalInsertStatement() {
			return GetRuleContext<ConditionalInsertStatementContext>(0);
		}
		public InsertStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterInsertStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitInsertStatement(this);
		}
	}

	[RuleVersion(0)]
	public InsertStatementContext insertStatement() {
		InsertStatementContext _localctx = new InsertStatementContext(Context, State);
		EnterRule(_localctx, 1242, RULE_insertStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6123;
			Match(INSERT);
			State = 6127;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,663,Context) ) {
			case 1:
				{
				State = 6124;
				singleTableInsertStatement();
				}
				break;
			case 2:
				{
				State = 6125;
				multiTableInsertStatement();
				}
				break;
			case 3:
				{
				State = 6126;
				conditionalInsertStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SingleTableInsertStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ValuesClauseContext valuesClause() {
			return GetRuleContext<ValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertColumnListClauseContext insertColumnListClause() {
			return GetRuleContext<InsertColumnListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturningClauseContext returningClause() {
			return GetRuleContext<ReturningClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingClauseContext errorLoggingClause() {
			return GetRuleContext<ErrorLoggingClauseContext>(0);
		}
		public SingleTableInsertStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_singleTableInsertStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSingleTableInsertStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSingleTableInsertStatement(this);
		}
	}

	[RuleVersion(0)]
	public SingleTableInsertStatementContext singleTableInsertStatement() {
		SingleTableInsertStatementContext _localctx = new SingleTableInsertStatementContext(Context, State);
		EnterRule(_localctx, 1244, RULE_singleTableInsertStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6129;
			Match(INTO);
			State = 6130;
			fromClauseItem();
			State = 6132;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,664,Context) ) {
			case 1:
				{
				State = 6131;
				insertColumnListClause();
				}
				break;
			}
			State = 6136;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case VALUES:
				{
				State = 6134;
				valuesClause();
				}
				break;
			case SELECT:
			case WITH:
			case LPAREN:
				{
				State = 6135;
				selectStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6139;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURNING) {
				{
				State = 6138;
				returningClause();
				}
			}

			State = 6142;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOG) {
				{
				State = 6141;
				errorLoggingClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiTableInsertStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiTableInsertItemContext[] multiTableInsertItem() {
			return GetRuleContexts<MultiTableInsertItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiTableInsertItemContext multiTableInsertItem(int i) {
			return GetRuleContext<MultiTableInsertItemContext>(i);
		}
		public MultiTableInsertStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiTableInsertStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMultiTableInsertStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMultiTableInsertStatement(this);
		}
	}

	[RuleVersion(0)]
	public MultiTableInsertStatementContext multiTableInsertStatement() {
		MultiTableInsertStatementContext _localctx = new MultiTableInsertStatementContext(Context, State);
		EnterRule(_localctx, 1246, RULE_multiTableInsertStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6144;
			Match(ALL);
			State = 6146;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6145;
				multiTableInsertItem();
				}
				}
				State = 6148;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==INTO );
			State = 6150;
			selectStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiTableInsertItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertColumnListClauseContext insertColumnListClause() {
			return GetRuleContext<InsertColumnListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ValuesClauseContext valuesClause() {
			return GetRuleContext<ValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingClauseContext errorLoggingClause() {
			return GetRuleContext<ErrorLoggingClauseContext>(0);
		}
		public MultiTableInsertItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiTableInsertItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMultiTableInsertItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMultiTableInsertItem(this);
		}
	}

	[RuleVersion(0)]
	public MultiTableInsertItemContext multiTableInsertItem() {
		MultiTableInsertItemContext _localctx = new MultiTableInsertItemContext(Context, State);
		EnterRule(_localctx, 1248, RULE_multiTableInsertItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6152;
			Match(INTO);
			State = 6153;
			fromClauseItem();
			State = 6155;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,669,Context) ) {
			case 1:
				{
				State = 6154;
				insertColumnListClause();
				}
				break;
			}
			State = 6158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==VALUES) {
				{
				State = 6157;
				valuesClause();
				}
			}

			State = 6161;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOG) {
				{
				State = 6160;
				errorLoggingClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalInsertStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalInsertWhenEntryContext[] conditionalInsertWhenEntry() {
			return GetRuleContexts<ConditionalInsertWhenEntryContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalInsertWhenEntryContext conditionalInsertWhenEntry(int i) {
			return GetRuleContext<ConditionalInsertWhenEntryContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalInsertElseClauseContext conditionalInsertElseClause() {
			return GetRuleContext<ConditionalInsertElseClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(OracleAntlrParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIRST() { return GetToken(OracleAntlrParser.FIRST, 0); }
		public ConditionalInsertStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalInsertStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConditionalInsertStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConditionalInsertStatement(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalInsertStatementContext conditionalInsertStatement() {
		ConditionalInsertStatementContext _localctx = new ConditionalInsertStatementContext(Context, State);
		EnterRule(_localctx, 1250, RULE_conditionalInsertStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6164;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==FIRST) {
				{
				State = 6163;
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==FIRST) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 6167;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6166;
				conditionalInsertWhenEntry();
				}
				}
				State = 6169;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 6172;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 6171;
				conditionalInsertElseClause();
				}
			}

			State = 6174;
			selectStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalInsertWhenEntryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalInsertThenClauseContext conditionalInsertThenClause() {
			return GetRuleContext<ConditionalInsertThenClauseContext>(0);
		}
		public ConditionalInsertWhenEntryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalInsertWhenEntry; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConditionalInsertWhenEntry(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConditionalInsertWhenEntry(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalInsertWhenEntryContext conditionalInsertWhenEntry() {
		ConditionalInsertWhenEntryContext _localctx = new ConditionalInsertWhenEntryContext(Context, State);
		EnterRule(_localctx, 1252, RULE_conditionalInsertWhenEntry);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6176;
			Match(WHEN);
			State = 6177;
			fullExpression();
			State = 6178;
			conditionalInsertThenClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalInsertThenClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(OracleAntlrParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MultiTableInsertItemContext[] multiTableInsertItem() {
			return GetRuleContexts<MultiTableInsertItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiTableInsertItemContext multiTableInsertItem(int i) {
			return GetRuleContext<MultiTableInsertItemContext>(i);
		}
		public ConditionalInsertThenClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalInsertThenClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConditionalInsertThenClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConditionalInsertThenClause(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalInsertThenClauseContext conditionalInsertThenClause() {
		ConditionalInsertThenClauseContext _localctx = new ConditionalInsertThenClauseContext(Context, State);
		EnterRule(_localctx, 1254, RULE_conditionalInsertThenClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6180;
			Match(THEN);
			State = 6182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6181;
				multiTableInsertItem();
				}
				}
				State = 6184;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==INTO );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalInsertElseClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(OracleAntlrParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MultiTableInsertItemContext[] multiTableInsertItem() {
			return GetRuleContexts<MultiTableInsertItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiTableInsertItemContext multiTableInsertItem(int i) {
			return GetRuleContext<MultiTableInsertItemContext>(i);
		}
		public ConditionalInsertElseClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalInsertElseClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConditionalInsertElseClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConditionalInsertElseClause(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalInsertElseClauseContext conditionalInsertElseClause() {
		ConditionalInsertElseClauseContext _localctx = new ConditionalInsertElseClauseContext(Context, State);
		EnterRule(_localctx, 1256, RULE_conditionalInsertElseClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6186;
			Match(ELSE);
			State = 6188;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6187;
				multiTableInsertItem();
				}
				}
				State = 6190;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==INTO );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SetClauseValueClauseContext setClauseValueClause() {
			return GetRuleContext<SetClauseValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetListContext[] setList() {
			return GetRuleContexts<SetListContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetListContext setList(int i) {
			return GetRuleContext<SetListContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public SetClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSetClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSetClause(this);
		}
	}

	[RuleVersion(0)]
	public SetClauseContext setClause() {
		SetClauseContext _localctx = new SetClauseContext(Context, State);
		EnterRule(_localctx, 1258, RULE_setClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6192;
			Match(SET);
			State = 6202;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,678,Context) ) {
			case 1:
				{
				State = 6193;
				setClauseValueClause();
				}
				break;
			case 2:
				{
				State = 6194;
				setList();
				State = 6199;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 6195;
					Match(COMMA);
					State = 6196;
					setList();
					}
					}
					State = 6201;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetClauseValueClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(OracleAntlrParser.VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public SetClauseValueClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setClauseValueClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSetClauseValueClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSetClauseValueClause(this);
		}
	}

	[RuleVersion(0)]
	public SetClauseValueClauseContext setClauseValueClause() {
		SetClauseValueClauseContext _localctx = new SetClauseValueClauseContext(Context, State);
		EnterRule(_localctx, 1260, RULE_setClauseValueClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6204;
			Match(VALUE);
			State = 6205;
			Match(LPAREN);
			State = 6206;
			identifier();
			State = 6207;
			Match(RPAREN);
			State = 6208;
			Match(EQUAL_SIGN);
			State = 6209;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FlattenedQueryContext flattenedQuery() {
			return GetRuleContext<FlattenedQueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultExpressionContext defaultExpression() {
			return GetRuleContext<DefaultExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetColumnListClauseContext setColumnListClause() {
			return GetRuleContext<SetColumnListClauseContext>(0);
		}
		public SetListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSetList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSetList(this);
		}
	}

	[RuleVersion(0)]
	public SetListContext setList() {
		SetListContext _localctx = new SetListContext(Context, State);
		EnterRule(_localctx, 1262, RULE_setList);
		try {
			State = 6228;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,681,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6216;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case A_:
				case ACCOUNT:
				case ADVANCED:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ALLOCATE:
				case ALLOW:
				case ALWAYS:
				case ANALYZE:
				case ANYSCHEMA:
				case ARCHIVE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case ATTRIBUTES:
				case AUTHENTICATION:
				case AUTHID:
				case AUTO:
				case AUTONOMOUS_TRANSACTION:
				case BASIC:
				case BASICFILE:
				case BATCH:
				case BEFORE:
				case BEGINNING:
				case BINARY:
				case BITMAP:
				case BLOCK:
				case BODY:
				case BOTH:
				case BREADTH:
				case BUFFER_POOL:
				case BUILD:
				case BUILTIN:
				case BULK:
				case BULK_EXCEPTIONS:
				case BULK_ROWCOUNT:
				case BYTE:
				case C_:
				case CACHE:
				case CALL:
				case CASCADE:
				case CAST:
				case CELL_FLASH_CACHE:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHARSET:
				case CHR:
				case CHUNK:
				case CLOB:
				case CLOSE:
				case COALESCE:
				case COLLATION:
				case COLLECT:
				case COLUMN_VALUE:
				case COMMIT:
				case COMMITTED:
				case COMPACT:
				case COMPILE:
				case COMPLETE:
				case COMPOUND:
				case COMPUTATION:
				case COMPUTE:
				case CONDITIONAL:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTAINER:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case COUNT:
				case CREATION:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DATAFILE:
				case DATE:
				case DAY:
				case DBTIMEZONE:
				case DDL:
				case DEALLOCATE:
				case DEBUG:
				case DECODE:
				case DECRYPT:
				case DEDUPLICATE:
				case DEFERRABLE:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DEMAND:
				case DENSE_RANK:
				case DEPTH:
				case DETERMINISTIC:
				case DIRECT_LOAD:
				case DISABLE:
				case DISALLOW:
				case DISASSOCIATE:
				case DOUBLE:
				case DUPLICATED:
				case EACH:
				case EDITION:
				case EDITIONABLE:
				case EDITIONING:
				case EDITIONS:
				case ELEMENT:
				case ELSIF:
				case EMPTY_KEYWORD:
				case ENABLE:
				case ENCRYPT:
				case ENFORCED:
				case ERROR_CODE:
				case ERROR_INDEX:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVALUATE:
				case EXCEPT:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXISTS:
				case EXIT:
				case EXPIRE:
				case EXTEND:
				case EXTENDED:
				case EXTENT:
				case EXTERNALLY:
				case EXTRACT:
				case FALSE:
				case FAST:
				case FILESYSTEM_LIKE_LOGGING:
				case FINAL:
				case FIPSFLAG:
				case FIRST:
				case FIRST_ROWS:
				case FIXED:
				case FOLLOWING:
				case FORALL:
				case FORCE:
				case FOREIGN:
				case FORMAT:
				case FOUND:
				case FLASH_CACHE:
				case FREELIST:
				case FREELISTS:
				case FREEPOOLS:
				case FULL:
				case FUNCTION:
				case GENERATED:
				case GLOBAL:
				case GLOBALLY:
				case GROUPING:
				case GROUPS:
				case HASH:
				case HEAP:
				case HIGH:
				case HOUR:
				case ID:
				case IDENTIFIER:
				case IDENTITY:
				case INCLUDE:
				case INCLUDING:
				case INDEXING:
				case INDICATOR:
				case INDICES:
				case INITIALLY:
				case INITRANS:
				case INNER:
				case INSTANCE:
				case INSTANTIABLE:
				case INSTEAD:
				case INTERFACE:
				case INTERVAL:
				case INVALIDATE:
				case INVALIDATION:
				case INVISIBLE:
				case ISOLATION:
				case ISOPEN:
				case JAVA:
				case JOIN:
				case JSON:
				case JSON_TABLE:
				case KEEP:
				case KEEP_DUPLICATES:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LEADING:
				case LEFT:
				case LESS:
				case LEVEL:
				case LEVELS:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LIST:
				case LOB:
				case LOBS:
				case LOCAL:
				case LOCATOR:
				case LOCKED:
				case LOCKING:
				case LOG:
				case LOGGING:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOW:
				case MAP:
				case MAPPING:
				case MASTER:
				case MATCHED:
				case MATERIALIZED:
				case MAX:
				case MAXSIZE:
				case MAXTRANS:
				case MAXVALUE:
				case MEDIUM:
				case MEMBER:
				case MEMOPTIMIZE:
				case MERGE:
				case METADATA:
				case MIN:
				case MINEXTENTS:
				case MINUTE:
				case MINVALUE:
				case MOD:
				case MONITORING:
				case MONTH:
				case MOVEMENT:
				case MULTISET:
				case NAME:
				case NATIONAL:
				case NATURAL:
				case NCHAR:
				case NCHAR_CS:
				case NCHR:
				case NESTED:
				case NEVER:
				case NEW:
				case NEW_NAMES:
				case NEXT:
				case NO:
				case NOCACHE:
				case NOCOPY:
				case NOCYCLE:
				case NOEXTEND:
				case NOKEEP:
				case NOLOGGING:
				case NOMAPPING:
				case NOMAXVALUE:
				case NOMINVALUE:
				case NOMONITORING:
				case NOORDER:
				case NONE:
				case NONEDITIONABLE:
				case NONSCHEMA:
				case NOPARALLEL:
				case NORELY:
				case NOREVERSE:
				case NOROWDEPENDENCIES:
				case NOSCALE:
				case NOSHARD:
				case NOSORT:
				case NOTFOUND:
				case NOVALIDATE:
				case NULLS:
				case OBJECT:
				case OID:
				case OIDINDEX:
				case OLD:
				case ONLY:
				case ONLINE:
				case OPAQUE:
				case OPEN:
				case OPERATIONS:
				case OPTIMAL:
				case ORDINALITY:
				case ORGANIZATION:
				case OUT:
				case OUTER:
				case OVER:
				case OVERFLOW:
				case OVERLAPS:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTIAL:
				case PARTITION:
				case PARTITIONS:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PCTINCREASE:
				case PCTTHRESHOLD:
				case PCTUSED:
				case PCTVERSION:
				case PERCENTILE_DISC:
				case PERIOD:
				case PIPE:
				case PIPELINED:
				case POLYMORPHIC:
				case PRAGMA:
				case PREBUILT:
				case PRECEDING:
				case PRECISION:
				case PRESERVE:
				case PRIMARY:
				case PRIOR:
				case PRIVATE:
				case PROCEDURE:
				case PROFILE:
				case PUBLIC:
				case PURGE:
				case QUERY:
				case QUOTA:
				case RAISE:
				case RAISE_APPLICATION_ERROR:
				case RANGE:
				case RAW:
				case READ:
				case READS:
				case REBUILD:
				case RECORD:
				case RECYCLE:
				case REDUCED:
				case REF:
				case REFERENCES:
				case REFERENCING:
				case REFRESH:
				case REJECT:
				case RELATIONAL:
				case RELIES_ON:
				case RELY:
				case RENAME:
				case REPLACE:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETENTION:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case REWRITE:
				case RIGHT:
				case ROLLUP:
				case ROW:
				case ROWCOUNT:
				case ROWDEPENDENCIES:
				case ROWID:
				case ROWTYPE:
				case SALT:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCALE:
				case SCHEMA:
				case SCN:
				case SCOPE:
				case SEARCH:
				case SECOND:
				case SECUREFILE:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSION:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHRINK:
				case SHUTDOWN:
				case SIBLINGS:
				case SIZE:
				case SKIP_:
				case SOME:
				case SORT:
				case SPACE:
				case SPECIFICATION:
				case SPLIT:
				case STARTUP:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORAGE:
				case STORE:
				case STRING:
				case SHARD:
				case SHARDED:
				case SHARING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUPPLEMENTAL:
				case SUSPEND:
				case SYNONYM:
				case SYSTEM:
				case TABLES:
				case TABLESPACE:
				case TEMPLATE:
				case TEMPORARY:
				case THAN:
				case TIME:
				case TIMESTAMP:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIM:
				case TRUE:
				case TRUNCATE:
				case TRUSTED:
				case TYPE:
				case UNBOUNDED:
				case UNCONDITIONAL:
				case UNDER:
				case UNLIMITED:
				case UNLOCK:
				case UNUSABLE:
				case UNUSED:
				case USABLE:
				case USAGE:
				case USE:
				case USER:
				case USING:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARRAY:
				case VARRAYS:
				case VARYING:
				case VERSIONS:
				case VIRTUAL:
				case VISIBLE:
				case WAIT:
				case WHEN:
				case WITHIN:
				case WITHOUT:
				case WORK:
				case WRAPPED:
				case WRAPPER:
				case WRITE:
				case XML:
				case XMLNAMESPACES:
				case XMLSCHEMA:
				case XMLTABLE:
				case XMLTYPE:
				case YEAR:
				case ZONE:
				case REGULAR_IDENTIFIER:
				case QUOTED_IDENTIFIER:
					{
					State = 6211;
					identifier();
					}
					break;
				case LPAREN:
					{
					State = 6212;
					Match(LPAREN);
					State = 6213;
					identifier();
					State = 6214;
					Match(RPAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 6218;
				Match(EQUAL_SIGN);
				State = 6222;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,680,Context) ) {
				case 1:
					{
					State = 6219;
					flattenedQuery();
					}
					break;
				case 2:
					{
					State = 6220;
					fullExpression();
					}
					break;
				case 3:
					{
					State = 6221;
					defaultExpression();
					}
					break;
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6224;
				setColumnListClause();
				State = 6225;
				Match(EQUAL_SIGN);
				State = 6226;
				flattenedQuery();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetColumnListClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public SetColumnListClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setColumnListClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSetColumnListClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSetColumnListClause(this);
		}
	}

	[RuleVersion(0)]
	public SetColumnListClauseContext setColumnListClause() {
		SetColumnListClauseContext _localctx = new SetColumnListClauseContext(Context, State);
		EnterRule(_localctx, 1264, RULE_setColumnListClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6230;
			Match(LPAREN);
			State = 6231;
			identifierList();
			State = 6232;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UpdateStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UPDATE() { return GetToken(OracleAntlrParser.UPDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SetClauseContext setClause() {
			return GetRuleContext<SetClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OnlyClauseContext onlyClause() {
			return GetRuleContext<OnlyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturningClauseContext returningClause() {
			return GetRuleContext<ReturningClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingClauseContext errorLoggingClause() {
			return GetRuleContext<ErrorLoggingClauseContext>(0);
		}
		public UpdateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_updateStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUpdateStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUpdateStatement(this);
		}
	}

	[RuleVersion(0)]
	public UpdateStatementContext updateStatement() {
		UpdateStatementContext _localctx = new UpdateStatementContext(Context, State);
		EnterRule(_localctx, 1266, RULE_updateStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6234;
			Match(UPDATE);
			State = 6237;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,682,Context) ) {
			case 1:
				{
				State = 6235;
				onlyClause();
				}
				break;
			case 2:
				{
				State = 6236;
				fromClauseItem();
				}
				break;
			}
			State = 6239;
			setClause();
			State = 6241;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 6240;
				whereClause();
				}
			}

			State = 6244;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURNING) {
				{
				State = 6243;
				returningClause();
				}
			}

			State = 6247;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOG) {
				{
				State = 6246;
				errorLoggingClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeleteStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(OracleAntlrParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OnlyClauseContext onlyClause() {
			return GetRuleContext<OnlyClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(OracleAntlrParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturningClauseContext returningClause() {
			return GetRuleContext<ReturningClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingClauseContext errorLoggingClause() {
			return GetRuleContext<ErrorLoggingClauseContext>(0);
		}
		public DeleteStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deleteStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDeleteStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDeleteStatement(this);
		}
	}

	[RuleVersion(0)]
	public DeleteStatementContext deleteStatement() {
		DeleteStatementContext _localctx = new DeleteStatementContext(Context, State);
		EnterRule(_localctx, 1268, RULE_deleteStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6249;
			Match(DELETE);
			State = 6251;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FROM) {
				{
				State = 6250;
				Match(FROM);
				}
			}

			State = 6255;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,687,Context) ) {
			case 1:
				{
				State = 6253;
				onlyClause();
				}
				break;
			case 2:
				{
				State = 6254;
				fromClauseItem();
				}
				break;
			}
			State = 6258;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 6257;
				whereClause();
				}
			}

			State = 6261;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURNING) {
				{
				State = 6260;
				returningClause();
				}
			}

			State = 6264;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOG) {
				{
				State = 6263;
				errorLoggingClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CloseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE() { return GetToken(OracleAntlrParser.CLOSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public CloseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_closeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCloseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCloseStatement(this);
		}
	}

	[RuleVersion(0)]
	public CloseStatementContext closeStatement() {
		CloseStatementContext _localctx = new CloseStatementContext(Context, State);
		EnterRule(_localctx, 1270, RULE_closeStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6266;
			Match(CLOSE);
			State = 6267;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FetchStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FETCH() { return GetToken(OracleAntlrParser.FETCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FetchTargetListContext fetchTargetList() {
			return GetRuleContext<FetchTargetListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BulkCollectIntoClauseContext bulkCollectIntoClause() {
			return GetRuleContext<BulkCollectIntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FetchLimitClauseContext fetchLimitClause() {
			return GetRuleContext<FetchLimitClauseContext>(0);
		}
		public FetchStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fetchStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFetchStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFetchStatement(this);
		}
	}

	[RuleVersion(0)]
	public FetchStatementContext fetchStatement() {
		FetchStatementContext _localctx = new FetchStatementContext(Context, State);
		EnterRule(_localctx, 1272, RULE_fetchStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6269;
			Match(FETCH);
			State = 6270;
			identifier();
			State = 6273;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INTO:
				{
				State = 6271;
				fetchTargetList();
				}
				break;
			case BULK:
				{
				State = 6272;
				bulkCollectIntoClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6276;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LIMIT) {
				{
				State = 6275;
				fetchLimitClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FetchTargetListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		public FetchTargetListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fetchTargetList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFetchTargetList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFetchTargetList(this);
		}
	}

	[RuleVersion(0)]
	public FetchTargetListContext fetchTargetList() {
		FetchTargetListContext _localctx = new FetchTargetListContext(Context, State);
		EnterRule(_localctx, 1274, RULE_fetchTargetList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6278;
			Match(INTO);
			State = 6279;
			identifierList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BulkCollectIntoClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BULK() { return GetToken(OracleAntlrParser.BULK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLLECT() { return GetToken(OracleAntlrParser.COLLECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		public BulkCollectIntoClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bulkCollectIntoClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBulkCollectIntoClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBulkCollectIntoClause(this);
		}
	}

	[RuleVersion(0)]
	public BulkCollectIntoClauseContext bulkCollectIntoClause() {
		BulkCollectIntoClauseContext _localctx = new BulkCollectIntoClauseContext(Context, State);
		EnterRule(_localctx, 1276, RULE_bulkCollectIntoClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6281;
			Match(BULK);
			State = 6282;
			Match(COLLECT);
			State = 6283;
			Match(INTO);
			State = 6284;
			identifierList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FetchLimitClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIMIT() { return GetToken(OracleAntlrParser.LIMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public FetchLimitClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fetchLimitClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFetchLimitClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFetchLimitClause(this);
		}
	}

	[RuleVersion(0)]
	public FetchLimitClauseContext fetchLimitClause() {
		FetchLimitClauseContext _localctx = new FetchLimitClauseContext(Context, State);
		EnterRule(_localctx, 1278, RULE_fetchLimitClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6286;
			Match(LIMIT);
			State = 6287;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OpenStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN() { return GetToken(OracleAntlrParser.OPEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpenForClauseContext openForClause() {
			return GetRuleContext<OpenForClauseContext>(0);
		}
		public OpenStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_openStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOpenStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOpenStatement(this);
		}
	}

	[RuleVersion(0)]
	public OpenStatementContext openStatement() {
		OpenStatementContext _localctx = new OpenStatementContext(Context, State);
		EnterRule(_localctx, 1280, RULE_openStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6289;
			Match(OPEN);
			State = 6290;
			identifier();
			State = 6292;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 6291;
				openForClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OpenForClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingListContext usingList() {
			return GetRuleContext<UsingListContext>(0);
		}
		public OpenForClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_openForClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOpenForClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOpenForClause(this);
		}
	}

	[RuleVersion(0)]
	public OpenForClauseContext openForClause() {
		OpenForClauseContext _localctx = new OpenForClauseContext(Context, State);
		EnterRule(_localctx, 1282, RULE_openForClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6294;
			Match(FOR);
			State = 6300;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,695,Context) ) {
			case 1:
				{
				State = 6295;
				selectStatement();
				}
				break;
			case 2:
				{
				State = 6296;
				fullExpression();
				State = 6298;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 6297;
					usingList();
					}
				}

				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UsingListItemContext[] usingListItem() {
			return GetRuleContexts<UsingListItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingListItemContext usingListItem(int i) {
			return GetRuleContext<UsingListItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public UsingListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUsingList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUsingList(this);
		}
	}

	[RuleVersion(0)]
	public UsingListContext usingList() {
		UsingListContext _localctx = new UsingListContext(Context, State);
		EnterRule(_localctx, 1284, RULE_usingList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6302;
			Match(USING);
			State = 6303;
			usingListItem();
			State = 6308;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 6304;
				Match(COMMA);
				State = 6305;
				usingListItem();
				}
				}
				State = 6310;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingListItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OUT() { return GetToken(OracleAntlrParser.OUT, 0); }
		public UsingListItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingListItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUsingListItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUsingListItem(this);
		}
	}

	[RuleVersion(0)]
	public UsingListItemContext usingListItem() {
		UsingListItemContext _localctx = new UsingListItemContext(Context, State);
		EnterRule(_localctx, 1286, RULE_usingListItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6315;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,697,Context) ) {
			case 1:
				{
				State = 6311;
				Match(IN);
				State = 6312;
				Match(OUT);
				}
				break;
			case 2:
				{
				State = 6313;
				Match(IN);
				}
				break;
			case 3:
				{
				State = 6314;
				Match(OUT);
				}
				break;
			}
			State = 6317;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommitWorkStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMIT() { return GetToken(OracleAntlrParser.COMMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WORK() { return GetToken(OracleAntlrParser.WORK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommitWorkCommentClauseContext commitWorkCommentClause() {
			return GetRuleContext<CommitWorkCommentClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommitWorkWriteClauseContext commitWorkWriteClause() {
			return GetRuleContext<CommitWorkWriteClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommitWorkForceClauseContext commitWorkForceClause() {
			return GetRuleContext<CommitWorkForceClauseContext>(0);
		}
		public CommitWorkStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commitWorkStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCommitWorkStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCommitWorkStatement(this);
		}
	}

	[RuleVersion(0)]
	public CommitWorkStatementContext commitWorkStatement() {
		CommitWorkStatementContext _localctx = new CommitWorkStatementContext(Context, State);
		EnterRule(_localctx, 1288, RULE_commitWorkStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6319;
			Match(COMMIT);
			State = 6321;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WORK) {
				{
				State = 6320;
				Match(WORK);
				}
			}

			State = 6329;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMMENT:
				{
				State = 6323;
				commitWorkCommentClause();
				State = 6325;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WRITE) {
					{
					State = 6324;
					commitWorkWriteClause();
					}
				}

				}
				break;
			case WRITE:
				{
				State = 6327;
				commitWorkWriteClause();
				}
				break;
			case FORCE:
				{
				State = 6328;
				commitWorkForceClause();
				}
				break;
			case Eof:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommitWorkCommentClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMENT() { return GetToken(OracleAntlrParser.COMMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public CommitWorkCommentClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commitWorkCommentClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCommitWorkCommentClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCommitWorkCommentClause(this);
		}
	}

	[RuleVersion(0)]
	public CommitWorkCommentClauseContext commitWorkCommentClause() {
		CommitWorkCommentClauseContext _localctx = new CommitWorkCommentClauseContext(Context, State);
		EnterRule(_localctx, 1290, RULE_commitWorkCommentClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6331;
			Match(COMMENT);
			State = 6332;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommitWorkWriteClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRITE() { return GetToken(OracleAntlrParser.WRITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMEDIATE() { return GetToken(OracleAntlrParser.IMMEDIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BATCH() { return GetToken(OracleAntlrParser.BATCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WAIT() { return GetToken(OracleAntlrParser.WAIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOWAIT() { return GetToken(OracleAntlrParser.NOWAIT, 0); }
		public CommitWorkWriteClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commitWorkWriteClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCommitWorkWriteClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCommitWorkWriteClause(this);
		}
	}

	[RuleVersion(0)]
	public CommitWorkWriteClauseContext commitWorkWriteClause() {
		CommitWorkWriteClauseContext _localctx = new CommitWorkWriteClauseContext(Context, State);
		EnterRule(_localctx, 1292, RULE_commitWorkWriteClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6334;
			Match(WRITE);
			State = 6336;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BATCH || _la==IMMEDIATE) {
				{
				State = 6335;
				_la = TokenStream.LA(1);
				if ( !(_la==BATCH || _la==IMMEDIATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 6339;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOWAIT || _la==WAIT) {
				{
				State = 6338;
				_la = TokenStream.LA(1);
				if ( !(_la==NOWAIT || _la==WAIT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommitWorkForceClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORCE() { return GetToken(OracleAntlrParser.FORCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		public CommitWorkForceClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commitWorkForceClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCommitWorkForceClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCommitWorkForceClause(this);
		}
	}

	[RuleVersion(0)]
	public CommitWorkForceClauseContext commitWorkForceClause() {
		CommitWorkForceClauseContext _localctx = new CommitWorkForceClauseContext(Context, State);
		EnterRule(_localctx, 1294, RULE_commitWorkForceClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6341;
			Match(FORCE);
			State = 6342;
			literal();
			State = 6345;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 6343;
				Match(COMMA);
				State = 6344;
				Match(INTEGER_LITERAL);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetTransactionStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(OracleAntlrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRANSACTION() { return GetToken(OracleAntlrParser.TRANSACTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SetTransactionNameContext setTransactionName() {
			return GetRuleContext<SetTransactionNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetTransactionReadClauseContext setTransactionReadClause() {
			return GetRuleContext<SetTransactionReadClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IsolationLevelClauseContext isolationLevelClause() {
			return GetRuleContext<IsolationLevelClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UseRollbackSegmentClauseContext useRollbackSegmentClause() {
			return GetRuleContext<UseRollbackSegmentClauseContext>(0);
		}
		public SetTransactionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setTransactionStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSetTransactionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSetTransactionStatement(this);
		}
	}

	[RuleVersion(0)]
	public SetTransactionStatementContext setTransactionStatement() {
		SetTransactionStatementContext _localctx = new SetTransactionStatementContext(Context, State);
		EnterRule(_localctx, 1296, RULE_setTransactionStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6347;
			Match(SET);
			State = 6348;
			Match(TRANSACTION);
			State = 6358;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ISOLATION:
			case READ:
			case USE:
				{
				State = 6352;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case READ:
					{
					State = 6349;
					setTransactionReadClause();
					}
					break;
				case ISOLATION:
					{
					State = 6350;
					isolationLevelClause();
					}
					break;
				case USE:
					{
					State = 6351;
					useRollbackSegmentClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 6355;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NAME) {
					{
					State = 6354;
					setTransactionName();
					}
				}

				}
				break;
			case NAME:
				{
				State = 6357;
				setTransactionName();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetTransactionNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAME() { return GetToken(OracleAntlrParser.NAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public SetTransactionNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setTransactionName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSetTransactionName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSetTransactionName(this);
		}
	}

	[RuleVersion(0)]
	public SetTransactionNameContext setTransactionName() {
		SetTransactionNameContext _localctx = new SetTransactionNameContext(Context, State);
		EnterRule(_localctx, 1298, RULE_setTransactionName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6360;
			Match(NAME);
			State = 6361;
			literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetTransactionReadClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READ() { return GetToken(OracleAntlrParser.READ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLY() { return GetToken(OracleAntlrParser.ONLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRITE() { return GetToken(OracleAntlrParser.WRITE, 0); }
		public SetTransactionReadClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setTransactionReadClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSetTransactionReadClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSetTransactionReadClause(this);
		}
	}

	[RuleVersion(0)]
	public SetTransactionReadClauseContext setTransactionReadClause() {
		SetTransactionReadClauseContext _localctx = new SetTransactionReadClauseContext(Context, State);
		EnterRule(_localctx, 1300, RULE_setTransactionReadClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6363;
			Match(READ);
			State = 6365;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ONLY || _la==WRITE) {
				{
				State = 6364;
				_la = TokenStream.LA(1);
				if ( !(_la==ONLY || _la==WRITE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IsolationLevelClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ISOLATION() { return GetToken(OracleAntlrParser.ISOLATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEVEL() { return GetToken(OracleAntlrParser.LEVEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERIALIZABLE() { return GetToken(OracleAntlrParser.SERIALIZABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READ() { return GetToken(OracleAntlrParser.READ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMITTED() { return GetToken(OracleAntlrParser.COMMITTED, 0); }
		public IsolationLevelClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_isolationLevelClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIsolationLevelClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIsolationLevelClause(this);
		}
	}

	[RuleVersion(0)]
	public IsolationLevelClauseContext isolationLevelClause() {
		IsolationLevelClauseContext _localctx = new IsolationLevelClauseContext(Context, State);
		EnterRule(_localctx, 1302, RULE_isolationLevelClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6367;
			Match(ISOLATION);
			State = 6368;
			Match(LEVEL);
			State = 6372;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SERIALIZABLE:
				{
				State = 6369;
				Match(SERIALIZABLE);
				}
				break;
			case READ:
				{
				State = 6370;
				Match(READ);
				State = 6371;
				Match(COMMITTED);
				}
				break;
			case Eof:
			case NAME:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UseRollbackSegmentClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USE() { return GetToken(OracleAntlrParser.USE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLLBACK() { return GetToken(OracleAntlrParser.ROLLBACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEGMENT() { return GetToken(OracleAntlrParser.SEGMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public UseRollbackSegmentClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_useRollbackSegmentClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterUseRollbackSegmentClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitUseRollbackSegmentClause(this);
		}
	}

	[RuleVersion(0)]
	public UseRollbackSegmentClauseContext useRollbackSegmentClause() {
		UseRollbackSegmentClauseContext _localctx = new UseRollbackSegmentClauseContext(Context, State);
		EnterRule(_localctx, 1304, RULE_useRollbackSegmentClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6374;
			Match(USE);
			State = 6375;
			Match(ROLLBACK);
			State = 6376;
			Match(SEGMENT);
			State = 6377;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RollbackWorkStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLLBACK() { return GetToken(OracleAntlrParser.ROLLBACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WORK() { return GetToken(OracleAntlrParser.WORK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ToSavepointClauseContext toSavepointClause() {
			return GetRuleContext<ToSavepointClauseContext>(0);
		}
		public RollbackWorkStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollbackWorkStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRollbackWorkStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRollbackWorkStatement(this);
		}
	}

	[RuleVersion(0)]
	public RollbackWorkStatementContext rollbackWorkStatement() {
		RollbackWorkStatementContext _localctx = new RollbackWorkStatementContext(Context, State);
		EnterRule(_localctx, 1306, RULE_rollbackWorkStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6379;
			Match(ROLLBACK);
			State = 6381;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WORK) {
				{
				State = 6380;
				Match(WORK);
				}
			}

			State = 6384;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TO) {
				{
				State = 6383;
				toSavepointClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ToSavepointClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(OracleAntlrParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SAVEPOINT() { return GetToken(OracleAntlrParser.SAVEPOINT, 0); }
		public ToSavepointClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_toSavepointClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterToSavepointClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitToSavepointClause(this);
		}
	}

	[RuleVersion(0)]
	public ToSavepointClauseContext toSavepointClause() {
		ToSavepointClauseContext _localctx = new ToSavepointClauseContext(Context, State);
		EnterRule(_localctx, 1308, RULE_toSavepointClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6386;
			Match(TO);
			State = 6388;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,711,Context) ) {
			case 1:
				{
				State = 6387;
				Match(SAVEPOINT);
				}
				break;
			}
			State = 6390;
			simpleIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SavepointStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SAVEPOINT() { return GetToken(OracleAntlrParser.SAVEPOINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		public SavepointStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_savepointStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSavepointStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSavepointStatement(this);
		}
	}

	[RuleVersion(0)]
	public SavepointStatementContext savepointStatement() {
		SavepointStatementContext _localctx = new SavepointStatementContext(Context, State);
		EnterRule(_localctx, 1310, RULE_savepointStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6392;
			Match(SAVEPOINT);
			State = 6393;
			simpleIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN_OPERATOR() { return GetToken(OracleAntlrParser.ASSIGN_OPERATOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public AssignmentStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignmentStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAssignmentStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAssignmentStatement(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentStatementContext assignmentStatement() {
		AssignmentStatementContext _localctx = new AssignmentStatementContext(Context, State);
		EnterRule(_localctx, 1312, RULE_assignmentStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6395;
			identifier();
			State = 6396;
			Match(ASSIGN_OPERATOR);
			State = 6397;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ErrorLoggingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOG() { return GetToken(OracleAntlrParser.LOG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERRORS() { return GetToken(OracleAntlrParser.ERRORS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingIntoClauseContext errorLoggingIntoClause() {
			return GetRuleContext<ErrorLoggingIntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingTagExpressionContext errorLoggingTagExpression() {
			return GetRuleContext<ErrorLoggingTagExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingRejectLimitContext errorLoggingRejectLimit() {
			return GetRuleContext<ErrorLoggingRejectLimitContext>(0);
		}
		public ErrorLoggingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_errorLoggingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterErrorLoggingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitErrorLoggingClause(this);
		}
	}

	[RuleVersion(0)]
	public ErrorLoggingClauseContext errorLoggingClause() {
		ErrorLoggingClauseContext _localctx = new ErrorLoggingClauseContext(Context, State);
		EnterRule(_localctx, 1314, RULE_errorLoggingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6399;
			Match(LOG);
			State = 6400;
			Match(ERRORS);
			State = 6402;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,712,Context) ) {
			case 1:
				{
				State = 6401;
				errorLoggingIntoClause();
				}
				break;
			}
			State = 6405;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,713,Context) ) {
			case 1:
				{
				State = 6404;
				errorLoggingTagExpression();
				}
				break;
			}
			State = 6408;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REJECT) {
				{
				State = 6407;
				errorLoggingRejectLimit();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ErrorLoggingIntoClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ErrorLoggingIntoClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_errorLoggingIntoClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterErrorLoggingIntoClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitErrorLoggingIntoClause(this);
		}
	}

	[RuleVersion(0)]
	public ErrorLoggingIntoClauseContext errorLoggingIntoClause() {
		ErrorLoggingIntoClauseContext _localctx = new ErrorLoggingIntoClauseContext(Context, State);
		EnterRule(_localctx, 1316, RULE_errorLoggingIntoClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6410;
			Match(INTO);
			State = 6411;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ErrorLoggingTagExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public ErrorLoggingTagExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_errorLoggingTagExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterErrorLoggingTagExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitErrorLoggingTagExpression(this);
		}
	}

	[RuleVersion(0)]
	public ErrorLoggingTagExpressionContext errorLoggingTagExpression() {
		ErrorLoggingTagExpressionContext _localctx = new ErrorLoggingTagExpressionContext(Context, State);
		EnterRule(_localctx, 1318, RULE_errorLoggingTagExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6413;
			Match(LPAREN);
			State = 6414;
			fullExpression();
			State = 6415;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ErrorLoggingRejectLimitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REJECT() { return GetToken(OracleAntlrParser.REJECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIMIT() { return GetToken(OracleAntlrParser.LIMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNLIMITED() { return GetToken(OracleAntlrParser.UNLIMITED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ErrorLoggingRejectLimitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_errorLoggingRejectLimit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterErrorLoggingRejectLimit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitErrorLoggingRejectLimit(this);
		}
	}

	[RuleVersion(0)]
	public ErrorLoggingRejectLimitContext errorLoggingRejectLimit() {
		ErrorLoggingRejectLimitContext _localctx = new ErrorLoggingRejectLimitContext(Context, State);
		EnterRule(_localctx, 1320, RULE_errorLoggingRejectLimit);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6417;
			Match(REJECT);
			State = 6418;
			Match(LIMIT);
			State = 6421;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNLIMITED:
				{
				State = 6419;
				Match(UNLIMITED);
				}
				break;
			case DATE:
			case FALSE:
			case INTERVAL:
			case TIMESTAMP:
			case TRUE:
			case INTEGER_LITERAL:
			case FLOATING_POINT_LITERAL:
			case FLOATING_POINT_BINARY_LITERAL:
			case UNICODE_CHARACTER_STRING_LITERAL:
			case BINARY_STRING_LITERAL:
			case CHARACTER_STRING_LITERAL:
			case MONEY_LITERAL:
			case QUOTE_CHARACTER_STRING_LITERAL:
				{
				State = 6420;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MERGE() { return GetToken(OracleAntlrParser.MERGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeUsingClauseContext mergeUsingClause() {
			return GetRuleContext<MergeUsingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeConditionClauseContext mergeConditionClause() {
			return GetRuleContext<MergeConditionClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeUpdateOrInsertClauseContext mergeUpdateOrInsertClause() {
			return GetRuleContext<MergeUpdateOrInsertClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorLoggingClauseContext errorLoggingClause() {
			return GetRuleContext<ErrorLoggingClauseContext>(0);
		}
		public MergeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMergeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMergeStatement(this);
		}
	}

	[RuleVersion(0)]
	public MergeStatementContext mergeStatement() {
		MergeStatementContext _localctx = new MergeStatementContext(Context, State);
		EnterRule(_localctx, 1322, RULE_mergeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6423;
			Match(MERGE);
			State = 6424;
			Match(INTO);
			State = 6425;
			fromClauseItem();
			State = 6426;
			mergeUsingClause();
			State = 6427;
			mergeConditionClause();
			State = 6429;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHEN) {
				{
				State = 6428;
				mergeUpdateOrInsertClause();
				}
			}

			State = 6432;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOG) {
				{
				State = 6431;
				errorLoggingClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeUpdateOrInsertClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MergeUpdateClauseContext mergeUpdateClause() {
			return GetRuleContext<MergeUpdateClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeInsertClauseContext mergeInsertClause() {
			return GetRuleContext<MergeInsertClauseContext>(0);
		}
		public MergeUpdateOrInsertClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeUpdateOrInsertClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMergeUpdateOrInsertClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMergeUpdateOrInsertClause(this);
		}
	}

	[RuleVersion(0)]
	public MergeUpdateOrInsertClauseContext mergeUpdateOrInsertClause() {
		MergeUpdateOrInsertClauseContext _localctx = new MergeUpdateOrInsertClauseContext(Context, State);
		EnterRule(_localctx, 1324, RULE_mergeUpdateOrInsertClause);
		int _la;
		try {
			State = 6442;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,720,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6434;
				mergeUpdateClause();
				State = 6436;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHEN) {
					{
					State = 6435;
					mergeInsertClause();
					}
				}

				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6438;
				mergeInsertClause();
				State = 6440;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHEN) {
					{
					State = 6439;
					mergeUpdateClause();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeUsingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem() {
			return GetRuleContext<FromClauseItemContext>(0);
		}
		public MergeUsingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeUsingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMergeUsingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMergeUsingClause(this);
		}
	}

	[RuleVersion(0)]
	public MergeUsingClauseContext mergeUsingClause() {
		MergeUsingClauseContext _localctx = new MergeUsingClauseContext(Context, State);
		EnterRule(_localctx, 1326, RULE_mergeUsingClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6444;
			Match(USING);
			State = 6445;
			fromClauseItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeConditionClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(OracleAntlrParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public MergeConditionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeConditionClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMergeConditionClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMergeConditionClause(this);
		}
	}

	[RuleVersion(0)]
	public MergeConditionClauseContext mergeConditionClause() {
		MergeConditionClauseContext _localctx = new MergeConditionClauseContext(Context, State);
		EnterRule(_localctx, 1328, RULE_mergeConditionClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6447;
			Match(ON);
			State = 6448;
			Match(LPAREN);
			State = 6449;
			fullExpression();
			State = 6450;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeUpdateClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATCHED() { return GetToken(OracleAntlrParser.MATCHED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(OracleAntlrParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UPDATE() { return GetToken(OracleAntlrParser.UPDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SetClauseContext setClause() {
			return GetRuleContext<SetClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeleteWhereClauseContext deleteWhereClause() {
			return GetRuleContext<DeleteWhereClauseContext>(0);
		}
		public MergeUpdateClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeUpdateClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMergeUpdateClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMergeUpdateClause(this);
		}
	}

	[RuleVersion(0)]
	public MergeUpdateClauseContext mergeUpdateClause() {
		MergeUpdateClauseContext _localctx = new MergeUpdateClauseContext(Context, State);
		EnterRule(_localctx, 1330, RULE_mergeUpdateClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6452;
			Match(WHEN);
			State = 6453;
			Match(MATCHED);
			State = 6454;
			Match(THEN);
			State = 6455;
			Match(UPDATE);
			State = 6456;
			setClause();
			State = 6458;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 6457;
				whereClause();
				}
			}

			State = 6461;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DELETE) {
				{
				State = 6460;
				deleteWhereClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeleteWhereClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(OracleAntlrParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public DeleteWhereClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deleteWhereClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDeleteWhereClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDeleteWhereClause(this);
		}
	}

	[RuleVersion(0)]
	public DeleteWhereClauseContext deleteWhereClause() {
		DeleteWhereClauseContext _localctx = new DeleteWhereClauseContext(Context, State);
		EnterRule(_localctx, 1332, RULE_deleteWhereClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6463;
			Match(DELETE);
			State = 6464;
			whereClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeInsertClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATCHED() { return GetToken(OracleAntlrParser.MATCHED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(OracleAntlrParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSERT() { return GetToken(OracleAntlrParser.INSERT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ValuesClauseContext valuesClause() {
			return GetRuleContext<ValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertColumnListClauseContext insertColumnListClause() {
			return GetRuleContext<InsertColumnListClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public MergeInsertClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeInsertClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterMergeInsertClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitMergeInsertClause(this);
		}
	}

	[RuleVersion(0)]
	public MergeInsertClauseContext mergeInsertClause() {
		MergeInsertClauseContext _localctx = new MergeInsertClauseContext(Context, State);
		EnterRule(_localctx, 1334, RULE_mergeInsertClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6466;
			Match(WHEN);
			State = 6467;
			Match(NOT);
			State = 6468;
			Match(MATCHED);
			State = 6469;
			Match(THEN);
			State = 6470;
			Match(INSERT);
			State = 6472;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 6471;
				insertColumnListClause();
				}
			}

			State = 6474;
			valuesClause();
			State = 6476;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 6475;
				whereClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExecuteImmediateStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXECUTE() { return GetToken(OracleAntlrParser.EXECUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMEDIATE() { return GetToken(OracleAntlrParser.IMMEDIATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntoClauseContext intoClause() {
			return GetRuleContext<IntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BulkCollectIntoClauseContext bulkCollectIntoClause() {
			return GetRuleContext<BulkCollectIntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingListContext usingList() {
			return GetRuleContext<UsingListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExecuteReturningClauseContext executeReturningClause() {
			return GetRuleContext<ExecuteReturningClauseContext>(0);
		}
		public ExecuteImmediateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_executeImmediateStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExecuteImmediateStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExecuteImmediateStatement(this);
		}
	}

	[RuleVersion(0)]
	public ExecuteImmediateStatementContext executeImmediateStatement() {
		ExecuteImmediateStatementContext _localctx = new ExecuteImmediateStatementContext(Context, State);
		EnterRule(_localctx, 1336, RULE_executeImmediateStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6478;
			Match(EXECUTE);
			State = 6479;
			Match(IMMEDIATE);
			State = 6480;
			fullExpression();
			State = 6483;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INTO:
				{
				State = 6481;
				intoClause();
				}
				break;
			case BULK:
				{
				State = 6482;
				bulkCollectIntoClause();
				}
				break;
			case Eof:
			case RETURN:
			case RETURNING:
			case USING:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			State = 6486;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 6485;
				usingList();
				}
			}

			State = 6489;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURN || _la==RETURNING) {
				{
				State = 6488;
				executeReturningClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExecuteReturningClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IntoClauseContext intoClause() {
			return GetRuleContext<IntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURNING() { return GetToken(OracleAntlrParser.RETURNING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(OracleAntlrParser.RETURN, 0); }
		public ExecuteReturningClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_executeReturningClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExecuteReturningClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExecuteReturningClause(this);
		}
	}

	[RuleVersion(0)]
	public ExecuteReturningClauseContext executeReturningClause() {
		ExecuteReturningClauseContext _localctx = new ExecuteReturningClauseContext(Context, State);
		EnterRule(_localctx, 1338, RULE_executeReturningClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6491;
			_la = TokenStream.LA(1);
			if ( !(_la==RETURN || _la==RETURNING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 6492;
			intoClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PipeRowStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PIPE() { return GetToken(OracleAntlrParser.PIPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PureExpressionContext pureExpression() {
			return GetRuleContext<PureExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public PipeRowStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pipeRowStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPipeRowStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPipeRowStatement(this);
		}
	}

	[RuleVersion(0)]
	public PipeRowStatementContext pipeRowStatement() {
		PipeRowStatementContext _localctx = new PipeRowStatementContext(Context, State);
		EnterRule(_localctx, 1340, RULE_pipeRowStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6494;
			Match(PIPE);
			State = 6495;
			Match(ROW);
			State = 6496;
			Match(LPAREN);
			State = 6497;
			pureExpression();
			State = 6498;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RaiseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RAISE() { return GetToken(OracleAntlrParser.RAISE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public RaiseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_raiseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRaiseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRaiseStatement(this);
		}
	}

	[RuleVersion(0)]
	public RaiseStatementContext raiseStatement() {
		RaiseStatementContext _localctx = new RaiseStatementContext(Context, State);
		EnterRule(_localctx, 1342, RULE_raiseStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6500;
			Match(RAISE);
			State = 6502;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 6501;
				identifier();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TruncateTableStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUNCATE() { return GetToken(OracleAntlrParser.TRUNCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TruncateTableLogClauseContext truncateTableLogClause() {
			return GetRuleContext<TruncateTableLogClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TruncateStatementStorageClauseContext truncateStatementStorageClause() {
			return GetRuleContext<TruncateStatementStorageClauseContext>(0);
		}
		public TruncateTableStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_truncateTableStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTruncateTableStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTruncateTableStatement(this);
		}
	}

	[RuleVersion(0)]
	public TruncateTableStatementContext truncateTableStatement() {
		TruncateTableStatementContext _localctx = new TruncateTableStatementContext(Context, State);
		EnterRule(_localctx, 1344, RULE_truncateTableStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6504;
			Match(TRUNCATE);
			State = 6505;
			Match(TABLE);
			State = 6506;
			identifier();
			State = 6508;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PRESERVE || _la==PURGE) {
				{
				State = 6507;
				truncateTableLogClause();
				}
			}

			State = 6511;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DROP || _la==REUSE) {
				{
				State = 6510;
				truncateStatementStorageClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TruncateTableLogClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PreservePurgeClauseContext preservePurgeClause() {
			return GetRuleContext<PreservePurgeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATERIALIZED() { return GetToken(OracleAntlrParser.MATERIALIZED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VIEW() { return GetToken(OracleAntlrParser.VIEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOG() { return GetToken(OracleAntlrParser.LOG, 0); }
		public TruncateTableLogClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_truncateTableLogClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTruncateTableLogClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTruncateTableLogClause(this);
		}
	}

	[RuleVersion(0)]
	public TruncateTableLogClauseContext truncateTableLogClause() {
		TruncateTableLogClauseContext _localctx = new TruncateTableLogClauseContext(Context, State);
		EnterRule(_localctx, 1346, RULE_truncateTableLogClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6513;
			preservePurgeClause();
			State = 6514;
			Match(MATERIALIZED);
			State = 6515;
			Match(VIEW);
			State = 6516;
			Match(LOG);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PreservePurgeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRESERVE() { return GetToken(OracleAntlrParser.PRESERVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PURGE() { return GetToken(OracleAntlrParser.PURGE, 0); }
		public PreservePurgeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_preservePurgeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPreservePurgeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPreservePurgeClause(this);
		}
	}

	[RuleVersion(0)]
	public PreservePurgeClauseContext preservePurgeClause() {
		PreservePurgeClauseContext _localctx = new PreservePurgeClauseContext(Context, State);
		EnterRule(_localctx, 1348, RULE_preservePurgeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6518;
			_la = TokenStream.LA(1);
			if ( !(_la==PRESERVE || _la==PURGE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TruncateClusterStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUNCATE() { return GetToken(OracleAntlrParser.TRUNCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLUSTER() { return GetToken(OracleAntlrParser.CLUSTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TruncateStatementStorageClauseContext truncateStatementStorageClause() {
			return GetRuleContext<TruncateStatementStorageClauseContext>(0);
		}
		public TruncateClusterStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_truncateClusterStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTruncateClusterStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTruncateClusterStatement(this);
		}
	}

	[RuleVersion(0)]
	public TruncateClusterStatementContext truncateClusterStatement() {
		TruncateClusterStatementContext _localctx = new TruncateClusterStatementContext(Context, State);
		EnterRule(_localctx, 1350, RULE_truncateClusterStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6520;
			Match(TRUNCATE);
			State = 6521;
			Match(CLUSTER);
			State = 6522;
			identifier();
			State = 6524;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DROP || _la==REUSE) {
				{
				State = 6523;
				truncateStatementStorageClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TruncateStatementStorageClauseContext : ParserRuleContext {
		public IToken clauseType;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STORAGE() { return GetToken(OracleAntlrParser.STORAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(OracleAntlrParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REUSE() { return GetToken(OracleAntlrParser.REUSE, 0); }
		public TruncateStatementStorageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_truncateStatementStorageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTruncateStatementStorageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTruncateStatementStorageClause(this);
		}
	}

	[RuleVersion(0)]
	public TruncateStatementStorageClauseContext truncateStatementStorageClause() {
		TruncateStatementStorageClauseContext _localctx = new TruncateStatementStorageClauseContext(Context, State);
		EnterRule(_localctx, 1352, RULE_truncateStatementStorageClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6526;
			_localctx.clauseType = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DROP || _la==REUSE) ) {
				_localctx.clauseType = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 6527;
			Match(STORAGE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockTableStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCK() { return GetToken(OracleAntlrParser.LOCK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LockTableItemListContext lockTableItemList() {
			return GetRuleContext<LockTableItemListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LockTableModeClauseContext lockTableModeClause() {
			return GetRuleContext<LockTableModeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LockTableNowaitClauseContext lockTableNowaitClause() {
			return GetRuleContext<LockTableNowaitClauseContext>(0);
		}
		public LockTableStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockTableStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLockTableStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLockTableStatement(this);
		}
	}

	[RuleVersion(0)]
	public LockTableStatementContext lockTableStatement() {
		LockTableStatementContext _localctx = new LockTableStatementContext(Context, State);
		EnterRule(_localctx, 1354, RULE_lockTableStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6529;
			Match(LOCK);
			State = 6530;
			Match(TABLE);
			State = 6531;
			lockTableItemList();
			State = 6532;
			lockTableModeClause();
			State = 6534;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOWAIT) {
				{
				State = 6533;
				lockTableNowaitClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockTableItemListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext[] fromClauseItem() {
			return GetRuleContexts<FromClauseItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FromClauseItemContext fromClauseItem(int i) {
			return GetRuleContext<FromClauseItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public LockTableItemListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockTableItemList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLockTableItemList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLockTableItemList(this);
		}
	}

	[RuleVersion(0)]
	public LockTableItemListContext lockTableItemList() {
		LockTableItemListContext _localctx = new LockTableItemListContext(Context, State);
		EnterRule(_localctx, 1356, RULE_lockTableItemList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6536;
			fromClauseItem();
			State = 6541;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 6537;
				Match(COMMA);
				State = 6538;
				fromClauseItem();
				}
				}
				State = 6543;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockTableModeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MODE() { return GetToken(OracleAntlrParser.MODE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(OracleAntlrParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARE() { return GetToken(OracleAntlrParser.SHARE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLUSIVE() { return GetToken(OracleAntlrParser.EXCLUSIVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UPDATE() { return GetToken(OracleAntlrParser.UPDATE, 0); }
		public LockTableModeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockTableModeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLockTableModeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLockTableModeClause(this);
		}
	}

	[RuleVersion(0)]
	public LockTableModeClauseContext lockTableModeClause() {
		LockTableModeClauseContext _localctx = new LockTableModeClauseContext(Context, State);
		EnterRule(_localctx, 1358, RULE_lockTableModeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6544;
			Match(IN);
			State = 6554;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ROW:
				{
				State = 6545;
				Match(ROW);
				State = 6546;
				_la = TokenStream.LA(1);
				if ( !(_la==EXCLUSIVE || _la==SHARE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case SHARE:
				{
				State = 6547;
				Match(SHARE);
				State = 6551;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case UPDATE:
					{
					State = 6548;
					Match(UPDATE);
					}
					break;
				case ROW:
					{
					State = 6549;
					Match(ROW);
					State = 6550;
					Match(EXCLUSIVE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case EXCLUSIVE:
				{
				State = 6553;
				Match(EXCLUSIVE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6556;
			Match(MODE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockTableNowaitClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOWAIT() { return GetToken(OracleAntlrParser.NOWAIT, 0); }
		public LockTableNowaitClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockTableNowaitClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLockTableNowaitClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLockTableNowaitClause(this);
		}
	}

	[RuleVersion(0)]
	public LockTableNowaitClauseContext lockTableNowaitClause() {
		LockTableNowaitClauseContext _localctx = new LockTableNowaitClauseContext(Context, State);
		EnterRule(_localctx, 1360, RULE_lockTableNowaitClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6558;
			Match(NOWAIT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TranslateExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRANSLATE() { return GetToken(OracleAntlrParser.TRANSLATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAR_CS() { return GetToken(OracleAntlrParser.CHAR_CS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NCHAR_CS() { return GetToken(OracleAntlrParser.NCHAR_CS, 0); }
		public TranslateExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_translateExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTranslateExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTranslateExpression(this);
		}
	}

	[RuleVersion(0)]
	public TranslateExpressionContext translateExpression() {
		TranslateExpressionContext _localctx = new TranslateExpressionContext(Context, State);
		EnterRule(_localctx, 1362, RULE_translateExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6560;
			Match(TRANSLATE);
			State = 6561;
			Match(LPAREN);
			State = 6562;
			fullExpression();
			State = 6563;
			Match(USING);
			State = 6564;
			_la = TokenStream.LA(1);
			if ( !(_la==CHAR_CS || _la==NCHAR_CS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 6565;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CharExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHR() { return GetToken(OracleAntlrParser.CHR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(OracleAntlrParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NCHAR_CS() { return GetToken(OracleAntlrParser.NCHAR_CS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NCHR() { return GetToken(OracleAntlrParser.NCHR, 0); }
		public CharExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_charExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCharExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCharExpression(this);
		}
	}

	[RuleVersion(0)]
	public CharExpressionContext charExpression() {
		CharExpressionContext _localctx = new CharExpressionContext(Context, State);
		EnterRule(_localctx, 1364, RULE_charExpression);
		try {
			State = 6579;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CHR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6567;
				Match(CHR);
				State = 6568;
				Match(LPAREN);
				State = 6569;
				fullExpression();
				State = 6570;
				Match(USING);
				State = 6571;
				Match(NCHAR_CS);
				State = 6572;
				Match(RPAREN);
				}
				break;
			case NCHR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6574;
				Match(NCHR);
				State = 6575;
				Match(LPAREN);
				State = 6576;
				fullExpression();
				State = 6577;
				Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ControlStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhileStatementContext whileStatement() {
			return GetRuleContext<WhileStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForStatementContext forStatement() {
			return GetRuleContext<ForStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseStatementContext caseStatement() {
			return GetRuleContext<CaseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoopStatementContext loopStatement() {
			return GetRuleContext<LoopStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForAllStatementContext forAllStatement() {
			return GetRuleContext<ForAllStatementContext>(0);
		}
		public ControlStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_controlStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterControlStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitControlStructure(this);
		}
	}

	[RuleVersion(0)]
	public ControlStructureContext controlStructure() {
		ControlStructureContext _localctx = new ControlStructureContext(Context, State);
		EnterRule(_localctx, 1366, RULE_controlStructure);
		try {
			State = 6587;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IF:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6581;
				ifStatement();
				}
				break;
			case WHILE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6582;
				whileStatement();
				}
				break;
			case FOR:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6583;
				forStatement();
				}
				break;
			case CASE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 6584;
				caseStatement();
				}
				break;
			case LOOP:
				EnterOuterAlt(_localctx, 5);
				{
				State = 6585;
				loopStatement();
				}
				break;
			case FORALL:
				EnterOuterAlt(_localctx, 6);
				{
				State = 6586;
				forAllStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForAllStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORALL() { return GetToken(OracleAntlrParser.FORALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForAllInClauseContext forAllInClause() {
			return GetRuleContext<ForAllInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertStatementContext insertStatement() {
			return GetRuleContext<InsertStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeleteStatementContext deleteStatement() {
			return GetRuleContext<DeleteStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UpdateStatementContext updateStatement() {
			return GetRuleContext<UpdateStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeStatementContext mergeStatement() {
			return GetRuleContext<MergeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExecuteImmediateStatementContext executeImmediateStatement() {
			return GetRuleContext<ExecuteImmediateStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForAllSaveExceptionsClauseContext forAllSaveExceptionsClause() {
			return GetRuleContext<ForAllSaveExceptionsClauseContext>(0);
		}
		public ForAllStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forAllStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForAllStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForAllStatement(this);
		}
	}

	[RuleVersion(0)]
	public ForAllStatementContext forAllStatement() {
		ForAllStatementContext _localctx = new ForAllStatementContext(Context, State);
		EnterRule(_localctx, 1368, RULE_forAllStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6589;
			Match(FORALL);
			State = 6590;
			simpleIdentifier();
			State = 6591;
			forAllInClause();
			State = 6593;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SAVE) {
				{
				State = 6592;
				forAllSaveExceptionsClause();
				}
			}

			State = 6600;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INSERT:
				{
				State = 6595;
				insertStatement();
				}
				break;
			case DELETE:
				{
				State = 6596;
				deleteStatement();
				}
				break;
			case UPDATE:
				{
				State = 6597;
				updateStatement();
				}
				break;
			case MERGE:
				{
				State = 6598;
				mergeStatement();
				}
				break;
			case EXECUTE:
				{
				State = 6599;
				executeImmediateStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForAllInClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ForAllIndicesClauseContext forAllIndicesClause() {
			return GetRuleContext<ForAllIndicesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForAllValuesClauseContext forAllValuesClause() {
			return GetRuleContext<ForAllValuesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForAllLowerUpperBoundClauseContext forAllLowerUpperBoundClause() {
			return GetRuleContext<ForAllLowerUpperBoundClauseContext>(0);
		}
		public ForAllInClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forAllInClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForAllInClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForAllInClause(this);
		}
	}

	[RuleVersion(0)]
	public ForAllInClauseContext forAllInClause() {
		ForAllInClauseContext _localctx = new ForAllInClauseContext(Context, State);
		EnterRule(_localctx, 1370, RULE_forAllInClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6602;
			Match(IN);
			State = 6606;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,740,Context) ) {
			case 1:
				{
				State = 6603;
				forAllIndicesClause();
				}
				break;
			case 2:
				{
				State = 6604;
				forAllValuesClause();
				}
				break;
			case 3:
				{
				State = 6605;
				forAllLowerUpperBoundClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForAllIndicesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDICES() { return GetToken(OracleAntlrParser.INDICES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForAllIndeciesBoundsClauseContext forAllIndeciesBoundsClause() {
			return GetRuleContext<ForAllIndeciesBoundsClauseContext>(0);
		}
		public ForAllIndicesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forAllIndicesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForAllIndicesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForAllIndicesClause(this);
		}
	}

	[RuleVersion(0)]
	public ForAllIndicesClauseContext forAllIndicesClause() {
		ForAllIndicesClauseContext _localctx = new ForAllIndicesClauseContext(Context, State);
		EnterRule(_localctx, 1372, RULE_forAllIndicesClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6608;
			Match(INDICES);
			State = 6609;
			Match(OF);
			State = 6610;
			identifier();
			State = 6612;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BETWEEN) {
				{
				State = 6611;
				forAllIndeciesBoundsClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForAllIndeciesBoundsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BETWEEN() { return GetToken(OracleAntlrParser.BETWEEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(OracleAntlrParser.AND, 0); }
		public ForAllIndeciesBoundsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forAllIndeciesBoundsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForAllIndeciesBoundsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForAllIndeciesBoundsClause(this);
		}
	}

	[RuleVersion(0)]
	public ForAllIndeciesBoundsClauseContext forAllIndeciesBoundsClause() {
		ForAllIndeciesBoundsClauseContext _localctx = new ForAllIndeciesBoundsClauseContext(Context, State);
		EnterRule(_localctx, 1374, RULE_forAllIndeciesBoundsClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6614;
			Match(BETWEEN);
			State = 6615;
			fullExpression();
			State = 6618;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AND) {
				{
				State = 6616;
				Match(AND);
				State = 6617;
				fullExpression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForAllValuesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUES() { return GetToken(OracleAntlrParser.VALUES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ForAllValuesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forAllValuesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForAllValuesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForAllValuesClause(this);
		}
	}

	[RuleVersion(0)]
	public ForAllValuesClauseContext forAllValuesClause() {
		ForAllValuesClauseContext _localctx = new ForAllValuesClauseContext(Context, State);
		EnterRule(_localctx, 1376, RULE_forAllValuesClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6620;
			Match(VALUES);
			State = 6621;
			Match(OF);
			State = 6622;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForAllLowerUpperBoundClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterDoubleDotContext delimiterDoubleDot() {
			return GetRuleContext<DelimiterDoubleDotContext>(0);
		}
		public ForAllLowerUpperBoundClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forAllLowerUpperBoundClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForAllLowerUpperBoundClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForAllLowerUpperBoundClause(this);
		}
	}

	[RuleVersion(0)]
	public ForAllLowerUpperBoundClauseContext forAllLowerUpperBoundClause() {
		ForAllLowerUpperBoundClauseContext _localctx = new ForAllLowerUpperBoundClauseContext(Context, State);
		EnterRule(_localctx, 1378, RULE_forAllLowerUpperBoundClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6624;
			fullExpression();
			State = 6625;
			delimiterDoubleDot();
			State = 6626;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForAllSaveExceptionsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SAVE() { return GetToken(OracleAntlrParser.SAVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPTIONS() { return GetToken(OracleAntlrParser.EXCEPTIONS, 0); }
		public ForAllSaveExceptionsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forAllSaveExceptionsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForAllSaveExceptionsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForAllSaveExceptionsClause(this);
		}
	}

	[RuleVersion(0)]
	public ForAllSaveExceptionsClauseContext forAllSaveExceptionsClause() {
		ForAllSaveExceptionsClauseContext _localctx = new ForAllSaveExceptionsClauseContext(Context, State);
		EnterRule(_localctx, 1380, RULE_forAllSaveExceptionsClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6628;
			Match(SAVE);
			State = 6629;
			Match(EXCEPTIONS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] IF() { return GetTokens(OracleAntlrParser.IF); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF(int i) {
			return GetToken(OracleAntlrParser.IF, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ThenBlockContext thenBlock() {
			return GetRuleContext<ThenBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(OracleAntlrParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ElsIfBlockContext[] elsIfBlock() {
			return GetRuleContexts<ElsIfBlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElsIfBlockContext elsIfBlock(int i) {
			return GetRuleContext<ElsIfBlockContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseBlockContext elseBlock() {
			return GetRuleContext<ElseBlockContext>(0);
		}
		public IfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIfStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIfStatement(this);
		}
	}

	[RuleVersion(0)]
	public IfStatementContext ifStatement() {
		IfStatementContext _localctx = new IfStatementContext(Context, State);
		EnterRule(_localctx, 1382, RULE_ifStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6631;
			Match(IF);
			State = 6632;
			fullExpression();
			State = 6633;
			thenBlock();
			State = 6637;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ELSIF) {
				{
				{
				State = 6634;
				elsIfBlock();
				}
				}
				State = 6639;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6641;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 6640;
				elseBlock();
				}
			}

			State = 6643;
			Match(END);
			State = 6644;
			Match(IF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ThenBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(OracleAntlrParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlSqlStatementBatchContext plSqlStatementBatch() {
			return GetRuleContext<PlSqlStatementBatchContext>(0);
		}
		public ThenBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_thenBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterThenBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitThenBlock(this);
		}
	}

	[RuleVersion(0)]
	public ThenBlockContext thenBlock() {
		ThenBlockContext _localctx = new ThenBlockContext(Context, State);
		EnterRule(_localctx, 1384, RULE_thenBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6646;
			Match(THEN);
			State = 6647;
			plSqlStatementBatch();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(OracleAntlrParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlSqlStatementBatchContext plSqlStatementBatch() {
			return GetRuleContext<PlSqlStatementBatchContext>(0);
		}
		public ElseBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterElseBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitElseBlock(this);
		}
	}

	[RuleVersion(0)]
	public ElseBlockContext elseBlock() {
		ElseBlockContext _localctx = new ElseBlockContext(Context, State);
		EnterRule(_localctx, 1386, RULE_elseBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6649;
			Match(ELSE);
			State = 6650;
			plSqlStatementBatch();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElsIfBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSIF() { return GetToken(OracleAntlrParser.ELSIF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ThenBlockContext thenBlock() {
			return GetRuleContext<ThenBlockContext>(0);
		}
		public ElsIfBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elsIfBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterElsIfBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitElsIfBlock(this);
		}
	}

	[RuleVersion(0)]
	public ElsIfBlockContext elsIfBlock() {
		ElsIfBlockContext _localctx = new ElsIfBlockContext(Context, State);
		EnterRule(_localctx, 1388, RULE_elsIfBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6652;
			Match(ELSIF);
			State = 6653;
			fullExpression();
			State = 6654;
			thenBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfDirectiveStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE_IF() { return GetToken(OracleAntlrParser.DIRECTIVE_IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ThenDirectiveBlockContext thenDirectiveBlock() {
			return GetRuleContext<ThenDirectiveBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE_END() { return GetToken(OracleAntlrParser.DIRECTIVE_END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ElsIfDirectiveBlockContext[] elsIfDirectiveBlock() {
			return GetRuleContexts<ElsIfDirectiveBlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElsIfDirectiveBlockContext elsIfDirectiveBlock(int i) {
			return GetRuleContext<ElsIfDirectiveBlockContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseDirectiveBlockContext elseDirectiveBlock() {
			return GetRuleContext<ElseDirectiveBlockContext>(0);
		}
		public IfDirectiveStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifDirectiveStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIfDirectiveStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIfDirectiveStatement(this);
		}
	}

	[RuleVersion(0)]
	public IfDirectiveStatementContext ifDirectiveStatement() {
		IfDirectiveStatementContext _localctx = new IfDirectiveStatementContext(Context, State);
		EnterRule(_localctx, 1390, RULE_ifDirectiveStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6656;
			Match(DIRECTIVE_IF);
			State = 6657;
			fullExpression();
			State = 6658;
			thenDirectiveBlock();
			State = 6662;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DIRECTIVE_ELSIF) {
				{
				{
				State = 6659;
				elsIfDirectiveBlock();
				}
				}
				State = 6664;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6666;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DIRECTIVE_ELSE) {
				{
				State = 6665;
				elseDirectiveBlock();
				}
			}

			State = 6668;
			Match(DIRECTIVE_END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ThenDirectiveBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE_THEN() { return GetToken(OracleAntlrParser.DIRECTIVE_THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ErrorDirectiveBlockContext[] errorDirectiveBlock() {
			return GetRuleContexts<ErrorDirectiveBlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorDirectiveBlockContext errorDirectiveBlock(int i) {
			return GetRuleContext<ErrorDirectiveBlockContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockItemContext[] declarationBlockItem() {
			return GetRuleContexts<DeclarationBlockItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockItemContext declarationBlockItem(int i) {
			return GetRuleContext<DeclarationBlockItemContext>(i);
		}
		public ThenDirectiveBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_thenDirectiveBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterThenDirectiveBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitThenDirectiveBlock(this);
		}
	}

	[RuleVersion(0)]
	public ThenDirectiveBlockContext thenDirectiveBlock() {
		ThenDirectiveBlockContext _localctx = new ThenDirectiveBlockContext(Context, State);
		EnterRule(_localctx, 1392, RULE_thenDirectiveBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6670;
			Match(DIRECTIVE_THEN);
			State = 6675;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DIRECTIVE_ERROR - 128)) | (1L << (DIRECTIVE_IF - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 6673;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DIRECTIVE_ERROR:
					{
					State = 6671;
					errorDirectiveBlock();
					}
					break;
				case A_:
				case ACCOUNT:
				case ADVANCED:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ALLOCATE:
				case ALLOW:
				case ALWAYS:
				case ANALYZE:
				case ANYSCHEMA:
				case ARCHIVE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case ATTRIBUTES:
				case AUTHENTICATION:
				case AUTHID:
				case AUTO:
				case AUTONOMOUS_TRANSACTION:
				case BASIC:
				case BASICFILE:
				case BATCH:
				case BEFORE:
				case BEGINNING:
				case BINARY:
				case BITMAP:
				case BLOCK:
				case BODY:
				case BOTH:
				case BREADTH:
				case BUFFER_POOL:
				case BUILD:
				case BUILTIN:
				case BULK:
				case BULK_EXCEPTIONS:
				case BULK_ROWCOUNT:
				case BYTE:
				case C_:
				case CACHE:
				case CALL:
				case CASCADE:
				case CAST:
				case CELL_FLASH_CACHE:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHARSET:
				case CHR:
				case CHUNK:
				case CLOB:
				case CLOSE:
				case COALESCE:
				case COLLATION:
				case COLLECT:
				case COLUMN_VALUE:
				case COMMIT:
				case COMMITTED:
				case COMPACT:
				case COMPILE:
				case COMPLETE:
				case COMPOUND:
				case COMPUTATION:
				case COMPUTE:
				case CONDITIONAL:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTAINER:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case COUNT:
				case CREATION:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DATAFILE:
				case DATE:
				case DAY:
				case DBTIMEZONE:
				case DDL:
				case DEALLOCATE:
				case DEBUG:
				case DECODE:
				case DECRYPT:
				case DEDUPLICATE:
				case DEFERRABLE:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DEMAND:
				case DENSE_RANK:
				case DEPTH:
				case DETERMINISTIC:
				case DIRECT_LOAD:
				case DIRECTIVE_IF:
				case DISABLE:
				case DISALLOW:
				case DISASSOCIATE:
				case DOUBLE:
				case DUPLICATED:
				case EACH:
				case EDITION:
				case EDITIONABLE:
				case EDITIONING:
				case EDITIONS:
				case ELEMENT:
				case ELSIF:
				case EMPTY_KEYWORD:
				case ENABLE:
				case ENCRYPT:
				case ENFORCED:
				case ERROR_CODE:
				case ERROR_INDEX:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVALUATE:
				case EXCEPT:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXISTS:
				case EXIT:
				case EXPIRE:
				case EXTEND:
				case EXTENDED:
				case EXTENT:
				case EXTERNALLY:
				case EXTRACT:
				case FALSE:
				case FAST:
				case FILESYSTEM_LIKE_LOGGING:
				case FINAL:
				case FIPSFLAG:
				case FIRST:
				case FIRST_ROWS:
				case FIXED:
				case FOLLOWING:
				case FORALL:
				case FORCE:
				case FOREIGN:
				case FORMAT:
				case FOUND:
				case FLASH_CACHE:
				case FREELIST:
				case FREELISTS:
				case FREEPOOLS:
				case FULL:
				case FUNCTION:
				case GENERATED:
				case GLOBAL:
				case GLOBALLY:
				case GROUPING:
				case GROUPS:
				case HASH:
				case HEAP:
				case HIGH:
				case HOUR:
				case ID:
				case IDENTIFIER:
				case IDENTITY:
				case INCLUDE:
				case INCLUDING:
				case INDEXING:
				case INDICATOR:
				case INDICES:
				case INITIALLY:
				case INITRANS:
				case INNER:
				case INSTANCE:
				case INSTANTIABLE:
				case INSTEAD:
				case INTERFACE:
				case INTERVAL:
				case INVALIDATE:
				case INVALIDATION:
				case INVISIBLE:
				case ISOLATION:
				case ISOPEN:
				case JAVA:
				case JOIN:
				case JSON:
				case JSON_TABLE:
				case KEEP:
				case KEEP_DUPLICATES:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LEADING:
				case LEFT:
				case LESS:
				case LEVEL:
				case LEVELS:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LIST:
				case LOB:
				case LOBS:
				case LOCAL:
				case LOCATOR:
				case LOCKED:
				case LOCKING:
				case LOG:
				case LOGGING:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOW:
				case MAP:
				case MAPPING:
				case MASTER:
				case MATCHED:
				case MATERIALIZED:
				case MAX:
				case MAXSIZE:
				case MAXTRANS:
				case MAXVALUE:
				case MEDIUM:
				case MEMBER:
				case MEMOPTIMIZE:
				case MERGE:
				case METADATA:
				case MIN:
				case MINEXTENTS:
				case MINUTE:
				case MINVALUE:
				case MOD:
				case MONITORING:
				case MONTH:
				case MOVEMENT:
				case MULTISET:
				case NAME:
				case NATIONAL:
				case NATURAL:
				case NCHAR:
				case NCHAR_CS:
				case NCHR:
				case NESTED:
				case NEVER:
				case NEW:
				case NEW_NAMES:
				case NEXT:
				case NO:
				case NOCACHE:
				case NOCOPY:
				case NOCYCLE:
				case NOEXTEND:
				case NOKEEP:
				case NOLOGGING:
				case NOMAPPING:
				case NOMAXVALUE:
				case NOMINVALUE:
				case NOMONITORING:
				case NOORDER:
				case NONE:
				case NONEDITIONABLE:
				case NONSCHEMA:
				case NOPARALLEL:
				case NORELY:
				case NOREVERSE:
				case NOROWDEPENDENCIES:
				case NOSCALE:
				case NOSHARD:
				case NOSORT:
				case NOTFOUND:
				case NOVALIDATE:
				case NULLS:
				case OBJECT:
				case OID:
				case OIDINDEX:
				case OLD:
				case ONLY:
				case ONLINE:
				case OPAQUE:
				case OPEN:
				case OPERATIONS:
				case OPTIMAL:
				case ORDINALITY:
				case ORGANIZATION:
				case OUT:
				case OUTER:
				case OVER:
				case OVERFLOW:
				case OVERLAPS:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTIAL:
				case PARTITION:
				case PARTITIONS:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PCTINCREASE:
				case PCTTHRESHOLD:
				case PCTUSED:
				case PCTVERSION:
				case PERCENTILE_DISC:
				case PERIOD:
				case PIPE:
				case PIPELINED:
				case POLYMORPHIC:
				case PRAGMA:
				case PREBUILT:
				case PRECEDING:
				case PRECISION:
				case PRESERVE:
				case PRIMARY:
				case PRIOR:
				case PRIVATE:
				case PROCEDURE:
				case PROFILE:
				case PUBLIC:
				case PURGE:
				case QUERY:
				case QUOTA:
				case RAISE:
				case RAISE_APPLICATION_ERROR:
				case RANGE:
				case RAW:
				case READ:
				case READS:
				case REBUILD:
				case RECORD:
				case RECYCLE:
				case REDUCED:
				case REF:
				case REFERENCES:
				case REFERENCING:
				case REFRESH:
				case REJECT:
				case RELATIONAL:
				case RELIES_ON:
				case RELY:
				case RENAME:
				case REPLACE:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETENTION:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case REWRITE:
				case RIGHT:
				case ROLLUP:
				case ROW:
				case ROWCOUNT:
				case ROWDEPENDENCIES:
				case ROWID:
				case ROWTYPE:
				case SALT:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCALE:
				case SCHEMA:
				case SCN:
				case SCOPE:
				case SEARCH:
				case SECOND:
				case SECUREFILE:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSION:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHRINK:
				case SHUTDOWN:
				case SIBLINGS:
				case SIZE:
				case SKIP_:
				case SOME:
				case SORT:
				case SPACE:
				case SPECIFICATION:
				case SPLIT:
				case STARTUP:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORAGE:
				case STORE:
				case STRING:
				case SHARD:
				case SHARDED:
				case SHARING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUPPLEMENTAL:
				case SUSPEND:
				case SYNONYM:
				case SYSTEM:
				case TABLES:
				case TABLESPACE:
				case TEMPLATE:
				case TEMPORARY:
				case THAN:
				case TIME:
				case TIMESTAMP:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIM:
				case TRUE:
				case TRUNCATE:
				case TRUSTED:
				case TYPE:
				case UNBOUNDED:
				case UNCONDITIONAL:
				case UNDER:
				case UNLIMITED:
				case UNLOCK:
				case UNUSABLE:
				case UNUSED:
				case USABLE:
				case USAGE:
				case USE:
				case USER:
				case USING:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARRAY:
				case VARRAYS:
				case VARYING:
				case VERSIONS:
				case VIRTUAL:
				case VISIBLE:
				case WAIT:
				case WHEN:
				case WITHIN:
				case WITHOUT:
				case WORK:
				case WRAPPED:
				case WRAPPER:
				case WRITE:
				case XML:
				case XMLNAMESPACES:
				case XMLSCHEMA:
				case XMLTABLE:
				case XMLTYPE:
				case YEAR:
				case ZONE:
				case REGULAR_IDENTIFIER:
				case QUOTED_IDENTIFIER:
					{
					State = 6672;
					declarationBlockItem();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 6677;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseDirectiveBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE_ELSE() { return GetToken(OracleAntlrParser.DIRECTIVE_ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ErrorDirectiveBlockContext[] errorDirectiveBlock() {
			return GetRuleContexts<ErrorDirectiveBlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ErrorDirectiveBlockContext errorDirectiveBlock(int i) {
			return GetRuleContext<ErrorDirectiveBlockContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockItemContext[] declarationBlockItem() {
			return GetRuleContexts<DeclarationBlockItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockItemContext declarationBlockItem(int i) {
			return GetRuleContext<DeclarationBlockItemContext>(i);
		}
		public ElseDirectiveBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseDirectiveBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterElseDirectiveBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitElseDirectiveBlock(this);
		}
	}

	[RuleVersion(0)]
	public ElseDirectiveBlockContext elseDirectiveBlock() {
		ElseDirectiveBlockContext _localctx = new ElseDirectiveBlockContext(Context, State);
		EnterRule(_localctx, 1394, RULE_elseDirectiveBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6678;
			Match(DIRECTIVE_ELSE);
			State = 6683;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DIRECTIVE_ERROR - 128)) | (1L << (DIRECTIVE_IF - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 6681;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DIRECTIVE_ERROR:
					{
					State = 6679;
					errorDirectiveBlock();
					}
					break;
				case A_:
				case ACCOUNT:
				case ADVANCED:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ALLOCATE:
				case ALLOW:
				case ALWAYS:
				case ANALYZE:
				case ANYSCHEMA:
				case ARCHIVE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case ATTRIBUTES:
				case AUTHENTICATION:
				case AUTHID:
				case AUTO:
				case AUTONOMOUS_TRANSACTION:
				case BASIC:
				case BASICFILE:
				case BATCH:
				case BEFORE:
				case BEGINNING:
				case BINARY:
				case BITMAP:
				case BLOCK:
				case BODY:
				case BOTH:
				case BREADTH:
				case BUFFER_POOL:
				case BUILD:
				case BUILTIN:
				case BULK:
				case BULK_EXCEPTIONS:
				case BULK_ROWCOUNT:
				case BYTE:
				case C_:
				case CACHE:
				case CALL:
				case CASCADE:
				case CAST:
				case CELL_FLASH_CACHE:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHARSET:
				case CHR:
				case CHUNK:
				case CLOB:
				case CLOSE:
				case COALESCE:
				case COLLATION:
				case COLLECT:
				case COLUMN_VALUE:
				case COMMIT:
				case COMMITTED:
				case COMPACT:
				case COMPILE:
				case COMPLETE:
				case COMPOUND:
				case COMPUTATION:
				case COMPUTE:
				case CONDITIONAL:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTAINER:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case COUNT:
				case CREATION:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DATAFILE:
				case DATE:
				case DAY:
				case DBTIMEZONE:
				case DDL:
				case DEALLOCATE:
				case DEBUG:
				case DECODE:
				case DECRYPT:
				case DEDUPLICATE:
				case DEFERRABLE:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DEMAND:
				case DENSE_RANK:
				case DEPTH:
				case DETERMINISTIC:
				case DIRECT_LOAD:
				case DIRECTIVE_IF:
				case DISABLE:
				case DISALLOW:
				case DISASSOCIATE:
				case DOUBLE:
				case DUPLICATED:
				case EACH:
				case EDITION:
				case EDITIONABLE:
				case EDITIONING:
				case EDITIONS:
				case ELEMENT:
				case ELSIF:
				case EMPTY_KEYWORD:
				case ENABLE:
				case ENCRYPT:
				case ENFORCED:
				case ERROR_CODE:
				case ERROR_INDEX:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVALUATE:
				case EXCEPT:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXISTS:
				case EXIT:
				case EXPIRE:
				case EXTEND:
				case EXTENDED:
				case EXTENT:
				case EXTERNALLY:
				case EXTRACT:
				case FALSE:
				case FAST:
				case FILESYSTEM_LIKE_LOGGING:
				case FINAL:
				case FIPSFLAG:
				case FIRST:
				case FIRST_ROWS:
				case FIXED:
				case FOLLOWING:
				case FORALL:
				case FORCE:
				case FOREIGN:
				case FORMAT:
				case FOUND:
				case FLASH_CACHE:
				case FREELIST:
				case FREELISTS:
				case FREEPOOLS:
				case FULL:
				case FUNCTION:
				case GENERATED:
				case GLOBAL:
				case GLOBALLY:
				case GROUPING:
				case GROUPS:
				case HASH:
				case HEAP:
				case HIGH:
				case HOUR:
				case ID:
				case IDENTIFIER:
				case IDENTITY:
				case INCLUDE:
				case INCLUDING:
				case INDEXING:
				case INDICATOR:
				case INDICES:
				case INITIALLY:
				case INITRANS:
				case INNER:
				case INSTANCE:
				case INSTANTIABLE:
				case INSTEAD:
				case INTERFACE:
				case INTERVAL:
				case INVALIDATE:
				case INVALIDATION:
				case INVISIBLE:
				case ISOLATION:
				case ISOPEN:
				case JAVA:
				case JOIN:
				case JSON:
				case JSON_TABLE:
				case KEEP:
				case KEEP_DUPLICATES:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LEADING:
				case LEFT:
				case LESS:
				case LEVEL:
				case LEVELS:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LIST:
				case LOB:
				case LOBS:
				case LOCAL:
				case LOCATOR:
				case LOCKED:
				case LOCKING:
				case LOG:
				case LOGGING:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOW:
				case MAP:
				case MAPPING:
				case MASTER:
				case MATCHED:
				case MATERIALIZED:
				case MAX:
				case MAXSIZE:
				case MAXTRANS:
				case MAXVALUE:
				case MEDIUM:
				case MEMBER:
				case MEMOPTIMIZE:
				case MERGE:
				case METADATA:
				case MIN:
				case MINEXTENTS:
				case MINUTE:
				case MINVALUE:
				case MOD:
				case MONITORING:
				case MONTH:
				case MOVEMENT:
				case MULTISET:
				case NAME:
				case NATIONAL:
				case NATURAL:
				case NCHAR:
				case NCHAR_CS:
				case NCHR:
				case NESTED:
				case NEVER:
				case NEW:
				case NEW_NAMES:
				case NEXT:
				case NO:
				case NOCACHE:
				case NOCOPY:
				case NOCYCLE:
				case NOEXTEND:
				case NOKEEP:
				case NOLOGGING:
				case NOMAPPING:
				case NOMAXVALUE:
				case NOMINVALUE:
				case NOMONITORING:
				case NOORDER:
				case NONE:
				case NONEDITIONABLE:
				case NONSCHEMA:
				case NOPARALLEL:
				case NORELY:
				case NOREVERSE:
				case NOROWDEPENDENCIES:
				case NOSCALE:
				case NOSHARD:
				case NOSORT:
				case NOTFOUND:
				case NOVALIDATE:
				case NULLS:
				case OBJECT:
				case OID:
				case OIDINDEX:
				case OLD:
				case ONLY:
				case ONLINE:
				case OPAQUE:
				case OPEN:
				case OPERATIONS:
				case OPTIMAL:
				case ORDINALITY:
				case ORGANIZATION:
				case OUT:
				case OUTER:
				case OVER:
				case OVERFLOW:
				case OVERLAPS:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTIAL:
				case PARTITION:
				case PARTITIONS:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PCTINCREASE:
				case PCTTHRESHOLD:
				case PCTUSED:
				case PCTVERSION:
				case PERCENTILE_DISC:
				case PERIOD:
				case PIPE:
				case PIPELINED:
				case POLYMORPHIC:
				case PRAGMA:
				case PREBUILT:
				case PRECEDING:
				case PRECISION:
				case PRESERVE:
				case PRIMARY:
				case PRIOR:
				case PRIVATE:
				case PROCEDURE:
				case PROFILE:
				case PUBLIC:
				case PURGE:
				case QUERY:
				case QUOTA:
				case RAISE:
				case RAISE_APPLICATION_ERROR:
				case RANGE:
				case RAW:
				case READ:
				case READS:
				case REBUILD:
				case RECORD:
				case RECYCLE:
				case REDUCED:
				case REF:
				case REFERENCES:
				case REFERENCING:
				case REFRESH:
				case REJECT:
				case RELATIONAL:
				case RELIES_ON:
				case RELY:
				case RENAME:
				case REPLACE:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETENTION:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case REWRITE:
				case RIGHT:
				case ROLLUP:
				case ROW:
				case ROWCOUNT:
				case ROWDEPENDENCIES:
				case ROWID:
				case ROWTYPE:
				case SALT:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCALE:
				case SCHEMA:
				case SCN:
				case SCOPE:
				case SEARCH:
				case SECOND:
				case SECUREFILE:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSION:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHRINK:
				case SHUTDOWN:
				case SIBLINGS:
				case SIZE:
				case SKIP_:
				case SOME:
				case SORT:
				case SPACE:
				case SPECIFICATION:
				case SPLIT:
				case STARTUP:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORAGE:
				case STORE:
				case STRING:
				case SHARD:
				case SHARDED:
				case SHARING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUPPLEMENTAL:
				case SUSPEND:
				case SYNONYM:
				case SYSTEM:
				case TABLES:
				case TABLESPACE:
				case TEMPLATE:
				case TEMPORARY:
				case THAN:
				case TIME:
				case TIMESTAMP:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIM:
				case TRUE:
				case TRUNCATE:
				case TRUSTED:
				case TYPE:
				case UNBOUNDED:
				case UNCONDITIONAL:
				case UNDER:
				case UNLIMITED:
				case UNLOCK:
				case UNUSABLE:
				case UNUSED:
				case USABLE:
				case USAGE:
				case USE:
				case USER:
				case USING:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARRAY:
				case VARRAYS:
				case VARYING:
				case VERSIONS:
				case VIRTUAL:
				case VISIBLE:
				case WAIT:
				case WHEN:
				case WITHIN:
				case WITHOUT:
				case WORK:
				case WRAPPED:
				case WRAPPER:
				case WRITE:
				case XML:
				case XMLNAMESPACES:
				case XMLSCHEMA:
				case XMLTABLE:
				case XMLTYPE:
				case YEAR:
				case ZONE:
				case REGULAR_IDENTIFIER:
				case QUOTED_IDENTIFIER:
					{
					State = 6680;
					declarationBlockItem();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 6685;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElsIfDirectiveBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE_ELSIF() { return GetToken(OracleAntlrParser.DIRECTIVE_ELSIF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ThenDirectiveBlockContext thenDirectiveBlock() {
			return GetRuleContext<ThenDirectiveBlockContext>(0);
		}
		public ElsIfDirectiveBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elsIfDirectiveBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterElsIfDirectiveBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitElsIfDirectiveBlock(this);
		}
	}

	[RuleVersion(0)]
	public ElsIfDirectiveBlockContext elsIfDirectiveBlock() {
		ElsIfDirectiveBlockContext _localctx = new ElsIfDirectiveBlockContext(Context, State);
		EnterRule(_localctx, 1396, RULE_elsIfDirectiveBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6686;
			Match(DIRECTIVE_ELSIF);
			State = 6687;
			fullExpression();
			State = 6688;
			thenDirectiveBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ErrorDirectiveBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE_ERROR() { return GetToken(OracleAntlrParser.DIRECTIVE_ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE_END() { return GetToken(OracleAntlrParser.DIRECTIVE_END, 0); }
		public ErrorDirectiveBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_errorDirectiveBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterErrorDirectiveBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitErrorDirectiveBlock(this);
		}
	}

	[RuleVersion(0)]
	public ErrorDirectiveBlockContext errorDirectiveBlock() {
		ErrorDirectiveBlockContext _localctx = new ErrorDirectiveBlockContext(Context, State);
		EnterRule(_localctx, 1398, RULE_errorDirectiveBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6690;
			Match(DIRECTIVE_ERROR);
			State = 6691;
			fullExpression();
			State = 6692;
			Match(DIRECTIVE_END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LoopBlockContext loopBlock() {
			return GetRuleContext<LoopBlockContext>(0);
		}
		public LoopStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLoopStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLoopStatement(this);
		}
	}

	[RuleVersion(0)]
	public LoopStatementContext loopStatement() {
		LoopStatementContext _localctx = new LoopStatementContext(Context, State);
		EnterRule(_localctx, 1400, RULE_loopStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6694;
			loopBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOOP() { return GetToken(OracleAntlrParser.LOOP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlSqlStatementBatchContext plSqlStatementBatch() {
			return GetRuleContext<PlSqlStatementBatchContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndLoopClauseContext endLoopClause() {
			return GetRuleContext<EndLoopClauseContext>(0);
		}
		public LoopBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLoopBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLoopBlock(this);
		}
	}

	[RuleVersion(0)]
	public LoopBlockContext loopBlock() {
		LoopBlockContext _localctx = new LoopBlockContext(Context, State);
		EnterRule(_localctx, 1402, RULE_loopBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6696;
			Match(LOOP);
			State = 6697;
			plSqlStatementBatch();
			State = 6698;
			endLoopClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHILE() { return GetToken(OracleAntlrParser.WHILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoopBlockContext loopBlock() {
			return GetRuleContext<LoopBlockContext>(0);
		}
		public WhileStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterWhileStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitWhileStatement(this);
		}
	}

	[RuleVersion(0)]
	public WhileStatementContext whileStatement() {
		WhileStatementContext _localctx = new WhileStatementContext(Context, State);
		EnterRule(_localctx, 1404, RULE_whileStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6700;
			Match(WHILE);
			State = 6701;
			fullExpression();
			State = 6702;
			loopBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EndLoopClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(OracleAntlrParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOOP() { return GetToken(OracleAntlrParser.LOOP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier() {
			return GetRuleContext<SimpleIdentifierRegularIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTED_IDENTIFIER() { return GetToken(OracleAntlrParser.QUOTED_IDENTIFIER, 0); }
		public EndLoopClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_endLoopClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterEndLoopClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitEndLoopClause(this);
		}
	}

	[RuleVersion(0)]
	public EndLoopClauseContext endLoopClause() {
		EndLoopClauseContext _localctx = new EndLoopClauseContext(Context, State);
		EnterRule(_localctx, 1406, RULE_endLoopClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6704;
			Match(END);
			State = 6705;
			Match(LOOP);
			State = 6708;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
				{
				State = 6706;
				simpleIdentifierRegularIdentifier();
				}
				break;
			case QUOTED_IDENTIFIER:
				{
				State = 6707;
				Match(QUOTED_IDENTIFIER);
				}
				break;
			case SEMI:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForStatementInClauseContext forStatementInClause() {
			return GetRuleContext<ForStatementInClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoopBlockContext loopBlock() {
			return GetRuleContext<LoopBlockContext>(0);
		}
		public ForStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForStatement(this);
		}
	}

	[RuleVersion(0)]
	public ForStatementContext forStatement() {
		ForStatementContext _localctx = new ForStatementContext(Context, State);
		EnterRule(_localctx, 1408, RULE_forStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6710;
			Match(FOR);
			State = 6711;
			simpleIdentifier();
			State = 6712;
			forStatementInClause();
			State = 6713;
			loopBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForStatementInClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(OracleAntlrParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext[] fullExpression() {
			return GetRuleContexts<FullExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression(int i) {
			return GetRuleContext<FullExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REVERSE() { return GetToken(OracleAntlrParser.REVERSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOUBLE_DOT_OPERATOR() { return GetToken(OracleAntlrParser.DOUBLE_DOT_OPERATOR, 0); }
		public ForStatementInClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forStatementInClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForStatementInClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForStatementInClause(this);
		}
	}

	[RuleVersion(0)]
	public ForStatementInClauseContext forStatementInClause() {
		ForStatementInClauseContext _localctx = new ForStatementInClauseContext(Context, State);
		EnterRule(_localctx, 1410, RULE_forStatementInClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6715;
			Match(IN);
			State = 6717;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,752,Context) ) {
			case 1:
				{
				State = 6716;
				Match(REVERSE);
				}
				break;
			}
			State = 6719;
			fullExpression();
			State = 6722;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DOUBLE_DOT_OPERATOR) {
				{
				State = 6720;
				Match(DOUBLE_DOT_OPERATOR);
				State = 6721;
				fullExpression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ContinueStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTINUE() { return GetToken(OracleAntlrParser.CONTINUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OptionalLabelWhenConditionContext optionalLabelWhenCondition() {
			return GetRuleContext<OptionalLabelWhenConditionContext>(0);
		}
		public ContinueStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_continueStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterContinueStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitContinueStatement(this);
		}
	}

	[RuleVersion(0)]
	public ContinueStatementContext continueStatement() {
		ContinueStatementContext _localctx = new ContinueStatementContext(Context, State);
		EnterRule(_localctx, 1412, RULE_continueStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6724;
			Match(CONTINUE);
			State = 6726;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 6725;
				optionalLabelWhenCondition();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] CASE() { return GetTokens(OracleAntlrParser.CASE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASE(int i) {
			return GetToken(OracleAntlrParser.CASE, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(OracleAntlrParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SearchedCaseStatementContext searchedCaseStatement() {
			return GetRuleContext<SearchedCaseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleCaseStatementContext simpleCaseStatement() {
			return GetRuleContext<SimpleCaseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier() {
			return GetRuleContext<SimpleIdentifierRegularIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTED_IDENTIFIER() { return GetToken(OracleAntlrParser.QUOTED_IDENTIFIER, 0); }
		public CaseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCaseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCaseStatement(this);
		}
	}

	[RuleVersion(0)]
	public CaseStatementContext caseStatement() {
		CaseStatementContext _localctx = new CaseStatementContext(Context, State);
		EnterRule(_localctx, 1414, RULE_caseStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6728;
			Match(CASE);
			State = 6731;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,755,Context) ) {
			case 1:
				{
				State = 6729;
				searchedCaseStatement();
				}
				break;
			case 2:
				{
				State = 6730;
				simpleCaseStatement();
				}
				break;
			}
			State = 6733;
			Match(END);
			State = 6734;
			Match(CASE);
			State = 6737;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
				{
				State = 6735;
				simpleIdentifierRegularIdentifier();
				}
				break;
			case QUOTED_IDENTIFIER:
				{
				State = 6736;
				Match(QUOTED_IDENTIFIER);
				}
				break;
			case SEMI:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleCaseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseStatementWhenEntryContext[] caseStatementWhenEntry() {
			return GetRuleContexts<CaseStatementWhenEntryContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseStatementWhenEntryContext caseStatementWhenEntry(int i) {
			return GetRuleContext<CaseStatementWhenEntryContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseBlockContext elseBlock() {
			return GetRuleContext<ElseBlockContext>(0);
		}
		public SimpleCaseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleCaseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSimpleCaseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSimpleCaseStatement(this);
		}
	}

	[RuleVersion(0)]
	public SimpleCaseStatementContext simpleCaseStatement() {
		SimpleCaseStatementContext _localctx = new SimpleCaseStatementContext(Context, State);
		EnterRule(_localctx, 1416, RULE_simpleCaseStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6739;
			fullExpression();
			State = 6741;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6740;
				caseStatementWhenEntry();
				}
				}
				State = 6743;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 6746;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 6745;
				elseBlock();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SearchedCaseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CaseStatementWhenEntryContext[] caseStatementWhenEntry() {
			return GetRuleContexts<CaseStatementWhenEntryContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseStatementWhenEntryContext caseStatementWhenEntry(int i) {
			return GetRuleContext<CaseStatementWhenEntryContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseBlockContext elseBlock() {
			return GetRuleContext<ElseBlockContext>(0);
		}
		public SearchedCaseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searchedCaseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSearchedCaseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSearchedCaseStatement(this);
		}
	}

	[RuleVersion(0)]
	public SearchedCaseStatementContext searchedCaseStatement() {
		SearchedCaseStatementContext _localctx = new SearchedCaseStatementContext(Context, State);
		EnterRule(_localctx, 1418, RULE_searchedCaseStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6749;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6748;
				caseStatementWhenEntry();
				}
				}
				State = 6751;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 6754;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 6753;
				elseBlock();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseStatementWhenEntryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ThenBlockContext thenBlock() {
			return GetRuleContext<ThenBlockContext>(0);
		}
		public CaseStatementWhenEntryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseStatementWhenEntry; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCaseStatementWhenEntry(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCaseStatementWhenEntry(this);
		}
	}

	[RuleVersion(0)]
	public CaseStatementWhenEntryContext caseStatementWhenEntry() {
		CaseStatementWhenEntryContext _localctx = new CaseStatementWhenEntryContext(Context, State);
		EnterRule(_localctx, 1420, RULE_caseStatementWhenEntry);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6756;
			Match(WHEN);
			State = 6757;
			fullExpression();
			State = 6758;
			thenBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockBodyContext blockBody() {
			return GetRuleContext<BlockBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockContext declarationBlock() {
			return GetRuleContext<DeclarationBlockContext>(0);
		}
		public BlockStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBlockStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBlockStatement(this);
		}
	}

	[RuleVersion(0)]
	public BlockStatementContext blockStatement() {
		BlockStatementContext _localctx = new BlockStatementContext(Context, State);
		EnterRule(_localctx, 1422, RULE_blockStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6761;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECLARE - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DIRECTIVE_IF - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 6760;
				declarationBlock();
				}
			}

			State = 6763;
			blockBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BEGIN() { return GetToken(OracleAntlrParser.BEGIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlSqlStatementBatchContext plSqlStatementBatch() {
			return GetRuleContext<PlSqlStatementBatchContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndClauseContext endClause() {
			return GetRuleContext<EndClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionBlockContext exceptionBlock() {
			return GetRuleContext<ExceptionBlockContext>(0);
		}
		public BlockBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBlockBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBlockBody(this);
		}
	}

	[RuleVersion(0)]
	public BlockBodyContext blockBody() {
		BlockBodyContext _localctx = new BlockBodyContext(Context, State);
		EnterRule(_localctx, 1424, RULE_blockBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6765;
			Match(BEGIN);
			State = 6766;
			plSqlStatementBatch();
			State = 6768;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXCEPTION) {
				{
				State = 6767;
				exceptionBlock();
				}
			}

			State = 6770;
			endClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EndClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(OracleAntlrParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierRegularIdentifierContext simpleIdentifierRegularIdentifier() {
			return GetRuleContext<SimpleIdentifierRegularIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOTED_IDENTIFIER() { return GetToken(OracleAntlrParser.QUOTED_IDENTIFIER, 0); }
		public EndClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_endClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterEndClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitEndClause(this);
		}
	}

	[RuleVersion(0)]
	public EndClauseContext endClause() {
		EndClauseContext _localctx = new EndClauseContext(Context, State);
		EnterRule(_localctx, 1426, RULE_endClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6772;
			Match(END);
			State = 6775;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,763,Context) ) {
			case 1:
				{
				State = 6773;
				simpleIdentifierRegularIdentifier();
				}
				break;
			case 2:
				{
				State = 6774;
				Match(QUOTED_IDENTIFIER);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExceptionBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPTION() { return GetToken(OracleAntlrParser.EXCEPTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionHandlerContext[] exceptionHandler() {
			return GetRuleContexts<ExceptionHandlerContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionHandlerContext exceptionHandler(int i) {
			return GetRuleContext<ExceptionHandlerContext>(i);
		}
		public ExceptionBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exceptionBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExceptionBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExceptionBlock(this);
		}
	}

	[RuleVersion(0)]
	public ExceptionBlockContext exceptionBlock() {
		ExceptionBlockContext _localctx = new ExceptionBlockContext(Context, State);
		EnterRule(_localctx, 1428, RULE_exceptionBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6777;
			Match(EXCEPTION);
			State = 6779;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6778;
				exceptionHandler();
				}
				}
				State = 6781;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExceptionHandlerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionNameListContext exceptionNameList() {
			return GetRuleContext<ExceptionNameListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ThenBlockContext thenBlock() {
			return GetRuleContext<ThenBlockContext>(0);
		}
		public ExceptionHandlerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exceptionHandler; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExceptionHandler(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExceptionHandler(this);
		}
	}

	[RuleVersion(0)]
	public ExceptionHandlerContext exceptionHandler() {
		ExceptionHandlerContext _localctx = new ExceptionHandlerContext(Context, State);
		EnterRule(_localctx, 1430, RULE_exceptionHandler);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6783;
			Match(WHEN);
			State = 6784;
			exceptionNameList();
			State = 6785;
			thenBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExceptionNameListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] OR() { return GetTokens(OracleAntlrParser.OR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR(int i) {
			return GetToken(OracleAntlrParser.OR, i);
		}
		public ExceptionNameListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exceptionNameList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExceptionNameList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExceptionNameList(this);
		}
	}

	[RuleVersion(0)]
	public ExceptionNameListContext exceptionNameList() {
		ExceptionNameListContext _localctx = new ExceptionNameListContext(Context, State);
		EnterRule(_localctx, 1432, RULE_exceptionNameList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6787;
			identifier();
			State = 6792;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR) {
				{
				{
				State = 6788;
				Match(OR);
				State = 6789;
				identifier();
				}
				}
				State = 6794;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GotoStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GOTO() { return GetToken(OracleAntlrParser.GOTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public GotoStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gotoStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterGotoStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitGotoStatement(this);
		}
	}

	[RuleVersion(0)]
	public GotoStatementContext gotoStatement() {
		GotoStatementContext _localctx = new GotoStatementContext(Context, State);
		EnterRule(_localctx, 1434, RULE_gotoStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6795;
			Match(GOTO);
			State = 6796;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LabelBodyContext labelBody() {
			return GetRuleContext<LabelBodyContext>(0);
		}
		public LabelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLabel(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLabel(this);
		}
	}

	[RuleVersion(0)]
	public LabelContext label() {
		LabelContext _localctx = new LabelContext(Context, State);
		EnterRule(_localctx, 1436, RULE_label);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6798;
			labelBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LESS_THAN() { return GetTokens(OracleAntlrParser.LESS_THAN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS_THAN(int i) {
			return GetToken(OracleAntlrParser.LESS_THAN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] GREATER_THAN() { return GetTokens(OracleAntlrParser.GREATER_THAN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER_THAN(int i) {
			return GetToken(OracleAntlrParser.GREATER_THAN, i);
		}
		public LabelBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labelBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterLabelBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitLabelBody(this);
		}
	}

	[RuleVersion(0)]
	public LabelBodyContext labelBody() {
		LabelBodyContext _localctx = new LabelBodyContext(Context, State);
		EnterRule(_localctx, 1438, RULE_labelBody);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6800;
			Match(LESS_THAN);
			State = 6801;
			Match(LESS_THAN);
			State = 6802;
			simpleIdentifierWithoutParentheses();
			State = 6803;
			Match(GREATER_THAN);
			State = 6804;
			Match(GREATER_THAN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NullStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public NullStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nullStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNullStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNullStatement(this);
		}
	}

	[RuleVersion(0)]
	public NullStatementContext nullStatement() {
		NullStatementContext _localctx = new NullStatementContext(Context, State);
		EnterRule(_localctx, 1440, RULE_nullStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6806;
			Match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(OracleAntlrParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public ReturnStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterReturnStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitReturnStatement(this);
		}
	}

	[RuleVersion(0)]
	public ReturnStatementContext returnStatement() {
		ReturnStatementContext _localctx = new ReturnStatementContext(Context, State);
		EnterRule(_localctx, 1442, RULE_returnStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6808;
			Match(RETURN);
			State = 6810;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLAGG - 512)) | (1L << (XMLCAST - 512)) | (1L << (XMLNAMESPACES - 512)) | (1L << (XMLQUERY - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (INTEGER_LITERAL - 576)) | (1L << (LPAREN - 576)) | (1L << (PLUS_SIGN - 576)) | (1L << (MINUS_SIGN - 576)) | (1L << (QUESTION_MARK - 576)) | (1L << (ASTERISK - 576)) | (1L << (FLOATING_POINT_LITERAL - 576)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 576)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 576)) | (1L << (BINARY_STRING_LITERAL - 576)) | (1L << (CHARACTER_STRING_LITERAL - 576)) | (1L << (MONEY_LITERAL - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 576)))) != 0)) {
				{
				State = 6809;
				fullExpression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ProcedureCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterProcedureCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitProcedureCall(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureCallContext procedureCall() {
		ProcedureCallContext _localctx = new ProcedureCallContext(Context, State);
		EnterRule(_localctx, 1444, RULE_procedureCall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6812;
			identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExitStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXIT() { return GetToken(OracleAntlrParser.EXIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OptionalLabelWhenConditionContext optionalLabelWhenCondition() {
			return GetRuleContext<OptionalLabelWhenConditionContext>(0);
		}
		public ExitStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exitStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExitStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExitStatement(this);
		}
	}

	[RuleVersion(0)]
	public ExitStatementContext exitStatement() {
		ExitStatementContext _localctx = new ExitStatementContext(Context, State);
		EnterRule(_localctx, 1446, RULE_exitStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6814;
			Match(EXIT);
			State = 6816;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 6815;
				optionalLabelWhenCondition();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionalLabelWhenConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public WhenConditionContext whenCondition() {
			return GetRuleContext<WhenConditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		public OptionalLabelWhenConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optionalLabelWhenCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOptionalLabelWhenCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOptionalLabelWhenCondition(this);
		}
	}

	[RuleVersion(0)]
	public OptionalLabelWhenConditionContext optionalLabelWhenCondition() {
		OptionalLabelWhenConditionContext _localctx = new OptionalLabelWhenConditionContext(Context, State);
		EnterRule(_localctx, 1448, RULE_optionalLabelWhenCondition);
		int _la;
		try {
			State = 6823;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,769,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6818;
				whenCondition();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6819;
				simpleIdentifier();
				State = 6821;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHEN) {
					{
					State = 6820;
					whenCondition();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhenConditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(OracleAntlrParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public WhenConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whenCondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterWhenCondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitWhenCondition(this);
		}
	}

	[RuleVersion(0)]
	public WhenConditionContext whenCondition() {
		WhenConditionContext _localctx = new WhenConditionContext(Context, State);
		EnterRule(_localctx, 1450, RULE_whenCondition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6825;
			Match(WHEN);
			State = 6826;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockItemContext[] declarationBlockItem() {
			return GetRuleContexts<DeclarationBlockItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationBlockItemContext declarationBlockItem(int i) {
			return GetRuleContext<DeclarationBlockItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECLARE() { return GetToken(OracleAntlrParser.DECLARE, 0); }
		public DeclarationBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarationBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDeclarationBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDeclarationBlock(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationBlockContext declarationBlock() {
		DeclarationBlockContext _localctx = new DeclarationBlockContext(Context, State);
		EnterRule(_localctx, 1452, RULE_declarationBlock);
		try {
			int _alt;
			State = 6840;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DIRECTIVE_IF:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6829;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 6828;
						declarationBlockItem();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 6831;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,770,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case DECLARE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6833;
				Match(DECLARE);
				State = 6837;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,771,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 6834;
						declarationBlockItem();
						}
						} 
					}
					State = 6839;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,771,Context);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationBlockItemContext : ParserRuleContext {
		public IToken semi;
		[System.Diagnostics.DebuggerNonUserCode] public IfDirectiveStatementContext ifDirectiveStatement() {
			return GetRuleContext<IfDirectiveStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI() { return GetToken(OracleAntlrParser.SEMI, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionStatementContext functionStatement() {
			return GetRuleContext<FunctionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureStatementContext procedureStatement() {
			return GetRuleContext<ProcedureStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionDeclarationContext exceptionDeclaration() {
			return GetRuleContext<ExceptionDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeDeclarationContext typeDeclaration() {
			return GetRuleContext<TypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubtypeDeclarationContext subtypeDeclaration() {
			return GetRuleContext<SubtypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CursorDeclarationContext cursorDeclaration() {
			return GetRuleContext<CursorDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationPragmaContext declarationPragma() {
			return GetRuleContext<DeclarationPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableDeclarationContext variableDeclaration() {
			return GetRuleContext<VariableDeclarationContext>(0);
		}
		public DeclarationBlockItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarationBlockItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDeclarationBlockItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDeclarationBlockItem(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationBlockItemContext declarationBlockItem() {
		DeclarationBlockItemContext _localctx = new DeclarationBlockItemContext(Context, State);
		EnterRule(_localctx, 1454, RULE_declarationBlockItem);
		try {
			State = 6855;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DIRECTIVE_IF:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6842;
				ifDirectiveStatement();
				}
				break;
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6851;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,773,Context) ) {
				case 1:
					{
					State = 6843;
					functionStatement();
					}
					break;
				case 2:
					{
					State = 6844;
					procedureStatement();
					}
					break;
				case 3:
					{
					State = 6845;
					exceptionDeclaration();
					}
					break;
				case 4:
					{
					State = 6846;
					typeDeclaration();
					}
					break;
				case 5:
					{
					State = 6847;
					subtypeDeclaration();
					}
					break;
				case 6:
					{
					State = 6848;
					cursorDeclaration();
					}
					break;
				case 7:
					{
					State = 6849;
					declarationPragma();
					}
					break;
				case 8:
					{
					State = 6850;
					variableDeclaration();
					}
					break;
				}
				State = 6853;
				_localctx.semi = Match(SEMI);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NotNullClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public NotNullClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_notNullClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNotNullClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNotNullClause(this);
		}
	}

	[RuleVersion(0)]
	public NotNullClauseContext notNullClause() {
		NotNullClauseContext _localctx = new NotNullClauseContext(Context, State);
		EnterRule(_localctx, 1456, RULE_notNullClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6857;
			Match(NOT);
			State = 6858;
			Match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NullClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(OracleAntlrParser.NULL, 0); }
		public NullClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nullClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNullClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNullClause(this);
		}
	}

	[RuleVersion(0)]
	public NullClauseContext nullClause() {
		NullClauseContext _localctx = new NullClauseContext(Context, State);
		EnterRule(_localctx, 1458, RULE_nullClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6860;
			Match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefaultValueClauseContext : ParserRuleContext {
		public IToken clauseType;
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN_OPERATOR() { return GetToken(OracleAntlrParser.ASSIGN_OPERATOR, 0); }
		public DefaultValueClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defaultValueClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDefaultValueClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDefaultValueClause(this);
		}
	}

	[RuleVersion(0)]
	public DefaultValueClauseContext defaultValueClause() {
		DefaultValueClauseContext _localctx = new DefaultValueClauseContext(Context, State);
		EnterRule(_localctx, 1460, RULE_defaultValueClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6862;
			_localctx.clauseType = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DEFAULT || _la==ASSIGN_OPERATOR) ) {
				_localctx.clauseType = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 6863;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CursorReturnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(OracleAntlrParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public CursorReturnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursorReturnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCursorReturnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCursorReturnClause(this);
		}
	}

	[RuleVersion(0)]
	public CursorReturnClauseContext cursorReturnClause() {
		CursorReturnClauseContext _localctx = new CursorReturnClauseContext(Context, State);
		EnterRule(_localctx, 1462, RULE_cursorReturnClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6865;
			Match(RETURN);
			State = 6866;
			typeReference();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExceptionDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPTION() { return GetToken(OracleAntlrParser.EXCEPTION, 0); }
		public ExceptionDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exceptionDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExceptionDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExceptionDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public ExceptionDeclarationContext exceptionDeclaration() {
		ExceptionDeclarationContext _localctx = new ExceptionDeclarationContext(Context, State);
		EnterRule(_localctx, 1464, RULE_exceptionDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6868;
			simpleIdentifier();
			State = 6869;
			Match(EXCEPTION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterIsContext delimiterIs() {
			return GetRuleContext<DelimiterIsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterAsContext delimiterAs() {
			return GetRuleContext<DelimiterAsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RecordTypeDeclarationContext recordTypeDeclaration() {
			return GetRuleContext<RecordTypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayTypeDeclarationContext varrayTypeDeclaration() {
			return GetRuleContext<VarrayTypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableTypeDeclarationContext tableTypeDeclaration() {
			return GetRuleContext<TableTypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RefCursorTypeDeclarationContext refCursorTypeDeclaration() {
			return GetRuleContext<RefCursorTypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeDeclarationContext objectTypeDeclaration() {
			return GetRuleContext<ObjectTypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NewTypeContext newType() {
			return GetRuleContext<NewTypeContext>(0);
		}
		public TypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public TypeDeclarationContext typeDeclaration() {
		TypeDeclarationContext _localctx = new TypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1466, RULE_typeDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6871;
			Match(TYPE);
			State = 6872;
			simpleIdentifier();
			State = 6875;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IS:
				{
				State = 6873;
				delimiterIs();
				}
				break;
			case AS:
				{
				State = 6874;
				delimiterAs();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6878;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,776,Context) ) {
			case 1:
				{
				State = 6877;
				newType();
				}
				break;
			}
			State = 6886;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,777,Context) ) {
			case 1:
				{
				State = 6880;
				recordTypeDeclaration();
				}
				break;
			case 2:
				{
				State = 6881;
				varrayTypeDeclaration();
				}
				break;
			case 3:
				{
				State = 6882;
				tableTypeDeclaration();
				}
				break;
			case 4:
				{
				State = 6883;
				refCursorTypeDeclaration();
				}
				break;
			case 5:
				{
				State = 6884;
				objectTypeDeclaration();
				}
				break;
			case 6:
				{
				State = 6885;
				typeReference();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimiterAsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		public DelimiterAsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimiterAs; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDelimiterAs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDelimiterAs(this);
		}
	}

	[RuleVersion(0)]
	public DelimiterAsContext delimiterAs() {
		DelimiterAsContext _localctx = new DelimiterAsContext(Context, State);
		EnterRule(_localctx, 1468, RULE_delimiterAs);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6888;
			Match(AS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(OracleAntlrParser.NEW, 0); }
		public NewTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNewType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNewType(this);
		}
	}

	[RuleVersion(0)]
	public NewTypeContext newType() {
		NewTypeContext _localctx = new NewTypeContext(Context, State);
		EnterRule(_localctx, 1470, RULE_newType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6890;
			Match(NEW);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RecordTypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RECORD() { return GetToken(OracleAntlrParser.RECORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RecordFieldDeclarationContext[] recordFieldDeclaration() {
			return GetRuleContexts<RecordFieldDeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RecordFieldDeclarationContext recordFieldDeclaration(int i) {
			return GetRuleContext<RecordFieldDeclarationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public RecordTypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_recordTypeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRecordTypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRecordTypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public RecordTypeDeclarationContext recordTypeDeclaration() {
		RecordTypeDeclarationContext _localctx = new RecordTypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1472, RULE_recordTypeDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6892;
			Match(RECORD);
			State = 6893;
			Match(LPAREN);
			State = 6894;
			recordFieldDeclaration();
			State = 6899;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 6895;
				Match(COMMA);
				State = 6896;
				recordFieldDeclaration();
				}
				}
				State = 6901;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6902;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RecordFieldDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultValueClauseContext defaultValueClause() {
			return GetRuleContext<DefaultValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullClauseContext nullClause() {
			return GetRuleContext<NullClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotNullClauseContext notNullClause() {
			return GetRuleContext<NotNullClauseContext>(0);
		}
		public RecordFieldDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_recordFieldDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRecordFieldDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRecordFieldDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public RecordFieldDeclarationContext recordFieldDeclaration() {
		RecordFieldDeclarationContext _localctx = new RecordFieldDeclarationContext(Context, State);
		EnterRule(_localctx, 1474, RULE_recordFieldDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6904;
			simpleIdentifier();
			State = 6905;
			typeReference();
			State = 6914;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEFAULT:
			case NOT:
			case ASSIGN_OPERATOR:
				{
				State = 6907;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 6906;
					notNullClause();
					}
				}

				State = 6909;
				defaultValueClause();
				}
				break;
			case NULL:
				{
				State = 6910;
				nullClause();
				State = 6912;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT || _la==ASSIGN_OPERATOR) {
					{
					State = 6911;
					defaultValueClause();
					}
				}

				}
				break;
			case RPAREN:
			case COMMA:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(OracleAntlrParser.OBJECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectFieldDeclarationContext objectFieldDeclaration() {
			return GetRuleContext<ObjectFieldDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RecordFieldDeclarationContext[] recordFieldDeclaration() {
			return GetRuleContexts<RecordFieldDeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RecordFieldDeclarationContext recordFieldDeclaration(int i) {
			return GetRuleContext<RecordFieldDeclarationContext>(i);
		}
		public ObjectTypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectTypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectTypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeDeclarationContext objectTypeDeclaration() {
		ObjectTypeDeclarationContext _localctx = new ObjectTypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1476, RULE_objectTypeDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6916;
			Match(OBJECT);
			State = 6917;
			Match(LPAREN);
			State = 6918;
			objectFieldDeclaration();
			State = 6923;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 6919;
				Match(COMMA);
				State = 6920;
				recordFieldDeclaration();
				}
				}
				State = 6925;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6926;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectFieldDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultValueClauseContext defaultValueClause() {
			return GetRuleContext<DefaultValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullClauseContext nullClause() {
			return GetRuleContext<NullClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotNullClauseContext notNullClause() {
			return GetRuleContext<NotNullClauseContext>(0);
		}
		public ObjectFieldDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectFieldDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectFieldDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectFieldDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public ObjectFieldDeclarationContext objectFieldDeclaration() {
		ObjectFieldDeclarationContext _localctx = new ObjectFieldDeclarationContext(Context, State);
		EnterRule(_localctx, 1478, RULE_objectFieldDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6928;
			simpleIdentifier();
			State = 6929;
			typeReference();
			State = 6938;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEFAULT:
			case NOT:
			case ASSIGN_OPERATOR:
				{
				State = 6931;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 6930;
					notNullClause();
					}
				}

				State = 6933;
				defaultValueClause();
				}
				break;
			case NULL:
				{
				State = 6934;
				nullClause();
				State = 6936;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT || _la==ASSIGN_OPERATOR) {
					{
					State = 6935;
					defaultValueClause();
					}
				}

				}
				break;
			case RPAREN:
			case COMMA:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarrayTypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public VarraySizeLimitClauseContext varraySizeLimitClause() {
			return GetRuleContext<VarraySizeLimitClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeDeclararionElementTypeClauseContext typeDeclararionElementTypeClause() {
			return GetRuleContext<TypeDeclararionElementTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARRAY() { return GetToken(OracleAntlrParser.VARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARYING() { return GetToken(OracleAntlrParser.VARYING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARRAY() { return GetToken(OracleAntlrParser.ARRAY, 0); }
		public VarrayTypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varrayTypeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterVarrayTypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitVarrayTypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public VarrayTypeDeclarationContext varrayTypeDeclaration() {
		VarrayTypeDeclarationContext _localctx = new VarrayTypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1480, RULE_varrayTypeDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6943;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case VARRAY:
				{
				State = 6940;
				Match(VARRAY);
				}
				break;
			case VARYING:
				{
				State = 6941;
				Match(VARYING);
				State = 6942;
				Match(ARRAY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6945;
			varraySizeLimitClause();
			State = 6946;
			typeDeclararionElementTypeClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarraySizeLimitClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public VarraySizeLimitClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varraySizeLimitClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterVarraySizeLimitClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitVarraySizeLimitClause(this);
		}
	}

	[RuleVersion(0)]
	public VarraySizeLimitClauseContext varraySizeLimitClause() {
		VarraySizeLimitClauseContext _localctx = new VarraySizeLimitClauseContext(Context, State);
		EnterRule(_localctx, 1482, RULE_varraySizeLimitClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6948;
			Match(LPAREN);
			State = 6949;
			literal();
			State = 6950;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeDeclararionElementTypeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(OracleAntlrParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotNullClauseContext notNullClause() {
			return GetRuleContext<NotNullClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullClauseContext nullClause() {
			return GetRuleContext<NullClauseContext>(0);
		}
		public TypeDeclararionElementTypeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeDeclararionElementTypeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTypeDeclararionElementTypeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTypeDeclararionElementTypeClause(this);
		}
	}

	[RuleVersion(0)]
	public TypeDeclararionElementTypeClauseContext typeDeclararionElementTypeClause() {
		TypeDeclararionElementTypeClauseContext _localctx = new TypeDeclararionElementTypeClauseContext(Context, State);
		EnterRule(_localctx, 1484, RULE_typeDeclararionElementTypeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6952;
			Match(OF);
			State = 6953;
			typeReference();
			State = 6956;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOT:
				{
				State = 6954;
				notNullClause();
				}
				break;
			case NULL:
				{
				State = 6955;
				nullClause();
				}
				break;
			case Eof:
			case ALTER:
			case INDEX:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableTypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeDeclararionElementTypeClauseContext typeDeclararionElementTypeClause() {
			return GetRuleContext<TypeDeclararionElementTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableTypeIndexByClauseContext tableTypeIndexByClause() {
			return GetRuleContext<TableTypeIndexByClauseContext>(0);
		}
		public TableTypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableTypeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTableTypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTableTypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public TableTypeDeclarationContext tableTypeDeclaration() {
		TableTypeDeclarationContext _localctx = new TableTypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1486, RULE_tableTypeDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6958;
			Match(TABLE);
			State = 6959;
			typeDeclararionElementTypeClause();
			State = 6961;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INDEX) {
				{
				State = 6960;
				tableTypeIndexByClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableTypeIndexByClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotNullClauseContext notNullClause() {
			return GetRuleContext<NotNullClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullClauseContext nullClause() {
			return GetRuleContext<NullClauseContext>(0);
		}
		public TableTypeIndexByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableTypeIndexByClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTableTypeIndexByClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTableTypeIndexByClause(this);
		}
	}

	[RuleVersion(0)]
	public TableTypeIndexByClauseContext tableTypeIndexByClause() {
		TableTypeIndexByClauseContext _localctx = new TableTypeIndexByClauseContext(Context, State);
		EnterRule(_localctx, 1488, RULE_tableTypeIndexByClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6963;
			Match(INDEX);
			State = 6964;
			Match(BY);
			State = 6965;
			typeReference();
			State = 6968;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOT:
				{
				State = 6966;
				notNullClause();
				}
				break;
			case NULL:
				{
				State = 6967;
				nullClause();
				}
				break;
			case Eof:
			case ALTER:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RefCursorTypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REF() { return GetToken(OracleAntlrParser.REF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURSOR() { return GetToken(OracleAntlrParser.CURSOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CursorReturnClauseContext cursorReturnClause() {
			return GetRuleContext<CursorReturnClauseContext>(0);
		}
		public RefCursorTypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_refCursorTypeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRefCursorTypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRefCursorTypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public RefCursorTypeDeclarationContext refCursorTypeDeclaration() {
		RefCursorTypeDeclarationContext _localctx = new RefCursorTypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1490, RULE_refCursorTypeDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6970;
			Match(REF);
			State = 6971;
			Match(CURSOR);
			State = 6973;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURN) {
				{
				State = 6972;
				cursorReturnClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubtypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBTYPE() { return GetToken(OracleAntlrParser.SUBTYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DelimiterIsContext delimiterIs() {
			return GetRuleContext<DelimiterIsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotNullClauseContext notNullClause() {
			return GetRuleContext<NotNullClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullClauseContext nullClause() {
			return GetRuleContext<NullClauseContext>(0);
		}
		public SubtypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subtypeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubtypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubtypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public SubtypeDeclarationContext subtypeDeclaration() {
		SubtypeDeclarationContext _localctx = new SubtypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1492, RULE_subtypeDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6975;
			Match(SUBTYPE);
			State = 6976;
			simpleIdentifier();
			State = 6977;
			delimiterIs();
			State = 6978;
			typeReference();
			State = 6981;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOT:
				{
				State = 6979;
				notNullClause();
				}
				break;
			case NULL:
				{
				State = 6980;
				nullClause();
				}
				break;
			case SEMI:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CursorDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CursorHeaderContext cursorHeader() {
			return GetRuleContext<CursorHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CursorReturnClauseContext cursorReturnClause() {
			return GetRuleContext<CursorReturnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CursorSelectContext cursorSelect() {
			return GetRuleContext<CursorSelectContext>(0);
		}
		public CursorDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursorDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCursorDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCursorDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public CursorDeclarationContext cursorDeclaration() {
		CursorDeclarationContext _localctx = new CursorDeclarationContext(Context, State);
		EnterRule(_localctx, 1494, RULE_cursorDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6983;
			cursorHeader();
			State = 6985;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 6984;
				argumentList();
				}
			}

			State = 6988;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURN) {
				{
				State = 6987;
				cursorReturnClause();
				}
			}

			State = 6991;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IS) {
				{
				State = 6990;
				cursorSelect();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CursorHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURSOR() { return GetToken(OracleAntlrParser.CURSOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public CursorHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursorHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCursorHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCursorHeader(this);
		}
	}

	[RuleVersion(0)]
	public CursorHeaderContext cursorHeader() {
		CursorHeaderContext _localctx = new CursorHeaderContext(Context, State);
		EnterRule(_localctx, 1496, RULE_cursorHeader);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6993;
			Match(CURSOR);
			State = 6994;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CursorSelectContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(OracleAntlrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public CursorSelectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursorSelect; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCursorSelect(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCursorSelect(this);
		}
	}

	[RuleVersion(0)]
	public CursorSelectContext cursorSelect() {
		CursorSelectContext _localctx = new CursorSelectContext(Context, State);
		EnterRule(_localctx, 1498, RULE_cursorSelect);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6996;
			Match(IS);
			State = 6997;
			selectStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRAGMA() { return GetToken(OracleAntlrParser.PRAGMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionInitPragmaContext exceptionInitPragma() {
			return GetRuleContext<ExceptionInitPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AutonomousTransactionPragmaContext autonomousTransactionPragma() {
			return GetRuleContext<AutonomousTransactionPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SeriallyReusablePragmaContext seriallyReusablePragma() {
			return GetRuleContext<SeriallyReusablePragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RestrictReferencesPragmaContext restrictReferencesPragma() {
			return GetRuleContext<RestrictReferencesPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BuiltinPragmaContext builtinPragma() {
			return GetRuleContext<BuiltinPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FipsflagPragmaContext fipsflagPragma() {
			return GetRuleContext<FipsflagPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InterfacePragmaContext interfacePragma() {
			return GetRuleContext<InterfacePragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TimestampPragmaContext timestampPragma() {
			return GetRuleContext<TimestampPragmaContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NewNamesPragmaContext newNamesPragma() {
			return GetRuleContext<NewNamesPragmaContext>(0);
		}
		public DeclarationPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarationPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDeclarationPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDeclarationPragma(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationPragmaContext declarationPragma() {
		DeclarationPragmaContext _localctx = new DeclarationPragmaContext(Context, State);
		EnterRule(_localctx, 1500, RULE_declarationPragma);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6999;
			Match(PRAGMA);
			State = 7009;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EXCEPTION_INIT:
				{
				State = 7000;
				exceptionInitPragma();
				}
				break;
			case AUTONOMOUS_TRANSACTION:
				{
				State = 7001;
				autonomousTransactionPragma();
				}
				break;
			case SERIALLY_REUSABLE:
				{
				State = 7002;
				seriallyReusablePragma();
				}
				break;
			case RESTRICT_REFERENCES:
				{
				State = 7003;
				restrictReferencesPragma();
				}
				break;
			case BUILTIN:
				{
				State = 7004;
				builtinPragma();
				}
				break;
			case FIPSFLAG:
				{
				State = 7005;
				fipsflagPragma();
				}
				break;
			case INTERFACE:
				{
				State = 7006;
				interfacePragma();
				}
				break;
			case TIMESTAMP:
				{
				State = 7007;
				timestampPragma();
				}
				break;
			case NEW_NAMES:
				{
				State = 7008;
				newNamesPragma();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExceptionInitPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCEPTION_INIT() { return GetToken(OracleAntlrParser.EXCEPTION_INIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public ExceptionInitPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exceptionInitPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExceptionInitPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExceptionInitPragma(this);
		}
	}

	[RuleVersion(0)]
	public ExceptionInitPragmaContext exceptionInitPragma() {
		ExceptionInitPragmaContext _localctx = new ExceptionInitPragmaContext(Context, State);
		EnterRule(_localctx, 1502, RULE_exceptionInitPragma);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7011;
			Match(EXCEPTION_INIT);
			State = 7012;
			Match(LPAREN);
			State = 7013;
			identifier();
			State = 7014;
			Match(COMMA);
			State = 7015;
			fullExpression();
			State = 7016;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AutonomousTransactionPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTONOMOUS_TRANSACTION() { return GetToken(OracleAntlrParser.AUTONOMOUS_TRANSACTION, 0); }
		public AutonomousTransactionPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_autonomousTransactionPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAutonomousTransactionPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAutonomousTransactionPragma(this);
		}
	}

	[RuleVersion(0)]
	public AutonomousTransactionPragmaContext autonomousTransactionPragma() {
		AutonomousTransactionPragmaContext _localctx = new AutonomousTransactionPragmaContext(Context, State);
		EnterRule(_localctx, 1504, RULE_autonomousTransactionPragma);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7018;
			Match(AUTONOMOUS_TRANSACTION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SeriallyReusablePragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERIALLY_REUSABLE() { return GetToken(OracleAntlrParser.SERIALLY_REUSABLE, 0); }
		public SeriallyReusablePragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_seriallyReusablePragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSeriallyReusablePragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSeriallyReusablePragma(this);
		}
	}

	[RuleVersion(0)]
	public SeriallyReusablePragmaContext seriallyReusablePragma() {
		SeriallyReusablePragmaContext _localctx = new SeriallyReusablePragmaContext(Context, State);
		EnterRule(_localctx, 1506, RULE_seriallyReusablePragma);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7020;
			Match(SERIALLY_REUSABLE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RestrictReferencesPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RESTRICT_REFERENCES() { return GetToken(OracleAntlrParser.RESTRICT_REFERENCES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		public RestrictReferencesPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_restrictReferencesPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRestrictReferencesPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRestrictReferencesPragma(this);
		}
	}

	[RuleVersion(0)]
	public RestrictReferencesPragmaContext restrictReferencesPragma() {
		RestrictReferencesPragmaContext _localctx = new RestrictReferencesPragmaContext(Context, State);
		EnterRule(_localctx, 1508, RULE_restrictReferencesPragma);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7022;
			Match(RESTRICT_REFERENCES);
			State = 7023;
			Match(LPAREN);
			State = 7025;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 7024;
				identifierList();
				}
			}

			State = 7027;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BuiltinPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUILTIN() { return GetToken(OracleAntlrParser.BUILTIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public BuiltinPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_builtinPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterBuiltinPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitBuiltinPragma(this);
		}
	}

	[RuleVersion(0)]
	public BuiltinPragmaContext builtinPragma() {
		BuiltinPragmaContext _localctx = new BuiltinPragmaContext(Context, State);
		EnterRule(_localctx, 1510, RULE_builtinPragma);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7029;
			Match(BUILTIN);
			State = 7030;
			Match(LPAREN);
			State = 7032;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLAGG - 512)) | (1L << (XMLCAST - 512)) | (1L << (XMLNAMESPACES - 512)) | (1L << (XMLQUERY - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (INTEGER_LITERAL - 576)) | (1L << (LPAREN - 576)) | (1L << (PLUS_SIGN - 576)) | (1L << (MINUS_SIGN - 576)) | (1L << (QUESTION_MARK - 576)) | (1L << (ASTERISK - 576)) | (1L << (FLOATING_POINT_LITERAL - 576)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 576)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 576)) | (1L << (BINARY_STRING_LITERAL - 576)) | (1L << (CHARACTER_STRING_LITERAL - 576)) | (1L << (MONEY_LITERAL - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 576)))) != 0)) {
				{
				State = 7031;
				expressionList();
				}
			}

			State = 7034;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FipsflagPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIPSFLAG() { return GetToken(OracleAntlrParser.FIPSFLAG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public FipsflagPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fipsflagPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterFipsflagPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitFipsflagPragma(this);
		}
	}

	[RuleVersion(0)]
	public FipsflagPragmaContext fipsflagPragma() {
		FipsflagPragmaContext _localctx = new FipsflagPragmaContext(Context, State);
		EnterRule(_localctx, 1512, RULE_fipsflagPragma);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7036;
			Match(FIPSFLAG);
			State = 7037;
			Match(LPAREN);
			State = 7039;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLAGG - 512)) | (1L << (XMLCAST - 512)) | (1L << (XMLNAMESPACES - 512)) | (1L << (XMLQUERY - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (INTEGER_LITERAL - 576)) | (1L << (LPAREN - 576)) | (1L << (PLUS_SIGN - 576)) | (1L << (MINUS_SIGN - 576)) | (1L << (QUESTION_MARK - 576)) | (1L << (ASTERISK - 576)) | (1L << (FLOATING_POINT_LITERAL - 576)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 576)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 576)) | (1L << (BINARY_STRING_LITERAL - 576)) | (1L << (CHARACTER_STRING_LITERAL - 576)) | (1L << (MONEY_LITERAL - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 576)))) != 0)) {
				{
				State = 7038;
				expressionList();
				}
			}

			State = 7041;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InterfacePragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERFACE() { return GetToken(OracleAntlrParser.INTERFACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public InterfacePragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_interfacePragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterInterfacePragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitInterfacePragma(this);
		}
	}

	[RuleVersion(0)]
	public InterfacePragmaContext interfacePragma() {
		InterfacePragmaContext _localctx = new InterfacePragmaContext(Context, State);
		EnterRule(_localctx, 1514, RULE_interfacePragma);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7043;
			Match(INTERFACE);
			State = 7044;
			Match(LPAREN);
			State = 7046;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLAGG - 512)) | (1L << (XMLCAST - 512)) | (1L << (XMLNAMESPACES - 512)) | (1L << (XMLQUERY - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (INTEGER_LITERAL - 576)) | (1L << (LPAREN - 576)) | (1L << (PLUS_SIGN - 576)) | (1L << (MINUS_SIGN - 576)) | (1L << (QUESTION_MARK - 576)) | (1L << (ASTERISK - 576)) | (1L << (FLOATING_POINT_LITERAL - 576)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 576)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 576)) | (1L << (BINARY_STRING_LITERAL - 576)) | (1L << (CHARACTER_STRING_LITERAL - 576)) | (1L << (MONEY_LITERAL - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 576)))) != 0)) {
				{
				State = 7045;
				expressionList();
				}
			}

			State = 7048;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimestampPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMESTAMP() { return GetToken(OracleAntlrParser.TIMESTAMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public TimestampPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timestampPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTimestampPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTimestampPragma(this);
		}
	}

	[RuleVersion(0)]
	public TimestampPragmaContext timestampPragma() {
		TimestampPragmaContext _localctx = new TimestampPragmaContext(Context, State);
		EnterRule(_localctx, 1516, RULE_timestampPragma);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7050;
			Match(TIMESTAMP);
			State = 7051;
			Match(LPAREN);
			State = 7053;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLAGG - 512)) | (1L << (XMLCAST - 512)) | (1L << (XMLNAMESPACES - 512)) | (1L << (XMLQUERY - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (INTEGER_LITERAL - 576)) | (1L << (LPAREN - 576)) | (1L << (PLUS_SIGN - 576)) | (1L << (MINUS_SIGN - 576)) | (1L << (QUESTION_MARK - 576)) | (1L << (ASTERISK - 576)) | (1L << (FLOATING_POINT_LITERAL - 576)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 576)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 576)) | (1L << (BINARY_STRING_LITERAL - 576)) | (1L << (CHARACTER_STRING_LITERAL - 576)) | (1L << (MONEY_LITERAL - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 576)))) != 0)) {
				{
				State = 7052;
				expressionList();
				}
			}

			State = 7055;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewNamesPragmaContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW_NAMES() { return GetToken(OracleAntlrParser.NEW_NAMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public NewNamesPragmaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newNamesPragma; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNewNamesPragma(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNewNamesPragma(this);
		}
	}

	[RuleVersion(0)]
	public NewNamesPragmaContext newNamesPragma() {
		NewNamesPragmaContext _localctx = new NewNamesPragmaContext(Context, State);
		EnterRule(_localctx, 1518, RULE_newNamesPragma);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7057;
			Match(NEW_NAMES);
			State = 7058;
			Match(LPAREN);
			State = 7060;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (EXTRACTVALUE - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULL - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYS_CONNECT_BY_PATH - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLAGG - 512)) | (1L << (XMLCAST - 512)) | (1L << (XMLNAMESPACES - 512)) | (1L << (XMLQUERY - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (INTEGER_LITERAL - 576)) | (1L << (LPAREN - 576)) | (1L << (PLUS_SIGN - 576)) | (1L << (MINUS_SIGN - 576)) | (1L << (QUESTION_MARK - 576)) | (1L << (ASTERISK - 576)) | (1L << (FLOATING_POINT_LITERAL - 576)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 576)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 576)) | (1L << (BINARY_STRING_LITERAL - 576)) | (1L << (CHARACTER_STRING_LITERAL - 576)) | (1L << (MONEY_LITERAL - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 576)))) != 0)) {
				{
				State = 7059;
				expressionList();
				}
			}

			State = 7062;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableConstantClauseContext variableConstantClause() {
			return GetRuleContext<VariableConstantClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultValueClauseContext defaultValueClause() {
			return GetRuleContext<DefaultValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullClauseContext nullClause() {
			return GetRuleContext<NullClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotNullClauseContext notNullClause() {
			return GetRuleContext<NotNullClauseContext>(0);
		}
		public VariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitVariableDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public VariableDeclarationContext variableDeclaration() {
		VariableDeclarationContext _localctx = new VariableDeclarationContext(Context, State);
		EnterRule(_localctx, 1520, RULE_variableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7064;
			simpleIdentifier();
			State = 7066;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,802,Context) ) {
			case 1:
				{
				State = 7065;
				variableConstantClause();
				}
				break;
			}
			State = 7068;
			typeReference();
			State = 7077;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEFAULT:
			case NOT:
			case ASSIGN_OPERATOR:
				{
				State = 7070;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 7069;
					notNullClause();
					}
				}

				State = 7072;
				defaultValueClause();
				}
				break;
			case NULL:
				{
				State = 7073;
				nullClause();
				State = 7075;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT || _la==ASSIGN_OPERATOR) {
					{
					State = 7074;
					defaultValueClause();
					}
				}

				}
				break;
			case SEMI:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableConstantClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTANT() { return GetToken(OracleAntlrParser.CONSTANT, 0); }
		public VariableConstantClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableConstantClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterVariableConstantClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitVariableConstantClause(this);
		}
	}

	[RuleVersion(0)]
	public VariableConstantClauseContext variableConstantClause() {
		VariableConstantClauseContext _localctx = new VariableConstantClauseContext(Context, State);
		EnterRule(_localctx, 1522, RULE_variableConstantClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7079;
			Match(CONSTANT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(OracleAntlrParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DropTypeBodyStatementContext dropTypeBodyStatement() {
			return GetRuleContext<DropTypeBodyStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropTypeStatementContext dropTypeStatement() {
			return GetRuleContext<DropTypeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropTriggerStatementContext dropTriggerStatement() {
			return GetRuleContext<DropTriggerStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropIndexStatementContext dropIndexStatement() {
			return GetRuleContext<DropIndexStatementContext>(0);
		}
		public DropStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDropStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDropStatement(this);
		}
	}

	[RuleVersion(0)]
	public DropStatementContext dropStatement() {
		DropStatementContext _localctx = new DropStatementContext(Context, State);
		EnterRule(_localctx, 1524, RULE_dropStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7081;
			Match(DROP);
			State = 7086;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,806,Context) ) {
			case 1:
				{
				State = 7082;
				dropTypeBodyStatement();
				}
				break;
			case 2:
				{
				State = 7083;
				dropTypeStatement();
				}
				break;
			case 3:
				{
				State = 7084;
				dropTriggerStatement();
				}
				break;
			case 4:
				{
				State = 7085;
				dropIndexStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropTypeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForceValidateClauseContext forceValidateClause() {
			return GetRuleContext<ForceValidateClauseContext>(0);
		}
		public DropTypeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropTypeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDropTypeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDropTypeStatement(this);
		}
	}

	[RuleVersion(0)]
	public DropTypeStatementContext dropTypeStatement() {
		DropTypeStatementContext _localctx = new DropTypeStatementContext(Context, State);
		EnterRule(_localctx, 1526, RULE_dropTypeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7088;
			Match(TYPE);
			State = 7089;
			plainIdentifier();
			State = 7091;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FORCE || _la==VALIDATE) {
				{
				State = 7090;
				forceValidateClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForceValidateClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORCE() { return GetToken(OracleAntlrParser.FORCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALIDATE() { return GetToken(OracleAntlrParser.VALIDATE, 0); }
		public ForceValidateClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forceValidateClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForceValidateClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForceValidateClause(this);
		}
	}

	[RuleVersion(0)]
	public ForceValidateClauseContext forceValidateClause() {
		ForceValidateClauseContext _localctx = new ForceValidateClauseContext(Context, State);
		EnterRule(_localctx, 1528, RULE_forceValidateClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7093;
			_la = TokenStream.LA(1);
			if ( !(_la==FORCE || _la==VALIDATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropTypeBodyStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BODY() { return GetToken(OracleAntlrParser.BODY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public DropTypeBodyStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropTypeBodyStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDropTypeBodyStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDropTypeBodyStatement(this);
		}
	}

	[RuleVersion(0)]
	public DropTypeBodyStatementContext dropTypeBodyStatement() {
		DropTypeBodyStatementContext _localctx = new DropTypeBodyStatementContext(Context, State);
		EnterRule(_localctx, 1530, RULE_dropTypeBodyStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7095;
			Match(TYPE);
			State = 7096;
			Match(BODY);
			State = 7097;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropTriggerStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIGGER() { return GetToken(OracleAntlrParser.TRIGGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		public DropTriggerStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropTriggerStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDropTriggerStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDropTriggerStatement(this);
		}
	}

	[RuleVersion(0)]
	public DropTriggerStatementContext dropTriggerStatement() {
		DropTriggerStatementContext _localctx = new DropTriggerStatementContext(Context, State);
		EnterRule(_localctx, 1532, RULE_dropTriggerStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7099;
			Match(TRIGGER);
			State = 7100;
			plainIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropIndexStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORCE() { return GetToken(OracleAntlrParser.FORCE, 0); }
		public DropIndexStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropIndexStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDropIndexStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDropIndexStatement(this);
		}
	}

	[RuleVersion(0)]
	public DropIndexStatementContext dropIndexStatement() {
		DropIndexStatementContext _localctx = new DropIndexStatementContext(Context, State);
		EnterRule(_localctx, 1534, RULE_dropIndexStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7102;
			Match(INDEX);
			State = 7103;
			plainIdentifier();
			State = 7105;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FORCE) {
				{
				State = 7104;
				Match(FORCE);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALTER() { return GetToken(OracleAntlrParser.ALTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AlterTypeStatementContext alterTypeStatement() {
			return GetRuleContext<AlterTypeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterSequenceStatementContext alterSequenceStatement() {
			return GetRuleContext<AlterSequenceStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterTriggerStatementContext alterTriggerStatement() {
			return GetRuleContext<AlterTriggerStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterIndexStatementContext alterIndexStatement() {
			return GetRuleContext<AlterIndexStatementContext>(0);
		}
		public AlterStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlterStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlterStatement(this);
		}
	}

	[RuleVersion(0)]
	public AlterStatementContext alterStatement() {
		AlterStatementContext _localctx = new AlterStatementContext(Context, State);
		EnterRule(_localctx, 1536, RULE_alterStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7107;
			Match(ALTER);
			State = 7112;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TYPE:
				{
				State = 7108;
				alterTypeStatement();
				}
				break;
			case SEQUENCE:
				{
				State = 7109;
				alterSequenceStatement();
				}
				break;
			case TRIGGER:
				{
				State = 7110;
				alterTriggerStatement();
				}
				break;
			case INDEX:
				{
				State = 7111;
				alterIndexStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTypeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompileTypeClauseContext compileTypeClause() {
			return GetRuleContext<CompileTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReplaceTypeClauseContext replaceTypeClause() {
			return GetRuleContext<ReplaceTypeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterTypeSpecificationsContext alterTypeSpecifications() {
			return GetRuleContext<AlterTypeSpecificationsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DependentHandlingClauseContext dependentHandlingClause() {
			return GetRuleContext<DependentHandlingClauseContext>(0);
		}
		public AlterTypeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTypeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlterTypeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlterTypeStatement(this);
		}
	}

	[RuleVersion(0)]
	public AlterTypeStatementContext alterTypeStatement() {
		AlterTypeStatementContext _localctx = new AlterTypeStatementContext(Context, State);
		EnterRule(_localctx, 1538, RULE_alterTypeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7114;
			Match(TYPE);
			State = 7115;
			plainIdentifier();
			State = 7122;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPILE:
				{
				State = 7116;
				compileTypeClause();
				}
				break;
			case REPLACE:
				{
				State = 7117;
				replaceTypeClause();
				}
				break;
			case Eof:
			case ADD:
			case ALTER:
			case CASCADE:
			case DROP:
			case FINAL:
			case INSTANTIABLE:
			case INVALIDATE:
			case MODIFY:
			case NOT:
			case OVERRIDING:
			case SEMI:
			case FSLASH:
				{
				State = 7118;
				alterTypeSpecifications();
				State = 7120;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CASCADE || _la==INVALIDATE) {
					{
					State = 7119;
					dependentHandlingClause();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTypeSpecificationsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AlterMethodSpecificationsContext alterMethodSpecifications() {
			return GetRuleContext<AlterMethodSpecificationsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterCollectionClausesContext alterCollectionClauses() {
			return GetRuleContext<AlterCollectionClausesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterAttributeDefinitionContext alterAttributeDefinition() {
			return GetRuleContext<AlterAttributeDefinitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InheritanceClauseContext[] inheritanceClause() {
			return GetRuleContexts<InheritanceClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public InheritanceClauseContext inheritanceClause(int i) {
			return GetRuleContext<InheritanceClauseContext>(i);
		}
		public AlterTypeSpecificationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTypeSpecifications; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlterTypeSpecifications(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlterTypeSpecifications(this);
		}
	}

	[RuleVersion(0)]
	public AlterTypeSpecificationsContext alterTypeSpecifications() {
		AlterTypeSpecificationsContext _localctx = new AlterTypeSpecificationsContext(Context, State);
		EnterRule(_localctx, 1540, RULE_alterTypeSpecifications);
		int _la;
		try {
			State = 7133;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,813,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7124;
				alterMethodSpecifications();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7125;
				alterCollectionClauses();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7126;
				alterAttributeDefinition();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7130;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==FINAL || _la==INSTANTIABLE || _la==NOT || _la==OVERRIDING) {
					{
					{
					State = 7127;
					inheritanceClause();
					}
					}
					State = 7132;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTriggerStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIGGER() { return GetToken(OracleAntlrParser.TRIGGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISABLE() { return GetToken(OracleAntlrParser.DISABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RenameClauseContext renameClause() {
			return GetRuleContext<RenameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompileClauseContext compileClause() {
			return GetRuleContext<CompileClauseContext>(0);
		}
		public AlterTriggerStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTriggerStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlterTriggerStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlterTriggerStatement(this);
		}
	}

	[RuleVersion(0)]
	public AlterTriggerStatementContext alterTriggerStatement() {
		AlterTriggerStatementContext _localctx = new AlterTriggerStatementContext(Context, State);
		EnterRule(_localctx, 1542, RULE_alterTriggerStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7135;
			Match(TRIGGER);
			State = 7136;
			plainIdentifier();
			State = 7141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ENABLE:
				{
				State = 7137;
				Match(ENABLE);
				}
				break;
			case DISABLE:
				{
				State = 7138;
				Match(DISABLE);
				}
				break;
			case RENAME:
				{
				State = 7139;
				renameClause();
				}
				break;
			case COMPILE:
				{
				State = 7140;
				compileClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RENAME() { return GetToken(OracleAntlrParser.RENAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(OracleAntlrParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public RenameClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRenameClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRenameClause(this);
		}
	}

	[RuleVersion(0)]
	public RenameClauseContext renameClause() {
		RenameClauseContext _localctx = new RenameClauseContext(Context, State);
		EnterRule(_localctx, 1544, RULE_renameClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7143;
			Match(RENAME);
			State = 7144;
			Match(TO);
			State = 7145;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompileClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPILE() { return GetToken(OracleAntlrParser.COMPILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEBUG() { return GetToken(OracleAntlrParser.DEBUG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CompilerParametersClauseContext compilerParametersClause() {
			return GetRuleContext<CompilerParametersClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REUSE() { return GetToken(OracleAntlrParser.REUSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETTINGS() { return GetToken(OracleAntlrParser.SETTINGS, 0); }
		public CompileClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compileClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCompileClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCompileClause(this);
		}
	}

	[RuleVersion(0)]
	public CompileClauseContext compileClause() {
		CompileClauseContext _localctx = new CompileClauseContext(Context, State);
		EnterRule(_localctx, 1546, RULE_compileClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7147;
			Match(COMPILE);
			State = 7149;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,815,Context) ) {
			case 1:
				{
				State = 7148;
				Match(DEBUG);
				}
				break;
			}
			State = 7152;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,816,Context) ) {
			case 1:
				{
				State = 7151;
				compilerParametersClause();
				}
				break;
			}
			State = 7156;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REUSE) {
				{
				State = 7154;
				Match(REUSE);
				State = 7155;
				Match(SETTINGS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterIndexStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(OracleAntlrParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(OracleAntlrParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISABLE() { return GetToken(OracleAntlrParser.DISABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COALESCE() { return GetToken(OracleAntlrParser.COALESCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USAGE() { return GetToken(OracleAntlrParser.USAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UPDATE() { return GetToken(OracleAntlrParser.UPDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BLOCK() { return GetToken(OracleAntlrParser.BLOCK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFERENCES() { return GetToken(OracleAntlrParser.REFERENCES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexOptionsContext indexOptions() {
			return GetRuleContext<IndexOptionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RebuildClauseContext rebuildClause() {
			return GetRuleContext<RebuildClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParametersClauseContext parametersClause() {
			return GetRuleContext<ParametersClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RenameClauseContext renameClause() {
			return GetRuleContext<RenameClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterIndexPartitioningContext alterIndexPartitioning() {
			return GetRuleContext<AlterIndexPartitioningContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MONITORING() { return GetToken(OracleAntlrParser.MONITORING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMONITORING() { return GetToken(OracleAntlrParser.NOMONITORING, 0); }
		public AlterIndexStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterIndexStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlterIndexStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlterIndexStatement(this);
		}
	}

	[RuleVersion(0)]
	public AlterIndexStatementContext alterIndexStatement() {
		AlterIndexStatementContext _localctx = new AlterIndexStatementContext(Context, State);
		EnterRule(_localctx, 1548, RULE_alterIndexStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7158;
			Match(INDEX);
			State = 7159;
			plainIdentifier();
			State = 7174;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,818,Context) ) {
			case 1:
				{
				State = 7160;
				Match(ENABLE);
				}
				break;
			case 2:
				{
				State = 7161;
				Match(DISABLE);
				}
				break;
			case 3:
				{
				State = 7162;
				Match(UNUSABLE);
				}
				break;
			case 4:
				{
				State = 7163;
				Match(COALESCE);
				}
				break;
			case 5:
				{
				State = 7164;
				_la = TokenStream.LA(1);
				if ( !(_la==MONITORING || _la==NOMONITORING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 7165;
				Match(USAGE);
				}
				break;
			case 6:
				{
				State = 7166;
				Match(UPDATE);
				State = 7167;
				Match(BLOCK);
				State = 7168;
				Match(REFERENCES);
				}
				break;
			case 7:
				{
				State = 7169;
				indexOptions();
				}
				break;
			case 8:
				{
				State = 7170;
				rebuildClause();
				}
				break;
			case 9:
				{
				State = 7171;
				parametersClause();
				}
				break;
			case 10:
				{
				State = 7172;
				renameClause();
				}
				break;
			case 11:
				{
				State = 7173;
				alterIndexPartitioning();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOptionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeallocateUnusedClauseContext[] deallocateUnusedClause() {
			return GetRuleContexts<DeallocateUnusedClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeallocateUnusedClauseContext deallocateUnusedClause(int i) {
			return GetRuleContext<DeallocateUnusedClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AllocateExtentClauseContext[] allocateExtentClause() {
			return GetRuleContexts<AllocateExtentClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AllocateExtentClauseContext allocateExtentClause(int i) {
			return GetRuleContext<AllocateExtentClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShrinkClauseContext[] shrinkClause() {
			return GetRuleContexts<ShrinkClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShrinkClauseContext shrinkClause(int i) {
			return GetRuleContext<ShrinkClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext[] parallelClause() {
			return GetRuleContexts<ParallelClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause(int i) {
			return GetRuleContext<ParallelClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext[] physicalAttribute() {
			return GetRuleContexts<PhysicalAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute(int i) {
			return GetRuleContext<PhysicalAttributeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext[] loggingClause() {
			return GetRuleContexts<LoggingClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause(int i) {
			return GetRuleContext<LoggingClauseContext>(i);
		}
		public IndexOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOptions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexOptions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexOptions(this);
		}
	}

	[RuleVersion(0)]
	public IndexOptionsContext indexOptions() {
		IndexOptionsContext _localctx = new IndexOptionsContext(Context, State);
		EnterRule(_localctx, 1550, RULE_indexOptions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7184;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ALLOCATE || _la==DEALLOCATE || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 277)) & ~0x3f) == 0 && ((1L << (_la - 277)) & ((1L << (LOGGING - 277)) | (1L << (MAXTRANS - 277)) | (1L << (NOLOGGING - 277)) | (1L << (NOPARALLEL - 277)))) != 0) || ((((_la - 377)) & ~0x3f) == 0 && ((1L << (_la - 377)) & ((1L << (PARALLEL - 377)) | (1L << (PCTFREE - 377)) | (1L << (PCTUSED - 377)))) != 0) || _la==SHRINK || _la==STORAGE) {
				{
				State = 7182;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DEALLOCATE:
					{
					State = 7176;
					deallocateUnusedClause();
					}
					break;
				case ALLOCATE:
					{
					State = 7177;
					allocateExtentClause();
					}
					break;
				case SHRINK:
					{
					State = 7178;
					shrinkClause();
					}
					break;
				case NOPARALLEL:
				case PARALLEL:
					{
					State = 7179;
					parallelClause();
					}
					break;
				case INITRANS:
				case MAXTRANS:
				case PCTFREE:
				case PCTUSED:
				case STORAGE:
					{
					State = 7180;
					physicalAttribute();
					}
					break;
				case FILESYSTEM_LIKE_LOGGING:
				case LOGGING:
				case NOLOGGING:
					{
					State = 7181;
					loggingClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 7186;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeallocateUnusedClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEALLOCATE() { return GetToken(OracleAntlrParser.DEALLOCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSED() { return GetToken(OracleAntlrParser.UNUSED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public KeepSizeClauseContext keepSizeClause() {
			return GetRuleContext<KeepSizeClauseContext>(0);
		}
		public DeallocateUnusedClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deallocateUnusedClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDeallocateUnusedClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDeallocateUnusedClause(this);
		}
	}

	[RuleVersion(0)]
	public DeallocateUnusedClauseContext deallocateUnusedClause() {
		DeallocateUnusedClauseContext _localctx = new DeallocateUnusedClauseContext(Context, State);
		EnterRule(_localctx, 1552, RULE_deallocateUnusedClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7187;
			Match(DEALLOCATE);
			State = 7188;
			Match(UNUSED);
			State = 7190;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KEEP) {
				{
				State = 7189;
				keepSizeClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeepSizeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ByteSizeLiteralContext byteSizeLiteral() {
			return GetRuleContext<ByteSizeLiteralContext>(0);
		}
		public KeepSizeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keepSizeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterKeepSizeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitKeepSizeClause(this);
		}
	}

	[RuleVersion(0)]
	public KeepSizeClauseContext keepSizeClause() {
		KeepSizeClauseContext _localctx = new KeepSizeClauseContext(Context, State);
		EnterRule(_localctx, 1554, RULE_keepSizeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7192;
			Match(KEEP);
			State = 7193;
			byteSizeLiteral();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AllocateExtentClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALLOCATE() { return GetToken(OracleAntlrParser.ALLOCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTENT() { return GetToken(OracleAntlrParser.EXTENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExtentOptionsContext extentOptions() {
			return GetRuleContext<ExtentOptionsContext>(0);
		}
		public AllocateExtentClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_allocateExtentClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAllocateExtentClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAllocateExtentClause(this);
		}
	}

	[RuleVersion(0)]
	public AllocateExtentClauseContext allocateExtentClause() {
		AllocateExtentClauseContext _localctx = new AllocateExtentClauseContext(Context, State);
		EnterRule(_localctx, 1556, RULE_allocateExtentClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7195;
			Match(ALLOCATE);
			State = 7196;
			Match(EXTENT);
			State = 7198;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 7197;
				extentOptions();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtentOptionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExtentOptionContext[] extentOption() {
			return GetRuleContexts<ExtentOptionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtentOptionContext extentOption(int i) {
			return GetRuleContext<ExtentOptionContext>(i);
		}
		public ExtentOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extentOptions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExtentOptions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExtentOptions(this);
		}
	}

	[RuleVersion(0)]
	public ExtentOptionsContext extentOptions() {
		ExtentOptionsContext _localctx = new ExtentOptionsContext(Context, State);
		EnterRule(_localctx, 1558, RULE_extentOptions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7200;
			Match(LPAREN);
			State = 7202;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 7201;
				extentOption();
				}
				}
				State = 7204;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==DATAFILE || _la==INSTANCE || _la==SIZE );
			State = 7206;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtentOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIZE() { return GetToken(OracleAntlrParser.SIZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ByteSizeLiteralContext byteSizeLiteral() {
			return GetRuleContext<ByteSizeLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATAFILE() { return GetToken(OracleAntlrParser.DATAFILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSTANCE() { return GetToken(OracleAntlrParser.INSTANCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ExtentOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extentOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterExtentOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitExtentOption(this);
		}
	}

	[RuleVersion(0)]
	public ExtentOptionContext extentOption() {
		ExtentOptionContext _localctx = new ExtentOptionContext(Context, State);
		EnterRule(_localctx, 1560, RULE_extentOption);
		try {
			State = 7214;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SIZE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7208;
				Match(SIZE);
				State = 7209;
				byteSizeLiteral();
				}
				break;
			case DATAFILE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7210;
				Match(DATAFILE);
				State = 7211;
				fullExpression();
				}
				break;
			case INSTANCE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7212;
				Match(INSTANCE);
				State = 7213;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShrinkClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHRINK() { return GetToken(OracleAntlrParser.SHRINK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SPACE() { return GetToken(OracleAntlrParser.SPACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPACT() { return GetToken(OracleAntlrParser.COMPACT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASCADE() { return GetToken(OracleAntlrParser.CASCADE, 0); }
		public ShrinkClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shrinkClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterShrinkClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitShrinkClause(this);
		}
	}

	[RuleVersion(0)]
	public ShrinkClauseContext shrinkClause() {
		ShrinkClauseContext _localctx = new ShrinkClauseContext(Context, State);
		EnterRule(_localctx, 1562, RULE_shrinkClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7216;
			Match(SHRINK);
			State = 7217;
			Match(SPACE);
			State = 7219;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMPACT) {
				{
				State = 7218;
				Match(COMPACT);
				}
			}

			State = 7222;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CASCADE) {
				{
				State = 7221;
				Match(CASCADE);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PhysicalAttributeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTFREE() { return GetToken(OracleAntlrParser.PCTFREE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PCTUSED() { return GetToken(OracleAntlrParser.PCTUSED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INITRANS() { return GetToken(OracleAntlrParser.INITRANS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXTRANS() { return GetToken(OracleAntlrParser.MAXTRANS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StorageAttributesClauseContext storageAttributesClause() {
			return GetRuleContext<StorageAttributesClauseContext>(0);
		}
		public PhysicalAttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_physicalAttribute; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterPhysicalAttribute(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitPhysicalAttribute(this);
		}
	}

	[RuleVersion(0)]
	public PhysicalAttributeContext physicalAttribute() {
		PhysicalAttributeContext _localctx = new PhysicalAttributeContext(Context, State);
		EnterRule(_localctx, 1564, RULE_physicalAttribute);
		try {
			State = 7233;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PCTFREE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7224;
				Match(PCTFREE);
				State = 7225;
				literal();
				}
				break;
			case PCTUSED:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7226;
				Match(PCTUSED);
				State = 7227;
				literal();
				}
				break;
			case INITRANS:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7228;
				Match(INITRANS);
				State = 7229;
				literal();
				}
				break;
			case MAXTRANS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7230;
				Match(MAXTRANS);
				State = 7231;
				literal();
				}
				break;
			case STORAGE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7232;
				storageAttributesClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RebuildClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REBUILD() { return GetToken(OracleAntlrParser.REBUILD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REVERSE() { return GetToken(OracleAntlrParser.REVERSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOREVERSE() { return GetToken(OracleAntlrParser.NOREVERSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RebuildOptionsContext[] rebuildOptions() {
			return GetRuleContexts<RebuildOptionsContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RebuildOptionsContext rebuildOptions(int i) {
			return GetRuleContext<RebuildOptionsContext>(i);
		}
		public RebuildClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rebuildClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRebuildClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRebuildClause(this);
		}
	}

	[RuleVersion(0)]
	public RebuildClauseContext rebuildClause() {
		RebuildClauseContext _localctx = new RebuildClauseContext(Context, State);
		EnterRule(_localctx, 1566, RULE_rebuildClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7235;
			Match(REBUILD);
			State = 7242;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PARTITION:
				{
				State = 7236;
				Match(PARTITION);
				State = 7237;
				simpleIdentifierWithoutParentheses();
				}
				break;
			case SUBPARTITION:
				{
				State = 7238;
				Match(SUBPARTITION);
				State = 7239;
				simpleIdentifierWithoutParentheses();
				}
				break;
			case REVERSE:
				{
				State = 7240;
				Match(REVERSE);
				}
				break;
			case NOREVERSE:
				{
				State = 7241;
				Match(NOREVERSE);
				}
				break;
			case Eof:
			case COMPRESS:
			case COMPUTE:
			case FILESYSTEM_LIKE_LOGGING:
			case INITRANS:
			case LOGGING:
			case MAXTRANS:
			case NOCOMPRESS:
			case NOLOGGING:
			case NOPARALLEL:
			case ONLINE:
			case PARALLEL:
			case PARAMETERS:
			case PCTFREE:
			case PCTUSED:
			case STORAGE:
			case TABLESPACE:
			case SEMI:
			case FSLASH:
				break;
			default:
				break;
			}
			State = 7247;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMPRESS || _la==COMPUTE || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 277)) & ~0x3f) == 0 && ((1L << (_la - 277)) & ((1L << (LOGGING - 277)) | (1L << (MAXTRANS - 277)) | (1L << (NOCOMPRESS - 277)) | (1L << (NOLOGGING - 277)) | (1L << (NOPARALLEL - 277)))) != 0) || ((((_la - 360)) & ~0x3f) == 0 && ((1L << (_la - 360)) & ((1L << (ONLINE - 360)) | (1L << (PARALLEL - 360)) | (1L << (PARAMETERS - 360)) | (1L << (PCTFREE - 360)) | (1L << (PCTUSED - 360)))) != 0) || _la==STORAGE || _la==TABLESPACE) {
				{
				{
				State = 7244;
				rebuildOptions();
				}
				}
				State = 7249;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RebuildOptionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause() {
			return GetRuleContext<TablespaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParametersClauseContext parametersClause() {
			return GetRuleContext<ParametersClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLINE() { return GetToken(OracleAntlrParser.ONLINE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPUTE() { return GetToken(OracleAntlrParser.COMPUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATISTICS() { return GetToken(OracleAntlrParser.STATISTICS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute() {
			return GetRuleContext<PhysicalAttributeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeyCompressionContext keyCompression() {
			return GetRuleContext<KeyCompressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause() {
			return GetRuleContext<LoggingClauseContext>(0);
		}
		public RebuildOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rebuildOptions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRebuildOptions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRebuildOptions(this);
		}
	}

	[RuleVersion(0)]
	public RebuildOptionsContext rebuildOptions() {
		RebuildOptionsContext _localctx = new RebuildOptionsContext(Context, State);
		EnterRule(_localctx, 1568, RULE_rebuildOptions);
		try {
			State = 7259;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOPARALLEL:
			case PARALLEL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7250;
				parallelClause();
				}
				break;
			case TABLESPACE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7251;
				tablespaceClause();
				}
				break;
			case PARAMETERS:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7252;
				parametersClause();
				}
				break;
			case ONLINE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7253;
				Match(ONLINE);
				}
				break;
			case COMPUTE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7254;
				Match(COMPUTE);
				State = 7255;
				Match(STATISTICS);
				}
				break;
			case INITRANS:
			case MAXTRANS:
			case PCTFREE:
			case PCTUSED:
			case STORAGE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 7256;
				physicalAttribute();
				}
				break;
			case COMPRESS:
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 7);
				{
				State = 7257;
				keyCompression();
				}
				break;
			case FILESYSTEM_LIKE_LOGGING:
			case LOGGING:
			case NOLOGGING:
				EnterOuterAlt(_localctx, 8);
				{
				State = 7258;
				loggingClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeyCompressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPRESS() { return GetToken(OracleAntlrParser.COMPRESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCOMPRESS() { return GetToken(OracleAntlrParser.NOCOMPRESS, 0); }
		public KeyCompressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keyCompression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterKeyCompression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitKeyCompression(this);
		}
	}

	[RuleVersion(0)]
	public KeyCompressionContext keyCompression() {
		KeyCompressionContext _localctx = new KeyCompressionContext(Context, State);
		EnterRule(_localctx, 1570, RULE_keyCompression);
		int _la;
		try {
			State = 7266;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPRESS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7261;
				Match(COMPRESS);
				State = 7263;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATE || _la==FALSE || _la==INTERVAL || _la==TIMESTAMP || _la==TRUE || ((((_la - 581)) & ~0x3f) == 0 && ((1L << (_la - 581)) & ((1L << (INTEGER_LITERAL - 581)) | (1L << (FLOATING_POINT_LITERAL - 581)) | (1L << (FLOATING_POINT_BINARY_LITERAL - 581)) | (1L << (UNICODE_CHARACTER_STRING_LITERAL - 581)) | (1L << (BINARY_STRING_LITERAL - 581)) | (1L << (CHARACTER_STRING_LITERAL - 581)) | (1L << (MONEY_LITERAL - 581)) | (1L << (QUOTE_CHARACTER_STRING_LITERAL - 581)))) != 0)) {
					{
					State = 7262;
					literal();
					}
				}

				}
				break;
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7265;
				Match(NOCOMPRESS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParametersClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARAMETERS() { return GetToken(OracleAntlrParser.PARAMETERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public ParametersClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parametersClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterParametersClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitParametersClause(this);
		}
	}

	[RuleVersion(0)]
	public ParametersClauseContext parametersClause() {
		ParametersClauseContext _localctx = new ParametersClauseContext(Context, State);
		EnterRule(_localctx, 1572, RULE_parametersClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7268;
			Match(PARAMETERS);
			State = 7269;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterIndexPartitioningContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModifyIndexDefaultAttributesContext modifyIndexDefaultAttributes() {
			return GetRuleContext<ModifyIndexDefaultAttributesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AddHashIndexPartitionContext addHashIndexPartition() {
			return GetRuleContext<AddHashIndexPartitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModifyIndexPartitionContext modifyIndexPartition() {
			return GetRuleContext<ModifyIndexPartitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RenameIndexPartitionContext renameIndexPartition() {
			return GetRuleContext<RenameIndexPartitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropIndexPartitionContext dropIndexPartition() {
			return GetRuleContext<DropIndexPartitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SplitIndexPartitionContext splitIndexPartition() {
			return GetRuleContext<SplitIndexPartitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CoalesceIndexPartitionContext coalesceIndexPartition() {
			return GetRuleContext<CoalesceIndexPartitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModifyIndexSubpartitionContext modifyIndexSubpartition() {
			return GetRuleContext<ModifyIndexSubpartitionContext>(0);
		}
		public AlterIndexPartitioningContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterIndexPartitioning; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlterIndexPartitioning(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlterIndexPartitioning(this);
		}
	}

	[RuleVersion(0)]
	public AlterIndexPartitioningContext alterIndexPartitioning() {
		AlterIndexPartitioningContext _localctx = new AlterIndexPartitioningContext(Context, State);
		EnterRule(_localctx, 1574, RULE_alterIndexPartitioning);
		try {
			State = 7279;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,833,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7271;
				modifyIndexDefaultAttributes();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7272;
				addHashIndexPartition();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7273;
				modifyIndexPartition();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7274;
				renameIndexPartition();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7275;
				dropIndexPartition();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 7276;
				splitIndexPartition();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 7277;
				coalesceIndexPartition();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 7278;
				modifyIndexSubpartition();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModifyIndexDefaultAttributesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MODIFY() { return GetToken(OracleAntlrParser.MODIFY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(OracleAntlrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ATTRIBUTES() { return GetToken(OracleAntlrParser.ATTRIBUTES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModifyIndexAttributesContext[] modifyIndexAttributes() {
			return GetRuleContexts<ModifyIndexAttributesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModifyIndexAttributesContext modifyIndexAttributes(int i) {
			return GetRuleContext<ModifyIndexAttributesContext>(i);
		}
		public ModifyIndexDefaultAttributesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifyIndexDefaultAttributes; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterModifyIndexDefaultAttributes(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitModifyIndexDefaultAttributes(this);
		}
	}

	[RuleVersion(0)]
	public ModifyIndexDefaultAttributesContext modifyIndexDefaultAttributes() {
		ModifyIndexDefaultAttributesContext _localctx = new ModifyIndexDefaultAttributesContext(Context, State);
		EnterRule(_localctx, 1576, RULE_modifyIndexDefaultAttributes);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7281;
			Match(MODIFY);
			State = 7282;
			Match(DEFAULT);
			State = 7283;
			Match(ATTRIBUTES);
			State = 7287;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 7284;
				Match(FOR);
				State = 7285;
				Match(PARTITION);
				State = 7286;
				simpleIdentifierWithoutParentheses();
				}
			}

			State = 7290;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 7289;
				modifyIndexAttributes();
				}
				}
				State = 7292;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 277)) & ~0x3f) == 0 && ((1L << (_la - 277)) & ((1L << (LOGGING - 277)) | (1L << (MAXTRANS - 277)) | (1L << (NOLOGGING - 277)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModifyIndexAttributesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute() {
			return GetRuleContext<PhysicalAttributeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause() {
			return GetRuleContext<TablespaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause() {
			return GetRuleContext<LoggingClauseContext>(0);
		}
		public ModifyIndexAttributesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifyIndexAttributes; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterModifyIndexAttributes(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitModifyIndexAttributes(this);
		}
	}

	[RuleVersion(0)]
	public ModifyIndexAttributesContext modifyIndexAttributes() {
		ModifyIndexAttributesContext _localctx = new ModifyIndexAttributesContext(Context, State);
		EnterRule(_localctx, 1578, RULE_modifyIndexAttributes);
		try {
			State = 7297;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INITRANS:
			case MAXTRANS:
			case PCTFREE:
			case PCTUSED:
			case STORAGE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7294;
				physicalAttribute();
				}
				break;
			case TABLESPACE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7295;
				tablespaceClause();
				}
				break;
			case FILESYSTEM_LIKE_LOGGING:
			case LOGGING:
			case NOLOGGING:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7296;
				loggingClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddHashIndexPartitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADD() { return GetToken(OracleAntlrParser.ADD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TablespaceClauseContext tablespaceClause() {
			return GetRuleContext<TablespaceClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		public AddHashIndexPartitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addHashIndexPartition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAddHashIndexPartition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAddHashIndexPartition(this);
		}
	}

	[RuleVersion(0)]
	public AddHashIndexPartitionContext addHashIndexPartition() {
		AddHashIndexPartitionContext _localctx = new AddHashIndexPartitionContext(Context, State);
		EnterRule(_localctx, 1580, RULE_addHashIndexPartition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7299;
			Match(ADD);
			State = 7300;
			Match(PARTITION);
			State = 7302;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,837,Context) ) {
			case 1:
				{
				State = 7301;
				simpleIdentifierWithoutParentheses();
				}
				break;
			}
			State = 7305;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLESPACE) {
				{
				State = 7304;
				tablespaceClause();
				}
			}

			State = 7308;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOPARALLEL || _la==PARALLEL) {
				{
				State = 7307;
				parallelClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CoalesceIndexPartitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COALESCE() { return GetToken(OracleAntlrParser.COALESCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		public CoalesceIndexPartitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_coalesceIndexPartition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCoalesceIndexPartition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCoalesceIndexPartition(this);
		}
	}

	[RuleVersion(0)]
	public CoalesceIndexPartitionContext coalesceIndexPartition() {
		CoalesceIndexPartitionContext _localctx = new CoalesceIndexPartitionContext(Context, State);
		EnterRule(_localctx, 1582, RULE_coalesceIndexPartition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7310;
			Match(COALESCE);
			State = 7311;
			Match(PARTITION);
			State = 7313;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOPARALLEL || _la==PARALLEL) {
				{
				State = 7312;
				parallelClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModifyIndexPartitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MODIFY() { return GetToken(OracleAntlrParser.MODIFY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModifyIndexPartitionOptionsContext modifyIndexPartitionOptions() {
			return GetRuleContext<ModifyIndexPartitionOptionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParametersClauseContext parametersClause() {
			return GetRuleContext<ParametersClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COALESCE() { return GetToken(OracleAntlrParser.COALESCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UPDATE() { return GetToken(OracleAntlrParser.UPDATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BLOCK() { return GetToken(OracleAntlrParser.BLOCK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REFERENCES() { return GetToken(OracleAntlrParser.REFERENCES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		public ModifyIndexPartitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifyIndexPartition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterModifyIndexPartition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitModifyIndexPartition(this);
		}
	}

	[RuleVersion(0)]
	public ModifyIndexPartitionContext modifyIndexPartition() {
		ModifyIndexPartitionContext _localctx = new ModifyIndexPartitionContext(Context, State);
		EnterRule(_localctx, 1584, RULE_modifyIndexPartition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7315;
			Match(MODIFY);
			State = 7316;
			Match(PARTITION);
			State = 7317;
			simpleIdentifierWithoutParentheses();
			State = 7325;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
			case ALLOCATE:
			case COMPRESS:
			case DEALLOCATE:
			case FILESYSTEM_LIKE_LOGGING:
			case INITRANS:
			case LOGGING:
			case MAXTRANS:
			case NOCOMPRESS:
			case NOLOGGING:
			case PCTFREE:
			case PCTUSED:
			case STORAGE:
			case SEMI:
			case FSLASH:
				{
				State = 7318;
				modifyIndexPartitionOptions();
				}
				break;
			case PARAMETERS:
				{
				State = 7319;
				parametersClause();
				}
				break;
			case COALESCE:
				{
				State = 7320;
				Match(COALESCE);
				}
				break;
			case UPDATE:
				{
				State = 7321;
				Match(UPDATE);
				State = 7322;
				Match(BLOCK);
				State = 7323;
				Match(REFERENCES);
				}
				break;
			case UNUSABLE:
				{
				State = 7324;
				Match(UNUSABLE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModifyIndexPartitionOptionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeallocateUnusedClauseContext[] deallocateUnusedClause() {
			return GetRuleContexts<DeallocateUnusedClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeallocateUnusedClauseContext deallocateUnusedClause(int i) {
			return GetRuleContext<DeallocateUnusedClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AllocateExtentClauseContext[] allocateExtentClause() {
			return GetRuleContexts<AllocateExtentClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AllocateExtentClauseContext allocateExtentClause(int i) {
			return GetRuleContext<AllocateExtentClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext[] physicalAttribute() {
			return GetRuleContexts<PhysicalAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PhysicalAttributeContext physicalAttribute(int i) {
			return GetRuleContext<PhysicalAttributeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext[] loggingClause() {
			return GetRuleContexts<LoggingClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoggingClauseContext loggingClause(int i) {
			return GetRuleContext<LoggingClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeyCompressionContext[] keyCompression() {
			return GetRuleContexts<KeyCompressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeyCompressionContext keyCompression(int i) {
			return GetRuleContext<KeyCompressionContext>(i);
		}
		public ModifyIndexPartitionOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifyIndexPartitionOptions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterModifyIndexPartitionOptions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitModifyIndexPartitionOptions(this);
		}
	}

	[RuleVersion(0)]
	public ModifyIndexPartitionOptionsContext modifyIndexPartitionOptions() {
		ModifyIndexPartitionOptionsContext _localctx = new ModifyIndexPartitionOptionsContext(Context, State);
		EnterRule(_localctx, 1586, RULE_modifyIndexPartitionOptions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7334;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ALLOCATE || _la==COMPRESS || _la==DEALLOCATE || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 277)) & ~0x3f) == 0 && ((1L << (_la - 277)) & ((1L << (LOGGING - 277)) | (1L << (MAXTRANS - 277)) | (1L << (NOCOMPRESS - 277)) | (1L << (NOLOGGING - 277)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE) {
				{
				State = 7332;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DEALLOCATE:
					{
					State = 7327;
					deallocateUnusedClause();
					}
					break;
				case ALLOCATE:
					{
					State = 7328;
					allocateExtentClause();
					}
					break;
				case INITRANS:
				case MAXTRANS:
				case PCTFREE:
				case PCTUSED:
				case STORAGE:
					{
					State = 7329;
					physicalAttribute();
					}
					break;
				case FILESYSTEM_LIKE_LOGGING:
				case LOGGING:
				case NOLOGGING:
					{
					State = 7330;
					loggingClause();
					}
					break;
				case COMPRESS:
				case NOCOMPRESS:
					{
					State = 7331;
					keyCompression();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 7336;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameIndexPartitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RENAME() { return GetToken(OracleAntlrParser.RENAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext[] simpleIdentifierWithoutParentheses() {
			return GetRuleContexts<SimpleIdentifierWithoutParenthesesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses(int i) {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(OracleAntlrParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		public RenameIndexPartitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameIndexPartition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterRenameIndexPartition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitRenameIndexPartition(this);
		}
	}

	[RuleVersion(0)]
	public RenameIndexPartitionContext renameIndexPartition() {
		RenameIndexPartitionContext _localctx = new RenameIndexPartitionContext(Context, State);
		EnterRule(_localctx, 1588, RULE_renameIndexPartition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7337;
			Match(RENAME);
			State = 7338;
			_la = TokenStream.LA(1);
			if ( !(_la==PARTITION || _la==SUBPARTITION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 7339;
			simpleIdentifierWithoutParentheses();
			State = 7340;
			Match(TO);
			State = 7341;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropIndexPartitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(OracleAntlrParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		public DropIndexPartitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropIndexPartition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDropIndexPartition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDropIndexPartition(this);
		}
	}

	[RuleVersion(0)]
	public DropIndexPartitionContext dropIndexPartition() {
		DropIndexPartitionContext _localctx = new DropIndexPartitionContext(Context, State);
		EnterRule(_localctx, 1590, RULE_dropIndexPartition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7343;
			Match(DROP);
			State = 7344;
			Match(PARTITION);
			State = 7345;
			simpleIdentifierWithoutParentheses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SplitIndexPartitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SPLIT() { return GetToken(OracleAntlrParser.SPLIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SplitIndexPartitionAtClauseContext splitIndexPartitionAtClause() {
			return GetRuleContext<SplitIndexPartitionAtClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SplitIndexPartitionIntoClauseContext splitIndexPartitionIntoClause() {
			return GetRuleContext<SplitIndexPartitionIntoClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParallelClauseContext parallelClause() {
			return GetRuleContext<ParallelClauseContext>(0);
		}
		public SplitIndexPartitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_splitIndexPartition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSplitIndexPartition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSplitIndexPartition(this);
		}
	}

	[RuleVersion(0)]
	public SplitIndexPartitionContext splitIndexPartition() {
		SplitIndexPartitionContext _localctx = new SplitIndexPartitionContext(Context, State);
		EnterRule(_localctx, 1592, RULE_splitIndexPartition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7347;
			Match(SPLIT);
			State = 7348;
			Match(PARTITION);
			State = 7349;
			simpleIdentifierWithoutParentheses();
			State = 7350;
			splitIndexPartitionAtClause();
			State = 7352;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTO) {
				{
				State = 7351;
				splitIndexPartitionIntoClause();
				}
			}

			State = 7355;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOPARALLEL || _la==PARALLEL) {
				{
				State = 7354;
				parallelClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SplitIndexPartitionAtClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT() { return GetToken(OracleAntlrParser.AT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParenthesizedExpressionListContext parenthesizedExpressionList() {
			return GetRuleContext<ParenthesizedExpressionListContext>(0);
		}
		public SplitIndexPartitionAtClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_splitIndexPartitionAtClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSplitIndexPartitionAtClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSplitIndexPartitionAtClause(this);
		}
	}

	[RuleVersion(0)]
	public SplitIndexPartitionAtClauseContext splitIndexPartitionAtClause() {
		SplitIndexPartitionAtClauseContext _localctx = new SplitIndexPartitionAtClauseContext(Context, State);
		EnterRule(_localctx, 1594, RULE_splitIndexPartitionAtClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7357;
			Match(AT);
			State = 7358;
			parenthesizedExpressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SplitIndexPartitionIntoClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTO() { return GetToken(OracleAntlrParser.INTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexPartitionDescriptionContext[] indexPartitionDescription() {
			return GetRuleContexts<IndexPartitionDescriptionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexPartitionDescriptionContext indexPartitionDescription(int i) {
			return GetRuleContext<IndexPartitionDescriptionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(OracleAntlrParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		public SplitIndexPartitionIntoClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_splitIndexPartitionIntoClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSplitIndexPartitionIntoClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSplitIndexPartitionIntoClause(this);
		}
	}

	[RuleVersion(0)]
	public SplitIndexPartitionIntoClauseContext splitIndexPartitionIntoClause() {
		SplitIndexPartitionIntoClauseContext _localctx = new SplitIndexPartitionIntoClauseContext(Context, State);
		EnterRule(_localctx, 1596, RULE_splitIndexPartitionIntoClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7360;
			Match(INTO);
			State = 7361;
			Match(LPAREN);
			State = 7362;
			indexPartitionDescription();
			State = 7363;
			Match(COMMA);
			State = 7364;
			indexPartitionDescription();
			State = 7365;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexPartitionDescriptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARTITION() { return GetToken(OracleAntlrParser.PARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseContext[] segmentAttributesClause() {
			return GetRuleContexts<SegmentAttributesClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SegmentAttributesClauseContext segmentAttributesClause(int i) {
			return GetRuleContext<SegmentAttributesClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeyCompressionContext[] keyCompression() {
			return GetRuleContexts<KeyCompressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeyCompressionContext keyCompression(int i) {
			return GetRuleContext<KeyCompressionContext>(i);
		}
		public IndexPartitionDescriptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexPartitionDescription; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIndexPartitionDescription(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIndexPartitionDescription(this);
		}
	}

	[RuleVersion(0)]
	public IndexPartitionDescriptionContext indexPartitionDescription() {
		IndexPartitionDescriptionContext _localctx = new IndexPartitionDescriptionContext(Context, State);
		EnterRule(_localctx, 1598, RULE_indexPartitionDescription);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7367;
			Match(PARTITION);
			State = 7376;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_) | (1L << ACCOUNT) | (1L << ADVANCED) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALLOCATE) | (1L << ALLOW) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << ANYSCHEMA) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << ATTRIBUTES) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGINNING) | (1L << BINARY) | (1L << BITMAP) | (1L << BLOCK) | (1L << BODY) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BUILTIN) | (1L << BULK) | (1L << BULK_EXCEPTIONS) | (1L << BULK_ROWCOUNT) | (1L << BYTE) | (1L << C_) | (1L << CACHE) | (1L << CALL) | (1L << CASCADE) | (1L << CAST) | (1L << CELL_FLASH_CACHE) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHARSET) | (1L << CHR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CHUNK - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLATION - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN_VALUE - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPACT - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPLETE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPUTATION - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONDITIONAL - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (COUNT - 64)) | (1L << (CREATION - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEBUG - 64)) | (1L << (DECODE - 64)) | (1L << (DECRYPT - 64)) | (1L << (DEDUPLICATE - 64)) | (1L << (DEFERRABLE - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEMAND - 64)) | (1L << (DENSE_RANK - 64)) | (1L << (DEPTH - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DETERMINISTIC - 128)) | (1L << (DIRECT_LOAD - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DOUBLE - 128)) | (1L << (DUPLICATED - 128)) | (1L << (EACH - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY_KEYWORD - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENFORCED - 128)) | (1L << (ERROR_CODE - 128)) | (1L << (ERROR_INDEX - 128)) | (1L << (ERROR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALUATE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPIRE - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTENDED - 128)) | (1L << (EXTENT - 128)) | (1L << (EXTERNALLY - 128)) | (1L << (EXTRACT - 128)) | (1L << (FALSE - 128)) | (1L << (FAST - 128)) | (1L << (FILESYSTEM_LIKE_LOGGING - 128)) | (1L << (FINAL - 128)) | (1L << (FIPSFLAG - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_ROWS - 128)) | (1L << (FIXED - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FOREIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (FORMAT - 192)) | (1L << (FOUND - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (HASH - 192)) | (1L << (HEAP - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (ID - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INDEXING - 192)) | (1L << (INDICATOR - 192)) | (1L << (INDICES - 192)) | (1L << (INITIALLY - 192)) | (1L << (INITRANS - 192)) | (1L << (INNER - 192)) | (1L << (INSTANCE - 192)) | (1L << (INSTANTIABLE - 192)) | (1L << (INSTEAD - 192)) | (1L << (INTERFACE - 192)) | (1L << (INTERVAL - 192)) | (1L << (INVALIDATE - 192)) | (1L << (INVALIDATION - 192)) | (1L << (INVISIBLE - 192)) | (1L << (ISOLATION - 192)) | (1L << (ISOPEN - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (JSON - 192)) | (1L << (JSON_TABLE - 192)) | (1L << (KEEP - 192)) | (1L << (KEEP_DUPLICATES - 192)) | (1L << (KEY - 192)) | (1L << (LANGUAGE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (LAST - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIMIT - 256)) | (1L << (LIST - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOG - 256)) | (1L << (LOGGING - 256)) | (1L << (LOGOFF - 256)) | (1L << (LOGON - 256)) | (1L << (LONG - 256)) | (1L << (LOW - 256)) | (1L << (MAP - 256)) | (1L << (MAPPING - 256)) | (1L << (MASTER - 256)) | (1L << (MATCHED - 256)) | (1L << (MATERIALIZED - 256)) | (1L << (MAX - 256)) | (1L << (MAXSIZE - 256)) | (1L << (MAXTRANS - 256)) | (1L << (MAXVALUE - 256)) | (1L << (MEDIUM - 256)) | (1L << (MEMBER - 256)) | (1L << (MEMOPTIMIZE - 256)) | (1L << (MERGE - 256)) | (1L << (METADATA - 256)) | (1L << (MIN - 256)) | (1L << (MINEXTENTS - 256)) | (1L << (MINUTE - 256)) | (1L << (MINVALUE - 256)) | (1L << (MOD - 256)) | (1L << (MONITORING - 256)) | (1L << (MONTH - 256)) | (1L << (MOVEMENT - 256)) | (1L << (MULTISET - 256)) | (1L << (NAME - 256)) | (1L << (NATIONAL - 256)) | (1L << (NATURAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NCHAR_CS - 256)) | (1L << (NCHR - 256)) | (1L << (NESTED - 256)) | (1L << (NEVER - 256)) | (1L << (NEW - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (NEW_NAMES - 320)) | (1L << (NEXT - 320)) | (1L << (NO - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEXTEND - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NOMONITORING - 320)) | (1L << (NOORDER - 320)) | (1L << (NONE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONSCHEMA - 320)) | (1L << (NOPARALLEL - 320)) | (1L << (NORELY - 320)) | (1L << (NOREVERSE - 320)) | (1L << (NOROWDEPENDENCIES - 320)) | (1L << (NOSCALE - 320)) | (1L << (NOSHARD - 320)) | (1L << (NOSORT - 320)) | (1L << (NOTFOUND - 320)) | (1L << (NOVALIDATE - 320)) | (1L << (NULLS - 320)) | (1L << (OBJECT - 320)) | (1L << (OID - 320)) | (1L << (OIDINDEX - 320)) | (1L << (OLD - 320)) | (1L << (ONLY - 320)) | (1L << (ONLINE - 320)) | (1L << (OPAQUE - 320)) | (1L << (OPEN - 320)) | (1L << (OPERATIONS - 320)) | (1L << (OPTIMAL - 320)) | (1L << (ORDINALITY - 320)) | (1L << (ORGANIZATION - 320)) | (1L << (OUT - 320)) | (1L << (OUTER - 320)) | (1L << (OVER - 320)) | (1L << (OVERFLOW - 320)) | (1L << (OVERLAPS - 320)) | (1L << (OVERRIDING - 320)) | (1L << (PACKAGE - 320)) | (1L << (PARALLEL - 320)) | (1L << (PARALLEL_ENABLE - 320)) | (1L << (PARAMETERS - 320)) | (1L << (PARENT - 320)) | (1L << (PARTIAL - 320)) | (1L << (PARTITION - 320)) | (1L << (PARTITIONS - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENTILE_DISC - 384)) | (1L << (PERIOD - 384)) | (1L << (PIPE - 384)) | (1L << (PIPELINED - 384)) | (1L << (POLYMORPHIC - 384)) | (1L << (PRAGMA - 384)) | (1L << (PREBUILT - 384)) | (1L << (PRECEDING - 384)) | (1L << (PRECISION - 384)) | (1L << (PRESERVE - 384)) | (1L << (PRIMARY - 384)) | (1L << (PRIOR - 384)) | (1L << (PRIVATE - 384)) | (1L << (PROCEDURE - 384)) | (1L << (PROFILE - 384)) | (1L << (PUBLIC - 384)) | (1L << (PURGE - 384)) | (1L << (QUERY - 384)) | (1L << (QUOTA - 384)) | (1L << (RAISE - 384)) | (1L << (RAISE_APPLICATION_ERROR - 384)) | (1L << (RANGE - 384)) | (1L << (RAW - 384)) | (1L << (READ - 384)) | (1L << (READS - 384)) | (1L << (REBUILD - 384)) | (1L << (RECORD - 384)) | (1L << (RECYCLE - 384)) | (1L << (REDUCED - 384)) | (1L << (REF - 384)) | (1L << (REFERENCES - 384)) | (1L << (REFERENCING - 384)) | (1L << (REFRESH - 384)) | (1L << (REJECT - 384)) | (1L << (RELATIONAL - 384)) | (1L << (RELIES_ON - 384)) | (1L << (RELY - 384)) | (1L << (RENAME - 384)) | (1L << (REPLACE - 384)) | (1L << (RESTRICT_REFERENCES - 384)) | (1L << (RESULT - 384)) | (1L << (RESULT_CACHE - 384)) | (1L << (RETENTION - 384)) | (1L << (RETURNING - 384)) | (1L << (REUSE - 384)) | (1L << (REVERSE - 384)) | (1L << (REWRITE - 384)) | (1L << (RIGHT - 384)) | (1L << (ROLLUP - 384)) | (1L << (ROW - 384)) | (1L << (ROWCOUNT - 384)) | (1L << (ROWDEPENDENCIES - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ROWID - 448)) | (1L << (ROWTYPE - 448)) | (1L << (SALT - 448)) | (1L << (SAMPLE - 448)) | (1L << (SAVE - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (SCALE - 448)) | (1L << (SCHEMA - 448)) | (1L << (SCN - 448)) | (1L << (SCOPE - 448)) | (1L << (SEARCH - 448)) | (1L << (SECOND - 448)) | (1L << (SECUREFILE - 448)) | (1L << (SEED - 448)) | (1L << (SEGMENT - 448)) | (1L << (SELF - 448)) | (1L << (SEQUENCE - 448)) | (1L << (SERIALIZABLE - 448)) | (1L << (SERIALLY_REUSABLE - 448)) | (1L << (SERVERERROR - 448)) | (1L << (SESSION - 448)) | (1L << (SESSIONTIMEZONE - 448)) | (1L << (SET - 448)) | (1L << (SETS - 448)) | (1L << (SETTINGS - 448)) | (1L << (SHRINK - 448)) | (1L << (SHUTDOWN - 448)) | (1L << (SIBLINGS - 448)) | (1L << (SIZE - 448)) | (1L << (SKIP_ - 448)) | (1L << (SOME - 448)) | (1L << (SORT - 448)) | (1L << (SPACE - 448)) | (1L << (SPECIFICATION - 448)) | (1L << (SPLIT - 448)) | (1L << (STARTUP - 448)) | (1L << (STATEMENT - 448)) | (1L << (STATIC - 448)) | (1L << (STATISTICS - 448)) | (1L << (STORAGE - 448)) | (1L << (STORE - 448)) | (1L << (STRING - 448)) | (1L << (SHARD - 448)) | (1L << (SHARDED - 448)) | (1L << (SHARING - 448)) | (1L << (SUBMULTISET - 448)) | (1L << (SUBPARTITION - 448)) | (1L << (SUBPARTITIONS - 448)) | (1L << (SUBSTITUTABLE - 448)) | (1L << (SUBTYPE - 448)) | (1L << (SUPPLEMENTAL - 448)) | (1L << (SUSPEND - 448)) | (1L << (SYNONYM - 448)) | (1L << (SYSTEM - 448)) | (1L << (TABLES - 448)) | (1L << (TABLESPACE - 448)) | (1L << (TEMPLATE - 448)) | (1L << (TEMPORARY - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (THAN - 512)) | (1L << (TIME - 512)) | (1L << (TIMESTAMP - 512)) | (1L << (TIMEZONE_ABBR - 512)) | (1L << (TIMEZONE_HOUR - 512)) | (1L << (TIMEZONE_MINUTE - 512)) | (1L << (TIMEZONE_REGION - 512)) | (1L << (TRAILING - 512)) | (1L << (TRANSACTION - 512)) | (1L << (TRANSLATE - 512)) | (1L << (TREAT - 512)) | (1L << (TRIM - 512)) | (1L << (TRUE - 512)) | (1L << (TRUNCATE - 512)) | (1L << (TRUSTED - 512)) | (1L << (TYPE - 512)) | (1L << (UNBOUNDED - 512)) | (1L << (UNCONDITIONAL - 512)) | (1L << (UNDER - 512)) | (1L << (UNLIMITED - 512)) | (1L << (UNLOCK - 512)) | (1L << (UNUSABLE - 512)) | (1L << (UNUSED - 512)) | (1L << (USABLE - 512)) | (1L << (USAGE - 512)) | (1L << (USE - 512)) | (1L << (USER - 512)) | (1L << (USING - 512)) | (1L << (VALIDATE - 512)) | (1L << (VALUE - 512)) | (1L << (VARCHAR - 512)) | (1L << (VARCHAR2 - 512)) | (1L << (VARRAY - 512)) | (1L << (VARRAYS - 512)) | (1L << (VARYING - 512)) | (1L << (VERSIONS - 512)) | (1L << (VIRTUAL - 512)) | (1L << (VISIBLE - 512)) | (1L << (WAIT - 512)) | (1L << (WHEN - 512)) | (1L << (WITHIN - 512)) | (1L << (WITHOUT - 512)) | (1L << (WORK - 512)) | (1L << (WRAPPED - 512)) | (1L << (WRAPPER - 512)) | (1L << (WRITE - 512)) | (1L << (XML - 512)) | (1L << (XMLNAMESPACES - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (XMLSCHEMA - 576)) | (1L << (XMLTABLE - 576)) | (1L << (XMLTYPE - 576)) | (1L << (YEAR - 576)) | (1L << (ZONE - 576)) | (1L << (REGULAR_IDENTIFIER - 576)) | (1L << (QUOTED_IDENTIFIER - 576)))) != 0)) {
				{
				State = 7368;
				simpleIdentifierWithoutParentheses();
				State = 7373;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 277)) & ~0x3f) == 0 && ((1L << (_la - 277)) & ((1L << (LOGGING - 277)) | (1L << (MAXTRANS - 277)) | (1L << (NOCOMPRESS - 277)) | (1L << (NOLOGGING - 277)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
					{
					State = 7371;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case FILESYSTEM_LIKE_LOGGING:
					case INITRANS:
					case LOGGING:
					case MAXTRANS:
					case NOLOGGING:
					case PCTFREE:
					case PCTUSED:
					case STORAGE:
					case TABLESPACE:
						{
						State = 7369;
						segmentAttributesClause();
						}
						break;
					case COMPRESS:
					case NOCOMPRESS:
						{
						State = 7370;
						keyCompression();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 7375;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModifyIndexSubpartitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MODIFY() { return GetToken(OracleAntlrParser.MODIFY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBPARTITION() { return GetToken(OracleAntlrParser.SUBPARTITION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNUSABLE() { return GetToken(OracleAntlrParser.UNUSABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AllocateExtentClauseContext allocateExtentClause() {
			return GetRuleContext<AllocateExtentClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeallocateUnusedClauseContext deallocateUnusedClause() {
			return GetRuleContext<DeallocateUnusedClauseContext>(0);
		}
		public ModifyIndexSubpartitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifyIndexSubpartition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterModifyIndexSubpartition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitModifyIndexSubpartition(this);
		}
	}

	[RuleVersion(0)]
	public ModifyIndexSubpartitionContext modifyIndexSubpartition() {
		ModifyIndexSubpartitionContext _localctx = new ModifyIndexSubpartitionContext(Context, State);
		EnterRule(_localctx, 1600, RULE_modifyIndexSubpartition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7378;
			Match(MODIFY);
			State = 7379;
			Match(SUBPARTITION);
			State = 7380;
			simpleIdentifierWithoutParentheses();
			State = 7384;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNUSABLE:
				{
				State = 7381;
				Match(UNUSABLE);
				}
				break;
			case ALLOCATE:
				{
				State = 7382;
				allocateExtentClause();
				}
				break;
			case DEALLOCATE:
				{
				State = 7383;
				deallocateUnusedClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompileTypeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPILE() { return GetToken(OracleAntlrParser.COMPILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEBUG() { return GetToken(OracleAntlrParser.DEBUG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CompilerParametersClauseContext compilerParametersClause() {
			return GetRuleContext<CompilerParametersClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REUSE() { return GetToken(OracleAntlrParser.REUSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETTINGS() { return GetToken(OracleAntlrParser.SETTINGS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SPECIFICATION() { return GetToken(OracleAntlrParser.SPECIFICATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BODY() { return GetToken(OracleAntlrParser.BODY, 0); }
		public CompileTypeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compileTypeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCompileTypeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCompileTypeClause(this);
		}
	}

	[RuleVersion(0)]
	public CompileTypeClauseContext compileTypeClause() {
		CompileTypeClauseContext _localctx = new CompileTypeClauseContext(Context, State);
		EnterRule(_localctx, 1602, RULE_compileTypeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7386;
			Match(COMPILE);
			State = 7388;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,850,Context) ) {
			case 1:
				{
				State = 7387;
				Match(DEBUG);
				}
				break;
			}
			State = 7391;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,851,Context) ) {
			case 1:
				{
				State = 7390;
				_la = TokenStream.LA(1);
				if ( !(_la==BODY || _la==SPECIFICATION) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 7394;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,852,Context) ) {
			case 1:
				{
				State = 7393;
				compilerParametersClause();
				}
				break;
			}
			State = 7398;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REUSE) {
				{
				State = 7396;
				Match(REUSE);
				State = 7397;
				Match(SETTINGS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompilerParametersClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullExpressionContext fullExpression() {
			return GetRuleContext<FullExpressionContext>(0);
		}
		public CompilerParametersClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compilerParametersClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCompilerParametersClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCompilerParametersClause(this);
		}
	}

	[RuleVersion(0)]
	public CompilerParametersClauseContext compilerParametersClause() {
		CompilerParametersClauseContext _localctx = new CompilerParametersClauseContext(Context, State);
		EnterRule(_localctx, 1604, RULE_compilerParametersClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7400;
			simpleIdentifierWithoutParentheses();
			State = 7401;
			Match(EQUAL_SIGN);
			State = 7402;
			fullExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReplaceTypeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPLACE() { return GetToken(OracleAntlrParser.REPLACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeStatementContext objectTypeStatement() {
			return GetRuleContext<ObjectTypeStatementContext>(0);
		}
		public ReplaceTypeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_replaceTypeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterReplaceTypeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitReplaceTypeClause(this);
		}
	}

	[RuleVersion(0)]
	public ReplaceTypeClauseContext replaceTypeClause() {
		ReplaceTypeClauseContext _localctx = new ReplaceTypeClauseContext(Context, State);
		EnterRule(_localctx, 1606, RULE_replaceTypeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7404;
			Match(REPLACE);
			State = 7405;
			objectTypeStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterMethodSpecificationsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AlterMethodSpecificationContext[] alterMethodSpecification() {
			return GetRuleContexts<AlterMethodSpecificationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterMethodSpecificationContext alterMethodSpecification(int i) {
			return GetRuleContext<AlterMethodSpecificationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public AlterMethodSpecificationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterMethodSpecifications; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlterMethodSpecifications(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlterMethodSpecifications(this);
		}
	}

	[RuleVersion(0)]
	public AlterMethodSpecificationsContext alterMethodSpecifications() {
		AlterMethodSpecificationsContext _localctx = new AlterMethodSpecificationsContext(Context, State);
		EnterRule(_localctx, 1608, RULE_alterMethodSpecifications);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7407;
			alterMethodSpecification();
			State = 7412;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 7408;
				Match(COMMA);
				State = 7409;
				alterMethodSpecification();
				}
				}
				State = 7414;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterMethodSpecificationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADD() { return GetToken(OracleAntlrParser.ADD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(OracleAntlrParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeMapOrderFunctionContext objectTypeMapOrderFunction() {
			return GetRuleContext<ObjectTypeMapOrderFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeMemberStaticRoutineContext objectTypeMemberStaticRoutine() {
			return GetRuleContext<ObjectTypeMemberStaticRoutineContext>(0);
		}
		public AlterMethodSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterMethodSpecification; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlterMethodSpecification(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlterMethodSpecification(this);
		}
	}

	[RuleVersion(0)]
	public AlterMethodSpecificationContext alterMethodSpecification() {
		AlterMethodSpecificationContext _localctx = new AlterMethodSpecificationContext(Context, State);
		EnterRule(_localctx, 1610, RULE_alterMethodSpecification);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7415;
			_la = TokenStream.LA(1);
			if ( !(_la==ADD || _la==DROP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 7418;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MAP:
			case ORDER:
				{
				State = 7416;
				objectTypeMapOrderFunction();
				}
				break;
			case MEMBER:
			case STATIC:
				{
				State = 7417;
				objectTypeMemberStaticRoutine();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterAttributeDefinitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AddOrModifyAttributeDefinitionContext addOrModifyAttributeDefinition() {
			return GetRuleContext<AddOrModifyAttributeDefinitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropAttributeDefinitionContext dropAttributeDefinition() {
			return GetRuleContext<DropAttributeDefinitionContext>(0);
		}
		public AlterAttributeDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterAttributeDefinition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlterAttributeDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlterAttributeDefinition(this);
		}
	}

	[RuleVersion(0)]
	public AlterAttributeDefinitionContext alterAttributeDefinition() {
		AlterAttributeDefinitionContext _localctx = new AlterAttributeDefinitionContext(Context, State);
		EnterRule(_localctx, 1612, RULE_alterAttributeDefinition);
		try {
			State = 7422;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ADD:
			case MODIFY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7420;
				addOrModifyAttributeDefinition();
				}
				break;
			case DROP:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7421;
				dropAttributeDefinition();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddOrModifyAttributeDefinitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ATTRIBUTE() { return GetToken(OracleAntlrParser.ATTRIBUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADD() { return GetToken(OracleAntlrParser.ADD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MODIFY() { return GetToken(OracleAntlrParser.MODIFY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AlterTypeDeclarationContext alterTypeDeclaration() {
			return GetRuleContext<AlterTypeDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterTypeDeclarationInParenContext alterTypeDeclarationInParen() {
			return GetRuleContext<AlterTypeDeclarationInParenContext>(0);
		}
		public AddOrModifyAttributeDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addOrModifyAttributeDefinition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAddOrModifyAttributeDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAddOrModifyAttributeDefinition(this);
		}
	}

	[RuleVersion(0)]
	public AddOrModifyAttributeDefinitionContext addOrModifyAttributeDefinition() {
		AddOrModifyAttributeDefinitionContext _localctx = new AddOrModifyAttributeDefinitionContext(Context, State);
		EnterRule(_localctx, 1614, RULE_addOrModifyAttributeDefinition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7424;
			_la = TokenStream.LA(1);
			if ( !(_la==ADD || _la==MODIFY) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 7425;
			Match(ATTRIBUTE);
			State = 7428;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case A_:
			case ACCOUNT:
			case ADVANCED:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALLOCATE:
			case ALLOW:
			case ALWAYS:
			case ANALYZE:
			case ANYSCHEMA:
			case ARCHIVE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case ATTRIBUTES:
			case AUTHENTICATION:
			case AUTHID:
			case AUTO:
			case AUTONOMOUS_TRANSACTION:
			case BASIC:
			case BASICFILE:
			case BATCH:
			case BEFORE:
			case BEGINNING:
			case BINARY:
			case BITMAP:
			case BLOCK:
			case BODY:
			case BOTH:
			case BREADTH:
			case BUFFER_POOL:
			case BUILD:
			case BUILTIN:
			case BULK:
			case BULK_EXCEPTIONS:
			case BULK_ROWCOUNT:
			case BYTE:
			case C_:
			case CACHE:
			case CALL:
			case CASCADE:
			case CAST:
			case CELL_FLASH_CACHE:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHARSET:
			case CHR:
			case CHUNK:
			case CLOB:
			case CLOSE:
			case COALESCE:
			case COLLATION:
			case COLLECT:
			case COLUMN_VALUE:
			case COMMIT:
			case COMMITTED:
			case COMPACT:
			case COMPILE:
			case COMPLETE:
			case COMPOUND:
			case COMPUTATION:
			case COMPUTE:
			case CONDITIONAL:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTAINER:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case COUNT:
			case CREATION:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATAFILE:
			case DATE:
			case DAY:
			case DBTIMEZONE:
			case DDL:
			case DEALLOCATE:
			case DEBUG:
			case DECODE:
			case DECRYPT:
			case DEDUPLICATE:
			case DEFERRABLE:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEMAND:
			case DENSE_RANK:
			case DEPTH:
			case DETERMINISTIC:
			case DIRECT_LOAD:
			case DISABLE:
			case DISALLOW:
			case DISASSOCIATE:
			case DOUBLE:
			case DUPLICATED:
			case EACH:
			case EDITION:
			case EDITIONABLE:
			case EDITIONING:
			case EDITIONS:
			case ELEMENT:
			case ELSIF:
			case EMPTY_KEYWORD:
			case ENABLE:
			case ENCRYPT:
			case ENFORCED:
			case ERROR_CODE:
			case ERROR_INDEX:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVALUATE:
			case EXCEPT:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPIRE:
			case EXTEND:
			case EXTENDED:
			case EXTENT:
			case EXTERNALLY:
			case EXTRACT:
			case FALSE:
			case FAST:
			case FILESYSTEM_LIKE_LOGGING:
			case FINAL:
			case FIPSFLAG:
			case FIRST:
			case FIRST_ROWS:
			case FIXED:
			case FOLLOWING:
			case FORALL:
			case FORCE:
			case FOREIGN:
			case FORMAT:
			case FOUND:
			case FLASH_CACHE:
			case FREELIST:
			case FREELISTS:
			case FREEPOOLS:
			case FULL:
			case FUNCTION:
			case GENERATED:
			case GLOBAL:
			case GLOBALLY:
			case GROUPING:
			case GROUPS:
			case HASH:
			case HEAP:
			case HIGH:
			case HOUR:
			case ID:
			case IDENTIFIER:
			case IDENTITY:
			case INCLUDE:
			case INCLUDING:
			case INDEXING:
			case INDICATOR:
			case INDICES:
			case INITIALLY:
			case INITRANS:
			case INNER:
			case INSTANCE:
			case INSTANTIABLE:
			case INSTEAD:
			case INTERFACE:
			case INTERVAL:
			case INVALIDATE:
			case INVALIDATION:
			case INVISIBLE:
			case ISOLATION:
			case ISOPEN:
			case JAVA:
			case JOIN:
			case JSON:
			case JSON_TABLE:
			case KEEP:
			case KEEP_DUPLICATES:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LEADING:
			case LEFT:
			case LESS:
			case LEVEL:
			case LEVELS:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LIST:
			case LOB:
			case LOBS:
			case LOCAL:
			case LOCATOR:
			case LOCKED:
			case LOCKING:
			case LOG:
			case LOGGING:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOW:
			case MAP:
			case MAPPING:
			case MASTER:
			case MATCHED:
			case MATERIALIZED:
			case MAX:
			case MAXSIZE:
			case MAXTRANS:
			case MAXVALUE:
			case MEDIUM:
			case MEMBER:
			case MEMOPTIMIZE:
			case MERGE:
			case METADATA:
			case MIN:
			case MINEXTENTS:
			case MINUTE:
			case MINVALUE:
			case MOD:
			case MONITORING:
			case MONTH:
			case MOVEMENT:
			case MULTISET:
			case NAME:
			case NATIONAL:
			case NATURAL:
			case NCHAR:
			case NCHAR_CS:
			case NCHR:
			case NESTED:
			case NEVER:
			case NEW:
			case NEW_NAMES:
			case NEXT:
			case NO:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOEXTEND:
			case NOKEEP:
			case NOLOGGING:
			case NOMAPPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NOMONITORING:
			case NOORDER:
			case NONE:
			case NONEDITIONABLE:
			case NONSCHEMA:
			case NOPARALLEL:
			case NORELY:
			case NOREVERSE:
			case NOROWDEPENDENCIES:
			case NOSCALE:
			case NOSHARD:
			case NOSORT:
			case NOTFOUND:
			case NOVALIDATE:
			case NULLS:
			case OBJECT:
			case OID:
			case OIDINDEX:
			case OLD:
			case ONLY:
			case ONLINE:
			case OPAQUE:
			case OPEN:
			case OPERATIONS:
			case OPTIMAL:
			case ORDINALITY:
			case ORGANIZATION:
			case OUT:
			case OUTER:
			case OVER:
			case OVERFLOW:
			case OVERLAPS:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTIAL:
			case PARTITION:
			case PARTITIONS:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PCTINCREASE:
			case PCTTHRESHOLD:
			case PCTUSED:
			case PCTVERSION:
			case PERCENTILE_DISC:
			case PERIOD:
			case PIPE:
			case PIPELINED:
			case POLYMORPHIC:
			case PRAGMA:
			case PREBUILT:
			case PRECEDING:
			case PRECISION:
			case PRESERVE:
			case PRIMARY:
			case PRIOR:
			case PRIVATE:
			case PROCEDURE:
			case PROFILE:
			case PUBLIC:
			case PURGE:
			case QUERY:
			case QUOTA:
			case RAISE:
			case RAISE_APPLICATION_ERROR:
			case RANGE:
			case RAW:
			case READ:
			case READS:
			case REBUILD:
			case RECORD:
			case RECYCLE:
			case REDUCED:
			case REF:
			case REFERENCES:
			case REFERENCING:
			case REFRESH:
			case REJECT:
			case RELATIONAL:
			case RELIES_ON:
			case RELY:
			case RENAME:
			case REPLACE:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETENTION:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REWRITE:
			case RIGHT:
			case ROLLUP:
			case ROW:
			case ROWCOUNT:
			case ROWDEPENDENCIES:
			case ROWID:
			case ROWTYPE:
			case SALT:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCALE:
			case SCHEMA:
			case SCN:
			case SCOPE:
			case SEARCH:
			case SECOND:
			case SECUREFILE:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSION:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHRINK:
			case SHUTDOWN:
			case SIBLINGS:
			case SIZE:
			case SKIP_:
			case SOME:
			case SORT:
			case SPACE:
			case SPECIFICATION:
			case SPLIT:
			case STARTUP:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORAGE:
			case STORE:
			case STRING:
			case SHARD:
			case SHARDED:
			case SHARING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUPPLEMENTAL:
			case SUSPEND:
			case SYNONYM:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMPLATE:
			case TEMPORARY:
			case THAN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case UNBOUNDED:
			case UNCONDITIONAL:
			case UNDER:
			case UNLIMITED:
			case UNLOCK:
			case UNUSABLE:
			case UNUSED:
			case USABLE:
			case USAGE:
			case USE:
			case USER:
			case USING:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARRAY:
			case VARRAYS:
			case VARYING:
			case VERSIONS:
			case VIRTUAL:
			case VISIBLE:
			case WAIT:
			case WHEN:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPED:
			case WRAPPER:
			case WRITE:
			case XML:
			case XMLNAMESPACES:
			case XMLSCHEMA:
			case XMLTABLE:
			case XMLTYPE:
			case YEAR:
			case ZONE:
			case REGULAR_IDENTIFIER:
			case QUOTED_IDENTIFIER:
				{
				State = 7426;
				alterTypeDeclaration();
				}
				break;
			case LPAREN:
				{
				State = 7427;
				alterTypeDeclarationInParen();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTypeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public AlterTypeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTypeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlterTypeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlterTypeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public AlterTypeDeclarationContext alterTypeDeclaration() {
		AlterTypeDeclarationContext _localctx = new AlterTypeDeclarationContext(Context, State);
		EnterRule(_localctx, 1616, RULE_alterTypeDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7430;
			simpleIdentifier();
			State = 7432;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,858,Context) ) {
			case 1:
				{
				State = 7431;
				typeReference();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTypeDeclarationInParenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeAttributeDeclarationContext[] objectTypeAttributeDeclaration() {
			return GetRuleContexts<ObjectTypeAttributeDeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeAttributeDeclarationContext objectTypeAttributeDeclaration(int i) {
			return GetRuleContext<ObjectTypeAttributeDeclarationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public AlterTypeDeclarationInParenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTypeDeclarationInParen; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlterTypeDeclarationInParen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlterTypeDeclarationInParen(this);
		}
	}

	[RuleVersion(0)]
	public AlterTypeDeclarationInParenContext alterTypeDeclarationInParen() {
		AlterTypeDeclarationInParenContext _localctx = new AlterTypeDeclarationInParenContext(Context, State);
		EnterRule(_localctx, 1618, RULE_alterTypeDeclarationInParen);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7434;
			Match(LPAREN);
			State = 7435;
			objectTypeAttributeDeclaration();
			State = 7440;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 7436;
				Match(COMMA);
				State = 7437;
				objectTypeAttributeDeclaration();
				}
				}
				State = 7442;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 7443;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropAttributeDefinitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(OracleAntlrParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ATTRIBUTE() { return GetToken(OracleAntlrParser.ATTRIBUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierWithoutParenthesesContext simpleIdentifierWithoutParentheses() {
			return GetRuleContext<SimpleIdentifierWithoutParenthesesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnListInParenElementClauseContext columnListInParenElementClause() {
			return GetRuleContext<ColumnListInParenElementClauseContext>(0);
		}
		public DropAttributeDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropAttributeDefinition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDropAttributeDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDropAttributeDefinition(this);
		}
	}

	[RuleVersion(0)]
	public DropAttributeDefinitionContext dropAttributeDefinition() {
		DropAttributeDefinitionContext _localctx = new DropAttributeDefinitionContext(Context, State);
		EnterRule(_localctx, 1620, RULE_dropAttributeDefinition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7445;
			Match(DROP);
			State = 7446;
			Match(ATTRIBUTE);
			State = 7447;
			simpleIdentifierWithoutParentheses();
			State = 7448;
			columnListInParenElementClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterCollectionClausesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MODIFY() { return GetToken(OracleAntlrParser.MODIFY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIMIT() { return GetToken(OracleAntlrParser.LIMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELEMENT() { return GetToken(OracleAntlrParser.ELEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public AlterCollectionClausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterCollectionClauses; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlterCollectionClauses(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlterCollectionClauses(this);
		}
	}

	[RuleVersion(0)]
	public AlterCollectionClausesContext alterCollectionClauses() {
		AlterCollectionClausesContext _localctx = new AlterCollectionClausesContext(Context, State);
		EnterRule(_localctx, 1622, RULE_alterCollectionClauses);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7450;
			Match(MODIFY);
			State = 7456;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LIMIT:
				{
				State = 7451;
				Match(LIMIT);
				State = 7452;
				literal();
				}
				break;
			case ELEMENT:
				{
				State = 7453;
				Match(ELEMENT);
				State = 7454;
				Match(TYPE);
				State = 7455;
				typeReference();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DependentHandlingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public InvalidateHandlingClauseContext invalidateHandlingClause() {
			return GetRuleContext<InvalidateHandlingClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CascadeHandlingClauseContext cascadeHandlingClause() {
			return GetRuleContext<CascadeHandlingClauseContext>(0);
		}
		public DependentHandlingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dependentHandlingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDependentHandlingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDependentHandlingClause(this);
		}
	}

	[RuleVersion(0)]
	public DependentHandlingClauseContext dependentHandlingClause() {
		DependentHandlingClauseContext _localctx = new DependentHandlingClauseContext(Context, State);
		EnterRule(_localctx, 1624, RULE_dependentHandlingClause);
		try {
			State = 7460;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INVALIDATE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7458;
				invalidateHandlingClause();
				}
				break;
			case CASCADE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7459;
				cascadeHandlingClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InvalidateHandlingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALIDATE() { return GetToken(OracleAntlrParser.INVALIDATE, 0); }
		public InvalidateHandlingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_invalidateHandlingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterInvalidateHandlingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitInvalidateHandlingClause(this);
		}
	}

	[RuleVersion(0)]
	public InvalidateHandlingClauseContext invalidateHandlingClause() {
		InvalidateHandlingClauseContext _localctx = new InvalidateHandlingClauseContext(Context, State);
		EnterRule(_localctx, 1626, RULE_invalidateHandlingClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7462;
			Match(INVALIDATE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CascadeHandlingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASCADE() { return GetToken(OracleAntlrParser.CASCADE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DependentTypesClauseContext dependentTypesClause() {
			return GetRuleContext<DependentTypesClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForceExceptionsClauseContext forceExceptionsClause() {
			return GetRuleContext<ForceExceptionsClauseContext>(0);
		}
		public CascadeHandlingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cascadeHandlingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCascadeHandlingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCascadeHandlingClause(this);
		}
	}

	[RuleVersion(0)]
	public CascadeHandlingClauseContext cascadeHandlingClause() {
		CascadeHandlingClauseContext _localctx = new CascadeHandlingClauseContext(Context, State);
		EnterRule(_localctx, 1628, RULE_cascadeHandlingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7464;
			Match(CASCADE);
			State = 7466;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONVERT || _la==INCLUDING || _la==NOT) {
				{
				State = 7465;
				dependentTypesClause();
				}
			}

			State = 7469;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXCEPTIONS || _la==FORCE) {
				{
				State = 7468;
				forceExceptionsClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DependentTypesClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IncludingTableDataContext includingTableData() {
			return GetRuleContext<IncludingTableDataContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConvertToSubstitutableContext convertToSubstitutable() {
			return GetRuleContext<ConvertToSubstitutableContext>(0);
		}
		public DependentTypesClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dependentTypesClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterDependentTypesClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitDependentTypesClause(this);
		}
	}

	[RuleVersion(0)]
	public DependentTypesClauseContext dependentTypesClause() {
		DependentTypesClauseContext _localctx = new DependentTypesClauseContext(Context, State);
		EnterRule(_localctx, 1630, RULE_dependentTypesClause);
		try {
			State = 7473;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INCLUDING:
			case NOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7471;
				includingTableData();
				}
				break;
			case CONVERT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7472;
				convertToSubstitutable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IncludingTableDataContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDING() { return GetToken(OracleAntlrParser.INCLUDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TABLE() { return GetToken(OracleAntlrParser.TABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATA() { return GetToken(OracleAntlrParser.DATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public IncludingTableDataContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_includingTableData; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIncludingTableData(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIncludingTableData(this);
		}
	}

	[RuleVersion(0)]
	public IncludingTableDataContext includingTableData() {
		IncludingTableDataContext _localctx = new IncludingTableDataContext(Context, State);
		EnterRule(_localctx, 1632, RULE_includingTableData);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7476;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 7475;
				Match(NOT);
				}
			}

			State = 7478;
			Match(INCLUDING);
			State = 7479;
			Match(TABLE);
			State = 7480;
			Match(DATA);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConvertToSubstitutableContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONVERT() { return GetToken(OracleAntlrParser.CONVERT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(OracleAntlrParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBSTITUTABLE() { return GetToken(OracleAntlrParser.SUBSTITUTABLE, 0); }
		public ConvertToSubstitutableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_convertToSubstitutable; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConvertToSubstitutable(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConvertToSubstitutable(this);
		}
	}

	[RuleVersion(0)]
	public ConvertToSubstitutableContext convertToSubstitutable() {
		ConvertToSubstitutableContext _localctx = new ConvertToSubstitutableContext(Context, State);
		EnterRule(_localctx, 1634, RULE_convertToSubstitutable);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7482;
			Match(CONVERT);
			State = 7483;
			Match(TO);
			State = 7484;
			Match(SUBSTITUTABLE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForceExceptionsClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExceptionsIntoConstraintClauseContext exceptionsIntoConstraintClause() {
			return GetRuleContext<ExceptionsIntoConstraintClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORCE() { return GetToken(OracleAntlrParser.FORCE, 0); }
		public ForceExceptionsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forceExceptionsClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterForceExceptionsClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitForceExceptionsClause(this);
		}
	}

	[RuleVersion(0)]
	public ForceExceptionsClauseContext forceExceptionsClause() {
		ForceExceptionsClauseContext _localctx = new ForceExceptionsClauseContext(Context, State);
		EnterRule(_localctx, 1636, RULE_forceExceptionsClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7487;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FORCE) {
				{
				State = 7486;
				Match(FORCE);
				}
			}

			State = 7489;
			exceptionsIntoConstraintClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterSequenceStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEQUENCE() { return GetToken(OracleAntlrParser.SEQUENCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceOptionContext[] sequenceOption() {
			return GetRuleContexts<SequenceOptionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceOptionContext sequenceOption(int i) {
			return GetRuleContext<SequenceOptionContext>(i);
		}
		public AlterSequenceStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterSequenceStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlterSequenceStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlterSequenceStatement(this);
		}
	}

	[RuleVersion(0)]
	public AlterSequenceStatementContext alterSequenceStatement() {
		AlterSequenceStatementContext _localctx = new AlterSequenceStatementContext(Context, State);
		EnterRule(_localctx, 1638, RULE_alterSequenceStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7491;
			Match(SEQUENCE);
			State = 7492;
			plainIdentifier();
			State = 7494;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 7493;
				sequenceOption();
				}
				}
				State = 7496;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==CACHE || _la==CYCLE || ((((_la - 202)) & ~0x3f) == 0 && ((1L << (_la - 202)) & ((1L << (GLOBAL - 202)) | (1L << (INCREMENT - 202)) | (1L << (KEEP - 202)))) != 0) || ((((_la - 292)) & ~0x3f) == 0 && ((1L << (_la - 292)) & ((1L << (MAXVALUE - 292)) | (1L << (MINVALUE - 292)) | (1L << (NOCACHE - 292)) | (1L << (NOCYCLE - 292)) | (1L << (NOKEEP - 292)) | (1L << (NOMAXVALUE - 292)) | (1L << (NOMINVALUE - 292)) | (1L << (NOORDER - 292)) | (1L << (NOSCALE - 292)) | (1L << (NOSHARD - 292)))) != 0) || _la==ORDER || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (SCALE - 455)) | (1L << (SESSION - 455)) | (1L << (START - 455)) | (1L << (SHARD - 455)))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SequenceIncrementClauseContext sequenceIncrementClause() {
			return GetRuleContext<SequenceIncrementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceStartWithClauseContext sequenceStartWithClause() {
			return GetRuleContext<SequenceStartWithClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceMaxValueClauseContext sequenceMaxValueClause() {
			return GetRuleContext<SequenceMaxValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceMinValueClauseContext sequenceMinValueClause() {
			return GetRuleContext<SequenceMinValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceCycleClauseContext sequenceCycleClause() {
			return GetRuleContext<SequenceCycleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceCacheClauseContext sequenceCacheClause() {
			return GetRuleContext<SequenceCacheClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceOrderClauseContext sequenceOrderClause() {
			return GetRuleContext<SequenceOrderClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceScaleClauseContext sequenceScaleClause() {
			return GetRuleContext<SequenceScaleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceKeepClauseContext sequenceKeepClause() {
			return GetRuleContext<SequenceKeepClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceShardClauseContext sequenceShardClause() {
			return GetRuleContext<SequenceShardClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceScopeClauseContext sequenceScopeClause() {
			return GetRuleContext<SequenceScopeClauseContext>(0);
		}
		public SequenceOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSequenceOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSequenceOption(this);
		}
	}

	[RuleVersion(0)]
	public SequenceOptionContext sequenceOption() {
		SequenceOptionContext _localctx = new SequenceOptionContext(Context, State);
		EnterRule(_localctx, 1640, RULE_sequenceOption);
		try {
			State = 7509;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INCREMENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7498;
				sequenceIncrementClause();
				}
				break;
			case START:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7499;
				sequenceStartWithClause();
				}
				break;
			case MAXVALUE:
			case NOMAXVALUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7500;
				sequenceMaxValueClause();
				}
				break;
			case MINVALUE:
			case NOMINVALUE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7501;
				sequenceMinValueClause();
				}
				break;
			case CYCLE:
			case NOCYCLE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7502;
				sequenceCycleClause();
				}
				break;
			case CACHE:
			case NOCACHE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 7503;
				sequenceCacheClause();
				}
				break;
			case NOORDER:
			case ORDER:
				EnterOuterAlt(_localctx, 7);
				{
				State = 7504;
				sequenceOrderClause();
				}
				break;
			case NOSCALE:
			case SCALE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 7505;
				sequenceScaleClause();
				}
				break;
			case KEEP:
			case NOKEEP:
				EnterOuterAlt(_localctx, 9);
				{
				State = 7506;
				sequenceKeepClause();
				}
				break;
			case NOSHARD:
			case SHARD:
				EnterOuterAlt(_localctx, 10);
				{
				State = 7507;
				sequenceShardClause();
				}
				break;
			case GLOBAL:
			case SESSION:
				EnterOuterAlt(_localctx, 11);
				{
				State = 7508;
				sequenceScopeClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentityOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SequenceIncrementClauseContext sequenceIncrementClause() {
			return GetRuleContext<SequenceIncrementClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceStartWithClauseContext sequenceStartWithClause() {
			return GetRuleContext<SequenceStartWithClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceMaxValueClauseContext sequenceMaxValueClause() {
			return GetRuleContext<SequenceMaxValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceMinValueClauseContext sequenceMinValueClause() {
			return GetRuleContext<SequenceMinValueClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceCycleClauseContext sequenceCycleClause() {
			return GetRuleContext<SequenceCycleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceCacheClauseContext sequenceCacheClause() {
			return GetRuleContext<SequenceCacheClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceOrderClauseContext sequenceOrderClause() {
			return GetRuleContext<SequenceOrderClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceScaleClauseContext sequenceScaleClause() {
			return GetRuleContext<SequenceScaleClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SequenceKeepClauseContext sequenceKeepClause() {
			return GetRuleContext<SequenceKeepClauseContext>(0);
		}
		public IdentityOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identityOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterIdentityOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitIdentityOption(this);
		}
	}

	[RuleVersion(0)]
	public IdentityOptionContext identityOption() {
		IdentityOptionContext _localctx = new IdentityOptionContext(Context, State);
		EnterRule(_localctx, 1642, RULE_identityOption);
		try {
			State = 7520;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INCREMENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7511;
				sequenceIncrementClause();
				}
				break;
			case START:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7512;
				sequenceStartWithClause();
				}
				break;
			case MAXVALUE:
			case NOMAXVALUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7513;
				sequenceMaxValueClause();
				}
				break;
			case MINVALUE:
			case NOMINVALUE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7514;
				sequenceMinValueClause();
				}
				break;
			case CYCLE:
			case NOCYCLE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7515;
				sequenceCycleClause();
				}
				break;
			case CACHE:
			case NOCACHE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 7516;
				sequenceCacheClause();
				}
				break;
			case NOORDER:
			case ORDER:
				EnterOuterAlt(_localctx, 7);
				{
				State = 7517;
				sequenceOrderClause();
				}
				break;
			case NOSCALE:
			case SCALE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 7518;
				sequenceScaleClause();
				}
				break;
			case KEEP:
			case NOKEEP:
				EnterOuterAlt(_localctx, 9);
				{
				State = 7519;
				sequenceKeepClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceIncrementClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCREMENT() { return GetToken(OracleAntlrParser.INCREMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(OracleAntlrParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_SIGN() { return GetToken(OracleAntlrParser.MINUS_SIGN, 0); }
		public SequenceIncrementClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceIncrementClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSequenceIncrementClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSequenceIncrementClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceIncrementClauseContext sequenceIncrementClause() {
		SequenceIncrementClauseContext _localctx = new SequenceIncrementClauseContext(Context, State);
		EnterRule(_localctx, 1644, RULE_sequenceIncrementClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7522;
			Match(INCREMENT);
			State = 7523;
			Match(BY);
			State = 7525;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MINUS_SIGN) {
				{
				State = 7524;
				Match(MINUS_SIGN);
				}
			}

			State = 7527;
			Match(INTEGER_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceStartWithClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode START() { return GetToken(OracleAntlrParser.START, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(OracleAntlrParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIMIT() { return GetToken(OracleAntlrParser.LIMIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(OracleAntlrParser.VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_SIGN() { return GetToken(OracleAntlrParser.MINUS_SIGN, 0); }
		public SequenceStartWithClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceStartWithClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSequenceStartWithClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSequenceStartWithClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceStartWithClauseContext sequenceStartWithClause() {
		SequenceStartWithClauseContext _localctx = new SequenceStartWithClauseContext(Context, State);
		EnterRule(_localctx, 1646, RULE_sequenceStartWithClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7529;
			Match(START);
			State = 7530;
			Match(WITH);
			State = 7537;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INTEGER_LITERAL:
			case MINUS_SIGN:
				{
				State = 7532;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MINUS_SIGN) {
					{
					State = 7531;
					Match(MINUS_SIGN);
					}
				}

				State = 7534;
				Match(INTEGER_LITERAL);
				}
				break;
			case LIMIT:
				{
				State = 7535;
				Match(LIMIT);
				State = 7536;
				Match(VALUE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceMaxValueClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAXVALUE() { return GetToken(OracleAntlrParser.MAXVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_SIGN() { return GetToken(OracleAntlrParser.MINUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMAXVALUE() { return GetToken(OracleAntlrParser.NOMAXVALUE, 0); }
		public SequenceMaxValueClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceMaxValueClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSequenceMaxValueClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSequenceMaxValueClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceMaxValueClauseContext sequenceMaxValueClause() {
		SequenceMaxValueClauseContext _localctx = new SequenceMaxValueClauseContext(Context, State);
		EnterRule(_localctx, 1648, RULE_sequenceMaxValueClause);
		int _la;
		try {
			State = 7545;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MAXVALUE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7539;
				Match(MAXVALUE);
				State = 7541;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MINUS_SIGN) {
					{
					State = 7540;
					Match(MINUS_SIGN);
					}
				}

				State = 7543;
				Match(INTEGER_LITERAL);
				}
				break;
			case NOMAXVALUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7544;
				Match(NOMAXVALUE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceMinValueClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINVALUE() { return GetToken(OracleAntlrParser.MINVALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_SIGN() { return GetToken(OracleAntlrParser.MINUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOMINVALUE() { return GetToken(OracleAntlrParser.NOMINVALUE, 0); }
		public SequenceMinValueClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceMinValueClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSequenceMinValueClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSequenceMinValueClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceMinValueClauseContext sequenceMinValueClause() {
		SequenceMinValueClauseContext _localctx = new SequenceMinValueClauseContext(Context, State);
		EnterRule(_localctx, 1650, RULE_sequenceMinValueClause);
		int _la;
		try {
			State = 7553;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MINVALUE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7547;
				Match(MINVALUE);
				State = 7549;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MINUS_SIGN) {
					{
					State = 7548;
					Match(MINUS_SIGN);
					}
				}

				State = 7551;
				Match(INTEGER_LITERAL);
				}
				break;
			case NOMINVALUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7552;
				Match(NOMINVALUE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceCycleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CYCLE() { return GetToken(OracleAntlrParser.CYCLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCYCLE() { return GetToken(OracleAntlrParser.NOCYCLE, 0); }
		public SequenceCycleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceCycleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSequenceCycleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSequenceCycleClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceCycleClauseContext sequenceCycleClause() {
		SequenceCycleClauseContext _localctx = new SequenceCycleClauseContext(Context, State);
		EnterRule(_localctx, 1652, RULE_sequenceCycleClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7555;
			_la = TokenStream.LA(1);
			if ( !(_la==CYCLE || _la==NOCYCLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceCacheClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CACHE() { return GetToken(OracleAntlrParser.CACHE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(OracleAntlrParser.INTEGER_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_SIGN() { return GetToken(OracleAntlrParser.MINUS_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOCACHE() { return GetToken(OracleAntlrParser.NOCACHE, 0); }
		public SequenceCacheClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceCacheClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSequenceCacheClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSequenceCacheClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceCacheClauseContext sequenceCacheClause() {
		SequenceCacheClauseContext _localctx = new SequenceCacheClauseContext(Context, State);
		EnterRule(_localctx, 1654, RULE_sequenceCacheClause);
		int _la;
		try {
			State = 7563;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CACHE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7557;
				Match(CACHE);
				State = 7559;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MINUS_SIGN) {
					{
					State = 7558;
					Match(MINUS_SIGN);
					}
				}

				State = 7561;
				Match(INTEGER_LITERAL);
				}
				break;
			case NOCACHE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7562;
				Match(NOCACHE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceOrderClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDER() { return GetToken(OracleAntlrParser.ORDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOORDER() { return GetToken(OracleAntlrParser.NOORDER, 0); }
		public SequenceOrderClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceOrderClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSequenceOrderClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSequenceOrderClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceOrderClauseContext sequenceOrderClause() {
		SequenceOrderClauseContext _localctx = new SequenceOrderClauseContext(Context, State);
		EnterRule(_localctx, 1656, RULE_sequenceOrderClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7565;
			_la = TokenStream.LA(1);
			if ( !(_la==NOORDER || _la==ORDER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceScaleClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCALE() { return GetToken(OracleAntlrParser.SCALE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTEND() { return GetToken(OracleAntlrParser.EXTEND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOEXTEND() { return GetToken(OracleAntlrParser.NOEXTEND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOSCALE() { return GetToken(OracleAntlrParser.NOSCALE, 0); }
		public SequenceScaleClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceScaleClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSequenceScaleClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSequenceScaleClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceScaleClauseContext sequenceScaleClause() {
		SequenceScaleClauseContext _localctx = new SequenceScaleClauseContext(Context, State);
		EnterRule(_localctx, 1658, RULE_sequenceScaleClause);
		int _la;
		try {
			State = 7572;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SCALE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7567;
				Match(SCALE);
				State = 7569;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EXTEND || _la==NOEXTEND) {
					{
					State = 7568;
					_la = TokenStream.LA(1);
					if ( !(_la==EXTEND || _la==NOEXTEND) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			case NOSCALE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7571;
				Match(NOSCALE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceKeepClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEEP() { return GetToken(OracleAntlrParser.KEEP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOKEEP() { return GetToken(OracleAntlrParser.NOKEEP, 0); }
		public SequenceKeepClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceKeepClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSequenceKeepClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSequenceKeepClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceKeepClauseContext sequenceKeepClause() {
		SequenceKeepClauseContext _localctx = new SequenceKeepClauseContext(Context, State);
		EnterRule(_localctx, 1660, RULE_sequenceKeepClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7574;
			_la = TokenStream.LA(1);
			if ( !(_la==KEEP || _la==NOKEEP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceShardClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARD() { return GetToken(OracleAntlrParser.SHARD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTEND() { return GetToken(OracleAntlrParser.EXTEND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOEXTEND() { return GetToken(OracleAntlrParser.NOEXTEND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOSHARD() { return GetToken(OracleAntlrParser.NOSHARD, 0); }
		public SequenceShardClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceShardClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSequenceShardClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSequenceShardClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceShardClauseContext sequenceShardClause() {
		SequenceShardClauseContext _localctx = new SequenceShardClauseContext(Context, State);
		EnterRule(_localctx, 1662, RULE_sequenceShardClause);
		int _la;
		try {
			State = 7581;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SHARD:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7576;
				Match(SHARD);
				State = 7578;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EXTEND || _la==NOEXTEND) {
					{
					State = 7577;
					_la = TokenStream.LA(1);
					if ( !(_la==EXTEND || _la==NOEXTEND) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			case NOSHARD:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7580;
				Match(NOSHARD);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SequenceScopeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SESSION() { return GetToken(OracleAntlrParser.SESSION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GLOBAL() { return GetToken(OracleAntlrParser.GLOBAL, 0); }
		public SequenceScopeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequenceScopeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSequenceScopeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSequenceScopeClause(this);
		}
	}

	[RuleVersion(0)]
	public SequenceScopeClauseContext sequenceScopeClause() {
		SequenceScopeClauseContext _localctx = new SequenceScopeClauseContext(Context, State);
		EnterRule(_localctx, 1664, RULE_sequenceScopeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7583;
			_la = TokenStream.LA(1);
			if ( !(_la==GLOBAL || _la==SESSION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTypeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OidClauseContext oidClause() {
			return GetRuleContext<OidClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompleteTypeStatementContext completeTypeStatement() {
			return GetRuleContext<CompleteTypeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterTypeEmbeddedStatementContext[] alterTypeEmbeddedStatement() {
			return GetRuleContexts<AlterTypeEmbeddedStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterTypeEmbeddedStatementContext alterTypeEmbeddedStatement(int i) {
			return GetRuleContext<AlterTypeEmbeddedStatementContext>(i);
		}
		public CreateTypeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTypeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateTypeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateTypeStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateTypeStatementContext createTypeStatement() {
		CreateTypeStatementContext _localctx = new CreateTypeStatementContext(Context, State);
		EnterRule(_localctx, 1666, RULE_createTypeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7585;
			Match(TYPE);
			State = 7586;
			plainIdentifier();
			State = 7588;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OID) {
				{
				State = 7587;
				oidClause();
				}
			}

			State = 7591;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS || _la==AUTHID || _la==IS || _la==UNDER) {
				{
				State = 7590;
				completeTypeStatement();
				}
			}

			State = 7596;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ALTER) {
				{
				{
				State = 7593;
				alterTypeEmbeddedStatement();
				}
				}
				State = 7598;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTypeEmbeddedStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALTER() { return GetToken(OracleAntlrParser.ALTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AlterTypeStatementContext alterTypeStatement() {
			return GetRuleContext<AlterTypeStatementContext>(0);
		}
		public AlterTypeEmbeddedStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTypeEmbeddedStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterAlterTypeEmbeddedStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitAlterTypeEmbeddedStatement(this);
		}
	}

	[RuleVersion(0)]
	public AlterTypeEmbeddedStatementContext alterTypeEmbeddedStatement() {
		AlterTypeEmbeddedStatementContext _localctx = new AlterTypeEmbeddedStatementContext(Context, State);
		EnterRule(_localctx, 1668, RULE_alterTypeEmbeddedStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7599;
			Match(ALTER);
			State = 7600;
			alterTypeStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompleteTypeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeStatementContext objectTypeStatement() {
			return GetRuleContext<ObjectTypeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayTypeStatementContext varrayTypeStatement() {
			return GetRuleContext<VarrayTypeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NestedTableTypeStatementContext nestedTableTypeStatement() {
			return GetRuleContext<NestedTableTypeStatementContext>(0);
		}
		public CompleteTypeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_completeTypeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCompleteTypeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCompleteTypeStatement(this);
		}
	}

	[RuleVersion(0)]
	public CompleteTypeStatementContext completeTypeStatement() {
		CompleteTypeStatementContext _localctx = new CompleteTypeStatementContext(Context, State);
		EnterRule(_localctx, 1670, RULE_completeTypeStatement);
		try {
			State = 7605;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,886,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7602;
				objectTypeStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7603;
				varrayTypeStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7604;
				nestedTableTypeStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TopLevelObjectTypeContext topLevelObjectType() {
			return GetRuleContext<TopLevelObjectTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubTypeContext subType() {
			return GetRuleContext<SubTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InvokerRightsClauseContext invokerRightsClause() {
			return GetRuleContext<InvokerRightsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeDeclarationItemsContext objectTypeDeclarationItems() {
			return GetRuleContext<ObjectTypeDeclarationItemsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InheritanceClauseContext[] inheritanceClause() {
			return GetRuleContexts<InheritanceClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public InheritanceClauseContext inheritanceClause(int i) {
			return GetRuleContext<InheritanceClauseContext>(i);
		}
		public ObjectTypeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectTypeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectTypeStatement(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeStatementContext objectTypeStatement() {
		ObjectTypeStatementContext _localctx = new ObjectTypeStatementContext(Context, State);
		EnterRule(_localctx, 1672, RULE_objectTypeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7608;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AUTHID) {
				{
				State = 7607;
				invokerRightsClause();
				}
			}

			State = 7612;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
			case IS:
				{
				State = 7610;
				topLevelObjectType();
				}
				break;
			case UNDER:
				{
				State = 7611;
				subType();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 7615;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 7614;
				objectTypeDeclarationItems();
				}
			}

			State = 7620;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==FINAL || _la==INSTANTIABLE || _la==NOT || _la==OVERRIDING) {
				{
				{
				State = 7617;
				inheritanceClause();
				}
				}
				State = 7622;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TopLevelObjectTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
			return GetRuleContext<RoutineBodyAsIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(OracleAntlrParser.OBJECT, 0); }
		public TopLevelObjectTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_topLevelObjectType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterTopLevelObjectType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitTopLevelObjectType(this);
		}
	}

	[RuleVersion(0)]
	public TopLevelObjectTypeContext topLevelObjectType() {
		TopLevelObjectTypeContext _localctx = new TopLevelObjectTypeContext(Context, State);
		EnterRule(_localctx, 1674, RULE_topLevelObjectType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7623;
			routineBodyAsIsClause();
			State = 7624;
			Match(OBJECT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UnderClauseContext underClause() {
			return GetRuleContext<UnderClauseContext>(0);
		}
		public SubTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterSubType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitSubType(this);
		}
	}

	[RuleVersion(0)]
	public SubTypeContext subType() {
		SubTypeContext _localctx = new SubTypeContext(Context, State);
		EnterRule(_localctx, 1676, RULE_subType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7626;
			underClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeDeclarationItemsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(OracleAntlrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeDeclarationItemContext[] objectTypeDeclarationItem() {
			return GetRuleContexts<ObjectTypeDeclarationItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeDeclarationItemContext objectTypeDeclarationItem(int i) {
			return GetRuleContext<ObjectTypeDeclarationItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(OracleAntlrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(OracleAntlrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(OracleAntlrParser.COMMA, i);
		}
		public ObjectTypeDeclarationItemsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeDeclarationItems; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectTypeDeclarationItems(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectTypeDeclarationItems(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeDeclarationItemsContext objectTypeDeclarationItems() {
		ObjectTypeDeclarationItemsContext _localctx = new ObjectTypeDeclarationItemsContext(Context, State);
		EnterRule(_localctx, 1678, RULE_objectTypeDeclarationItems);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7628;
			Match(LPAREN);
			State = 7629;
			objectTypeDeclarationItem();
			State = 7634;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 7630;
				Match(COMMA);
				State = 7631;
				objectTypeDeclarationItem();
				}
				}
				State = 7636;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 7637;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeDeclarationItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeRoutineContext objectTypeRoutine() {
			return GetRuleContext<ObjectTypeRoutineContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeAttributeDeclarationContext objectTypeAttributeDeclaration() {
			return GetRuleContext<ObjectTypeAttributeDeclarationContext>(0);
		}
		public ObjectTypeDeclarationItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeDeclarationItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectTypeDeclarationItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectTypeDeclarationItem(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeDeclarationItemContext objectTypeDeclarationItem() {
		ObjectTypeDeclarationItemContext _localctx = new ObjectTypeDeclarationItemContext(Context, State);
		EnterRule(_localctx, 1680, RULE_objectTypeDeclarationItem);
		try {
			State = 7641;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,892,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7639;
				objectTypeRoutine();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7640;
				objectTypeAttributeDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeAttributeDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleIdentifierContext simpleIdentifier() {
			return GetRuleContext<SimpleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public ObjectTypeAttributeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeAttributeDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectTypeAttributeDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectTypeAttributeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeAttributeDeclarationContext objectTypeAttributeDeclaration() {
		ObjectTypeAttributeDeclarationContext _localctx = new ObjectTypeAttributeDeclarationContext(Context, State);
		EnterRule(_localctx, 1682, RULE_objectTypeAttributeDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7643;
			simpleIdentifier();
			State = 7644;
			typeReference();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarrayTypeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
			return GetRuleContext<RoutineBodyAsIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarrayTypeDeclarationContext varrayTypeDeclaration() {
			return GetRuleContext<VarrayTypeDeclarationContext>(0);
		}
		public VarrayTypeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varrayTypeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterVarrayTypeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitVarrayTypeStatement(this);
		}
	}

	[RuleVersion(0)]
	public VarrayTypeStatementContext varrayTypeStatement() {
		VarrayTypeStatementContext _localctx = new VarrayTypeStatementContext(Context, State);
		EnterRule(_localctx, 1684, RULE_varrayTypeStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7646;
			routineBodyAsIsClause();
			State = 7647;
			varrayTypeDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NestedTableTypeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
			return GetRuleContext<RoutineBodyAsIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TableTypeDeclarationContext tableTypeDeclaration() {
			return GetRuleContext<TableTypeDeclarationContext>(0);
		}
		public NestedTableTypeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nestedTableTypeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterNestedTableTypeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitNestedTableTypeStatement(this);
		}
	}

	[RuleVersion(0)]
	public NestedTableTypeStatementContext nestedTableTypeStatement() {
		NestedTableTypeStatementContext _localctx = new NestedTableTypeStatementContext(Context, State);
		EnterRule(_localctx, 1686, RULE_nestedTableTypeStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7649;
			routineBodyAsIsClause();
			State = 7650;
			tableTypeDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OidClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OID() { return GetToken(OracleAntlrParser.OID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CharacterStringLiteralContext characterStringLiteral() {
			return GetRuleContext<CharacterStringLiteralContext>(0);
		}
		public OidClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_oidClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterOidClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitOidClause(this);
		}
	}

	[RuleVersion(0)]
	public OidClauseContext oidClause() {
		OidClauseContext _localctx = new OidClauseContext(Context, State);
		EnterRule(_localctx, 1688, RULE_oidClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7652;
			Match(OID);
			State = 7653;
			characterStringLiteral();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTypeBodyStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(OracleAntlrParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BODY() { return GetToken(OracleAntlrParser.BODY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyAsIsClauseContext routineBodyAsIsClause() {
			return GetRuleContext<RoutineBodyAsIsClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeBodyDeclarationItemsContext objectTypeBodyDeclarationItems() {
			return GetRuleContext<ObjectTypeBodyDeclarationItemsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(OracleAntlrParser.END, 0); }
		public CreateTypeBodyStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTypeBodyStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateTypeBodyStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateTypeBodyStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateTypeBodyStatementContext createTypeBodyStatement() {
		CreateTypeBodyStatementContext _localctx = new CreateTypeBodyStatementContext(Context, State);
		EnterRule(_localctx, 1690, RULE_createTypeBodyStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7655;
			Match(TYPE);
			State = 7656;
			Match(BODY);
			State = 7657;
			plainIdentifier();
			State = 7658;
			routineBodyAsIsClause();
			State = 7659;
			objectTypeBodyDeclarationItems();
			State = 7660;
			Match(END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeBodyDeclarationItemsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeRoutineContext[] objectTypeRoutine() {
			return GetRuleContexts<ObjectTypeRoutineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeRoutineContext objectTypeRoutine(int i) {
			return GetRuleContext<ObjectTypeRoutineContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SEMI() { return GetTokens(OracleAntlrParser.SEMI); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI(int i) {
			return GetToken(OracleAntlrParser.SEMI, i);
		}
		public ObjectTypeBodyDeclarationItemsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeBodyDeclarationItems; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectTypeBodyDeclarationItems(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectTypeBodyDeclarationItems(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeBodyDeclarationItemsContext objectTypeBodyDeclarationItems() {
		ObjectTypeBodyDeclarationItemsContext _localctx = new ObjectTypeBodyDeclarationItemsContext(Context, State);
		EnterRule(_localctx, 1692, RULE_objectTypeBodyDeclarationItems);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7662;
			objectTypeRoutine();
			State = 7663;
			Match(SEMI);
			State = 7669;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==CONSTRUCTOR || _la==FINAL || _la==INSTANTIABLE || ((((_la - 283)) & ~0x3f) == 0 && ((1L << (_la - 283)) & ((1L << (MAP - 283)) | (1L << (MEMBER - 283)) | (1L << (NOT - 283)))) != 0) || _la==ORDER || _la==OVERRIDING || _la==STATIC) {
				{
				{
				State = 7664;
				objectTypeRoutine();
				State = 7665;
				Match(SEMI);
				}
				}
				State = 7671;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeRoutineContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeMemberStaticRoutineContext objectTypeMemberStaticRoutine() {
			return GetRuleContext<ObjectTypeMemberStaticRoutineContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeConstructorContext objectTypeConstructor() {
			return GetRuleContext<ObjectTypeConstructorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectTypeMapOrderFunctionContext objectTypeMapOrderFunction() {
			return GetRuleContext<ObjectTypeMapOrderFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InheritanceClauseContext inheritanceClause() {
			return GetRuleContext<InheritanceClauseContext>(0);
		}
		public ObjectTypeRoutineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeRoutine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectTypeRoutine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectTypeRoutine(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeRoutineContext objectTypeRoutine() {
		ObjectTypeRoutineContext _localctx = new ObjectTypeRoutineContext(Context, State);
		EnterRule(_localctx, 1694, RULE_objectTypeRoutine);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7673;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FINAL || _la==INSTANTIABLE || _la==NOT || _la==OVERRIDING) {
				{
				State = 7672;
				inheritanceClause();
				}
			}

			State = 7678;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MEMBER:
			case STATIC:
				{
				State = 7675;
				objectTypeMemberStaticRoutine();
				}
				break;
			case CONSTRUCTOR:
				{
				State = 7676;
				objectTypeConstructor();
				}
				break;
			case MAP:
			case ORDER:
				{
				State = 7677;
				objectTypeMapOrderFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeMemberStaticRoutineContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEMBER() { return GetToken(OracleAntlrParser.MEMBER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATIC() { return GetToken(OracleAntlrParser.STATIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureStatementContext procedureStatement() {
			return GetRuleContext<ProcedureStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionStatementContext functionStatement() {
			return GetRuleContext<FunctionStatementContext>(0);
		}
		public ObjectTypeMemberStaticRoutineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeMemberStaticRoutine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectTypeMemberStaticRoutine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectTypeMemberStaticRoutine(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeMemberStaticRoutineContext objectTypeMemberStaticRoutine() {
		ObjectTypeMemberStaticRoutineContext _localctx = new ObjectTypeMemberStaticRoutineContext(Context, State);
		EnterRule(_localctx, 1696, RULE_objectTypeMemberStaticRoutine);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7680;
			_la = TokenStream.LA(1);
			if ( !(_la==MEMBER || _la==STATIC) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 7683;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PROCEDURE:
				{
				State = 7681;
				procedureStatement();
				}
				break;
			case FUNCTION:
				{
				State = 7682;
				functionStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeConstructorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstructorHeaderContext constructorHeader() {
			return GetRuleContext<ConstructorHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstructorReturnClauseContext constructorReturnClause() {
			return GetRuleContext<ConstructorReturnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureCallSpecClauseContext procedureCallSpecClause() {
			return GetRuleContext<ProcedureCallSpecClauseContext>(0);
		}
		public ObjectTypeConstructorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeConstructor; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectTypeConstructor(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectTypeConstructor(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeConstructorContext objectTypeConstructor() {
		ObjectTypeConstructorContext _localctx = new ObjectTypeConstructorContext(Context, State);
		EnterRule(_localctx, 1698, RULE_objectTypeConstructor);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7685;
			constructorHeader();
			State = 7686;
			constructorReturnClause();
			State = 7689;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
			case IS:
				{
				State = 7687;
				routineBody();
				}
				break;
			case LANGUAGE:
				{
				State = 7688;
				procedureCallSpecClause();
				}
				break;
			case RPAREN:
			case COMMA:
			case SEMI:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstructorHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRUCTOR() { return GetToken(OracleAntlrParser.CONSTRUCTOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTION() { return GetToken(OracleAntlrParser.FUNCTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public ConstructorHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constructorHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConstructorHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConstructorHeader(this);
		}
	}

	[RuleVersion(0)]
	public ConstructorHeaderContext constructorHeader() {
		ConstructorHeaderContext _localctx = new ConstructorHeaderContext(Context, State);
		EnterRule(_localctx, 1700, RULE_constructorHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7691;
			Match(CONSTRUCTOR);
			State = 7692;
			Match(FUNCTION);
			State = 7693;
			plainIdentifier();
			State = 7695;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 7694;
				argumentList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstructorReturnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(OracleAntlrParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SELF() { return GetToken(OracleAntlrParser.SELF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(OracleAntlrParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RESULT() { return GetToken(OracleAntlrParser.RESULT, 0); }
		public ConstructorReturnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constructorReturnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterConstructorReturnClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitConstructorReturnClause(this);
		}
	}

	[RuleVersion(0)]
	public ConstructorReturnClauseContext constructorReturnClause() {
		ConstructorReturnClauseContext _localctx = new ConstructorReturnClauseContext(Context, State);
		EnterRule(_localctx, 1702, RULE_constructorReturnClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7697;
			Match(RETURN);
			State = 7698;
			Match(SELF);
			State = 7699;
			Match(AS);
			State = 7700;
			Match(RESULT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectTypeMapOrderFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEMBER() { return GetToken(OracleAntlrParser.MEMBER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionStatementContext functionStatement() {
			return GetRuleContext<FunctionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAP() { return GetToken(OracleAntlrParser.MAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDER() { return GetToken(OracleAntlrParser.ORDER, 0); }
		public ObjectTypeMapOrderFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectTypeMapOrderFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterObjectTypeMapOrderFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitObjectTypeMapOrderFunction(this);
		}
	}

	[RuleVersion(0)]
	public ObjectTypeMapOrderFunctionContext objectTypeMapOrderFunction() {
		ObjectTypeMapOrderFunctionContext _localctx = new ObjectTypeMapOrderFunctionContext(Context, State);
		EnterRule(_localctx, 1704, RULE_objectTypeMapOrderFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7702;
			_la = TokenStream.LA(1);
			if ( !(_la==MAP || _la==ORDER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 7703;
			Match(MEMBER);
			State = 7704;
			functionStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InheritanceClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OVERRIDING() { return GetToken(OracleAntlrParser.OVERRIDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FINAL() { return GetToken(OracleAntlrParser.FINAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSTANTIABLE() { return GetToken(OracleAntlrParser.INSTANTIABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(OracleAntlrParser.NOT, 0); }
		public InheritanceClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inheritanceClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterInheritanceClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitInheritanceClause(this);
		}
	}

	[RuleVersion(0)]
	public InheritanceClauseContext inheritanceClause() {
		InheritanceClauseContext _localctx = new InheritanceClauseContext(Context, State);
		EnterRule(_localctx, 1706, RULE_inheritanceClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7707;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 7706;
				Match(NOT);
				}
			}

			State = 7709;
			_la = TokenStream.LA(1);
			if ( !(_la==FINAL || _la==INSTANTIABLE || _la==OVERRIDING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSynonymStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SYNONYM() { return GetToken(OracleAntlrParser.SYNONYM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainIdentifierContext plainIdentifier() {
			return GetRuleContext<PlainIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(OracleAntlrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainRemoteIdentifierContext plainRemoteIdentifier() {
			return GetRuleContext<PlainRemoteIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PUBLIC() { return GetToken(OracleAntlrParser.PUBLIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CreateSynonymSharingClauseContext createSynonymSharingClause() {
			return GetRuleContext<CreateSynonymSharingClauseContext>(0);
		}
		public CreateSynonymStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSynonymStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateSynonymStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateSynonymStatement(this);
		}
	}

	[RuleVersion(0)]
	public CreateSynonymStatementContext createSynonymStatement() {
		CreateSynonymStatementContext _localctx = new CreateSynonymStatementContext(Context, State);
		EnterRule(_localctx, 1708, RULE_createSynonymStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7712;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PUBLIC) {
				{
				State = 7711;
				Match(PUBLIC);
				}
			}

			State = 7714;
			Match(SYNONYM);
			State = 7715;
			plainIdentifier();
			State = 7717;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SHARING) {
				{
				State = 7716;
				createSynonymSharingClause();
				}
			}

			State = 7719;
			Match(FOR);
			State = 7720;
			plainRemoteIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSynonymSharingClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARING() { return GetToken(OracleAntlrParser.SHARING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL_SIGN() { return GetToken(OracleAntlrParser.EQUAL_SIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode METADATA() { return GetToken(OracleAntlrParser.METADATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(OracleAntlrParser.NONE, 0); }
		public CreateSynonymSharingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSynonymSharingClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.EnterCreateSynonymSharingClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IOracleAntlrParserListener typedListener = listener as IOracleAntlrParserListener;
			if (typedListener != null) typedListener.ExitCreateSynonymSharingClause(this);
		}
	}

	[RuleVersion(0)]
	public CreateSynonymSharingClauseContext createSynonymSharingClause() {
		CreateSynonymSharingClauseContext _localctx = new CreateSynonymSharingClauseContext(Context, State);
		EnterRule(_localctx, 1710, RULE_createSynonymSharingClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7722;
			Match(SHARING);
			State = 7723;
			Match(EQUAL_SIGN);
			State = 7724;
			_la = TokenStream.LA(1);
			if ( !(_la==METADATA || _la==NONE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 14: return plSqlStatementBatch_sempred((PlSqlStatementBatchContext)_localctx, predIndex);
		case 563: return fromClauseItem_sempred((FromClauseItemContext)_localctx, predIndex);
		}
		return true;
	}
	private bool plSqlStatementBatch_sempred(PlSqlStatementBatchContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return IsSqlStatement();
		}
		return true;
	}
	private bool fromClauseItem_sempred(FromClauseItemContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return IsAliasIdentifier();
		}
		return true;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '\x26F', '\x1E31', '\x4', '\x2', '\t', '\x2', '\x4', 
		'\x3', '\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', 
		'\x4', '\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', 
		'\b', '\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', 
		'\v', '\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', 
		'\t', '\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4', 
		'\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t', 
		'\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x4', 
		'\x16', '\t', '\x16', '\x4', '\x17', '\t', '\x17', '\x4', '\x18', '\t', 
		'\x18', '\x4', '\x19', '\t', '\x19', '\x4', '\x1A', '\t', '\x1A', '\x4', 
		'\x1B', '\t', '\x1B', '\x4', '\x1C', '\t', '\x1C', '\x4', '\x1D', '\t', 
		'\x1D', '\x4', '\x1E', '\t', '\x1E', '\x4', '\x1F', '\t', '\x1F', '\x4', 
		' ', '\t', ' ', '\x4', '!', '\t', '!', '\x4', '\"', '\t', '\"', '\x4', 
		'#', '\t', '#', '\x4', '$', '\t', '$', '\x4', '%', '\t', '%', '\x4', '&', 
		'\t', '&', '\x4', '\'', '\t', '\'', '\x4', '(', '\t', '(', '\x4', ')', 
		'\t', ')', '\x4', '*', '\t', '*', '\x4', '+', '\t', '+', '\x4', ',', '\t', 
		',', '\x4', '-', '\t', '-', '\x4', '.', '\t', '.', '\x4', '/', '\t', '/', 
		'\x4', '\x30', '\t', '\x30', '\x4', '\x31', '\t', '\x31', '\x4', '\x32', 
		'\t', '\x32', '\x4', '\x33', '\t', '\x33', '\x4', '\x34', '\t', '\x34', 
		'\x4', '\x35', '\t', '\x35', '\x4', '\x36', '\t', '\x36', '\x4', '\x37', 
		'\t', '\x37', '\x4', '\x38', '\t', '\x38', '\x4', '\x39', '\t', '\x39', 
		'\x4', ':', '\t', ':', '\x4', ';', '\t', ';', '\x4', '<', '\t', '<', '\x4', 
		'=', '\t', '=', '\x4', '>', '\t', '>', '\x4', '?', '\t', '?', '\x4', '@', 
		'\t', '@', '\x4', '\x41', '\t', '\x41', '\x4', '\x42', '\t', '\x42', '\x4', 
		'\x43', '\t', '\x43', '\x4', '\x44', '\t', '\x44', '\x4', '\x45', '\t', 
		'\x45', '\x4', '\x46', '\t', '\x46', '\x4', 'G', '\t', 'G', '\x4', 'H', 
		'\t', 'H', '\x4', 'I', '\t', 'I', '\x4', 'J', '\t', 'J', '\x4', 'K', '\t', 
		'K', '\x4', 'L', '\t', 'L', '\x4', 'M', '\t', 'M', '\x4', 'N', '\t', 'N', 
		'\x4', 'O', '\t', 'O', '\x4', 'P', '\t', 'P', '\x4', 'Q', '\t', 'Q', '\x4', 
		'R', '\t', 'R', '\x4', 'S', '\t', 'S', '\x4', 'T', '\t', 'T', '\x4', 'U', 
		'\t', 'U', '\x4', 'V', '\t', 'V', '\x4', 'W', '\t', 'W', '\x4', 'X', '\t', 
		'X', '\x4', 'Y', '\t', 'Y', '\x4', 'Z', '\t', 'Z', '\x4', '[', '\t', '[', 
		'\x4', '\\', '\t', '\\', '\x4', ']', '\t', ']', '\x4', '^', '\t', '^', 
		'\x4', '_', '\t', '_', '\x4', '`', '\t', '`', '\x4', '\x61', '\t', '\x61', 
		'\x4', '\x62', '\t', '\x62', '\x4', '\x63', '\t', '\x63', '\x4', '\x64', 
		'\t', '\x64', '\x4', '\x65', '\t', '\x65', '\x4', '\x66', '\t', '\x66', 
		'\x4', 'g', '\t', 'g', '\x4', 'h', '\t', 'h', '\x4', 'i', '\t', 'i', '\x4', 
		'j', '\t', 'j', '\x4', 'k', '\t', 'k', '\x4', 'l', '\t', 'l', '\x4', 'm', 
		'\t', 'm', '\x4', 'n', '\t', 'n', '\x4', 'o', '\t', 'o', '\x4', 'p', '\t', 
		'p', '\x4', 'q', '\t', 'q', '\x4', 'r', '\t', 'r', '\x4', 's', '\t', 's', 
		'\x4', 't', '\t', 't', '\x4', 'u', '\t', 'u', '\x4', 'v', '\t', 'v', '\x4', 
		'w', '\t', 'w', '\x4', 'x', '\t', 'x', '\x4', 'y', '\t', 'y', '\x4', 'z', 
		'\t', 'z', '\x4', '{', '\t', '{', '\x4', '|', '\t', '|', '\x4', '}', '\t', 
		'}', '\x4', '~', '\t', '~', '\x4', '\x7F', '\t', '\x7F', '\x4', '\x80', 
		'\t', '\x80', '\x4', '\x81', '\t', '\x81', '\x4', '\x82', '\t', '\x82', 
		'\x4', '\x83', '\t', '\x83', '\x4', '\x84', '\t', '\x84', '\x4', '\x85', 
		'\t', '\x85', '\x4', '\x86', '\t', '\x86', '\x4', '\x87', '\t', '\x87', 
		'\x4', '\x88', '\t', '\x88', '\x4', '\x89', '\t', '\x89', '\x4', '\x8A', 
		'\t', '\x8A', '\x4', '\x8B', '\t', '\x8B', '\x4', '\x8C', '\t', '\x8C', 
		'\x4', '\x8D', '\t', '\x8D', '\x4', '\x8E', '\t', '\x8E', '\x4', '\x8F', 
		'\t', '\x8F', '\x4', '\x90', '\t', '\x90', '\x4', '\x91', '\t', '\x91', 
		'\x4', '\x92', '\t', '\x92', '\x4', '\x93', '\t', '\x93', '\x4', '\x94', 
		'\t', '\x94', '\x4', '\x95', '\t', '\x95', '\x4', '\x96', '\t', '\x96', 
		'\x4', '\x97', '\t', '\x97', '\x4', '\x98', '\t', '\x98', '\x4', '\x99', 
		'\t', '\x99', '\x4', '\x9A', '\t', '\x9A', '\x4', '\x9B', '\t', '\x9B', 
		'\x4', '\x9C', '\t', '\x9C', '\x4', '\x9D', '\t', '\x9D', '\x4', '\x9E', 
		'\t', '\x9E', '\x4', '\x9F', '\t', '\x9F', '\x4', '\xA0', '\t', '\xA0', 
		'\x4', '\xA1', '\t', '\xA1', '\x4', '\xA2', '\t', '\xA2', '\x4', '\xA3', 
		'\t', '\xA3', '\x4', '\xA4', '\t', '\xA4', '\x4', '\xA5', '\t', '\xA5', 
		'\x4', '\xA6', '\t', '\xA6', '\x4', '\xA7', '\t', '\xA7', '\x4', '\xA8', 
		'\t', '\xA8', '\x4', '\xA9', '\t', '\xA9', '\x4', '\xAA', '\t', '\xAA', 
		'\x4', '\xAB', '\t', '\xAB', '\x4', '\xAC', '\t', '\xAC', '\x4', '\xAD', 
		'\t', '\xAD', '\x4', '\xAE', '\t', '\xAE', '\x4', '\xAF', '\t', '\xAF', 
		'\x4', '\xB0', '\t', '\xB0', '\x4', '\xB1', '\t', '\xB1', '\x4', '\xB2', 
		'\t', '\xB2', '\x4', '\xB3', '\t', '\xB3', '\x4', '\xB4', '\t', '\xB4', 
		'\x4', '\xB5', '\t', '\xB5', '\x4', '\xB6', '\t', '\xB6', '\x4', '\xB7', 
		'\t', '\xB7', '\x4', '\xB8', '\t', '\xB8', '\x4', '\xB9', '\t', '\xB9', 
		'\x4', '\xBA', '\t', '\xBA', '\x4', '\xBB', '\t', '\xBB', '\x4', '\xBC', 
		'\t', '\xBC', '\x4', '\xBD', '\t', '\xBD', '\x4', '\xBE', '\t', '\xBE', 
		'\x4', '\xBF', '\t', '\xBF', '\x4', '\xC0', '\t', '\xC0', '\x4', '\xC1', 
		'\t', '\xC1', '\x4', '\xC2', '\t', '\xC2', '\x4', '\xC3', '\t', '\xC3', 
		'\x4', '\xC4', '\t', '\xC4', '\x4', '\xC5', '\t', '\xC5', '\x4', '\xC6', 
		'\t', '\xC6', '\x4', '\xC7', '\t', '\xC7', '\x4', '\xC8', '\t', '\xC8', 
		'\x4', '\xC9', '\t', '\xC9', '\x4', '\xCA', '\t', '\xCA', '\x4', '\xCB', 
		'\t', '\xCB', '\x4', '\xCC', '\t', '\xCC', '\x4', '\xCD', '\t', '\xCD', 
		'\x4', '\xCE', '\t', '\xCE', '\x4', '\xCF', '\t', '\xCF', '\x4', '\xD0', 
		'\t', '\xD0', '\x4', '\xD1', '\t', '\xD1', '\x4', '\xD2', '\t', '\xD2', 
		'\x4', '\xD3', '\t', '\xD3', '\x4', '\xD4', '\t', '\xD4', '\x4', '\xD5', 
		'\t', '\xD5', '\x4', '\xD6', '\t', '\xD6', '\x4', '\xD7', '\t', '\xD7', 
		'\x4', '\xD8', '\t', '\xD8', '\x4', '\xD9', '\t', '\xD9', '\x4', '\xDA', 
		'\t', '\xDA', '\x4', '\xDB', '\t', '\xDB', '\x4', '\xDC', '\t', '\xDC', 
		'\x4', '\xDD', '\t', '\xDD', '\x4', '\xDE', '\t', '\xDE', '\x4', '\xDF', 
		'\t', '\xDF', '\x4', '\xE0', '\t', '\xE0', '\x4', '\xE1', '\t', '\xE1', 
		'\x4', '\xE2', '\t', '\xE2', '\x4', '\xE3', '\t', '\xE3', '\x4', '\xE4', 
		'\t', '\xE4', '\x4', '\xE5', '\t', '\xE5', '\x4', '\xE6', '\t', '\xE6', 
		'\x4', '\xE7', '\t', '\xE7', '\x4', '\xE8', '\t', '\xE8', '\x4', '\xE9', 
		'\t', '\xE9', '\x4', '\xEA', '\t', '\xEA', '\x4', '\xEB', '\t', '\xEB', 
		'\x4', '\xEC', '\t', '\xEC', '\x4', '\xED', '\t', '\xED', '\x4', '\xEE', 
		'\t', '\xEE', '\x4', '\xEF', '\t', '\xEF', '\x4', '\xF0', '\t', '\xF0', 
		'\x4', '\xF1', '\t', '\xF1', '\x4', '\xF2', '\t', '\xF2', '\x4', '\xF3', 
		'\t', '\xF3', '\x4', '\xF4', '\t', '\xF4', '\x4', '\xF5', '\t', '\xF5', 
		'\x4', '\xF6', '\t', '\xF6', '\x4', '\xF7', '\t', '\xF7', '\x4', '\xF8', 
		'\t', '\xF8', '\x4', '\xF9', '\t', '\xF9', '\x4', '\xFA', '\t', '\xFA', 
		'\x4', '\xFB', '\t', '\xFB', '\x4', '\xFC', '\t', '\xFC', '\x4', '\xFD', 
		'\t', '\xFD', '\x4', '\xFE', '\t', '\xFE', '\x4', '\xFF', '\t', '\xFF', 
		'\x4', '\x100', '\t', '\x100', '\x4', '\x101', '\t', '\x101', '\x4', '\x102', 
		'\t', '\x102', '\x4', '\x103', '\t', '\x103', '\x4', '\x104', '\t', '\x104', 
		'\x4', '\x105', '\t', '\x105', '\x4', '\x106', '\t', '\x106', '\x4', '\x107', 
		'\t', '\x107', '\x4', '\x108', '\t', '\x108', '\x4', '\x109', '\t', '\x109', 
		'\x4', '\x10A', '\t', '\x10A', '\x4', '\x10B', '\t', '\x10B', '\x4', '\x10C', 
		'\t', '\x10C', '\x4', '\x10D', '\t', '\x10D', '\x4', '\x10E', '\t', '\x10E', 
		'\x4', '\x10F', '\t', '\x10F', '\x4', '\x110', '\t', '\x110', '\x4', '\x111', 
		'\t', '\x111', '\x4', '\x112', '\t', '\x112', '\x4', '\x113', '\t', '\x113', 
		'\x4', '\x114', '\t', '\x114', '\x4', '\x115', '\t', '\x115', '\x4', '\x116', 
		'\t', '\x116', '\x4', '\x117', '\t', '\x117', '\x4', '\x118', '\t', '\x118', 
		'\x4', '\x119', '\t', '\x119', '\x4', '\x11A', '\t', '\x11A', '\x4', '\x11B', 
		'\t', '\x11B', '\x4', '\x11C', '\t', '\x11C', '\x4', '\x11D', '\t', '\x11D', 
		'\x4', '\x11E', '\t', '\x11E', '\x4', '\x11F', '\t', '\x11F', '\x4', '\x120', 
		'\t', '\x120', '\x4', '\x121', '\t', '\x121', '\x4', '\x122', '\t', '\x122', 
		'\x4', '\x123', '\t', '\x123', '\x4', '\x124', '\t', '\x124', '\x4', '\x125', 
		'\t', '\x125', '\x4', '\x126', '\t', '\x126', '\x4', '\x127', '\t', '\x127', 
		'\x4', '\x128', '\t', '\x128', '\x4', '\x129', '\t', '\x129', '\x4', '\x12A', 
		'\t', '\x12A', '\x4', '\x12B', '\t', '\x12B', '\x4', '\x12C', '\t', '\x12C', 
		'\x4', '\x12D', '\t', '\x12D', '\x4', '\x12E', '\t', '\x12E', '\x4', '\x12F', 
		'\t', '\x12F', '\x4', '\x130', '\t', '\x130', '\x4', '\x131', '\t', '\x131', 
		'\x4', '\x132', '\t', '\x132', '\x4', '\x133', '\t', '\x133', '\x4', '\x134', 
		'\t', '\x134', '\x4', '\x135', '\t', '\x135', '\x4', '\x136', '\t', '\x136', 
		'\x4', '\x137', '\t', '\x137', '\x4', '\x138', '\t', '\x138', '\x4', '\x139', 
		'\t', '\x139', '\x4', '\x13A', '\t', '\x13A', '\x4', '\x13B', '\t', '\x13B', 
		'\x4', '\x13C', '\t', '\x13C', '\x4', '\x13D', '\t', '\x13D', '\x4', '\x13E', 
		'\t', '\x13E', '\x4', '\x13F', '\t', '\x13F', '\x4', '\x140', '\t', '\x140', 
		'\x4', '\x141', '\t', '\x141', '\x4', '\x142', '\t', '\x142', '\x4', '\x143', 
		'\t', '\x143', '\x4', '\x144', '\t', '\x144', '\x4', '\x145', '\t', '\x145', 
		'\x4', '\x146', '\t', '\x146', '\x4', '\x147', '\t', '\x147', '\x4', '\x148', 
		'\t', '\x148', '\x4', '\x149', '\t', '\x149', '\x4', '\x14A', '\t', '\x14A', 
		'\x4', '\x14B', '\t', '\x14B', '\x4', '\x14C', '\t', '\x14C', '\x4', '\x14D', 
		'\t', '\x14D', '\x4', '\x14E', '\t', '\x14E', '\x4', '\x14F', '\t', '\x14F', 
		'\x4', '\x150', '\t', '\x150', '\x4', '\x151', '\t', '\x151', '\x4', '\x152', 
		'\t', '\x152', '\x4', '\x153', '\t', '\x153', '\x4', '\x154', '\t', '\x154', 
		'\x4', '\x155', '\t', '\x155', '\x4', '\x156', '\t', '\x156', '\x4', '\x157', 
		'\t', '\x157', '\x4', '\x158', '\t', '\x158', '\x4', '\x159', '\t', '\x159', 
		'\x4', '\x15A', '\t', '\x15A', '\x4', '\x15B', '\t', '\x15B', '\x4', '\x15C', 
		'\t', '\x15C', '\x4', '\x15D', '\t', '\x15D', '\x4', '\x15E', '\t', '\x15E', 
		'\x4', '\x15F', '\t', '\x15F', '\x4', '\x160', '\t', '\x160', '\x4', '\x161', 
		'\t', '\x161', '\x4', '\x162', '\t', '\x162', '\x4', '\x163', '\t', '\x163', 
		'\x4', '\x164', '\t', '\x164', '\x4', '\x165', '\t', '\x165', '\x4', '\x166', 
		'\t', '\x166', '\x4', '\x167', '\t', '\x167', '\x4', '\x168', '\t', '\x168', 
		'\x4', '\x169', '\t', '\x169', '\x4', '\x16A', '\t', '\x16A', '\x4', '\x16B', 
		'\t', '\x16B', '\x4', '\x16C', '\t', '\x16C', '\x4', '\x16D', '\t', '\x16D', 
		'\x4', '\x16E', '\t', '\x16E', '\x4', '\x16F', '\t', '\x16F', '\x4', '\x170', 
		'\t', '\x170', '\x4', '\x171', '\t', '\x171', '\x4', '\x172', '\t', '\x172', 
		'\x4', '\x173', '\t', '\x173', '\x4', '\x174', '\t', '\x174', '\x4', '\x175', 
		'\t', '\x175', '\x4', '\x176', '\t', '\x176', '\x4', '\x177', '\t', '\x177', 
		'\x4', '\x178', '\t', '\x178', '\x4', '\x179', '\t', '\x179', '\x4', '\x17A', 
		'\t', '\x17A', '\x4', '\x17B', '\t', '\x17B', '\x4', '\x17C', '\t', '\x17C', 
		'\x4', '\x17D', '\t', '\x17D', '\x4', '\x17E', '\t', '\x17E', '\x4', '\x17F', 
		'\t', '\x17F', '\x4', '\x180', '\t', '\x180', '\x4', '\x181', '\t', '\x181', 
		'\x4', '\x182', '\t', '\x182', '\x4', '\x183', '\t', '\x183', '\x4', '\x184', 
		'\t', '\x184', '\x4', '\x185', '\t', '\x185', '\x4', '\x186', '\t', '\x186', 
		'\x4', '\x187', '\t', '\x187', '\x4', '\x188', '\t', '\x188', '\x4', '\x189', 
		'\t', '\x189', '\x4', '\x18A', '\t', '\x18A', '\x4', '\x18B', '\t', '\x18B', 
		'\x4', '\x18C', '\t', '\x18C', '\x4', '\x18D', '\t', '\x18D', '\x4', '\x18E', 
		'\t', '\x18E', '\x4', '\x18F', '\t', '\x18F', '\x4', '\x190', '\t', '\x190', 
		'\x4', '\x191', '\t', '\x191', '\x4', '\x192', '\t', '\x192', '\x4', '\x193', 
		'\t', '\x193', '\x4', '\x194', '\t', '\x194', '\x4', '\x195', '\t', '\x195', 
		'\x4', '\x196', '\t', '\x196', '\x4', '\x197', '\t', '\x197', '\x4', '\x198', 
		'\t', '\x198', '\x4', '\x199', '\t', '\x199', '\x4', '\x19A', '\t', '\x19A', 
		'\x4', '\x19B', '\t', '\x19B', '\x4', '\x19C', '\t', '\x19C', '\x4', '\x19D', 
		'\t', '\x19D', '\x4', '\x19E', '\t', '\x19E', '\x4', '\x19F', '\t', '\x19F', 
		'\x4', '\x1A0', '\t', '\x1A0', '\x4', '\x1A1', '\t', '\x1A1', '\x4', '\x1A2', 
		'\t', '\x1A2', '\x4', '\x1A3', '\t', '\x1A3', '\x4', '\x1A4', '\t', '\x1A4', 
		'\x4', '\x1A5', '\t', '\x1A5', '\x4', '\x1A6', '\t', '\x1A6', '\x4', '\x1A7', 
		'\t', '\x1A7', '\x4', '\x1A8', '\t', '\x1A8', '\x4', '\x1A9', '\t', '\x1A9', 
		'\x4', '\x1AA', '\t', '\x1AA', '\x4', '\x1AB', '\t', '\x1AB', '\x4', '\x1AC', 
		'\t', '\x1AC', '\x4', '\x1AD', '\t', '\x1AD', '\x4', '\x1AE', '\t', '\x1AE', 
		'\x4', '\x1AF', '\t', '\x1AF', '\x4', '\x1B0', '\t', '\x1B0', '\x4', '\x1B1', 
		'\t', '\x1B1', '\x4', '\x1B2', '\t', '\x1B2', '\x4', '\x1B3', '\t', '\x1B3', 
		'\x4', '\x1B4', '\t', '\x1B4', '\x4', '\x1B5', '\t', '\x1B5', '\x4', '\x1B6', 
		'\t', '\x1B6', '\x4', '\x1B7', '\t', '\x1B7', '\x4', '\x1B8', '\t', '\x1B8', 
		'\x4', '\x1B9', '\t', '\x1B9', '\x4', '\x1BA', '\t', '\x1BA', '\x4', '\x1BB', 
		'\t', '\x1BB', '\x4', '\x1BC', '\t', '\x1BC', '\x4', '\x1BD', '\t', '\x1BD', 
		'\x4', '\x1BE', '\t', '\x1BE', '\x4', '\x1BF', '\t', '\x1BF', '\x4', '\x1C0', 
		'\t', '\x1C0', '\x4', '\x1C1', '\t', '\x1C1', '\x4', '\x1C2', '\t', '\x1C2', 
		'\x4', '\x1C3', '\t', '\x1C3', '\x4', '\x1C4', '\t', '\x1C4', '\x4', '\x1C5', 
		'\t', '\x1C5', '\x4', '\x1C6', '\t', '\x1C6', '\x4', '\x1C7', '\t', '\x1C7', 
		'\x4', '\x1C8', '\t', '\x1C8', '\x4', '\x1C9', '\t', '\x1C9', '\x4', '\x1CA', 
		'\t', '\x1CA', '\x4', '\x1CB', '\t', '\x1CB', '\x4', '\x1CC', '\t', '\x1CC', 
		'\x4', '\x1CD', '\t', '\x1CD', '\x4', '\x1CE', '\t', '\x1CE', '\x4', '\x1CF', 
		'\t', '\x1CF', '\x4', '\x1D0', '\t', '\x1D0', '\x4', '\x1D1', '\t', '\x1D1', 
		'\x4', '\x1D2', '\t', '\x1D2', '\x4', '\x1D3', '\t', '\x1D3', '\x4', '\x1D4', 
		'\t', '\x1D4', '\x4', '\x1D5', '\t', '\x1D5', '\x4', '\x1D6', '\t', '\x1D6', 
		'\x4', '\x1D7', '\t', '\x1D7', '\x4', '\x1D8', '\t', '\x1D8', '\x4', '\x1D9', 
		'\t', '\x1D9', '\x4', '\x1DA', '\t', '\x1DA', '\x4', '\x1DB', '\t', '\x1DB', 
		'\x4', '\x1DC', '\t', '\x1DC', '\x4', '\x1DD', '\t', '\x1DD', '\x4', '\x1DE', 
		'\t', '\x1DE', '\x4', '\x1DF', '\t', '\x1DF', '\x4', '\x1E0', '\t', '\x1E0', 
		'\x4', '\x1E1', '\t', '\x1E1', '\x4', '\x1E2', '\t', '\x1E2', '\x4', '\x1E3', 
		'\t', '\x1E3', '\x4', '\x1E4', '\t', '\x1E4', '\x4', '\x1E5', '\t', '\x1E5', 
		'\x4', '\x1E6', '\t', '\x1E6', '\x4', '\x1E7', '\t', '\x1E7', '\x4', '\x1E8', 
		'\t', '\x1E8', '\x4', '\x1E9', '\t', '\x1E9', '\x4', '\x1EA', '\t', '\x1EA', 
		'\x4', '\x1EB', '\t', '\x1EB', '\x4', '\x1EC', '\t', '\x1EC', '\x4', '\x1ED', 
		'\t', '\x1ED', '\x4', '\x1EE', '\t', '\x1EE', '\x4', '\x1EF', '\t', '\x1EF', 
		'\x4', '\x1F0', '\t', '\x1F0', '\x4', '\x1F1', '\t', '\x1F1', '\x4', '\x1F2', 
		'\t', '\x1F2', '\x4', '\x1F3', '\t', '\x1F3', '\x4', '\x1F4', '\t', '\x1F4', 
		'\x4', '\x1F5', '\t', '\x1F5', '\x4', '\x1F6', '\t', '\x1F6', '\x4', '\x1F7', 
		'\t', '\x1F7', '\x4', '\x1F8', '\t', '\x1F8', '\x4', '\x1F9', '\t', '\x1F9', 
		'\x4', '\x1FA', '\t', '\x1FA', '\x4', '\x1FB', '\t', '\x1FB', '\x4', '\x1FC', 
		'\t', '\x1FC', '\x4', '\x1FD', '\t', '\x1FD', '\x4', '\x1FE', '\t', '\x1FE', 
		'\x4', '\x1FF', '\t', '\x1FF', '\x4', '\x200', '\t', '\x200', '\x4', '\x201', 
		'\t', '\x201', '\x4', '\x202', '\t', '\x202', '\x4', '\x203', '\t', '\x203', 
		'\x4', '\x204', '\t', '\x204', '\x4', '\x205', '\t', '\x205', '\x4', '\x206', 
		'\t', '\x206', '\x4', '\x207', '\t', '\x207', '\x4', '\x208', '\t', '\x208', 
		'\x4', '\x209', '\t', '\x209', '\x4', '\x20A', '\t', '\x20A', '\x4', '\x20B', 
		'\t', '\x20B', '\x4', '\x20C', '\t', '\x20C', '\x4', '\x20D', '\t', '\x20D', 
		'\x4', '\x20E', '\t', '\x20E', '\x4', '\x20F', '\t', '\x20F', '\x4', '\x210', 
		'\t', '\x210', '\x4', '\x211', '\t', '\x211', '\x4', '\x212', '\t', '\x212', 
		'\x4', '\x213', '\t', '\x213', '\x4', '\x214', '\t', '\x214', '\x4', '\x215', 
		'\t', '\x215', '\x4', '\x216', '\t', '\x216', '\x4', '\x217', '\t', '\x217', 
		'\x4', '\x218', '\t', '\x218', '\x4', '\x219', '\t', '\x219', '\x4', '\x21A', 
		'\t', '\x21A', '\x4', '\x21B', '\t', '\x21B', '\x4', '\x21C', '\t', '\x21C', 
		'\x4', '\x21D', '\t', '\x21D', '\x4', '\x21E', '\t', '\x21E', '\x4', '\x21F', 
		'\t', '\x21F', '\x4', '\x220', '\t', '\x220', '\x4', '\x221', '\t', '\x221', 
		'\x4', '\x222', '\t', '\x222', '\x4', '\x223', '\t', '\x223', '\x4', '\x224', 
		'\t', '\x224', '\x4', '\x225', '\t', '\x225', '\x4', '\x226', '\t', '\x226', 
		'\x4', '\x227', '\t', '\x227', '\x4', '\x228', '\t', '\x228', '\x4', '\x229', 
		'\t', '\x229', '\x4', '\x22A', '\t', '\x22A', '\x4', '\x22B', '\t', '\x22B', 
		'\x4', '\x22C', '\t', '\x22C', '\x4', '\x22D', '\t', '\x22D', '\x4', '\x22E', 
		'\t', '\x22E', '\x4', '\x22F', '\t', '\x22F', '\x4', '\x230', '\t', '\x230', 
		'\x4', '\x231', '\t', '\x231', '\x4', '\x232', '\t', '\x232', '\x4', '\x233', 
		'\t', '\x233', '\x4', '\x234', '\t', '\x234', '\x4', '\x235', '\t', '\x235', 
		'\x4', '\x236', '\t', '\x236', '\x4', '\x237', '\t', '\x237', '\x4', '\x238', 
		'\t', '\x238', '\x4', '\x239', '\t', '\x239', '\x4', '\x23A', '\t', '\x23A', 
		'\x4', '\x23B', '\t', '\x23B', '\x4', '\x23C', '\t', '\x23C', '\x4', '\x23D', 
		'\t', '\x23D', '\x4', '\x23E', '\t', '\x23E', '\x4', '\x23F', '\t', '\x23F', 
		'\x4', '\x240', '\t', '\x240', '\x4', '\x241', '\t', '\x241', '\x4', '\x242', 
		'\t', '\x242', '\x4', '\x243', '\t', '\x243', '\x4', '\x244', '\t', '\x244', 
		'\x4', '\x245', '\t', '\x245', '\x4', '\x246', '\t', '\x246', '\x4', '\x247', 
		'\t', '\x247', '\x4', '\x248', '\t', '\x248', '\x4', '\x249', '\t', '\x249', 
		'\x4', '\x24A', '\t', '\x24A', '\x4', '\x24B', '\t', '\x24B', '\x4', '\x24C', 
		'\t', '\x24C', '\x4', '\x24D', '\t', '\x24D', '\x4', '\x24E', '\t', '\x24E', 
		'\x4', '\x24F', '\t', '\x24F', '\x4', '\x250', '\t', '\x250', '\x4', '\x251', 
		'\t', '\x251', '\x4', '\x252', '\t', '\x252', '\x4', '\x253', '\t', '\x253', 
		'\x4', '\x254', '\t', '\x254', '\x4', '\x255', '\t', '\x255', '\x4', '\x256', 
		'\t', '\x256', '\x4', '\x257', '\t', '\x257', '\x4', '\x258', '\t', '\x258', 
		'\x4', '\x259', '\t', '\x259', '\x4', '\x25A', '\t', '\x25A', '\x4', '\x25B', 
		'\t', '\x25B', '\x4', '\x25C', '\t', '\x25C', '\x4', '\x25D', '\t', '\x25D', 
		'\x4', '\x25E', '\t', '\x25E', '\x4', '\x25F', '\t', '\x25F', '\x4', '\x260', 
		'\t', '\x260', '\x4', '\x261', '\t', '\x261', '\x4', '\x262', '\t', '\x262', 
		'\x4', '\x263', '\t', '\x263', '\x4', '\x264', '\t', '\x264', '\x4', '\x265', 
		'\t', '\x265', '\x4', '\x266', '\t', '\x266', '\x4', '\x267', '\t', '\x267', 
		'\x4', '\x268', '\t', '\x268', '\x4', '\x269', '\t', '\x269', '\x4', '\x26A', 
		'\t', '\x26A', '\x4', '\x26B', '\t', '\x26B', '\x4', '\x26C', '\t', '\x26C', 
		'\x4', '\x26D', '\t', '\x26D', '\x4', '\x26E', '\t', '\x26E', '\x4', '\x26F', 
		'\t', '\x26F', '\x4', '\x270', '\t', '\x270', '\x4', '\x271', '\t', '\x271', 
		'\x4', '\x272', '\t', '\x272', '\x4', '\x273', '\t', '\x273', '\x4', '\x274', 
		'\t', '\x274', '\x4', '\x275', '\t', '\x275', '\x4', '\x276', '\t', '\x276', 
		'\x4', '\x277', '\t', '\x277', '\x4', '\x278', '\t', '\x278', '\x4', '\x279', 
		'\t', '\x279', '\x4', '\x27A', '\t', '\x27A', '\x4', '\x27B', '\t', '\x27B', 
		'\x4', '\x27C', '\t', '\x27C', '\x4', '\x27D', '\t', '\x27D', '\x4', '\x27E', 
		'\t', '\x27E', '\x4', '\x27F', '\t', '\x27F', '\x4', '\x280', '\t', '\x280', 
		'\x4', '\x281', '\t', '\x281', '\x4', '\x282', '\t', '\x282', '\x4', '\x283', 
		'\t', '\x283', '\x4', '\x284', '\t', '\x284', '\x4', '\x285', '\t', '\x285', 
		'\x4', '\x286', '\t', '\x286', '\x4', '\x287', '\t', '\x287', '\x4', '\x288', 
		'\t', '\x288', '\x4', '\x289', '\t', '\x289', '\x4', '\x28A', '\t', '\x28A', 
		'\x4', '\x28B', '\t', '\x28B', '\x4', '\x28C', '\t', '\x28C', '\x4', '\x28D', 
		'\t', '\x28D', '\x4', '\x28E', '\t', '\x28E', '\x4', '\x28F', '\t', '\x28F', 
		'\x4', '\x290', '\t', '\x290', '\x4', '\x291', '\t', '\x291', '\x4', '\x292', 
		'\t', '\x292', '\x4', '\x293', '\t', '\x293', '\x4', '\x294', '\t', '\x294', 
		'\x4', '\x295', '\t', '\x295', '\x4', '\x296', '\t', '\x296', '\x4', '\x297', 
		'\t', '\x297', '\x4', '\x298', '\t', '\x298', '\x4', '\x299', '\t', '\x299', 
		'\x4', '\x29A', '\t', '\x29A', '\x4', '\x29B', '\t', '\x29B', '\x4', '\x29C', 
		'\t', '\x29C', '\x4', '\x29D', '\t', '\x29D', '\x4', '\x29E', '\t', '\x29E', 
		'\x4', '\x29F', '\t', '\x29F', '\x4', '\x2A0', '\t', '\x2A0', '\x4', '\x2A1', 
		'\t', '\x2A1', '\x4', '\x2A2', '\t', '\x2A2', '\x4', '\x2A3', '\t', '\x2A3', 
		'\x4', '\x2A4', '\t', '\x2A4', '\x4', '\x2A5', '\t', '\x2A5', '\x4', '\x2A6', 
		'\t', '\x2A6', '\x4', '\x2A7', '\t', '\x2A7', '\x4', '\x2A8', '\t', '\x2A8', 
		'\x4', '\x2A9', '\t', '\x2A9', '\x4', '\x2AA', '\t', '\x2AA', '\x4', '\x2AB', 
		'\t', '\x2AB', '\x4', '\x2AC', '\t', '\x2AC', '\x4', '\x2AD', '\t', '\x2AD', 
		'\x4', '\x2AE', '\t', '\x2AE', '\x4', '\x2AF', '\t', '\x2AF', '\x4', '\x2B0', 
		'\t', '\x2B0', '\x4', '\x2B1', '\t', '\x2B1', '\x4', '\x2B2', '\t', '\x2B2', 
		'\x4', '\x2B3', '\t', '\x2B3', '\x4', '\x2B4', '\t', '\x2B4', '\x4', '\x2B5', 
		'\t', '\x2B5', '\x4', '\x2B6', '\t', '\x2B6', '\x4', '\x2B7', '\t', '\x2B7', 
		'\x4', '\x2B8', '\t', '\x2B8', '\x4', '\x2B9', '\t', '\x2B9', '\x4', '\x2BA', 
		'\t', '\x2BA', '\x4', '\x2BB', '\t', '\x2BB', '\x4', '\x2BC', '\t', '\x2BC', 
		'\x4', '\x2BD', '\t', '\x2BD', '\x4', '\x2BE', '\t', '\x2BE', '\x4', '\x2BF', 
		'\t', '\x2BF', '\x4', '\x2C0', '\t', '\x2C0', '\x4', '\x2C1', '\t', '\x2C1', 
		'\x4', '\x2C2', '\t', '\x2C2', '\x4', '\x2C3', '\t', '\x2C3', '\x4', '\x2C4', 
		'\t', '\x2C4', '\x4', '\x2C5', '\t', '\x2C5', '\x4', '\x2C6', '\t', '\x2C6', 
		'\x4', '\x2C7', '\t', '\x2C7', '\x4', '\x2C8', '\t', '\x2C8', '\x4', '\x2C9', 
		'\t', '\x2C9', '\x4', '\x2CA', '\t', '\x2CA', '\x4', '\x2CB', '\t', '\x2CB', 
		'\x4', '\x2CC', '\t', '\x2CC', '\x4', '\x2CD', '\t', '\x2CD', '\x4', '\x2CE', 
		'\t', '\x2CE', '\x4', '\x2CF', '\t', '\x2CF', '\x4', '\x2D0', '\t', '\x2D0', 
		'\x4', '\x2D1', '\t', '\x2D1', '\x4', '\x2D2', '\t', '\x2D2', '\x4', '\x2D3', 
		'\t', '\x2D3', '\x4', '\x2D4', '\t', '\x2D4', '\x4', '\x2D5', '\t', '\x2D5', 
		'\x4', '\x2D6', '\t', '\x2D6', '\x4', '\x2D7', '\t', '\x2D7', '\x4', '\x2D8', 
		'\t', '\x2D8', '\x4', '\x2D9', '\t', '\x2D9', '\x4', '\x2DA', '\t', '\x2DA', 
		'\x4', '\x2DB', '\t', '\x2DB', '\x4', '\x2DC', '\t', '\x2DC', '\x4', '\x2DD', 
		'\t', '\x2DD', '\x4', '\x2DE', '\t', '\x2DE', '\x4', '\x2DF', '\t', '\x2DF', 
		'\x4', '\x2E0', '\t', '\x2E0', '\x4', '\x2E1', '\t', '\x2E1', '\x4', '\x2E2', 
		'\t', '\x2E2', '\x4', '\x2E3', '\t', '\x2E3', '\x4', '\x2E4', '\t', '\x2E4', 
		'\x4', '\x2E5', '\t', '\x2E5', '\x4', '\x2E6', '\t', '\x2E6', '\x4', '\x2E7', 
		'\t', '\x2E7', '\x4', '\x2E8', '\t', '\x2E8', '\x4', '\x2E9', '\t', '\x2E9', 
		'\x4', '\x2EA', '\t', '\x2EA', '\x4', '\x2EB', '\t', '\x2EB', '\x4', '\x2EC', 
		'\t', '\x2EC', '\x4', '\x2ED', '\t', '\x2ED', '\x4', '\x2EE', '\t', '\x2EE', 
		'\x4', '\x2EF', '\t', '\x2EF', '\x4', '\x2F0', '\t', '\x2F0', '\x4', '\x2F1', 
		'\t', '\x2F1', '\x4', '\x2F2', '\t', '\x2F2', '\x4', '\x2F3', '\t', '\x2F3', 
		'\x4', '\x2F4', '\t', '\x2F4', '\x4', '\x2F5', '\t', '\x2F5', '\x4', '\x2F6', 
		'\t', '\x2F6', '\x4', '\x2F7', '\t', '\x2F7', '\x4', '\x2F8', '\t', '\x2F8', 
		'\x4', '\x2F9', '\t', '\x2F9', '\x4', '\x2FA', '\t', '\x2FA', '\x4', '\x2FB', 
		'\t', '\x2FB', '\x4', '\x2FC', '\t', '\x2FC', '\x4', '\x2FD', '\t', '\x2FD', 
		'\x4', '\x2FE', '\t', '\x2FE', '\x4', '\x2FF', '\t', '\x2FF', '\x4', '\x300', 
		'\t', '\x300', '\x4', '\x301', '\t', '\x301', '\x4', '\x302', '\t', '\x302', 
		'\x4', '\x303', '\t', '\x303', '\x4', '\x304', '\t', '\x304', '\x4', '\x305', 
		'\t', '\x305', '\x4', '\x306', '\t', '\x306', '\x4', '\x307', '\t', '\x307', 
		'\x4', '\x308', '\t', '\x308', '\x4', '\x309', '\t', '\x309', '\x4', '\x30A', 
		'\t', '\x30A', '\x4', '\x30B', '\t', '\x30B', '\x4', '\x30C', '\t', '\x30C', 
		'\x4', '\x30D', '\t', '\x30D', '\x4', '\x30E', '\t', '\x30E', '\x4', '\x30F', 
		'\t', '\x30F', '\x4', '\x310', '\t', '\x310', '\x4', '\x311', '\t', '\x311', 
		'\x4', '\x312', '\t', '\x312', '\x4', '\x313', '\t', '\x313', '\x4', '\x314', 
		'\t', '\x314', '\x4', '\x315', '\t', '\x315', '\x4', '\x316', '\t', '\x316', 
		'\x4', '\x317', '\t', '\x317', '\x4', '\x318', '\t', '\x318', '\x4', '\x319', 
		'\t', '\x319', '\x4', '\x31A', '\t', '\x31A', '\x4', '\x31B', '\t', '\x31B', 
		'\x4', '\x31C', '\t', '\x31C', '\x4', '\x31D', '\t', '\x31D', '\x4', '\x31E', 
		'\t', '\x31E', '\x4', '\x31F', '\t', '\x31F', '\x4', '\x320', '\t', '\x320', 
		'\x4', '\x321', '\t', '\x321', '\x4', '\x322', '\t', '\x322', '\x4', '\x323', 
		'\t', '\x323', '\x4', '\x324', '\t', '\x324', '\x4', '\x325', '\t', '\x325', 
		'\x4', '\x326', '\t', '\x326', '\x4', '\x327', '\t', '\x327', '\x4', '\x328', 
		'\t', '\x328', '\x4', '\x329', '\t', '\x329', '\x4', '\x32A', '\t', '\x32A', 
		'\x4', '\x32B', '\t', '\x32B', '\x4', '\x32C', '\t', '\x32C', '\x4', '\x32D', 
		'\t', '\x32D', '\x4', '\x32E', '\t', '\x32E', '\x4', '\x32F', '\t', '\x32F', 
		'\x4', '\x330', '\t', '\x330', '\x4', '\x331', '\t', '\x331', '\x4', '\x332', 
		'\t', '\x332', '\x4', '\x333', '\t', '\x333', '\x4', '\x334', '\t', '\x334', 
		'\x4', '\x335', '\t', '\x335', '\x4', '\x336', '\t', '\x336', '\x4', '\x337', 
		'\t', '\x337', '\x4', '\x338', '\t', '\x338', '\x4', '\x339', '\t', '\x339', 
		'\x4', '\x33A', '\t', '\x33A', '\x4', '\x33B', '\t', '\x33B', '\x4', '\x33C', 
		'\t', '\x33C', '\x4', '\x33D', '\t', '\x33D', '\x4', '\x33E', '\t', '\x33E', 
		'\x4', '\x33F', '\t', '\x33F', '\x4', '\x340', '\t', '\x340', '\x4', '\x341', 
		'\t', '\x341', '\x4', '\x342', '\t', '\x342', '\x4', '\x343', '\t', '\x343', 
		'\x4', '\x344', '\t', '\x344', '\x4', '\x345', '\t', '\x345', '\x4', '\x346', 
		'\t', '\x346', '\x4', '\x347', '\t', '\x347', '\x4', '\x348', '\t', '\x348', 
		'\x4', '\x349', '\t', '\x349', '\x4', '\x34A', '\t', '\x34A', '\x4', '\x34B', 
		'\t', '\x34B', '\x4', '\x34C', '\t', '\x34C', '\x4', '\x34D', '\t', '\x34D', 
		'\x4', '\x34E', '\t', '\x34E', '\x4', '\x34F', '\t', '\x34F', '\x4', '\x350', 
		'\t', '\x350', '\x4', '\x351', '\t', '\x351', '\x4', '\x352', '\t', '\x352', 
		'\x4', '\x353', '\t', '\x353', '\x4', '\x354', '\t', '\x354', '\x4', '\x355', 
		'\t', '\x355', '\x4', '\x356', '\t', '\x356', '\x4', '\x357', '\t', '\x357', 
		'\x4', '\x358', '\t', '\x358', '\x4', '\x359', '\t', '\x359', '\x3', '\x2', 
		'\x3', '\x2', '\x3', '\x3', '\x3', '\x3', '\x3', '\x4', '\x3', '\x4', 
		'\x3', '\x5', '\x3', '\x5', '\x5', '\x5', '\x6BB', '\n', '\x5', '\x3', 
		'\x6', '\x3', '\x6', '\x3', '\a', '\x3', '\a', '\x3', '\b', '\a', '\b', 
		'\x6C2', '\n', '\b', '\f', '\b', '\xE', '\b', '\x6C5', '\v', '\b', '\x3', 
		'\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', 
		'\x3', '\t', '\x3', '\t', '\x3', '\t', '\x5', '\t', '\x6D0', '\n', '\t', 
		'\x3', '\t', '\x5', '\t', '\x6D3', '\n', '\t', '\x3', '\n', '\x3', '\n', 
		'\x5', '\n', '\x6D7', '\n', '\n', '\x3', '\n', '\x3', '\n', '\x3', '\n', 
		'\a', '\n', '\x6DC', '\n', '\n', '\f', '\n', '\xE', '\n', '\x6DF', '\v', 
		'\n', '\x3', '\n', '\x3', '\n', '\x3', '\v', '\x3', '\v', '\a', '\v', 
		'\x6E5', '\n', '\v', '\f', '\v', '\xE', '\v', '\x6E8', '\v', '\v', '\x3', 
		'\v', '\x3', '\v', '\x3', '\f', '\x3', '\f', '\x3', '\f', '\x3', '\r', 
		'\x3', '\r', '\x3', '\r', '\a', '\r', '\x6F2', '\n', '\r', '\f', '\r', 
		'\xE', '\r', '\x6F5', '\v', '\r', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', 
		'\x5', '\xE', '\x6FA', '\n', '\xE', '\x5', '\xE', '\x6FC', '\n', '\xE', 
		'\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x5', '\xF', 
		'\x702', '\n', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', 
		'\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', 
		'\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', 
		'\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x5', 
		'\xF', '\x716', '\n', '\xF', '\x5', '\xF', '\x718', '\n', '\xF', '\x3', 
		'\x10', '\x3', '\x10', '\a', '\x10', '\x71C', '\n', '\x10', '\f', '\x10', 
		'\xE', '\x10', '\x71F', '\v', '\x10', '\x3', '\x11', '\x5', '\x11', '\x722', 
		'\n', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', 
		'\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', 
		'\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', 
		'\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', 
		'\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', 
		'\x3', '\x11', '\x3', '\x11', '\x5', '\x11', '\x73E', '\n', '\x11', '\x3', 
		'\x11', '\x3', '\x11', '\x3', '\x12', '\x3', '\x12', '\x5', '\x12', '\x744', 
		'\n', '\x12', '\x3', '\x12', '\x5', '\x12', '\x747', '\n', '\x12', '\x3', 
		'\x12', '\x3', '\x12', '\a', '\x12', '\x74B', '\n', '\x12', '\f', '\x12', 
		'\xE', '\x12', '\x74E', '\v', '\x12', '\x3', '\x13', '\x3', '\x13', '\x5', 
		'\x13', '\x752', '\n', '\x13', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', 
		'\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', 
		'\x3', '\x14', '\x3', '\x14', '\x5', '\x14', '\x75E', '\n', '\x14', '\x3', 
		'\x15', '\x3', '\x15', '\x3', '\x16', '\x3', '\x16', '\x3', '\x17', '\x3', 
		'\x17', '\x3', '\x18', '\x3', '\x18', '\x3', '\x19', '\x3', '\x19', '\x3', 
		'\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1B', '\x3', '\x1B', '\x3', 
		'\x1B', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', 
		'\x1C', '\x5', '\x1C', '\x775', '\n', '\x1C', '\x3', '\x1D', '\x3', '\x1D', 
		'\x5', '\x1D', '\x779', '\n', '\x1D', '\x3', '\x1E', '\x3', '\x1E', '\x3', 
		'\x1E', '\x3', '\x1E', '\x5', '\x1E', '\x77F', '\n', '\x1E', '\x3', '\x1E', 
		'\x3', '\x1E', '\x3', '\x1F', '\x3', '\x1F', '\x3', ' ', '\x3', ' ', '\x5', 
		' ', '\x787', '\n', ' ', '\x3', '!', '\x3', '!', '\x3', '\"', '\x3', '\"', 
		'\x3', '\"', '\x3', '\"', '\x5', '\"', '\x78F', '\n', '\"', '\x3', '\"', 
		'\a', '\"', '\x792', '\n', '\"', '\f', '\"', '\xE', '\"', '\x795', '\v', 
		'\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x5', '\"', '\x79A', '\n', 
		'\"', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\a', '#', '\x7A0', 
		'\n', '#', '\f', '#', '\xE', '#', '\x7A3', '\v', '#', '\x3', '$', '\x3', 
		'$', '\x3', '$', '\x3', '$', '\a', '$', '\x7A9', '\n', '$', '\f', '$', 
		'\xE', '$', '\x7AC', '\v', '$', '\x3', '$', '\x5', '$', '\x7AF', '\n', 
		'$', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x6', '%', '\x7B5', 
		'\n', '%', '\r', '%', '\xE', '%', '\x7B6', '\x3', '&', '\x3', '&', '\x3', 
		'\'', '\x3', '\'', '\x3', '\'', '\x5', '\'', '\x7BE', '\n', '\'', '\x3', 
		'\'', '\x3', '\'', '\x3', '\'', '\x5', '\'', '\x7C3', '\n', '\'', '\a', 
		'\'', '\x7C5', '\n', '\'', '\f', '\'', '\xE', '\'', '\x7C8', '\v', '\'', 
		'\x3', '(', '\x3', '(', '\x5', '(', '\x7CC', '\n', '(', '\x3', '(', '\x5', 
		'(', '\x7CF', '\n', '(', '\x3', '(', '\x5', '(', '\x7D2', '\n', '(', '\x3', 
		')', '\x3', ')', '\x3', '*', '\x3', '*', '\x3', '+', '\x3', '+', '\x3', 
		'+', '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', '\a', '+', '\x7DF', 
		'\n', '+', '\f', '+', '\xE', '+', '\x7E2', '\v', '+', '\x3', ',', '\x3', 
		',', '\x5', ',', '\x7E6', '\n', ',', '\x3', '-', '\x3', '-', '\x5', '-', 
		'\x7EA', '\n', '-', '\x3', '-', '\x5', '-', '\x7ED', '\n', '-', '\x3', 
		'-', '\x3', '-', '\x3', '.', '\x3', '.', '\x5', '.', '\x7F3', '\n', '.', 
		'\x3', '/', '\x3', '/', '\x5', '/', '\x7F7', '\n', '/', '\x3', '/', '\x5', 
		'/', '\x7FA', '\n', '/', '\x3', '\x30', '\x3', '\x30', '\x3', '\x31', 
		'\x3', '\x31', '\x3', '\x31', '\x3', '\x31', '\x3', '\x31', '\x3', '\x31', 
		'\x3', '\x31', '\x3', '\x31', '\x3', '\x31', '\x3', '\x31', '\x3', '\x31', 
		'\x3', '\x31', '\x3', '\x31', '\x3', '\x31', '\x5', '\x31', '\x80C', '\n', 
		'\x31', '\x3', '\x31', '\x5', '\x31', '\x80F', '\n', '\x31', '\x3', '\x32', 
		'\x3', '\x32', '\x5', '\x32', '\x813', '\n', '\x32', '\x3', '\x33', '\x3', 
		'\x33', '\x5', '\x33', '\x817', '\n', '\x33', '\x3', '\x34', '\x3', '\x34', 
		'\x5', '\x34', '\x81B', '\n', '\x34', '\x3', '\x35', '\x3', '\x35', '\x5', 
		'\x35', '\x81F', '\n', '\x35', '\x3', '\x36', '\x3', '\x36', '\x5', '\x36', 
		'\x823', '\n', '\x36', '\x3', '\x37', '\x3', '\x37', '\x5', '\x37', '\x827', 
		'\n', '\x37', '\x3', '\x38', '\x3', '\x38', '\x5', '\x38', '\x82B', '\n', 
		'\x38', '\x3', '\x39', '\x3', '\x39', '\x5', '\x39', '\x82F', '\n', '\x39', 
		'\x3', ':', '\x3', ':', '\x5', ':', '\x833', '\n', ':', '\x3', ';', '\x3', 
		';', '\x3', ';', '\x3', '<', '\x3', '<', '\x3', '<', '\x5', '<', '\x83B', 
		'\n', '<', '\x3', '=', '\x3', '=', '\x5', '=', '\x83F', '\n', '=', '\x3', 
		'=', '\x5', '=', '\x842', '\n', '=', '\x3', '=', '\x5', '=', '\x845', 
		'\n', '=', '\x3', '>', '\x3', '>', '\x3', '>', '\x5', '>', '\x84A', '\n', 
		'>', '\x3', '>', '\x5', '>', '\x84D', '\n', '>', '\x3', '>', '\x5', '>', 
		'\x850', '\n', '>', '\x3', '?', '\x3', '?', '\x5', '?', '\x854', '\n', 
		'?', '\x3', '?', '\x5', '?', '\x857', '\n', '?', '\x3', '?', '\x5', '?', 
		'\x85A', '\n', '?', '\x3', '@', '\x3', '@', '\x5', '@', '\x85E', '\n', 
		'@', '\x3', '@', '\x5', '@', '\x861', '\n', '@', '\x3', '\x41', '\x3', 
		'\x41', '\x5', '\x41', '\x865', '\n', '\x41', '\x3', '\x41', '\x5', '\x41', 
		'\x868', '\n', '\x41', '\x3', '\x42', '\x3', '\x42', '\x5', '\x42', '\x86C', 
		'\n', '\x42', '\x3', '\x42', '\x5', '\x42', '\x86F', '\n', '\x42', '\x3', 
		'\x43', '\x3', '\x43', '\x5', '\x43', '\x873', '\n', '\x43', '\x3', '\x43', 
		'\x5', '\x43', '\x876', '\n', '\x43', '\x3', '\x44', '\x3', '\x44', '\x3', 
		'\x44', '\x5', '\x44', '\x87B', '\n', '\x44', '\x3', '\x44', '\x3', '\x44', 
		'\x3', '\x45', '\x3', '\x45', '\x5', '\x45', '\x881', '\n', '\x45', '\x3', 
		'\x45', '\x3', '\x45', '\x5', '\x45', '\x885', '\n', '\x45', '\x3', '\x45', 
		'\x3', '\x45', '\x3', '\x45', '\x5', '\x45', '\x88A', '\n', '\x45', '\x3', 
		'\x46', '\x3', '\x46', '\x3', '\x46', '\x3', '\x46', '\x3', '\x46', '\x3', 
		'G', '\x3', 'G', '\x3', 'G', '\x3', 'G', '\x3', 'G', '\x3', 'G', '\x3', 
		'G', '\x5', 'G', '\x898', '\n', 'G', '\x3', 'H', '\x3', 'H', '\x3', 'H', 
		'\x3', 'I', '\x3', 'I', '\x3', 'I', '\x5', 'I', '\x8A0', '\n', 'I', '\x3', 
		'J', '\x3', 'J', '\x3', 'J', '\x5', 'J', '\x8A5', '\n', 'J', '\x3', 'K', 
		'\x3', 'K', '\x3', 'K', '\x3', 'K', '\x5', 'K', '\x8AB', '\n', 'K', '\x3', 
		'L', '\x3', 'L', '\x3', 'L', '\x3', 'M', '\x3', 'M', '\x3', 'M', '\x3', 
		'M', '\x3', 'M', '\x3', 'N', '\x3', 'N', '\x3', 'O', '\x3', 'O', '\x3', 
		'O', '\x3', 'P', '\x3', 'P', '\x3', 'P', '\x3', 'Q', '\x3', 'Q', '\x3', 
		'R', '\x3', 'R', '\x3', 'R', '\a', 'R', '\x8C2', '\n', 'R', '\f', 'R', 
		'\xE', 'R', '\x8C5', '\v', 'R', '\x3', 'S', '\x3', 'S', '\x3', 'S', '\a', 
		'S', '\x8CA', '\n', 'S', '\f', 'S', '\xE', 'S', '\x8CD', '\v', 'S', '\x3', 
		'T', '\x5', 'T', '\x8D0', '\n', 'T', '\x3', 'T', '\x3', 'T', '\x5', 'T', 
		'\x8D4', '\n', 'T', '\x3', 'U', '\x3', 'U', '\x3', 'U', '\x3', 'U', '\x3', 
		'U', '\x3', 'U', '\x3', 'U', '\x5', 'U', '\x8DD', '\n', 'U', '\x3', 'V', 
		'\x3', 'V', '\x3', 'V', '\x3', 'W', '\x3', 'W', '\x3', 'X', '\x3', 'X', 
		'\x3', 'X', '\x3', 'X', '\x3', 'X', '\x5', 'X', '\x8E9', '\n', 'X', '\x3', 
		'X', '\x3', 'X', '\x5', 'X', '\x8ED', '\n', 'X', '\x3', 'X', '\x5', 'X', 
		'\x8F0', '\n', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x5', 'X', '\x8F5', 
		'\n', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', 
		'\x3', 'X', '\x3', 'X', '\x5', 'X', '\x8FE', '\n', 'X', '\x3', 'X', '\x3', 
		'X', '\x3', 'X', '\x5', 'X', '\x903', '\n', 'X', '\x3', 'X', '\x3', 'X', 
		'\x3', 'X', '\x5', 'X', '\x908', '\n', 'X', '\x3', 'X', '\x5', 'X', '\x90B', 
		'\n', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', 
		'\x3', 'X', '\x3', 'X', '\x5', 'X', '\x914', '\n', 'X', '\x5', 'X', '\x916', 
		'\n', 'X', '\x3', 'Y', '\x3', 'Y', '\x3', 'Z', '\x3', 'Z', '\x3', '[', 
		'\x3', '[', '\x3', '\\', '\x3', '\\', '\x3', ']', '\x3', ']', '\x3', '^', 
		'\x3', '^', '\x3', '_', '\x3', '_', '\x3', '`', '\x3', '`', '\x3', '\x61', 
		'\x3', '\x61', '\x3', '\x62', '\x3', '\x62', '\x5', '\x62', '\x92C', '\n', 
		'\x62', '\x3', '\x62', '\x3', '\x62', '\x5', '\x62', '\x930', '\n', '\x62', 
		'\x3', '\x62', '\x3', '\x62', '\x3', '\x63', '\x3', '\x63', '\x5', '\x63', 
		'\x936', '\n', '\x63', '\x3', '\x63', '\x3', '\x63', '\x3', '\x63', '\a', 
		'\x63', '\x93B', '\n', '\x63', '\f', '\x63', '\xE', '\x63', '\x93E', '\v', 
		'\x63', '\x3', '\x63', '\x3', '\x63', '\x3', '\x64', '\x3', '\x64', '\x5', 
		'\x64', '\x944', '\n', '\x64', '\x3', '\x65', '\x3', '\x65', '\x3', '\x65', 
		'\x3', '\x65', '\a', '\x65', '\x94A', '\n', '\x65', '\f', '\x65', '\xE', 
		'\x65', '\x94D', '\v', '\x65', '\x3', '\x66', '\x3', '\x66', '\x3', '\x66', 
		'\x3', '\x66', '\a', '\x66', '\x953', '\n', '\x66', '\f', '\x66', '\xE', 
		'\x66', '\x956', '\v', '\x66', '\x3', 'g', '\x3', 'g', '\x3', 'h', '\x3', 
		'h', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 
		'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 
		'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 
		'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 
		'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 
		'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x5', 
		'i', '\x97F', '\n', 'i', '\x3', 'i', '\x5', 'i', '\x982', '\n', 'i', '\x3', 
		'j', '\x3', 'j', '\x3', 'k', '\x3', 'k', '\x3', 'k', '\x3', 'k', '\x3', 
		'k', '\x3', 'k', '\x5', 'k', '\x98C', '\n', 'k', '\x3', 'k', '\x3', 'k', 
		'\x3', 'k', '\x3', 'k', '\x3', 'k', '\x3', 'l', '\x3', 'l', '\x3', 'l', 
		'\a', 'l', '\x996', '\n', 'l', '\f', 'l', '\xE', 'l', '\x999', '\v', 'l', 
		'\x3', 'm', '\x3', 'm', '\x3', 'm', '\x5', 'm', '\x99E', '\n', 'm', '\x3', 
		'n', '\x3', 'n', '\x3', 'n', '\x3', 'n', '\x3', 'n', '\x5', 'n', '\x9A5', 
		'\n', 'n', '\x3', 'n', '\x3', 'n', '\x3', 'n', '\x3', 'n', '\x3', 'o', 
		'\x3', 'o', '\x3', 'o', '\x3', 'p', '\x3', 'p', '\x3', 'p', '\x5', 'p', 
		'\x9B1', '\n', 'p', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 
		'q', '\x3', 'r', '\x3', 'r', '\x5', 'r', '\x9BA', '\n', 'r', '\x3', 'r', 
		'\x3', 'r', '\x3', 's', '\x3', 's', '\x3', 's', '\x3', 't', '\x3', 't', 
		'\x3', 't', '\x3', 't', '\a', 't', '\x9C5', '\n', 't', '\f', 't', '\xE', 
		't', '\x9C8', '\v', 't', '\x3', 'u', '\x3', 'u', '\x3', 'u', '\x5', 'u', 
		'\x9CD', '\n', 'u', '\x3', 'v', '\x3', 'v', '\x3', 'v', '\x5', 'v', '\x9D2', 
		'\n', 'v', '\x3', 'w', '\x3', 'w', '\x3', 'x', '\x3', 'x', '\x3', 'x', 
		'\x3', 'x', '\x3', 'x', '\x5', 'x', '\x9DB', '\n', 'x', '\x3', 'y', '\x3', 
		'y', '\x3', 'y', '\x5', 'y', '\x9E0', '\n', 'y', '\x3', 'z', '\x3', 'z', 
		'\x3', 'z', '\x3', 'z', '\x3', 'z', '\x3', 'z', '\x3', 'z', '\x3', '{', 
		'\x3', '{', '\x3', '{', '\x5', '{', '\x9EC', '\n', '{', '\x3', '|', '\x3', 
		'|', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '}', '\x3', 
		'}', '\x3', '}', '\x3', '~', '\x3', '~', '\x3', '~', '\x5', '~', '\x9FA', 
		'\n', '~', '\x3', '~', '\x3', '~', '\x5', '~', '\x9FE', '\n', '~', '\x5', 
		'~', '\xA00', '\n', '~', '\x3', '~', '\x3', '~', '\x3', '\x7F', '\x3', 
		'\x7F', '\x3', '\x7F', '\x3', '\x7F', '\x3', '\x80', '\x3', '\x80', '\x3', 
		'\x80', '\x5', '\x80', '\xA0B', '\n', '\x80', '\x3', '\x81', '\x3', '\x81', 
		'\x3', '\x81', '\x3', '\x81', '\x3', '\x81', '\x3', '\x82', '\x3', '\x82', 
		'\x3', '\x83', '\x3', '\x83', '\x3', '\x83', '\x3', '\x83', '\x3', '\x83', 
		'\x3', '\x83', '\x3', '\x83', '\x5', '\x83', '\xA1B', '\n', '\x83', '\x3', 
		'\x84', '\x3', '\x84', '\x3', '\x85', '\x3', '\x85', '\x3', '\x85', '\x3', 
		'\x85', '\x3', '\x86', '\x3', '\x86', '\x3', '\x86', '\x3', '\x86', '\x5', 
		'\x86', '\xA27', '\n', '\x86', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', 
		'\x3', '\x87', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', '\x5', '\x87', 
		'\xA30', '\n', '\x87', '\x3', '\x88', '\x3', '\x88', '\x3', '\x88', '\x3', 
		'\x89', '\x3', '\x89', '\x3', '\x89', '\x3', '\x89', '\x3', '\x8A', '\x3', 
		'\x8A', '\x3', '\x8A', '\x5', '\x8A', '\xA3C', '\n', '\x8A', '\x3', '\x8B', 
		'\x3', '\x8B', '\x3', '\x8C', '\x3', '\x8C', '\x3', '\x8D', '\x3', '\x8D', 
		'\x3', '\x8E', '\x3', '\x8E', '\x3', '\x8E', '\x5', '\x8E', '\xA47', '\n', 
		'\x8E', '\x3', '\x8F', '\x3', '\x8F', '\x3', '\x8F', '\x3', '\x8F', '\x3', 
		'\x8F', '\x5', '\x8F', '\xA4E', '\n', '\x8F', '\x3', '\x8F', '\x3', '\x8F', 
		'\x3', '\x8F', '\x3', '\x8F', '\x3', '\x90', '\x3', '\x90', '\x3', '\x90', 
		'\x3', '\x90', '\x3', '\x90', '\x3', '\x91', '\x3', '\x91', '\x3', '\x91', 
		'\x5', '\x91', '\xA5C', '\n', '\x91', '\x3', '\x91', '\x3', '\x91', '\x3', 
		'\x92', '\x3', '\x92', '\x6', '\x92', '\xA62', '\n', '\x92', '\r', '\x92', 
		'\xE', '\x92', '\xA63', '\x3', '\x92', '\x5', '\x92', '\xA67', '\n', '\x92', 
		'\x3', '\x93', '\x3', '\x93', '\x3', '\x93', '\x3', '\x93', '\x3', '\x93', 
		'\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x95', '\x6', '\x95', 
		'\xA72', '\n', '\x95', '\r', '\x95', '\xE', '\x95', '\xA73', '\x3', '\x95', 
		'\x5', '\x95', '\xA77', '\n', '\x95', '\x3', '\x96', '\x3', '\x96', '\x3', 
		'\x96', '\x3', '\x96', '\x3', '\x96', '\x3', '\x97', '\x3', '\x97', '\x3', 
		'\x97', '\x3', '\x98', '\x3', '\x98', '\x3', '\x98', '\x3', '\x99', '\x3', 
		'\x99', '\x3', '\x99', '\x3', '\x9A', '\x3', '\x9A', '\x3', '\x9A', '\x5', 
		'\x9A', '\xA8A', '\n', '\x9A', '\x3', '\x9A', '\x3', '\x9A', '\x3', '\x9A', 
		'\x3', '\x9B', '\x3', '\x9B', '\x5', '\x9B', '\xA91', '\n', '\x9B', '\x3', 
		'\x9B', '\x5', '\x9B', '\xA94', '\n', '\x9B', '\x3', '\x9B', '\x3', '\x9B', 
		'\x3', '\x9C', '\x3', '\x9C', '\x3', '\x9C', '\x3', '\x9C', '\x3', '\x9C', 
		'\a', '\x9C', '\xA9D', '\n', '\x9C', '\f', '\x9C', '\xE', '\x9C', '\xAA0', 
		'\v', '\x9C', '\x3', '\x9C', '\x3', '\x9C', '\x3', '\x9D', '\x3', '\x9D', 
		'\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9E', 
		'\x3', '\x9E', '\x3', '\x9E', '\x3', '\x9E', '\x3', '\x9E', '\x3', '\x9E', 
		'\x3', '\x9E', '\x5', '\x9E', '\xAB1', '\n', '\x9E', '\x3', '\x9E', '\x3', 
		'\x9E', '\x3', '\x9F', '\x3', '\x9F', '\x3', '\xA0', '\x3', '\xA0', '\x3', 
		'\xA1', '\x3', '\xA1', '\x3', '\xA2', '\x3', '\xA2', '\x5', '\xA2', '\xABD', 
		'\n', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA3', '\x3', '\xA3', 
		'\x3', '\xA4', '\x3', '\xA4', '\x3', '\xA4', '\x3', '\xA4', '\x3', '\xA4', 
		'\x5', '\xA4', '\xAC8', '\n', '\xA4', '\x3', '\xA4', '\x3', '\xA4', '\x5', 
		'\xA4', '\xACC', '\n', '\xA4', '\x3', '\xA4', '\x3', '\xA4', '\x5', '\xA4', 
		'\xAD0', '\n', '\xA4', '\x5', '\xA4', '\xAD2', '\n', '\xA4', '\x3', '\xA5', 
		'\x3', '\xA5', '\x3', '\xA5', '\x3', '\xA5', '\x3', '\xA6', '\x3', '\xA6', 
		'\x3', '\xA6', '\x3', '\xA6', '\x3', '\xA6', '\a', '\xA6', '\xADD', '\n', 
		'\xA6', '\f', '\xA6', '\xE', '\xA6', '\xAE0', '\v', '\xA6', '\x5', '\xA6', 
		'\xAE2', '\n', '\xA6', '\x3', '\xA6', '\x3', '\xA6', '\x3', '\xA7', '\x3', 
		'\xA7', '\x3', '\xA7', '\x3', '\xA7', '\x5', '\xA7', '\xAEA', '\n', '\xA7', 
		'\x3', '\xA8', '\x5', '\xA8', '\xAED', '\n', '\xA8', '\x3', '\xA8', '\x3', 
		'\xA8', '\x3', '\xA8', '\x3', '\xA8', '\x3', '\xA9', '\x5', '\xA9', '\xAF4', 
		'\n', '\xA9', '\x3', '\xA9', '\x3', '\xA9', '\x3', '\xA9', '\x3', '\xA9', 
		'\x3', '\xAA', '\x3', '\xAA', '\x5', '\xAA', '\xAFC', '\n', '\xAA', '\x3', 
		'\xAA', '\x3', '\xAA', '\x3', '\xAA', '\x3', '\xAB', '\x3', '\xAB', '\x5', 
		'\xAB', '\xB03', '\n', '\xAB', '\x3', '\xAB', '\x3', '\xAB', '\x3', '\xAC', 
		'\x3', '\xAC', '\x3', '\xAD', '\x3', '\xAD', '\x3', '\xAD', '\x3', '\xAE', 
		'\x3', '\xAE', '\x3', '\xAF', '\x3', '\xAF', '\x3', '\xB0', '\x3', '\xB0', 
		'\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', 
		'\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', 
		'\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\x5', '\xB0', '\xB1F', '\n', 
		'\xB0', '\x3', '\xB1', '\x3', '\xB1', '\x3', '\xB1', '\x3', '\xB1', '\x3', 
		'\xB2', '\x3', '\xB2', '\x3', '\xB2', '\x3', '\xB2', '\x3', '\xB2', '\x3', 
		'\xB3', '\x3', '\xB3', '\x3', '\xB3', '\x3', '\xB3', '\x3', '\xB3', '\x3', 
		'\xB3', '\x3', '\xB3', '\x3', '\xB3', '\x3', '\xB3', '\x5', '\xB3', '\xB33', 
		'\n', '\xB3', '\x3', '\xB3', '\x3', '\xB3', '\x5', '\xB3', '\xB37', '\n', 
		'\xB3', '\x3', '\xB4', '\x3', '\xB4', '\x3', '\xB4', '\a', '\xB4', '\xB3C', 
		'\n', '\xB4', '\f', '\xB4', '\xE', '\xB4', '\xB3F', '\v', '\xB4', '\x3', 
		'\xB5', '\x3', '\xB5', '\x3', '\xB5', '\x3', '\xB5', '\x3', '\xB5', '\x5', 
		'\xB5', '\xB46', '\n', '\xB5', '\x3', '\xB6', '\x3', '\xB6', '\x3', '\xB6', 
		'\a', '\xB6', '\xB4B', '\n', '\xB6', '\f', '\xB6', '\xE', '\xB6', '\xB4E', 
		'\v', '\xB6', '\x3', '\xB7', '\x3', '\xB7', '\x3', '\xB7', '\x6', '\xB7', 
		'\xB53', '\n', '\xB7', '\r', '\xB7', '\xE', '\xB7', '\xB54', '\x3', '\xB8', 
		'\x3', '\xB8', '\x3', '\xB9', '\x5', '\xB9', '\xB5A', '\n', '\xB9', '\x3', 
		'\xB9', '\x3', '\xB9', '\x5', '\xB9', '\xB5E', '\n', '\xB9', '\x3', '\xB9', 
		'\x5', '\xB9', '\xB61', '\n', '\xB9', '\x3', '\xBA', '\x3', '\xBA', '\x3', 
		'\xBA', '\x3', '\xBA', '\x5', '\xBA', '\xB67', '\n', '\xBA', '\x3', '\xBA', 
		'\x3', '\xBA', '\x3', '\xBB', '\x3', '\xBB', '\x3', '\xBB', '\x3', '\xBC', 
		'\x5', '\xBC', '\xB6F', '\n', '\xBC', '\x3', '\xBC', '\x3', '\xBC', '\x3', 
		'\xBD', '\x3', '\xBD', '\x3', '\xBD', '\a', '\xBD', '\xB76', '\n', '\xBD', 
		'\f', '\xBD', '\xE', '\xBD', '\xB79', '\v', '\xBD', '\x3', '\xBE', '\x3', 
		'\xBE', '\x3', '\xBE', '\a', '\xBE', '\xB7E', '\n', '\xBE', '\f', '\xBE', 
		'\xE', '\xBE', '\xB81', '\v', '\xBE', '\x3', '\xBF', '\x3', '\xBF', '\x3', 
		'\xC0', '\x3', '\xC0', '\x3', '\xC1', '\x3', '\xC1', '\x5', '\xC1', '\xB89', 
		'\n', '\xC1', '\x3', '\xC1', '\x3', '\xC1', '\x3', '\xC1', '\x3', '\xC1', 
		'\x3', '\xC1', '\x3', '\xC1', '\x3', '\xC1', '\x5', '\xC1', '\xB92', '\n', 
		'\xC1', '\x3', '\xC2', '\x3', '\xC2', '\x3', '\xC2', '\x3', '\xC3', '\x3', 
		'\xC3', '\x3', '\xC3', '\x3', '\xC3', '\x3', '\xC3', '\a', '\xC3', '\xB9C', 
		'\n', '\xC3', '\f', '\xC3', '\xE', '\xC3', '\xB9F', '\v', '\xC3', '\x3', 
		'\xC4', '\x3', '\xC4', '\x3', '\xC4', '\x3', '\xC4', '\x5', '\xC4', '\xBA5', 
		'\n', '\xC4', '\x3', '\xC5', '\x3', '\xC5', '\x3', '\xC5', '\x3', '\xC5', 
		'\x5', '\xC5', '\xBAB', '\n', '\xC5', '\x3', '\xC6', '\x3', '\xC6', '\x3', 
		'\xC6', '\x5', '\xC6', '\xBB0', '\n', '\xC6', '\x3', '\xC7', '\x3', '\xC7', 
		'\x3', '\xC7', '\x5', '\xC7', '\xBB5', '\n', '\xC7', '\x3', '\xC8', '\x3', 
		'\xC8', '\x3', '\xC8', '\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', 
		'\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', 
		'\xC9', '\x5', '\xC9', '\xBC3', '\n', '\xC9', '\x3', '\xCA', '\x3', '\xCA', 
		'\x3', '\xCA', '\x3', '\xCA', '\x3', '\xCB', '\x3', '\xCB', '\x3', '\xCB', 
		'\x3', '\xCB', '\x3', '\xCC', '\x5', '\xCC', '\xBCE', '\n', '\xCC', '\x3', 
		'\xCC', '\x3', '\xCC', '\x3', '\xCC', '\x3', '\xCC', '\x3', '\xCD', '\x3', 
		'\xCD', '\x3', '\xCD', '\x5', '\xCD', '\xBD7', '\n', '\xCD', '\x3', '\xCD', 
		'\x3', '\xCD', '\x3', '\xCD', '\x3', '\xCE', '\x3', '\xCE', '\x3', '\xCE', 
		'\x3', '\xCF', '\x3', '\xCF', '\x3', '\xCF', '\x3', '\xD0', '\x3', '\xD0', 
		'\x3', '\xD0', '\x3', '\xD1', '\x3', '\xD1', '\x3', '\xD1', '\x3', '\xD2', 
		'\x3', '\xD2', '\x3', '\xD2', '\x3', '\xD2', '\x3', '\xD3', '\x5', '\xD3', 
		'\xBED', '\n', '\xD3', '\x3', '\xD3', '\x3', '\xD3', '\x3', '\xD3', '\x3', 
		'\xD3', '\x3', '\xD3', '\x3', '\xD3', '\x5', '\xD3', '\xBF5', '\n', '\xD3', 
		'\x3', '\xD3', '\x5', '\xD3', '\xBF8', '\n', '\xD3', '\x3', '\xD3', '\x3', 
		'\xD3', '\x5', '\xD3', '\xBFC', '\n', '\xD3', '\x3', '\xD4', '\x3', '\xD4', 
		'\x3', '\xD4', '\a', '\xD4', '\xC01', '\n', '\xD4', '\f', '\xD4', '\xE', 
		'\xD4', '\xC04', '\v', '\xD4', '\x3', '\xD5', '\x3', '\xD5', '\x5', '\xD5', 
		'\xC08', '\n', '\xD5', '\x3', '\xD5', '\x3', '\xD5', '\x3', '\xD5', '\x3', 
		'\xD5', '\a', '\xD5', '\xC0E', '\n', '\xD5', '\f', '\xD5', '\xE', '\xD5', 
		'\xC11', '\v', '\xD5', '\x3', '\xD5', '\x3', '\xD5', '\x5', '\xD5', '\xC15', 
		'\n', '\xD5', '\x3', '\xD6', '\x3', '\xD6', '\x5', '\xD6', '\xC19', '\n', 
		'\xD6', '\x3', '\xD7', '\x3', '\xD7', '\x3', '\xD7', '\x3', '\xD7', '\x3', 
		'\xD7', '\x3', '\xD7', '\x3', '\xD7', '\x3', '\xD7', '\a', '\xD7', '\xC23', 
		'\n', '\xD7', '\f', '\xD7', '\xE', '\xD7', '\xC26', '\v', '\xD7', '\x3', 
		'\xD7', '\x3', '\xD7', '\x5', '\xD7', '\xC2A', '\n', '\xD7', '\x3', '\xD7', 
		'\a', '\xD7', '\xC2D', '\n', '\xD7', '\f', '\xD7', '\xE', '\xD7', '\xC30', 
		'\v', '\xD7', '\x3', '\xD8', '\x3', '\xD8', '\x5', '\xD8', '\xC34', '\n', 
		'\xD8', '\x3', '\xD9', '\x3', '\xD9', '\x5', '\xD9', '\xC38', '\n', '\xD9', 
		'\x3', '\xDA', '\x3', '\xDA', '\x3', '\xDA', '\x6', '\xDA', '\xC3D', '\n', 
		'\xDA', '\r', '\xDA', '\xE', '\xDA', '\xC3E', '\x3', '\xDA', '\x5', '\xDA', 
		'\xC42', '\n', '\xDA', '\x3', '\xDB', '\x3', '\xDB', '\x3', '\xDB', '\x3', 
		'\xDC', '\x3', '\xDC', '\x3', '\xDC', '\x3', '\xDC', '\x5', '\xDC', '\xC4B', 
		'\n', '\xDC', '\x3', '\xDD', '\x3', '\xDD', '\x3', '\xDD', '\x3', '\xDD', 
		'\a', '\xDD', '\xC51', '\n', '\xDD', '\f', '\xDD', '\xE', '\xDD', '\xC54', 
		'\v', '\xDD', '\x3', '\xDD', '\x3', '\xDD', '\x3', '\xDE', '\x3', '\xDE', 
		'\x5', '\xDE', '\xC5A', '\n', '\xDE', '\x3', '\xDE', '\x3', '\xDE', '\a', 
		'\xDE', '\xC5E', '\n', '\xDE', '\f', '\xDE', '\xE', '\xDE', '\xC61', '\v', 
		'\xDE', '\x3', '\xDE', '\x5', '\xDE', '\xC64', '\n', '\xDE', '\x3', '\xDF', 
		'\x3', '\xDF', '\x3', '\xDF', '\x3', '\xDF', '\x3', '\xDF', '\a', '\xDF', 
		'\xC6B', '\n', '\xDF', '\f', '\xDF', '\xE', '\xDF', '\xC6E', '\v', '\xDF', 
		'\x3', '\xDF', '\x3', '\xDF', '\x5', '\xDF', '\xC72', '\n', '\xDF', '\x3', 
		'\xE0', '\x3', '\xE0', '\x5', '\xE0', '\xC76', '\n', '\xE0', '\x3', '\xE0', 
		'\x5', '\xE0', '\xC79', '\n', '\xE0', '\x3', '\xE0', '\x5', '\xE0', '\xC7C', 
		'\n', '\xE0', '\x3', '\xE0', '\x3', '\xE0', '\x3', '\xE1', '\x5', '\xE1', 
		'\xC81', '\n', '\xE1', '\x3', '\xE1', '\x3', '\xE1', '\x3', '\xE1', '\x3', 
		'\xE1', '\a', '\xE1', '\xC87', '\n', '\xE1', '\f', '\xE1', '\xE', '\xE1', 
		'\xC8A', '\v', '\xE1', '\x3', '\xE1', '\x3', '\xE1', '\x3', '\xE2', '\x3', 
		'\xE2', '\x3', '\xE2', '\x3', '\xE3', '\x3', '\xE3', '\x3', '\xE3', '\x3', 
		'\xE3', '\x3', '\xE3', '\a', '\xE3', '\xC96', '\n', '\xE3', '\f', '\xE3', 
		'\xE', '\xE3', '\xC99', '\v', '\xE3', '\x3', '\xE3', '\x3', '\xE3', '\x5', 
		'\xE3', '\xC9D', '\n', '\xE3', '\x3', '\xE4', '\x3', '\xE4', '\x5', '\xE4', 
		'\xCA1', '\n', '\xE4', '\x3', '\xE4', '\x5', '\xE4', '\xCA4', '\n', '\xE4', 
		'\x3', '\xE4', '\x5', '\xE4', '\xCA7', '\n', '\xE4', '\x3', '\xE4', '\x3', 
		'\xE4', '\x3', '\xE5', '\x3', '\xE5', '\x3', '\xE5', '\x3', '\xE5', '\x3', 
		'\xE5', '\x3', '\xE5', '\x3', '\xE5', '\x3', '\xE5', '\x3', '\xE5', '\x3', 
		'\xE5', '\x3', '\xE5', '\x3', '\xE5', '\x5', '\xE5', '\xCB7', '\n', '\xE5', 
		'\x3', '\xE6', '\x3', '\xE6', '\x3', '\xE7', '\x3', '\xE7', '\x3', '\xE7', 
		'\x3', '\xE8', '\x3', '\xE8', '\x3', '\xE8', '\x3', '\xE8', '\x5', '\xE8', 
		'\xCC2', '\n', '\xE8', '\x3', '\xE8', '\x5', '\xE8', '\xCC5', '\n', '\xE8', 
		'\x3', '\xE8', '\x5', '\xE8', '\xCC8', '\n', '\xE8', '\x3', '\xE9', '\x3', 
		'\xE9', '\x3', '\xE9', '\x3', '\xE9', '\x3', '\xE9', '\x3', '\xE9', '\x3', 
		'\xE9', '\x3', '\xE9', '\x3', '\xEA', '\x3', '\xEA', '\x3', '\xEA', '\x5', 
		'\xEA', '\xCD5', '\n', '\xEA', '\x3', '\xEB', '\x3', '\xEB', '\x3', '\xEB', 
		'\x3', '\xEB', '\x3', '\xEB', '\x3', '\xEC', '\x3', '\xEC', '\x3', '\xEC', 
		'\x3', '\xED', '\x3', '\xED', '\x3', '\xED', '\x5', '\xED', '\xCE2', '\n', 
		'\xED', '\x3', '\xED', '\a', '\xED', '\xCE5', '\n', '\xED', '\f', '\xED', 
		'\xE', '\xED', '\xCE8', '\v', '\xED', '\x3', '\xEE', '\x3', '\xEE', '\x3', 
		'\xEE', '\x3', '\xEE', '\x3', '\xEF', '\x5', '\xEF', '\xCEF', '\n', '\xEF', 
		'\x3', '\xEF', '\x3', '\xEF', '\x3', '\xEF', '\x3', '\xEF', '\x3', '\xEF', 
		'\x3', '\xEF', '\x3', '\xEF', '\x3', '\xEF', '\x5', '\xEF', '\xCF9', '\n', 
		'\xEF', '\x3', '\xF0', '\x3', '\xF0', '\x3', '\xF1', '\x3', '\xF1', '\x3', 
		'\xF1', '\x3', '\xF1', '\a', '\xF1', '\xD01', '\n', '\xF1', '\f', '\xF1', 
		'\xE', '\xF1', '\xD04', '\v', '\xF1', '\x3', '\xF1', '\x5', '\xF1', '\xD07', 
		'\n', '\xF1', '\x3', '\xF1', '\x3', '\xF1', '\x3', '\xF1', '\x3', '\xF1', 
		'\x5', '\xF1', '\xD0D', '\n', '\xF1', '\x3', '\xF2', '\x3', '\xF2', '\x3', 
		'\xF2', '\x3', '\xF2', '\x3', '\xF2', '\a', '\xF2', '\xD14', '\n', '\xF2', 
		'\f', '\xF2', '\xE', '\xF2', '\xD17', '\v', '\xF2', '\x3', '\xF2', '\x3', 
		'\xF2', '\x3', '\xF2', '\x3', '\xF2', '\x5', '\xF2', '\xD1D', '\n', '\xF2', 
		'\x5', '\xF2', '\xD1F', '\n', '\xF2', '\x3', '\xF3', '\x5', '\xF3', '\xD22', 
		'\n', '\xF3', '\x3', '\xF4', '\x3', '\xF4', '\x5', '\xF4', '\xD26', '\n', 
		'\xF4', '\x3', '\xF5', '\x3', '\xF5', '\x5', '\xF5', '\xD2A', '\n', '\xF5', 
		'\x3', '\xF6', '\x3', '\xF6', '\x5', '\xF6', '\xD2E', '\n', '\xF6', '\x3', 
		'\xF7', '\x3', '\xF7', '\x3', '\xF7', '\x5', '\xF7', '\xD33', '\n', '\xF7', 
		'\x3', '\xF8', '\x3', '\xF8', '\x5', '\xF8', '\xD37', '\n', '\xF8', '\x3', 
		'\xF8', '\x3', '\xF8', '\x3', '\xF9', '\x3', '\xF9', '\x3', '\xFA', '\x3', 
		'\xFA', '\x3', '\xFA', '\x3', '\xFB', '\x3', '\xFB', '\x3', '\xFB', '\x5', 
		'\xFB', '\xD43', '\n', '\xFB', '\x3', '\xFC', '\x3', '\xFC', '\x3', '\xFC', 
		'\x3', '\xFC', '\x3', '\xFD', '\x3', '\xFD', '\x5', '\xFD', '\xD4B', '\n', 
		'\xFD', '\x3', '\xFD', '\x3', '\xFD', '\x5', '\xFD', '\xD4F', '\n', '\xFD', 
		'\x3', '\xFD', '\x5', '\xFD', '\xD52', '\n', '\xFD', '\x3', '\xFD', '\x5', 
		'\xFD', '\xD55', '\n', '\xFD', '\x3', '\xFE', '\x3', '\xFE', '\x3', '\xFE', 
		'\x3', '\xFF', '\x3', '\xFF', '\x3', '\xFF', '\x3', '\x100', '\x3', '\x100', 
		'\x3', '\x100', '\x3', '\x100', '\x3', '\x101', '\x3', '\x101', '\x3', 
		'\x101', '\x3', '\x102', '\x3', '\x102', '\x3', '\x102', '\x3', '\x102', 
		'\x3', '\x102', '\x3', '\x103', '\x3', '\x103', '\x3', '\x103', '\x3', 
		'\x103', '\a', '\x103', '\xD6D', '\n', '\x103', '\f', '\x103', '\xE', 
		'\x103', '\xD70', '\v', '\x103', '\x5', '\x103', '\xD72', '\n', '\x103', 
		'\x3', '\x103', '\x3', '\x103', '\x3', '\x104', '\x3', '\x104', '\x5', 
		'\x104', '\xD78', '\n', '\x104', '\x3', '\x104', '\x5', '\x104', '\xD7B', 
		'\n', '\x104', '\x3', '\x104', '\x3', '\x104', '\x5', '\x104', '\xD7F', 
		'\n', '\x104', '\x3', '\x105', '\x3', '\x105', '\x3', '\x106', '\x3', 
		'\x106', '\x3', '\x106', '\x3', '\x106', '\x5', '\x106', '\xD87', '\n', 
		'\x106', '\x3', '\x107', '\x3', '\x107', '\x3', '\x107', '\x3', '\x108', 
		'\x3', '\x108', '\x5', '\x108', '\xD8E', '\n', '\x108', '\x3', '\x109', 
		'\x3', '\x109', '\x3', '\x109', '\x3', '\x109', '\x3', '\x109', '\x3', 
		'\x109', '\x3', '\x109', '\x3', '\x109', '\a', '\x109', '\xD98', '\n', 
		'\x109', '\f', '\x109', '\xE', '\x109', '\xD9B', '\v', '\x109', '\x3', 
		'\x10A', '\x3', '\x10A', '\x5', '\x10A', '\xD9F', '\n', '\x10A', '\x3', 
		'\x10B', '\x3', '\x10B', '\x3', '\x10B', '\x5', '\x10B', '\xDA4', '\n', 
		'\x10B', '\x3', '\x10B', '\x5', '\x10B', '\xDA7', '\n', '\x10B', '\x3', 
		'\x10C', '\x3', '\x10C', '\x3', '\x10C', '\x3', '\x10D', '\x3', '\x10D', 
		'\x3', '\x10E', '\x3', '\x10E', '\x5', '\x10E', '\xDB0', '\n', '\x10E', 
		'\x3', '\x10F', '\x3', '\x10F', '\x3', '\x10F', '\x3', '\x10F', '\x3', 
		'\x10F', '\x3', '\x10F', '\x3', '\x110', '\x3', '\x110', '\x3', '\x110', 
		'\x3', '\x110', '\x3', '\x110', '\x3', '\x110', '\x3', '\x110', '\x5', 
		'\x110', '\xDBF', '\n', '\x110', '\x5', '\x110', '\xDC1', '\n', '\x110', 
		'\x3', '\x111', '\x3', '\x111', '\x3', '\x111', '\x3', '\x111', '\x3', 
		'\x112', '\x3', '\x112', '\x3', '\x112', '\x3', '\x112', '\x3', '\x113', 
		'\x3', '\x113', '\x3', '\x113', '\x3', '\x114', '\x3', '\x114', '\x5', 
		'\x114', '\xDD0', '\n', '\x114', '\x3', '\x115', '\x3', '\x115', '\x3', 
		'\x115', '\x3', '\x115', '\x3', '\x115', '\a', '\x115', '\xDD7', '\n', 
		'\x115', '\f', '\x115', '\xE', '\x115', '\xDDA', '\v', '\x115', '\x3', 
		'\x115', '\x3', '\x115', '\x3', '\x116', '\x3', '\x116', '\x3', '\x116', 
		'\x3', '\x116', '\x3', '\x117', '\x3', '\x117', '\x3', '\x117', '\x5', 
		'\x117', '\xDE5', '\n', '\x117', '\x3', '\x117', '\x3', '\x117', '\x5', 
		'\x117', '\xDE9', '\n', '\x117', '\x3', '\x118', '\x3', '\x118', '\x3', 
		'\x118', '\x3', '\x118', '\x5', '\x118', '\xDEF', '\n', '\x118', '\x3', 
		'\x118', '\x5', '\x118', '\xDF2', '\n', '\x118', '\x3', '\x118', '\x5', 
		'\x118', '\xDF5', '\n', '\x118', '\x3', '\x119', '\x3', '\x119', '\x3', 
		'\x119', '\x3', '\x119', '\x3', '\x119', '\x3', '\x119', '\x5', '\x119', 
		'\xDFD', '\n', '\x119', '\x3', '\x119', '\x3', '\x119', '\x3', '\x119', 
		'\x3', '\x119', '\x3', '\x119', '\x3', '\x119', '\x3', '\x119', '\x3', 
		'\x119', '\x3', '\x119', '\x5', '\x119', '\xE08', '\n', '\x119', '\x5', 
		'\x119', '\xE0A', '\n', '\x119', '\x3', '\x11A', '\x3', '\x11A', '\x5', 
		'\x11A', '\xE0E', '\n', '\x11A', '\x3', '\x11A', '\x5', '\x11A', '\xE11', 
		'\n', '\x11A', '\x3', '\x11A', '\x5', '\x11A', '\xE14', '\n', '\x11A', 
		'\x3', '\x11A', '\x5', '\x11A', '\xE17', '\n', '\x11A', '\x3', '\x11A', 
		'\x5', '\x11A', '\xE1A', '\n', '\x11A', '\x3', '\x11A', '\x3', '\x11A', 
		'\x3', '\x11B', '\x3', '\x11B', '\x3', '\x11B', '\x6', '\x11B', '\xE21', 
		'\n', '\x11B', '\r', '\x11B', '\xE', '\x11B', '\xE22', '\x3', '\x11C', 
		'\x3', '\x11C', '\x3', '\x11C', '\x3', '\x11D', '\x3', '\x11D', '\x5', 
		'\x11D', '\xE2A', '\n', '\x11D', '\x3', '\x11D', '\x3', '\x11D', '\x3', 
		'\x11E', '\x3', '\x11E', '\x3', '\x11E', '\x6', '\x11E', '\xE31', '\n', 
		'\x11E', '\r', '\x11E', '\xE', '\x11E', '\xE32', '\x3', '\x11E', '\x3', 
		'\x11E', '\x3', '\x11F', '\x3', '\x11F', '\x3', '\x11F', '\x3', '\x11F', 
		'\x3', '\x11F', '\x3', '\x11F', '\x3', '\x11F', '\x5', '\x11F', '\xE3E', 
		'\n', '\x11F', '\x3', '\x120', '\x3', '\x120', '\x3', '\x120', '\x5', 
		'\x120', '\xE43', '\n', '\x120', '\x3', '\x121', '\x5', '\x121', '\xE46', 
		'\n', '\x121', '\x3', '\x121', '\x5', '\x121', '\xE49', '\n', '\x121', 
		'\x3', '\x121', '\x5', '\x121', '\xE4C', '\n', '\x121', '\x3', '\x121', 
		'\x5', '\x121', '\xE4F', '\n', '\x121', '\x3', '\x121', '\x3', '\x121', 
		'\x3', '\x122', '\x3', '\x122', '\x3', '\x122', '\x5', '\x122', '\xE56', 
		'\n', '\x122', '\x3', '\x123', '\x5', '\x123', '\xE59', '\n', '\x123', 
		'\x3', '\x123', '\x5', '\x123', '\xE5C', '\n', '\x123', '\x3', '\x123', 
		'\x5', '\x123', '\xE5F', '\n', '\x123', '\x3', '\x123', '\x5', '\x123', 
		'\xE62', '\n', '\x123', '\x3', '\x123', '\x5', '\x123', '\xE65', '\n', 
		'\x123', '\x3', '\x123', '\x5', '\x123', '\xE68', '\n', '\x123', '\x3', 
		'\x123', '\a', '\x123', '\xE6B', '\n', '\x123', '\f', '\x123', '\xE', 
		'\x123', '\xE6E', '\v', '\x123', '\x3', '\x123', '\x5', '\x123', '\xE71', 
		'\n', '\x123', '\x3', '\x123', '\x5', '\x123', '\xE74', '\n', '\x123', 
		'\x3', '\x124', '\x3', '\x124', '\x3', '\x124', '\x3', '\x124', '\x5', 
		'\x124', '\xE7A', '\n', '\x124', '\x3', '\x124', '\x6', '\x124', '\xE7D', 
		'\n', '\x124', '\r', '\x124', '\xE', '\x124', '\xE7E', '\x3', '\x125', 
		'\x3', '\x125', '\x5', '\x125', '\xE83', '\n', '\x125', '\x3', '\x125', 
		'\x3', '\x125', '\x5', '\x125', '\xE87', '\n', '\x125', '\x3', '\x125', 
		'\x3', '\x125', '\x3', '\x125', '\x5', '\x125', '\xE8C', '\n', '\x125', 
		'\x3', '\x126', '\x3', '\x126', '\x5', '\x126', '\xE90', '\n', '\x126', 
		'\x3', '\x127', '\x3', '\x127', '\x3', '\x127', '\x3', '\x127', '\x5', 
		'\x127', '\xE96', '\n', '\x127', '\x3', '\x128', '\x3', '\x128', '\x3', 
		'\x128', '\x3', '\x129', '\x5', '\x129', '\xE9C', '\n', '\x129', '\x3', 
		'\x129', '\x3', '\x129', '\x3', '\x129', '\x5', '\x129', '\xEA1', '\n', 
		'\x129', '\x3', '\x129', '\x5', '\x129', '\xEA4', '\n', '\x129', '\x3', 
		'\x129', '\x5', '\x129', '\xEA7', '\n', '\x129', '\x3', '\x12A', '\x3', 
		'\x12A', '\x3', '\x12A', '\x3', '\x12A', '\x3', '\x12A', '\x3', '\x12A', 
		'\x3', '\x12B', '\x3', '\x12B', '\x3', '\x12B', '\x3', '\x12B', '\x3', 
		'\x12C', '\x3', '\x12C', '\x3', '\x12C', '\x3', '\x12C', '\x3', '\x12D', 
		'\x3', '\x12D', '\x3', '\x12D', '\x3', '\x12D', '\x5', '\x12D', '\xEBB', 
		'\n', '\x12D', '\x3', '\x12D', '\x3', '\x12D', '\x5', '\x12D', '\xEBF', 
		'\n', '\x12D', '\x3', '\x12D', '\x5', '\x12D', '\xEC2', '\n', '\x12D', 
		'\x3', '\x12E', '\x3', '\x12E', '\x3', '\x12E', '\x3', '\x12E', '\x5', 
		'\x12E', '\xEC8', '\n', '\x12E', '\x3', '\x12E', '\x3', '\x12E', '\x3', 
		'\x12F', '\x3', '\x12F', '\x5', '\x12F', '\xECE', '\n', '\x12F', '\x3', 
		'\x12F', '\x3', '\x12F', '\x3', '\x130', '\x3', '\x130', '\x3', '\x130', 
		'\x3', '\x130', '\a', '\x130', '\xED6', '\n', '\x130', '\f', '\x130', 
		'\xE', '\x130', '\xED9', '\v', '\x130', '\x3', '\x130', '\x3', '\x130', 
		'\x3', '\x131', '\x3', '\x131', '\x3', '\x131', '\x3', '\x131', '\x3', 
		'\x131', '\x5', '\x131', '\xEE2', '\n', '\x131', '\x3', '\x131', '\x5', 
		'\x131', '\xEE5', '\n', '\x131', '\x3', '\x131', '\x3', '\x131', '\x6', 
		'\x131', '\xEE9', '\n', '\x131', '\r', '\x131', '\xE', '\x131', '\xEEA', 
		'\x5', '\x131', '\xEED', '\n', '\x131', '\x5', '\x131', '\xEEF', '\n', 
		'\x131', '\x3', '\x132', '\x3', '\x132', '\x3', '\x132', '\x3', '\x132', 
		'\x3', '\x133', '\x3', '\x133', '\x3', '\x133', '\x5', '\x133', '\xEF8', 
		'\n', '\x133', '\x5', '\x133', '\xEFA', '\n', '\x133', '\x3', '\x134', 
		'\x3', '\x134', '\x3', '\x134', '\x3', '\x135', '\x3', '\x135', '\x3', 
		'\x135', '\x3', '\x135', '\x3', '\x136', '\x3', '\x136', '\x5', '\x136', 
		'\xF05', '\n', '\x136', '\x3', '\x136', '\x3', '\x136', '\x3', '\x136', 
		'\x5', '\x136', '\xF0A', '\n', '\x136', '\x3', '\x136', '\x5', '\x136', 
		'\xF0D', '\n', '\x136', '\x3', '\x136', '\x5', '\x136', '\xF10', '\n', 
		'\x136', '\x3', '\x136', '\x5', '\x136', '\xF13', '\n', '\x136', '\x3', 
		'\x136', '\x5', '\x136', '\xF16', '\n', '\x136', '\x3', '\x137', '\x3', 
		'\x137', '\x3', '\x137', '\x3', '\x138', '\x3', '\x138', '\x3', '\x139', 
		'\x3', '\x139', '\x3', '\x13A', '\x3', '\x13A', '\x3', '\x13B', '\x3', 
		'\x13B', '\x5', '\x13B', '\xF23', '\n', '\x13B', '\x3', '\x13B', '\x5', 
		'\x13B', '\xF26', '\n', '\x13B', '\x3', '\x13C', '\x3', '\x13C', '\x3', 
		'\x13C', '\x3', '\x13C', '\x3', '\x13C', '\x3', '\x13C', '\x5', '\x13C', 
		'\xF2E', '\n', '\x13C', '\x3', '\x13D', '\x3', '\x13D', '\x3', '\x13D', 
		'\x3', '\x13D', '\x5', '\x13D', '\xF34', '\n', '\x13D', '\x3', '\x13D', 
		'\x3', '\x13D', '\x3', '\x13E', '\x3', '\x13E', '\x3', '\x13E', '\x3', 
		'\x13E', '\x3', '\x13E', '\x3', '\x13E', '\x5', '\x13E', '\xF3E', '\n', 
		'\x13E', '\x3', '\x13F', '\x3', '\x13F', '\x3', '\x13F', '\x5', '\x13F', 
		'\xF43', '\n', '\x13F', '\x3', '\x140', '\x3', '\x140', '\x3', '\x140', 
		'\x3', '\x140', '\x3', '\x140', '\x5', '\x140', '\xF4A', '\n', '\x140', 
		'\x3', '\x141', '\x3', '\x141', '\x3', '\x141', '\x3', '\x141', '\x5', 
		'\x141', '\xF50', '\n', '\x141', '\x3', '\x142', '\x3', '\x142', '\x3', 
		'\x142', '\x3', '\x142', '\a', '\x142', '\xF56', '\n', '\x142', '\f', 
		'\x142', '\xE', '\x142', '\xF59', '\v', '\x142', '\x3', '\x142', '\x3', 
		'\x142', '\x3', '\x143', '\x3', '\x143', '\x3', '\x143', '\x5', '\x143', 
		'\xF60', '\n', '\x143', '\x3', '\x143', '\x5', '\x143', '\xF63', '\n', 
		'\x143', '\x3', '\x144', '\x3', '\x144', '\x3', '\x144', '\x3', '\x144', 
		'\x3', '\x145', '\x3', '\x145', '\x3', '\x145', '\x3', '\x145', '\x5', 
		'\x145', '\xF6D', '\n', '\x145', '\x3', '\x146', '\x3', '\x146', '\x3', 
		'\x146', '\x5', '\x146', '\xF72', '\n', '\x146', '\x3', '\x146', '\x5', 
		'\x146', '\xF75', '\n', '\x146', '\x3', '\x147', '\x3', '\x147', '\x3', 
		'\x147', '\x3', '\x147', '\a', '\x147', '\xF7B', '\n', '\x147', '\f', 
		'\x147', '\xE', '\x147', '\xF7E', '\v', '\x147', '\x3', '\x147', '\x3', 
		'\x147', '\x3', '\x148', '\x3', '\x148', '\x3', '\x148', '\x3', '\x148', 
		'\x5', '\x148', '\xF86', '\n', '\x148', '\x5', '\x148', '\xF88', '\n', 
		'\x148', '\x3', '\x149', '\x3', '\x149', '\x3', '\x149', '\x3', '\x14A', 
		'\x3', '\x14A', '\x3', '\x14A', '\x3', '\x14A', '\a', '\x14A', '\xF91', 
		'\n', '\x14A', '\f', '\x14A', '\xE', '\x14A', '\xF94', '\v', '\x14A', 
		'\x3', '\x14A', '\x3', '\x14A', '\x3', '\x14B', '\x3', '\x14B', '\x5', 
		'\x14B', '\xF9A', '\n', '\x14B', '\x3', '\x14B', '\x3', '\x14B', '\x5', 
		'\x14B', '\xF9E', '\n', '\x14B', '\x3', '\x14B', '\x3', '\x14B', '\x3', 
		'\x14C', '\x5', '\x14C', '\xFA3', '\n', '\x14C', '\x3', '\x14C', '\x5', 
		'\x14C', '\xFA6', '\n', '\x14C', '\x3', '\x14C', '\x5', '\x14C', '\xFA9', 
		'\n', '\x14C', '\x3', '\x14C', '\x3', '\x14C', '\a', '\x14C', '\xFAD', 
		'\n', '\x14C', '\f', '\x14C', '\xE', '\x14C', '\xFB0', '\v', '\x14C', 
		'\x3', '\x14C', '\x5', '\x14C', '\xFB3', '\n', '\x14C', '\x3', '\x14D', 
		'\x3', '\x14D', '\x5', '\x14D', '\xFB7', '\n', '\x14D', '\x3', '\x14E', 
		'\x3', '\x14E', '\x3', '\x14E', '\x3', '\x14E', '\a', '\x14E', '\xFBD', 
		'\n', '\x14E', '\f', '\x14E', '\xE', '\x14E', '\xFC0', '\v', '\x14E', 
		'\x3', '\x14E', '\x3', '\x14E', '\x3', '\x14F', '\x3', '\x14F', '\x3', 
		'\x14F', '\x3', '\x14F', '\x5', '\x14F', '\xFC8', '\n', '\x14F', '\x3', 
		'\x14F', '\x3', '\x14F', '\x5', '\x14F', '\xFCC', '\n', '\x14F', '\x3', 
		'\x14F', '\x5', '\x14F', '\xFCF', '\n', '\x14F', '\x5', '\x14F', '\xFD1', 
		'\n', '\x14F', '\x3', '\x150', '\x3', '\x150', '\x3', '\x150', '\x3', 
		'\x150', '\x6', '\x150', '\xFD7', '\n', '\x150', '\r', '\x150', '\xE', 
		'\x150', '\xFD8', '\x3', '\x151', '\x3', '\x151', '\x3', '\x151', '\x3', 
		'\x152', '\x3', '\x152', '\x3', '\x152', '\x5', '\x152', '\xFE1', '\n', 
		'\x152', '\x3', '\x153', '\x3', '\x153', '\x3', '\x153', '\x3', '\x153', 
		'\x3', '\x154', '\x3', '\x154', '\x3', '\x154', '\x3', '\x154', '\a', 
		'\x154', '\xFEB', '\n', '\x154', '\f', '\x154', '\xE', '\x154', '\xFEE', 
		'\v', '\x154', '\x3', '\x154', '\x3', '\x154', '\x3', '\x155', '\x3', 
		'\x155', '\x3', '\x155', '\x5', '\x155', '\xFF5', '\n', '\x155', '\x3', 
		'\x155', '\x5', '\x155', '\xFF8', '\n', '\x155', '\x3', '\x156', '\x3', 
		'\x156', '\x5', '\x156', '\xFFC', '\n', '\x156', '\x3', '\x157', '\x5', 
		'\x157', '\xFFF', '\n', '\x157', '\x3', '\x157', '\x3', '\x157', '\x3', 
		'\x157', '\x3', '\x157', '\x3', '\x157', '\x3', '\x158', '\x5', '\x158', 
		'\x1007', '\n', '\x158', '\x3', '\x158', '\x3', '\x158', '\x3', '\x158', 
		'\x5', '\x158', '\x100C', '\n', '\x158', '\x3', '\x158', '\x3', '\x158', 
		'\x5', '\x158', '\x1010', '\n', '\x158', '\x3', '\x158', '\x3', '\x158', 
		'\x3', '\x158', '\x3', '\x159', '\x3', '\x159', '\x3', '\x15A', '\x3', 
		'\x15A', '\x3', '\x15A', '\x5', '\x15A', '\x101A', '\n', '\x15A', '\x3', 
		'\x15A', '\x3', '\x15A', '\x3', '\x15A', '\x3', '\x15A', '\x5', '\x15A', 
		'\x1020', '\n', '\x15A', '\x5', '\x15A', '\x1022', '\n', '\x15A', '\x3', 
		'\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x5', '\x15B', 
		'\x1028', '\n', '\x15B', '\x5', '\x15B', '\x102A', '\n', '\x15B', '\x3', 
		'\x15C', '\x3', '\x15C', '\x3', '\x15C', '\x3', '\x15C', '\x6', '\x15C', 
		'\x1030', '\n', '\x15C', '\r', '\x15C', '\xE', '\x15C', '\x1031', '\x3', 
		'\x15C', '\x3', '\x15C', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', 
		'\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', 
		'\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', 
		'\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', 
		'\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', 
		'\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x5', '\x15D', '\x104E', 
		'\n', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', 
		'\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', 
		'\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', 
		'\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', 
		'\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', 
		'\x15D', '\x5', '\x15D', '\x1066', '\n', '\x15D', '\x3', '\x15D', '\x3', 
		'\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x5', '\x15D', 
		'\x106D', '\n', '\x15D', '\x3', '\x15E', '\x3', '\x15E', '\x3', '\x15E', 
		'\x3', '\x15E', '\x3', '\x15E', '\a', '\x15E', '\x1074', '\n', '\x15E', 
		'\f', '\x15E', '\xE', '\x15E', '\x1077', '\v', '\x15E', '\x3', '\x15E', 
		'\x3', '\x15E', '\x3', '\x15E', '\x3', '\x15E', '\x3', '\x15F', '\x3', 
		'\x15F', '\x3', '\x15F', '\x3', '\x15F', '\x3', '\x15F', '\x3', '\x160', 
		'\x3', '\x160', '\x3', '\x160', '\x3', '\x160', '\a', '\x160', '\x1086', 
		'\n', '\x160', '\f', '\x160', '\xE', '\x160', '\x1089', '\v', '\x160', 
		'\x3', '\x160', '\x3', '\x160', '\x3', '\x161', '\x3', '\x161', '\x5', 
		'\x161', '\x108F', '\n', '\x161', '\x3', '\x162', '\x3', '\x162', '\x3', 
		'\x162', '\x3', '\x163', '\x5', '\x163', '\x1095', '\n', '\x163', '\x3', 
		'\x163', '\x3', '\x163', '\x5', '\x163', '\x1099', '\n', '\x163', '\x3', 
		'\x163', '\x3', '\x163', '\x6', '\x163', '\x109D', '\n', '\x163', '\r', 
		'\x163', '\xE', '\x163', '\x109E', '\x3', '\x163', '\x5', '\x163', '\x10A2', 
		'\n', '\x163', '\x3', '\x164', '\x3', '\x164', '\x3', '\x164', '\x3', 
		'\x164', '\x3', '\x165', '\x3', '\x165', '\x3', '\x165', '\x3', '\x165', 
		'\x6', '\x165', '\x10AC', '\n', '\x165', '\r', '\x165', '\xE', '\x165', 
		'\x10AD', '\x3', '\x165', '\x3', '\x165', '\x3', '\x165', '\x6', '\x165', 
		'\x10B3', '\n', '\x165', '\r', '\x165', '\xE', '\x165', '\x10B4', '\x3', 
		'\x165', '\x5', '\x165', '\x10B8', '\n', '\x165', '\x5', '\x165', '\x10BA', 
		'\n', '\x165', '\x3', '\x166', '\x3', '\x166', '\x3', '\x166', '\x3', 
		'\x166', '\x3', '\x167', '\x3', '\x167', '\x3', '\x168', '\x3', '\x168', 
		'\x3', '\x168', '\x5', '\x168', '\x10C5', '\n', '\x168', '\x3', '\x169', 
		'\x5', '\x169', '\x10C8', '\n', '\x169', '\x3', '\x169', '\x3', '\x169', 
		'\x5', '\x169', '\x10CC', '\n', '\x169', '\x3', '\x16A', '\x3', '\x16A', 
		'\x5', '\x16A', '\x10D0', '\n', '\x16A', '\x3', '\x16A', '\x5', '\x16A', 
		'\x10D3', '\n', '\x16A', '\x3', '\x16B', '\x3', '\x16B', '\x3', '\x16B', 
		'\x3', '\x16C', '\x3', '\x16C', '\x3', '\x16C', '\x3', '\x16D', '\x3', 
		'\x16D', '\x3', '\x16D', '\x5', '\x16D', '\x10DE', '\n', '\x16D', '\x3', 
		'\x16E', '\x3', '\x16E', '\x5', '\x16E', '\x10E2', '\n', '\x16E', '\x3', 
		'\x16E', '\x5', '\x16E', '\x10E5', '\n', '\x16E', '\x3', '\x16E', '\x3', 
		'\x16E', '\x3', '\x16E', '\x3', '\x16E', '\x5', '\x16E', '\x10EB', '\n', 
		'\x16E', '\x3', '\x16E', '\x3', '\x16E', '\x3', '\x16E', '\x3', '\x16E', 
		'\x3', '\x16E', '\x3', '\x16E', '\x5', '\x16E', '\x10F3', '\n', '\x16E', 
		'\x5', '\x16E', '\x10F5', '\n', '\x16E', '\x3', '\x16E', '\x5', '\x16E', 
		'\x10F8', '\n', '\x16E', '\x3', '\x16E', '\x3', '\x16E', '\x3', '\x16E', 
		'\x5', '\x16E', '\x10FD', '\n', '\x16E', '\x3', '\x16E', '\x5', '\x16E', 
		'\x1100', '\n', '\x16E', '\x3', '\x16F', '\x3', '\x16F', '\x3', '\x16F', 
		'\x3', '\x16F', '\x5', '\x16F', '\x1106', '\n', '\x16F', '\x5', '\x16F', 
		'\x1108', '\n', '\x16F', '\x3', '\x16F', '\x5', '\x16F', '\x110B', '\n', 
		'\x16F', '\x3', '\x170', '\x3', '\x170', '\x3', '\x170', '\x3', '\x170', 
		'\x3', '\x171', '\x6', '\x171', '\x1112', '\n', '\x171', '\r', '\x171', 
		'\xE', '\x171', '\x1113', '\x3', '\x172', '\x3', '\x172', '\x3', '\x172', 
		'\x5', '\x172', '\x1119', '\n', '\x172', '\x3', '\x173', '\x3', '\x173', 
		'\x3', '\x173', '\x3', '\x173', '\x3', '\x173', '\x3', '\x174', '\x3', 
		'\x174', '\x3', '\x174', '\x3', '\x174', '\a', '\x174', '\x1124', '\n', 
		'\x174', '\f', '\x174', '\xE', '\x174', '\x1127', '\v', '\x174', '\x3', 
		'\x174', '\x3', '\x174', '\x3', '\x175', '\x3', '\x175', '\x3', '\x175', 
		'\x3', '\x175', '\x5', '\x175', '\x112F', '\n', '\x175', '\x3', '\x176', 
		'\x3', '\x176', '\x3', '\x176', '\x3', '\x176', '\x5', '\x176', '\x1135', 
		'\n', '\x176', '\x3', '\x177', '\x3', '\x177', '\x3', '\x177', '\x3', 
		'\x177', '\x5', '\x177', '\x113B', '\n', '\x177', '\x3', '\x178', '\x3', 
		'\x178', '\x3', '\x178', '\x3', '\x178', '\x3', '\x178', '\a', '\x178', 
		'\x1142', '\n', '\x178', '\f', '\x178', '\xE', '\x178', '\x1145', '\v', 
		'\x178', '\x3', '\x178', '\x3', '\x178', '\x3', '\x178', '\x3', '\x179', 
		'\x3', '\x179', '\x3', '\x179', '\x3', '\x179', '\x3', '\x179', '\x3', 
		'\x179', '\x5', '\x179', '\x1150', '\n', '\x179', '\x3', '\x17A', '\x3', 
		'\x17A', '\x3', '\x17A', '\x5', '\x17A', '\x1155', '\n', '\x17A', '\x3', 
		'\x17A', '\x3', '\x17A', '\x3', '\x17A', '\x5', '\x17A', '\x115A', '\n', 
		'\x17A', '\x3', '\x17A', '\x3', '\x17A', '\x6', '\x17A', '\x115E', '\n', 
		'\x17A', '\r', '\x17A', '\xE', '\x17A', '\x115F', '\x5', '\x17A', '\x1162', 
		'\n', '\x17A', '\x3', '\x17B', '\x3', '\x17B', '\x3', '\x17B', '\x3', 
		'\x17B', '\x3', '\x17B', '\x3', '\x17B', '\x5', '\x17B', '\x116A', '\n', 
		'\x17B', '\x5', '\x17B', '\x116C', '\n', '\x17B', '\x3', '\x17B', '\x3', 
		'\x17B', '\x3', '\x17B', '\x3', '\x17B', '\a', '\x17B', '\x1172', '\n', 
		'\x17B', '\f', '\x17B', '\xE', '\x17B', '\x1175', '\v', '\x17B', '\x3', 
		'\x17B', '\x3', '\x17B', '\a', '\x17B', '\x1179', '\n', '\x17B', '\f', 
		'\x17B', '\xE', '\x17B', '\x117C', '\v', '\x17B', '\x5', '\x17B', '\x117E', 
		'\n', '\x17B', '\x3', '\x17C', '\x3', '\x17C', '\x3', '\x17C', '\x5', 
		'\x17C', '\x1183', '\n', '\x17C', '\x3', '\x17C', '\x3', '\x17C', '\x3', 
		'\x17D', '\x3', '\x17D', '\x5', '\x17D', '\x1189', '\n', '\x17D', '\x3', 
		'\x17D', '\x3', '\x17D', '\x3', '\x17D', '\x3', '\x17D', '\x3', '\x17D', 
		'\x5', '\x17D', '\x1190', '\n', '\x17D', '\x3', '\x17D', '\x5', '\x17D', 
		'\x1193', '\n', '\x17D', '\x3', '\x17E', '\x3', '\x17E', '\x3', '\x17F', 
		'\x3', '\x17F', '\x3', '\x17F', '\x5', '\x17F', '\x119A', '\n', '\x17F', 
		'\x3', '\x180', '\x3', '\x180', '\x3', '\x180', '\x3', '\x180', '\x3', 
		'\x180', '\x3', '\x181', '\x3', '\x181', '\x3', '\x181', '\x3', '\x181', 
		'\x3', '\x181', '\x3', '\x181', '\x3', '\x182', '\x5', '\x182', '\x11A8', 
		'\n', '\x182', '\x3', '\x182', '\x3', '\x182', '\x5', '\x182', '\x11AC', 
		'\n', '\x182', '\x3', '\x182', '\x5', '\x182', '\x11AF', '\n', '\x182', 
		'\x3', '\x182', '\x3', '\x182', '\x5', '\x182', '\x11B3', '\n', '\x182', 
		'\x3', '\x183', '\x3', '\x183', '\x3', '\x183', '\x3', '\x184', '\x3', 
		'\x184', '\x3', '\x184', '\x3', '\x184', '\x3', '\x185', '\x3', '\x185', 
		'\x3', '\x185', '\x3', '\x185', '\x3', '\x186', '\x5', '\x186', '\x11C1', 
		'\n', '\x186', '\x3', '\x186', '\x3', '\x186', '\x3', '\x186', '\x5', 
		'\x186', '\x11C6', '\n', '\x186', '\x3', '\x186', '\x5', '\x186', '\x11C9', 
		'\n', '\x186', '\x3', '\x187', '\x3', '\x187', '\x3', '\x187', '\x3', 
		'\x187', '\x3', '\x188', '\x3', '\x188', '\x3', '\x188', '\x3', '\x188', 
		'\x5', '\x188', '\x11D3', '\n', '\x188', '\x3', '\x188', '\x5', '\x188', 
		'\x11D6', '\n', '\x188', '\x3', '\x188', '\x5', '\x188', '\x11D9', '\n', 
		'\x188', '\x3', '\x188', '\x3', '\x188', '\x3', '\x188', '\x3', '\x188', 
		'\x5', '\x188', '\x11DF', '\n', '\x188', '\x3', '\x188', '\x5', '\x188', 
		'\x11E2', '\n', '\x188', '\x3', '\x188', '\x5', '\x188', '\x11E5', '\n', 
		'\x188', '\x3', '\x188', '\x5', '\x188', '\x11E8', '\n', '\x188', '\x3', 
		'\x188', '\x5', '\x188', '\x11EB', '\n', '\x188', '\x3', '\x188', '\x5', 
		'\x188', '\x11EE', '\n', '\x188', '\x3', '\x189', '\x3', '\x189', '\x3', 
		'\x189', '\x3', '\x18A', '\x3', '\x18A', '\x3', '\x18A', '\x3', '\x18A', 
		'\x3', '\x18A', '\x3', '\x18A', '\x5', '\x18A', '\x11F9', '\n', '\x18A', 
		'\x3', '\x18B', '\x3', '\x18B', '\x3', '\x18B', '\x3', '\x18B', '\x3', 
		'\x18C', '\x3', '\x18C', '\x6', '\x18C', '\x1201', '\n', '\x18C', '\r', 
		'\x18C', '\xE', '\x18C', '\x1202', '\x3', '\x18C', '\x3', '\x18C', '\x3', 
		'\x18D', '\x5', '\x18D', '\x1208', '\n', '\x18D', '\x3', '\x18D', '\x5', 
		'\x18D', '\x120B', '\n', '\x18D', '\x3', '\x18D', '\x5', '\x18D', '\x120E', 
		'\n', '\x18D', '\x3', '\x18D', '\x5', '\x18D', '\x1211', '\n', '\x18D', 
		'\x3', '\x18D', '\x5', '\x18D', '\x1214', '\n', '\x18D', '\x3', '\x18E', 
		'\x3', '\x18E', '\x3', '\x18F', '\x3', '\x18F', '\x3', '\x18F', '\x3', 
		'\x190', '\x3', '\x190', '\x3', '\x190', '\x3', '\x190', '\x3', '\x190', 
		'\x5', '\x190', '\x1220', '\n', '\x190', '\x5', '\x190', '\x1222', '\n', 
		'\x190', '\x3', '\x191', '\x3', '\x191', '\x6', '\x191', '\x1226', '\n', 
		'\x191', '\r', '\x191', '\xE', '\x191', '\x1227', '\x3', '\x192', '\x3', 
		'\x192', '\x3', '\x192', '\x3', '\x192', '\x5', '\x192', '\x122E', '\n', 
		'\x192', '\x3', '\x193', '\x3', '\x193', '\x3', '\x193', '\x3', '\x193', 
		'\x3', '\x193', '\x3', '\x193', '\x6', '\x193', '\x1236', '\n', '\x193', 
		'\r', '\x193', '\xE', '\x193', '\x1237', '\x3', '\x194', '\x3', '\x194', 
		'\x3', '\x195', '\x3', '\x195', '\x3', '\x195', '\x3', '\x196', '\x3', 
		'\x196', '\x3', '\x196', '\x5', '\x196', '\x1242', '\n', '\x196', '\x3', 
		'\x196', '\x3', '\x196', '\x3', '\x197', '\x3', '\x197', '\x3', '\x197', 
		'\x3', '\x197', '\x5', '\x197', '\x124A', '\n', '\x197', '\x3', '\x198', 
		'\x3', '\x198', '\x3', '\x198', '\x5', '\x198', '\x124F', '\n', '\x198', 
		'\x3', '\x198', '\x3', '\x198', '\x3', '\x198', '\x5', '\x198', '\x1254', 
		'\n', '\x198', '\x3', '\x198', '\x3', '\x198', '\x3', '\x198', '\x5', 
		'\x198', '\x1259', '\n', '\x198', '\x3', '\x199', '\x3', '\x199', '\x3', 
		'\x199', '\x3', '\x199', '\x3', '\x19A', '\x3', '\x19A', '\x3', '\x19A', 
		'\x3', '\x19A', '\x3', '\x19A', '\x3', '\x19A', '\x3', '\x19A', '\x3', 
		'\x19A', '\x5', '\x19A', '\x1267', '\n', '\x19A', '\x3', '\x19B', '\x3', 
		'\x19B', '\x3', '\x19B', '\x3', '\x19B', '\x3', '\x19B', '\x3', '\x19C', 
		'\x3', '\x19C', '\x3', '\x19C', '\x3', '\x19C', '\x5', '\x19C', '\x1272', 
		'\n', '\x19C', '\x3', '\x19C', '\x5', '\x19C', '\x1275', '\n', '\x19C', 
		'\x3', '\x19D', '\x3', '\x19D', '\x3', '\x19D', '\x3', '\x19D', '\x3', 
		'\x19D', '\x3', '\x19D', '\x5', '\x19D', '\x127D', '\n', '\x19D', '\x3', 
		'\x19E', '\x3', '\x19E', '\x3', '\x19E', '\x3', '\x19E', '\x3', '\x19E', 
		'\x3', '\x19E', '\x3', '\x19E', '\x3', '\x19E', '\x3', '\x19E', '\x5', 
		'\x19E', '\x1288', '\n', '\x19E', '\x3', '\x19F', '\x5', '\x19F', '\x128B', 
		'\n', '\x19F', '\x3', '\x19F', '\x5', '\x19F', '\x128E', '\n', '\x19F', 
		'\x3', '\x19F', '\x5', '\x19F', '\x1291', '\n', '\x19F', '\x3', '\x19F', 
		'\x3', '\x19F', '\x3', '\x19F', '\x3', '\x1A0', '\x3', '\x1A0', '\x3', 
		'\x1A0', '\x3', '\x1A0', '\x3', '\x1A0', '\x5', '\x1A0', '\x129B', '\n', 
		'\x1A0', '\x3', '\x1A0', '\x5', '\x1A0', '\x129E', '\n', '\x1A0', '\x3', 
		'\x1A0', '\x3', '\x1A0', '\x3', '\x1A1', '\x3', '\x1A1', '\x3', '\x1A1', 
		'\x3', '\x1A1', '\x3', '\x1A1', '\x3', '\x1A2', '\x5', '\x1A2', '\x12A8', 
		'\n', '\x1A2', '\x3', '\x1A2', '\x5', '\x1A2', '\x12AB', '\n', '\x1A2', 
		'\x3', '\x1A2', '\x5', '\x1A2', '\x12AE', '\n', '\x1A2', '\x3', '\x1A2', 
		'\x5', '\x1A2', '\x12B1', '\n', '\x1A2', '\x3', '\x1A2', '\x5', '\x1A2', 
		'\x12B4', '\n', '\x1A2', '\x3', '\x1A3', '\x3', '\x1A3', '\x3', '\x1A3', 
		'\x3', '\x1A4', '\x3', '\x1A4', '\x3', '\x1A4', '\x3', '\x1A4', '\x5', 
		'\x1A4', '\x12BD', '\n', '\x1A4', '\x3', '\x1A5', '\x3', '\x1A5', '\x3', 
		'\x1A5', '\x3', '\x1A6', '\x3', '\x1A6', '\x3', '\x1A6', '\x3', '\x1A7', 
		'\x3', '\x1A7', '\x3', '\x1A7', '\x3', '\x1A7', '\x5', '\x1A7', '\x12C9', 
		'\n', '\x1A7', '\x3', '\x1A7', '\x5', '\x1A7', '\x12CC', '\n', '\x1A7', 
		'\x3', '\x1A8', '\x3', '\x1A8', '\x3', '\x1A8', '\x3', '\x1A9', '\x3', 
		'\x1A9', '\x3', '\x1A9', '\x3', '\x1A9', '\x3', '\x1A9', '\x5', '\x1A9', 
		'\x12D6', '\n', '\x1A9', '\x3', '\x1AA', '\x3', '\x1AA', '\x3', '\x1AA', 
		'\x3', '\x1AA', '\x3', '\x1AB', '\x5', '\x1AB', '\x12DD', '\n', '\x1AB', 
		'\x3', '\x1AB', '\x3', '\x1AB', '\x3', '\x1AC', '\x3', '\x1AC', '\x3', 
		'\x1AD', '\x3', '\x1AD', '\x3', '\x1AD', '\x5', '\x1AD', '\x12E6', '\n', 
		'\x1AD', '\x3', '\x1AD', '\x5', '\x1AD', '\x12E9', '\n', '\x1AD', '\x3', 
		'\x1AE', '\x3', '\x1AE', '\x3', '\x1AE', '\x3', '\x1AE', '\a', '\x1AE', 
		'\x12EF', '\n', '\x1AE', '\f', '\x1AE', '\xE', '\x1AE', '\x12F2', '\v', 
		'\x1AE', '\x3', '\x1AE', '\x3', '\x1AE', '\x3', '\x1AF', '\x3', '\x1AF', 
		'\x5', '\x1AF', '\x12F8', '\n', '\x1AF', '\x3', '\x1B0', '\x3', '\x1B0', 
		'\a', '\x1B0', '\x12FC', '\n', '\x1B0', '\f', '\x1B0', '\xE', '\x1B0', 
		'\x12FF', '\v', '\x1B0', '\x3', '\x1B1', '\x3', '\x1B1', '\x3', '\x1B1', 
		'\x3', '\x1B1', '\a', '\x1B1', '\x1305', '\n', '\x1B1', '\f', '\x1B1', 
		'\xE', '\x1B1', '\x1308', '\v', '\x1B1', '\x3', '\x1B1', '\x3', '\x1B1', 
		'\x3', '\x1B2', '\x3', '\x1B2', '\x5', '\x1B2', '\x130E', '\n', '\x1B2', 
		'\x3', '\x1B3', '\x3', '\x1B3', '\x6', '\x1B3', '\x1312', '\n', '\x1B3', 
		'\r', '\x1B3', '\xE', '\x1B3', '\x1313', '\x3', '\x1B4', '\x5', '\x1B4', 
		'\x1317', '\n', '\x1B4', '\x3', '\x1B4', '\x3', '\x1B4', '\x3', '\x1B4', 
		'\x3', '\x1B4', '\x5', '\x1B4', '\x131D', '\n', '\x1B4', '\x3', '\x1B4', 
		'\x5', '\x1B4', '\x1320', '\n', '\x1B4', '\x3', '\x1B5', '\x3', '\x1B5', 
		'\x3', '\x1B5', '\x5', '\x1B5', '\x1325', '\n', '\x1B5', '\x3', '\x1B5', 
		'\x3', '\x1B5', '\x3', '\x1B5', '\x5', '\x1B5', '\x132A', '\n', '\x1B5', 
		'\a', '\x1B5', '\x132C', '\n', '\x1B5', '\f', '\x1B5', '\xE', '\x1B5', 
		'\x132F', '\v', '\x1B5', '\x3', '\x1B5', '\x3', '\x1B5', '\x3', '\x1B6', 
		'\x5', '\x1B6', '\x1334', '\n', '\x1B6', '\x3', '\x1B6', '\x3', '\x1B6', 
		'\x3', '\x1B6', '\x3', '\x1B6', '\x3', '\x1B6', '\x5', '\x1B6', '\x133B', 
		'\n', '\x1B6', '\x3', '\x1B6', '\x5', '\x1B6', '\x133E', '\n', '\x1B6', 
		'\x3', '\x1B7', '\x3', '\x1B7', '\x3', '\x1B7', '\x3', '\x1B7', '\x3', 
		'\x1B7', '\x3', '\x1B7', '\x3', '\x1B7', '\x6', '\x1B7', '\x1347', '\n', 
		'\x1B7', '\r', '\x1B7', '\xE', '\x1B7', '\x1348', '\x3', '\x1B8', '\x5', 
		'\x1B8', '\x134C', '\n', '\x1B8', '\x3', '\x1B8', '\x3', '\x1B8', '\x3', 
		'\x1B9', '\x3', '\x1B9', '\x3', '\x1B9', '\x3', '\x1BA', '\x3', '\x1BA', 
		'\x3', '\x1BB', '\x3', '\x1BB', '\x3', '\x1BC', '\x3', '\x1BC', '\x3', 
		'\x1BC', '\x3', '\x1BC', '\x5', '\x1BC', '\x135B', '\n', '\x1BC', '\x3', 
		'\x1BD', '\x3', '\x1BD', '\x3', '\x1BD', '\x3', '\x1BD', '\x3', '\x1BD', 
		'\x3', '\x1BD', '\x6', '\x1BD', '\x1363', '\n', '\x1BD', '\r', '\x1BD', 
		'\xE', '\x1BD', '\x1364', '\x3', '\x1BE', '\x3', '\x1BE', '\x5', '\x1BE', 
		'\x1369', '\n', '\x1BE', '\x3', '\x1BF', '\x3', '\x1BF', '\x3', '\x1BF', 
		'\x5', '\x1BF', '\x136E', '\n', '\x1BF', '\x3', '\x1C0', '\x3', '\x1C0', 
		'\x3', '\x1C1', '\x3', '\x1C1', '\x5', '\x1C1', '\x1374', '\n', '\x1C1', 
		'\x3', '\x1C1', '\x3', '\x1C1', '\x5', '\x1C1', '\x1378', '\n', '\x1C1', 
		'\x3', '\x1C2', '\x3', '\x1C2', '\x3', '\x1C3', '\x3', '\x1C3', '\x3', 
		'\x1C3', '\x6', '\x1C3', '\x137F', '\n', '\x1C3', '\r', '\x1C3', '\xE', 
		'\x1C3', '\x1380', '\x3', '\x1C3', '\x3', '\x1C3', '\x3', '\x1C4', '\x3', 
		'\x1C4', '\x3', '\x1C4', '\x3', '\x1C4', '\x3', '\x1C4', '\x3', '\x1C4', 
		'\x3', '\x1C4', '\x3', '\x1C4', '\x3', '\x1C4', '\x3', '\x1C4', '\x3', 
		'\x1C4', '\x3', '\x1C4', '\x5', '\x1C4', '\x1391', '\n', '\x1C4', '\x3', 
		'\x1C5', '\x3', '\x1C5', '\x3', '\x1C5', '\x5', '\x1C5', '\x1396', '\n', 
		'\x1C5', '\x3', '\x1C6', '\x3', '\x1C6', '\x3', '\x1C7', '\x3', '\x1C7', 
		'\x3', '\x1C7', '\x3', '\x1C8', '\x3', '\x1C8', '\x3', '\x1C8', '\x5', 
		'\x1C8', '\x13A0', '\n', '\x1C8', '\x5', '\x1C8', '\x13A2', '\n', '\x1C8', 
		'\x3', '\x1C9', '\x3', '\x1C9', '\x3', '\x1C9', '\x3', '\x1CA', '\x3', 
		'\x1CA', '\x3', '\x1CA', '\x5', '\x1CA', '\x13AA', '\n', '\x1CA', '\x3', 
		'\x1CB', '\x3', '\x1CB', '\x3', '\x1CB', '\x3', '\x1CC', '\x3', '\x1CC', 
		'\x3', '\x1CC', '\x3', '\x1CD', '\x3', '\x1CD', '\x3', '\x1CD', '\x3', 
		'\x1CD', '\x3', '\x1CE', '\x3', '\x1CE', '\x3', '\x1CE', '\x3', '\x1CF', 
		'\x3', '\x1CF', '\x3', '\x1CF', '\x3', '\x1D0', '\x3', '\x1D0', '\x3', 
		'\x1D0', '\x3', '\x1D1', '\x3', '\x1D1', '\x3', '\x1D1', '\x3', '\x1D2', 
		'\x3', '\x1D2', '\x3', '\x1D3', '\x3', '\x1D3', '\x3', '\x1D3', '\x3', 
		'\x1D3', '\x3', '\x1D4', '\x3', '\x1D4', '\x3', '\x1D5', '\x3', '\x1D5', 
		'\x3', '\x1D5', '\x3', '\x1D6', '\x5', '\x1D6', '\x13CE', '\n', '\x1D6', 
		'\x3', '\x1D6', '\x3', '\x1D6', '\x3', '\x1D7', '\x3', '\x1D7', '\x5', 
		'\x1D7', '\x13D4', '\n', '\x1D7', '\x3', '\x1D8', '\x3', '\x1D8', '\x3', 
		'\x1D8', '\x5', '\x1D8', '\x13D9', '\n', '\x1D8', '\x3', '\x1D9', '\x3', 
		'\x1D9', '\x3', '\x1D9', '\x3', '\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', 
		'\x3', '\x1DA', '\x3', '\x1DB', '\x3', '\x1DB', '\x5', '\x1DB', '\x13E4', 
		'\n', '\x1DB', '\x3', '\x1DB', '\x5', '\x1DB', '\x13E7', '\n', '\x1DB', 
		'\x3', '\x1DB', '\x3', '\x1DB', '\x5', '\x1DB', '\x13EB', '\n', '\x1DB', 
		'\x3', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x5', '\x1DC', '\x13F0', 
		'\n', '\x1DC', '\x3', '\x1DD', '\x3', '\x1DD', '\x3', '\x1DD', '\x3', 
		'\x1DD', '\x3', '\x1DD', '\x5', '\x1DD', '\x13F7', '\n', '\x1DD', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x5', '\x1DE', '\x13FF', '\n', '\x1DE', '\x3', '\x1DF', 
		'\x3', '\x1DF', '\x3', '\x1DF', '\x5', '\x1DF', '\x1404', '\n', '\x1DF', 
		'\x3', '\x1DF', '\x3', '\x1DF', '\x5', '\x1DF', '\x1408', '\n', '\x1DF', 
		'\x3', '\x1E0', '\x3', '\x1E0', '\x3', '\x1E0', '\x3', '\x1E0', '\x5', 
		'\x1E0', '\x140E', '\n', '\x1E0', '\x3', '\x1E1', '\x3', '\x1E1', '\x3', 
		'\x1E1', '\x5', '\x1E1', '\x1413', '\n', '\x1E1', '\x3', '\x1E1', '\x3', 
		'\x1E1', '\x3', '\x1E2', '\x3', '\x1E2', '\x3', '\x1E2', '\x5', '\x1E2', 
		'\x141A', '\n', '\x1E2', '\x3', '\x1E2', '\x3', '\x1E2', '\x3', '\x1E2', 
		'\x5', '\x1E2', '\x141F', '\n', '\x1E2', '\x3', '\x1E3', '\x3', '\x1E3', 
		'\x3', '\x1E3', '\x5', '\x1E3', '\x1424', '\n', '\x1E3', '\x3', '\x1E3', 
		'\x6', '\x1E3', '\x1427', '\n', '\x1E3', '\r', '\x1E3', '\xE', '\x1E3', 
		'\x1428', '\x3', '\x1E3', '\x3', '\x1E3', '\x3', '\x1E4', '\x3', '\x1E4', 
		'\x3', '\x1E4', '\x3', '\x1E4', '\x3', '\x1E4', '\x3', '\x1E4', '\x3', 
		'\x1E5', '\x3', '\x1E5', '\x3', '\x1E5', '\x3', '\x1E5', '\x3', '\x1E5', 
		'\x3', '\x1E5', '\x5', '\x1E5', '\x1439', '\n', '\x1E5', '\x3', '\x1E5', 
		'\x3', '\x1E5', '\x5', '\x1E5', '\x143D', '\n', '\x1E5', '\x3', '\x1E6', 
		'\x3', '\x1E6', '\x3', '\x1E6', '\x5', '\x1E6', '\x1442', '\n', '\x1E6', 
		'\x3', '\x1E7', '\x3', '\x1E7', '\x3', '\x1E7', '\x3', '\x1E7', '\x3', 
		'\x1E8', '\x3', '\x1E8', '\x3', '\x1E8', '\x5', '\x1E8', '\x144B', '\n', 
		'\x1E8', '\x3', '\x1E9', '\x5', '\x1E9', '\x144E', '\n', '\x1E9', '\x3', 
		'\x1E9', '\x3', '\x1E9', '\x3', '\x1EA', '\x3', '\x1EA', '\x3', '\x1EA', 
		'\x3', '\x1EB', '\x3', '\x1EB', '\x3', '\x1EB', '\x3', '\x1EC', '\x3', 
		'\x1EC', '\x3', '\x1EC', '\a', '\x1EC', '\x145B', '\n', '\x1EC', '\f', 
		'\x1EC', '\xE', '\x1EC', '\x145E', '\v', '\x1EC', '\x3', '\x1ED', '\x3', 
		'\x1ED', '\x3', '\x1ED', '\a', '\x1ED', '\x1463', '\n', '\x1ED', '\f', 
		'\x1ED', '\xE', '\x1ED', '\x1466', '\v', '\x1ED', '\x3', '\x1EE', '\x3', 
		'\x1EE', '\x3', '\x1EE', '\x3', '\x1EE', '\x3', '\x1EE', '\x3', '\x1EE', 
		'\x3', '\x1EE', '\x3', '\x1EE', '\x3', '\x1EE', '\x3', '\x1EE', '\x3', 
		'\x1EE', '\x3', '\x1EE', '\x3', '\x1EE', '\x3', '\x1EE', '\x3', '\x1EE', 
		'\x3', '\x1EE', '\x5', '\x1EE', '\x1478', '\n', '\x1EE', '\x3', '\x1EF', 
		'\x3', '\x1EF', '\x3', '\x1F0', '\x3', '\x1F0', '\x3', '\x1F0', '\x3', 
		'\x1F0', '\x3', '\x1F0', '\x5', '\x1F0', '\x1481', '\n', '\x1F0', '\x3', 
		'\x1F1', '\x3', '\x1F1', '\x3', '\x1F1', '\x5', '\x1F1', '\x1486', '\n', 
		'\x1F1', '\x3', '\x1F1', '\x5', '\x1F1', '\x1489', '\n', '\x1F1', '\x3', 
		'\x1F2', '\x3', '\x1F2', '\x3', '\x1F2', '\a', '\x1F2', '\x148E', '\n', 
		'\x1F2', '\f', '\x1F2', '\xE', '\x1F2', '\x1491', '\v', '\x1F2', '\x3', 
		'\x1F3', '\x3', '\x1F3', '\x5', '\x1F3', '\x1495', '\n', '\x1F3', '\x3', 
		'\x1F4', '\x3', '\x1F4', '\x3', '\x1F4', '\x3', '\x1F5', '\x3', '\x1F5', 
		'\x3', '\x1F5', '\x3', '\x1F5', '\x3', '\x1F5', '\x5', '\x1F5', '\x149F', 
		'\n', '\x1F5', '\x3', '\x1F6', '\x3', '\x1F6', '\x3', '\x1F6', '\x3', 
		'\x1F6', '\x3', '\x1F6', '\x3', '\x1F7', '\x3', '\x1F7', '\x6', '\x1F7', 
		'\x14A8', '\n', '\x1F7', '\r', '\x1F7', '\xE', '\x1F7', '\x14A9', '\x3', 
		'\x1F8', '\x3', '\x1F8', '\x5', '\x1F8', '\x14AE', '\n', '\x1F8', '\x3', 
		'\x1F8', '\x3', '\x1F8', '\x3', '\x1F9', '\x3', '\x1F9', '\x3', '\x1F9', 
		'\x3', '\x1F9', '\x3', '\x1FA', '\x3', '\x1FA', '\x3', '\x1FA', '\x3', 
		'\x1FA', '\x5', '\x1FA', '\x14BA', '\n', '\x1FA', '\x3', '\x1FB', '\x3', 
		'\x1FB', '\x3', '\x1FB', '\x3', '\x1FB', '\x3', '\x1FB', '\x3', '\x1FC', 
		'\x5', '\x1FC', '\x14C2', '\n', '\x1FC', '\x3', '\x1FC', '\x3', '\x1FC', 
		'\x3', '\x1FC', '\x3', '\x1FC', '\a', '\x1FC', '\x14C8', '\n', '\x1FC', 
		'\f', '\x1FC', '\xE', '\x1FC', '\x14CB', '\v', '\x1FC', '\x3', '\x1FC', 
		'\x3', '\x1FC', '\x5', '\x1FC', '\x14CF', '\n', '\x1FC', '\x3', '\x1FC', 
		'\x3', '\x1FC', '\x5', '\x1FC', '\x14D3', '\n', '\x1FC', '\x5', '\x1FC', 
		'\x14D5', '\n', '\x1FC', '\x3', '\x1FC', '\x5', '\x1FC', '\x14D8', '\n', 
		'\x1FC', '\x3', '\x1FD', '\x3', '\x1FD', '\x3', '\x1FD', '\x3', '\x1FD', 
		'\x3', '\x1FD', '\x5', '\x1FD', '\x14DF', '\n', '\x1FD', '\x3', '\x1FE', 
		'\x3', '\x1FE', '\x3', '\x1FE', '\x3', '\x1FE', '\x3', '\x1FE', '\x5', 
		'\x1FE', '\x14E6', '\n', '\x1FE', '\x3', '\x1FF', '\x3', '\x1FF', '\x3', 
		'\x1FF', '\x3', '\x200', '\x3', '\x200', '\x3', '\x200', '\x3', '\x201', 
		'\x3', '\x201', '\x5', '\x201', '\x14F0', '\n', '\x201', '\x3', '\x201', 
		'\x3', '\x201', '\x3', '\x201', '\x3', '\x202', '\x3', '\x202', '\x5', 
		'\x202', '\x14F7', '\n', '\x202', '\x3', '\x202', '\x3', '\x202', '\x3', 
		'\x202', '\x3', '\x203', '\x3', '\x203', '\x5', '\x203', '\x14FE', '\n', 
		'\x203', '\x3', '\x203', '\x3', '\x203', '\x3', '\x203', '\x3', '\x204', 
		'\x3', '\x204', '\x3', '\x204', '\a', '\x204', '\x1506', '\n', '\x204', 
		'\f', '\x204', '\xE', '\x204', '\x1509', '\v', '\x204', '\x3', '\x205', 
		'\x3', '\x205', '\x5', '\x205', '\x150D', '\n', '\x205', '\x3', '\x205', 
		'\x5', '\x205', '\x1510', '\n', '\x205', '\x3', '\x206', '\x3', '\x206', 
		'\x3', '\x207', '\x3', '\x207', '\x3', '\x207', '\x3', '\x208', '\x3', 
		'\x208', '\x3', '\x208', '\x3', '\x208', '\x3', '\x208', '\x5', '\x208', 
		'\x151C', '\n', '\x208', '\x3', '\x208', '\x3', '\x208', '\x5', '\x208', 
		'\x1520', '\n', '\x208', '\x3', '\x209', '\x3', '\x209', '\x3', '\x20A', 
		'\x3', '\x20A', '\x3', '\x20A', '\x5', '\x20A', '\x1527', '\n', '\x20A', 
		'\x3', '\x20B', '\x3', '\x20B', '\x3', '\x20B', '\x3', '\x20C', '\x3', 
		'\x20C', '\x3', '\x20C', '\x3', '\x20C', '\a', '\x20C', '\x1530', '\n', 
		'\x20C', '\f', '\x20C', '\xE', '\x20C', '\x1533', '\v', '\x20C', '\x3', 
		'\x20D', '\x3', '\x20D', '\x5', '\x20D', '\x1537', '\n', '\x20D', '\x3', 
		'\x20D', '\x3', '\x20D', '\x5', '\x20D', '\x153B', '\n', '\x20D', '\x3', 
		'\x20D', '\x5', '\x20D', '\x153E', '\n', '\x20D', '\x3', '\x20E', '\x3', 
		'\x20E', '\x3', '\x20E', '\x3', '\x20E', '\x3', '\x20F', '\x3', '\x20F', 
		'\x3', '\x20F', '\x3', '\x20F', '\x3', '\x20F', '\x3', '\x20F', '\x3', 
		'\x20F', '\x3', '\x210', '\x3', '\x210', '\x3', '\x210', '\x3', '\x211', 
		'\x3', '\x211', '\x3', '\x211', '\x3', '\x211', '\x3', '\x211', '\x3', 
		'\x211', '\x3', '\x212', '\x3', '\x212', '\x3', '\x212', '\x3', '\x213', 
		'\x3', '\x213', '\x3', '\x213', '\x3', '\x214', '\x3', '\x214', '\x5', 
		'\x214', '\x155C', '\n', '\x214', '\x3', '\x214', '\x3', '\x214', '\x3', 
		'\x214', '\x5', '\x214', '\x1561', '\n', '\x214', '\x3', '\x214', '\x3', 
		'\x214', '\x5', '\x214', '\x1565', '\n', '\x214', '\x3', '\x214', '\x3', 
		'\x214', '\x5', '\x214', '\x1569', '\n', '\x214', '\x3', '\x214', '\x3', 
		'\x214', '\x3', '\x214', '\x5', '\x214', '\x156E', '\n', '\x214', '\x3', 
		'\x214', '\x3', '\x214', '\x5', '\x214', '\x1572', '\n', '\x214', '\x3', 
		'\x214', '\x3', '\x214', '\x5', '\x214', '\x1576', '\n', '\x214', '\x5', 
		'\x214', '\x1578', '\n', '\x214', '\x3', '\x215', '\x3', '\x215', '\x3', 
		'\x216', '\x3', '\x216', '\x3', '\x216', '\x3', '\x217', '\x3', '\x217', 
		'\x3', '\x217', '\x3', '\x218', '\x3', '\x218', '\x3', '\x218', '\x3', 
		'\x218', '\x3', '\x219', '\x3', '\x219', '\x3', '\x21A', '\x3', '\x21A', 
		'\x3', '\x21A', '\a', '\x21A', '\x158B', '\n', '\x21A', '\f', '\x21A', 
		'\xE', '\x21A', '\x158E', '\v', '\x21A', '\x3', '\x21B', '\x3', '\x21B', 
		'\x5', '\x21B', '\x1592', '\n', '\x21B', '\x3', '\x21C', '\x3', '\x21C', 
		'\x3', '\x21C', '\x3', '\x21C', '\a', '\x21C', '\x1598', '\n', '\x21C', 
		'\f', '\x21C', '\xE', '\x21C', '\x159B', '\v', '\x21C', '\x3', '\x21C', 
		'\x3', '\x21C', '\x3', '\x21D', '\x3', '\x21D', '\x3', '\x21D', '\x3', 
		'\x21D', '\x5', '\x21D', '\x15A3', '\n', '\x21D', '\x3', '\x21E', '\x3', 
		'\x21E', '\x3', '\x21E', '\x3', '\x21F', '\x3', '\x21F', '\x3', '\x21F', 
		'\x3', '\x21F', '\x3', '\x21F', '\x3', '\x21F', '\x3', '\x220', '\x3', 
		'\x220', '\x3', '\x220', '\a', '\x220', '\x15B1', '\n', '\x220', '\f', 
		'\x220', '\xE', '\x220', '\x15B4', '\v', '\x220', '\x3', '\x221', '\x3', 
		'\x221', '\x3', '\x221', '\x5', '\x221', '\x15B9', '\n', '\x221', '\x3', 
		'\x222', '\x3', '\x222', '\x5', '\x222', '\x15BD', '\n', '\x222', '\x3', 
		'\x223', '\x3', '\x223', '\x3', '\x223', '\x3', '\x223', '\a', '\x223', 
		'\x15C3', '\n', '\x223', '\f', '\x223', '\xE', '\x223', '\x15C6', '\v', 
		'\x223', '\x3', '\x223', '\x3', '\x223', '\x3', '\x224', '\x3', '\x224', 
		'\x3', '\x224', '\x3', '\x224', '\x3', '\x224', '\x3', '\x225', '\x3', 
		'\x225', '\x3', '\x225', '\a', '\x225', '\x15D2', '\n', '\x225', '\f', 
		'\x225', '\xE', '\x225', '\x15D5', '\v', '\x225', '\x3', '\x226', '\x3', 
		'\x226', '\x5', '\x226', '\x15D9', '\n', '\x226', '\x3', '\x227', '\x3', 
		'\x227', '\x3', '\x227', '\x3', '\x227', '\a', '\x227', '\x15DF', '\n', 
		'\x227', '\f', '\x227', '\xE', '\x227', '\x15E2', '\v', '\x227', '\x3', 
		'\x227', '\x3', '\x227', '\x3', '\x228', '\x3', '\x228', '\x3', '\x228', 
		'\x5', '\x228', '\x15E9', '\n', '\x228', '\x3', '\x228', '\x3', '\x228', 
		'\x3', '\x229', '\x3', '\x229', '\x3', '\x229', '\x3', '\x229', '\x3', 
		'\x22A', '\x3', '\x22A', '\x3', '\x22A', '\x3', '\x22B', '\x3', '\x22B', 
		'\x3', '\x22B', '\x3', '\x22B', '\a', '\x22B', '\x15F8', '\n', '\x22B', 
		'\f', '\x22B', '\xE', '\x22B', '\x15FB', '\v', '\x22B', '\x3', '\x22C', 
		'\x3', '\x22C', '\x5', '\x22C', '\x15FF', '\n', '\x22C', '\x3', '\x22D', 
		'\x3', '\x22D', '\x5', '\x22D', '\x1603', '\n', '\x22D', '\x3', '\x22D', 
		'\x3', '\x22D', '\x3', '\x22D', '\x3', '\x22D', '\x5', '\x22D', '\x1609', 
		'\n', '\x22D', '\x3', '\x22D', '\x3', '\x22D', '\x3', '\x22D', '\a', '\x22D', 
		'\x160E', '\n', '\x22D', '\f', '\x22D', '\xE', '\x22D', '\x1611', '\v', 
		'\x22D', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', 
		'\x3', '\x22E', '\x5', '\x22E', '\x1618', '\n', '\x22E', '\x3', '\x22E', 
		'\x5', '\x22E', '\x161B', '\n', '\x22E', '\x3', '\x22F', '\x3', '\x22F', 
		'\x5', '\x22F', '\x161F', '\n', '\x22F', '\x3', '\x22F', '\x3', '\x22F', 
		'\x3', '\x230', '\x3', '\x230', '\x5', '\x230', '\x1625', '\n', '\x230', 
		'\x3', '\x231', '\x3', '\x231', '\x3', '\x231', '\x3', '\x232', '\x3', 
		'\x232', '\x3', '\x232', '\x3', '\x232', '\x3', '\x232', '\a', '\x232', 
		'\x162F', '\n', '\x232', '\f', '\x232', '\xE', '\x232', '\x1632', '\v', 
		'\x232', '\x3', '\x232', '\x3', '\x232', '\x3', '\x233', '\x3', '\x233', 
		'\x3', '\x233', '\x3', '\x233', '\x3', '\x233', '\x3', '\x233', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x235', '\x3', '\x235', '\x3', '\x235', '\x5', '\x235', '\x1644', 
		'\n', '\x235', '\x3', '\x235', '\x5', '\x235', '\x1647', '\n', '\x235', 
		'\x3', '\x235', '\x3', '\x235', '\x3', '\x235', '\x3', '\x235', '\x3', 
		'\x235', '\x3', '\x235', '\x3', '\x235', '\x3', '\x235', '\x5', '\x235', 
		'\x1651', '\n', '\x235', '\x3', '\x235', '\x5', '\x235', '\x1654', '\n', 
		'\x235', '\x3', '\x235', '\x3', '\x235', '\x5', '\x235', '\x1658', '\n', 
		'\x235', '\x3', '\x235', '\x5', '\x235', '\x165B', '\n', '\x235', '\x3', 
		'\x236', '\x3', '\x236', '\x3', '\x236', '\x3', '\x236', '\x3', '\x236', 
		'\x5', '\x236', '\x1662', '\n', '\x236', '\x3', '\x236', '\x3', '\x236', 
		'\x5', '\x236', '\x1666', '\n', '\x236', '\x3', '\x236', '\a', '\x236', 
		'\x1669', '\n', '\x236', '\f', '\x236', '\xE', '\x236', '\x166C', '\v', 
		'\x236', '\x3', '\x236', '\x3', '\x236', '\x3', '\x236', '\x3', '\x237', 
		'\x3', '\x237', '\x3', '\x237', '\x3', '\x238', '\x3', '\x238', '\x3', 
		'\x238', '\x3', '\x239', '\x3', '\x239', '\x5', '\x239', '\x1679', '\n', 
		'\x239', '\x3', '\x23A', '\x3', '\x23A', '\x3', '\x23A', '\x3', '\x23A', 
		'\x3', '\x23A', '\a', '\x23A', '\x1680', '\n', '\x23A', '\f', '\x23A', 
		'\xE', '\x23A', '\x1683', '\v', '\x23A', '\x3', '\x23A', '\x3', '\x23A', 
		'\x3', '\x23B', '\x3', '\x23B', '\x3', '\x23B', '\x3', '\x23B', '\x3', 
		'\x23B', '\x5', '\x23B', '\x168C', '\n', '\x23B', '\x3', '\x23C', '\x3', 
		'\x23C', '\x5', '\x23C', '\x1690', '\n', '\x23C', '\x3', '\x23C', '\x3', 
		'\x23C', '\x3', '\x23C', '\x5', '\x23C', '\x1695', '\n', '\x23C', '\x3', 
		'\x23C', '\a', '\x23C', '\x1698', '\n', '\x23C', '\f', '\x23C', '\xE', 
		'\x23C', '\x169B', '\v', '\x23C', '\x3', '\x23D', '\x3', '\x23D', '\x3', 
		'\x23D', '\x3', '\x23E', '\x3', '\x23E', '\x3', '\x23E', '\x3', '\x23F', 
		'\x3', '\x23F', '\x5', '\x23F', '\x16A5', '\n', '\x23F', '\x3', '\x23F', 
		'\x5', '\x23F', '\x16A8', '\n', '\x23F', '\x3', '\x23F', '\x3', '\x23F', 
		'\x3', '\x23F', '\x5', '\x23F', '\x16AD', '\n', '\x23F', '\x3', '\x23F', 
		'\x3', '\x23F', '\x5', '\x23F', '\x16B1', '\n', '\x23F', '\x3', '\x23F', 
		'\a', '\x23F', '\x16B4', '\n', '\x23F', '\f', '\x23F', '\xE', '\x23F', 
		'\x16B7', '\v', '\x23F', '\x3', '\x240', '\x3', '\x240', '\x5', '\x240', 
		'\x16BB', '\n', '\x240', '\x3', '\x240', '\x5', '\x240', '\x16BE', '\n', 
		'\x240', '\x3', '\x240', '\x5', '\x240', '\x16C1', '\n', '\x240', '\x3', 
		'\x240', '\x3', '\x240', '\x3', '\x241', '\x3', '\x241', '\x3', '\x241', 
		'\x3', '\x242', '\x3', '\x242', '\x3', '\x242', '\x3', '\x242', '\x5', 
		'\x242', '\x16CC', '\n', '\x242', '\x5', '\x242', '\x16CE', '\n', '\x242', 
		'\x3', '\x242', '\x3', '\x242', '\x3', '\x243', '\x3', '\x243', '\x5', 
		'\x243', '\x16D4', '\n', '\x243', '\x3', '\x243', '\x5', '\x243', '\x16D7', 
		'\n', '\x243', '\x3', '\x243', '\x3', '\x243', '\x5', '\x243', '\x16DB', 
		'\n', '\x243', '\x3', '\x243', '\a', '\x243', '\x16DE', '\n', '\x243', 
		'\f', '\x243', '\xE', '\x243', '\x16E1', '\v', '\x243', '\x3', '\x244', 
		'\x3', '\x244', '\x3', '\x244', '\x3', '\x245', '\x3', '\x245', '\x3', 
		'\x245', '\x3', '\x245', '\x5', '\x245', '\x16EA', '\n', '\x245', '\x3', 
		'\x245', '\x3', '\x245', '\x3', '\x246', '\x3', '\x246', '\x5', '\x246', 
		'\x16F0', '\n', '\x246', '\x3', '\x246', '\x3', '\x246', '\x3', '\x246', 
		'\x3', '\x247', '\x3', '\x247', '\x3', '\x247', '\x3', '\x247', '\x3', 
		'\x248', '\x3', '\x248', '\x5', '\x248', '\x16FB', '\n', '\x248', '\x3', 
		'\x248', '\x3', '\x248', '\x5', '\x248', '\x16FF', '\n', '\x248', '\x5', 
		'\x248', '\x1701', '\n', '\x248', '\x3', '\x249', '\x3', '\x249', '\x3', 
		'\x249', '\x3', '\x249', '\x3', '\x249', '\x5', '\x249', '\x1708', '\n', 
		'\x249', '\x3', '\x249', '\x3', '\x249', '\x3', '\x249', '\x3', '\x249', 
		'\x3', '\x24A', '\x3', '\x24A', '\x3', '\x24A', '\x5', '\x24A', '\x1711', 
		'\n', '\x24A', '\x3', '\x24A', '\x3', '\x24A', '\x5', '\x24A', '\x1715', 
		'\n', '\x24A', '\x3', '\x24A', '\x3', '\x24A', '\x3', '\x24B', '\x5', 
		'\x24B', '\x171A', '\n', '\x24B', '\x3', '\x24B', '\x3', '\x24B', '\x3', 
		'\x24B', '\x3', '\x24B', '\a', '\x24B', '\x1720', '\n', '\x24B', '\f', 
		'\x24B', '\xE', '\x24B', '\x1723', '\v', '\x24B', '\x5', '\x24B', '\x1725', 
		'\n', '\x24B', '\x3', '\x24C', '\x3', '\x24C', '\x3', '\x24C', '\x5', 
		'\x24C', '\x172A', '\n', '\x24C', '\x3', '\x24C', '\x3', '\x24C', '\x3', 
		'\x24D', '\x3', '\x24D', '\x3', '\x24D', '\x3', '\x24D', '\x3', '\x24D', 
		'\x3', '\x24D', '\x5', '\x24D', '\x1734', '\n', '\x24D', '\x3', '\x24D', 
		'\x3', '\x24D', '\x5', '\x24D', '\x1738', '\n', '\x24D', '\x5', '\x24D', 
		'\x173A', '\n', '\x24D', '\x3', '\x24E', '\x3', '\x24E', '\x5', '\x24E', 
		'\x173E', '\n', '\x24E', '\x3', '\x24F', '\x3', '\x24F', '\x5', '\x24F', 
		'\x1742', '\n', '\x24F', '\x3', '\x24F', '\x3', '\x24F', '\x3', '\x250', 
		'\x3', '\x250', '\x3', '\x250', '\x3', '\x250', '\x3', '\x250', '\x3', 
		'\x250', '\x3', '\x251', '\x3', '\x251', '\x3', '\x251', '\x3', '\x252', 
		'\x3', '\x252', '\x5', '\x252', '\x1751', '\n', '\x252', '\x3', '\x253', 
		'\x3', '\x253', '\x3', '\x253', '\x3', '\x253', '\x3', '\x254', '\x3', 
		'\x254', '\x3', '\x254', '\x5', '\x254', '\x175A', '\n', '\x254', '\x3', 
		'\x255', '\x3', '\x255', '\x3', '\x255', '\x3', '\x255', '\a', '\x255', 
		'\x1760', '\n', '\x255', '\f', '\x255', '\xE', '\x255', '\x1763', '\v', 
		'\x255', '\x3', '\x255', '\x3', '\x255', '\x3', '\x256', '\x3', '\x256', 
		'\x3', '\x256', '\x5', '\x256', '\x176A', '\n', '\x256', '\x5', '\x256', 
		'\x176C', '\n', '\x256', '\x3', '\x257', '\x3', '\x257', '\x3', '\x258', 
		'\x3', '\x258', '\x5', '\x258', '\x1772', '\n', '\x258', '\x3', '\x259', 
		'\x3', '\x259', '\x3', '\x259', '\x3', '\x259', '\x3', '\x25A', '\x3', 
		'\x25A', '\x3', '\x25A', '\x3', '\x25A', '\x3', '\x25A', '\x5', '\x25A', 
		'\x177D', '\n', '\x25A', '\x3', '\x25A', '\x3', '\x25A', '\x3', '\x25B', 
		'\x3', '\x25B', '\x3', '\x25B', '\x3', '\x25B', '\x3', '\x25B', '\x3', 
		'\x25B', '\x3', '\x25C', '\x3', '\x25C', '\x3', '\x25C', '\x3', '\x25D', 
		'\x3', '\x25D', '\x3', '\x25D', '\x3', '\x25D', '\a', '\x25D', '\x178E', 
		'\n', '\x25D', '\f', '\x25D', '\xE', '\x25D', '\x1791', '\v', '\x25D', 
		'\x3', '\x25D', '\x3', '\x25D', '\x3', '\x25E', '\x3', '\x25E', '\x5', 
		'\x25E', '\x1797', '\n', '\x25E', '\x3', '\x25F', '\x3', '\x25F', '\x3', 
		'\x25F', '\x3', '\x260', '\x3', '\x260', '\x5', '\x260', '\x179E', '\n', 
		'\x260', '\x3', '\x261', '\x3', '\x261', '\x3', '\x261', '\x3', '\x261', 
		'\a', '\x261', '\x17A4', '\n', '\x261', '\f', '\x261', '\xE', '\x261', 
		'\x17A7', '\v', '\x261', '\x3', '\x261', '\x3', '\x261', '\x3', '\x262', 
		'\x3', '\x262', '\x5', '\x262', '\x17AD', '\n', '\x262', '\x3', '\x263', 
		'\x3', '\x263', '\x3', '\x263', '\x3', '\x263', '\x3', '\x263', '\x3', 
		'\x263', '\x5', '\x263', '\x17B5', '\n', '\x263', '\x3', '\x264', '\x3', 
		'\x264', '\x3', '\x264', '\x3', '\x264', '\x5', '\x264', '\x17BB', '\n', 
		'\x264', '\x3', '\x264', '\x3', '\x264', '\x3', '\x264', '\x3', '\x264', 
		'\x3', '\x265', '\x3', '\x265', '\x3', '\x265', '\x3', '\x265', '\x3', 
		'\x265', '\x5', '\x265', '\x17C6', '\n', '\x265', '\x3', '\x266', '\x3', 
		'\x266', '\x3', '\x267', '\x3', '\x267', '\x5', '\x267', '\x17CC', '\n', 
		'\x267', '\x3', '\x267', '\x3', '\x267', '\x5', '\x267', '\x17D0', '\n', 
		'\x267', '\x3', '\x268', '\x3', '\x268', '\x3', '\x268', '\x3', '\x269', 
		'\x3', '\x269', '\x3', '\x269', '\x3', '\x269', '\x3', '\x26A', '\x5', 
		'\x26A', '\x17DA', '\n', '\x26A', '\x3', '\x26A', '\x3', '\x26A', '\x3', 
		'\x26B', '\x3', '\x26B', '\x3', '\x26C', '\x3', '\x26C', '\x3', '\x26C', 
		'\x3', '\x26C', '\x3', '\x26D', '\x3', '\x26D', '\x3', '\x26D', '\x3', 
		'\x26D', '\x3', '\x26D', '\x3', '\x26D', '\x5', '\x26D', '\x17EA', '\n', 
		'\x26D', '\x3', '\x26E', '\x3', '\x26E', '\x3', '\x26F', '\x3', '\x26F', 
		'\x3', '\x26F', '\x3', '\x26F', '\x5', '\x26F', '\x17F2', '\n', '\x26F', 
		'\x3', '\x270', '\x3', '\x270', '\x3', '\x270', '\x5', '\x270', '\x17F7', 
		'\n', '\x270', '\x3', '\x270', '\x3', '\x270', '\x5', '\x270', '\x17FB', 
		'\n', '\x270', '\x3', '\x270', '\x5', '\x270', '\x17FE', '\n', '\x270', 
		'\x3', '\x270', '\x5', '\x270', '\x1801', '\n', '\x270', '\x3', '\x271', 
		'\x3', '\x271', '\x6', '\x271', '\x1805', '\n', '\x271', '\r', '\x271', 
		'\xE', '\x271', '\x1806', '\x3', '\x271', '\x3', '\x271', '\x3', '\x272', 
		'\x3', '\x272', '\x3', '\x272', '\x5', '\x272', '\x180E', '\n', '\x272', 
		'\x3', '\x272', '\x5', '\x272', '\x1811', '\n', '\x272', '\x3', '\x272', 
		'\x5', '\x272', '\x1814', '\n', '\x272', '\x3', '\x273', '\x5', '\x273', 
		'\x1817', '\n', '\x273', '\x3', '\x273', '\x6', '\x273', '\x181A', '\n', 
		'\x273', '\r', '\x273', '\xE', '\x273', '\x181B', '\x3', '\x273', '\x5', 
		'\x273', '\x181F', '\n', '\x273', '\x3', '\x273', '\x3', '\x273', '\x3', 
		'\x274', '\x3', '\x274', '\x3', '\x274', '\x3', '\x274', '\x3', '\x275', 
		'\x3', '\x275', '\x6', '\x275', '\x1829', '\n', '\x275', '\r', '\x275', 
		'\xE', '\x275', '\x182A', '\x3', '\x276', '\x3', '\x276', '\x6', '\x276', 
		'\x182F', '\n', '\x276', '\r', '\x276', '\xE', '\x276', '\x1830', '\x3', 
		'\x277', '\x3', '\x277', '\x3', '\x277', '\x3', '\x277', '\x3', '\x277', 
		'\a', '\x277', '\x1838', '\n', '\x277', '\f', '\x277', '\xE', '\x277', 
		'\x183B', '\v', '\x277', '\x5', '\x277', '\x183D', '\n', '\x277', '\x3', 
		'\x278', '\x3', '\x278', '\x3', '\x278', '\x3', '\x278', '\x3', '\x278', 
		'\x3', '\x278', '\x3', '\x278', '\x3', '\x279', '\x3', '\x279', '\x3', 
		'\x279', '\x3', '\x279', '\x3', '\x279', '\x5', '\x279', '\x184B', '\n', 
		'\x279', '\x3', '\x279', '\x3', '\x279', '\x3', '\x279', '\x3', '\x279', 
		'\x5', '\x279', '\x1851', '\n', '\x279', '\x3', '\x279', '\x3', '\x279', 
		'\x3', '\x279', '\x3', '\x279', '\x5', '\x279', '\x1857', '\n', '\x279', 
		'\x3', '\x27A', '\x3', '\x27A', '\x3', '\x27A', '\x3', '\x27A', '\x3', 
		'\x27B', '\x3', '\x27B', '\x3', '\x27B', '\x5', '\x27B', '\x1860', '\n', 
		'\x27B', '\x3', '\x27B', '\x3', '\x27B', '\x5', '\x27B', '\x1864', '\n', 
		'\x27B', '\x3', '\x27B', '\x5', '\x27B', '\x1867', '\n', '\x27B', '\x3', 
		'\x27B', '\x5', '\x27B', '\x186A', '\n', '\x27B', '\x3', '\x27C', '\x3', 
		'\x27C', '\x5', '\x27C', '\x186E', '\n', '\x27C', '\x3', '\x27C', '\x3', 
		'\x27C', '\x5', '\x27C', '\x1872', '\n', '\x27C', '\x3', '\x27C', '\x5', 
		'\x27C', '\x1875', '\n', '\x27C', '\x3', '\x27C', '\x5', '\x27C', '\x1878', 
		'\n', '\x27C', '\x3', '\x27C', '\x5', '\x27C', '\x187B', '\n', '\x27C', 
		'\x3', '\x27D', '\x3', '\x27D', '\x3', '\x27D', '\x3', '\x27E', '\x3', 
		'\x27E', '\x3', '\x27E', '\x3', '\x27E', '\x5', '\x27E', '\x1884', '\n', 
		'\x27E', '\x3', '\x27E', '\x5', '\x27E', '\x1887', '\n', '\x27E', '\x3', 
		'\x27F', '\x3', '\x27F', '\x3', '\x27F', '\x3', '\x280', '\x3', '\x280', 
		'\x3', '\x280', '\x3', '\x280', '\x3', '\x280', '\x3', '\x281', '\x3', 
		'\x281', '\x3', '\x281', '\x3', '\x282', '\x3', '\x282', '\x3', '\x282', 
		'\x5', '\x282', '\x1897', '\n', '\x282', '\x3', '\x283', '\x3', '\x283', 
		'\x3', '\x283', '\x3', '\x283', '\x5', '\x283', '\x189D', '\n', '\x283', 
		'\x5', '\x283', '\x189F', '\n', '\x283', '\x3', '\x284', '\x3', '\x284', 
		'\x3', '\x284', '\x3', '\x284', '\a', '\x284', '\x18A5', '\n', '\x284', 
		'\f', '\x284', '\xE', '\x284', '\x18A8', '\v', '\x284', '\x3', '\x285', 
		'\x3', '\x285', '\x3', '\x285', '\x3', '\x285', '\x5', '\x285', '\x18AE', 
		'\n', '\x285', '\x3', '\x285', '\x3', '\x285', '\x3', '\x286', '\x3', 
		'\x286', '\x5', '\x286', '\x18B4', '\n', '\x286', '\x3', '\x286', '\x3', 
		'\x286', '\x5', '\x286', '\x18B8', '\n', '\x286', '\x3', '\x286', '\x3', 
		'\x286', '\x5', '\x286', '\x18BC', '\n', '\x286', '\x3', '\x287', '\x3', 
		'\x287', '\x3', '\x287', '\x3', '\x288', '\x3', '\x288', '\x5', '\x288', 
		'\x18C3', '\n', '\x288', '\x3', '\x288', '\x5', '\x288', '\x18C6', '\n', 
		'\x288', '\x3', '\x289', '\x3', '\x289', '\x3', '\x289', '\x3', '\x289', 
		'\x5', '\x289', '\x18CC', '\n', '\x289', '\x3', '\x28A', '\x3', '\x28A', 
		'\x3', '\x28A', '\x3', '\x28A', '\x3', '\x28A', '\x5', '\x28A', '\x18D3', 
		'\n', '\x28A', '\x3', '\x28A', '\x5', '\x28A', '\x18D6', '\n', '\x28A', 
		'\x3', '\x28A', '\x5', '\x28A', '\x18D9', '\n', '\x28A', '\x3', '\x28B', 
		'\x3', '\x28B', '\x3', '\x28B', '\x3', '\x28C', '\x3', '\x28C', '\x5', 
		'\x28C', '\x18E0', '\n', '\x28C', '\x3', '\x28D', '\x3', '\x28D', '\x3', 
		'\x28D', '\x3', '\x28D', '\x3', '\x28D', '\x5', '\x28D', '\x18E7', '\n', 
		'\x28D', '\x3', '\x28E', '\x3', '\x28E', '\x3', '\x28E', '\x3', '\x28E', 
		'\x3', '\x28E', '\x3', '\x28F', '\x3', '\x28F', '\x5', '\x28F', '\x18F0', 
		'\n', '\x28F', '\x3', '\x28F', '\x5', '\x28F', '\x18F3', '\n', '\x28F', 
		'\x3', '\x290', '\x3', '\x290', '\x5', '\x290', '\x18F7', '\n', '\x290', 
		'\x3', '\x290', '\x3', '\x290', '\x3', '\x291', '\x3', '\x291', '\x3', 
		'\x291', '\x3', '\x292', '\x3', '\x292', '\x3', '\x292', '\x3', '\x292', 
		'\x3', '\x293', '\x3', '\x293', '\x3', '\x293', '\x5', '\x293', '\x1905', 
		'\n', '\x293', '\x3', '\x293', '\x5', '\x293', '\x1908', '\n', '\x293', 
		'\x3', '\x293', '\x5', '\x293', '\x190B', '\n', '\x293', '\x3', '\x294', 
		'\x3', '\x294', '\x3', '\x294', '\x3', '\x295', '\x3', '\x295', '\x3', 
		'\x295', '\x3', '\x295', '\x3', '\x296', '\x3', '\x296', '\x3', '\x296', 
		'\x3', '\x296', '\x5', '\x296', '\x1918', '\n', '\x296', '\x3', '\x297', 
		'\x3', '\x297', '\x3', '\x297', '\x3', '\x297', '\x3', '\x297', '\x3', 
		'\x297', '\x5', '\x297', '\x1920', '\n', '\x297', '\x3', '\x297', '\x5', 
		'\x297', '\x1923', '\n', '\x297', '\x3', '\x298', '\x3', '\x298', '\x5', 
		'\x298', '\x1927', '\n', '\x298', '\x3', '\x298', '\x3', '\x298', '\x5', 
		'\x298', '\x192B', '\n', '\x298', '\x5', '\x298', '\x192D', '\n', '\x298', 
		'\x3', '\x299', '\x3', '\x299', '\x3', '\x299', '\x3', '\x29A', '\x3', 
		'\x29A', '\x3', '\x29A', '\x3', '\x29A', '\x3', '\x29A', '\x3', '\x29B', 
		'\x3', '\x29B', '\x3', '\x29B', '\x3', '\x29B', '\x3', '\x29B', '\x3', 
		'\x29B', '\x5', '\x29B', '\x193D', '\n', '\x29B', '\x3', '\x29B', '\x5', 
		'\x29B', '\x1940', '\n', '\x29B', '\x3', '\x29C', '\x3', '\x29C', '\x3', 
		'\x29C', '\x3', '\x29D', '\x3', '\x29D', '\x3', '\x29D', '\x3', '\x29D', 
		'\x3', '\x29D', '\x3', '\x29D', '\x5', '\x29D', '\x194B', '\n', '\x29D', 
		'\x3', '\x29D', '\x3', '\x29D', '\x5', '\x29D', '\x194F', '\n', '\x29D', 
		'\x3', '\x29E', '\x3', '\x29E', '\x3', '\x29E', '\x3', '\x29E', '\x3', 
		'\x29E', '\x5', '\x29E', '\x1956', '\n', '\x29E', '\x3', '\x29E', '\x5', 
		'\x29E', '\x1959', '\n', '\x29E', '\x3', '\x29E', '\x5', '\x29E', '\x195C', 
		'\n', '\x29E', '\x3', '\x29F', '\x3', '\x29F', '\x3', '\x29F', '\x3', 
		'\x2A0', '\x3', '\x2A0', '\x3', '\x2A0', '\x3', '\x2A0', '\x3', '\x2A0', 
		'\x3', '\x2A0', '\x3', '\x2A1', '\x3', '\x2A1', '\x5', '\x2A1', '\x1969', 
		'\n', '\x2A1', '\x3', '\x2A2', '\x3', '\x2A2', '\x3', '\x2A2', '\x3', 
		'\x2A2', '\x5', '\x2A2', '\x196F', '\n', '\x2A2', '\x3', '\x2A2', '\x5', 
		'\x2A2', '\x1972', '\n', '\x2A2', '\x3', '\x2A3', '\x3', '\x2A3', '\x3', 
		'\x2A3', '\x3', '\x2A3', '\x3', '\x2A3', '\x3', '\x2A4', '\x3', '\x2A4', 
		'\x3', '\x2A5', '\x3', '\x2A5', '\x3', '\x2A5', '\x3', '\x2A5', '\x5', 
		'\x2A5', '\x197F', '\n', '\x2A5', '\x3', '\x2A6', '\x3', '\x2A6', '\x3', 
		'\x2A6', '\x3', '\x2A7', '\x3', '\x2A7', '\x3', '\x2A7', '\x3', '\x2A7', 
		'\x3', '\x2A7', '\x5', '\x2A7', '\x1989', '\n', '\x2A7', '\x3', '\x2A8', 
		'\x3', '\x2A8', '\x3', '\x2A8', '\a', '\x2A8', '\x198E', '\n', '\x2A8', 
		'\f', '\x2A8', '\xE', '\x2A8', '\x1991', '\v', '\x2A8', '\x3', '\x2A9', 
		'\x3', '\x2A9', '\x3', '\x2A9', '\x3', '\x2A9', '\x3', '\x2A9', '\x3', 
		'\x2A9', '\x3', '\x2A9', '\x5', '\x2A9', '\x199A', '\n', '\x2A9', '\x3', 
		'\x2A9', '\x5', '\x2A9', '\x199D', '\n', '\x2A9', '\x3', '\x2A9', '\x3', 
		'\x2A9', '\x3', '\x2AA', '\x3', '\x2AA', '\x3', '\x2AB', '\x3', '\x2AB', 
		'\x3', '\x2AB', '\x3', '\x2AB', '\x3', '\x2AB', '\x3', '\x2AB', '\x3', 
		'\x2AB', '\x3', '\x2AC', '\x3', '\x2AC', '\x3', '\x2AC', '\x3', '\x2AC', 
		'\x3', '\x2AC', '\x3', '\x2AC', '\x3', '\x2AC', '\x3', '\x2AC', '\x3', 
		'\x2AC', '\x3', '\x2AC', '\x3', '\x2AC', '\x3', '\x2AC', '\x5', '\x2AC', 
		'\x19B6', '\n', '\x2AC', '\x3', '\x2AD', '\x3', '\x2AD', '\x3', '\x2AD', 
		'\x3', '\x2AD', '\x3', '\x2AD', '\x3', '\x2AD', '\x5', '\x2AD', '\x19BE', 
		'\n', '\x2AD', '\x3', '\x2AE', '\x3', '\x2AE', '\x3', '\x2AE', '\x3', 
		'\x2AE', '\x5', '\x2AE', '\x19C4', '\n', '\x2AE', '\x3', '\x2AE', '\x3', 
		'\x2AE', '\x3', '\x2AE', '\x3', '\x2AE', '\x3', '\x2AE', '\x5', '\x2AE', 
		'\x19CB', '\n', '\x2AE', '\x3', '\x2AF', '\x3', '\x2AF', '\x3', '\x2AF', 
		'\x3', '\x2AF', '\x5', '\x2AF', '\x19D1', '\n', '\x2AF', '\x3', '\x2B0', 
		'\x3', '\x2B0', '\x3', '\x2B0', '\x3', '\x2B0', '\x5', '\x2B0', '\x19D7', 
		'\n', '\x2B0', '\x3', '\x2B1', '\x3', '\x2B1', '\x3', '\x2B1', '\x3', 
		'\x2B1', '\x5', '\x2B1', '\x19DD', '\n', '\x2B1', '\x3', '\x2B2', '\x3', 
		'\x2B2', '\x3', '\x2B2', '\x3', '\x2B2', '\x3', '\x2B3', '\x3', '\x2B3', 
		'\x3', '\x2B3', '\x3', '\x2B3', '\x3', '\x2B4', '\x3', '\x2B4', '\x3', 
		'\x2B4', '\x3', '\x2B5', '\x3', '\x2B5', '\x3', '\x2B5', '\x3', '\x2B5', 
		'\a', '\x2B5', '\x19EE', '\n', '\x2B5', '\f', '\x2B5', '\xE', '\x2B5', 
		'\x19F1', '\v', '\x2B5', '\x3', '\x2B5', '\x5', '\x2B5', '\x19F4', '\n', 
		'\x2B5', '\x3', '\x2B5', '\x3', '\x2B5', '\x3', '\x2B5', '\x3', '\x2B6', 
		'\x3', '\x2B6', '\x3', '\x2B6', '\x3', '\x2B7', '\x3', '\x2B7', '\x3', 
		'\x2B7', '\x3', '\x2B8', '\x3', '\x2B8', '\x3', '\x2B8', '\x3', '\x2B8', 
		'\x3', '\x2B9', '\x3', '\x2B9', '\x3', '\x2B9', '\x3', '\x2B9', '\a', 
		'\x2B9', '\x1A07', '\n', '\x2B9', '\f', '\x2B9', '\xE', '\x2B9', '\x1A0A', 
		'\v', '\x2B9', '\x3', '\x2B9', '\x5', '\x2B9', '\x1A0D', '\n', '\x2B9', 
		'\x3', '\x2B9', '\x3', '\x2B9', '\x3', '\x2BA', '\x3', '\x2BA', '\x3', 
		'\x2BA', '\a', '\x2BA', '\x1A14', '\n', '\x2BA', '\f', '\x2BA', '\xE', 
		'\x2BA', '\x1A17', '\v', '\x2BA', '\x3', '\x2BB', '\x3', '\x2BB', '\x3', 
		'\x2BB', '\a', '\x2BB', '\x1A1C', '\n', '\x2BB', '\f', '\x2BB', '\xE', 
		'\x2BB', '\x1A1F', '\v', '\x2BB', '\x3', '\x2BC', '\x3', '\x2BC', '\x3', 
		'\x2BC', '\x3', '\x2BC', '\x3', '\x2BD', '\x3', '\x2BD', '\x3', '\x2BD', 
		'\x3', '\x2BD', '\x3', '\x2BE', '\x3', '\x2BE', '\x3', '\x2BF', '\x3', 
		'\x2BF', '\x3', '\x2BF', '\x3', '\x2BF', '\x3', '\x2C0', '\x3', '\x2C0', 
		'\x3', '\x2C0', '\x3', '\x2C0', '\x3', '\x2C1', '\x3', '\x2C1', '\x3', 
		'\x2C1', '\x3', '\x2C1', '\x5', '\x2C1', '\x1A37', '\n', '\x2C1', '\x3', 
		'\x2C2', '\x3', '\x2C2', '\x3', '\x2C2', '\x3', '\x2C2', '\x3', '\x2C2', 
		'\x3', '\x2C3', '\x3', '\x2C3', '\x5', '\x2C3', '\x1A40', '\n', '\x2C3', 
		'\x3', '\x2C3', '\x3', '\x2C3', '\x3', '\x2C3', '\x5', '\x2C3', '\x1A45', 
		'\n', '\x2C3', '\x3', '\x2C4', '\x3', '\x2C4', '\x5', '\x2C4', '\x1A49', 
		'\n', '\x2C4', '\x3', '\x2C5', '\x3', '\x2C5', '\x3', '\x2C5', '\x5', 
		'\x2C5', '\x1A4E', '\n', '\x2C5', '\x3', '\x2C5', '\x3', '\x2C5', '\x3', 
		'\x2C5', '\x3', '\x2C5', '\x5', '\x2C5', '\x1A54', '\n', '\x2C5', '\x3', 
		'\x2C6', '\x3', '\x2C6', '\x6', '\x2C6', '\x1A58', '\n', '\x2C6', '\r', 
		'\x2C6', '\xE', '\x2C6', '\x1A59', '\x3', '\x2C6', '\x5', '\x2C6', '\x1A5D', 
		'\n', '\x2C6', '\x3', '\x2C7', '\x6', '\x2C7', '\x1A60', '\n', '\x2C7', 
		'\r', '\x2C7', '\xE', '\x2C7', '\x1A61', '\x3', '\x2C7', '\x5', '\x2C7', 
		'\x1A65', '\n', '\x2C7', '\x3', '\x2C8', '\x3', '\x2C8', '\x3', '\x2C8', 
		'\x3', '\x2C8', '\x3', '\x2C9', '\x5', '\x2C9', '\x1A6C', '\n', '\x2C9', 
		'\x3', '\x2C9', '\x3', '\x2C9', '\x3', '\x2CA', '\x3', '\x2CA', '\x3', 
		'\x2CA', '\x5', '\x2CA', '\x1A73', '\n', '\x2CA', '\x3', '\x2CA', '\x3', 
		'\x2CA', '\x3', '\x2CB', '\x3', '\x2CB', '\x3', '\x2CB', '\x5', '\x2CB', 
		'\x1A7A', '\n', '\x2CB', '\x3', '\x2CC', '\x3', '\x2CC', '\x6', '\x2CC', 
		'\x1A7E', '\n', '\x2CC', '\r', '\x2CC', '\xE', '\x2CC', '\x1A7F', '\x3', 
		'\x2CD', '\x3', '\x2CD', '\x3', '\x2CD', '\x3', '\x2CD', '\x3', '\x2CE', 
		'\x3', '\x2CE', '\x3', '\x2CE', '\a', '\x2CE', '\x1A89', '\n', '\x2CE', 
		'\f', '\x2CE', '\xE', '\x2CE', '\x1A8C', '\v', '\x2CE', '\x3', '\x2CF', 
		'\x3', '\x2CF', '\x3', '\x2CF', '\x3', '\x2D0', '\x3', '\x2D0', '\x3', 
		'\x2D1', '\x3', '\x2D1', '\x3', '\x2D1', '\x3', '\x2D1', '\x3', '\x2D1', 
		'\x3', '\x2D1', '\x3', '\x2D2', '\x3', '\x2D2', '\x3', '\x2D3', '\x3', 
		'\x2D3', '\x5', '\x2D3', '\x1A9D', '\n', '\x2D3', '\x3', '\x2D4', '\x3', 
		'\x2D4', '\x3', '\x2D5', '\x3', '\x2D5', '\x5', '\x2D5', '\x1AA3', '\n', 
		'\x2D5', '\x3', '\x2D6', '\x3', '\x2D6', '\x3', '\x2D6', '\x5', '\x2D6', 
		'\x1AA8', '\n', '\x2D6', '\x5', '\x2D6', '\x1AAA', '\n', '\x2D6', '\x3', 
		'\x2D7', '\x3', '\x2D7', '\x3', '\x2D7', '\x3', '\x2D8', '\x6', '\x2D8', 
		'\x1AB0', '\n', '\x2D8', '\r', '\x2D8', '\xE', '\x2D8', '\x1AB1', '\x3', 
		'\x2D8', '\x3', '\x2D8', '\a', '\x2D8', '\x1AB6', '\n', '\x2D8', '\f', 
		'\x2D8', '\xE', '\x2D8', '\x1AB9', '\v', '\x2D8', '\x5', '\x2D8', '\x1ABB', 
		'\n', '\x2D8', '\x3', '\x2D9', '\x3', '\x2D9', '\x3', '\x2D9', '\x3', 
		'\x2D9', '\x3', '\x2D9', '\x3', '\x2D9', '\x3', '\x2D9', '\x3', '\x2D9', 
		'\x3', '\x2D9', '\x5', '\x2D9', '\x1AC6', '\n', '\x2D9', '\x3', '\x2D9', 
		'\x3', '\x2D9', '\x5', '\x2D9', '\x1ACA', '\n', '\x2D9', '\x3', '\x2DA', 
		'\x3', '\x2DA', '\x3', '\x2DA', '\x3', '\x2DB', '\x3', '\x2DB', '\x3', 
		'\x2DC', '\x3', '\x2DC', '\x3', '\x2DC', '\x3', '\x2DD', '\x3', '\x2DD', 
		'\x3', '\x2DD', '\x3', '\x2DE', '\x3', '\x2DE', '\x3', '\x2DE', '\x3', 
		'\x2DF', '\x3', '\x2DF', '\x3', '\x2DF', '\x3', '\x2DF', '\x5', '\x2DF', 
		'\x1ADE', '\n', '\x2DF', '\x3', '\x2DF', '\x5', '\x2DF', '\x1AE1', '\n', 
		'\x2DF', '\x3', '\x2DF', '\x3', '\x2DF', '\x3', '\x2DF', '\x3', '\x2DF', 
		'\x3', '\x2DF', '\x3', '\x2DF', '\x5', '\x2DF', '\x1AE9', '\n', '\x2DF', 
		'\x3', '\x2E0', '\x3', '\x2E0', '\x3', '\x2E1', '\x3', '\x2E1', '\x3', 
		'\x2E2', '\x3', '\x2E2', '\x3', '\x2E2', '\x3', '\x2E2', '\x3', '\x2E2', 
		'\a', '\x2E2', '\x1AF4', '\n', '\x2E2', '\f', '\x2E2', '\xE', '\x2E2', 
		'\x1AF7', '\v', '\x2E2', '\x3', '\x2E2', '\x3', '\x2E2', '\x3', '\x2E3', 
		'\x3', '\x2E3', '\x3', '\x2E3', '\x5', '\x2E3', '\x1AFE', '\n', '\x2E3', 
		'\x3', '\x2E3', '\x3', '\x2E3', '\x3', '\x2E3', '\x5', '\x2E3', '\x1B03', 
		'\n', '\x2E3', '\x5', '\x2E3', '\x1B05', '\n', '\x2E3', '\x3', '\x2E4', 
		'\x3', '\x2E4', '\x3', '\x2E4', '\x3', '\x2E4', '\x3', '\x2E4', '\a', 
		'\x2E4', '\x1B0C', '\n', '\x2E4', '\f', '\x2E4', '\xE', '\x2E4', '\x1B0F', 
		'\v', '\x2E4', '\x3', '\x2E4', '\x3', '\x2E4', '\x3', '\x2E5', '\x3', 
		'\x2E5', '\x3', '\x2E5', '\x5', '\x2E5', '\x1B16', '\n', '\x2E5', '\x3', 
		'\x2E5', '\x3', '\x2E5', '\x3', '\x2E5', '\x5', '\x2E5', '\x1B1B', '\n', 
		'\x2E5', '\x5', '\x2E5', '\x1B1D', '\n', '\x2E5', '\x3', '\x2E6', '\x3', 
		'\x2E6', '\x3', '\x2E6', '\x5', '\x2E6', '\x1B22', '\n', '\x2E6', '\x3', 
		'\x2E6', '\x3', '\x2E6', '\x3', '\x2E6', '\x3', '\x2E7', '\x3', '\x2E7', 
		'\x3', '\x2E7', '\x3', '\x2E7', '\x3', '\x2E8', '\x3', '\x2E8', '\x3', 
		'\x2E8', '\x3', '\x2E8', '\x5', '\x2E8', '\x1B2F', '\n', '\x2E8', '\x3', 
		'\x2E9', '\x3', '\x2E9', '\x3', '\x2E9', '\x5', '\x2E9', '\x1B34', '\n', 
		'\x2E9', '\x3', '\x2EA', '\x3', '\x2EA', '\x3', '\x2EA', '\x3', '\x2EA', 
		'\x3', '\x2EA', '\x5', '\x2EA', '\x1B3B', '\n', '\x2EA', '\x3', '\x2EB', 
		'\x3', '\x2EB', '\x3', '\x2EB', '\x5', '\x2EB', '\x1B40', '\n', '\x2EB', 
		'\x3', '\x2EC', '\x3', '\x2EC', '\x3', '\x2EC', '\x3', '\x2EC', '\x3', 
		'\x2EC', '\x3', '\x2EC', '\x5', '\x2EC', '\x1B48', '\n', '\x2EC', '\x3', 
		'\x2ED', '\x3', '\x2ED', '\x5', '\x2ED', '\x1B4C', '\n', '\x2ED', '\x3', 
		'\x2ED', '\x5', '\x2ED', '\x1B4F', '\n', '\x2ED', '\x3', '\x2ED', '\x5', 
		'\x2ED', '\x1B52', '\n', '\x2ED', '\x3', '\x2EE', '\x3', '\x2EE', '\x3', 
		'\x2EE', '\x3', '\x2EF', '\x3', '\x2EF', '\x3', '\x2EF', '\x3', '\x2F0', 
		'\x3', '\x2F0', '\x3', '\x2F0', '\x3', '\x2F0', '\x3', '\x2F0', '\x3', 
		'\x2F0', '\x3', '\x2F0', '\x3', '\x2F0', '\x3', '\x2F0', '\x3', '\x2F0', 
		'\x5', '\x2F0', '\x1B64', '\n', '\x2F0', '\x3', '\x2F1', '\x3', '\x2F1', 
		'\x3', '\x2F1', '\x3', '\x2F1', '\x3', '\x2F1', '\x3', '\x2F1', '\x3', 
		'\x2F1', '\x3', '\x2F2', '\x3', '\x2F2', '\x3', '\x2F3', '\x3', '\x2F3', 
		'\x3', '\x2F4', '\x3', '\x2F4', '\x3', '\x2F4', '\x5', '\x2F4', '\x1B74', 
		'\n', '\x2F4', '\x3', '\x2F4', '\x3', '\x2F4', '\x3', '\x2F5', '\x3', 
		'\x2F5', '\x3', '\x2F5', '\x5', '\x2F5', '\x1B7B', '\n', '\x2F5', '\x3', 
		'\x2F5', '\x3', '\x2F5', '\x3', '\x2F6', '\x3', '\x2F6', '\x3', '\x2F6', 
		'\x5', '\x2F6', '\x1B82', '\n', '\x2F6', '\x3', '\x2F6', '\x3', '\x2F6', 
		'\x3', '\x2F7', '\x3', '\x2F7', '\x3', '\x2F7', '\x5', '\x2F7', '\x1B89', 
		'\n', '\x2F7', '\x3', '\x2F7', '\x3', '\x2F7', '\x3', '\x2F8', '\x3', 
		'\x2F8', '\x3', '\x2F8', '\x5', '\x2F8', '\x1B90', '\n', '\x2F8', '\x3', 
		'\x2F8', '\x3', '\x2F8', '\x3', '\x2F9', '\x3', '\x2F9', '\x3', '\x2F9', 
		'\x5', '\x2F9', '\x1B97', '\n', '\x2F9', '\x3', '\x2F9', '\x3', '\x2F9', 
		'\x3', '\x2FA', '\x3', '\x2FA', '\x5', '\x2FA', '\x1B9D', '\n', '\x2FA', 
		'\x3', '\x2FA', '\x3', '\x2FA', '\x5', '\x2FA', '\x1BA1', '\n', '\x2FA', 
		'\x3', '\x2FA', '\x3', '\x2FA', '\x3', '\x2FA', '\x5', '\x2FA', '\x1BA6', 
		'\n', '\x2FA', '\x5', '\x2FA', '\x1BA8', '\n', '\x2FA', '\x3', '\x2FB', 
		'\x3', '\x2FB', '\x3', '\x2FC', '\x3', '\x2FC', '\x3', '\x2FC', '\x3', 
		'\x2FC', '\x3', '\x2FC', '\x5', '\x2FC', '\x1BB1', '\n', '\x2FC', '\x3', 
		'\x2FD', '\x3', '\x2FD', '\x3', '\x2FD', '\x5', '\x2FD', '\x1BB6', '\n', 
		'\x2FD', '\x3', '\x2FE', '\x3', '\x2FE', '\x3', '\x2FF', '\x3', '\x2FF', 
		'\x3', '\x2FF', '\x3', '\x2FF', '\x3', '\x300', '\x3', '\x300', '\x3', 
		'\x300', '\x3', '\x301', '\x3', '\x301', '\x3', '\x301', '\x5', '\x301', 
		'\x1BC4', '\n', '\x301', '\x3', '\x302', '\x3', '\x302', '\x3', '\x302', 
		'\x3', '\x302', '\x3', '\x302', '\x5', '\x302', '\x1BCB', '\n', '\x302', 
		'\x3', '\x303', '\x3', '\x303', '\x3', '\x303', '\x3', '\x303', '\x3', 
		'\x303', '\x3', '\x303', '\x5', '\x303', '\x1BD3', '\n', '\x303', '\x5', 
		'\x303', '\x1BD5', '\n', '\x303', '\x3', '\x304', '\x3', '\x304', '\x3', 
		'\x304', '\x3', '\x304', '\a', '\x304', '\x1BDB', '\n', '\x304', '\f', 
		'\x304', '\xE', '\x304', '\x1BDE', '\v', '\x304', '\x5', '\x304', '\x1BE0', 
		'\n', '\x304', '\x3', '\x305', '\x3', '\x305', '\x3', '\x305', '\x3', 
		'\x305', '\x3', '\x305', '\x3', '\x305', '\x5', '\x305', '\x1BE8', '\n', 
		'\x305', '\x3', '\x306', '\x3', '\x306', '\x3', '\x306', '\x3', '\x306', 
		'\x3', '\x307', '\x3', '\x307', '\x5', '\x307', '\x1BF0', '\n', '\x307', 
		'\x3', '\x307', '\x5', '\x307', '\x1BF3', '\n', '\x307', '\x3', '\x307', 
		'\x3', '\x307', '\x5', '\x307', '\x1BF7', '\n', '\x307', '\x3', '\x308', 
		'\x3', '\x308', '\x3', '\x308', '\x3', '\x308', '\x3', '\x308', '\x3', 
		'\x308', '\x3', '\x308', '\x3', '\x308', '\x3', '\x308', '\x3', '\x308', 
		'\x3', '\x308', '\x3', '\x308', '\x3', '\x308', '\x3', '\x308', '\x3', 
		'\x308', '\x3', '\x308', '\x5', '\x308', '\x1C09', '\n', '\x308', '\x3', 
		'\x309', '\x3', '\x309', '\x3', '\x309', '\x3', '\x309', '\x3', '\x309', 
		'\x3', '\x309', '\a', '\x309', '\x1C11', '\n', '\x309', '\f', '\x309', 
		'\xE', '\x309', '\x1C14', '\v', '\x309', '\x3', '\x30A', '\x3', '\x30A', 
		'\x3', '\x30A', '\x5', '\x30A', '\x1C19', '\n', '\x30A', '\x3', '\x30B', 
		'\x3', '\x30B', '\x3', '\x30B', '\x3', '\x30C', '\x3', '\x30C', '\x3', 
		'\x30C', '\x5', '\x30C', '\x1C21', '\n', '\x30C', '\x3', '\x30D', '\x3', 
		'\x30D', '\x6', '\x30D', '\x1C25', '\n', '\x30D', '\r', '\x30D', '\xE', 
		'\x30D', '\x1C26', '\x3', '\x30D', '\x3', '\x30D', '\x3', '\x30E', '\x3', 
		'\x30E', '\x3', '\x30E', '\x3', '\x30E', '\x3', '\x30E', '\x3', '\x30E', 
		'\x5', '\x30E', '\x1C31', '\n', '\x30E', '\x3', '\x30F', '\x3', '\x30F', 
		'\x3', '\x30F', '\x5', '\x30F', '\x1C36', '\n', '\x30F', '\x3', '\x30F', 
		'\x5', '\x30F', '\x1C39', '\n', '\x30F', '\x3', '\x310', '\x3', '\x310', 
		'\x3', '\x310', '\x3', '\x310', '\x3', '\x310', '\x3', '\x310', '\x3', 
		'\x310', '\x3', '\x310', '\x3', '\x310', '\x5', '\x310', '\x1C44', '\n', 
		'\x310', '\x3', '\x311', '\x3', '\x311', '\x3', '\x311', '\x3', '\x311', 
		'\x3', '\x311', '\x3', '\x311', '\x3', '\x311', '\x5', '\x311', '\x1C4D', 
		'\n', '\x311', '\x3', '\x311', '\a', '\x311', '\x1C50', '\n', '\x311', 
		'\f', '\x311', '\xE', '\x311', '\x1C53', '\v', '\x311', '\x3', '\x312', 
		'\x3', '\x312', '\x3', '\x312', '\x3', '\x312', '\x3', '\x312', '\x3', 
		'\x312', '\x3', '\x312', '\x3', '\x312', '\x3', '\x312', '\x5', '\x312', 
		'\x1C5E', '\n', '\x312', '\x3', '\x313', '\x3', '\x313', '\x5', '\x313', 
		'\x1C62', '\n', '\x313', '\x3', '\x313', '\x5', '\x313', '\x1C65', '\n', 
		'\x313', '\x3', '\x314', '\x3', '\x314', '\x3', '\x314', '\x3', '\x315', 
		'\x3', '\x315', '\x3', '\x315', '\x3', '\x315', '\x3', '\x315', '\x3', 
		'\x315', '\x3', '\x315', '\x3', '\x315', '\x5', '\x315', '\x1C72', '\n', 
		'\x315', '\x3', '\x316', '\x3', '\x316', '\x3', '\x316', '\x3', '\x316', 
		'\x3', '\x316', '\x3', '\x316', '\x5', '\x316', '\x1C7A', '\n', '\x316', 
		'\x3', '\x316', '\x6', '\x316', '\x1C7D', '\n', '\x316', '\r', '\x316', 
		'\xE', '\x316', '\x1C7E', '\x3', '\x317', '\x3', '\x317', '\x3', '\x317', 
		'\x5', '\x317', '\x1C84', '\n', '\x317', '\x3', '\x318', '\x3', '\x318', 
		'\x3', '\x318', '\x5', '\x318', '\x1C89', '\n', '\x318', '\x3', '\x318', 
		'\x5', '\x318', '\x1C8C', '\n', '\x318', '\x3', '\x318', '\x5', '\x318', 
		'\x1C8F', '\n', '\x318', '\x3', '\x319', '\x3', '\x319', '\x3', '\x319', 
		'\x5', '\x319', '\x1C94', '\n', '\x319', '\x3', '\x31A', '\x3', '\x31A', 
		'\x3', '\x31A', '\x3', '\x31A', '\x3', '\x31A', '\x3', '\x31A', '\x3', 
		'\x31A', '\x3', '\x31A', '\x3', '\x31A', '\x3', '\x31A', '\x5', '\x31A', 
		'\x1CA0', '\n', '\x31A', '\x3', '\x31B', '\x3', '\x31B', '\x3', '\x31B', 
		'\x3', '\x31B', '\x3', '\x31B', '\a', '\x31B', '\x1CA7', '\n', '\x31B', 
		'\f', '\x31B', '\xE', '\x31B', '\x1CAA', '\v', '\x31B', '\x3', '\x31C', 
		'\x3', '\x31C', '\x3', '\x31C', '\x3', '\x31C', '\x3', '\x31C', '\x3', 
		'\x31C', '\x3', '\x31D', '\x3', '\x31D', '\x3', '\x31D', '\x3', '\x31D', 
		'\x3', '\x31E', '\x3', '\x31E', '\x3', '\x31E', '\x3', '\x31E', '\x3', 
		'\x31E', '\x5', '\x31E', '\x1CBB', '\n', '\x31E', '\x3', '\x31E', '\x5', 
		'\x31E', '\x1CBE', '\n', '\x31E', '\x3', '\x31F', '\x3', '\x31F', '\x3', 
		'\x31F', '\x3', '\x320', '\x3', '\x320', '\x3', '\x320', '\x3', '\x320', 
		'\x3', '\x320', '\x3', '\x320', '\x3', '\x320', '\x3', '\x321', '\x3', 
		'\x321', '\x3', '\x321', '\x3', '\x321', '\a', '\x321', '\x1CCE', '\n', 
		'\x321', '\f', '\x321', '\xE', '\x321', '\x1CD1', '\v', '\x321', '\x5', 
		'\x321', '\x1CD3', '\n', '\x321', '\x3', '\x322', '\x3', '\x322', '\x3', 
		'\x322', '\x3', '\x322', '\x3', '\x322', '\x3', '\x322', '\x5', '\x322', 
		'\x1CDB', '\n', '\x322', '\x3', '\x323', '\x3', '\x323', '\x5', '\x323', 
		'\x1CDF', '\n', '\x323', '\x3', '\x323', '\x5', '\x323', '\x1CE2', '\n', 
		'\x323', '\x3', '\x323', '\x5', '\x323', '\x1CE5', '\n', '\x323', '\x3', 
		'\x323', '\x3', '\x323', '\x5', '\x323', '\x1CE9', '\n', '\x323', '\x3', 
		'\x324', '\x3', '\x324', '\x3', '\x324', '\x3', '\x324', '\x3', '\x325', 
		'\x3', '\x325', '\x3', '\x325', '\x3', '\x326', '\x3', '\x326', '\x3', 
		'\x326', '\a', '\x326', '\x1CF5', '\n', '\x326', '\f', '\x326', '\xE', 
		'\x326', '\x1CF8', '\v', '\x326', '\x3', '\x327', '\x3', '\x327', '\x3', 
		'\x327', '\x5', '\x327', '\x1CFD', '\n', '\x327', '\x3', '\x328', '\x3', 
		'\x328', '\x5', '\x328', '\x1D01', '\n', '\x328', '\x3', '\x329', '\x3', 
		'\x329', '\x3', '\x329', '\x3', '\x329', '\x5', '\x329', '\x1D07', '\n', 
		'\x329', '\x3', '\x32A', '\x3', '\x32A', '\x5', '\x32A', '\x1D0B', '\n', 
		'\x32A', '\x3', '\x32B', '\x3', '\x32B', '\x3', '\x32B', '\x3', '\x32B', 
		'\a', '\x32B', '\x1D11', '\n', '\x32B', '\f', '\x32B', '\xE', '\x32B', 
		'\x1D14', '\v', '\x32B', '\x3', '\x32B', '\x3', '\x32B', '\x3', '\x32C', 
		'\x3', '\x32C', '\x3', '\x32C', '\x3', '\x32C', '\x3', '\x32C', '\x3', 
		'\x32D', '\x3', '\x32D', '\x3', '\x32D', '\x3', '\x32D', '\x3', '\x32D', 
		'\x3', '\x32D', '\x5', '\x32D', '\x1D23', '\n', '\x32D', '\x3', '\x32E', 
		'\x3', '\x32E', '\x5', '\x32E', '\x1D27', '\n', '\x32E', '\x3', '\x32F', 
		'\x3', '\x32F', '\x3', '\x330', '\x3', '\x330', '\x5', '\x330', '\x1D2D', 
		'\n', '\x330', '\x3', '\x330', '\x5', '\x330', '\x1D30', '\n', '\x330', 
		'\x3', '\x331', '\x3', '\x331', '\x5', '\x331', '\x1D34', '\n', '\x331', 
		'\x3', '\x332', '\x5', '\x332', '\x1D37', '\n', '\x332', '\x3', '\x332', 
		'\x3', '\x332', '\x3', '\x332', '\x3', '\x332', '\x3', '\x333', '\x3', 
		'\x333', '\x3', '\x333', '\x3', '\x333', '\x3', '\x334', '\x5', '\x334', 
		'\x1D42', '\n', '\x334', '\x3', '\x334', '\x3', '\x334', '\x3', '\x335', 
		'\x3', '\x335', '\x3', '\x335', '\x6', '\x335', '\x1D49', '\n', '\x335', 
		'\r', '\x335', '\xE', '\x335', '\x1D4A', '\x3', '\x336', '\x3', '\x336', 
		'\x3', '\x336', '\x3', '\x336', '\x3', '\x336', '\x3', '\x336', '\x3', 
		'\x336', '\x3', '\x336', '\x3', '\x336', '\x3', '\x336', '\x3', '\x336', 
		'\x5', '\x336', '\x1D58', '\n', '\x336', '\x3', '\x337', '\x3', '\x337', 
		'\x3', '\x337', '\x3', '\x337', '\x3', '\x337', '\x3', '\x337', '\x3', 
		'\x337', '\x3', '\x337', '\x3', '\x337', '\x5', '\x337', '\x1D63', '\n', 
		'\x337', '\x3', '\x338', '\x3', '\x338', '\x3', '\x338', '\x5', '\x338', 
		'\x1D68', '\n', '\x338', '\x3', '\x338', '\x3', '\x338', '\x3', '\x339', 
		'\x3', '\x339', '\x3', '\x339', '\x5', '\x339', '\x1D6F', '\n', '\x339', 
		'\x3', '\x339', '\x3', '\x339', '\x3', '\x339', '\x5', '\x339', '\x1D74', 
		'\n', '\x339', '\x3', '\x33A', '\x3', '\x33A', '\x5', '\x33A', '\x1D78', 
		'\n', '\x33A', '\x3', '\x33A', '\x3', '\x33A', '\x5', '\x33A', '\x1D7C', 
		'\n', '\x33A', '\x3', '\x33B', '\x3', '\x33B', '\x5', '\x33B', '\x1D80', 
		'\n', '\x33B', '\x3', '\x33B', '\x3', '\x33B', '\x5', '\x33B', '\x1D84', 
		'\n', '\x33B', '\x3', '\x33C', '\x3', '\x33C', '\x3', '\x33D', '\x3', 
		'\x33D', '\x5', '\x33D', '\x1D8A', '\n', '\x33D', '\x3', '\x33D', '\x3', 
		'\x33D', '\x5', '\x33D', '\x1D8E', '\n', '\x33D', '\x3', '\x33E', '\x3', 
		'\x33E', '\x3', '\x33F', '\x3', '\x33F', '\x5', '\x33F', '\x1D94', '\n', 
		'\x33F', '\x3', '\x33F', '\x5', '\x33F', '\x1D97', '\n', '\x33F', '\x3', 
		'\x340', '\x3', '\x340', '\x3', '\x341', '\x3', '\x341', '\x5', '\x341', 
		'\x1D9D', '\n', '\x341', '\x3', '\x341', '\x5', '\x341', '\x1DA0', '\n', 
		'\x341', '\x3', '\x342', '\x3', '\x342', '\x3', '\x343', '\x3', '\x343', 
		'\x3', '\x343', '\x5', '\x343', '\x1DA7', '\n', '\x343', '\x3', '\x343', 
		'\x5', '\x343', '\x1DAA', '\n', '\x343', '\x3', '\x343', '\a', '\x343', 
		'\x1DAD', '\n', '\x343', '\f', '\x343', '\xE', '\x343', '\x1DB0', '\v', 
		'\x343', '\x3', '\x344', '\x3', '\x344', '\x3', '\x344', '\x3', '\x345', 
		'\x3', '\x345', '\x3', '\x345', '\x5', '\x345', '\x1DB8', '\n', '\x345', 
		'\x3', '\x346', '\x5', '\x346', '\x1DBB', '\n', '\x346', '\x3', '\x346', 
		'\x3', '\x346', '\x5', '\x346', '\x1DBF', '\n', '\x346', '\x3', '\x346', 
		'\x5', '\x346', '\x1DC2', '\n', '\x346', '\x3', '\x346', '\a', '\x346', 
		'\x1DC5', '\n', '\x346', '\f', '\x346', '\xE', '\x346', '\x1DC8', '\v', 
		'\x346', '\x3', '\x347', '\x3', '\x347', '\x3', '\x347', '\x3', '\x348', 
		'\x3', '\x348', '\x3', '\x349', '\x3', '\x349', '\x3', '\x349', '\x3', 
		'\x349', '\a', '\x349', '\x1DD3', '\n', '\x349', '\f', '\x349', '\xE', 
		'\x349', '\x1DD6', '\v', '\x349', '\x3', '\x349', '\x3', '\x349', '\x3', 
		'\x34A', '\x3', '\x34A', '\x5', '\x34A', '\x1DDC', '\n', '\x34A', '\x3', 
		'\x34B', '\x3', '\x34B', '\x3', '\x34B', '\x3', '\x34C', '\x3', '\x34C', 
		'\x3', '\x34C', '\x3', '\x34D', '\x3', '\x34D', '\x3', '\x34D', '\x3', 
		'\x34E', '\x3', '\x34E', '\x3', '\x34E', '\x3', '\x34F', '\x3', '\x34F', 
		'\x3', '\x34F', '\x3', '\x34F', '\x3', '\x34F', '\x3', '\x34F', '\x3', 
		'\x34F', '\x3', '\x350', '\x3', '\x350', '\x3', '\x350', '\x3', '\x350', 
		'\x3', '\x350', '\a', '\x350', '\x1DF6', '\n', '\x350', '\f', '\x350', 
		'\xE', '\x350', '\x1DF9', '\v', '\x350', '\x3', '\x351', '\x5', '\x351', 
		'\x1DFC', '\n', '\x351', '\x3', '\x351', '\x3', '\x351', '\x3', '\x351', 
		'\x5', '\x351', '\x1E01', '\n', '\x351', '\x3', '\x352', '\x3', '\x352', 
		'\x3', '\x352', '\x5', '\x352', '\x1E06', '\n', '\x352', '\x3', '\x353', 
		'\x3', '\x353', '\x3', '\x353', '\x3', '\x353', '\x5', '\x353', '\x1E0C', 
		'\n', '\x353', '\x3', '\x354', '\x3', '\x354', '\x3', '\x354', '\x3', 
		'\x354', '\x5', '\x354', '\x1E12', '\n', '\x354', '\x3', '\x355', '\x3', 
		'\x355', '\x3', '\x355', '\x3', '\x355', '\x3', '\x355', '\x3', '\x356', 
		'\x3', '\x356', '\x3', '\x356', '\x3', '\x356', '\x3', '\x357', '\x5', 
		'\x357', '\x1E1E', '\n', '\x357', '\x3', '\x357', '\x3', '\x357', '\x3', 
		'\x358', '\x5', '\x358', '\x1E23', '\n', '\x358', '\x3', '\x358', '\x3', 
		'\x358', '\x3', '\x358', '\x5', '\x358', '\x1E28', '\n', '\x358', '\x3', 
		'\x358', '\x3', '\x358', '\x3', '\x358', '\x3', '\x359', '\x3', '\x359', 
		'\x3', '\x359', '\x3', '\x359', '\x3', '\x359', '\x3', '\x74C', '\x2', 
		'\x35A', '\x2', '\x4', '\x6', '\b', '\n', '\f', '\xE', '\x10', '\x12', 
		'\x14', '\x16', '\x18', '\x1A', '\x1C', '\x1E', ' ', '\"', '$', '&', '(', 
		'*', ',', '.', '\x30', '\x32', '\x34', '\x36', '\x38', ':', '<', '>', 
		'@', '\x42', '\x44', '\x46', 'H', 'J', 'L', 'N', 'P', 'R', 'T', 'V', 'X', 
		'Z', '\\', '^', '`', '\x62', '\x64', '\x66', 'h', 'j', 'l', 'n', 'p', 
		'r', 't', 'v', 'x', 'z', '|', '~', '\x80', '\x82', '\x84', '\x86', '\x88', 
		'\x8A', '\x8C', '\x8E', '\x90', '\x92', '\x94', '\x96', '\x98', '\x9A', 
		'\x9C', '\x9E', '\xA0', '\xA2', '\xA4', '\xA6', '\xA8', '\xAA', '\xAC', 
		'\xAE', '\xB0', '\xB2', '\xB4', '\xB6', '\xB8', '\xBA', '\xBC', '\xBE', 
		'\xC0', '\xC2', '\xC4', '\xC6', '\xC8', '\xCA', '\xCC', '\xCE', '\xD0', 
		'\xD2', '\xD4', '\xD6', '\xD8', '\xDA', '\xDC', '\xDE', '\xE0', '\xE2', 
		'\xE4', '\xE6', '\xE8', '\xEA', '\xEC', '\xEE', '\xF0', '\xF2', '\xF4', 
		'\xF6', '\xF8', '\xFA', '\xFC', '\xFE', '\x100', '\x102', '\x104', '\x106', 
		'\x108', '\x10A', '\x10C', '\x10E', '\x110', '\x112', '\x114', '\x116', 
		'\x118', '\x11A', '\x11C', '\x11E', '\x120', '\x122', '\x124', '\x126', 
		'\x128', '\x12A', '\x12C', '\x12E', '\x130', '\x132', '\x134', '\x136', 
		'\x138', '\x13A', '\x13C', '\x13E', '\x140', '\x142', '\x144', '\x146', 
		'\x148', '\x14A', '\x14C', '\x14E', '\x150', '\x152', '\x154', '\x156', 
		'\x158', '\x15A', '\x15C', '\x15E', '\x160', '\x162', '\x164', '\x166', 
		'\x168', '\x16A', '\x16C', '\x16E', '\x170', '\x172', '\x174', '\x176', 
		'\x178', '\x17A', '\x17C', '\x17E', '\x180', '\x182', '\x184', '\x186', 
		'\x188', '\x18A', '\x18C', '\x18E', '\x190', '\x192', '\x194', '\x196', 
		'\x198', '\x19A', '\x19C', '\x19E', '\x1A0', '\x1A2', '\x1A4', '\x1A6', 
		'\x1A8', '\x1AA', '\x1AC', '\x1AE', '\x1B0', '\x1B2', '\x1B4', '\x1B6', 
		'\x1B8', '\x1BA', '\x1BC', '\x1BE', '\x1C0', '\x1C2', '\x1C4', '\x1C6', 
		'\x1C8', '\x1CA', '\x1CC', '\x1CE', '\x1D0', '\x1D2', '\x1D4', '\x1D6', 
		'\x1D8', '\x1DA', '\x1DC', '\x1DE', '\x1E0', '\x1E2', '\x1E4', '\x1E6', 
		'\x1E8', '\x1EA', '\x1EC', '\x1EE', '\x1F0', '\x1F2', '\x1F4', '\x1F6', 
		'\x1F8', '\x1FA', '\x1FC', '\x1FE', '\x200', '\x202', '\x204', '\x206', 
		'\x208', '\x20A', '\x20C', '\x20E', '\x210', '\x212', '\x214', '\x216', 
		'\x218', '\x21A', '\x21C', '\x21E', '\x220', '\x222', '\x224', '\x226', 
		'\x228', '\x22A', '\x22C', '\x22E', '\x230', '\x232', '\x234', '\x236', 
		'\x238', '\x23A', '\x23C', '\x23E', '\x240', '\x242', '\x244', '\x246', 
		'\x248', '\x24A', '\x24C', '\x24E', '\x250', '\x252', '\x254', '\x256', 
		'\x258', '\x25A', '\x25C', '\x25E', '\x260', '\x262', '\x264', '\x266', 
		'\x268', '\x26A', '\x26C', '\x26E', '\x270', '\x272', '\x274', '\x276', 
		'\x278', '\x27A', '\x27C', '\x27E', '\x280', '\x282', '\x284', '\x286', 
		'\x288', '\x28A', '\x28C', '\x28E', '\x290', '\x292', '\x294', '\x296', 
		'\x298', '\x29A', '\x29C', '\x29E', '\x2A0', '\x2A2', '\x2A4', '\x2A6', 
		'\x2A8', '\x2AA', '\x2AC', '\x2AE', '\x2B0', '\x2B2', '\x2B4', '\x2B6', 
		'\x2B8', '\x2BA', '\x2BC', '\x2BE', '\x2C0', '\x2C2', '\x2C4', '\x2C6', 
		'\x2C8', '\x2CA', '\x2CC', '\x2CE', '\x2D0', '\x2D2', '\x2D4', '\x2D6', 
		'\x2D8', '\x2DA', '\x2DC', '\x2DE', '\x2E0', '\x2E2', '\x2E4', '\x2E6', 
		'\x2E8', '\x2EA', '\x2EC', '\x2EE', '\x2F0', '\x2F2', '\x2F4', '\x2F6', 
		'\x2F8', '\x2FA', '\x2FC', '\x2FE', '\x300', '\x302', '\x304', '\x306', 
		'\x308', '\x30A', '\x30C', '\x30E', '\x310', '\x312', '\x314', '\x316', 
		'\x318', '\x31A', '\x31C', '\x31E', '\x320', '\x322', '\x324', '\x326', 
		'\x328', '\x32A', '\x32C', '\x32E', '\x330', '\x332', '\x334', '\x336', 
		'\x338', '\x33A', '\x33C', '\x33E', '\x340', '\x342', '\x344', '\x346', 
		'\x348', '\x34A', '\x34C', '\x34E', '\x350', '\x352', '\x354', '\x356', 
		'\x358', '\x35A', '\x35C', '\x35E', '\x360', '\x362', '\x364', '\x366', 
		'\x368', '\x36A', '\x36C', '\x36E', '\x370', '\x372', '\x374', '\x376', 
		'\x378', '\x37A', '\x37C', '\x37E', '\x380', '\x382', '\x384', '\x386', 
		'\x388', '\x38A', '\x38C', '\x38E', '\x390', '\x392', '\x394', '\x396', 
		'\x398', '\x39A', '\x39C', '\x39E', '\x3A0', '\x3A2', '\x3A4', '\x3A6', 
		'\x3A8', '\x3AA', '\x3AC', '\x3AE', '\x3B0', '\x3B2', '\x3B4', '\x3B6', 
		'\x3B8', '\x3BA', '\x3BC', '\x3BE', '\x3C0', '\x3C2', '\x3C4', '\x3C6', 
		'\x3C8', '\x3CA', '\x3CC', '\x3CE', '\x3D0', '\x3D2', '\x3D4', '\x3D6', 
		'\x3D8', '\x3DA', '\x3DC', '\x3DE', '\x3E0', '\x3E2', '\x3E4', '\x3E6', 
		'\x3E8', '\x3EA', '\x3EC', '\x3EE', '\x3F0', '\x3F2', '\x3F4', '\x3F6', 
		'\x3F8', '\x3FA', '\x3FC', '\x3FE', '\x400', '\x402', '\x404', '\x406', 
		'\x408', '\x40A', '\x40C', '\x40E', '\x410', '\x412', '\x414', '\x416', 
		'\x418', '\x41A', '\x41C', '\x41E', '\x420', '\x422', '\x424', '\x426', 
		'\x428', '\x42A', '\x42C', '\x42E', '\x430', '\x432', '\x434', '\x436', 
		'\x438', '\x43A', '\x43C', '\x43E', '\x440', '\x442', '\x444', '\x446', 
		'\x448', '\x44A', '\x44C', '\x44E', '\x450', '\x452', '\x454', '\x456', 
		'\x458', '\x45A', '\x45C', '\x45E', '\x460', '\x462', '\x464', '\x466', 
		'\x468', '\x46A', '\x46C', '\x46E', '\x470', '\x472', '\x474', '\x476', 
		'\x478', '\x47A', '\x47C', '\x47E', '\x480', '\x482', '\x484', '\x486', 
		'\x488', '\x48A', '\x48C', '\x48E', '\x490', '\x492', '\x494', '\x496', 
		'\x498', '\x49A', '\x49C', '\x49E', '\x4A0', '\x4A2', '\x4A4', '\x4A6', 
		'\x4A8', '\x4AA', '\x4AC', '\x4AE', '\x4B0', '\x4B2', '\x4B4', '\x4B6', 
		'\x4B8', '\x4BA', '\x4BC', '\x4BE', '\x4C0', '\x4C2', '\x4C4', '\x4C6', 
		'\x4C8', '\x4CA', '\x4CC', '\x4CE', '\x4D0', '\x4D2', '\x4D4', '\x4D6', 
		'\x4D8', '\x4DA', '\x4DC', '\x4DE', '\x4E0', '\x4E2', '\x4E4', '\x4E6', 
		'\x4E8', '\x4EA', '\x4EC', '\x4EE', '\x4F0', '\x4F2', '\x4F4', '\x4F6', 
		'\x4F8', '\x4FA', '\x4FC', '\x4FE', '\x500', '\x502', '\x504', '\x506', 
		'\x508', '\x50A', '\x50C', '\x50E', '\x510', '\x512', '\x514', '\x516', 
		'\x518', '\x51A', '\x51C', '\x51E', '\x520', '\x522', '\x524', '\x526', 
		'\x528', '\x52A', '\x52C', '\x52E', '\x530', '\x532', '\x534', '\x536', 
		'\x538', '\x53A', '\x53C', '\x53E', '\x540', '\x542', '\x544', '\x546', 
		'\x548', '\x54A', '\x54C', '\x54E', '\x550', '\x552', '\x554', '\x556', 
		'\x558', '\x55A', '\x55C', '\x55E', '\x560', '\x562', '\x564', '\x566', 
		'\x568', '\x56A', '\x56C', '\x56E', '\x570', '\x572', '\x574', '\x576', 
		'\x578', '\x57A', '\x57C', '\x57E', '\x580', '\x582', '\x584', '\x586', 
		'\x588', '\x58A', '\x58C', '\x58E', '\x590', '\x592', '\x594', '\x596', 
		'\x598', '\x59A', '\x59C', '\x59E', '\x5A0', '\x5A2', '\x5A4', '\x5A6', 
		'\x5A8', '\x5AA', '\x5AC', '\x5AE', '\x5B0', '\x5B2', '\x5B4', '\x5B6', 
		'\x5B8', '\x5BA', '\x5BC', '\x5BE', '\x5C0', '\x5C2', '\x5C4', '\x5C6', 
		'\x5C8', '\x5CA', '\x5CC', '\x5CE', '\x5D0', '\x5D2', '\x5D4', '\x5D6', 
		'\x5D8', '\x5DA', '\x5DC', '\x5DE', '\x5E0', '\x5E2', '\x5E4', '\x5E6', 
		'\x5E8', '\x5EA', '\x5EC', '\x5EE', '\x5F0', '\x5F2', '\x5F4', '\x5F6', 
		'\x5F8', '\x5FA', '\x5FC', '\x5FE', '\x600', '\x602', '\x604', '\x606', 
		'\x608', '\x60A', '\x60C', '\x60E', '\x610', '\x612', '\x614', '\x616', 
		'\x618', '\x61A', '\x61C', '\x61E', '\x620', '\x622', '\x624', '\x626', 
		'\x628', '\x62A', '\x62C', '\x62E', '\x630', '\x632', '\x634', '\x636', 
		'\x638', '\x63A', '\x63C', '\x63E', '\x640', '\x642', '\x644', '\x646', 
		'\x648', '\x64A', '\x64C', '\x64E', '\x650', '\x652', '\x654', '\x656', 
		'\x658', '\x65A', '\x65C', '\x65E', '\x660', '\x662', '\x664', '\x666', 
		'\x668', '\x66A', '\x66C', '\x66E', '\x670', '\x672', '\x674', '\x676', 
		'\x678', '\x67A', '\x67C', '\x67E', '\x680', '\x682', '\x684', '\x686', 
		'\x688', '\x68A', '\x68C', '\x68E', '\x690', '\x692', '\x694', '\x696', 
		'\x698', '\x69A', '\x69C', '\x69E', '\x6A0', '\x6A2', '\x6A4', '\x6A6', 
		'\x6A8', '\x6AA', '\x6AC', '\x6AE', '\x6B0', '\x2', 'l', '\x5', '\x2', 
		'\x247', '\x247', '\x261', '\x261', '\x267', '\x267', '\x4', '\x2', '\xB4', 
		'\xB4', '\x212', '\x212', '\b', '\x2', 'p', 'p', '\xD7', '\xD7', '\x12F', 
		'\x12F', '\x135', '\x135', '\x1CE', '\x1CE', '\x245', '\x245', 'V', '\x2', 
		'\x3', '\x4', '\x6', '\t', '\v', '\f', '\xE', '\xF', '\x12', '\x14', '\x17', 
		'\x1A', '\x1C', '#', '%', '%', '\'', '\x32', '\x34', '\x38', ':', '?', 
		'\x41', '\x44', '\x46', '\x46', 'H', 'I', 'K', 'K', 'N', 'S', 'U', 'W', 
		'Z', '^', '`', '\x63', '\x65', 'g', 'i', 'i', 'k', 't', 'v', 'x', 'z', 
		'\x80', '\x82', '\x83', '\x8A', '\x8C', '\x8E', '\x8E', '\x90', '\x96', 
		'\x98', '\x9B', '\x9D', '\xA4', '\xA6', '\xA8', '\xAA', '\xB2', '\xB4', 
		'\xB5', '\xB7', '\xBD', '\xBF', '\xC7', '\xC9', '\xCD', '\xD1', '\xD3', 
		'\xD5', '\xD8', '\xDA', '\xDB', '\xDF', '\xE0', '\xE3', '\xE3', '\xE5', 
		'\xE6', '\xE9', '\xEB', '\xED', '\xF0', '\xF2', '\xF2', '\xF4', '\xF6', 
		'\xF8', '\x108', '\x10A', '\x112', '\x114', '\x11A', '\x11C', '\x122', 
		'\x124', '\x12D', '\x12F', '\x131', '\x134', '\x138', '\x13A', '\x144', 
		'\x146', '\x146', '\x148', '\x15B', '\x15D', '\x15E', '\x161', '\x161', 
		'\x163', '\x163', '\x165', '\x167', '\x169', '\x16E', '\x172', '\x184', 
		'\x186', '\x18D', '\x18F', '\x1B5', '\x1B7', '\x1B9', '\x1BB', '\x1BC', 
		'\x1BE', '\x1C2', '\x1C4', '\x1D1', '\x1D3', '\x1DC', '\x1DE', '\x1E7', 
		'\x1E9', '\x1FA', '\x1FC', '\x1FC', '\x1FE', '\x202', '\x205', '\x20A', 
		'\x20C', '\x20F', '\x211', '\x218', '\x21B', '\x21C', '\x21E', '\x21F', 
		'\x221', '\x227', '\x229', '\x22E', '\x230', '\x233', '\x237', '\x23D', 
		'\x240', '\x240', '\x242', '\x246', '\x4', '\x2', '\x257', '\x257', '\x25E', 
		'\x25E', '\x3', '\x2', '\x250', '\x250', '\x5', '\x2', '\n', '\n', '\x8D', 
		'\x8D', '\x21A', '\x21A', '\x4', '\x2', '<', '<', '>', '>', '\x4', '\x2', 
		'\x34', '\x34', '<', '<', '\x4', '\x2', '\x1C4', '\x1C4', '\x215', '\x215', 
		'\x4', '\x2', '\x24A', '\x24A', '\x258', '\x259', '\x5', '\x2', '\x131', 
		'\x131', '\x251', '\x251', '\x25D', '\x25D', '\x5', '\x2', '\xA4', '\xA4', 
		'\xF1', '\xF1', '\x219', '\x219', '\x4', '\x2', '\n', '\n', '\x8D', '\x8D', 
		'\x4', '\x2', '\xBA', '\xBA', '\x102', '\x102', '\x4', '\x2', '\x1A0', 
		'\x1A0', '\x1C3', '\x1C3', '\x4', '\x2', '\xBD', '\xBD', '\x192', '\x192', 
		'\x6', '\x2', '\xC3', '\xC3', '\xF9', '\xF9', '\x15D', '\x15D', '\x1C0', 
		'\x1C0', '\x3', '\x2', '\x9E', '\x9F', '\x5', '\x2', '+', '+', '\x103', 
		'\x103', '\x20C', '\x20C', '\t', '\x2', 'p', 'p', '\xD7', '\xD7', '\x12F', 
		'\x12F', '\x135', '\x135', '\x1CE', '\x1CE', '\x207', '\x20A', '\x245', 
		'\x245', '\x3', '\x2', '\xB2', '\xB3', '\x3', '\x2', '\x109', '\x10C', 
		'\x4', '\x2', '\x113', '\x113', '\x21C', '\x21C', '\x4', '\x2', '\n', 
		'\n', 'h', 'h', '\x4', '\x2', '(', '(', '\x21A', '\x21A', '\x4', '\x2', 
		'\x21E', '\x21E', '\x221', '\x221', '\x4', '\x2', '{', '{', '\xDD', '\xDD', 
		'\x4', '\x2', '\x16', '\x16', '\x81', '\x81', '\x4', '\x2', '\xF6', '\xF6', 
		'\x231', '\x231', '\x4', '\x2', '\xC9', '\xC9', '\x17F', '\x17F', '\x5', 
		'\x2', 'l', 'l', '\x12B', '\x12B', '\x152', '\x152', '\x4', '\x2', '\x93', 
		'\x93', '\x153', '\x153', '\x3', '\x2', '\x251', '\x251', '\x4', '\x2', 
		'\x15', '\x15', '\xF7', '\xF7', '\x4', '\x2', 'i', 'i', '|', '|', '\x4', 
		'\x2', 'y', 'y', '\x248', '\x248', '\x4', '\x2', '\xD3', '\xD3', '\x1A0', 
		'\x1A0', '\x4', '\x2', '\x45', '\x45', '\x171', '\x171', '\x4', '\x2', 
		'\x1BF', '\x1BF', '\x1FD', '\x1FD', '\x4', '\x2', '\x1A2', '\x1A2', '\x23C', 
		'\x23C', '\x4', '\x2', '!', '!', '\x1CF', '\x1CF', '\x4', '\x2', '\x110', 
		'\x110', '\x1FE', '\x1FE', '\x4', '\x2', '\x112', '\x112', '\x227', '\x227', 
		'\x4', '\x2', '\x8F', '\x8F', '\xFE', '\xFE', '\x4', '\x2', '\x134', '\x134', 
		'\x150', '\x150', '\x4', '\x2', '\x158', '\x158', '\x1C1', '\x1C1', '\x4', 
		'\x2', '\x6', '\x6', ' ', ' ', '\x4', '\x2', '\x13', '\x13', '\x19C', 
		'\x19C', '\x4', '\x2', '\xD6', '\xD6', '\x11C', '\x11C', '\x4', '\x2', 
		'\n', '\n', '\x83', '\x83', '\x4', '\x2', '}', '}', '\x194', '\x194', 
		'\x4', '\x2', '\x236', '\x236', '\x238', '\x238', '\x4', '\x2', '\x36', 
		'\x36', '\x146', '\x146', '\x5', '\x2', 'R', 'R', '\xB5', '\xB5', '\xC0', 
		'\xC0', '\x5', '\x2', 'N', 'N', '~', '~', '\x1EA', '\x1EA', '\x4', '\x2', 
		'\x111', '\x111', '\x11F', '\x11F', '\x4', '\x2', '\x9D', '\x9D', '\x214', 
		'\x214', '\x4', '\x2', '\x8A', '\x8A', '\x9A', '\x9A', '\x4', '\x2', '\f', 
		'\f', '\x8B', '\x8B', '\x4', '\x2', '\xDA', '\xDA', '\x165', '\x165', 
		'\x4', '\x2', '\x156', '\x156', '\x1AF', '\x1AF', '\x5', '\x2', '\xB7', 
		'\xB7', '\x117', '\x117', '\x14C', '\x14C', '\x4', '\x2', '\x15B', '\x15B', 
		'\x1E4', '\x1E4', '\x4', '\x2', '\xE8', '\xE8', '\x143', '\x143', '\x5', 
		'\x2', 'y', 'y', '\xFE', '\xFE', '\x1A6', '\x1A6', '\x5', '\x2', 'y', 
		'y', '\xFE', '\xFE', '\x152', '\x152', '\x4', '\x2', '\x15E', '\x15E', 
		'\x226', '\x226', '\x4', '\x2', '\x247', '\x247', '\x266', '\x266', '\x4', 
		'\x2', '\a', '\a', '#', '#', '\x4', '\x2', 'm', 'm', '\x1CA', '\x1CA', 
		'\a', '\x2', '\x118', '\x119', '\x1D7', '\x1D7', '\x1DF', '\x1DF', '\x1E9', 
		'\x1E9', '\x1F9', '\x1F9', '\x5', '\x2', '}', '}', '\xEC', '\xEC', '\x220', 
		'\x220', '\x5', '\x2', '\x141', '\x141', '\x167', '\x167', '\x17E', '\x17E', 
		'\x4', '\x2', ',', ',', '\x80', '\x80', '\x4', '\x2', 'g', 'g', '\x1BE', 
		'\x1BE', '\x5', '\x2', '\xC9', '\xC9', '\x104', '\x104', '\x1BC', '\x1BC', 
		'\x4', '\x2', '\x180', '\x180', '\x1F4', '\x1F4', '\x4', '\x2', '\x99', 
		'\x99', '\xA0', '\xA0', '\x4', '\x2', '\xA0', '\xA0', '\x160', '\x160', 
		'\x5', '\x2', '\xA0', '\xA0', '\xB4', '\xB4', '\x212', '\x212', '\x4', 
		'\x2', 'W', 'W', '\x217', '\x217', '\x4', '\x2', '\x14', '\x14', '\x163', 
		'\x163', '\x4', '\x2', '\x1CB', '\x1CB', '\x206', '\x206', '\x4', '\x2', 
		'\n', '\n', '\xBA', '\xBA', '\x4', '\x2', '\"', '\"', '\xDD', '\xDD', 
		'\x4', '\x2', '\x15F', '\x15F', '\x232', '\x232', '\x4', '\x2', '\x169', 
		'\x169', '\x23C', '\x23C', '\x3', '\x2', '\x1B6', '\x1B7', '\x4', '\x2', 
		'\x194', '\x194', '\x19B', '\x19B', '\x4', '\x2', '\x8F', '\x8F', '\x1B8', 
		'\x1B8', '\x4', '\x2', '\xA9', '\xA9', '\x1DD', '\x1DD', '\x4', '\x2', 
		'=', '=', '\x13D', '\x13D', '\x4', '\x2', '\xC0', '\xC0', '\x226', '\x226', 
		'\x4', '\x2', '*', '*', '\x1E6', '\x1E6', '\x4', '\x2', '\x5', '\x5', 
		'\x8F', '\x8F', '\x4', '\x2', '\x5', '\x5', '\x133', '\x133', '\x4', '\x2', 
		'k', 'k', '\x149', '\x149', '\x4', '\x2', '\x151', '\x151', '\x171', '\x171', 
		'\x4', '\x2', '\xAE', '\xAE', '\x14A', '\x14A', '\x4', '\x2', '\xFE', 
		'\xFE', '\x14B', '\x14B', '\x4', '\x2', '\xCC', '\xCC', '\x1D8', '\x1D8', 
		'\x4', '\x2', '\x128', '\x128', '\x1EB', '\x1EB', '\x4', '\x2', '\x11D', 
		'\x11D', '\x171', '\x171', '\x5', '\x2', '\xB8', '\xB8', '\xEE', '\xEE', 
		'\x179', '\x179', '\x4', '\x2', '\x12B', '\x12B', '\x152', '\x152', '\x2', 
		'\x1FF2', '\x2', '\x6B2', '\x3', '\x2', '\x2', '\x2', '\x4', '\x6B4', 
		'\x3', '\x2', '\x2', '\x2', '\x6', '\x6B6', '\x3', '\x2', '\x2', '\x2', 
		'\b', '\x6BA', '\x3', '\x2', '\x2', '\x2', '\n', '\x6BC', '\x3', '\x2', 
		'\x2', '\x2', '\f', '\x6BE', '\x3', '\x2', '\x2', '\x2', '\xE', '\x6C3', 
		'\x3', '\x2', '\x2', '\x2', '\x10', '\x6CF', '\x3', '\x2', '\x2', '\x2', 
		'\x12', '\x6D4', '\x3', '\x2', '\x2', '\x2', '\x14', '\x6E2', '\x3', '\x2', 
		'\x2', '\x2', '\x16', '\x6EB', '\x3', '\x2', '\x2', '\x2', '\x18', '\x6EE', 
		'\x3', '\x2', '\x2', '\x2', '\x1A', '\x6F6', '\x3', '\x2', '\x2', '\x2', 
		'\x1C', '\x717', '\x3', '\x2', '\x2', '\x2', '\x1E', '\x71D', '\x3', '\x2', 
		'\x2', '\x2', ' ', '\x721', '\x3', '\x2', '\x2', '\x2', '\"', '\x741', 
		'\x3', '\x2', '\x2', '\x2', '$', '\x751', '\x3', '\x2', '\x2', '\x2', 
		'&', '\x75D', '\x3', '\x2', '\x2', '\x2', '(', '\x75F', '\x3', '\x2', 
		'\x2', '\x2', '*', '\x761', '\x3', '\x2', '\x2', '\x2', ',', '\x763', 
		'\x3', '\x2', '\x2', '\x2', '.', '\x765', '\x3', '\x2', '\x2', '\x2', 
		'\x30', '\x767', '\x3', '\x2', '\x2', '\x2', '\x32', '\x769', '\x3', '\x2', 
		'\x2', '\x2', '\x34', '\x76C', '\x3', '\x2', '\x2', '\x2', '\x36', '\x76F', 
		'\x3', '\x2', '\x2', '\x2', '\x38', '\x776', '\x3', '\x2', '\x2', '\x2', 
		':', '\x77A', '\x3', '\x2', '\x2', '\x2', '<', '\x782', '\x3', '\x2', 
		'\x2', '\x2', '>', '\x786', '\x3', '\x2', '\x2', '\x2', '@', '\x788', 
		'\x3', '\x2', '\x2', '\x2', '\x42', '\x78A', '\x3', '\x2', '\x2', '\x2', 
		'\x44', '\x79B', '\x3', '\x2', '\x2', '\x2', '\x46', '\x7A4', '\x3', '\x2', 
		'\x2', '\x2', 'H', '\x7B0', '\x3', '\x2', '\x2', '\x2', 'J', '\x7B8', 
		'\x3', '\x2', '\x2', '\x2', 'L', '\x7BA', '\x3', '\x2', '\x2', '\x2', 
		'N', '\x7CB', '\x3', '\x2', '\x2', '\x2', 'P', '\x7D3', '\x3', '\x2', 
		'\x2', '\x2', 'R', '\x7D5', '\x3', '\x2', '\x2', '\x2', 'T', '\x7D7', 
		'\x3', '\x2', '\x2', '\x2', 'V', '\x7E3', '\x3', '\x2', '\x2', '\x2', 
		'X', '\x7E7', '\x3', '\x2', '\x2', '\x2', 'Z', '\x7F2', '\x3', '\x2', 
		'\x2', '\x2', '\\', '\x7F6', '\x3', '\x2', '\x2', '\x2', '^', '\x7FB', 
		'\x3', '\x2', '\x2', '\x2', '`', '\x80B', '\x3', '\x2', '\x2', '\x2', 
		'\x62', '\x810', '\x3', '\x2', '\x2', '\x2', '\x64', '\x814', '\x3', '\x2', 
		'\x2', '\x2', '\x66', '\x818', '\x3', '\x2', '\x2', '\x2', 'h', '\x81C', 
		'\x3', '\x2', '\x2', '\x2', 'j', '\x820', '\x3', '\x2', '\x2', '\x2', 
		'l', '\x824', '\x3', '\x2', '\x2', '\x2', 'n', '\x828', '\x3', '\x2', 
		'\x2', '\x2', 'p', '\x82C', '\x3', '\x2', '\x2', '\x2', 'r', '\x830', 
		'\x3', '\x2', '\x2', '\x2', 't', '\x834', '\x3', '\x2', '\x2', '\x2', 
		'v', '\x837', '\x3', '\x2', '\x2', '\x2', 'x', '\x83C', '\x3', '\x2', 
		'\x2', '\x2', 'z', '\x846', '\x3', '\x2', '\x2', '\x2', '|', '\x851', 
		'\x3', '\x2', '\x2', '\x2', '~', '\x85B', '\x3', '\x2', '\x2', '\x2', 
		'\x80', '\x862', '\x3', '\x2', '\x2', '\x2', '\x82', '\x869', '\x3', '\x2', 
		'\x2', '\x2', '\x84', '\x870', '\x3', '\x2', '\x2', '\x2', '\x86', '\x877', 
		'\x3', '\x2', '\x2', '\x2', '\x88', '\x880', '\x3', '\x2', '\x2', '\x2', 
		'\x8A', '\x88B', '\x3', '\x2', '\x2', '\x2', '\x8C', '\x897', '\x3', '\x2', 
		'\x2', '\x2', '\x8E', '\x899', '\x3', '\x2', '\x2', '\x2', '\x90', '\x89F', 
		'\x3', '\x2', '\x2', '\x2', '\x92', '\x8A4', '\x3', '\x2', '\x2', '\x2', 
		'\x94', '\x8A6', '\x3', '\x2', '\x2', '\x2', '\x96', '\x8AC', '\x3', '\x2', 
		'\x2', '\x2', '\x98', '\x8AF', '\x3', '\x2', '\x2', '\x2', '\x9A', '\x8B4', 
		'\x3', '\x2', '\x2', '\x2', '\x9C', '\x8B6', '\x3', '\x2', '\x2', '\x2', 
		'\x9E', '\x8B9', '\x3', '\x2', '\x2', '\x2', '\xA0', '\x8BC', '\x3', '\x2', 
		'\x2', '\x2', '\xA2', '\x8BE', '\x3', '\x2', '\x2', '\x2', '\xA4', '\x8C6', 
		'\x3', '\x2', '\x2', '\x2', '\xA6', '\x8CF', '\x3', '\x2', '\x2', '\x2', 
		'\xA8', '\x8DC', '\x3', '\x2', '\x2', '\x2', '\xAA', '\x8DE', '\x3', '\x2', 
		'\x2', '\x2', '\xAC', '\x8E1', '\x3', '\x2', '\x2', '\x2', '\xAE', '\x8E3', 
		'\x3', '\x2', '\x2', '\x2', '\xB0', '\x917', '\x3', '\x2', '\x2', '\x2', 
		'\xB2', '\x919', '\x3', '\x2', '\x2', '\x2', '\xB4', '\x91B', '\x3', '\x2', 
		'\x2', '\x2', '\xB6', '\x91D', '\x3', '\x2', '\x2', '\x2', '\xB8', '\x91F', 
		'\x3', '\x2', '\x2', '\x2', '\xBA', '\x921', '\x3', '\x2', '\x2', '\x2', 
		'\xBC', '\x923', '\x3', '\x2', '\x2', '\x2', '\xBE', '\x925', '\x3', '\x2', 
		'\x2', '\x2', '\xC0', '\x927', '\x3', '\x2', '\x2', '\x2', '\xC2', '\x929', 
		'\x3', '\x2', '\x2', '\x2', '\xC4', '\x933', '\x3', '\x2', '\x2', '\x2', 
		'\xC6', '\x943', '\x3', '\x2', '\x2', '\x2', '\xC8', '\x945', '\x3', '\x2', 
		'\x2', '\x2', '\xCA', '\x94E', '\x3', '\x2', '\x2', '\x2', '\xCC', '\x957', 
		'\x3', '\x2', '\x2', '\x2', '\xCE', '\x959', '\x3', '\x2', '\x2', '\x2', 
		'\xD0', '\x97E', '\x3', '\x2', '\x2', '\x2', '\xD2', '\x983', '\x3', '\x2', 
		'\x2', '\x2', '\xD4', '\x985', '\x3', '\x2', '\x2', '\x2', '\xD6', '\x992', 
		'\x3', '\x2', '\x2', '\x2', '\xD8', '\x99A', '\x3', '\x2', '\x2', '\x2', 
		'\xDA', '\x99F', '\x3', '\x2', '\x2', '\x2', '\xDC', '\x9AA', '\x3', '\x2', 
		'\x2', '\x2', '\xDE', '\x9AD', '\x3', '\x2', '\x2', '\x2', '\xE0', '\x9B2', 
		'\x3', '\x2', '\x2', '\x2', '\xE2', '\x9B7', '\x3', '\x2', '\x2', '\x2', 
		'\xE4', '\x9BD', '\x3', '\x2', '\x2', '\x2', '\xE6', '\x9C0', '\x3', '\x2', 
		'\x2', '\x2', '\xE8', '\x9C9', '\x3', '\x2', '\x2', '\x2', '\xEA', '\x9CE', 
		'\x3', '\x2', '\x2', '\x2', '\xEC', '\x9D3', '\x3', '\x2', '\x2', '\x2', 
		'\xEE', '\x9D5', '\x3', '\x2', '\x2', '\x2', '\xF0', '\x9DC', '\x3', '\x2', 
		'\x2', '\x2', '\xF2', '\x9E1', '\x3', '\x2', '\x2', '\x2', '\xF4', '\x9E8', 
		'\x3', '\x2', '\x2', '\x2', '\xF6', '\x9ED', '\x3', '\x2', '\x2', '\x2', 
		'\xF8', '\x9F3', '\x3', '\x2', '\x2', '\x2', '\xFA', '\x9F6', '\x3', '\x2', 
		'\x2', '\x2', '\xFC', '\xA03', '\x3', '\x2', '\x2', '\x2', '\xFE', '\xA07', 
		'\x3', '\x2', '\x2', '\x2', '\x100', '\xA0C', '\x3', '\x2', '\x2', '\x2', 
		'\x102', '\xA11', '\x3', '\x2', '\x2', '\x2', '\x104', '\xA1A', '\x3', 
		'\x2', '\x2', '\x2', '\x106', '\xA1C', '\x3', '\x2', '\x2', '\x2', '\x108', 
		'\xA1E', '\x3', '\x2', '\x2', '\x2', '\x10A', '\xA22', '\x3', '\x2', '\x2', 
		'\x2', '\x10C', '\xA28', '\x3', '\x2', '\x2', '\x2', '\x10E', '\xA31', 
		'\x3', '\x2', '\x2', '\x2', '\x110', '\xA34', '\x3', '\x2', '\x2', '\x2', 
		'\x112', '\xA38', '\x3', '\x2', '\x2', '\x2', '\x114', '\xA3D', '\x3', 
		'\x2', '\x2', '\x2', '\x116', '\xA3F', '\x3', '\x2', '\x2', '\x2', '\x118', 
		'\xA41', '\x3', '\x2', '\x2', '\x2', '\x11A', '\xA46', '\x3', '\x2', '\x2', 
		'\x2', '\x11C', '\xA48', '\x3', '\x2', '\x2', '\x2', '\x11E', '\xA53', 
		'\x3', '\x2', '\x2', '\x2', '\x120', '\xA58', '\x3', '\x2', '\x2', '\x2', 
		'\x122', '\xA5F', '\x3', '\x2', '\x2', '\x2', '\x124', '\xA68', '\x3', 
		'\x2', '\x2', '\x2', '\x126', '\xA6D', '\x3', '\x2', '\x2', '\x2', '\x128', 
		'\xA71', '\x3', '\x2', '\x2', '\x2', '\x12A', '\xA78', '\x3', '\x2', '\x2', 
		'\x2', '\x12C', '\xA7D', '\x3', '\x2', '\x2', '\x2', '\x12E', '\xA80', 
		'\x3', '\x2', '\x2', '\x2', '\x130', '\xA83', '\x3', '\x2', '\x2', '\x2', 
		'\x132', '\xA86', '\x3', '\x2', '\x2', '\x2', '\x134', '\xA93', '\x3', 
		'\x2', '\x2', '\x2', '\x136', '\xA97', '\x3', '\x2', '\x2', '\x2', '\x138', 
		'\xAA3', '\x3', '\x2', '\x2', '\x2', '\x13A', '\xAA9', '\x3', '\x2', '\x2', 
		'\x2', '\x13C', '\xAB4', '\x3', '\x2', '\x2', '\x2', '\x13E', '\xAB6', 
		'\x3', '\x2', '\x2', '\x2', '\x140', '\xAB8', '\x3', '\x2', '\x2', '\x2', 
		'\x142', '\xABA', '\x3', '\x2', '\x2', '\x2', '\x144', '\xAC0', '\x3', 
		'\x2', '\x2', '\x2', '\x146', '\xAD1', '\x3', '\x2', '\x2', '\x2', '\x148', 
		'\xAD3', '\x3', '\x2', '\x2', '\x2', '\x14A', '\xAD7', '\x3', '\x2', '\x2', 
		'\x2', '\x14C', '\xAE9', '\x3', '\x2', '\x2', '\x2', '\x14E', '\xAEC', 
		'\x3', '\x2', '\x2', '\x2', '\x150', '\xAF3', '\x3', '\x2', '\x2', '\x2', 
		'\x152', '\xAF9', '\x3', '\x2', '\x2', '\x2', '\x154', '\xB00', '\x3', 
		'\x2', '\x2', '\x2', '\x156', '\xB06', '\x3', '\x2', '\x2', '\x2', '\x158', 
		'\xB08', '\x3', '\x2', '\x2', '\x2', '\x15A', '\xB0B', '\x3', '\x2', '\x2', 
		'\x2', '\x15C', '\xB0D', '\x3', '\x2', '\x2', '\x2', '\x15E', '\xB1E', 
		'\x3', '\x2', '\x2', '\x2', '\x160', '\xB20', '\x3', '\x2', '\x2', '\x2', 
		'\x162', '\xB24', '\x3', '\x2', '\x2', '\x2', '\x164', '\xB36', '\x3', 
		'\x2', '\x2', '\x2', '\x166', '\xB38', '\x3', '\x2', '\x2', '\x2', '\x168', 
		'\xB45', '\x3', '\x2', '\x2', '\x2', '\x16A', '\xB47', '\x3', '\x2', '\x2', 
		'\x2', '\x16C', '\xB4F', '\x3', '\x2', '\x2', '\x2', '\x16E', '\xB56', 
		'\x3', '\x2', '\x2', '\x2', '\x170', '\xB59', '\x3', '\x2', '\x2', '\x2', 
		'\x172', '\xB62', '\x3', '\x2', '\x2', '\x2', '\x174', '\xB6A', '\x3', 
		'\x2', '\x2', '\x2', '\x176', '\xB6E', '\x3', '\x2', '\x2', '\x2', '\x178', 
		'\xB72', '\x3', '\x2', '\x2', '\x2', '\x17A', '\xB7A', '\x3', '\x2', '\x2', 
		'\x2', '\x17C', '\xB82', '\x3', '\x2', '\x2', '\x2', '\x17E', '\xB84', 
		'\x3', '\x2', '\x2', '\x2', '\x180', '\xB86', '\x3', '\x2', '\x2', '\x2', 
		'\x182', '\xB93', '\x3', '\x2', '\x2', '\x2', '\x184', '\xB96', '\x3', 
		'\x2', '\x2', '\x2', '\x186', '\xBA4', '\x3', '\x2', '\x2', '\x2', '\x188', 
		'\xBA6', '\x3', '\x2', '\x2', '\x2', '\x18A', '\xBAC', '\x3', '\x2', '\x2', 
		'\x2', '\x18C', '\xBB1', '\x3', '\x2', '\x2', '\x2', '\x18E', '\xBB6', 
		'\x3', '\x2', '\x2', '\x2', '\x190', '\xBC2', '\x3', '\x2', '\x2', '\x2', 
		'\x192', '\xBC4', '\x3', '\x2', '\x2', '\x2', '\x194', '\xBC8', '\x3', 
		'\x2', '\x2', '\x2', '\x196', '\xBCD', '\x3', '\x2', '\x2', '\x2', '\x198', 
		'\xBD3', '\x3', '\x2', '\x2', '\x2', '\x19A', '\xBDB', '\x3', '\x2', '\x2', 
		'\x2', '\x19C', '\xBDE', '\x3', '\x2', '\x2', '\x2', '\x19E', '\xBE1', 
		'\x3', '\x2', '\x2', '\x2', '\x1A0', '\xBE4', '\x3', '\x2', '\x2', '\x2', 
		'\x1A2', '\xBE7', '\x3', '\x2', '\x2', '\x2', '\x1A4', '\xBEC', '\x3', 
		'\x2', '\x2', '\x2', '\x1A6', '\xBFD', '\x3', '\x2', '\x2', '\x2', '\x1A8', 
		'\xC05', '\x3', '\x2', '\x2', '\x2', '\x1AA', '\xC16', '\x3', '\x2', '\x2', 
		'\x2', '\x1AC', '\xC1A', '\x3', '\x2', '\x2', '\x2', '\x1AE', '\xC31', 
		'\x3', '\x2', '\x2', '\x2', '\x1B0', '\xC35', '\x3', '\x2', '\x2', '\x2', 
		'\x1B2', '\xC41', '\x3', '\x2', '\x2', '\x2', '\x1B4', '\xC43', '\x3', 
		'\x2', '\x2', '\x2', '\x1B6', '\xC4A', '\x3', '\x2', '\x2', '\x2', '\x1B8', 
		'\xC4C', '\x3', '\x2', '\x2', '\x2', '\x1BA', '\xC57', '\x3', '\x2', '\x2', 
		'\x2', '\x1BC', '\xC71', '\x3', '\x2', '\x2', '\x2', '\x1BE', '\xC73', 
		'\x3', '\x2', '\x2', '\x2', '\x1C0', '\xC80', '\x3', '\x2', '\x2', '\x2', 
		'\x1C2', '\xC8D', '\x3', '\x2', '\x2', '\x2', '\x1C4', '\xC9C', '\x3', 
		'\x2', '\x2', '\x2', '\x1C6', '\xC9E', '\x3', '\x2', '\x2', '\x2', '\x1C8', 
		'\xCB6', '\x3', '\x2', '\x2', '\x2', '\x1CA', '\xCB8', '\x3', '\x2', '\x2', 
		'\x2', '\x1CC', '\xCBA', '\x3', '\x2', '\x2', '\x2', '\x1CE', '\xCBD', 
		'\x3', '\x2', '\x2', '\x2', '\x1D0', '\xCC9', '\x3', '\x2', '\x2', '\x2', 
		'\x1D2', '\xCD1', '\x3', '\x2', '\x2', '\x2', '\x1D4', '\xCD6', '\x3', 
		'\x2', '\x2', '\x2', '\x1D6', '\xCDB', '\x3', '\x2', '\x2', '\x2', '\x1D8', 
		'\xCDE', '\x3', '\x2', '\x2', '\x2', '\x1DA', '\xCE9', '\x3', '\x2', '\x2', 
		'\x2', '\x1DC', '\xCEE', '\x3', '\x2', '\x2', '\x2', '\x1DE', '\xCFA', 
		'\x3', '\x2', '\x2', '\x2', '\x1E0', '\xCFC', '\x3', '\x2', '\x2', '\x2', 
		'\x1E2', '\xD0E', '\x3', '\x2', '\x2', '\x2', '\x1E4', '\xD21', '\x3', 
		'\x2', '\x2', '\x2', '\x1E6', '\xD23', '\x3', '\x2', '\x2', '\x2', '\x1E8', 
		'\xD27', '\x3', '\x2', '\x2', '\x2', '\x1EA', '\xD2D', '\x3', '\x2', '\x2', 
		'\x2', '\x1EC', '\xD2F', '\x3', '\x2', '\x2', '\x2', '\x1EE', '\xD34', 
		'\x3', '\x2', '\x2', '\x2', '\x1F0', '\xD3A', '\x3', '\x2', '\x2', '\x2', 
		'\x1F2', '\xD3C', '\x3', '\x2', '\x2', '\x2', '\x1F4', '\xD3F', '\x3', 
		'\x2', '\x2', '\x2', '\x1F6', '\xD44', '\x3', '\x2', '\x2', '\x2', '\x1F8', 
		'\xD48', '\x3', '\x2', '\x2', '\x2', '\x1FA', '\xD56', '\x3', '\x2', '\x2', 
		'\x2', '\x1FC', '\xD59', '\x3', '\x2', '\x2', '\x2', '\x1FE', '\xD5C', 
		'\x3', '\x2', '\x2', '\x2', '\x200', '\xD60', '\x3', '\x2', '\x2', '\x2', 
		'\x202', '\xD63', '\x3', '\x2', '\x2', '\x2', '\x204', '\xD68', '\x3', 
		'\x2', '\x2', '\x2', '\x206', '\xD75', '\x3', '\x2', '\x2', '\x2', '\x208', 
		'\xD80', '\x3', '\x2', '\x2', '\x2', '\x20A', '\xD86', '\x3', '\x2', '\x2', 
		'\x2', '\x20C', '\xD88', '\x3', '\x2', '\x2', '\x2', '\x20E', '\xD8B', 
		'\x3', '\x2', '\x2', '\x2', '\x210', '\xD8F', '\x3', '\x2', '\x2', '\x2', 
		'\x212', '\xD9E', '\x3', '\x2', '\x2', '\x2', '\x214', '\xDA0', '\x3', 
		'\x2', '\x2', '\x2', '\x216', '\xDA8', '\x3', '\x2', '\x2', '\x2', '\x218', 
		'\xDAB', '\x3', '\x2', '\x2', '\x2', '\x21A', '\xDAD', '\x3', '\x2', '\x2', 
		'\x2', '\x21C', '\xDB1', '\x3', '\x2', '\x2', '\x2', '\x21E', '\xDB7', 
		'\x3', '\x2', '\x2', '\x2', '\x220', '\xDC2', '\x3', '\x2', '\x2', '\x2', 
		'\x222', '\xDC6', '\x3', '\x2', '\x2', '\x2', '\x224', '\xDCA', '\x3', 
		'\x2', '\x2', '\x2', '\x226', '\xDCD', '\x3', '\x2', '\x2', '\x2', '\x228', 
		'\xDD1', '\x3', '\x2', '\x2', '\x2', '\x22A', '\xDDD', '\x3', '\x2', '\x2', 
		'\x2', '\x22C', '\xDE1', '\x3', '\x2', '\x2', '\x2', '\x22E', '\xDEA', 
		'\x3', '\x2', '\x2', '\x2', '\x230', '\xDFC', '\x3', '\x2', '\x2', '\x2', 
		'\x232', '\xE0B', '\x3', '\x2', '\x2', '\x2', '\x234', '\xE20', '\x3', 
		'\x2', '\x2', '\x2', '\x236', '\xE24', '\x3', '\x2', '\x2', '\x2', '\x238', 
		'\xE27', '\x3', '\x2', '\x2', '\x2', '\x23A', '\xE2D', '\x3', '\x2', '\x2', 
		'\x2', '\x23C', '\xE36', '\x3', '\x2', '\x2', '\x2', '\x23E', '\xE3F', 
		'\x3', '\x2', '\x2', '\x2', '\x240', '\xE45', '\x3', '\x2', '\x2', '\x2', 
		'\x242', '\xE52', '\x3', '\x2', '\x2', '\x2', '\x244', '\xE58', '\x3', 
		'\x2', '\x2', '\x2', '\x246', '\xE7C', '\x3', '\x2', '\x2', '\x2', '\x248', 
		'\xE80', '\x3', '\x2', '\x2', '\x2', '\x24A', '\xE8F', '\x3', '\x2', '\x2', 
		'\x2', '\x24C', '\xE91', '\x3', '\x2', '\x2', '\x2', '\x24E', '\xE97', 
		'\x3', '\x2', '\x2', '\x2', '\x250', '\xE9B', '\x3', '\x2', '\x2', '\x2', 
		'\x252', '\xEA8', '\x3', '\x2', '\x2', '\x2', '\x254', '\xEAE', '\x3', 
		'\x2', '\x2', '\x2', '\x256', '\xEB2', '\x3', '\x2', '\x2', '\x2', '\x258', 
		'\xEB6', '\x3', '\x2', '\x2', '\x2', '\x25A', '\xEC3', '\x3', '\x2', '\x2', 
		'\x2', '\x25C', '\xECB', '\x3', '\x2', '\x2', '\x2', '\x25E', '\xED1', 
		'\x3', '\x2', '\x2', '\x2', '\x260', '\xEEE', '\x3', '\x2', '\x2', '\x2', 
		'\x262', '\xEF0', '\x3', '\x2', '\x2', '\x2', '\x264', '\xEF9', '\x3', 
		'\x2', '\x2', '\x2', '\x266', '\xEFB', '\x3', '\x2', '\x2', '\x2', '\x268', 
		'\xEFE', '\x3', '\x2', '\x2', '\x2', '\x26A', '\xF02', '\x3', '\x2', '\x2', 
		'\x2', '\x26C', '\xF17', '\x3', '\x2', '\x2', '\x2', '\x26E', '\xF1A', 
		'\x3', '\x2', '\x2', '\x2', '\x270', '\xF1C', '\x3', '\x2', '\x2', '\x2', 
		'\x272', '\xF1E', '\x3', '\x2', '\x2', '\x2', '\x274', '\xF25', '\x3', 
		'\x2', '\x2', '\x2', '\x276', '\xF27', '\x3', '\x2', '\x2', '\x2', '\x278', 
		'\xF2F', '\x3', '\x2', '\x2', '\x2', '\x27A', '\xF37', '\x3', '\x2', '\x2', 
		'\x2', '\x27C', '\xF3F', '\x3', '\x2', '\x2', '\x2', '\x27E', '\xF44', 
		'\x3', '\x2', '\x2', '\x2', '\x280', '\xF4B', '\x3', '\x2', '\x2', '\x2', 
		'\x282', '\xF51', '\x3', '\x2', '\x2', '\x2', '\x284', '\xF5C', '\x3', 
		'\x2', '\x2', '\x2', '\x286', '\xF64', '\x3', '\x2', '\x2', '\x2', '\x288', 
		'\xF68', '\x3', '\x2', '\x2', '\x2', '\x28A', '\xF6E', '\x3', '\x2', '\x2', 
		'\x2', '\x28C', '\xF76', '\x3', '\x2', '\x2', '\x2', '\x28E', '\xF81', 
		'\x3', '\x2', '\x2', '\x2', '\x290', '\xF89', '\x3', '\x2', '\x2', '\x2', 
		'\x292', '\xF8C', '\x3', '\x2', '\x2', '\x2', '\x294', '\xF97', '\x3', 
		'\x2', '\x2', '\x2', '\x296', '\xFA2', '\x3', '\x2', '\x2', '\x2', '\x298', 
		'\xFB6', '\x3', '\x2', '\x2', '\x2', '\x29A', '\xFB8', '\x3', '\x2', '\x2', 
		'\x2', '\x29C', '\xFC3', '\x3', '\x2', '\x2', '\x2', '\x29E', '\xFD6', 
		'\x3', '\x2', '\x2', '\x2', '\x2A0', '\xFDA', '\x3', '\x2', '\x2', '\x2', 
		'\x2A2', '\xFDD', '\x3', '\x2', '\x2', '\x2', '\x2A4', '\xFE2', '\x3', 
		'\x2', '\x2', '\x2', '\x2A6', '\xFE6', '\x3', '\x2', '\x2', '\x2', '\x2A8', 
		'\xFF1', '\x3', '\x2', '\x2', '\x2', '\x2AA', '\xFFB', '\x3', '\x2', '\x2', 
		'\x2', '\x2AC', '\xFFE', '\x3', '\x2', '\x2', '\x2', '\x2AE', '\x1006', 
		'\x3', '\x2', '\x2', '\x2', '\x2B0', '\x1014', '\x3', '\x2', '\x2', '\x2', 
		'\x2B2', '\x1016', '\x3', '\x2', '\x2', '\x2', '\x2B4', '\x1023', '\x3', 
		'\x2', '\x2', '\x2', '\x2B6', '\x102B', '\x3', '\x2', '\x2', '\x2', '\x2B8', 
		'\x106C', '\x3', '\x2', '\x2', '\x2', '\x2BA', '\x106E', '\x3', '\x2', 
		'\x2', '\x2', '\x2BC', '\x107C', '\x3', '\x2', '\x2', '\x2', '\x2BE', 
		'\x1081', '\x3', '\x2', '\x2', '\x2', '\x2C0', '\x108E', '\x3', '\x2', 
		'\x2', '\x2', '\x2C2', '\x1090', '\x3', '\x2', '\x2', '\x2', '\x2C4', 
		'\x10A1', '\x3', '\x2', '\x2', '\x2', '\x2C6', '\x10A3', '\x3', '\x2', 
		'\x2', '\x2', '\x2C8', '\x10A7', '\x3', '\x2', '\x2', '\x2', '\x2CA', 
		'\x10BB', '\x3', '\x2', '\x2', '\x2', '\x2CC', '\x10BF', '\x3', '\x2', 
		'\x2', '\x2', '\x2CE', '\x10C4', '\x3', '\x2', '\x2', '\x2', '\x2D0', 
		'\x10C7', '\x3', '\x2', '\x2', '\x2', '\x2D2', '\x10CD', '\x3', '\x2', 
		'\x2', '\x2', '\x2D4', '\x10D4', '\x3', '\x2', '\x2', '\x2', '\x2D6', 
		'\x10D7', '\x3', '\x2', '\x2', '\x2', '\x2D8', '\x10DD', '\x3', '\x2', 
		'\x2', '\x2', '\x2DA', '\x10FF', '\x3', '\x2', '\x2', '\x2', '\x2DC', 
		'\x110A', '\x3', '\x2', '\x2', '\x2', '\x2DE', '\x110C', '\x3', '\x2', 
		'\x2', '\x2', '\x2E0', '\x1111', '\x3', '\x2', '\x2', '\x2', '\x2E2', 
		'\x1118', '\x3', '\x2', '\x2', '\x2', '\x2E4', '\x111A', '\x3', '\x2', 
		'\x2', '\x2', '\x2E6', '\x111F', '\x3', '\x2', '\x2', '\x2', '\x2E8', 
		'\x112E', '\x3', '\x2', '\x2', '\x2', '\x2EA', '\x1130', '\x3', '\x2', 
		'\x2', '\x2', '\x2EC', '\x1136', '\x3', '\x2', '\x2', '\x2', '\x2EE', 
		'\x113C', '\x3', '\x2', '\x2', '\x2', '\x2F0', '\x114F', '\x3', '\x2', 
		'\x2', '\x2', '\x2F2', '\x1151', '\x3', '\x2', '\x2', '\x2', '\x2F4', 
		'\x1163', '\x3', '\x2', '\x2', '\x2', '\x2F6', '\x117F', '\x3', '\x2', 
		'\x2', '\x2', '\x2F8', '\x1188', '\x3', '\x2', '\x2', '\x2', '\x2FA', 
		'\x1194', '\x3', '\x2', '\x2', '\x2', '\x2FC', '\x1199', '\x3', '\x2', 
		'\x2', '\x2', '\x2FE', '\x119B', '\x3', '\x2', '\x2', '\x2', '\x300', 
		'\x11A0', '\x3', '\x2', '\x2', '\x2', '\x302', '\x11B2', '\x3', '\x2', 
		'\x2', '\x2', '\x304', '\x11B4', '\x3', '\x2', '\x2', '\x2', '\x306', 
		'\x11B7', '\x3', '\x2', '\x2', '\x2', '\x308', '\x11BB', '\x3', '\x2', 
		'\x2', '\x2', '\x30A', '\x11C0', '\x3', '\x2', '\x2', '\x2', '\x30C', 
		'\x11CA', '\x3', '\x2', '\x2', '\x2', '\x30E', '\x11CE', '\x3', '\x2', 
		'\x2', '\x2', '\x310', '\x11EF', '\x3', '\x2', '\x2', '\x2', '\x312', 
		'\x11F2', '\x3', '\x2', '\x2', '\x2', '\x314', '\x11FA', '\x3', '\x2', 
		'\x2', '\x2', '\x316', '\x11FE', '\x3', '\x2', '\x2', '\x2', '\x318', 
		'\x1207', '\x3', '\x2', '\x2', '\x2', '\x31A', '\x1215', '\x3', '\x2', 
		'\x2', '\x2', '\x31C', '\x1217', '\x3', '\x2', '\x2', '\x2', '\x31E', 
		'\x121A', '\x3', '\x2', '\x2', '\x2', '\x320', '\x1225', '\x3', '\x2', 
		'\x2', '\x2', '\x322', '\x122D', '\x3', '\x2', '\x2', '\x2', '\x324', 
		'\x1235', '\x3', '\x2', '\x2', '\x2', '\x326', '\x1239', '\x3', '\x2', 
		'\x2', '\x2', '\x328', '\x123B', '\x3', '\x2', '\x2', '\x2', '\x32A', 
		'\x1241', '\x3', '\x2', '\x2', '\x2', '\x32C', '\x1245', '\x3', '\x2', 
		'\x2', '\x2', '\x32E', '\x124B', '\x3', '\x2', '\x2', '\x2', '\x330', 
		'\x125A', '\x3', '\x2', '\x2', '\x2', '\x332', '\x125E', '\x3', '\x2', 
		'\x2', '\x2', '\x334', '\x1268', '\x3', '\x2', '\x2', '\x2', '\x336', 
		'\x126D', '\x3', '\x2', '\x2', '\x2', '\x338', '\x1276', '\x3', '\x2', 
		'\x2', '\x2', '\x33A', '\x127E', '\x3', '\x2', '\x2', '\x2', '\x33C', 
		'\x128A', '\x3', '\x2', '\x2', '\x2', '\x33E', '\x1295', '\x3', '\x2', 
		'\x2', '\x2', '\x340', '\x12A1', '\x3', '\x2', '\x2', '\x2', '\x342', 
		'\x12A7', '\x3', '\x2', '\x2', '\x2', '\x344', '\x12B5', '\x3', '\x2', 
		'\x2', '\x2', '\x346', '\x12B8', '\x3', '\x2', '\x2', '\x2', '\x348', 
		'\x12BE', '\x3', '\x2', '\x2', '\x2', '\x34A', '\x12C1', '\x3', '\x2', 
		'\x2', '\x2', '\x34C', '\x12C4', '\x3', '\x2', '\x2', '\x2', '\x34E', 
		'\x12CD', '\x3', '\x2', '\x2', '\x2', '\x350', '\x12D0', '\x3', '\x2', 
		'\x2', '\x2', '\x352', '\x12D7', '\x3', '\x2', '\x2', '\x2', '\x354', 
		'\x12DC', '\x3', '\x2', '\x2', '\x2', '\x356', '\x12E0', '\x3', '\x2', 
		'\x2', '\x2', '\x358', '\x12E2', '\x3', '\x2', '\x2', '\x2', '\x35A', 
		'\x12EA', '\x3', '\x2', '\x2', '\x2', '\x35C', '\x12F7', '\x3', '\x2', 
		'\x2', '\x2', '\x35E', '\x12F9', '\x3', '\x2', '\x2', '\x2', '\x360', 
		'\x1300', '\x3', '\x2', '\x2', '\x2', '\x362', '\x130D', '\x3', '\x2', 
		'\x2', '\x2', '\x364', '\x130F', '\x3', '\x2', '\x2', '\x2', '\x366', 
		'\x1316', '\x3', '\x2', '\x2', '\x2', '\x368', '\x1321', '\x3', '\x2', 
		'\x2', '\x2', '\x36A', '\x1333', '\x3', '\x2', '\x2', '\x2', '\x36C', 
		'\x1346', '\x3', '\x2', '\x2', '\x2', '\x36E', '\x134B', '\x3', '\x2', 
		'\x2', '\x2', '\x370', '\x134F', '\x3', '\x2', '\x2', '\x2', '\x372', 
		'\x1352', '\x3', '\x2', '\x2', '\x2', '\x374', '\x1354', '\x3', '\x2', 
		'\x2', '\x2', '\x376', '\x1356', '\x3', '\x2', '\x2', '\x2', '\x378', 
		'\x1362', '\x3', '\x2', '\x2', '\x2', '\x37A', '\x1368', '\x3', '\x2', 
		'\x2', '\x2', '\x37C', '\x136D', '\x3', '\x2', '\x2', '\x2', '\x37E', 
		'\x136F', '\x3', '\x2', '\x2', '\x2', '\x380', '\x1371', '\x3', '\x2', 
		'\x2', '\x2', '\x382', '\x1379', '\x3', '\x2', '\x2', '\x2', '\x384', 
		'\x137B', '\x3', '\x2', '\x2', '\x2', '\x386', '\x1390', '\x3', '\x2', 
		'\x2', '\x2', '\x388', '\x1392', '\x3', '\x2', '\x2', '\x2', '\x38A', 
		'\x1397', '\x3', '\x2', '\x2', '\x2', '\x38C', '\x1399', '\x3', '\x2', 
		'\x2', '\x2', '\x38E', '\x139C', '\x3', '\x2', '\x2', '\x2', '\x390', 
		'\x13A3', '\x3', '\x2', '\x2', '\x2', '\x392', '\x13A6', '\x3', '\x2', 
		'\x2', '\x2', '\x394', '\x13AB', '\x3', '\x2', '\x2', '\x2', '\x396', 
		'\x13AE', '\x3', '\x2', '\x2', '\x2', '\x398', '\x13B1', '\x3', '\x2', 
		'\x2', '\x2', '\x39A', '\x13B5', '\x3', '\x2', '\x2', '\x2', '\x39C', 
		'\x13B8', '\x3', '\x2', '\x2', '\x2', '\x39E', '\x13BB', '\x3', '\x2', 
		'\x2', '\x2', '\x3A0', '\x13BE', '\x3', '\x2', '\x2', '\x2', '\x3A2', 
		'\x13C1', '\x3', '\x2', '\x2', '\x2', '\x3A4', '\x13C3', '\x3', '\x2', 
		'\x2', '\x2', '\x3A6', '\x13C7', '\x3', '\x2', '\x2', '\x2', '\x3A8', 
		'\x13C9', '\x3', '\x2', '\x2', '\x2', '\x3AA', '\x13CD', '\x3', '\x2', 
		'\x2', '\x2', '\x3AC', '\x13D1', '\x3', '\x2', '\x2', '\x2', '\x3AE', 
		'\x13D5', '\x3', '\x2', '\x2', '\x2', '\x3B0', '\x13DA', '\x3', '\x2', 
		'\x2', '\x2', '\x3B2', '\x13DD', '\x3', '\x2', '\x2', '\x2', '\x3B4', 
		'\x13E3', '\x3', '\x2', '\x2', '\x2', '\x3B6', '\x13EC', '\x3', '\x2', 
		'\x2', '\x2', '\x3B8', '\x13F1', '\x3', '\x2', '\x2', '\x2', '\x3BA', 
		'\x13F8', '\x3', '\x2', '\x2', '\x2', '\x3BC', '\x1400', '\x3', '\x2', 
		'\x2', '\x2', '\x3BE', '\x1409', '\x3', '\x2', '\x2', '\x2', '\x3C0', 
		'\x140F', '\x3', '\x2', '\x2', '\x2', '\x3C2', '\x1416', '\x3', '\x2', 
		'\x2', '\x2', '\x3C4', '\x1420', '\x3', '\x2', '\x2', '\x2', '\x3C6', 
		'\x142C', '\x3', '\x2', '\x2', '\x2', '\x3C8', '\x143C', '\x3', '\x2', 
		'\x2', '\x2', '\x3CA', '\x143E', '\x3', '\x2', '\x2', '\x2', '\x3CC', 
		'\x1443', '\x3', '\x2', '\x2', '\x2', '\x3CE', '\x1447', '\x3', '\x2', 
		'\x2', '\x2', '\x3D0', '\x144D', '\x3', '\x2', '\x2', '\x2', '\x3D2', 
		'\x1451', '\x3', '\x2', '\x2', '\x2', '\x3D4', '\x1454', '\x3', '\x2', 
		'\x2', '\x2', '\x3D6', '\x1457', '\x3', '\x2', '\x2', '\x2', '\x3D8', 
		'\x145F', '\x3', '\x2', '\x2', '\x2', '\x3DA', '\x1477', '\x3', '\x2', 
		'\x2', '\x2', '\x3DC', '\x1479', '\x3', '\x2', '\x2', '\x2', '\x3DE', 
		'\x1480', '\x3', '\x2', '\x2', '\x2', '\x3E0', '\x1482', '\x3', '\x2', 
		'\x2', '\x2', '\x3E2', '\x148A', '\x3', '\x2', '\x2', '\x2', '\x3E4', 
		'\x1492', '\x3', '\x2', '\x2', '\x2', '\x3E6', '\x1496', '\x3', '\x2', 
		'\x2', '\x2', '\x3E8', '\x1499', '\x3', '\x2', '\x2', '\x2', '\x3EA', 
		'\x14A0', '\x3', '\x2', '\x2', '\x2', '\x3EC', '\x14A5', '\x3', '\x2', 
		'\x2', '\x2', '\x3EE', '\x14AB', '\x3', '\x2', '\x2', '\x2', '\x3F0', 
		'\x14B1', '\x3', '\x2', '\x2', '\x2', '\x3F2', '\x14B5', '\x3', '\x2', 
		'\x2', '\x2', '\x3F4', '\x14BB', '\x3', '\x2', '\x2', '\x2', '\x3F6', 
		'\x14C1', '\x3', '\x2', '\x2', '\x2', '\x3F8', '\x14DE', '\x3', '\x2', 
		'\x2', '\x2', '\x3FA', '\x14E5', '\x3', '\x2', '\x2', '\x2', '\x3FC', 
		'\x14E7', '\x3', '\x2', '\x2', '\x2', '\x3FE', '\x14EA', '\x3', '\x2', 
		'\x2', '\x2', '\x400', '\x14ED', '\x3', '\x2', '\x2', '\x2', '\x402', 
		'\x14F4', '\x3', '\x2', '\x2', '\x2', '\x404', '\x14FB', '\x3', '\x2', 
		'\x2', '\x2', '\x406', '\x1502', '\x3', '\x2', '\x2', '\x2', '\x408', 
		'\x150A', '\x3', '\x2', '\x2', '\x2', '\x40A', '\x1511', '\x3', '\x2', 
		'\x2', '\x2', '\x40C', '\x1513', '\x3', '\x2', '\x2', '\x2', '\x40E', 
		'\x1516', '\x3', '\x2', '\x2', '\x2', '\x410', '\x1521', '\x3', '\x2', 
		'\x2', '\x2', '\x412', '\x1526', '\x3', '\x2', '\x2', '\x2', '\x414', 
		'\x1528', '\x3', '\x2', '\x2', '\x2', '\x416', '\x152B', '\x3', '\x2', 
		'\x2', '\x2', '\x418', '\x1534', '\x3', '\x2', '\x2', '\x2', '\x41A', 
		'\x153F', '\x3', '\x2', '\x2', '\x2', '\x41C', '\x1543', '\x3', '\x2', 
		'\x2', '\x2', '\x41E', '\x154A', '\x3', '\x2', '\x2', '\x2', '\x420', 
		'\x154D', '\x3', '\x2', '\x2', '\x2', '\x422', '\x1553', '\x3', '\x2', 
		'\x2', '\x2', '\x424', '\x1556', '\x3', '\x2', '\x2', '\x2', '\x426', 
		'\x1559', '\x3', '\x2', '\x2', '\x2', '\x428', '\x1579', '\x3', '\x2', 
		'\x2', '\x2', '\x42A', '\x157B', '\x3', '\x2', '\x2', '\x2', '\x42C', 
		'\x157E', '\x3', '\x2', '\x2', '\x2', '\x42E', '\x1581', '\x3', '\x2', 
		'\x2', '\x2', '\x430', '\x1585', '\x3', '\x2', '\x2', '\x2', '\x432', 
		'\x1587', '\x3', '\x2', '\x2', '\x2', '\x434', '\x1591', '\x3', '\x2', 
		'\x2', '\x2', '\x436', '\x1593', '\x3', '\x2', '\x2', '\x2', '\x438', 
		'\x15A2', '\x3', '\x2', '\x2', '\x2', '\x43A', '\x15A4', '\x3', '\x2', 
		'\x2', '\x2', '\x43C', '\x15A7', '\x3', '\x2', '\x2', '\x2', '\x43E', 
		'\x15AD', '\x3', '\x2', '\x2', '\x2', '\x440', '\x15B8', '\x3', '\x2', 
		'\x2', '\x2', '\x442', '\x15BC', '\x3', '\x2', '\x2', '\x2', '\x444', 
		'\x15BE', '\x3', '\x2', '\x2', '\x2', '\x446', '\x15C9', '\x3', '\x2', 
		'\x2', '\x2', '\x448', '\x15CE', '\x3', '\x2', '\x2', '\x2', '\x44A', 
		'\x15D8', '\x3', '\x2', '\x2', '\x2', '\x44C', '\x15DA', '\x3', '\x2', 
		'\x2', '\x2', '\x44E', '\x15E5', '\x3', '\x2', '\x2', '\x2', '\x450', 
		'\x15EC', '\x3', '\x2', '\x2', '\x2', '\x452', '\x15F0', '\x3', '\x2', 
		'\x2', '\x2', '\x454', '\x15F3', '\x3', '\x2', '\x2', '\x2', '\x456', 
		'\x15FC', '\x3', '\x2', '\x2', '\x2', '\x458', '\x1600', '\x3', '\x2', 
		'\x2', '\x2', '\x45A', '\x161A', '\x3', '\x2', '\x2', '\x2', '\x45C', 
		'\x161E', '\x3', '\x2', '\x2', '\x2', '\x45E', '\x1622', '\x3', '\x2', 
		'\x2', '\x2', '\x460', '\x1626', '\x3', '\x2', '\x2', '\x2', '\x462', 
		'\x1629', '\x3', '\x2', '\x2', '\x2', '\x464', '\x1635', '\x3', '\x2', 
		'\x2', '\x2', '\x466', '\x163B', '\x3', '\x2', '\x2', '\x2', '\x468', 
		'\x1650', '\x3', '\x2', '\x2', '\x2', '\x46A', '\x165C', '\x3', '\x2', 
		'\x2', '\x2', '\x46C', '\x1670', '\x3', '\x2', '\x2', '\x2', '\x46E', 
		'\x1673', '\x3', '\x2', '\x2', '\x2', '\x470', '\x1678', '\x3', '\x2', 
		'\x2', '\x2', '\x472', '\x167A', '\x3', '\x2', '\x2', '\x2', '\x474', 
		'\x168B', '\x3', '\x2', '\x2', '\x2', '\x476', '\x168D', '\x3', '\x2', 
		'\x2', '\x2', '\x478', '\x169C', '\x3', '\x2', '\x2', '\x2', '\x47A', 
		'\x169F', '\x3', '\x2', '\x2', '\x2', '\x47C', '\x16A2', '\x3', '\x2', 
		'\x2', '\x2', '\x47E', '\x16BD', '\x3', '\x2', '\x2', '\x2', '\x480', 
		'\x16C4', '\x3', '\x2', '\x2', '\x2', '\x482', '\x16CD', '\x3', '\x2', 
		'\x2', '\x2', '\x484', '\x16D1', '\x3', '\x2', '\x2', '\x2', '\x486', 
		'\x16E2', '\x3', '\x2', '\x2', '\x2', '\x488', '\x16E9', '\x3', '\x2', 
		'\x2', '\x2', '\x48A', '\x16ED', '\x3', '\x2', '\x2', '\x2', '\x48C', 
		'\x16F4', '\x3', '\x2', '\x2', '\x2', '\x48E', '\x1700', '\x3', '\x2', 
		'\x2', '\x2', '\x490', '\x1702', '\x3', '\x2', '\x2', '\x2', '\x492', 
		'\x170D', '\x3', '\x2', '\x2', '\x2', '\x494', '\x1719', '\x3', '\x2', 
		'\x2', '\x2', '\x496', '\x1726', '\x3', '\x2', '\x2', '\x2', '\x498', 
		'\x172D', '\x3', '\x2', '\x2', '\x2', '\x49A', '\x173D', '\x3', '\x2', 
		'\x2', '\x2', '\x49C', '\x173F', '\x3', '\x2', '\x2', '\x2', '\x49E', 
		'\x1745', '\x3', '\x2', '\x2', '\x2', '\x4A0', '\x174B', '\x3', '\x2', 
		'\x2', '\x2', '\x4A2', '\x1750', '\x3', '\x2', '\x2', '\x2', '\x4A4', 
		'\x1752', '\x3', '\x2', '\x2', '\x2', '\x4A6', '\x1756', '\x3', '\x2', 
		'\x2', '\x2', '\x4A8', '\x175B', '\x3', '\x2', '\x2', '\x2', '\x4AA', 
		'\x176B', '\x3', '\x2', '\x2', '\x2', '\x4AC', '\x176D', '\x3', '\x2', 
		'\x2', '\x2', '\x4AE', '\x1771', '\x3', '\x2', '\x2', '\x2', '\x4B0', 
		'\x1773', '\x3', '\x2', '\x2', '\x2', '\x4B2', '\x1777', '\x3', '\x2', 
		'\x2', '\x2', '\x4B4', '\x1780', '\x3', '\x2', '\x2', '\x2', '\x4B6', 
		'\x1786', '\x3', '\x2', '\x2', '\x2', '\x4B8', '\x1789', '\x3', '\x2', 
		'\x2', '\x2', '\x4BA', '\x1794', '\x3', '\x2', '\x2', '\x2', '\x4BC', 
		'\x1798', '\x3', '\x2', '\x2', '\x2', '\x4BE', '\x179D', '\x3', '\x2', 
		'\x2', '\x2', '\x4C0', '\x179F', '\x3', '\x2', '\x2', '\x2', '\x4C2', 
		'\x17AC', '\x3', '\x2', '\x2', '\x2', '\x4C4', '\x17AE', '\x3', '\x2', 
		'\x2', '\x2', '\x4C6', '\x17B6', '\x3', '\x2', '\x2', '\x2', '\x4C8', 
		'\x17C0', '\x3', '\x2', '\x2', '\x2', '\x4CA', '\x17C7', '\x3', '\x2', 
		'\x2', '\x2', '\x4CC', '\x17C9', '\x3', '\x2', '\x2', '\x2', '\x4CE', 
		'\x17D1', '\x3', '\x2', '\x2', '\x2', '\x4D0', '\x17D4', '\x3', '\x2', 
		'\x2', '\x2', '\x4D2', '\x17D9', '\x3', '\x2', '\x2', '\x2', '\x4D4', 
		'\x17DD', '\x3', '\x2', '\x2', '\x2', '\x4D6', '\x17DF', '\x3', '\x2', 
		'\x2', '\x2', '\x4D8', '\x17E3', '\x3', '\x2', '\x2', '\x2', '\x4DA', 
		'\x17EB', '\x3', '\x2', '\x2', '\x2', '\x4DC', '\x17ED', '\x3', '\x2', 
		'\x2', '\x2', '\x4DE', '\x17F3', '\x3', '\x2', '\x2', '\x2', '\x4E0', 
		'\x1802', '\x3', '\x2', '\x2', '\x2', '\x4E2', '\x180A', '\x3', '\x2', 
		'\x2', '\x2', '\x4E4', '\x1816', '\x3', '\x2', '\x2', '\x2', '\x4E6', 
		'\x1822', '\x3', '\x2', '\x2', '\x2', '\x4E8', '\x1826', '\x3', '\x2', 
		'\x2', '\x2', '\x4EA', '\x182C', '\x3', '\x2', '\x2', '\x2', '\x4EC', 
		'\x1832', '\x3', '\x2', '\x2', '\x2', '\x4EE', '\x183E', '\x3', '\x2', 
		'\x2', '\x2', '\x4F0', '\x1856', '\x3', '\x2', '\x2', '\x2', '\x4F2', 
		'\x1858', '\x3', '\x2', '\x2', '\x2', '\x4F4', '\x185C', '\x3', '\x2', 
		'\x2', '\x2', '\x4F6', '\x186B', '\x3', '\x2', '\x2', '\x2', '\x4F8', 
		'\x187C', '\x3', '\x2', '\x2', '\x2', '\x4FA', '\x187F', '\x3', '\x2', 
		'\x2', '\x2', '\x4FC', '\x1888', '\x3', '\x2', '\x2', '\x2', '\x4FE', 
		'\x188B', '\x3', '\x2', '\x2', '\x2', '\x500', '\x1890', '\x3', '\x2', 
		'\x2', '\x2', '\x502', '\x1893', '\x3', '\x2', '\x2', '\x2', '\x504', 
		'\x1898', '\x3', '\x2', '\x2', '\x2', '\x506', '\x18A0', '\x3', '\x2', 
		'\x2', '\x2', '\x508', '\x18AD', '\x3', '\x2', '\x2', '\x2', '\x50A', 
		'\x18B1', '\x3', '\x2', '\x2', '\x2', '\x50C', '\x18BD', '\x3', '\x2', 
		'\x2', '\x2', '\x50E', '\x18C0', '\x3', '\x2', '\x2', '\x2', '\x510', 
		'\x18C7', '\x3', '\x2', '\x2', '\x2', '\x512', '\x18CD', '\x3', '\x2', 
		'\x2', '\x2', '\x514', '\x18DA', '\x3', '\x2', '\x2', '\x2', '\x516', 
		'\x18DD', '\x3', '\x2', '\x2', '\x2', '\x518', '\x18E1', '\x3', '\x2', 
		'\x2', '\x2', '\x51A', '\x18E8', '\x3', '\x2', '\x2', '\x2', '\x51C', 
		'\x18ED', '\x3', '\x2', '\x2', '\x2', '\x51E', '\x18F4', '\x3', '\x2', 
		'\x2', '\x2', '\x520', '\x18FA', '\x3', '\x2', '\x2', '\x2', '\x522', 
		'\x18FD', '\x3', '\x2', '\x2', '\x2', '\x524', '\x1901', '\x3', '\x2', 
		'\x2', '\x2', '\x526', '\x190C', '\x3', '\x2', '\x2', '\x2', '\x528', 
		'\x190F', '\x3', '\x2', '\x2', '\x2', '\x52A', '\x1913', '\x3', '\x2', 
		'\x2', '\x2', '\x52C', '\x1919', '\x3', '\x2', '\x2', '\x2', '\x52E', 
		'\x192C', '\x3', '\x2', '\x2', '\x2', '\x530', '\x192E', '\x3', '\x2', 
		'\x2', '\x2', '\x532', '\x1931', '\x3', '\x2', '\x2', '\x2', '\x534', 
		'\x1936', '\x3', '\x2', '\x2', '\x2', '\x536', '\x1941', '\x3', '\x2', 
		'\x2', '\x2', '\x538', '\x1944', '\x3', '\x2', '\x2', '\x2', '\x53A', 
		'\x1950', '\x3', '\x2', '\x2', '\x2', '\x53C', '\x195D', '\x3', '\x2', 
		'\x2', '\x2', '\x53E', '\x1960', '\x3', '\x2', '\x2', '\x2', '\x540', 
		'\x1966', '\x3', '\x2', '\x2', '\x2', '\x542', '\x196A', '\x3', '\x2', 
		'\x2', '\x2', '\x544', '\x1973', '\x3', '\x2', '\x2', '\x2', '\x546', 
		'\x1978', '\x3', '\x2', '\x2', '\x2', '\x548', '\x197A', '\x3', '\x2', 
		'\x2', '\x2', '\x54A', '\x1980', '\x3', '\x2', '\x2', '\x2', '\x54C', 
		'\x1983', '\x3', '\x2', '\x2', '\x2', '\x54E', '\x198A', '\x3', '\x2', 
		'\x2', '\x2', '\x550', '\x1992', '\x3', '\x2', '\x2', '\x2', '\x552', 
		'\x19A0', '\x3', '\x2', '\x2', '\x2', '\x554', '\x19A2', '\x3', '\x2', 
		'\x2', '\x2', '\x556', '\x19B5', '\x3', '\x2', '\x2', '\x2', '\x558', 
		'\x19BD', '\x3', '\x2', '\x2', '\x2', '\x55A', '\x19BF', '\x3', '\x2', 
		'\x2', '\x2', '\x55C', '\x19CC', '\x3', '\x2', '\x2', '\x2', '\x55E', 
		'\x19D2', '\x3', '\x2', '\x2', '\x2', '\x560', '\x19D8', '\x3', '\x2', 
		'\x2', '\x2', '\x562', '\x19DE', '\x3', '\x2', '\x2', '\x2', '\x564', 
		'\x19E2', '\x3', '\x2', '\x2', '\x2', '\x566', '\x19E6', '\x3', '\x2', 
		'\x2', '\x2', '\x568', '\x19E9', '\x3', '\x2', '\x2', '\x2', '\x56A', 
		'\x19F8', '\x3', '\x2', '\x2', '\x2', '\x56C', '\x19FB', '\x3', '\x2', 
		'\x2', '\x2', '\x56E', '\x19FE', '\x3', '\x2', '\x2', '\x2', '\x570', 
		'\x1A02', '\x3', '\x2', '\x2', '\x2', '\x572', '\x1A10', '\x3', '\x2', 
		'\x2', '\x2', '\x574', '\x1A18', '\x3', '\x2', '\x2', '\x2', '\x576', 
		'\x1A20', '\x3', '\x2', '\x2', '\x2', '\x578', '\x1A24', '\x3', '\x2', 
		'\x2', '\x2', '\x57A', '\x1A28', '\x3', '\x2', '\x2', '\x2', '\x57C', 
		'\x1A2A', '\x3', '\x2', '\x2', '\x2', '\x57E', '\x1A2E', '\x3', '\x2', 
		'\x2', '\x2', '\x580', '\x1A32', '\x3', '\x2', '\x2', '\x2', '\x582', 
		'\x1A38', '\x3', '\x2', '\x2', '\x2', '\x584', '\x1A3D', '\x3', '\x2', 
		'\x2', '\x2', '\x586', '\x1A46', '\x3', '\x2', '\x2', '\x2', '\x588', 
		'\x1A4A', '\x3', '\x2', '\x2', '\x2', '\x58A', '\x1A55', '\x3', '\x2', 
		'\x2', '\x2', '\x58C', '\x1A5F', '\x3', '\x2', '\x2', '\x2', '\x58E', 
		'\x1A66', '\x3', '\x2', '\x2', '\x2', '\x590', '\x1A6B', '\x3', '\x2', 
		'\x2', '\x2', '\x592', '\x1A6F', '\x3', '\x2', '\x2', '\x2', '\x594', 
		'\x1A76', '\x3', '\x2', '\x2', '\x2', '\x596', '\x1A7B', '\x3', '\x2', 
		'\x2', '\x2', '\x598', '\x1A81', '\x3', '\x2', '\x2', '\x2', '\x59A', 
		'\x1A85', '\x3', '\x2', '\x2', '\x2', '\x59C', '\x1A8D', '\x3', '\x2', 
		'\x2', '\x2', '\x59E', '\x1A90', '\x3', '\x2', '\x2', '\x2', '\x5A0', 
		'\x1A92', '\x3', '\x2', '\x2', '\x2', '\x5A2', '\x1A98', '\x3', '\x2', 
		'\x2', '\x2', '\x5A4', '\x1A9A', '\x3', '\x2', '\x2', '\x2', '\x5A6', 
		'\x1A9E', '\x3', '\x2', '\x2', '\x2', '\x5A8', '\x1AA0', '\x3', '\x2', 
		'\x2', '\x2', '\x5AA', '\x1AA9', '\x3', '\x2', '\x2', '\x2', '\x5AC', 
		'\x1AAB', '\x3', '\x2', '\x2', '\x2', '\x5AE', '\x1ABA', '\x3', '\x2', 
		'\x2', '\x2', '\x5B0', '\x1AC9', '\x3', '\x2', '\x2', '\x2', '\x5B2', 
		'\x1ACB', '\x3', '\x2', '\x2', '\x2', '\x5B4', '\x1ACE', '\x3', '\x2', 
		'\x2', '\x2', '\x5B6', '\x1AD0', '\x3', '\x2', '\x2', '\x2', '\x5B8', 
		'\x1AD3', '\x3', '\x2', '\x2', '\x2', '\x5BA', '\x1AD6', '\x3', '\x2', 
		'\x2', '\x2', '\x5BC', '\x1AD9', '\x3', '\x2', '\x2', '\x2', '\x5BE', 
		'\x1AEA', '\x3', '\x2', '\x2', '\x2', '\x5C0', '\x1AEC', '\x3', '\x2', 
		'\x2', '\x2', '\x5C2', '\x1AEE', '\x3', '\x2', '\x2', '\x2', '\x5C4', 
		'\x1AFA', '\x3', '\x2', '\x2', '\x2', '\x5C6', '\x1B06', '\x3', '\x2', 
		'\x2', '\x2', '\x5C8', '\x1B12', '\x3', '\x2', '\x2', '\x2', '\x5CA', 
		'\x1B21', '\x3', '\x2', '\x2', '\x2', '\x5CC', '\x1B26', '\x3', '\x2', 
		'\x2', '\x2', '\x5CE', '\x1B2A', '\x3', '\x2', '\x2', '\x2', '\x5D0', 
		'\x1B30', '\x3', '\x2', '\x2', '\x2', '\x5D2', '\x1B35', '\x3', '\x2', 
		'\x2', '\x2', '\x5D4', '\x1B3C', '\x3', '\x2', '\x2', '\x2', '\x5D6', 
		'\x1B41', '\x3', '\x2', '\x2', '\x2', '\x5D8', '\x1B49', '\x3', '\x2', 
		'\x2', '\x2', '\x5DA', '\x1B53', '\x3', '\x2', '\x2', '\x2', '\x5DC', 
		'\x1B56', '\x3', '\x2', '\x2', '\x2', '\x5DE', '\x1B59', '\x3', '\x2', 
		'\x2', '\x2', '\x5E0', '\x1B65', '\x3', '\x2', '\x2', '\x2', '\x5E2', 
		'\x1B6C', '\x3', '\x2', '\x2', '\x2', '\x5E4', '\x1B6E', '\x3', '\x2', 
		'\x2', '\x2', '\x5E6', '\x1B70', '\x3', '\x2', '\x2', '\x2', '\x5E8', 
		'\x1B77', '\x3', '\x2', '\x2', '\x2', '\x5EA', '\x1B7E', '\x3', '\x2', 
		'\x2', '\x2', '\x5EC', '\x1B85', '\x3', '\x2', '\x2', '\x2', '\x5EE', 
		'\x1B8C', '\x3', '\x2', '\x2', '\x2', '\x5F0', '\x1B93', '\x3', '\x2', 
		'\x2', '\x2', '\x5F2', '\x1B9A', '\x3', '\x2', '\x2', '\x2', '\x5F4', 
		'\x1BA9', '\x3', '\x2', '\x2', '\x2', '\x5F6', '\x1BAB', '\x3', '\x2', 
		'\x2', '\x2', '\x5F8', '\x1BB2', '\x3', '\x2', '\x2', '\x2', '\x5FA', 
		'\x1BB7', '\x3', '\x2', '\x2', '\x2', '\x5FC', '\x1BB9', '\x3', '\x2', 
		'\x2', '\x2', '\x5FE', '\x1BBD', '\x3', '\x2', '\x2', '\x2', '\x600', 
		'\x1BC0', '\x3', '\x2', '\x2', '\x2', '\x602', '\x1BC5', '\x3', '\x2', 
		'\x2', '\x2', '\x604', '\x1BCC', '\x3', '\x2', '\x2', '\x2', '\x606', 
		'\x1BDF', '\x3', '\x2', '\x2', '\x2', '\x608', '\x1BE1', '\x3', '\x2', 
		'\x2', '\x2', '\x60A', '\x1BE9', '\x3', '\x2', '\x2', '\x2', '\x60C', 
		'\x1BED', '\x3', '\x2', '\x2', '\x2', '\x60E', '\x1BF8', '\x3', '\x2', 
		'\x2', '\x2', '\x610', '\x1C12', '\x3', '\x2', '\x2', '\x2', '\x612', 
		'\x1C15', '\x3', '\x2', '\x2', '\x2', '\x614', '\x1C1A', '\x3', '\x2', 
		'\x2', '\x2', '\x616', '\x1C1D', '\x3', '\x2', '\x2', '\x2', '\x618', 
		'\x1C22', '\x3', '\x2', '\x2', '\x2', '\x61A', '\x1C30', '\x3', '\x2', 
		'\x2', '\x2', '\x61C', '\x1C32', '\x3', '\x2', '\x2', '\x2', '\x61E', 
		'\x1C43', '\x3', '\x2', '\x2', '\x2', '\x620', '\x1C45', '\x3', '\x2', 
		'\x2', '\x2', '\x622', '\x1C5D', '\x3', '\x2', '\x2', '\x2', '\x624', 
		'\x1C64', '\x3', '\x2', '\x2', '\x2', '\x626', '\x1C66', '\x3', '\x2', 
		'\x2', '\x2', '\x628', '\x1C71', '\x3', '\x2', '\x2', '\x2', '\x62A', 
		'\x1C73', '\x3', '\x2', '\x2', '\x2', '\x62C', '\x1C83', '\x3', '\x2', 
		'\x2', '\x2', '\x62E', '\x1C85', '\x3', '\x2', '\x2', '\x2', '\x630', 
		'\x1C90', '\x3', '\x2', '\x2', '\x2', '\x632', '\x1C95', '\x3', '\x2', 
		'\x2', '\x2', '\x634', '\x1CA8', '\x3', '\x2', '\x2', '\x2', '\x636', 
		'\x1CAB', '\x3', '\x2', '\x2', '\x2', '\x638', '\x1CB1', '\x3', '\x2', 
		'\x2', '\x2', '\x63A', '\x1CB5', '\x3', '\x2', '\x2', '\x2', '\x63C', 
		'\x1CBF', '\x3', '\x2', '\x2', '\x2', '\x63E', '\x1CC2', '\x3', '\x2', 
		'\x2', '\x2', '\x640', '\x1CC9', '\x3', '\x2', '\x2', '\x2', '\x642', 
		'\x1CD4', '\x3', '\x2', '\x2', '\x2', '\x644', '\x1CDC', '\x3', '\x2', 
		'\x2', '\x2', '\x646', '\x1CEA', '\x3', '\x2', '\x2', '\x2', '\x648', 
		'\x1CEE', '\x3', '\x2', '\x2', '\x2', '\x64A', '\x1CF1', '\x3', '\x2', 
		'\x2', '\x2', '\x64C', '\x1CF9', '\x3', '\x2', '\x2', '\x2', '\x64E', 
		'\x1D00', '\x3', '\x2', '\x2', '\x2', '\x650', '\x1D02', '\x3', '\x2', 
		'\x2', '\x2', '\x652', '\x1D08', '\x3', '\x2', '\x2', '\x2', '\x654', 
		'\x1D0C', '\x3', '\x2', '\x2', '\x2', '\x656', '\x1D17', '\x3', '\x2', 
		'\x2', '\x2', '\x658', '\x1D1C', '\x3', '\x2', '\x2', '\x2', '\x65A', 
		'\x1D26', '\x3', '\x2', '\x2', '\x2', '\x65C', '\x1D28', '\x3', '\x2', 
		'\x2', '\x2', '\x65E', '\x1D2A', '\x3', '\x2', '\x2', '\x2', '\x660', 
		'\x1D33', '\x3', '\x2', '\x2', '\x2', '\x662', '\x1D36', '\x3', '\x2', 
		'\x2', '\x2', '\x664', '\x1D3C', '\x3', '\x2', '\x2', '\x2', '\x666', 
		'\x1D41', '\x3', '\x2', '\x2', '\x2', '\x668', '\x1D45', '\x3', '\x2', 
		'\x2', '\x2', '\x66A', '\x1D57', '\x3', '\x2', '\x2', '\x2', '\x66C', 
		'\x1D62', '\x3', '\x2', '\x2', '\x2', '\x66E', '\x1D64', '\x3', '\x2', 
		'\x2', '\x2', '\x670', '\x1D6B', '\x3', '\x2', '\x2', '\x2', '\x672', 
		'\x1D7B', '\x3', '\x2', '\x2', '\x2', '\x674', '\x1D83', '\x3', '\x2', 
		'\x2', '\x2', '\x676', '\x1D85', '\x3', '\x2', '\x2', '\x2', '\x678', 
		'\x1D8D', '\x3', '\x2', '\x2', '\x2', '\x67A', '\x1D8F', '\x3', '\x2', 
		'\x2', '\x2', '\x67C', '\x1D96', '\x3', '\x2', '\x2', '\x2', '\x67E', 
		'\x1D98', '\x3', '\x2', '\x2', '\x2', '\x680', '\x1D9F', '\x3', '\x2', 
		'\x2', '\x2', '\x682', '\x1DA1', '\x3', '\x2', '\x2', '\x2', '\x684', 
		'\x1DA3', '\x3', '\x2', '\x2', '\x2', '\x686', '\x1DB1', '\x3', '\x2', 
		'\x2', '\x2', '\x688', '\x1DB7', '\x3', '\x2', '\x2', '\x2', '\x68A', 
		'\x1DBA', '\x3', '\x2', '\x2', '\x2', '\x68C', '\x1DC9', '\x3', '\x2', 
		'\x2', '\x2', '\x68E', '\x1DCC', '\x3', '\x2', '\x2', '\x2', '\x690', 
		'\x1DCE', '\x3', '\x2', '\x2', '\x2', '\x692', '\x1DDB', '\x3', '\x2', 
		'\x2', '\x2', '\x694', '\x1DDD', '\x3', '\x2', '\x2', '\x2', '\x696', 
		'\x1DE0', '\x3', '\x2', '\x2', '\x2', '\x698', '\x1DE3', '\x3', '\x2', 
		'\x2', '\x2', '\x69A', '\x1DE6', '\x3', '\x2', '\x2', '\x2', '\x69C', 
		'\x1DE9', '\x3', '\x2', '\x2', '\x2', '\x69E', '\x1DF0', '\x3', '\x2', 
		'\x2', '\x2', '\x6A0', '\x1DFB', '\x3', '\x2', '\x2', '\x2', '\x6A2', 
		'\x1E02', '\x3', '\x2', '\x2', '\x2', '\x6A4', '\x1E07', '\x3', '\x2', 
		'\x2', '\x2', '\x6A6', '\x1E0D', '\x3', '\x2', '\x2', '\x2', '\x6A8', 
		'\x1E13', '\x3', '\x2', '\x2', '\x2', '\x6AA', '\x1E18', '\x3', '\x2', 
		'\x2', '\x2', '\x6AC', '\x1E1D', '\x3', '\x2', '\x2', '\x2', '\x6AE', 
		'\x1E22', '\x3', '\x2', '\x2', '\x2', '\x6B0', '\x1E2C', '\x3', '\x2', 
		'\x2', '\x2', '\x6B2', '\x6B3', '\x5', '\xA0', 'Q', '\x2', '\x6B3', '\x3', 
		'\x3', '\x2', '\x2', '\x2', '\x6B4', '\x6B5', '\x5', '\xA0', 'Q', '\x2', 
		'\x6B5', '\x5', '\x3', '\x2', '\x2', '\x2', '\x6B6', '\x6B7', '\x5', '\xE', 
		'\b', '\x2', '\x6B7', '\a', '\x3', '\x2', '\x2', '\x2', '\x6B8', '\x6BB', 
		'\x5', '\x1C', '\xF', '\x2', '\x6B9', '\x6BB', '\x5', ' ', '\x11', '\x2', 
		'\x6BA', '\x6B8', '\x3', '\x2', '\x2', '\x2', '\x6BA', '\x6B9', '\x3', 
		'\x2', '\x2', '\x2', '\x6BB', '\t', '\x3', '\x2', '\x2', '\x2', '\x6BC', 
		'\x6BD', '\x5', '\x2FA', '\x17E', '\x2', '\x6BD', '\v', '\x3', '\x2', 
		'\x2', '\x2', '\x6BE', '\x6BF', '\x5', '\x166', '\xB4', '\x2', '\x6BF', 
		'\r', '\x3', '\x2', '\x2', '\x2', '\x6C0', '\x6C2', '\x5', '\x10', '\t', 
		'\x2', '\x6C1', '\x6C0', '\x3', '\x2', '\x2', '\x2', '\x6C2', '\x6C5', 
		'\x3', '\x2', '\x2', '\x2', '\x6C3', '\x6C1', '\x3', '\x2', '\x2', '\x2', 
		'\x6C3', '\x6C4', '\x3', '\x2', '\x2', '\x2', '\x6C4', '\xF', '\x3', '\x2', 
		'\x2', '\x2', '\x6C5', '\x6C3', '\x3', '\x2', '\x2', '\x2', '\x6C6', '\x6D0', 
		'\a', '\xBB', '\x2', '\x2', '\x6C7', '\x6D0', '\a', '\xE2', '\x2', '\x2', 
		'\x6C8', '\x6D0', '\a', '\xC9', '\x2', '\x2', '\x6C9', '\x6D0', '\a', 
		'\xD3', '\x2', '\x2', '\x6CA', '\x6D0', '\a', '\x12A', '\x2', '\x2', '\x6CB', 
		'\x6D0', '\a', '\x17B', '\x2', '\x2', '\x6CC', '\x6D0', '\a', '\x36', 
		'\x2', '\x2', '\x6CD', '\x6D0', '\a', '\x146', '\x2', '\x2', '\x6CE', 
		'\x6D0', '\x5', 'N', '(', '\x2', '\x6CF', '\x6C6', '\x3', '\x2', '\x2', 
		'\x2', '\x6CF', '\x6C7', '\x3', '\x2', '\x2', '\x2', '\x6CF', '\x6C8', 
		'\x3', '\x2', '\x2', '\x2', '\x6CF', '\x6C9', '\x3', '\x2', '\x2', '\x2', 
		'\x6CF', '\x6CA', '\x3', '\x2', '\x2', '\x2', '\x6CF', '\x6CB', '\x3', 
		'\x2', '\x2', '\x2', '\x6CF', '\x6CC', '\x3', '\x2', '\x2', '\x2', '\x6CF', 
		'\x6CD', '\x3', '\x2', '\x2', '\x2', '\x6CF', '\x6CE', '\x3', '\x2', '\x2', 
		'\x2', '\x6D0', '\x6D2', '\x3', '\x2', '\x2', '\x2', '\x6D1', '\x6D3', 
		'\x5', '\x12', '\n', '\x2', '\x6D2', '\x6D1', '\x3', '\x2', '\x2', '\x2', 
		'\x6D2', '\x6D3', '\x3', '\x2', '\x2', '\x2', '\x6D3', '\x11', '\x3', 
		'\x2', '\x2', '\x2', '\x6D4', '\x6D6', '\a', '\x24D', '\x2', '\x2', '\x6D5', 
		'\x6D7', '\x5', '\x16', '\f', '\x2', '\x6D6', '\x6D5', '\x3', '\x2', '\x2', 
		'\x2', '\x6D6', '\x6D7', '\x3', '\x2', '\x2', '\x2', '\x6D7', '\x6DD', 
		'\x3', '\x2', '\x2', '\x2', '\x6D8', '\x6DC', '\x5', '&', '\x14', '\x2', 
		'\x6D9', '\x6DC', '\x5', '\x42', '\"', '\x2', '\x6DA', '\x6DC', '\x5', 
		'\x14', '\v', '\x2', '\x6DB', '\x6D8', '\x3', '\x2', '\x2', '\x2', '\x6DB', 
		'\x6D9', '\x3', '\x2', '\x2', '\x2', '\x6DB', '\x6DA', '\x3', '\x2', '\x2', 
		'\x2', '\x6DC', '\x6DF', '\x3', '\x2', '\x2', '\x2', '\x6DD', '\x6DB', 
		'\x3', '\x2', '\x2', '\x2', '\x6DD', '\x6DE', '\x3', '\x2', '\x2', '\x2', 
		'\x6DE', '\x6E0', '\x3', '\x2', '\x2', '\x2', '\x6DF', '\x6DD', '\x3', 
		'\x2', '\x2', '\x2', '\x6E0', '\x6E1', '\a', '\x24E', '\x2', '\x2', '\x6E1', 
		'\x13', '\x3', '\x2', '\x2', '\x2', '\x6E2', '\x6E6', '\a', '\x24D', '\x2', 
		'\x2', '\x6E3', '\x6E5', '\x5', '\x42', '\"', '\x2', '\x6E4', '\x6E3', 
		'\x3', '\x2', '\x2', '\x2', '\x6E5', '\x6E8', '\x3', '\x2', '\x2', '\x2', 
		'\x6E6', '\x6E4', '\x3', '\x2', '\x2', '\x2', '\x6E6', '\x6E7', '\x3', 
		'\x2', '\x2', '\x2', '\x6E7', '\x6E9', '\x3', '\x2', '\x2', '\x2', '\x6E8', 
		'\x6E6', '\x3', '\x2', '\x2', '\x2', '\x6E9', '\x6EA', '\a', '\x24E', 
		'\x2', '\x2', '\x6EA', '\x15', '\x3', '\x2', '\x2', '\x2', '\x6EB', '\x6EC', 
		'\a', '\x257', '\x2', '\x2', '\x6EC', '\x6ED', '\x5', '\x42', '\"', '\x2', 
		'\x6ED', '\x17', '\x3', '\x2', '\x2', '\x2', '\x6EE', '\x6F3', '\x5', 
		'\x1A', '\xE', '\x2', '\x6EF', '\x6F0', '\a', '\x251', '\x2', '\x2', '\x6F0', 
		'\x6F2', '\x5', '\x1A', '\xE', '\x2', '\x6F1', '\x6EF', '\x3', '\x2', 
		'\x2', '\x2', '\x6F2', '\x6F5', '\x3', '\x2', '\x2', '\x2', '\x6F3', '\x6F1', 
		'\x3', '\x2', '\x2', '\x2', '\x6F3', '\x6F4', '\x3', '\x2', '\x2', '\x2', 
		'\x6F4', '\x19', '\x3', '\x2', '\x2', '\x2', '\x6F5', '\x6F3', '\x3', 
		'\x2', '\x2', '\x2', '\x6F6', '\x6FB', '\x5', '\x1C', '\xF', '\x2', '\x6F7', 
		'\x6F9', '\a', '\x250', '\x2', '\x2', '\x6F8', '\x6FA', '\x5', '\x1A', 
		'\xE', '\x2', '\x6F9', '\x6F8', '\x3', '\x2', '\x2', '\x2', '\x6F9', '\x6FA', 
		'\x3', '\x2', '\x2', '\x2', '\x6FA', '\x6FC', '\x3', '\x2', '\x2', '\x2', 
		'\x6FB', '\x6F7', '\x3', '\x2', '\x2', '\x2', '\x6FB', '\x6FC', '\x3', 
		'\x2', '\x2', '\x2', '\x6FC', '\x1B', '\x3', '\x2', '\x2', '\x2', '\x6FD', 
		'\x718', '\x5', '\x180', '\xC1', '\x2', '\x6FE', '\x718', '\x5', '\x602', 
		'\x302', '\x2', '\x6FF', '\x718', '\x5', '\x5F6', '\x2FC', '\x2', '\x700', 
		'\x702', '\x5', '\x59E', '\x2D0', '\x2', '\x701', '\x700', '\x3', '\x2', 
		'\x2', '\x2', '\x701', '\x702', '\x3', '\x2', '\x2', '\x2', '\x702', '\x715', 
		'\x3', '\x2', '\x2', '\x2', '\x703', '\x716', '\x5', '\x4F6', '\x27C', 
		'\x2', '\x704', '\x716', '\x5', '\x4F8', '\x27D', '\x2', '\x705', '\x716', 
		'\x5', '\x502', '\x282', '\x2', '\x706', '\x716', '\x5', '\x53A', '\x29E', 
		'\x2', '\x707', '\x716', '\x5', '\x512', '\x28A', '\x2', '\x708', '\x716', 
		'\x5', '\x540', '\x2A1', '\x2', '\x709', '\x716', '\x5', '\x542', '\x2A2', 
		'\x2', '\x70A', '\x716', '\x5', '\x548', '\x2A5', '\x2', '\x70B', '\x716', 
		'\x5', '\x590', '\x2C9', '\x2', '\x70C', '\x716', '\x5', '\x3F6', '\x1FC', 
		'\x2', '\x70D', '\x716', '\x5', '\x4DC', '\x26F', '\x2', '\x70E', '\x716', 
		'\x5', '\x4F4', '\x27B', '\x2', '\x70F', '\x716', '\x5', '\x59C', '\x2CF', 
		'\x2', '\x710', '\x716', '\x5', '\x4FA', '\x27E', '\x2', '\x711', '\x716', 
		'\x5', '\x50A', '\x286', '\x2', '\x712', '\x716', '\x5', '\x51C', '\x28F', 
		'\x2', '\x713', '\x716', '\x5', '\x520', '\x291', '\x2', '\x714', '\x716', 
		'\x5', '\x52C', '\x297', '\x2', '\x715', '\x703', '\x3', '\x2', '\x2', 
		'\x2', '\x715', '\x704', '\x3', '\x2', '\x2', '\x2', '\x715', '\x705', 
		'\x3', '\x2', '\x2', '\x2', '\x715', '\x706', '\x3', '\x2', '\x2', '\x2', 
		'\x715', '\x707', '\x3', '\x2', '\x2', '\x2', '\x715', '\x708', '\x3', 
		'\x2', '\x2', '\x2', '\x715', '\x709', '\x3', '\x2', '\x2', '\x2', '\x715', 
		'\x70A', '\x3', '\x2', '\x2', '\x2', '\x715', '\x70B', '\x3', '\x2', '\x2', 
		'\x2', '\x715', '\x70C', '\x3', '\x2', '\x2', '\x2', '\x715', '\x70D', 
		'\x3', '\x2', '\x2', '\x2', '\x715', '\x70E', '\x3', '\x2', '\x2', '\x2', 
		'\x715', '\x70F', '\x3', '\x2', '\x2', '\x2', '\x715', '\x710', '\x3', 
		'\x2', '\x2', '\x2', '\x715', '\x711', '\x3', '\x2', '\x2', '\x2', '\x715', 
		'\x712', '\x3', '\x2', '\x2', '\x2', '\x715', '\x713', '\x3', '\x2', '\x2', 
		'\x2', '\x715', '\x714', '\x3', '\x2', '\x2', '\x2', '\x716', '\x718', 
		'\x3', '\x2', '\x2', '\x2', '\x717', '\x6FD', '\x3', '\x2', '\x2', '\x2', 
		'\x717', '\x6FE', '\x3', '\x2', '\x2', '\x2', '\x717', '\x6FF', '\x3', 
		'\x2', '\x2', '\x2', '\x717', '\x701', '\x3', '\x2', '\x2', '\x2', '\x718', 
		'\x1D', '\x3', '\x2', '\x2', '\x2', '\x719', '\x71A', '\x6', '\x10', '\x2', 
		'\x2', '\x71A', '\x71C', '\x5', ' ', '\x11', '\x2', '\x71B', '\x719', 
		'\x3', '\x2', '\x2', '\x2', '\x71C', '\x71F', '\x3', '\x2', '\x2', '\x2', 
		'\x71D', '\x71B', '\x3', '\x2', '\x2', '\x2', '\x71D', '\x71E', '\x3', 
		'\x2', '\x2', '\x2', '\x71E', '\x1F', '\x3', '\x2', '\x2', '\x2', '\x71F', 
		'\x71D', '\x3', '\x2', '\x2', '\x2', '\x720', '\x722', '\x5', '\x59E', 
		'\x2D0', '\x2', '\x721', '\x720', '\x3', '\x2', '\x2', '\x2', '\x721', 
		'\x722', '\x3', '\x2', '\x2', '\x2', '\x722', '\x73D', '\x3', '\x2', '\x2', 
		'\x2', '\x723', '\x73E', '\x5', '\x558', '\x2AD', '\x2', '\x724', '\x73E', 
		'\x5', '\x586', '\x2C4', '\x2', '\x725', '\x73E', '\x5', '\x4F6', '\x27C', 
		'\x2', '\x726', '\x73E', '\x5', '\x53A', '\x29E', '\x2', '\x727', '\x73E', 
		'\x5', '\x522', '\x292', '\x2', '\x728', '\x73E', '\x5', '\x540', '\x2A1', 
		'\x2', '\x729', '\x73E', '\x5', '\x50A', '\x286', '\x2', '\x72A', '\x73E', 
		'\x5', '\x5A8', '\x2D5', '\x2', '\x72B', '\x73E', '\x5', '\x5A6', '\x2D4', 
		'\x2', '\x72C', '\x73E', '\x5', '\x4F8', '\x27D', '\x2', '\x72D', '\x73E', 
		'\x5', '\x502', '\x282', '\x2', '\x72E', '\x73E', '\x5', '\x512', '\x28A', 
		'\x2', '\x72F', '\x73E', '\x5', '\x5DE', '\x2F0', '\x2', '\x730', '\x73E', 
		'\x5', '\x590', '\x2C9', '\x2', '\x731', '\x73E', '\x5', '\x3F6', '\x1FC', 
		'\x2', '\x732', '\x73E', '\x5', '\x4DC', '\x26F', '\x2', '\x733', '\x73E', 
		'\x5', '\x4F4', '\x27B', '\x2', '\x734', '\x73E', '\x5', '\x59C', '\x2CF', 
		'\x2', '\x735', '\x73E', '\x5', '\x4FA', '\x27E', '\x2', '\x736', '\x73E', 
		'\x5', '\x51C', '\x28F', '\x2', '\x737', '\x73E', '\x5', '\x520', '\x291', 
		'\x2', '\x738', '\x73E', '\x5', '\x5A4', '\x2D3', '\x2', '\x739', '\x73E', 
		'\x5', '\x5A2', '\x2D2', '\x2', '\x73A', '\x73E', '\x5', '\x54C', '\x2A7', 
		'\x2', '\x73B', '\x73E', '\x5', '\x52C', '\x297', '\x2', '\x73C', '\x73E', 
		'\x5', '\x53E', '\x2A0', '\x2', '\x73D', '\x723', '\x3', '\x2', '\x2', 
		'\x2', '\x73D', '\x724', '\x3', '\x2', '\x2', '\x2', '\x73D', '\x725', 
		'\x3', '\x2', '\x2', '\x2', '\x73D', '\x726', '\x3', '\x2', '\x2', '\x2', 
		'\x73D', '\x727', '\x3', '\x2', '\x2', '\x2', '\x73D', '\x728', '\x3', 
		'\x2', '\x2', '\x2', '\x73D', '\x729', '\x3', '\x2', '\x2', '\x2', '\x73D', 
		'\x72A', '\x3', '\x2', '\x2', '\x2', '\x73D', '\x72B', '\x3', '\x2', '\x2', 
		'\x2', '\x73D', '\x72C', '\x3', '\x2', '\x2', '\x2', '\x73D', '\x72D', 
		'\x3', '\x2', '\x2', '\x2', '\x73D', '\x72E', '\x3', '\x2', '\x2', '\x2', 
		'\x73D', '\x72F', '\x3', '\x2', '\x2', '\x2', '\x73D', '\x730', '\x3', 
		'\x2', '\x2', '\x2', '\x73D', '\x731', '\x3', '\x2', '\x2', '\x2', '\x73D', 
		'\x732', '\x3', '\x2', '\x2', '\x2', '\x73D', '\x733', '\x3', '\x2', '\x2', 
		'\x2', '\x73D', '\x734', '\x3', '\x2', '\x2', '\x2', '\x73D', '\x735', 
		'\x3', '\x2', '\x2', '\x2', '\x73D', '\x736', '\x3', '\x2', '\x2', '\x2', 
		'\x73D', '\x737', '\x3', '\x2', '\x2', '\x2', '\x73D', '\x738', '\x3', 
		'\x2', '\x2', '\x2', '\x73D', '\x739', '\x3', '\x2', '\x2', '\x2', '\x73D', 
		'\x73A', '\x3', '\x2', '\x2', '\x2', '\x73D', '\x73B', '\x3', '\x2', '\x2', 
		'\x2', '\x73D', '\x73C', '\x3', '\x2', '\x2', '\x2', '\x73E', '\x73F', 
		'\x3', '\x2', '\x2', '\x2', '\x73F', '\x740', '\a', '\x250', '\x2', '\x2', 
		'\x740', '!', '\x3', '\x2', '\x2', '\x2', '\x741', '\x743', '\a', '\x64', 
		'\x2', '\x2', '\x742', '\x744', '\x5', '\x182', '\xC2', '\x2', '\x743', 
		'\x742', '\x3', '\x2', '\x2', '\x2', '\x743', '\x744', '\x3', '\x2', '\x2', 
		'\x2', '\x744', '\x746', '\x3', '\x2', '\x2', '\x2', '\x745', '\x747', 
		'\x5', '\x1DE', '\xF0', '\x2', '\x746', '\x745', '\x3', '\x2', '\x2', 
		'\x2', '\x746', '\x747', '\x3', '\x2', '\x2', '\x2', '\x747', '\x748', 
		'\x3', '\x2', '\x2', '\x2', '\x748', '\x74C', '\x5', '$', '\x13', '\x2', 
		'\x749', '\x74B', '\v', '\x2', '\x2', '\x2', '\x74A', '\x749', '\x3', 
		'\x2', '\x2', '\x2', '\x74B', '\x74E', '\x3', '\x2', '\x2', '\x2', '\x74C', 
		'\x74D', '\x3', '\x2', '\x2', '\x2', '\x74C', '\x74A', '\x3', '\x2', '\x2', 
		'\x2', '\x74D', '#', '\x3', '\x2', '\x2', '\x2', '\x74E', '\x74C', '\x3', 
		'\x2', '\x2', '\x2', '\x74F', '\x752', '\x5', '\x1E8', '\xF5', '\x2', 
		'\x750', '\x752', '\x5', '\x210', '\x109', '\x2', '\x751', '\x74F', '\x3', 
		'\x2', '\x2', '\x2', '\x751', '\x750', '\x3', '\x2', '\x2', '\x2', '\x752', 
		'%', '\x3', '\x2', '\x2', '\x2', '\x753', '\x75E', '\t', '\x2', '\x2', 
		'\x2', '\x754', '\x75E', '\x5', '*', '\x16', '\x2', '\x755', '\x75E', 
		'\x5', '(', '\x15', '\x2', '\x756', '\x75E', '\x5', ',', '\x17', '\x2', 
		'\x757', '\x75E', '\x5', '.', '\x18', '\x2', '\x758', '\x75E', '\x5', 
		'\x30', '\x19', '\x2', '\x759', '\x75E', '\x5', '\x32', '\x1A', '\x2', 
		'\x75A', '\x75E', '\x5', '\x34', '\x1B', '\x2', '\x75B', '\x75E', '\x5', 
		'\x36', '\x1C', '\x2', '\x75C', '\x75E', '\x5', '<', '\x1F', '\x2', '\x75D', 
		'\x753', '\x3', '\x2', '\x2', '\x2', '\x75D', '\x754', '\x3', '\x2', '\x2', 
		'\x2', '\x75D', '\x755', '\x3', '\x2', '\x2', '\x2', '\x75D', '\x756', 
		'\x3', '\x2', '\x2', '\x2', '\x75D', '\x757', '\x3', '\x2', '\x2', '\x2', 
		'\x75D', '\x758', '\x3', '\x2', '\x2', '\x2', '\x75D', '\x759', '\x3', 
		'\x2', '\x2', '\x2', '\x75D', '\x75A', '\x3', '\x2', '\x2', '\x2', '\x75D', 
		'\x75B', '\x3', '\x2', '\x2', '\x2', '\x75D', '\x75C', '\x3', '\x2', '\x2', 
		'\x2', '\x75E', '\'', '\x3', '\x2', '\x2', '\x2', '\x75F', '\x760', '\a', 
		'\x26E', '\x2', '\x2', '\x760', ')', '\x3', '\x2', '\x2', '\x2', '\x761', 
		'\x762', '\a', '\x265', '\x2', '\x2', '\x762', '+', '\x3', '\x2', '\x2', 
		'\x2', '\x763', '\x764', '\a', '\x263', '\x2', '\x2', '\x764', '-', '\x3', 
		'\x2', '\x2', '\x2', '\x765', '\x766', '\a', '\x264', '\x2', '\x2', '\x766', 
		'/', '\x3', '\x2', '\x2', '\x2', '\x767', '\x768', '\t', '\x3', '\x2', 
		'\x2', '\x768', '\x31', '\x3', '\x2', '\x2', '\x2', '\x769', '\x76A', 
		'\a', 'o', '\x2', '\x2', '\x76A', '\x76B', '\a', '\x265', '\x2', '\x2', 
		'\x76B', '\x33', '\x3', '\x2', '\x2', '\x2', '\x76C', '\x76D', '\a', '\x206', 
		'\x2', '\x2', '\x76D', '\x76E', '\a', '\x265', '\x2', '\x2', '\x76E', 
		'\x35', '\x3', '\x2', '\x2', '\x2', '\x76F', '\x770', '\a', '\xF2', '\x2', 
		'\x2', '\x770', '\x771', '\a', '\x265', '\x2', '\x2', '\x771', '\x774', 
		'\x5', '\x38', '\x1D', '\x2', '\x772', '\x773', '\a', '\x20B', '\x2', 
		'\x2', '\x773', '\x775', '\x5', '\x38', '\x1D', '\x2', '\x774', '\x772', 
		'\x3', '\x2', '\x2', '\x2', '\x774', '\x775', '\x3', '\x2', '\x2', '\x2', 
		'\x775', '\x37', '\x3', '\x2', '\x2', '\x2', '\x776', '\x778', '\t', '\x4', 
		'\x2', '\x2', '\x777', '\x779', '\x5', ':', '\x1E', '\x2', '\x778', '\x777', 
		'\x3', '\x2', '\x2', '\x2', '\x778', '\x779', '\x3', '\x2', '\x2', '\x2', 
		'\x779', '\x39', '\x3', '\x2', '\x2', '\x2', '\x77A', '\x77B', '\a', '\x24D', 
		'\x2', '\x2', '\x77B', '\x77E', '\x5', '&', '\x14', '\x2', '\x77C', '\x77D', 
		'\a', '\x24F', '\x2', '\x2', '\x77D', '\x77F', '\x5', '&', '\x14', '\x2', 
		'\x77E', '\x77C', '\x3', '\x2', '\x2', '\x2', '\x77E', '\x77F', '\x3', 
		'\x2', '\x2', '\x2', '\x77F', '\x780', '\x3', '\x2', '\x2', '\x2', '\x780', 
		'\x781', '\a', '\x24E', '\x2', '\x2', '\x781', ';', '\x3', '\x2', '\x2', 
		'\x2', '\x782', '\x783', '\a', '\x262', '\x2', '\x2', '\x783', '=', '\x3', 
		'\x2', '\x2', '\x2', '\x784', '\x787', '\a', '\x268', '\x2', '\x2', '\x785', 
		'\x787', '\t', '\x5', '\x2', '\x2', '\x786', '\x784', '\x3', '\x2', '\x2', 
		'\x2', '\x786', '\x785', '\x3', '\x2', '\x2', '\x2', '\x787', '?', '\x3', 
		'\x2', '\x2', '\x2', '\x788', '\x789', '\a', '\x25E', '\x2', '\x2', '\x789', 
		'\x41', '\x3', '\x2', '\x2', '\x2', '\x78A', '\x793', '\x5', 'N', '(', 
		'\x2', '\x78B', '\x78E', '\x5', '@', '!', '\x2', '\x78C', '\x78F', '\x5', 
		'N', '(', '\x2', '\x78D', '\x78F', '\x5', 'J', '&', '\x2', '\x78E', '\x78C', 
		'\x3', '\x2', '\x2', '\x2', '\x78E', '\x78D', '\x3', '\x2', '\x2', '\x2', 
		'\x78F', '\x792', '\x3', '\x2', '\x2', '\x2', '\x790', '\x792', '\x5', 
		'P', ')', '\x2', '\x791', '\x78B', '\x3', '\x2', '\x2', '\x2', '\x791', 
		'\x790', '\x3', '\x2', '\x2', '\x2', '\x792', '\x795', '\x3', '\x2', '\x2', 
		'\x2', '\x793', '\x791', '\x3', '\x2', '\x2', '\x2', '\x793', '\x794', 
		'\x3', '\x2', '\x2', '\x2', '\x794', '\x799', '\x3', '\x2', '\x2', '\x2', 
		'\x795', '\x793', '\x3', '\x2', '\x2', '\x2', '\x796', '\x797', '\a', 
		'\x24D', '\x2', '\x2', '\x797', '\x798', '\a', '\x258', '\x2', '\x2', 
		'\x798', '\x79A', '\a', '\x24E', '\x2', '\x2', '\x799', '\x796', '\x3', 
		'\x2', '\x2', '\x2', '\x799', '\x79A', '\x3', '\x2', '\x2', '\x2', '\x79A', 
		'\x43', '\x3', '\x2', '\x2', '\x2', '\x79B', '\x7A1', '\x5', '\\', '/', 
		'\x2', '\x79C', '\x79D', '\x5', '@', '!', '\x2', '\x79D', '\x79E', '\x5', 
		'\\', '/', '\x2', '\x79E', '\x7A0', '\x3', '\x2', '\x2', '\x2', '\x79F', 
		'\x79C', '\x3', '\x2', '\x2', '\x2', '\x7A0', '\x7A3', '\x3', '\x2', '\x2', 
		'\x2', '\x7A1', '\x79F', '\x3', '\x2', '\x2', '\x2', '\x7A1', '\x7A2', 
		'\x3', '\x2', '\x2', '\x2', '\x7A2', '\x45', '\x3', '\x2', '\x2', '\x2', 
		'\x7A3', '\x7A1', '\x3', '\x2', '\x2', '\x2', '\x7A4', '\x7AA', '\x5', 
		'\\', '/', '\x2', '\x7A5', '\x7A6', '\x5', '@', '!', '\x2', '\x7A6', '\x7A7', 
		'\x5', '\\', '/', '\x2', '\x7A7', '\x7A9', '\x3', '\x2', '\x2', '\x2', 
		'\x7A8', '\x7A5', '\x3', '\x2', '\x2', '\x2', '\x7A9', '\x7AC', '\x3', 
		'\x2', '\x2', '\x2', '\x7AA', '\x7A8', '\x3', '\x2', '\x2', '\x2', '\x7AA', 
		'\x7AB', '\x3', '\x2', '\x2', '\x2', '\x7AB', '\x7AE', '\x3', '\x2', '\x2', 
		'\x2', '\x7AC', '\x7AA', '\x3', '\x2', '\x2', '\x2', '\x7AD', '\x7AF', 
		'\x5', 'L', '\'', '\x2', '\x7AE', '\x7AD', '\x3', '\x2', '\x2', '\x2', 
		'\x7AE', '\x7AF', '\x3', '\x2', '\x2', '\x2', '\x7AF', 'G', '\x3', '\x2', 
		'\x2', '\x2', '\x7B0', '\x7B4', '\x5', '\\', '/', '\x2', '\x7B1', '\x7B2', 
		'\x5', '@', '!', '\x2', '\x7B2', '\x7B3', '\x5', '\\', '/', '\x2', '\x7B3', 
		'\x7B5', '\x3', '\x2', '\x2', '\x2', '\x7B4', '\x7B1', '\x3', '\x2', '\x2', 
		'\x2', '\x7B5', '\x7B6', '\x3', '\x2', '\x2', '\x2', '\x7B6', '\x7B4', 
		'\x3', '\x2', '\x2', '\x2', '\x7B6', '\x7B7', '\x3', '\x2', '\x2', '\x2', 
		'\x7B7', 'I', '\x3', '\x2', '\x2', '\x2', '\x7B8', '\x7B9', '\a', '\x25D', 
		'\x2', '\x2', '\x7B9', 'K', '\x3', '\x2', '\x2', '\x2', '\x7BA', '\x7BD', 
		'\a', '\x257', '\x2', '\x2', '\x7BB', '\x7BE', '\x5', '>', ' ', '\x2', 
		'\x7BC', '\x7BE', '\a', '\x269', '\x2', '\x2', '\x7BD', '\x7BB', '\x3', 
		'\x2', '\x2', '\x2', '\x7BD', '\x7BC', '\x3', '\x2', '\x2', '\x2', '\x7BE', 
		'\x7C6', '\x3', '\x2', '\x2', '\x2', '\x7BF', '\x7C2', '\t', '\x6', '\x2', 
		'\x2', '\x7C0', '\x7C3', '\x5', '>', ' ', '\x2', '\x7C1', '\x7C3', '\a', 
		'\x269', '\x2', '\x2', '\x7C2', '\x7C0', '\x3', '\x2', '\x2', '\x2', '\x7C2', 
		'\x7C1', '\x3', '\x2', '\x2', '\x2', '\x7C3', '\x7C5', '\x3', '\x2', '\x2', 
		'\x2', '\x7C4', '\x7BF', '\x3', '\x2', '\x2', '\x2', '\x7C5', '\x7C8', 
		'\x3', '\x2', '\x2', '\x2', '\x7C6', '\x7C4', '\x3', '\x2', '\x2', '\x2', 
		'\x7C6', '\x7C7', '\x3', '\x2', '\x2', '\x2', '\x7C7', 'M', '\x3', '\x2', 
		'\x2', '\x2', '\x7C8', '\x7C6', '\x3', '\x2', '\x2', '\x2', '\x7C9', '\x7CC', 
		'\x5', '>', ' ', '\x2', '\x7CA', '\x7CC', '\a', '\x269', '\x2', '\x2', 
		'\x7CB', '\x7C9', '\x3', '\x2', '\x2', '\x2', '\x7CB', '\x7CA', '\x3', 
		'\x2', '\x2', '\x2', '\x7CC', '\x7CE', '\x3', '\x2', '\x2', '\x2', '\x7CD', 
		'\x7CF', '\x5', 'L', '\'', '\x2', '\x7CE', '\x7CD', '\x3', '\x2', '\x2', 
		'\x2', '\x7CE', '\x7CF', '\x3', '\x2', '\x2', '\x2', '\x7CF', '\x7D1', 
		'\x3', '\x2', '\x2', '\x2', '\x7D0', '\x7D2', '\x5', 'X', '-', '\x2', 
		'\x7D1', '\x7D0', '\x3', '\x2', '\x2', '\x2', '\x7D1', '\x7D2', '\x3', 
		'\x2', '\x2', '\x2', '\x7D2', 'O', '\x3', '\x2', '\x2', '\x2', '\x7D3', 
		'\x7D4', '\x5', 'X', '-', '\x2', '\x7D4', 'Q', '\x3', '\x2', '\x2', '\x2', 
		'\x7D5', '\x7D6', '\x5', 'V', ',', '\x2', '\x7D6', 'S', '\x3', '\x2', 
		'\x2', '\x2', '\x7D7', '\x7D8', '\a', '\x16B', '\x2', '\x2', '\x7D8', 
		'\x7D9', '\a', '\xBC', '\x2', '\x2', '\x7D9', '\x7DA', '\x5', 'X', '-', 
		'\x2', '\x7DA', '\x7DB', '\a', '\x225', '\x2', '\x2', '\x7DB', '\x7DC', 
		'\a', '\x108', '\x2', '\x2', '\x7DC', '\x7E0', '\x5', '\x42', '\"', '\x2', 
		'\x7DD', '\x7DF', '\n', '\a', '\x2', '\x2', '\x7DE', '\x7DD', '\x3', '\x2', 
		'\x2', '\x2', '\x7DF', '\x7E2', '\x3', '\x2', '\x2', '\x2', '\x7E0', '\x7DE', 
		'\x3', '\x2', '\x2', '\x2', '\x7E0', '\x7E1', '\x3', '\x2', '\x2', '\x2', 
		'\x7E1', 'U', '\x3', '\x2', '\x2', '\x2', '\x7E2', '\x7E0', '\x3', '\x2', 
		'\x2', '\x2', '\x7E3', '\x7E5', '\a', '\x265', '\x2', '\x2', '\x7E4', 
		'\x7E6', '\x5', 'X', '-', '\x2', '\x7E5', '\x7E4', '\x3', '\x2', '\x2', 
		'\x2', '\x7E5', '\x7E6', '\x3', '\x2', '\x2', '\x2', '\x7E6', 'W', '\x3', 
		'\x2', '\x2', '\x2', '\x7E7', '\x7E9', '\a', '\x24D', '\x2', '\x2', '\x7E8', 
		'\x7EA', '\t', '\b', '\x2', '\x2', '\x7E9', '\x7E8', '\x3', '\x2', '\x2', 
		'\x2', '\x7E9', '\x7EA', '\x3', '\x2', '\x2', '\x2', '\x7EA', '\x7EC', 
		'\x3', '\x2', '\x2', '\x2', '\x7EB', '\x7ED', '\x5', '\x16A', '\xB6', 
		'\x2', '\x7EC', '\x7EB', '\x3', '\x2', '\x2', '\x2', '\x7EC', '\x7ED', 
		'\x3', '\x2', '\x2', '\x2', '\x7ED', '\x7EE', '\x3', '\x2', '\x2', '\x2', 
		'\x7EE', '\x7EF', '\a', '\x24E', '\x2', '\x2', '\x7EF', 'Y', '\x3', '\x2', 
		'\x2', '\x2', '\x7F0', '\x7F3', '\x5', '>', ' ', '\x2', '\x7F1', '\x7F3', 
		'\a', '\x269', '\x2', '\x2', '\x7F2', '\x7F0', '\x3', '\x2', '\x2', '\x2', 
		'\x7F2', '\x7F1', '\x3', '\x2', '\x2', '\x2', '\x7F3', '[', '\x3', '\x2', 
		'\x2', '\x2', '\x7F4', '\x7F7', '\x5', '>', ' ', '\x2', '\x7F5', '\x7F7', 
		'\a', '\x269', '\x2', '\x2', '\x7F6', '\x7F4', '\x3', '\x2', '\x2', '\x2', 
		'\x7F6', '\x7F5', '\x3', '\x2', '\x2', '\x2', '\x7F7', '\x7F9', '\x3', 
		'\x2', '\x2', '\x2', '\x7F8', '\x7FA', '\x5', 'L', '\'', '\x2', '\x7F9', 
		'\x7F8', '\x3', '\x2', '\x2', '\x2', '\x7F9', '\x7FA', '\x3', '\x2', '\x2', 
		'\x2', '\x7FA', ']', '\x3', '\x2', '\x2', '\x2', '\x7FB', '\x7FC', '\a', 
		'\x25B', '\x2', '\x2', '\x7FC', '_', '\x3', '\x2', '\x2', '\x2', '\x7FD', 
		'\x80C', '\x5', '\x88', '\x45', '\x2', '\x7FE', '\x80C', '\x5', '\x8A', 
		'\x46', '\x2', '\x7FF', '\x80C', '\x5', '\x8C', 'G', '\x2', '\x800', '\x80C', 
		'\x5', '\x90', 'I', '\x2', '\x801', '\x80C', '\x5', '\x9E', 'P', '\x2', 
		'\x802', '\x803', '\a', '\x24D', '\x2', '\x2', '\x803', '\x804', '\x5', 
		'\x30', '\x19', '\x2', '\x804', '\x805', '\a', '\x24F', '\x2', '\x2', 
		'\x805', '\x806', '\x5', '\x30', '\x19', '\x2', '\x806', '\x807', '\a', 
		'\x24E', '\x2', '\x2', '\x807', '\x80C', '\x3', '\x2', '\x2', '\x2', '\x808', 
		'\x80C', '\x5', 'T', '+', '\x2', '\x809', '\x80C', '\x5', 'v', '<', '\x2', 
		'\x80A', '\x80C', '\x5', '\x42', '\"', '\x2', '\x80B', '\x7FD', '\x3', 
		'\x2', '\x2', '\x2', '\x80B', '\x7FE', '\x3', '\x2', '\x2', '\x2', '\x80B', 
		'\x7FF', '\x3', '\x2', '\x2', '\x2', '\x80B', '\x800', '\x3', '\x2', '\x2', 
		'\x2', '\x80B', '\x801', '\x3', '\x2', '\x2', '\x2', '\x80B', '\x802', 
		'\x3', '\x2', '\x2', '\x2', '\x80B', '\x808', '\x3', '\x2', '\x2', '\x2', 
		'\x80B', '\x809', '\x3', '\x2', '\x2', '\x2', '\x80B', '\x80A', '\x3', 
		'\x2', '\x2', '\x2', '\x80C', '\x80E', '\x3', '\x2', '\x2', '\x2', '\x80D', 
		'\x80F', '\x5', '\x92', 'J', '\x2', '\x80E', '\x80D', '\x3', '\x2', '\x2', 
		'\x2', '\x80E', '\x80F', '\x3', '\x2', '\x2', '\x2', '\x80F', '\x61', 
		'\x3', '\x2', '\x2', '\x2', '\x810', '\x812', '\a', '\x206', '\x2', '\x2', 
		'\x811', '\x813', '\x5', 'X', '-', '\x2', '\x812', '\x811', '\x3', '\x2', 
		'\x2', '\x2', '\x812', '\x813', '\x3', '\x2', '\x2', '\x2', '\x813', '\x63', 
		'\x3', '\x2', '\x2', '\x2', '\x814', '\x816', '\a', '\x205', '\x2', '\x2', 
		'\x815', '\x817', '\x5', 'X', '-', '\x2', '\x816', '\x815', '\x3', '\x2', 
		'\x2', '\x2', '\x816', '\x817', '\x3', '\x2', '\x2', '\x2', '\x817', '\x65', 
		'\x3', '\x2', '\x2', '\x2', '\x818', '\x81A', '\a', '\x236', '\x2', '\x2', 
		'\x819', '\x81B', '\x5', 'X', '-', '\x2', '\x81A', '\x819', '\x3', '\x2', 
		'\x2', '\x2', '\x81A', '\x81B', '\x3', '\x2', '\x2', '\x2', '\x81B', 'g', 
		'\x3', '\x2', '\x2', '\x2', '\x81C', '\x81E', '\a', '\x111', '\x2', '\x2', 
		'\x81D', '\x81F', '\x5', 'X', '-', '\x2', '\x81E', '\x81D', '\x3', '\x2', 
		'\x2', '\x2', '\x81E', '\x81F', '\x3', '\x2', '\x2', '\x2', '\x81F', 'i', 
		'\x3', '\x2', '\x2', '\x2', '\x820', '\x822', '\a', '\x246', '\x2', '\x2', 
		'\x821', '\x823', '\x5', 'X', '-', '\x2', '\x822', '\x821', '\x3', '\x2', 
		'\x2', '\x2', '\x822', '\x823', '\x3', '\x2', '\x2', '\x2', '\x823', 'k', 
		'\x3', '\x2', '\x2', '\x2', '\x824', '\x826', '\a', '\xF2', '\x2', '\x2', 
		'\x825', '\x827', '\x5', 'X', '-', '\x2', '\x826', '\x825', '\x3', '\x2', 
		'\x2', '\x2', '\x826', '\x827', '\x3', '\x2', '\x2', '\x2', '\x827', 'm', 
		'\x3', '\x2', '\x2', '\x2', '\x828', '\x82A', '\a', '\x20B', '\x2', '\x2', 
		'\x829', '\x82B', '\x5', 'X', '-', '\x2', '\x82A', '\x829', '\x3', '\x2', 
		'\x2', '\x2', '\x82A', '\x82B', '\x3', '\x2', '\x2', '\x2', '\x82B', 'o', 
		'\x3', '\x2', '\x2', '\x2', '\x82C', '\x82E', '\a', '\x11A', '\x2', '\x2', 
		'\x82D', '\x82F', '\x5', 'X', '-', '\x2', '\x82E', '\x82D', '\x3', '\x2', 
		'\x2', '\x2', '\x82E', '\x82F', '\x3', '\x2', '\x2', '\x2', '\x82F', 'q', 
		'\x3', '\x2', '\x2', '\x2', '\x830', '\x832', '\a', '\x1A1', '\x2', '\x2', 
		'\x831', '\x833', '\x5', 'X', '-', '\x2', '\x832', '\x831', '\x3', '\x2', 
		'\x2', '\x2', '\x832', '\x833', '\x3', '\x2', '\x2', '\x2', '\x833', 's', 
		'\x3', '\x2', '\x2', '\x2', '\x834', '\x835', '\a', '\x11A', '\x2', '\x2', 
		'\x835', '\x836', '\x5', 'r', ':', '\x2', '\x836', 'u', '\x3', '\x2', 
		'\x2', '\x2', '\x837', '\x838', '\a', '\x8E', '\x2', '\x2', '\x838', '\x83A', 
		'\a', '\x193', '\x2', '\x2', '\x839', '\x83B', '\x5', 'X', '-', '\x2', 
		'\x83A', '\x839', '\x3', '\x2', '\x2', '\x2', '\x83A', '\x83B', '\x3', 
		'\x2', '\x2', '\x2', '\x83B', 'w', '\x3', '\x2', '\x2', '\x2', '\x83C', 
		'\x83E', '\t', '\t', '\x2', '\x2', '\x83D', '\x83F', '\a', '\x22D', '\x2', 
		'\x2', '\x83E', '\x83D', '\x3', '\x2', '\x2', '\x2', '\x83E', '\x83F', 
		'\x3', '\x2', '\x2', '\x2', '\x83F', '\x841', '\x3', '\x2', '\x2', '\x2', 
		'\x840', '\x842', '\x5', '\x86', '\x44', '\x2', '\x841', '\x840', '\x3', 
		'\x2', '\x2', '\x2', '\x841', '\x842', '\x3', '\x2', '\x2', '\x2', '\x842', 
		'\x844', '\x3', '\x2', '\x2', '\x2', '\x843', '\x845', '\x5', '\x8E', 
		'H', '\x2', '\x844', '\x843', '\x3', '\x2', '\x2', '\x2', '\x844', '\x845', 
		'\x3', '\x2', '\x2', '\x2', '\x845', 'y', '\x3', '\x2', '\x2', '\x2', 
		'\x846', '\x847', '\a', '\x13A', '\x2', '\x2', '\x847', '\x849', '\t', 
		'\t', '\x2', '\x2', '\x848', '\x84A', '\a', '\x22D', '\x2', '\x2', '\x849', 
		'\x848', '\x3', '\x2', '\x2', '\x2', '\x849', '\x84A', '\x3', '\x2', '\x2', 
		'\x2', '\x84A', '\x84C', '\x3', '\x2', '\x2', '\x2', '\x84B', '\x84D', 
		'\x5', 'X', '-', '\x2', '\x84C', '\x84B', '\x3', '\x2', '\x2', '\x2', 
		'\x84C', '\x84D', '\x3', '\x2', '\x2', '\x2', '\x84D', '\x84F', '\x3', 
		'\x2', '\x2', '\x2', '\x84E', '\x850', '\x5', '\x8E', 'H', '\x2', '\x84F', 
		'\x84E', '\x3', '\x2', '\x2', '\x2', '\x84F', '\x850', '\x3', '\x2', '\x2', 
		'\x2', '\x850', '{', '\x3', '\x2', '\x2', '\x2', '\x851', '\x853', '\a', 
		'\x13C', '\x2', '\x2', '\x852', '\x854', '\a', '\x22D', '\x2', '\x2', 
		'\x853', '\x852', '\x3', '\x2', '\x2', '\x2', '\x853', '\x854', '\x3', 
		'\x2', '\x2', '\x2', '\x854', '\x856', '\x3', '\x2', '\x2', '\x2', '\x855', 
		'\x857', '\x5', 'X', '-', '\x2', '\x856', '\x855', '\x3', '\x2', '\x2', 
		'\x2', '\x856', '\x857', '\x3', '\x2', '\x2', '\x2', '\x857', '\x859', 
		'\x3', '\x2', '\x2', '\x2', '\x858', '\x85A', '\x5', '\x8E', 'H', '\x2', 
		'\x859', '\x858', '\x3', '\x2', '\x2', '\x2', '\x859', '\x85A', '\x3', 
		'\x2', '\x2', '\x2', '\x85A', '}', '\x3', '\x2', '\x2', '\x2', '\x85B', 
		'\x85D', '\a', '\x162', '\x2', '\x2', '\x85C', '\x85E', '\x5', 'X', '-', 
		'\x2', '\x85D', '\x85C', '\x3', '\x2', '\x2', '\x2', '\x85D', '\x85E', 
		'\x3', '\x2', '\x2', '\x2', '\x85E', '\x860', '\x3', '\x2', '\x2', '\x2', 
		'\x85F', '\x861', '\x5', '\x8E', 'H', '\x2', '\x860', '\x85F', '\x3', 
		'\x2', '\x2', '\x2', '\x860', '\x861', '\x3', '\x2', '\x2', '\x2', '\x861', 
		'\x7F', '\x3', '\x2', '\x2', '\x2', '\x862', '\x864', '\a', '\x229', '\x2', 
		'\x2', '\x863', '\x865', '\x5', '\x86', '\x44', '\x2', '\x864', '\x863', 
		'\x3', '\x2', '\x2', '\x2', '\x864', '\x865', '\x3', '\x2', '\x2', '\x2', 
		'\x865', '\x867', '\x3', '\x2', '\x2', '\x2', '\x866', '\x868', '\x5', 
		'\x8E', 'H', '\x2', '\x867', '\x866', '\x3', '\x2', '\x2', '\x2', '\x867', 
		'\x868', '\x3', '\x2', '\x2', '\x2', '\x868', '\x81', '\x3', '\x2', '\x2', 
		'\x2', '\x869', '\x86B', '\a', '\x22A', '\x2', '\x2', '\x86A', '\x86C', 
		'\x5', '\x86', '\x44', '\x2', '\x86B', '\x86A', '\x3', '\x2', '\x2', '\x2', 
		'\x86B', '\x86C', '\x3', '\x2', '\x2', '\x2', '\x86C', '\x86E', '\x3', 
		'\x2', '\x2', '\x2', '\x86D', '\x86F', '\x5', '\x8E', 'H', '\x2', '\x86E', 
		'\x86D', '\x3', '\x2', '\x2', '\x2', '\x86E', '\x86F', '\x3', '\x2', '\x2', 
		'\x2', '\x86F', '\x83', '\x3', '\x2', '\x2', '\x2', '\x870', '\x872', 
		'\a', '\x1EF', '\x2', '\x2', '\x871', '\x873', '\x5', '\x86', '\x44', 
		'\x2', '\x872', '\x871', '\x3', '\x2', '\x2', '\x2', '\x872', '\x873', 
		'\x3', '\x2', '\x2', '\x2', '\x873', '\x875', '\x3', '\x2', '\x2', '\x2', 
		'\x874', '\x876', '\x5', '\x8E', 'H', '\x2', '\x875', '\x874', '\x3', 
		'\x2', '\x2', '\x2', '\x875', '\x876', '\x3', '\x2', '\x2', '\x2', '\x876', 
		'\x85', '\x3', '\x2', '\x2', '\x2', '\x877', '\x878', '\a', '\x24D', '\x2', 
		'\x2', '\x878', '\x87A', '\x5', '\xA0', 'Q', '\x2', '\x879', '\x87B', 
		'\t', '\n', '\x2', '\x2', '\x87A', '\x879', '\x3', '\x2', '\x2', '\x2', 
		'\x87A', '\x87B', '\x3', '\x2', '\x2', '\x2', '\x87B', '\x87C', '\x3', 
		'\x2', '\x2', '\x2', '\x87C', '\x87D', '\a', '\x24E', '\x2', '\x2', '\x87D', 
		'\x87', '\x3', '\x2', '\x2', '\x2', '\x87E', '\x881', '\x5', '\x62', '\x32', 
		'\x2', '\x87F', '\x881', '\x5', '\x64', '\x33', '\x2', '\x880', '\x87E', 
		'\x3', '\x2', '\x2', '\x2', '\x880', '\x87F', '\x3', '\x2', '\x2', '\x2', 
		'\x881', '\x889', '\x3', '\x2', '\x2', '\x2', '\x882', '\x884', '\x5', 
		'\x66', '\x34', '\x2', '\x883', '\x885', '\x5', 'h', '\x35', '\x2', '\x884', 
		'\x883', '\x3', '\x2', '\x2', '\x2', '\x884', '\x885', '\x3', '\x2', '\x2', 
		'\x2', '\x885', '\x886', '\x3', '\x2', '\x2', '\x2', '\x886', '\x887', 
		'\x5', '\x64', '\x33', '\x2', '\x887', '\x888', '\x5', 'j', '\x36', '\x2', 
		'\x888', '\x88A', '\x3', '\x2', '\x2', '\x2', '\x889', '\x882', '\x3', 
		'\x2', '\x2', '\x2', '\x889', '\x88A', '\x3', '\x2', '\x2', '\x2', '\x88A', 
		'\x89', '\x3', '\x2', '\x2', '\x2', '\x88B', '\x88C', '\x5', 'l', '\x37', 
		'\x2', '\x88C', '\x88D', '\x5', '\x42', '\"', '\x2', '\x88D', '\x88E', 
		'\x5', 'n', '\x38', '\x2', '\x88E', '\x88F', '\x5', '\x42', '\"', '\x2', 
		'\x88F', '\x8B', '\x3', '\x2', '\x2', '\x2', '\x890', '\x898', '\x5', 
		'x', '=', '\x2', '\x891', '\x898', '\x5', '\x80', '\x41', '\x2', '\x892', 
		'\x898', '\x5', '\x82', '\x42', '\x2', '\x893', '\x898', '\x5', '|', '?', 
		'\x2', '\x894', '\x898', '\x5', '~', '@', '\x2', '\x895', '\x898', '\x5', 
		'\x84', '\x43', '\x2', '\x896', '\x898', '\x5', 'z', '>', '\x2', '\x897', 
		'\x890', '\x3', '\x2', '\x2', '\x2', '\x897', '\x891', '\x3', '\x2', '\x2', 
		'\x2', '\x897', '\x892', '\x3', '\x2', '\x2', '\x2', '\x897', '\x893', 
		'\x3', '\x2', '\x2', '\x2', '\x897', '\x894', '\x3', '\x2', '\x2', '\x2', 
		'\x897', '\x895', '\x3', '\x2', '\x2', '\x2', '\x897', '\x896', '\x3', 
		'\x2', '\x2', '\x2', '\x898', '\x8D', '\x3', '\x2', '\x2', '\x2', '\x899', 
		'\x89A', '\a', 'G', '\x2', '\x2', '\x89A', '\x89B', '\x5', 'Z', '.', '\x2', 
		'\x89B', '\x8F', '\x3', '\x2', '\x2', '\x2', '\x89C', '\x8A0', '\x5', 
		'r', ':', '\x2', '\x89D', '\x8A0', '\x5', 't', ';', '\x2', '\x89E', '\x8A0', 
		'\x5', 'p', '\x39', '\x2', '\x89F', '\x89C', '\x3', '\x2', '\x2', '\x2', 
		'\x89F', '\x89D', '\x3', '\x2', '\x2', '\x2', '\x89F', '\x89E', '\x3', 
		'\x2', '\x2', '\x2', '\x8A0', '\x91', '\x3', '\x2', '\x2', '\x2', '\x8A1', 
		'\x8A5', '\x5', '\x94', 'K', '\x2', '\x8A2', '\x8A5', '\x5', '\x98', 'M', 
		'\x2', '\x8A3', '\x8A5', '\x5', '\x9C', 'O', '\x2', '\x8A4', '\x8A1', 
		'\x3', '\x2', '\x2', '\x2', '\x8A4', '\x8A2', '\x3', '\x2', '\x2', '\x2', 
		'\x8A4', '\x8A3', '\x3', '\x2', '\x2', '\x2', '\x8A5', '\x93', '\x3', 
		'\x2', '\x2', '\x2', '\x8A6', '\x8A7', '\a', '>', '\x2', '\x2', '\x8A7', 
		'\x8A8', '\a', '\x1DA', '\x2', '\x2', '\x8A8', '\x8AA', '\x5', '\xA0', 
		'Q', '\x2', '\x8A9', '\x8AB', '\x5', '\x96', 'L', '\x2', '\x8AA', '\x8A9', 
		'\x3', '\x2', '\x2', '\x2', '\x8AA', '\x8AB', '\x3', '\x2', '\x2', '\x2', 
		'\x8AB', '\x95', '\x3', '\x2', '\x2', '\x2', '\x8AC', '\x8AD', '\a', '\x256', 
		'\x2', '\x2', '\x8AD', '\x8AE', '\a', '?', '\x2', '\x2', '\x8AE', '\x97', 
		'\x3', '\x2', '\x2', '\x2', '\x8AF', '\x8B0', '\a', '\x1A0', '\x2', '\x2', 
		'\x8B0', '\x8B1', '\x5', '\xA0', 'Q', '\x2', '\x8B1', '\x8B2', '\x5', 
		'\x9A', 'N', '\x2', '\x8B2', '\x8B3', '\x5', '\xA0', 'Q', '\x2', '\x8B3', 
		'\x99', '\x3', '\x2', '\x2', '\x2', '\x8B4', '\x8B5', '\a', '\x24C', '\x2', 
		'\x2', '\x8B5', '\x9B', '\x3', '\x2', '\x2', '\x2', '\x8B6', '\x8B7', 
		'\a', '\x256', '\x2', '\x2', '\x8B7', '\x8B8', '\t', '\v', '\x2', '\x2', 
		'\x8B8', '\x9D', '\x3', '\x2', '\x2', '\x2', '\x8B9', '\x8BA', '\a', '\x1A8', 
		'\x2', '\x2', '\x8BA', '\x8BB', '\x5', '\x42', '\"', '\x2', '\x8BB', '\x9F', 
		'\x3', '\x2', '\x2', '\x2', '\x8BC', '\x8BD', '\x5', '\xA2', 'R', '\x2', 
		'\x8BD', '\xA1', '\x3', '\x2', '\x2', '\x2', '\x8BE', '\x8C3', '\x5', 
		'\xA4', 'S', '\x2', '\x8BF', '\x8C0', '\a', '\x170', '\x2', '\x2', '\x8C0', 
		'\x8C2', '\x5', '\xA4', 'S', '\x2', '\x8C1', '\x8BF', '\x3', '\x2', '\x2', 
		'\x2', '\x8C2', '\x8C5', '\x3', '\x2', '\x2', '\x2', '\x8C3', '\x8C1', 
		'\x3', '\x2', '\x2', '\x2', '\x8C3', '\x8C4', '\x3', '\x2', '\x2', '\x2', 
		'\x8C4', '\xA3', '\x3', '\x2', '\x2', '\x2', '\x8C5', '\x8C3', '\x3', 
		'\x2', '\x2', '\x2', '\x8C6', '\x8CB', '\x5', '\xA6', 'T', '\x2', '\x8C7', 
		'\x8C8', '\a', '\x10', '\x2', '\x2', '\x8C8', '\x8CA', '\x5', '\xA6', 
		'T', '\x2', '\x8C9', '\x8C7', '\x3', '\x2', '\x2', '\x2', '\x8CA', '\x8CD', 
		'\x3', '\x2', '\x2', '\x2', '\x8CB', '\x8C9', '\x3', '\x2', '\x2', '\x2', 
		'\x8CB', '\x8CC', '\x3', '\x2', '\x2', '\x2', '\x8CC', '\xA5', '\x3', 
		'\x2', '\x2', '\x2', '\x8CD', '\x8CB', '\x3', '\x2', '\x2', '\x2', '\x8CE', 
		'\x8D0', '\a', '\x15C', '\x2', '\x2', '\x8CF', '\x8CE', '\x3', '\x2', 
		'\x2', '\x2', '\x8CF', '\x8D0', '\x3', '\x2', '\x2', '\x2', '\x8D0', '\x8D3', 
		'\x3', '\x2', '\x2', '\x2', '\x8D1', '\x8D4', '\x5', '\xA8', 'U', '\x2', 
		'\x8D2', '\x8D4', '\x5', '\xAE', 'X', '\x2', '\x8D3', '\x8D1', '\x3', 
		'\x2', '\x2', '\x2', '\x8D3', '\x8D2', '\x3', '\x2', '\x2', '\x2', '\x8D4', 
		'\xA7', '\x3', '\x2', '\x2', '\x2', '\x8D5', '\x8D6', '\x5', '\xAA', 'V', 
		'\x2', '\x8D6', '\x8D7', '\x5', '\x42', '\"', '\x2', '\x8D7', '\x8DD', 
		'\x3', '\x2', '\x2', '\x2', '\x8D8', '\x8D9', '\x5', '\xAC', 'W', '\x2', 
		'\x8D9', '\x8DA', '\x5', '\x160', '\xB1', '\x2', '\x8DA', '\x8DD', '\x3', 
		'\x2', '\x2', '\x2', '\x8DB', '\x8DD', '\x5', '\x146', '\xA4', '\x2', 
		'\x8DC', '\x8D5', '\x3', '\x2', '\x2', '\x2', '\x8DC', '\x8D8', '\x3', 
		'\x2', '\x2', '\x2', '\x8DC', '\x8DB', '\x3', '\x2', '\x2', '\x2', '\x8DD', 
		'\xA9', '\x3', '\x2', '\x2', '\x2', '\x8DE', '\x8DF', '\a', 'h', '\x2', 
		'\x2', '\x8DF', '\x8E0', '\a', '\x164', '\x2', '\x2', '\x8E0', '\xAB', 
		'\x3', '\x2', '\x2', '\x2', '\x8E1', '\x8E2', '\a', '\xAB', '\x2', '\x2', 
		'\x8E2', '\xAD', '\x3', '\x2', '\x2', '\x2', '\x8E3', '\x915', '\x5', 
		'\xC6', '\x64', '\x2', '\x8E4', '\x8EF', '\x5', '\x15E', '\xB0', '\x2', 
		'\x8E5', '\x8E9', '\x5', '\xB2', 'Z', '\x2', '\x8E6', '\x8E9', '\x5', 
		'\xB4', '[', '\x2', '\x8E7', '\x8E9', '\x5', '\xB6', '\\', '\x2', '\x8E8', 
		'\x8E5', '\x3', '\x2', '\x2', '\x2', '\x8E8', '\x8E6', '\x3', '\x2', '\x2', 
		'\x2', '\x8E8', '\x8E7', '\x3', '\x2', '\x2', '\x2', '\x8E9', '\x8EC', 
		'\x3', '\x2', '\x2', '\x2', '\x8EA', '\x8ED', '\x5', '\x160', '\xB1', 
		'\x2', '\x8EB', '\x8ED', '\x5', '\x14A', '\xA6', '\x2', '\x8EC', '\x8EA', 
		'\x3', '\x2', '\x2', '\x2', '\x8EC', '\x8EB', '\x3', '\x2', '\x2', '\x2', 
		'\x8ED', '\x8F0', '\x3', '\x2', '\x2', '\x2', '\x8EE', '\x8F0', '\x5', 
		'\xC6', '\x64', '\x2', '\x8EF', '\x8E8', '\x3', '\x2', '\x2', '\x2', '\x8EF', 
		'\x8EE', '\x3', '\x2', '\x2', '\x2', '\x8F0', '\x916', '\x3', '\x2', '\x2', 
		'\x2', '\x8F1', '\x916', '\x5', '\x14C', '\xA7', '\x2', '\x8F2', '\x916', 
		'\x5', '\xC2', '\x62', '\x2', '\x8F3', '\x8F5', '\x5', '\xB8', ']', '\x2', 
		'\x8F4', '\x8F3', '\x3', '\x2', '\x2', '\x2', '\x8F4', '\x8F5', '\x3', 
		'\x2', '\x2', '\x2', '\x8F5', '\x8F6', '\x3', '\x2', '\x2', '\x2', '\x8F6', 
		'\x8F7', '\x5', '\x15A', '\xAE', '\x2', '\x8F7', '\x8F8', '\x5', '\xC6', 
		'\x64', '\x2', '\x8F8', '\x8F9', '\x5', '\x15C', '\xAF', '\x2', '\x8F9', 
		'\x8FA', '\x5', '\xC6', '\x64', '\x2', '\x8FA', '\x916', '\x3', '\x2', 
		'\x2', '\x2', '\x8FB', '\x8FD', '\x5', '\xBA', '^', '\x2', '\x8FC', '\x8FE', 
		'\x5', '\xB8', ']', '\x2', '\x8FD', '\x8FC', '\x3', '\x2', '\x2', '\x2', 
		'\x8FD', '\x8FE', '\x3', '\x2', '\x2', '\x2', '\x8FE', '\x8FF', '\x3', 
		'\x2', '\x2', '\x2', '\x8FF', '\x900', '\x5', '\x11A', '\x8E', '\x2', 
		'\x900', '\x916', '\x3', '\x2', '\x2', '\x2', '\x901', '\x903', '\x5', 
		'\xB8', ']', '\x2', '\x902', '\x901', '\x3', '\x2', '\x2', '\x2', '\x902', 
		'\x903', '\x3', '\x2', '\x2', '\x2', '\x903', '\x904', '\x3', '\x2', '\x2', 
		'\x2', '\x904', '\x905', '\x5', '\x156', '\xAC', '\x2', '\x905', '\x907', 
		'\x5', '\xC6', '\x64', '\x2', '\x906', '\x908', '\x5', '\x158', '\xAD', 
		'\x2', '\x907', '\x906', '\x3', '\x2', '\x2', '\x2', '\x907', '\x908', 
		'\x3', '\x2', '\x2', '\x2', '\x908', '\x916', '\x3', '\x2', '\x2', '\x2', 
		'\x909', '\x90B', '\x5', '\xB8', ']', '\x2', '\x90A', '\x909', '\x3', 
		'\x2', '\x2', '\x2', '\x90A', '\x90B', '\x3', '\x2', '\x2', '\x2', '\x90B', 
		'\x90C', '\x3', '\x2', '\x2', '\x2', '\x90C', '\x913', '\x5', '\xBC', 
		'_', '\x2', '\x90D', '\x914', '\x5', '\x160', '\xB1', '\x2', '\x90E', 
		'\x914', '\x5', '\xB0', 'Y', '\x2', '\x90F', '\x910', '\x5', '\xBE', '`', 
		'\x2', '\x910', '\x911', '\x5', '\x16A', '\xB6', '\x2', '\x911', '\x912', 
		'\x5', '\xC0', '\x61', '\x2', '\x912', '\x914', '\x3', '\x2', '\x2', '\x2', 
		'\x913', '\x90D', '\x3', '\x2', '\x2', '\x2', '\x913', '\x90E', '\x3', 
		'\x2', '\x2', '\x2', '\x913', '\x90F', '\x3', '\x2', '\x2', '\x2', '\x914', 
		'\x916', '\x3', '\x2', '\x2', '\x2', '\x915', '\x8E4', '\x3', '\x2', '\x2', 
		'\x2', '\x915', '\x8F1', '\x3', '\x2', '\x2', '\x2', '\x915', '\x8F2', 
		'\x3', '\x2', '\x2', '\x2', '\x915', '\x8F4', '\x3', '\x2', '\x2', '\x2', 
		'\x915', '\x8FB', '\x3', '\x2', '\x2', '\x2', '\x915', '\x902', '\x3', 
		'\x2', '\x2', '\x2', '\x915', '\x90A', '\x3', '\x2', '\x2', '\x2', '\x915', 
		'\x916', '\x3', '\x2', '\x2', '\x2', '\x916', '\xAF', '\x3', '\x2', '\x2', 
		'\x2', '\x917', '\x918', '\x5', '\xC6', '\x64', '\x2', '\x918', '\xB1', 
		'\x3', '\x2', '\x2', '\x2', '\x919', '\x91A', '\a', '\x11', '\x2', '\x2', 
		'\x91A', '\xB3', '\x3', '\x2', '\x2', '\x2', '\x91B', '\x91C', '\a', '\x1E3', 
		'\x2', '\x2', '\x91C', '\xB5', '\x3', '\x2', '\x2', '\x2', '\x91D', '\x91E', 
		'\a', '\n', '\x2', '\x2', '\x91E', '\xB7', '\x3', '\x2', '\x2', '\x2', 
		'\x91F', '\x920', '\a', '\x15C', '\x2', '\x2', '\x920', '\xB9', '\x3', 
		'\x2', '\x2', '\x2', '\x921', '\x922', '\a', '\xF7', '\x2', '\x2', '\x922', 
		'\xBB', '\x3', '\x2', '\x2', '\x2', '\x923', '\x924', '\a', '\xDE', '\x2', 
		'\x2', '\x924', '\xBD', '\x3', '\x2', '\x2', '\x2', '\x925', '\x926', 
		'\a', '\x24D', '\x2', '\x2', '\x926', '\xBF', '\x3', '\x2', '\x2', '\x2', 
		'\x927', '\x928', '\a', '\x24E', '\x2', '\x2', '\x928', '\xC1', '\x3', 
		'\x2', '\x2', '\x2', '\x929', '\x92B', '\a', '\xF7', '\x2', '\x2', '\x92A', 
		'\x92C', '\a', '\x15C', '\x2', '\x2', '\x92B', '\x92A', '\x3', '\x2', 
		'\x2', '\x2', '\x92B', '\x92C', '\x3', '\x2', '\x2', '\x2', '\x92C', '\x92D', 
		'\x3', '\x2', '\x2', '\x2', '\x92D', '\x92F', '\a', '\x164', '\x2', '\x2', 
		'\x92E', '\x930', '\a', '\x215', '\x2', '\x2', '\x92F', '\x92E', '\x3', 
		'\x2', '\x2', '\x2', '\x92F', '\x930', '\x3', '\x2', '\x2', '\x2', '\x930', 
		'\x931', '\x3', '\x2', '\x2', '\x2', '\x931', '\x932', '\x5', '\xC4', 
		'\x63', '\x2', '\x932', '\xC3', '\x3', '\x2', '\x2', '\x2', '\x933', '\x935', 
		'\a', '\x24D', '\x2', '\x2', '\x934', '\x936', '\a', '\x169', '\x2', '\x2', 
		'\x935', '\x934', '\x3', '\x2', '\x2', '\x2', '\x935', '\x936', '\x3', 
		'\x2', '\x2', '\x2', '\x936', '\x937', '\x3', '\x2', '\x2', '\x2', '\x937', 
		'\x93C', '\x5', '\x44', '#', '\x2', '\x938', '\x939', '\a', '\x24F', '\x2', 
		'\x2', '\x939', '\x93B', '\x5', '\x44', '#', '\x2', '\x93A', '\x938', 
		'\x3', '\x2', '\x2', '\x2', '\x93B', '\x93E', '\x3', '\x2', '\x2', '\x2', 
		'\x93C', '\x93A', '\x3', '\x2', '\x2', '\x2', '\x93C', '\x93D', '\x3', 
		'\x2', '\x2', '\x2', '\x93D', '\x93F', '\x3', '\x2', '\x2', '\x2', '\x93E', 
		'\x93C', '\x3', '\x2', '\x2', '\x2', '\x93F', '\x940', '\a', '\x24E', 
		'\x2', '\x2', '\x940', '\xC5', '\x3', '\x2', '\x2', '\x2', '\x941', '\x944', 
		'\x5', '\xC8', '\x65', '\x2', '\x942', '\x944', '\x5', 'J', '&', '\x2', 
		'\x943', '\x941', '\x3', '\x2', '\x2', '\x2', '\x943', '\x942', '\x3', 
		'\x2', '\x2', '\x2', '\x944', '\xC7', '\x3', '\x2', '\x2', '\x2', '\x945', 
		'\x94B', '\x5', '\xCA', '\x66', '\x2', '\x946', '\x947', '\x5', '\xCC', 
		'g', '\x2', '\x947', '\x948', '\x5', '\xCA', '\x66', '\x2', '\x948', '\x94A', 
		'\x3', '\x2', '\x2', '\x2', '\x949', '\x946', '\x3', '\x2', '\x2', '\x2', 
		'\x94A', '\x94D', '\x3', '\x2', '\x2', '\x2', '\x94B', '\x949', '\x3', 
		'\x2', '\x2', '\x2', '\x94B', '\x94C', '\x3', '\x2', '\x2', '\x2', '\x94C', 
		'\xC9', '\x3', '\x2', '\x2', '\x2', '\x94D', '\x94B', '\x3', '\x2', '\x2', 
		'\x2', '\x94E', '\x954', '\x5', '\x112', '\x8A', '\x2', '\x94F', '\x950', 
		'\x5', '\xCE', 'h', '\x2', '\x950', '\x951', '\x5', '\x112', '\x8A', '\x2', 
		'\x951', '\x953', '\x3', '\x2', '\x2', '\x2', '\x952', '\x94F', '\x3', 
		'\x2', '\x2', '\x2', '\x953', '\x956', '\x3', '\x2', '\x2', '\x2', '\x954', 
		'\x952', '\x3', '\x2', '\x2', '\x2', '\x954', '\x955', '\x3', '\x2', '\x2', 
		'\x2', '\x955', '\xCB', '\x3', '\x2', '\x2', '\x2', '\x956', '\x954', 
		'\x3', '\x2', '\x2', '\x2', '\x957', '\x958', '\t', '\f', '\x2', '\x2', 
		'\x958', '\xCD', '\x3', '\x2', '\x2', '\x2', '\x959', '\x95A', '\t', '\r', 
		'\x2', '\x2', '\x95A', '\xCF', '\x3', '\x2', '\x2', '\x2', '\x95B', '\x97F', 
		'\x5', '\x114', '\x8B', '\x2', '\x95C', '\x97F', '\x5', '&', '\x14', '\x2', 
		'\x95D', '\x97F', '\x5', '\x11C', '\x8F', '\x2', '\x95E', '\x97F', '\x5', 
		'\x11E', '\x90', '\x2', '\x95F', '\x97F', '\x5', '\x132', '\x9A', '\x2', 
		'\x960', '\x97F', '\x5', '\xDE', 'p', '\x2', '\x961', '\x97F', '\x5', 
		'\x120', '\x91', '\x2', '\x962', '\x97F', '\x5', '\x136', '\x9C', '\x2', 
		'\x963', '\x97F', '\x5', '\x138', '\x9D', '\x2', '\x964', '\x97F', '\x5', 
		'\x13A', '\x9E', '\x2', '\x965', '\x97F', '\x5', '\xDC', 'o', '\x2', '\x966', 
		'\x967', '\a', '\x259', '\x2', '\x2', '\x967', '\x97F', '\x5', '\xD0', 
		'i', '\x2', '\x968', '\x969', '\a', '\x258', '\x2', '\x2', '\x969', '\x97F', 
		'\x5', '\xD0', 'i', '\x2', '\x96A', '\x97F', '\x5', '\x12C', '\x97', '\x2', 
		'\x96B', '\x97F', '\x5', '\x12E', '\x98', '\x2', '\x96C', '\x97F', '\x5', 
		'\x130', '\x99', '\x2', '\x96D', '\x97F', '\x5', '\x554', '\x2AB', '\x2', 
		'\x96E', '\x97F', '\x5', '\x556', '\x2AC', '\x2', '\x96F', '\x97F', '\x5', 
		'\x160', '\xB1', '\x2', '\x970', '\x971', '\a', '\x24D', '\x2', '\x2', 
		'\x971', '\x972', '\x5', '\xA0', 'Q', '\x2', '\x972', '\x973', '\a', '\x24E', 
		'\x2', '\x2', '\x973', '\x97F', '\x3', '\x2', '\x2', '\x2', '\x974', '\x97F', 
		'\x5', '\x172', '\xBA', '\x2', '\x975', '\x97F', '\x5', '\x108', '\x85', 
		'\x2', '\x976', '\x97F', '\x5', '\x10A', '\x86', '\x2', '\x977', '\x97F', 
		'\x5', '\xF8', '}', '\x2', '\x978', '\x97F', '\x5', '\xF4', '{', '\x2', 
		'\x979', '\x97F', '\x5', '\xF0', 'y', '\x2', '\x97A', '\x97F', '\x5', 
		'\x42', '\"', '\x2', '\x97B', '\x97F', '\x5', '^', '\x30', '\x2', '\x97C', 
		'\x97F', '\x5', '\xD2', 'j', '\x2', '\x97D', '\x97F', '\x5', '\xDA', 'n', 
		'\x2', '\x97E', '\x95B', '\x3', '\x2', '\x2', '\x2', '\x97E', '\x95C', 
		'\x3', '\x2', '\x2', '\x2', '\x97E', '\x95D', '\x3', '\x2', '\x2', '\x2', 
		'\x97E', '\x95E', '\x3', '\x2', '\x2', '\x2', '\x97E', '\x95F', '\x3', 
		'\x2', '\x2', '\x2', '\x97E', '\x960', '\x3', '\x2', '\x2', '\x2', '\x97E', 
		'\x961', '\x3', '\x2', '\x2', '\x2', '\x97E', '\x962', '\x3', '\x2', '\x2', 
		'\x2', '\x97E', '\x963', '\x3', '\x2', '\x2', '\x2', '\x97E', '\x964', 
		'\x3', '\x2', '\x2', '\x2', '\x97E', '\x965', '\x3', '\x2', '\x2', '\x2', 
		'\x97E', '\x966', '\x3', '\x2', '\x2', '\x2', '\x97E', '\x968', '\x3', 
		'\x2', '\x2', '\x2', '\x97E', '\x96A', '\x3', '\x2', '\x2', '\x2', '\x97E', 
		'\x96B', '\x3', '\x2', '\x2', '\x2', '\x97E', '\x96C', '\x3', '\x2', '\x2', 
		'\x2', '\x97E', '\x96D', '\x3', '\x2', '\x2', '\x2', '\x97E', '\x96E', 
		'\x3', '\x2', '\x2', '\x2', '\x97E', '\x96F', '\x3', '\x2', '\x2', '\x2', 
		'\x97E', '\x970', '\x3', '\x2', '\x2', '\x2', '\x97E', '\x974', '\x3', 
		'\x2', '\x2', '\x2', '\x97E', '\x975', '\x3', '\x2', '\x2', '\x2', '\x97E', 
		'\x976', '\x3', '\x2', '\x2', '\x2', '\x97E', '\x977', '\x3', '\x2', '\x2', 
		'\x2', '\x97E', '\x978', '\x3', '\x2', '\x2', '\x2', '\x97E', '\x979', 
		'\x3', '\x2', '\x2', '\x2', '\x97E', '\x97A', '\x3', '\x2', '\x2', '\x2', 
		'\x97E', '\x97B', '\x3', '\x2', '\x2', '\x2', '\x97E', '\x97C', '\x3', 
		'\x2', '\x2', '\x2', '\x97E', '\x97D', '\x3', '\x2', '\x2', '\x2', '\x97F', 
		'\x981', '\x3', '\x2', '\x2', '\x2', '\x980', '\x982', '\x5', '\xEA', 
		'v', '\x2', '\x981', '\x980', '\x3', '\x2', '\x2', '\x2', '\x981', '\x982', 
		'\x3', '\x2', '\x2', '\x2', '\x982', '\xD1', '\x3', '\x2', '\x2', '\x2', 
		'\x983', '\x984', '\x5', '\xD4', 'k', '\x2', '\x984', '\xD3', '\x3', '\x2', 
		'\x2', '\x2', '\x985', '\x986', '\a', '\x241', '\x2', '\x2', '\x986', 
		'\x987', '\a', '\x24D', '\x2', '\x2', '\x987', '\x988', '\x5', '\xC6', 
		'\x64', '\x2', '\x988', '\x98B', '\a', '\x182', '\x2', '\x2', '\x989', 
		'\x98A', '\a', '\x33', '\x2', '\x2', '\x98A', '\x98C', '\a', '\x227', 
		'\x2', '\x2', '\x98B', '\x989', '\x3', '\x2', '\x2', '\x2', '\x98B', '\x98C', 
		'\x3', '\x2', '\x2', '\x2', '\x98C', '\x98D', '\x3', '\x2', '\x2', '\x2', 
		'\x98D', '\x98E', '\x5', '\xD6', 'l', '\x2', '\x98E', '\x98F', '\a', '\x1B7', 
		'\x2', '\x2', '\x98F', '\x990', '\a', '_', '\x2', '\x2', '\x990', '\x991', 
		'\a', '\x24E', '\x2', '\x2', '\x991', '\xD5', '\x3', '\x2', '\x2', '\x2', 
		'\x992', '\x997', '\x5', '\xD8', 'm', '\x2', '\x993', '\x994', '\a', '\x24F', 
		'\x2', '\x2', '\x994', '\x996', '\x5', '\xD8', 'm', '\x2', '\x995', '\x993', 
		'\x3', '\x2', '\x2', '\x2', '\x996', '\x999', '\x3', '\x2', '\x2', '\x2', 
		'\x997', '\x995', '\x3', '\x2', '\x2', '\x2', '\x997', '\x998', '\x3', 
		'\x2', '\x2', '\x2', '\x998', '\xD7', '\x3', '\x2', '\x2', '\x2', '\x999', 
		'\x997', '\x3', '\x2', '\x2', '\x2', '\x99A', '\x99D', '\x5', '\xC6', 
		'\x64', '\x2', '\x99B', '\x99C', '\a', '\x15', '\x2', '\x2', '\x99C', 
		'\x99E', '\x5', '\x42', '\"', '\x2', '\x99D', '\x99B', '\x3', '\x2', '\x2', 
		'\x2', '\x99D', '\x99E', '\x3', '\x2', '\x2', '\x2', '\x99E', '\xD9', 
		'\x3', '\x2', '\x2', '\x2', '\x99F', '\x9A0', '\a', '\x23F', '\x2', '\x2', 
		'\x9A0', '\x9A4', '\a', '\x24D', '\x2', '\x2', '\x9A1', '\x9A2', '\a', 
		'\x137', '\x2', '\x2', '\x9A2', '\x9A5', '\x5', '\x160', '\xB1', '\x2', 
		'\x9A3', '\x9A5', '\x5', '\xA0', 'Q', '\x2', '\x9A4', '\x9A1', '\x3', 
		'\x2', '\x2', '\x2', '\x9A4', '\x9A3', '\x3', '\x2', '\x2', '\x2', '\x9A5', 
		'\x9A6', '\x3', '\x2', '\x2', '\x2', '\x9A6', '\x9A7', '\a', '\x15', '\x2', 
		'\x2', '\x9A7', '\x9A8', '\x5', '`', '\x31', '\x2', '\x9A8', '\x9A9', 
		'\a', '\x24E', '\x2', '\x2', '\x9A9', '\xDB', '\x3', '\x2', '\x2', '\x2', 
		'\x9AA', '\x9AB', '\a', '\x141', '\x2', '\x2', '\x9AB', '\x9AC', '\x5', 
		'\x42', '\"', '\x2', '\x9AC', '\xDD', '\x3', '\x2', '\x2', '\x2', '\x9AD', 
		'\x9AE', '\a', '\x20F', '\x2', '\x2', '\x9AE', '\x9B0', '\x5', '\xE0', 
		'q', '\x2', '\x9AF', '\x9B1', '\x5', '\xE4', 's', '\x2', '\x9B0', '\x9AF', 
		'\x3', '\x2', '\x2', '\x2', '\x9B0', '\x9B1', '\x3', '\x2', '\x2', '\x2', 
		'\x9B1', '\xDF', '\x3', '\x2', '\x2', '\x2', '\x9B2', '\x9B3', '\a', '\x24D', 
		'\x2', '\x2', '\x9B3', '\x9B4', '\x5', '\xA0', 'Q', '\x2', '\x9B4', '\x9B5', 
		'\x5', '\xE2', 'r', '\x2', '\x9B5', '\x9B6', '\a', '\x24E', '\x2', '\x2', 
		'\x9B6', '\xE1', '\x3', '\x2', '\x2', '\x2', '\x9B7', '\x9B9', '\a', '\x15', 
		'\x2', '\x2', '\x9B8', '\x9BA', '\a', '\x1A8', '\x2', '\x2', '\x9B9', 
		'\x9B8', '\x3', '\x2', '\x2', '\x2', '\x9B9', '\x9BA', '\x3', '\x2', '\x2', 
		'\x2', '\x9BA', '\x9BB', '\x3', '\x2', '\x2', '\x2', '\x9BB', '\x9BC', 
		'\x5', '\x44', '#', '\x2', '\x9BC', '\xE3', '\x3', '\x2', '\x2', '\x2', 
		'\x9BD', '\x9BE', '\a', '\x25E', '\x2', '\x2', '\x9BE', '\x9BF', '\x5', 
		'\x42', '\"', '\x2', '\x9BF', '\xE5', '\x3', '\x2', '\x2', '\x2', '\x9C0', 
		'\x9C6', '\x5', '\xD0', 'i', '\x2', '\x9C1', '\x9C2', '\x5', '\xE8', 'u', 
		'\x2', '\x9C2', '\x9C3', '\x5', '\xD0', 'i', '\x2', '\x9C3', '\x9C5', 
		'\x3', '\x2', '\x2', '\x2', '\x9C4', '\x9C1', '\x3', '\x2', '\x2', '\x2', 
		'\x9C5', '\x9C8', '\x3', '\x2', '\x2', '\x2', '\x9C6', '\x9C4', '\x3', 
		'\x2', '\x2', '\x2', '\x9C6', '\x9C7', '\x3', '\x2', '\x2', '\x2', '\x9C7', 
		'\xE7', '\x3', '\x2', '\x2', '\x2', '\x9C8', '\x9C6', '\x3', '\x2', '\x2', 
		'\x2', '\x9C9', '\x9CA', '\a', '\x137', '\x2', '\x2', '\x9CA', '\x9CC', 
		'\t', '\xE', '\x2', '\x2', '\x9CB', '\x9CD', '\t', '\xF', '\x2', '\x2', 
		'\x9CC', '\x9CB', '\x3', '\x2', '\x2', '\x2', '\x9CC', '\x9CD', '\x3', 
		'\x2', '\x2', '\x2', '\x9CD', '\xE9', '\x3', '\x2', '\x2', '\x2', '\x9CE', 
		'\x9D1', '\a', '\x18', '\x2', '\x2', '\x9CF', '\x9D2', '\x5', '\xEC', 
		'w', '\x2', '\x9D0', '\x9D2', '\x5', '\xEE', 'x', '\x2', '\x9D1', '\x9CF', 
		'\x3', '\x2', '\x2', '\x2', '\x9D1', '\x9D0', '\x3', '\x2', '\x2', '\x2', 
		'\x9D2', '\xEB', '\x3', '\x2', '\x2', '\x2', '\x9D3', '\x9D4', '\a', '\x111', 
		'\x2', '\x2', '\x9D4', '\xED', '\x3', '\x2', '\x2', '\x2', '\x9D5', '\x9D6', 
		'\a', '\x205', '\x2', '\x2', '\x9D6', '\x9DA', '\a', '\x246', '\x2', '\x2', 
		'\x9D7', '\x9DB', '\a', 'q', '\x2', '\x2', '\x9D8', '\x9DB', '\a', '\x1D9', 
		'\x2', '\x2', '\x9D9', '\x9DB', '\x5', '\xD0', 'i', '\x2', '\x9DA', '\x9D7', 
		'\x3', '\x2', '\x2', '\x2', '\x9DA', '\x9D8', '\x3', '\x2', '\x2', '\x2', 
		'\x9DA', '\x9D9', '\x3', '\x2', '\x2', '\x2', '\x9DB', '\xEF', '\x3', 
		'\x2', '\x2', '\x2', '\x9DC', '\x9DD', '\x5', '\x42', '\"', '\x2', '\x9DD', 
		'\x9DF', '\x5', '\xF2', 'z', '\x2', '\x9DE', '\x9E0', '\x5', '\xFA', '~', 
		'\x2', '\x9DF', '\x9DE', '\x3', '\x2', '\x2', '\x2', '\x9DF', '\x9E0', 
		'\x3', '\x2', '\x2', '\x2', '\x9E0', '\xF1', '\x3', '\x2', '\x2', '\x2', 
		'\x9E1', '\x9E2', '\a', '\xFE', '\x2', '\x2', '\x9E2', '\x9E3', '\a', 
		'\x24D', '\x2', '\x2', '\x9E3', '\x9E4', '\a', '\x7F', '\x2', '\x2', '\x9E4', 
		'\x9E5', '\t', '\x10', '\x2', '\x2', '\x9E5', '\x9E6', '\x5', '\x404', 
		'\x203', '\x2', '\x9E6', '\x9E7', '\a', '\x24E', '\x2', '\x2', '\x9E7', 
		'\xF3', '\x3', '\x2', '\x2', '\x2', '\x9E8', '\x9E9', '\x5', '\x42', '\"', 
		'\x2', '\x9E9', '\x9EB', '\x5', '\xF6', '|', '\x2', '\x9EA', '\x9EC', 
		'\x5', '\xFA', '~', '\x2', '\x9EB', '\x9EA', '\x3', '\x2', '\x2', '\x2', 
		'\x9EB', '\x9EC', '\x3', '\x2', '\x2', '\x2', '\x9EC', '\xF5', '\x3', 
		'\x2', '\x2', '\x2', '\x9ED', '\x9EE', '\a', '\x237', '\x2', '\x2', '\x9EE', 
		'\x9EF', '\a', '\xD0', '\x2', '\x2', '\x9EF', '\x9F0', '\a', '\x24D', 
		'\x2', '\x2', '\x9F0', '\x9F1', '\x5', '\x402', '\x202', '\x2', '\x9F1', 
		'\x9F2', '\a', '\x24E', '\x2', '\x2', '\x9F2', '\xF7', '\x3', '\x2', '\x2', 
		'\x2', '\x9F3', '\x9F4', '\x5', '\x42', '\"', '\x2', '\x9F4', '\x9F5', 
		'\x5', '\xFA', '~', '\x2', '\x9F5', '\xF9', '\x3', '\x2', '\x2', '\x2', 
		'\x9F6', '\x9F7', '\a', '\x176', '\x2', '\x2', '\x9F7', '\x9F9', '\a', 
		'\x24D', '\x2', '\x2', '\x9F8', '\x9FA', '\x5', '\xFC', '\x7F', '\x2', 
		'\x9F9', '\x9F8', '\x3', '\x2', '\x2', '\x2', '\x9F9', '\x9FA', '\x3', 
		'\x2', '\x2', '\x2', '\x9FA', '\x9FF', '\x3', '\x2', '\x2', '\x2', '\x9FB', 
		'\x9FD', '\x5', '\x400', '\x201', '\x2', '\x9FC', '\x9FE', '\x5', '\xFE', 
		'\x80', '\x2', '\x9FD', '\x9FC', '\x3', '\x2', '\x2', '\x2', '\x9FD', 
		'\x9FE', '\x3', '\x2', '\x2', '\x2', '\x9FE', '\xA00', '\x3', '\x2', '\x2', 
		'\x2', '\x9FF', '\x9FB', '\x3', '\x2', '\x2', '\x2', '\x9FF', '\xA00', 
		'\x3', '\x2', '\x2', '\x2', '\xA00', '\xA01', '\x3', '\x2', '\x2', '\x2', 
		'\xA01', '\xA02', '\a', '\x24E', '\x2', '\x2', '\xA02', '\xFB', '\x3', 
		'\x2', '\x2', '\x2', '\xA03', '\xA04', '\a', '\x180', '\x2', '\x2', '\xA04', 
		'\xA05', '\a', '\x33', '\x2', '\x2', '\xA05', '\xA06', '\x5', '\x16A', 
		'\xB6', '\x2', '\xA06', '\xFD', '\x3', '\x2', '\x2', '\x2', '\xA07', '\xA0A', 
		'\t', '\x11', '\x2', '\x2', '\xA08', '\xA0B', '\x5', '\x100', '\x81', 
		'\x2', '\xA09', '\xA0B', '\x5', '\x102', '\x82', '\x2', '\xA0A', '\xA08', 
		'\x3', '\x2', '\x2', '\x2', '\xA0A', '\xA09', '\x3', '\x2', '\x2', '\x2', 
		'\xA0B', '\xFF', '\x3', '\x2', '\x2', '\x2', '\xA0C', '\xA0D', '\a', '&', 
		'\x2', '\x2', '\xA0D', '\xA0E', '\x5', '\x104', '\x83', '\x2', '\xA0E', 
		'\xA0F', '\a', '\x10', '\x2', '\x2', '\xA0F', '\xA10', '\x5', '\x104', 
		'\x83', '\x2', '\xA10', '\x101', '\x3', '\x2', '\x2', '\x2', '\xA11', 
		'\xA12', '\x5', '\x104', '\x83', '\x2', '\xA12', '\x103', '\x3', '\x2', 
		'\x2', '\x2', '\xA13', '\xA14', '\a', '\x216', '\x2', '\x2', '\xA14', 
		'\xA1B', '\t', '\x12', '\x2', '\x2', '\xA15', '\xA16', '\a', 'h', '\x2', 
		'\x2', '\xA16', '\xA1B', '\a', '\x1BF', '\x2', '\x2', '\xA17', '\xA18', 
		'\x5', '\x106', '\x84', '\x2', '\xA18', '\xA19', '\t', '\x12', '\x2', 
		'\x2', '\xA19', '\xA1B', '\x3', '\x2', '\x2', '\x2', '\xA1A', '\xA13', 
		'\x3', '\x2', '\x2', '\x2', '\xA1A', '\xA15', '\x3', '\x2', '\x2', '\x2', 
		'\xA1A', '\xA17', '\x3', '\x2', '\x2', '\x2', '\xA1B', '\x105', '\x3', 
		'\x2', '\x2', '\x2', '\xA1C', '\xA1D', '\x5', '\xA0', 'Q', '\x2', '\xA1D', 
		'\x107', '\x3', '\x2', '\x2', '\x2', '\xA1E', '\xA1F', '\x5', '\x42', 
		'\"', '\x2', '\xA1F', '\xA20', '\a', '\x256', '\x2', '\x2', '\xA20', '\xA21', 
		'\t', '\x13', '\x2', '\x2', '\xA21', '\x109', '\x3', '\x2', '\x2', '\x2', 
		'\xA22', '\xA23', '\x5', '\x42', '\"', '\x2', '\xA23', '\xA26', '\a', 
		'\x256', '\x2', '\x2', '\xA24', '\xA27', '\x5', '\x10C', '\x87', '\x2', 
		'\xA25', '\xA27', '\x5', '\x10E', '\x88', '\x2', '\xA26', '\xA24', '\x3', 
		'\x2', '\x2', '\x2', '\xA26', '\xA25', '\x3', '\x2', '\x2', '\x2', '\xA27', 
		'\x10B', '\x3', '\x2', '\x2', '\x2', '\xA28', '\xA2F', '\a', '\x31', '\x2', 
		'\x2', '\xA29', '\xA2A', '\a', '\x25E', '\x2', '\x2', '\xA2A', '\xA30', 
		'\a', '\x63', '\x2', '\x2', '\xA2B', '\xA2C', '\x5', '\x110', '\x89', 
		'\x2', '\xA2C', '\xA2D', '\a', '\x25E', '\x2', '\x2', '\xA2D', '\xA2E', 
		'\t', '\x14', '\x2', '\x2', '\xA2E', '\xA30', '\x3', '\x2', '\x2', '\x2', 
		'\xA2F', '\xA29', '\x3', '\x2', '\x2', '\x2', '\xA2F', '\xA2B', '\x3', 
		'\x2', '\x2', '\x2', '\xA30', '\x10D', '\x3', '\x2', '\x2', '\x2', '\xA31', 
		'\xA32', '\a', '\x32', '\x2', '\x2', '\xA32', '\xA33', '\x5', '\x110', 
		'\x89', '\x2', '\xA33', '\x10F', '\x3', '\x2', '\x2', '\x2', '\xA34', 
		'\xA35', '\a', '\x24D', '\x2', '\x2', '\xA35', '\xA36', '\x5', '\xA0', 
		'Q', '\x2', '\xA36', '\xA37', '\a', '\x24E', '\x2', '\x2', '\xA37', '\x111', 
		'\x3', '\x2', '\x2', '\x2', '\xA38', '\xA3B', '\x5', '\xE6', 't', '\x2', 
		'\xA39', '\xA3A', '\a', '\x24B', '\x2', '\x2', '\xA3A', '\xA3C', '\x5', 
		'\xE6', 't', '\x2', '\xA3B', '\xA39', '\x3', '\x2', '\x2', '\x2', '\xA3B', 
		'\xA3C', '\x3', '\x2', '\x2', '\x2', '\xA3C', '\x113', '\x3', '\x2', '\x2', 
		'\x2', '\xA3D', '\xA3E', '\a', '\x160', '\x2', '\x2', '\xA3E', '\x115', 
		'\x3', '\x2', '\x2', '\x2', '\xA3F', '\xA40', '\a', '\x139', '\x2', '\x2', 
		'\xA40', '\x117', '\x3', '\x2', '\x2', '\x2', '\xA41', '\xA42', '\a', 
		'\xE7', '\x2', '\x2', '\xA42', '\x119', '\x3', '\x2', '\x2', '\x2', '\xA43', 
		'\xA47', '\x5', '\x114', '\x8B', '\x2', '\xA44', '\xA47', '\x5', '\x116', 
		'\x8C', '\x2', '\xA45', '\xA47', '\x5', '\x118', '\x8D', '\x2', '\xA46', 
		'\xA43', '\x3', '\x2', '\x2', '\x2', '\xA46', '\xA44', '\x3', '\x2', '\x2', 
		'\x2', '\xA46', '\xA45', '\x3', '\x2', '\x2', '\x2', '\xA47', '\x11B', 
		'\x3', '\x2', '\x2', '\x2', '\xA48', '\xA49', '\a', ':', '\x2', '\x2', 
		'\xA49', '\xA4D', '\a', '\x24D', '\x2', '\x2', '\xA4A', '\xA4B', '\a', 
		'\x137', '\x2', '\x2', '\xA4B', '\xA4E', '\x5', '\x160', '\xB1', '\x2', 
		'\xA4C', '\xA4E', '\x5', '\xA0', 'Q', '\x2', '\xA4D', '\xA4A', '\x3', 
		'\x2', '\x2', '\x2', '\xA4D', '\xA4C', '\x3', '\x2', '\x2', '\x2', '\xA4E', 
		'\xA4F', '\x3', '\x2', '\x2', '\x2', '\xA4F', '\xA50', '\a', '\x15', '\x2', 
		'\x2', '\xA50', '\xA51', '\x5', '`', '\x31', '\x2', '\xA51', '\xA52', 
		'\a', '\x24E', '\x2', '\x2', '\xA52', '\x11D', '\x3', '\x2', '\x2', '\x2', 
		'\xA53', '\xA54', '\a', 'j', '\x2', '\x2', '\xA54', '\xA55', '\a', '\x24D', 
		'\x2', '\x2', '\xA55', '\xA56', '\x5', '\x3F6', '\x1FC', '\x2', '\xA56', 
		'\xA57', '\a', '\x24E', '\x2', '\x2', '\xA57', '\x11F', '\x3', '\x2', 
		'\x2', '\x2', '\xA58', '\xA5B', '\a', '\x39', '\x2', '\x2', '\xA59', '\xA5C', 
		'\x5', '\x128', '\x95', '\x2', '\xA5A', '\xA5C', '\x5', '\x122', '\x92', 
		'\x2', '\xA5B', '\xA59', '\x3', '\x2', '\x2', '\x2', '\xA5B', '\xA5A', 
		'\x3', '\x2', '\x2', '\x2', '\xA5C', '\xA5D', '\x3', '\x2', '\x2', '\x2', 
		'\xA5D', '\xA5E', '\a', '\x9C', '\x2', '\x2', '\xA5E', '\x121', '\x3', 
		'\x2', '\x2', '\x2', '\xA5F', '\xA61', '\x5', '\xA0', 'Q', '\x2', '\xA60', 
		'\xA62', '\x5', '\x124', '\x93', '\x2', '\xA61', '\xA60', '\x3', '\x2', 
		'\x2', '\x2', '\xA62', '\xA63', '\x3', '\x2', '\x2', '\x2', '\xA63', '\xA61', 
		'\x3', '\x2', '\x2', '\x2', '\xA63', '\xA64', '\x3', '\x2', '\x2', '\x2', 
		'\xA64', '\xA66', '\x3', '\x2', '\x2', '\x2', '\xA65', '\xA67', '\x5', 
		'\x126', '\x94', '\x2', '\xA66', '\xA65', '\x3', '\x2', '\x2', '\x2', 
		'\xA66', '\xA67', '\x3', '\x2', '\x2', '\x2', '\xA67', '\x123', '\x3', 
		'\x2', '\x2', '\x2', '\xA68', '\xA69', '\a', '\x233', '\x2', '\x2', '\xA69', 
		'\xA6A', '\x5', '\xA0', 'Q', '\x2', '\xA6A', '\xA6B', '\a', '\x204', '\x2', 
		'\x2', '\xA6B', '\xA6C', '\x5', '\xA0', 'Q', '\x2', '\xA6C', '\x125', 
		'\x3', '\x2', '\x2', '\x2', '\xA6D', '\xA6E', '\a', '\x97', '\x2', '\x2', 
		'\xA6E', '\xA6F', '\x5', '\xA0', 'Q', '\x2', '\xA6F', '\x127', '\x3', 
		'\x2', '\x2', '\x2', '\xA70', '\xA72', '\x5', '\x12A', '\x96', '\x2', 
		'\xA71', '\xA70', '\x3', '\x2', '\x2', '\x2', '\xA72', '\xA73', '\x3', 
		'\x2', '\x2', '\x2', '\xA73', '\xA71', '\x3', '\x2', '\x2', '\x2', '\xA73', 
		'\xA74', '\x3', '\x2', '\x2', '\x2', '\xA74', '\xA76', '\x3', '\x2', '\x2', 
		'\x2', '\xA75', '\xA77', '\x5', '\x126', '\x94', '\x2', '\xA76', '\xA75', 
		'\x3', '\x2', '\x2', '\x2', '\xA76', '\xA77', '\x3', '\x2', '\x2', '\x2', 
		'\xA77', '\x129', '\x3', '\x2', '\x2', '\x2', '\xA78', '\xA79', '\a', 
		'\x233', '\x2', '\x2', '\xA79', '\xA7A', '\x5', '\xA0', 'Q', '\x2', '\xA7A', 
		'\xA7B', '\a', '\x204', '\x2', '\x2', '\xA7B', '\xA7C', '\x5', '\xA0', 
		'Q', '\x2', '\xA7C', '\x12B', '\x3', '\x2', '\x2', '\x2', '\xA7D', '\xA7E', 
		'\a', '\x196', '\x2', '\x2', '\xA7E', '\xA7F', '\x5', '\xD0', 'i', '\x2', 
		'\xA7F', '\x12D', '\x3', '\x2', '\x2', '\x2', '\xA80', '\xA81', '\a', 
		'Y', '\x2', '\x2', '\xA81', '\xA82', '\x5', '\xD0', 'i', '\x2', '\xA82', 
		'\x12F', '\x3', '\x2', '\x2', '\x2', '\xA83', '\xA84', '\a', '\x1FB', 
		'\x2', '\x2', '\xA84', '\xA85', '\x5', 'X', '-', '\x2', '\xA85', '\x131', 
		'\x3', '\x2', '\x2', '\x2', '\xA86', '\xA87', '\a', '\x211', '\x2', '\x2', 
		'\xA87', '\xA89', '\a', '\x24D', '\x2', '\x2', '\xA88', '\xA8A', '\x5', 
		'\x134', '\x9B', '\x2', '\xA89', '\xA88', '\x3', '\x2', '\x2', '\x2', 
		'\xA89', '\xA8A', '\x3', '\x2', '\x2', '\x2', '\xA8A', '\xA8B', '\x3', 
		'\x2', '\x2', '\x2', '\xA8B', '\xA8C', '\x5', '\xA0', 'Q', '\x2', '\xA8C', 
		'\xA8D', '\a', '\x24E', '\x2', '\x2', '\xA8D', '\x133', '\x3', '\x2', 
		'\x2', '\x2', '\xA8E', '\xA90', '\t', '\x15', '\x2', '\x2', '\xA8F', '\xA91', 
		'\x5', '\xA0', 'Q', '\x2', '\xA90', '\xA8F', '\x3', '\x2', '\x2', '\x2', 
		'\xA90', '\xA91', '\x3', '\x2', '\x2', '\x2', '\xA91', '\xA94', '\x3', 
		'\x2', '\x2', '\x2', '\xA92', '\xA94', '\x5', '\xA0', 'Q', '\x2', '\xA93', 
		'\xA8E', '\x3', '\x2', '\x2', '\x2', '\xA93', '\xA92', '\x3', '\x2', '\x2', 
		'\x2', '\xA94', '\xA95', '\x3', '\x2', '\x2', '\x2', '\xA95', '\xA96', 
		'\a', '\xC8', '\x2', '\x2', '\xA96', '\x135', '\x3', '\x2', '\x2', '\x2', 
		'\xA97', '\xA98', '\a', 'v', '\x2', '\x2', '\xA98', '\xA99', '\a', '\x24D', 
		'\x2', '\x2', '\xA99', '\xA9E', '\x5', '\xA0', 'Q', '\x2', '\xA9A', '\xA9B', 
		'\a', '\x24F', '\x2', '\x2', '\xA9B', '\xA9D', '\x5', '\xA0', 'Q', '\x2', 
		'\xA9C', '\xA9A', '\x3', '\x2', '\x2', '\x2', '\xA9D', '\xAA0', '\x3', 
		'\x2', '\x2', '\x2', '\xA9E', '\xA9C', '\x3', '\x2', '\x2', '\x2', '\xA9E', 
		'\xA9F', '\x3', '\x2', '\x2', '\x2', '\xA9F', '\xAA1', '\x3', '\x2', '\x2', 
		'\x2', '\xAA0', '\xA9E', '\x3', '\x2', '\x2', '\x2', '\xAA1', '\xAA2', 
		'\a', '\x24E', '\x2', '\x2', '\xAA2', '\x137', '\x3', '\x2', '\x2', '\x2', 
		'\xAA3', '\xAA4', '\a', '\xB2', '\x2', '\x2', '\xAA4', '\xAA5', '\a', 
		'\x24D', '\x2', '\x2', '\xAA5', '\xAA6', '\t', '\x16', '\x2', '\x2', '\xAA6', 
		'\xAA7', '\x5', '\x142', '\xA2', '\x2', '\xAA7', '\xAA8', '\a', '\x24E', 
		'\x2', '\x2', '\xAA8', '\x139', '\x3', '\x2', '\x2', '\x2', '\xAA9', '\xAAA', 
		'\t', '\x17', '\x2', '\x2', '\xAAA', '\xAAB', '\a', '\x24D', '\x2', '\x2', 
		'\xAAB', '\xAAC', '\x5', '\x13C', '\x9F', '\x2', '\xAAC', '\xAAD', '\a', 
		'\x24F', '\x2', '\x2', '\xAAD', '\xAB0', '\x5', '\x13E', '\xA0', '\x2', 
		'\xAAE', '\xAAF', '\a', '\x24F', '\x2', '\x2', '\xAAF', '\xAB1', '\x5', 
		'\x140', '\xA1', '\x2', '\xAB0', '\xAAE', '\x3', '\x2', '\x2', '\x2', 
		'\xAB0', '\xAB1', '\x3', '\x2', '\x2', '\x2', '\xAB1', '\xAB2', '\x3', 
		'\x2', '\x2', '\x2', '\xAB2', '\xAB3', '\a', '\x24E', '\x2', '\x2', '\xAB3', 
		'\x13B', '\x3', '\x2', '\x2', '\x2', '\xAB4', '\xAB5', '\x5', '\x170', 
		'\xB9', '\x2', '\xAB5', '\x13D', '\x3', '\x2', '\x2', '\x2', '\xAB6', 
		'\xAB7', '\x5', '\xC6', '\x64', '\x2', '\xAB7', '\x13F', '\x3', '\x2', 
		'\x2', '\x2', '\xAB8', '\xAB9', '\x5', '\xC6', '\x64', '\x2', '\xAB9', 
		'\x141', '\x3', '\x2', '\x2', '\x2', '\xABA', '\xABC', '\a', '\xC8', '\x2', 
		'\x2', '\xABB', '\xABD', '\x5', '\x144', '\xA3', '\x2', '\xABC', '\xABB', 
		'\x3', '\x2', '\x2', '\x2', '\xABC', '\xABD', '\x3', '\x2', '\x2', '\x2', 
		'\xABD', '\xABE', '\x3', '\x2', '\x2', '\x2', '\xABE', '\xABF', '\x5', 
		'\xA0', 'Q', '\x2', '\xABF', '\x143', '\x3', '\x2', '\x2', '\x2', '\xAC0', 
		'\xAC1', '\a', 'o', '\x2', '\x2', '\xAC1', '\x145', '\x3', '\x2', '\x2', 
		'\x2', '\xAC2', '\xAD2', '\x5', '\x148', '\xA5', '\x2', '\xAC3', '\xAC4', 
		'\x5', '\xBE', '`', '\x2', '\xAC4', '\xAC5', '\x5', '\x16C', '\xB7', '\x2', 
		'\xAC5', '\xACB', '\x5', '\xC0', '\x61', '\x2', '\xAC6', '\xAC8', '\x5', 
		'\xB8', ']', '\x2', '\xAC7', '\xAC6', '\x3', '\x2', '\x2', '\x2', '\xAC7', 
		'\xAC8', '\x3', '\x2', '\x2', '\x2', '\xAC8', '\xAC9', '\x3', '\x2', '\x2', 
		'\x2', '\xAC9', '\xACC', '\x5', '\xBC', '_', '\x2', '\xACA', '\xACC', 
		'\x5', '\x15E', '\xB0', '\x2', '\xACB', '\xAC7', '\x3', '\x2', '\x2', 
		'\x2', '\xACB', '\xACA', '\x3', '\x2', '\x2', '\x2', '\xACC', '\xACF', 
		'\x3', '\x2', '\x2', '\x2', '\xACD', '\xAD0', '\x5', '\x14A', '\xA6', 
		'\x2', '\xACE', '\xAD0', '\x5', '\x160', '\xB1', '\x2', '\xACF', '\xACD', 
		'\x3', '\x2', '\x2', '\x2', '\xACF', '\xACE', '\x3', '\x2', '\x2', '\x2', 
		'\xAD0', '\xAD2', '\x3', '\x2', '\x2', '\x2', '\xAD1', '\xAC2', '\x3', 
		'\x2', '\x2', '\x2', '\xAD1', '\xAC3', '\x3', '\x2', '\x2', '\x2', '\xAD2', 
		'\x147', '\x3', '\x2', '\x2', '\x2', '\xAD3', '\xAD4', '\x5', '\x352', 
		'\x1AA', '\x2', '\xAD4', '\xAD5', '\a', '\x178', '\x2', '\x2', '\xAD5', 
		'\xAD6', '\x5', '\x352', '\x1AA', '\x2', '\xAD6', '\x149', '\x3', '\x2', 
		'\x2', '\x2', '\xAD7', '\xAE1', '\a', '\x24D', '\x2', '\x2', '\xAD8', 
		'\xAE2', '\x5', '\x16A', '\xB6', '\x2', '\xAD9', '\xADE', '\x5', '\x14A', 
		'\xA6', '\x2', '\xADA', '\xADB', '\a', '\x24F', '\x2', '\x2', '\xADB', 
		'\xADD', '\x5', '\x14A', '\xA6', '\x2', '\xADC', '\xADA', '\x3', '\x2', 
		'\x2', '\x2', '\xADD', '\xAE0', '\x3', '\x2', '\x2', '\x2', '\xADE', '\xADC', 
		'\x3', '\x2', '\x2', '\x2', '\xADE', '\xADF', '\x3', '\x2', '\x2', '\x2', 
		'\xADF', '\xAE2', '\x3', '\x2', '\x2', '\x2', '\xAE0', '\xADE', '\x3', 
		'\x2', '\x2', '\x2', '\xAE1', '\xAD8', '\x3', '\x2', '\x2', '\x2', '\xAE1', 
		'\xAD9', '\x3', '\x2', '\x2', '\x2', '\xAE2', '\xAE3', '\x3', '\x2', '\x2', 
		'\x2', '\xAE3', '\xAE4', '\a', '\x24E', '\x2', '\x2', '\xAE4', '\x14B', 
		'\x3', '\x2', '\x2', '\x2', '\xAE5', '\xAEA', '\x5', '\x14E', '\xA8', 
		'\x2', '\xAE6', '\xAEA', '\x5', '\x150', '\xA9', '\x2', '\xAE7', '\xAEA', 
		'\x5', '\x152', '\xAA', '\x2', '\xAE8', '\xAEA', '\x5', '\x154', '\xAB', 
		'\x2', '\xAE9', '\xAE5', '\x3', '\x2', '\x2', '\x2', '\xAE9', '\xAE6', 
		'\x3', '\x2', '\x2', '\x2', '\xAE9', '\xAE7', '\x3', '\x2', '\x2', '\x2', 
		'\xAE9', '\xAE8', '\x3', '\x2', '\x2', '\x2', '\xAEA', '\x14D', '\x3', 
		'\x2', '\x2', '\x2', '\xAEB', '\xAED', '\a', '\x15C', '\x2', '\x2', '\xAEC', 
		'\xAEB', '\x3', '\x2', '\x2', '\x2', '\xAEC', '\xAED', '\x3', '\x2', '\x2', 
		'\x2', '\xAED', '\xAEE', '\x3', '\x2', '\x2', '\x2', '\xAEE', '\xAEF', 
		'\a', '\x1F3', '\x2', '\x2', '\xAEF', '\xAF0', '\a', '\x164', '\x2', '\x2', 
		'\xAF0', '\xAF1', '\x5', '\xC6', '\x64', '\x2', '\xAF1', '\x14F', '\x3', 
		'\x2', '\x2', '\x2', '\xAF2', '\xAF4', '\a', '\x15C', '\x2', '\x2', '\xAF3', 
		'\xAF2', '\x3', '\x2', '\x2', '\x2', '\xAF3', '\xAF4', '\x3', '\x2', '\x2', 
		'\x2', '\xAF4', '\xAF5', '\x3', '\x2', '\x2', '\x2', '\xAF5', '\xAF6', 
		'\a', '\x128', '\x2', '\x2', '\xAF6', '\xAF7', '\a', '\x164', '\x2', '\x2', 
		'\xAF7', '\xAF8', '\x5', '\xC6', '\x64', '\x2', '\xAF8', '\x151', '\x3', 
		'\x2', '\x2', '\x2', '\xAF9', '\xAFB', '\a', '\xF7', '\x2', '\x2', '\xAFA', 
		'\xAFC', '\a', '\x15C', '\x2', '\x2', '\xAFB', '\xAFA', '\x3', '\x2', 
		'\x2', '\x2', '\xAFB', '\xAFC', '\x3', '\x2', '\x2', '\x2', '\xAFC', '\xAFD', 
		'\x3', '\x2', '\x2', '\x2', '\xAFD', '\xAFE', '\a', '\x3', '\x2', '\x2', 
		'\xAFE', '\xAFF', '\a', '\x1DA', '\x2', '\x2', '\xAFF', '\x153', '\x3', 
		'\x2', '\x2', '\x2', '\xB00', '\xB02', '\a', '\xF7', '\x2', '\x2', '\xB01', 
		'\xB03', '\a', '\x15C', '\x2', '\x2', '\xB02', '\xB01', '\x3', '\x2', 
		'\x2', '\x2', '\xB02', '\xB03', '\x3', '\x2', '\x2', '\x2', '\xB03', '\xB04', 
		'\x3', '\x2', '\x2', '\x2', '\xB04', '\xB05', '\a', '\x99', '\x2', '\x2', 
		'\xB05', '\x155', '\x3', '\x2', '\x2', '\x2', '\xB06', '\xB07', '\t', 
		'\x18', '\x2', '\x2', '\xB07', '\x157', '\x3', '\x2', '\x2', '\x2', '\xB08', 
		'\xB09', '\a', '\xA2', '\x2', '\x2', '\xB09', '\xB0A', '\x5', '\xA0', 
		'Q', '\x2', '\xB0A', '\x159', '\x3', '\x2', '\x2', '\x2', '\xB0B', '\xB0C', 
		'\a', '&', '\x2', '\x2', '\xB0C', '\x15B', '\x3', '\x2', '\x2', '\x2', 
		'\xB0D', '\xB0E', '\a', '\x10', '\x2', '\x2', '\xB0E', '\x15D', '\x3', 
		'\x2', '\x2', '\x2', '\xB0F', '\xB10', '\a', '\x254', '\x2', '\x2', '\xB10', 
		'\xB1F', '\a', '\x253', '\x2', '\x2', '\xB11', '\xB12', '\a', '\x25C', 
		'\x2', '\x2', '\xB12', '\xB1F', '\a', '\x255', '\x2', '\x2', '\xB13', 
		'\xB14', '\a', '\x260', '\x2', '\x2', '\xB14', '\xB1F', '\a', '\x255', 
		'\x2', '\x2', '\xB15', '\xB16', '\a', '\x253', '\x2', '\x2', '\xB16', 
		'\xB1F', '\a', '\x255', '\x2', '\x2', '\xB17', '\xB18', '\a', '\x254', 
		'\x2', '\x2', '\xB18', '\xB1F', '\a', '\x255', '\x2', '\x2', '\xB19', 
		'\xB1F', '\a', '\x255', '\x2', '\x2', '\xB1A', '\xB1B', '\a', '\x25F', 
		'\x2', '\x2', '\xB1B', '\xB1F', '\a', '\x255', '\x2', '\x2', '\xB1C', 
		'\xB1F', '\a', '\x253', '\x2', '\x2', '\xB1D', '\xB1F', '\a', '\x254', 
		'\x2', '\x2', '\xB1E', '\xB0F', '\x3', '\x2', '\x2', '\x2', '\xB1E', '\xB11', 
		'\x3', '\x2', '\x2', '\x2', '\xB1E', '\xB13', '\x3', '\x2', '\x2', '\x2', 
		'\xB1E', '\xB15', '\x3', '\x2', '\x2', '\x2', '\xB1E', '\xB17', '\x3', 
		'\x2', '\x2', '\x2', '\xB1E', '\xB19', '\x3', '\x2', '\x2', '\x2', '\xB1E', 
		'\xB1A', '\x3', '\x2', '\x2', '\x2', '\xB1E', '\xB1C', '\x3', '\x2', '\x2', 
		'\x2', '\xB1E', '\xB1D', '\x3', '\x2', '\x2', '\x2', '\xB1F', '\x15F', 
		'\x3', '\x2', '\x2', '\x2', '\xB20', '\xB21', '\a', '\x24D', '\x2', '\x2', 
		'\xB21', '\xB22', '\x5', '\x3F6', '\x1FC', '\x2', '\xB22', '\xB23', '\a', 
		'\x24E', '\x2', '\x2', '\xB23', '\x161', '\x3', '\x2', '\x2', '\x2', '\xB24', 
		'\xB25', '\a', '\x15', '\x2', '\x2', '\xB25', '\xB26', '\a', '\x24D', 
		'\x2', '\x2', '\xB26', '\xB27', '\x5', '\x3F6', '\x1FC', '\x2', '\xB27', 
		'\xB28', '\a', '\x24E', '\x2', '\x2', '\xB28', '\x163', '\x3', '\x2', 
		'\x2', '\x2', '\xB29', '\xB2A', '\a', '\x203', '\x2', '\x2', '\xB2A', 
		'\xB2B', '\a', '\x24D', '\x2', '\x2', '\xB2B', '\xB2C', '\x5', '\x3F6', 
		'\x1FC', '\x2', '\xB2C', '\xB2D', '\a', '\x24E', '\x2', '\x2', '\xB2D', 
		'\xB37', '\x3', '\x2', '\x2', '\x2', '\xB2E', '\xB2F', '\a', '\x1FD', 
		'\x2', '\x2', '\xB2F', '\xB32', '\a', '\x24D', '\x2', '\x2', '\xB30', 
		'\xB33', '\x5', '\x3F6', '\x1FC', '\x2', '\xB31', '\xB33', '\x5', '\xA0', 
		'Q', '\x2', '\xB32', '\xB30', '\x3', '\x2', '\x2', '\x2', '\xB32', '\xB31', 
		'\x3', '\x2', '\x2', '\x2', '\xB33', '\xB34', '\x3', '\x2', '\x2', '\x2', 
		'\xB34', '\xB35', '\a', '\x24E', '\x2', '\x2', '\xB35', '\xB37', '\x3', 
		'\x2', '\x2', '\x2', '\xB36', '\xB29', '\x3', '\x2', '\x2', '\x2', '\xB36', 
		'\xB2E', '\x3', '\x2', '\x2', '\x2', '\xB37', '\x165', '\x3', '\x2', '\x2', 
		'\x2', '\xB38', '\xB3D', '\x5', '\x168', '\xB5', '\x2', '\xB39', '\xB3A', 
		'\a', '\x24F', '\x2', '\x2', '\xB3A', '\xB3C', '\x5', '\x168', '\xB5', 
		'\x2', '\xB3B', '\xB39', '\x3', '\x2', '\x2', '\x2', '\xB3C', '\xB3F', 
		'\x3', '\x2', '\x2', '\x2', '\xB3D', '\xB3B', '\x3', '\x2', '\x2', '\x2', 
		'\xB3D', '\xB3E', '\x3', '\x2', '\x2', '\x2', '\xB3E', '\x167', '\x3', 
		'\x2', '\x2', '\x2', '\xB3F', '\xB3D', '\x3', '\x2', '\x2', '\x2', '\xB40', 
		'\xB46', '\x5', '\x170', '\xB9', '\x2', '\xB41', '\xB42', '\a', '\x24D', 
		'\x2', '\x2', '\xB42', '\xB43', '\x5', '\x166', '\xB4', '\x2', '\xB43', 
		'\xB44', '\a', '\x24E', '\x2', '\x2', '\xB44', '\xB46', '\x3', '\x2', 
		'\x2', '\x2', '\xB45', '\xB40', '\x3', '\x2', '\x2', '\x2', '\xB45', '\xB41', 
		'\x3', '\x2', '\x2', '\x2', '\xB46', '\x169', '\x3', '\x2', '\x2', '\x2', 
		'\xB47', '\xB4C', '\x5', '\x170', '\xB9', '\x2', '\xB48', '\xB49', '\a', 
		'\x24F', '\x2', '\x2', '\xB49', '\xB4B', '\x5', '\x170', '\xB9', '\x2', 
		'\xB4A', '\xB48', '\x3', '\x2', '\x2', '\x2', '\xB4B', '\xB4E', '\x3', 
		'\x2', '\x2', '\x2', '\xB4C', '\xB4A', '\x3', '\x2', '\x2', '\x2', '\xB4C', 
		'\xB4D', '\x3', '\x2', '\x2', '\x2', '\xB4D', '\x16B', '\x3', '\x2', '\x2', 
		'\x2', '\xB4E', '\xB4C', '\x3', '\x2', '\x2', '\x2', '\xB4F', '\xB52', 
		'\x5', '\x170', '\xB9', '\x2', '\xB50', '\xB51', '\a', '\x24F', '\x2', 
		'\x2', '\xB51', '\xB53', '\x5', '\x170', '\xB9', '\x2', '\xB52', '\xB50', 
		'\x3', '\x2', '\x2', '\x2', '\xB53', '\xB54', '\x3', '\x2', '\x2', '\x2', 
		'\xB54', '\xB52', '\x3', '\x2', '\x2', '\x2', '\xB54', '\xB55', '\x3', 
		'\x2', '\x2', '\x2', '\xB55', '\x16D', '\x3', '\x2', '\x2', '\x2', '\xB56', 
		'\xB57', '\a', 'y', '\x2', '\x2', '\xB57', '\x16F', '\x3', '\x2', '\x2', 
		'\x2', '\xB58', '\xB5A', '\x5', '\x174', '\xBB', '\x2', '\xB59', '\xB58', 
		'\x3', '\x2', '\x2', '\x2', '\xB59', '\xB5A', '\x3', '\x2', '\x2', '\x2', 
		'\xB5A', '\xB5D', '\x3', '\x2', '\x2', '\x2', '\xB5B', '\xB5E', '\x5', 
		'\xA0', 'Q', '\x2', '\xB5C', '\xB5E', '\x5', '\x16E', '\xB8', '\x2', '\xB5D', 
		'\xB5B', '\x3', '\x2', '\x2', '\x2', '\xB5D', '\xB5C', '\x3', '\x2', '\x2', 
		'\x2', '\xB5E', '\xB60', '\x3', '\x2', '\x2', '\x2', '\xB5F', '\xB61', 
		'\x5', '\x176', '\xBC', '\x2', '\xB60', '\xB5F', '\x3', '\x2', '\x2', 
		'\x2', '\xB60', '\xB61', '\x3', '\x2', '\x2', '\x2', '\xB61', '\x171', 
		'\x3', '\x2', '\x2', '\x2', '\xB62', '\xB63', '\a', '\x23E', '\x2', '\x2', 
		'\xB63', '\xB64', '\a', '\x24D', '\x2', '\x2', '\xB64', '\xB66', '\x5', 
		'\xA0', 'Q', '\x2', '\xB65', '\xB67', '\x5', '\x404', '\x203', '\x2', 
		'\xB66', '\xB65', '\x3', '\x2', '\x2', '\x2', '\xB66', '\xB67', '\x3', 
		'\x2', '\x2', '\x2', '\xB67', '\xB68', '\x3', '\x2', '\x2', '\x2', '\xB68', 
		'\xB69', '\a', '\x24E', '\x2', '\x2', '\xB69', '\x173', '\x3', '\x2', 
		'\x2', '\x2', '\xB6A', '\xB6B', '\x5', 'N', '(', '\x2', '\xB6B', '\xB6C', 
		'\a', '\x249', '\x2', '\x2', '\xB6C', '\x175', '\x3', '\x2', '\x2', '\x2', 
		'\xB6D', '\xB6F', '\a', '\x15', '\x2', '\x2', '\xB6E', '\xB6D', '\x3', 
		'\x2', '\x2', '\x2', '\xB6E', '\xB6F', '\x3', '\x2', '\x2', '\x2', '\xB6F', 
		'\xB70', '\x3', '\x2', '\x2', '\x2', '\xB70', '\xB71', '\x5', '\\', '/', 
		'\x2', '\xB71', '\x177', '\x3', '\x2', '\x2', '\x2', '\xB72', '\xB77', 
		'\x5', '\x42', '\"', '\x2', '\xB73', '\xB74', '\a', '\x24F', '\x2', '\x2', 
		'\xB74', '\xB76', '\x5', '\x42', '\"', '\x2', '\xB75', '\xB73', '\x3', 
		'\x2', '\x2', '\x2', '\xB76', '\xB79', '\x3', '\x2', '\x2', '\x2', '\xB77', 
		'\xB75', '\x3', '\x2', '\x2', '\x2', '\xB77', '\xB78', '\x3', '\x2', '\x2', 
		'\x2', '\xB78', '\x179', '\x3', '\x2', '\x2', '\x2', '\xB79', '\xB77', 
		'\x3', '\x2', '\x2', '\x2', '\xB7A', '\xB7F', '\x5', '\x17C', '\xBF', 
		'\x2', '\xB7B', '\xB7C', '\a', '\x24F', '\x2', '\x2', '\xB7C', '\xB7E', 
		'\x5', '\x17C', '\xBF', '\x2', '\xB7D', '\xB7B', '\x3', '\x2', '\x2', 
		'\x2', '\xB7E', '\xB81', '\x3', '\x2', '\x2', '\x2', '\xB7F', '\xB7D', 
		'\x3', '\x2', '\x2', '\x2', '\xB7F', '\xB80', '\x3', '\x2', '\x2', '\x2', 
		'\xB80', '\x17B', '\x3', '\x2', '\x2', '\x2', '\xB81', '\xB7F', '\x3', 
		'\x2', '\x2', '\x2', '\xB82', '\xB83', '\x5', '\\', '/', '\x2', '\xB83', 
		'\x17D', '\x3', '\x2', '\x2', '\x2', '\xB84', '\xB85', '\x5', 'H', '%', 
		'\x2', '\xB85', '\x17F', '\x3', '\x2', '\x2', '\x2', '\xB86', '\xB88', 
		'\a', '\x64', '\x2', '\x2', '\xB87', '\xB89', '\x5', '\x182', '\xC2', 
		'\x2', '\xB88', '\xB87', '\x3', '\x2', '\x2', '\x2', '\xB88', '\xB89', 
		'\x3', '\x2', '\x2', '\x2', '\xB89', '\xB91', '\x3', '\x2', '\x2', '\x2', 
		'\xB8A', '\xB92', '\x5', '\x22E', '\x118', '\x2', '\xB8B', '\xB92', '\x5', 
		'\x33C', '\x19F', '\x2', '\xB8C', '\xB92', '\x5', '\x30C', '\x187', '\x2', 
		'\xB8D', '\xB92', '\x5', '\x1DC', '\xEF', '\x2', '\xB8E', '\xB92', '\x5', 
		'\x184', '\xC3', '\x2', '\xB8F', '\xB92', '\x5', '\x1A4', '\xD3', '\x2', 
		'\xB90', '\xB92', '\x5', '\x1D8', '\xED', '\x2', '\xB91', '\xB8A', '\x3', 
		'\x2', '\x2', '\x2', '\xB91', '\xB8B', '\x3', '\x2', '\x2', '\x2', '\xB91', 
		'\xB8C', '\x3', '\x2', '\x2', '\x2', '\xB91', '\xB8D', '\x3', '\x2', '\x2', 
		'\x2', '\xB91', '\xB8E', '\x3', '\x2', '\x2', '\x2', '\xB91', '\xB8F', 
		'\x3', '\x2', '\x2', '\x2', '\xB91', '\xB90', '\x3', '\x2', '\x2', '\x2', 
		'\xB92', '\x181', '\x3', '\x2', '\x2', '\x2', '\xB93', '\xB94', '\a', 
		'\x170', '\x2', '\x2', '\xB94', '\xB95', '\a', '\x1B1', '\x2', '\x2', 
		'\xB95', '\x183', '\x3', '\x2', '\x2', '\x2', '\xB96', '\xB97', '\a', 
		'\x224', '\x2', '\x2', '\xB97', '\xB98', '\x5', 'Z', '.', '\x2', '\xB98', 
		'\xB99', '\a', '\xD9', '\x2', '\x2', '\xB99', '\xB9D', '\x5', '\x186', 
		'\xC4', '\x2', '\xB9A', '\xB9C', '\x5', '\x190', '\xC9', '\x2', '\xB9B', 
		'\xB9A', '\x3', '\x2', '\x2', '\x2', '\xB9C', '\xB9F', '\x3', '\x2', '\x2', 
		'\x2', '\xB9D', '\xB9B', '\x3', '\x2', '\x2', '\x2', '\xB9D', '\xB9E', 
		'\x3', '\x2', '\x2', '\x2', '\xB9E', '\x185', '\x3', '\x2', '\x2', '\x2', 
		'\xB9F', '\xB9D', '\x3', '\x2', '\x2', '\x2', '\xBA0', '\xBA5', '\x5', 
		'\x188', '\xC5', '\x2', '\xBA1', '\xBA5', '\x5', '\x18A', '\xC6', '\x2', 
		'\xBA2', '\xBA5', '\x5', '\x18C', '\xC7', '\x2', '\xBA3', '\xBA5', '\x5', 
		'\x18E', '\xC8', '\x2', '\xBA4', '\xBA0', '\x3', '\x2', '\x2', '\x2', 
		'\xBA4', '\xBA1', '\x3', '\x2', '\x2', '\x2', '\xBA4', '\xBA2', '\x3', 
		'\x2', '\x2', '\x2', '\xBA4', '\xBA3', '\x3', '\x2', '\x2', '\x2', '\xBA5', 
		'\x187', '\x3', '\x2', '\x2', '\x2', '\xBA6', '\xBAA', '\a', '\x33', '\x2', 
		'\x2', '\xBA7', '\xBAB', '\x5', 'Z', '.', '\x2', '\xBA8', '\xBA9', '\a', 
		'\x228', '\x2', '\x2', '\xBA9', '\xBAB', '\x5', '*', '\x16', '\x2', '\xBAA', 
		'\xBA7', '\x3', '\x2', '\x2', '\x2', '\xBAA', '\xBA8', '\x3', '\x2', '\x2', 
		'\x2', '\xBAB', '\x189', '\x3', '\x2', '\x2', '\x2', '\xBAC', '\xBAF', 
		'\a', '\xB1', '\x2', '\x2', '\xBAD', '\xBAE', '\a', '\x15', '\x2', '\x2', 
		'\xBAE', '\xBB0', '\x5', '*', '\x16', '\x2', '\xBAF', '\xBAD', '\x3', 
		'\x2', '\x2', '\x2', '\xBAF', '\xBB0', '\x3', '\x2', '\x2', '\x2', '\xBB0', 
		'\x18B', '\x3', '\x2', '\x2', '\x2', '\xBB1', '\xBB4', '\a', '\xCD', '\x2', 
		'\x2', '\xBB2', '\xBB3', '\a', '\x15', '\x2', '\x2', '\xBB3', '\xBB5', 
		'\x5', '*', '\x16', '\x2', '\xBB4', '\xBB2', '\x3', '\x2', '\x2', '\x2', 
		'\xBB4', '\xBB5', '\x3', '\x2', '\x2', '\x2', '\xBB5', '\x18D', '\x3', 
		'\x2', '\x2', '\x2', '\xBB6', '\xBB7', '\a', '\x144', '\x2', '\x2', '\xBB7', 
		'\xBB8', '\a', '\x1C', '\x2', '\x2', '\xBB8', '\x18F', '\x3', '\x2', '\x2', 
		'\x2', '\xBB9', '\xBC3', '\x5', '\x192', '\xCA', '\x2', '\xBBA', '\xBC3', 
		'\x5', '\x194', '\xCB', '\x2', '\xBBB', '\xBC3', '\x5', '\x196', '\xCC', 
		'\x2', '\xBBC', '\xBC3', '\x5', '\x198', '\xCD', '\x2', '\xBBD', '\xBC3', 
		'\x5', '\x19A', '\xCE', '\x2', '\xBBE', '\xBC3', '\x5', '\x19C', '\xCF', 
		'\x2', '\xBBF', '\xBC3', '\x5', '\x19E', '\xD0', '\x2', '\xBC0', '\xBC3', 
		'\x5', '\x1A0', '\xD1', '\x2', '\xBC1', '\xBC3', '\x5', '\x1A2', '\xD2', 
		'\x2', '\xBC2', '\xBB9', '\x3', '\x2', '\x2', '\x2', '\xBC2', '\xBBA', 
		'\x3', '\x2', '\x2', '\x2', '\xBC2', '\xBBB', '\x3', '\x2', '\x2', '\x2', 
		'\xBC2', '\xBBC', '\x3', '\x2', '\x2', '\x2', '\xBC2', '\xBBD', '\x3', 
		'\x2', '\x2', '\x2', '\xBC2', '\xBBE', '\x3', '\x2', '\x2', '\x2', '\xBC2', 
		'\xBBF', '\x3', '\x2', '\x2', '\x2', '\xBC2', '\xBC0', '\x3', '\x2', '\x2', 
		'\x2', '\xBC2', '\xBC1', '\x3', '\x2', '\x2', '\x2', '\xBC3', '\x191', 
		'\x3', '\x2', '\x2', '\x2', '\xBC4', '\xBC5', '\a', 'y', '\x2', '\x2', 
		'\xBC5', '\xBC6', '\a', 'H', '\x2', '\x2', '\xBC6', '\xBC7', '\x5', 'Z', 
		'.', '\x2', '\xBC7', '\x193', '\x3', '\x2', '\x2', '\x2', '\xBC8', '\xBC9', 
		'\a', 'y', '\x2', '\x2', '\xBC9', '\xBCA', '\a', '\x1FF', '\x2', '\x2', 
		'\xBCA', '\xBCB', '\x5', 'Z', '.', '\x2', '\xBCB', '\x195', '\x3', '\x2', 
		'\x2', '\x2', '\xBCC', '\xBCE', '\a', '\x111', '\x2', '\x2', '\xBCD', 
		'\xBCC', '\x3', '\x2', '\x2', '\x2', '\xBCD', '\xBCE', '\x3', '\x2', '\x2', 
		'\x2', '\xBCE', '\xBCF', '\x3', '\x2', '\x2', '\x2', '\xBCF', '\xBD0', 
		'\a', '\x201', '\x2', '\x2', '\xBD0', '\xBD1', '\a', '\x1FF', '\x2', '\x2', 
		'\xBD1', '\xBD2', '\x5', 'Z', '.', '\x2', '\xBD2', '\x197', '\x3', '\x2', 
		'\x2', '\x2', '\xBD3', '\xBD6', '\a', '\x19D', '\x2', '\x2', '\xBD4', 
		'\xBD7', '\a', '\x21B', '\x2', '\x2', '\xBD5', '\xBD7', '\x5', '\x3A6', 
		'\x1D4', '\x2', '\xBD6', '\xBD4', '\x3', '\x2', '\x2', '\x2', '\xBD6', 
		'\xBD5', '\x3', '\x2', '\x2', '\x2', '\xBD7', '\xBD8', '\x3', '\x2', '\x2', 
		'\x2', '\xBD8', '\xBD9', '\a', '\x168', '\x2', '\x2', '\xBD9', '\xBDA', 
		'\x5', 'Z', '.', '\x2', '\xBDA', '\x199', '\x3', '\x2', '\x2', '\x2', 
		'\xBDB', '\xBDC', '\a', '\x199', '\x2', '\x2', '\xBDC', '\xBDD', '\x5', 
		'Z', '.', '\x2', '\xBDD', '\x19B', '\x3', '\x2', '\x2', '\x2', '\xBDE', 
		'\xBDF', '\a', '\x183', '\x2', '\x2', '\xBDF', '\xBE0', '\a', '\xAD', 
		'\x2', '\x2', '\xBE0', '\x19D', '\x3', '\x2', '\x2', '\x2', '\xBE1', '\xBE2', 
		'\a', '\x4', '\x2', '\x2', '\xBE2', '\xBE3', '\t', '\x19', '\x2', '\x2', 
		'\xBE3', '\x19F', '\x3', '\x2', '\x2', '\x2', '\xBE4', '\xBE5', '\a', 
		'\x9A', '\x2', '\x2', '\xBE5', '\xBE6', '\a', '\x95', '\x2', '\x2', '\xBE6', 
		'\x1A1', '\x3', '\x2', '\x2', '\x2', '\xBE7', '\xBE8', '\a', '^', '\x2', 
		'\x2', '\xBE8', '\xBE9', '\a', '\x255', '\x2', '\x2', '\xBE9', '\xBEA', 
		'\t', '\x1A', '\x2', '\x2', '\xBEA', '\x1A3', '\x3', '\x2', '\x2', '\x2', 
		'\xBEB', '\xBED', '\t', '\x1B', '\x2', '\x2', '\xBEC', '\xBEB', '\x3', 
		'\x2', '\x2', '\x2', '\xBEC', '\xBED', '\x3', '\x2', '\x2', '\x2', '\xBED', 
		'\xBEE', '\x3', '\x2', '\x2', '\x2', '\xBEE', '\xBEF', '\a', '\xE2', '\x2', 
		'\x2', '\xBEF', '\xBF0', '\x5', '\x44', '#', '\x2', '\xBF0', '\xBF4', 
		'\a', '\x168', '\x2', '\x2', '\xBF1', '\xBF5', '\x5', '\x1A6', '\xD4', 
		'\x2', '\xBF2', '\xBF5', '\x5', '\x1A8', '\xD5', '\x2', '\xBF3', '\xBF5', 
		'\x5', '\x1AC', '\xD7', '\x2', '\xBF4', '\xBF1', '\x3', '\x2', '\x2', 
		'\x2', '\xBF4', '\xBF2', '\x3', '\x2', '\x2', '\x2', '\xBF4', '\xBF3', 
		'\x3', '\x2', '\x2', '\x2', '\xBF5', '\xBF7', '\x3', '\x2', '\x2', '\x2', 
		'\xBF6', '\xBF8', '\t', '\x1C', '\x2', '\x2', '\xBF7', '\xBF6', '\x3', 
		'\x2', '\x2', '\x2', '\xBF7', '\xBF8', '\x3', '\x2', '\x2', '\x2', '\xBF8', 
		'\xBFB', '\x3', '\x2', '\x2', '\x2', '\xBF9', '\xBFA', '\t', '\x1D', '\x2', 
		'\x2', '\xBFA', '\xBFC', '\a', '\xF5', '\x2', '\x2', '\xBFB', '\xBF9', 
		'\x3', '\x2', '\x2', '\x2', '\xBFB', '\xBFC', '\x3', '\x2', '\x2', '\x2', 
		'\xBFC', '\x1A5', '\x3', '\x2', '\x2', '\x2', '\xBFD', '\xBFE', '\a', 
		'\x45', '\x2', '\x2', '\xBFE', '\xC02', '\x5', '\x44', '#', '\x2', '\xBFF', 
		'\xC01', '\x5', '\x1C8', '\xE5', '\x2', '\xC00', '\xBFF', '\x3', '\x2', 
		'\x2', '\x2', '\xC01', '\xC04', '\x3', '\x2', '\x2', '\x2', '\xC02', '\xC00', 
		'\x3', '\x2', '\x2', '\x2', '\xC02', '\xC03', '\x3', '\x2', '\x2', '\x2', 
		'\xC03', '\x1A7', '\x3', '\x2', '\x2', '\x2', '\xC04', '\xC02', '\x3', 
		'\x2', '\x2', '\x2', '\xC05', '\xC07', '\x5', '\x44', '#', '\x2', '\xC06', 
		'\xC08', '\x5', '\x4D4', '\x26B', '\x2', '\xC07', '\xC06', '\x3', '\x2', 
		'\x2', '\x2', '\xC07', '\xC08', '\x3', '\x2', '\x2', '\x2', '\xC08', '\xC09', 
		'\x3', '\x2', '\x2', '\x2', '\xC09', '\xC0A', '\a', '\x24D', '\x2', '\x2', 
		'\xC0A', '\xC0F', '\x5', '\x1AA', '\xD6', '\x2', '\xC0B', '\xC0C', '\a', 
		'\x24F', '\x2', '\x2', '\xC0C', '\xC0E', '\x5', '\x1AA', '\xD6', '\x2', 
		'\xC0D', '\xC0B', '\x3', '\x2', '\x2', '\x2', '\xC0E', '\xC11', '\x3', 
		'\x2', '\x2', '\x2', '\xC0F', '\xC0D', '\x3', '\x2', '\x2', '\x2', '\xC0F', 
		'\xC10', '\x3', '\x2', '\x2', '\x2', '\xC10', '\xC12', '\x3', '\x2', '\x2', 
		'\x2', '\xC11', '\xC0F', '\x3', '\x2', '\x2', '\x2', '\xC12', '\xC14', 
		'\a', '\x24E', '\x2', '\x2', '\xC13', '\xC15', '\x5', '\x1B2', '\xDA', 
		'\x2', '\xC14', '\xC13', '\x3', '\x2', '\x2', '\x2', '\xC14', '\xC15', 
		'\x3', '\x2', '\x2', '\x2', '\xC15', '\x1A9', '\x3', '\x2', '\x2', '\x2', 
		'\xC16', '\xC18', '\x5', '\xA0', 'Q', '\x2', '\xC17', '\xC19', '\t', '\x1E', 
		'\x2', '\x2', '\xC18', '\xC17', '\x3', '\x2', '\x2', '\x2', '\xC18', '\xC19', 
		'\x3', '\x2', '\x2', '\x2', '\xC19', '\x1AB', '\x3', '\x2', '\x2', '\x2', 
		'\xC1A', '\xC1B', '\x5', '\x44', '#', '\x2', '\xC1B', '\xC1C', '\a', '\x24D', 
		'\x2', '\x2', '\xC1C', '\xC1D', '\x5', '\x1AE', '\xD8', '\x2', '\xC1D', 
		'\xC1E', '\a', '\x24E', '\x2', '\x2', '\xC1E', '\xC1F', '\a', '\xC8', 
		'\x2', '\x2', '\xC1F', '\xC24', '\x5', '\x1B0', '\xD9', '\x2', '\xC20', 
		'\xC21', '\a', '\x24F', '\x2', '\x2', '\xC21', '\xC23', '\x5', '\x1B0', 
		'\xD9', '\x2', '\xC22', '\xC20', '\x3', '\x2', '\x2', '\x2', '\xC23', 
		'\xC26', '\x3', '\x2', '\x2', '\x2', '\xC24', '\xC22', '\x3', '\x2', '\x2', 
		'\x2', '\xC24', '\xC25', '\x3', '\x2', '\x2', '\x2', '\xC25', '\xC27', 
		'\x3', '\x2', '\x2', '\x2', '\xC26', '\xC24', '\x3', '\x2', '\x2', '\x2', 
		'\xC27', '\xC29', '\x5', '\x42C', '\x217', '\x2', '\xC28', '\xC2A', '\x5', 
		'\x1B6', '\xDC', '\x2', '\xC29', '\xC28', '\x3', '\x2', '\x2', '\x2', 
		'\xC29', '\xC2A', '\x3', '\x2', '\x2', '\x2', '\xC2A', '\xC2E', '\x3', 
		'\x2', '\x2', '\x2', '\xC2B', '\xC2D', '\x5', '\x1C8', '\xE5', '\x2', 
		'\xC2C', '\xC2B', '\x3', '\x2', '\x2', '\x2', '\xC2D', '\xC30', '\x3', 
		'\x2', '\x2', '\x2', '\xC2E', '\xC2C', '\x3', '\x2', '\x2', '\x2', '\xC2E', 
		'\xC2F', '\x3', '\x2', '\x2', '\x2', '\xC2F', '\x1AD', '\x3', '\x2', '\x2', 
		'\x2', '\xC30', '\xC2E', '\x3', '\x2', '\x2', '\x2', '\xC31', '\xC33', 
		'\x5', '\x44', '#', '\x2', '\xC32', '\xC34', '\t', '\x1E', '\x2', '\x2', 
		'\xC33', '\xC32', '\x3', '\x2', '\x2', '\x2', '\xC33', '\xC34', '\x3', 
		'\x2', '\x2', '\x2', '\xC34', '\x1AF', '\x3', '\x2', '\x2', '\x2', '\xC35', 
		'\xC37', '\x5', '\x44', '#', '\x2', '\xC36', '\xC38', '\x5', '\x4D4', 
		'\x26B', '\x2', '\xC37', '\xC36', '\x3', '\x2', '\x2', '\x2', '\xC37', 
		'\xC38', '\x3', '\x2', '\x2', '\x2', '\xC38', '\x1B1', '\x3', '\x2', '\x2', 
		'\x2', '\xC39', '\xC3D', '\x5', '\x1B4', '\xDB', '\x2', '\xC3A', '\xC3D', 
		'\x5', '\x1B6', '\xDC', '\x2', '\xC3B', '\xC3D', '\x5', '\x1C8', '\xE5', 
		'\x2', '\xC3C', '\xC39', '\x3', '\x2', '\x2', '\x2', '\xC3C', '\xC3A', 
		'\x3', '\x2', '\x2', '\x2', '\xC3C', '\xC3B', '\x3', '\x2', '\x2', '\x2', 
		'\xC3D', '\xC3E', '\x3', '\x2', '\x2', '\x2', '\xC3E', '\xC3C', '\x3', 
		'\x2', '\x2', '\x2', '\xC3E', '\xC3F', '\x3', '\x2', '\x2', '\x2', '\xC3F', 
		'\xC42', '\x3', '\x2', '\x2', '\x2', '\xC40', '\xC42', '\x5', '\x1CE', 
		'\xE8', '\x2', '\xC41', '\xC3C', '\x3', '\x2', '\x2', '\x2', '\xC41', 
		'\xC40', '\x3', '\x2', '\x2', '\x2', '\xC42', '\x1B3', '\x3', '\x2', '\x2', 
		'\x2', '\xC43', '\xC44', '\a', '\xCC', '\x2', '\x2', '\xC44', '\xC45', 
		'\x5', '\x276', '\x13C', '\x2', '\xC45', '\x1B5', '\x3', '\x2', '\x2', 
		'\x2', '\xC46', '\xC47', '\a', '\x111', '\x2', '\x2', '\xC47', '\xC4B', 
		'\x5', '\x1B8', '\xDD', '\x2', '\xC48', '\xC4B', '\x5', '\x1BC', '\xDF', 
		'\x2', '\xC49', '\xC4B', '\x5', '\x1C0', '\xE1', '\x2', '\xC4A', '\xC46', 
		'\x3', '\x2', '\x2', '\x2', '\xC4A', '\xC48', '\x3', '\x2', '\x2', '\x2', 
		'\xC4A', '\xC49', '\x3', '\x2', '\x2', '\x2', '\xC4B', '\x1B7', '\x3', 
		'\x2', '\x2', '\x2', '\xC4C', '\xC4D', '\a', '\x24D', '\x2', '\x2', '\xC4D', 
		'\xC52', '\x5', '\x1BA', '\xDE', '\x2', '\xC4E', '\xC4F', '\a', '\x24F', 
		'\x2', '\x2', '\xC4F', '\xC51', '\x5', '\x1BA', '\xDE', '\x2', '\xC50', 
		'\xC4E', '\x3', '\x2', '\x2', '\x2', '\xC51', '\xC54', '\x3', '\x2', '\x2', 
		'\x2', '\xC52', '\xC50', '\x3', '\x2', '\x2', '\x2', '\xC52', '\xC53', 
		'\x3', '\x2', '\x2', '\x2', '\xC53', '\xC55', '\x3', '\x2', '\x2', '\x2', 
		'\xC54', '\xC52', '\x3', '\x2', '\x2', '\x2', '\xC55', '\xC56', '\a', 
		'\x24E', '\x2', '\x2', '\xC56', '\x1B9', '\x3', '\x2', '\x2', '\x2', '\xC57', 
		'\xC59', '\a', '\x180', '\x2', '\x2', '\xC58', '\xC5A', '\x5', 'Z', '.', 
		'\x2', '\xC59', '\xC58', '\x3', '\x2', '\x2', '\x2', '\xC59', '\xC5A', 
		'\x3', '\x2', '\x2', '\x2', '\xC5A', '\xC5F', '\x3', '\x2', '\x2', '\x2', 
		'\xC5B', '\xC5E', '\x5', '\x2E0', '\x171', '\x2', '\xC5C', '\xC5E', '\x5', 
		'\x2DC', '\x16F', '\x2', '\xC5D', '\xC5B', '\x3', '\x2', '\x2', '\x2', 
		'\xC5D', '\xC5C', '\x3', '\x2', '\x2', '\x2', '\xC5E', '\xC61', '\x3', 
		'\x2', '\x2', '\x2', '\xC5F', '\xC5D', '\x3', '\x2', '\x2', '\x2', '\xC5F', 
		'\xC60', '\x3', '\x2', '\x2', '\x2', '\xC60', '\xC63', '\x3', '\x2', '\x2', 
		'\x2', '\xC61', '\xC5F', '\x3', '\x2', '\x2', '\x2', '\xC62', '\xC64', 
		'\t', '\x1C', '\x2', '\x2', '\xC63', '\xC62', '\x3', '\x2', '\x2', '\x2', 
		'\xC63', '\xC64', '\x3', '\x2', '\x2', '\x2', '\xC64', '\x1BB', '\x3', 
		'\x2', '\x2', '\x2', '\xC65', '\xC72', '\x5', '\x2A4', '\x153', '\x2', 
		'\xC66', '\xC67', '\a', '\x24D', '\x2', '\x2', '\xC67', '\xC6C', '\x5', 
		'\x1BE', '\xE0', '\x2', '\xC68', '\xC69', '\a', '\x24F', '\x2', '\x2', 
		'\xC69', '\xC6B', '\x5', '\x1BE', '\xE0', '\x2', '\xC6A', '\xC68', '\x3', 
		'\x2', '\x2', '\x2', '\xC6B', '\xC6E', '\x3', '\x2', '\x2', '\x2', '\xC6C', 
		'\xC6A', '\x3', '\x2', '\x2', '\x2', '\xC6C', '\xC6D', '\x3', '\x2', '\x2', 
		'\x2', '\xC6D', '\xC6F', '\x3', '\x2', '\x2', '\x2', '\xC6E', '\xC6C', 
		'\x3', '\x2', '\x2', '\x2', '\xC6F', '\xC70', '\a', '\x24E', '\x2', '\x2', 
		'\xC70', '\xC72', '\x3', '\x2', '\x2', '\x2', '\xC71', '\xC65', '\x3', 
		'\x2', '\x2', '\x2', '\xC71', '\xC66', '\x3', '\x2', '\x2', '\x2', '\xC72', 
		'\x1BD', '\x3', '\x2', '\x2', '\x2', '\xC73', '\xC75', '\a', '\x180', 
		'\x2', '\x2', '\xC74', '\xC76', '\x5', 'Z', '.', '\x2', '\xC75', '\xC74', 
		'\x3', '\x2', '\x2', '\x2', '\xC75', '\xC76', '\x3', '\x2', '\x2', '\x2', 
		'\xC76', '\xC78', '\x3', '\x2', '\x2', '\x2', '\xC77', '\xC79', '\x5', 
		'\x1D6', '\xEC', '\x2', '\xC78', '\xC77', '\x3', '\x2', '\x2', '\x2', 
		'\xC78', '\xC79', '\x3', '\x2', '\x2', '\x2', '\xC79', '\xC7B', '\x3', 
		'\x2', '\x2', '\x2', '\xC7A', '\xC7C', '\x5', '\x2DC', '\x16F', '\x2', 
		'\xC7B', '\xC7A', '\x3', '\x2', '\x2', '\x2', '\xC7B', '\xC7C', '\x3', 
		'\x2', '\x2', '\x2', '\xC7C', '\xC7D', '\x3', '\x2', '\x2', '\x2', '\xC7D', 
		'\xC7E', '\t', '\x1C', '\x2', '\x2', '\xC7E', '\x1BF', '\x3', '\x2', '\x2', 
		'\x2', '\xC7F', '\xC81', '\x5', '\x2A4', '\x153', '\x2', '\xC80', '\xC7F', 
		'\x3', '\x2', '\x2', '\x2', '\xC80', '\xC81', '\x3', '\x2', '\x2', '\x2', 
		'\xC81', '\xC82', '\x3', '\x2', '\x2', '\x2', '\xC82', '\xC83', '\a', 
		'\x24D', '\x2', '\x2', '\xC83', '\xC88', '\x5', '\x1C2', '\xE2', '\x2', 
		'\xC84', '\xC85', '\a', '\x24F', '\x2', '\x2', '\xC85', '\xC87', '\x5', 
		'\x1C2', '\xE2', '\x2', '\xC86', '\xC84', '\x3', '\x2', '\x2', '\x2', 
		'\xC87', '\xC8A', '\x3', '\x2', '\x2', '\x2', '\xC88', '\xC86', '\x3', 
		'\x2', '\x2', '\x2', '\xC88', '\xC89', '\x3', '\x2', '\x2', '\x2', '\xC89', 
		'\xC8B', '\x3', '\x2', '\x2', '\x2', '\xC8A', '\xC88', '\x3', '\x2', '\x2', 
		'\x2', '\xC8B', '\xC8C', '\a', '\x24E', '\x2', '\x2', '\xC8C', '\x1C1', 
		'\x3', '\x2', '\x2', '\x2', '\xC8D', '\xC8E', '\x5', '\x1BA', '\xDE', 
		'\x2', '\xC8E', '\xC8F', '\x5', '\x1C4', '\xE3', '\x2', '\xC8F', '\x1C3', 
		'\x3', '\x2', '\x2', '\x2', '\xC90', '\xC9D', '\x5', '\x2A4', '\x153', 
		'\x2', '\xC91', '\xC92', '\a', '\x24D', '\x2', '\x2', '\xC92', '\xC97', 
		'\x5', '\x1C6', '\xE4', '\x2', '\xC93', '\xC94', '\a', '\x24F', '\x2', 
		'\x2', '\xC94', '\xC96', '\x5', '\x1C6', '\xE4', '\x2', '\xC95', '\xC93', 
		'\x3', '\x2', '\x2', '\x2', '\xC96', '\xC99', '\x3', '\x2', '\x2', '\x2', 
		'\xC97', '\xC95', '\x3', '\x2', '\x2', '\x2', '\xC97', '\xC98', '\x3', 
		'\x2', '\x2', '\x2', '\xC98', '\xC9A', '\x3', '\x2', '\x2', '\x2', '\xC99', 
		'\xC97', '\x3', '\x2', '\x2', '\x2', '\xC9A', '\xC9B', '\a', '\x24E', 
		'\x2', '\x2', '\xC9B', '\xC9D', '\x3', '\x2', '\x2', '\x2', '\xC9C', '\xC90', 
		'\x3', '\x2', '\x2', '\x2', '\xC9C', '\xC91', '\x3', '\x2', '\x2', '\x2', 
		'\xC9D', '\x1C5', '\x3', '\x2', '\x2', '\x2', '\xC9E', '\xCA0', '\a', 
		'\x1F4', '\x2', '\x2', '\xC9F', '\xCA1', '\x5', 'Z', '.', '\x2', '\xCA0', 
		'\xC9F', '\x3', '\x2', '\x2', '\x2', '\xCA0', '\xCA1', '\x3', '\x2', '\x2', 
		'\x2', '\xCA1', '\xCA3', '\x3', '\x2', '\x2', '\x2', '\xCA2', '\xCA4', 
		'\x5', '\x1D6', '\xEC', '\x2', '\xCA3', '\xCA2', '\x3', '\x2', '\x2', 
		'\x2', '\xCA3', '\xCA4', '\x3', '\x2', '\x2', '\x2', '\xCA4', '\xCA6', 
		'\x3', '\x2', '\x2', '\x2', '\xCA5', '\xCA7', '\x5', '\x2DC', '\x16F', 
		'\x2', '\xCA6', '\xCA5', '\x3', '\x2', '\x2', '\x2', '\xCA6', '\xCA7', 
		'\x3', '\x2', '\x2', '\x2', '\xCA7', '\xCA8', '\x3', '\x2', '\x2', '\x2', 
		'\xCA8', '\xCA9', '\t', '\x1C', '\x2', '\x2', '\xCA9', '\x1C7', '\x3', 
		'\x2', '\x2', '\x2', '\xCAA', '\xCB7', '\x5', '\x61E', '\x310', '\x2', 
		'\xCAB', '\xCB7', '\x5', '\x37E', '\x1C0', '\x2', '\xCAC', '\xCB7', '\a', 
		'\x16A', '\x2', '\x2', '\xCAD', '\xCAE', '\a', 'V', '\x2', '\x2', '\xCAE', 
		'\xCB7', '\a', '\x1EC', '\x2', '\x2', '\xCAF', '\xCB7', '\x5', '\x380', 
		'\x1C1', '\x2', '\xCB0', '\xCB7', '\x5', '\x2DC', '\x16F', '\x2', '\xCB1', 
		'\xCB7', '\x5', '\x382', '\x1C2', '\x2', '\xCB2', '\xCB7', '\a', '\x1B9', 
		'\x2', '\x2', '\xCB3', '\xCB7', '\x5', '\x1CA', '\xE6', '\x2', '\xCB4', 
		'\xCB7', '\x5', '\x1CC', '\xE7', '\x2', '\xCB5', '\xCB7', '\x5', '\x274', 
		'\x13B', '\x2', '\xCB6', '\xCAA', '\x3', '\x2', '\x2', '\x2', '\xCB6', 
		'\xCAB', '\x3', '\x2', '\x2', '\x2', '\xCB6', '\xCAC', '\x3', '\x2', '\x2', 
		'\x2', '\xCB6', '\xCAD', '\x3', '\x2', '\x2', '\x2', '\xCB6', '\xCAF', 
		'\x3', '\x2', '\x2', '\x2', '\xCB6', '\xCB0', '\x3', '\x2', '\x2', '\x2', 
		'\xCB6', '\xCB1', '\x3', '\x2', '\x2', '\x2', '\xCB6', '\xCB2', '\x3', 
		'\x2', '\x2', '\x2', '\xCB6', '\xCB3', '\x3', '\x2', '\x2', '\x2', '\xCB6', 
		'\xCB4', '\x3', '\x2', '\x2', '\x2', '\xCB6', '\xCB5', '\x3', '\x2', '\x2', 
		'\x2', '\xCB7', '\x1C9', '\x3', '\x2', '\x2', '\x2', '\xCB8', '\xCB9', 
		'\t', '\x1F', '\x2', '\x2', '\xCB9', '\x1CB', '\x3', '\x2', '\x2', '\x2', 
		'\xCBA', '\xCBB', '\a', '\xE3', '\x2', '\x2', '\xCBB', '\xCBC', '\t', 
		' ', '\x2', '\x2', '\xCBC', '\x1CD', '\x3', '\x2', '\x2', '\x2', '\xCBD', 
		'\xCBE', '\a', '\xE4', '\x2', '\x2', '\xCBE', '\xCBF', '\a', '\xF7', '\x2', 
		'\x2', '\xCBF', '\xCC1', '\x5', '\x44', '#', '\x2', '\xCC0', '\xCC2', 
		'\x5', '\x1D0', '\xE9', '\x2', '\xCC1', '\xCC0', '\x3', '\x2', '\x2', 
		'\x2', '\xCC1', '\xCC2', '\x3', '\x2', '\x2', '\x2', '\xCC2', '\xCC4', 
		'\x3', '\x2', '\x2', '\x2', '\xCC3', '\xCC5', '\x5', '\x274', '\x13B', 
		'\x2', '\xCC4', '\xCC3', '\x3', '\x2', '\x2', '\x2', '\xCC4', '\xCC5', 
		'\x3', '\x2', '\x2', '\x2', '\xCC5', '\xCC7', '\x3', '\x2', '\x2', '\x2', 
		'\xCC6', '\xCC8', '\x5', '\x1D4', '\xEB', '\x2', '\xCC7', '\xCC6', '\x3', 
		'\x2', '\x2', '\x2', '\xCC7', '\xCC8', '\x3', '\x2', '\x2', '\x2', '\xCC8', 
		'\x1CF', '\x3', '\x2', '\x2', '\x2', '\xCC9', '\xCCA', '\a', '\x111', 
		'\x2', '\x2', '\xCCA', '\xCCB', '\a', '\x24D', '\x2', '\x2', '\xCCB', 
		'\xCCC', '\x5', '\x1D2', '\xEA', '\x2', '\xCCC', '\xCCD', '\a', '\x24F', 
		'\x2', '\x2', '\xCCD', '\xCCE', '\x5', '\x1D2', '\xEA', '\x2', '\xCCE', 
		'\xCCF', '\x3', '\x2', '\x2', '\x2', '\xCCF', '\xCD0', '\a', '\x24E', 
		'\x2', '\x2', '\xCD0', '\x1D1', '\x3', '\x2', '\x2', '\x2', '\xCD1', '\xCD2', 
		'\a', '\x180', '\x2', '\x2', '\xCD2', '\xCD4', '\x5', 'Z', '.', '\x2', 
		'\xCD3', '\xCD5', '\x5', '\x1D4', '\xEB', '\x2', '\xCD4', '\xCD3', '\x3', 
		'\x2', '\x2', '\x2', '\xCD4', '\xCD5', '\x3', '\x2', '\x2', '\x2', '\xCD5', 
		'\x1D3', '\x3', '\x2', '\x2', '\x2', '\xCD6', '\xCD7', '\a', '\x17D', 
		'\x2', '\x2', '\xCD7', '\xCD8', '\a', '\x24D', '\x2', '\x2', '\xCD8', 
		'\xCD9', '\x5', '*', '\x16', '\x2', '\xCD9', '\xCDA', '\a', '\x24E', '\x2', 
		'\x2', '\xCDA', '\x1D5', '\x3', '\x2', '\x2', '\x2', '\xCDB', '\xCDC', 
		'\a', '\x1FF', '\x2', '\x2', '\xCDC', '\xCDD', '\x5', 'Z', '.', '\x2', 
		'\xCDD', '\x1D7', '\x3', '\x2', '\x2', '\x2', '\xCDE', '\xCDF', '\a', 
		'\x1D4', '\x2', '\x2', '\xCDF', '\xCE1', '\x5', '\x44', '#', '\x2', '\xCE0', 
		'\xCE2', '\x5', '\x1DA', '\xEE', '\x2', '\xCE1', '\xCE0', '\x3', '\x2', 
		'\x2', '\x2', '\xCE1', '\xCE2', '\x3', '\x2', '\x2', '\x2', '\xCE2', '\xCE6', 
		'\x3', '\x2', '\x2', '\x2', '\xCE3', '\xCE5', '\x5', '\x66A', '\x336', 
		'\x2', '\xCE4', '\xCE3', '\x3', '\x2', '\x2', '\x2', '\xCE5', '\xCE8', 
		'\x3', '\x2', '\x2', '\x2', '\xCE6', '\xCE4', '\x3', '\x2', '\x2', '\x2', 
		'\xCE6', '\xCE7', '\x3', '\x2', '\x2', '\x2', '\xCE7', '\x1D9', '\x3', 
		'\x2', '\x2', '\x2', '\xCE8', '\xCE6', '\x3', '\x2', '\x2', '\x2', '\xCE9', 
		'\xCEA', '\a', '\x1F2', '\x2', '\x2', '\xCEA', '\xCEB', '\a', '\x255', 
		'\x2', '\x2', '\xCEB', '\xCEC', '\t', '!', '\x2', '\x2', '\xCEC', '\x1DB', 
		'\x3', '\x2', '\x2', '\x2', '\xCED', '\xCEF', '\x5', '\x1DE', '\xF0', 
		'\x2', '\xCEE', '\xCED', '\x3', '\x2', '\x2', '\x2', '\xCEE', '\xCEF', 
		'\x3', '\x2', '\x2', '\x2', '\xCEF', '\xCF8', '\x3', '\x2', '\x2', '\x2', 
		'\xCF0', '\xCF9', '\x5', '\x1E6', '\xF4', '\x2', '\xCF1', '\xCF9', '\x5', 
		'\x20E', '\x108', '\x2', '\xCF2', '\xCF9', '\x5', '\x3BA', '\x1DE', '\x2', 
		'\xCF3', '\xCF9', '\x5', '\x1E2', '\xF2', '\x2', '\xCF4', '\xCF9', '\x5', 
		'\x1E0', '\xF1', '\x2', '\xCF5', '\xCF9', '\x5', '\x69C', '\x34F', '\x2', 
		'\xCF6', '\xCF9', '\x5', '\x684', '\x343', '\x2', '\xCF7', '\xCF9', '\x5', 
		'\x6AE', '\x358', '\x2', '\xCF8', '\xCF0', '\x3', '\x2', '\x2', '\x2', 
		'\xCF8', '\xCF1', '\x3', '\x2', '\x2', '\x2', '\xCF8', '\xCF2', '\x3', 
		'\x2', '\x2', '\x2', '\xCF8', '\xCF3', '\x3', '\x2', '\x2', '\x2', '\xCF8', 
		'\xCF4', '\x3', '\x2', '\x2', '\x2', '\xCF8', '\xCF5', '\x3', '\x2', '\x2', 
		'\x2', '\xCF8', '\xCF6', '\x3', '\x2', '\x2', '\x2', '\xCF8', '\xCF7', 
		'\x3', '\x2', '\x2', '\x2', '\xCF9', '\x1DD', '\x3', '\x2', '\x2', '\x2', 
		'\xCFA', '\xCFB', '\t', '\"', '\x2', '\x2', '\xCFB', '\x1DF', '\x3', '\x2', 
		'\x2', '\x2', '\xCFC', '\xCFD', '\a', '\x17A', '\x2', '\x2', '\xCFD', 
		'\xD0C', '\x5', '\x44', '#', '\x2', '\xCFE', '\xD02', '\a', '\x23A', '\x2', 
		'\x2', '\xCFF', '\xD01', '\n', '#', '\x2', '\x2', '\xD00', '\xCFF', '\x3', 
		'\x2', '\x2', '\x2', '\xD01', '\xD04', '\x3', '\x2', '\x2', '\x2', '\xD02', 
		'\xD00', '\x3', '\x2', '\x2', '\x2', '\xD02', '\xD03', '\x3', '\x2', '\x2', 
		'\x2', '\xD03', '\xD0D', '\x3', '\x2', '\x2', '\x2', '\xD04', '\xD02', 
		'\x3', '\x2', '\x2', '\x2', '\xD05', '\xD07', '\x5', '\x1F2', '\xFA', 
		'\x2', '\xD06', '\xD05', '\x3', '\x2', '\x2', '\x2', '\xD06', '\xD07', 
		'\x3', '\x2', '\x2', '\x2', '\xD07', '\xD08', '\x3', '\x2', '\x2', '\x2', 
		'\xD08', '\xD09', '\x5', '\x1F0', '\xF9', '\x2', '\xD09', '\xD0A', '\x5', 
		'\x1E4', '\xF3', '\x2', '\xD0A', '\xD0B', '\x5', '\x594', '\x2CB', '\x2', 
		'\xD0B', '\xD0D', '\x3', '\x2', '\x2', '\x2', '\xD0C', '\xCFE', '\x3', 
		'\x2', '\x2', '\x2', '\xD0C', '\xD06', '\x3', '\x2', '\x2', '\x2', '\xD0D', 
		'\x1E1', '\x3', '\x2', '\x2', '\x2', '\xD0E', '\xD0F', '\a', '\x17A', 
		'\x2', '\x2', '\xD0F', '\xD10', '\a', '*', '\x2', '\x2', '\xD10', '\xD1E', 
		'\x5', '\x44', '#', '\x2', '\xD11', '\xD15', '\a', '\x23A', '\x2', '\x2', 
		'\xD12', '\xD14', '\n', '#', '\x2', '\x2', '\xD13', '\xD12', '\x3', '\x2', 
		'\x2', '\x2', '\xD14', '\xD17', '\x3', '\x2', '\x2', '\x2', '\xD15', '\xD13', 
		'\x3', '\x2', '\x2', '\x2', '\xD15', '\xD16', '\x3', '\x2', '\x2', '\x2', 
		'\xD16', '\xD1F', '\x3', '\x2', '\x2', '\x2', '\xD17', '\xD15', '\x3', 
		'\x2', '\x2', '\x2', '\xD18', '\xD19', '\x5', '\x1F0', '\xF9', '\x2', 
		'\xD19', '\xD1C', '\x5', '\x1E4', '\xF3', '\x2', '\xD1A', '\xD1D', '\x5', 
		'\x592', '\x2CA', '\x2', '\xD1B', '\xD1D', '\x5', '\x594', '\x2CB', '\x2', 
		'\xD1C', '\xD1A', '\x3', '\x2', '\x2', '\x2', '\xD1C', '\xD1B', '\x3', 
		'\x2', '\x2', '\x2', '\xD1D', '\xD1F', '\x3', '\x2', '\x2', '\x2', '\xD1E', 
		'\xD11', '\x3', '\x2', '\x2', '\x2', '\xD1E', '\xD18', '\x3', '\x2', '\x2', 
		'\x2', '\xD1F', '\x1E3', '\x3', '\x2', '\x2', '\x2', '\xD20', '\xD22', 
		'\x5', '\x5AE', '\x2D8', '\x2', '\xD21', '\xD20', '\x3', '\x2', '\x2', 
		'\x2', '\xD21', '\xD22', '\x3', '\x2', '\x2', '\x2', '\xD22', '\x1E5', 
		'\x3', '\x2', '\x2', '\x2', '\xD23', '\xD25', '\x5', '\x1E8', '\xF5', 
		'\x2', '\xD24', '\xD26', '\x5', '\x1EA', '\xF6', '\x2', '\xD25', '\xD24', 
		'\x3', '\x2', '\x2', '\x2', '\xD25', '\xD26', '\x3', '\x2', '\x2', '\x2', 
		'\xD26', '\x1E7', '\x3', '\x2', '\x2', '\x2', '\xD27', '\xD29', '\x5', 
		'\x1EC', '\xF7', '\x2', '\xD28', '\xD2A', '\x5', '\x1F2', '\xFA', '\x2', 
		'\xD29', '\xD28', '\x3', '\x2', '\x2', '\x2', '\xD29', '\xD2A', '\x3', 
		'\x2', '\x2', '\x2', '\xD2A', '\x1E9', '\x3', '\x2', '\x2', '\x2', '\xD2B', 
		'\xD2E', '\x5', '\x1EE', '\xF8', '\x2', '\xD2C', '\xD2E', '\x5', '\x1F4', 
		'\xFB', '\x2', '\xD2D', '\xD2B', '\x3', '\x2', '\x2', '\x2', '\xD2D', 
		'\xD2C', '\x3', '\x2', '\x2', '\x2', '\xD2E', '\x1EB', '\x3', '\x2', '\x2', 
		'\x2', '\xD2F', '\xD30', '\a', '\x198', '\x2', '\x2', '\xD30', '\xD32', 
		'\x5', '\x44', '#', '\x2', '\xD31', '\xD33', '\x5', '\x204', '\x103', 
		'\x2', '\xD32', '\xD31', '\x3', '\x2', '\x2', '\x2', '\xD32', '\xD33', 
		'\x3', '\x2', '\x2', '\x2', '\xD33', '\x1ED', '\x3', '\x2', '\x2', '\x2', 
		'\xD34', '\xD36', '\x5', '\x1F0', '\xF9', '\x2', '\xD35', '\xD37', '\x5', 
		'\x5AE', '\x2D8', '\x2', '\xD36', '\xD35', '\x3', '\x2', '\x2', '\x2', 
		'\xD36', '\xD37', '\x3', '\x2', '\x2', '\x2', '\xD37', '\xD38', '\x3', 
		'\x2', '\x2', '\x2', '\xD38', '\xD39', '\x5', '\x592', '\x2CA', '\x2', 
		'\xD39', '\x1EF', '\x3', '\x2', '\x2', '\x2', '\xD3A', '\xD3B', '\t', 
		'$', '\x2', '\x2', '\xD3B', '\x1F1', '\x3', '\x2', '\x2', '\x2', '\xD3C', 
		'\xD3D', '\a', '\x1D', '\x2', '\x2', '\xD3D', '\xD3E', '\t', '%', '\x2', 
		'\x2', '\xD3E', '\x1F3', '\x3', '\x2', '\x2', '\x2', '\xD3F', '\xD42', 
		'\a', '\x101', '\x2', '\x2', '\xD40', '\xD43', '\x5', '\x1F6', '\xFC', 
		'\x2', '\xD41', '\xD43', '\x5', '\x1F8', '\xFD', '\x2', '\xD42', '\xD40', 
		'\x3', '\x2', '\x2', '\x2', '\xD42', '\xD41', '\x3', '\x2', '\x2', '\x2', 
		'\xD43', '\x1F5', '\x3', '\x2', '\x2', '\x2', '\xD44', '\xD45', '\a', 
		'\xFA', '\x2', '\x2', '\xD45', '\xD46', '\a', '\x138', '\x2', '\x2', '\xD46', 
		'\xD47', '\x5', '&', '\x14', '\x2', '\xD47', '\x1F7', '\x3', '\x2', '\x2', 
		'\x2', '\xD48', '\xD4A', '\a', '\x35', '\x2', '\x2', '\xD49', '\xD4B', 
		'\x5', '\x1FA', '\xFE', '\x2', '\xD4A', '\xD49', '\x3', '\x2', '\x2', 
		'\x2', '\xD4A', '\xD4B', '\x3', '\x2', '\x2', '\x2', '\xD4B', '\xD4C', 
		'\x3', '\x2', '\x2', '\x2', '\xD4C', '\xD4E', '\x5', '\x1FC', '\xFF', 
		'\x2', '\xD4D', '\xD4F', '\x5', '\x1FE', '\x100', '\x2', '\xD4E', '\xD4D', 
		'\x3', '\x2', '\x2', '\x2', '\xD4E', '\xD4F', '\x3', '\x2', '\x2', '\x2', 
		'\xD4F', '\xD51', '\x3', '\x2', '\x2', '\x2', '\xD50', '\xD52', '\x5', 
		'\x200', '\x101', '\x2', '\xD51', '\xD50', '\x3', '\x2', '\x2', '\x2', 
		'\xD51', '\xD52', '\x3', '\x2', '\x2', '\x2', '\xD52', '\xD54', '\x3', 
		'\x2', '\x2', '\x2', '\xD53', '\xD55', '\x5', '\x202', '\x102', '\x2', 
		'\xD54', '\xD53', '\x3', '\x2', '\x2', '\x2', '\xD54', '\xD55', '\x3', 
		'\x2', '\x2', '\x2', '\xD55', '\x1F9', '\x3', '\x2', '\x2', '\x2', '\xD56', 
		'\xD57', '\a', '\x138', '\x2', '\x2', '\xD57', '\xD58', '\x5', '\x42', 
		'\"', '\x2', '\xD58', '\x1FB', '\x3', '\x2', '\x2', '\x2', '\xD59', '\xD5A', 
		'\a', '\x108', '\x2', '\x2', '\xD5A', '\xD5B', '\x5', '\x42', '\"', '\x2', 
		'\xD5B', '\x1FD', '\x3', '\x2', '\x2', '\x2', '\xD5C', '\xD5D', '\a', 
		'\b', '\x2', '\x2', '\xD5D', '\xD5E', '\a', '\xDE', '\x2', '\x2', '\xD5E', 
		'\xD5F', '\x5', '\x204', '\x103', '\x2', '\xD5F', '\x1FF', '\x3', '\x2', 
		'\x2', '\x2', '\xD60', '\xD61', '\a', '\x236', '\x2', '\x2', '\xD61', 
		'\xD62', '\a', '`', '\x2', '\x2', '\xD62', '\x201', '\x3', '\x2', '\x2', 
		'\x2', '\xD63', '\xD64', '\a', '\x17D', '\x2', '\x2', '\xD64', '\xD65', 
		'\a', '\x24D', '\x2', '\x2', '\xD65', '\xD66', '\x5', '\x178', '\xBD', 
		'\x2', '\xD66', '\xD67', '\a', '\x24E', '\x2', '\x2', '\xD67', '\x203', 
		'\x3', '\x2', '\x2', '\x2', '\xD68', '\xD71', '\a', '\x24D', '\x2', '\x2', 
		'\xD69', '\xD6E', '\x5', '\x206', '\x104', '\x2', '\xD6A', '\xD6B', '\a', 
		'\x24F', '\x2', '\x2', '\xD6B', '\xD6D', '\x5', '\x206', '\x104', '\x2', 
		'\xD6C', '\xD6A', '\x3', '\x2', '\x2', '\x2', '\xD6D', '\xD70', '\x3', 
		'\x2', '\x2', '\x2', '\xD6E', '\xD6C', '\x3', '\x2', '\x2', '\x2', '\xD6E', 
		'\xD6F', '\x3', '\x2', '\x2', '\x2', '\xD6F', '\xD72', '\x3', '\x2', '\x2', 
		'\x2', '\xD70', '\xD6E', '\x3', '\x2', '\x2', '\x2', '\xD71', '\xD69', 
		'\x3', '\x2', '\x2', '\x2', '\xD71', '\xD72', '\x3', '\x2', '\x2', '\x2', 
		'\xD72', '\xD73', '\x3', '\x2', '\x2', '\x2', '\xD73', '\xD74', '\a', 
		'\x24E', '\x2', '\x2', '\xD74', '\x205', '\x3', '\x2', '\x2', '\x2', '\xD75', 
		'\xD77', '\x5', 'N', '(', '\x2', '\xD76', '\xD78', '\x5', '\x20A', '\x106', 
		'\x2', '\xD77', '\xD76', '\x3', '\x2', '\x2', '\x2', '\xD77', '\xD78', 
		'\x3', '\x2', '\x2', '\x2', '\xD78', '\xD7A', '\x3', '\x2', '\x2', '\x2', 
		'\xD79', '\xD7B', '\x5', '\x208', '\x105', '\x2', '\xD7A', '\xD79', '\x3', 
		'\x2', '\x2', '\x2', '\xD7A', '\xD7B', '\x3', '\x2', '\x2', '\x2', '\xD7B', 
		'\xD7C', '\x3', '\x2', '\x2', '\x2', '\xD7C', '\xD7E', '\x5', '`', '\x31', 
		'\x2', '\xD7D', '\xD7F', '\x5', '\x20C', '\x107', '\x2', '\xD7E', '\xD7D', 
		'\x3', '\x2', '\x2', '\x2', '\xD7E', '\xD7F', '\x3', '\x2', '\x2', '\x2', 
		'\xD7F', '\x207', '\x3', '\x2', '\x2', '\x2', '\xD80', '\xD81', '\a', 
		'\x148', '\x2', '\x2', '\xD81', '\x209', '\x3', '\x2', '\x2', '\x2', '\xD82', 
		'\xD83', '\a', '\xDE', '\x2', '\x2', '\xD83', '\xD87', '\a', '\x174', 
		'\x2', '\x2', '\xD84', '\xD87', '\a', '\xDE', '\x2', '\x2', '\xD85', '\xD87', 
		'\a', '\x174', '\x2', '\x2', '\xD86', '\xD82', '\x3', '\x2', '\x2', '\x2', 
		'\xD86', '\xD84', '\x3', '\x2', '\x2', '\x2', '\xD86', '\xD85', '\x3', 
		'\x2', '\x2', '\x2', '\xD87', '\x20B', '\x3', '\x2', '\x2', '\x2', '\xD88', 
		'\xD89', '\t', '&', '\x2', '\x2', '\xD89', '\xD8A', '\x5', '\xA0', 'Q', 
		'\x2', '\xD8A', '\x20D', '\x3', '\x2', '\x2', '\x2', '\xD8B', '\xD8D', 
		'\x5', '\x210', '\x109', '\x2', '\xD8C', '\xD8E', '\x5', '\x212', '\x10A', 
		'\x2', '\xD8D', '\xD8C', '\x3', '\x2', '\x2', '\x2', '\xD8D', '\xD8E', 
		'\x3', '\x2', '\x2', '\x2', '\xD8E', '\x20F', '\x3', '\x2', '\x2', '\x2', 
		'\xD8F', '\xD90', '\x5', '\x214', '\x10B', '\x2', '\xD90', '\xD99', '\x5', 
		'\x216', '\x10C', '\x2', '\xD91', '\xD98', '\x5', '\x1F2', '\xFA', '\x2', 
		'\xD92', '\xD98', '\x5', '\x218', '\x10D', '\x2', '\xD93', '\xD98', '\x5', 
		'\x21A', '\x10E', '\x2', '\xD94', '\xD98', '\x5', '\x22A', '\x116', '\x2', 
		'\xD95', '\xD98', '\x5', '\x22C', '\x117', '\x2', '\xD96', '\xD98', '\x5', 
		'\x226', '\x114', '\x2', '\xD97', '\xD91', '\x3', '\x2', '\x2', '\x2', 
		'\xD97', '\xD92', '\x3', '\x2', '\x2', '\x2', '\xD97', '\xD93', '\x3', 
		'\x2', '\x2', '\x2', '\xD97', '\xD94', '\x3', '\x2', '\x2', '\x2', '\xD97', 
		'\xD95', '\x3', '\x2', '\x2', '\x2', '\xD97', '\xD96', '\x3', '\x2', '\x2', 
		'\x2', '\xD98', '\xD9B', '\x3', '\x2', '\x2', '\x2', '\xD99', '\xD97', 
		'\x3', '\x2', '\x2', '\x2', '\xD99', '\xD9A', '\x3', '\x2', '\x2', '\x2', 
		'\xD9A', '\x211', '\x3', '\x2', '\x2', '\x2', '\xD9B', '\xD99', '\x3', 
		'\x2', '\x2', '\x2', '\xD9C', '\xD9F', '\x5', '\x1EE', '\xF8', '\x2', 
		'\xD9D', '\xD9F', '\x5', '\x1F4', '\xFB', '\x2', '\xD9E', '\xD9C', '\x3', 
		'\x2', '\x2', '\x2', '\xD9E', '\xD9D', '\x3', '\x2', '\x2', '\x2', '\xD9F', 
		'\x213', '\x3', '\x2', '\x2', '\x2', '\xDA0', '\xDA3', '\a', '\xCA', '\x2', 
		'\x2', '\xDA1', '\xDA4', '\x5', '\x44', '#', '\x2', '\xDA2', '\xDA4', 
		'\x5', 'R', '*', '\x2', '\xDA3', '\xDA1', '\x3', '\x2', '\x2', '\x2', 
		'\xDA3', '\xDA2', '\x3', '\x2', '\x2', '\x2', '\xDA4', '\xDA6', '\x3', 
		'\x2', '\x2', '\x2', '\xDA5', '\xDA7', '\x5', '\x204', '\x103', '\x2', 
		'\xDA6', '\xDA5', '\x3', '\x2', '\x2', '\x2', '\xDA6', '\xDA7', '\x3', 
		'\x2', '\x2', '\x2', '\xDA7', '\x215', '\x3', '\x2', '\x2', '\x2', '\xDA8', 
		'\xDA9', '\a', '\x1B6', '\x2', '\x2', '\xDA9', '\xDAA', '\x5', '`', '\x31', 
		'\x2', '\xDAA', '\x217', '\x3', '\x2', '\x2', '\x2', '\xDAB', '\xDAC', 
		'\a', '\x82', '\x2', '\x2', '\xDAC', '\x219', '\x3', '\x2', '\x2', '\x2', 
		'\xDAD', '\xDAF', '\a', '\x17C', '\x2', '\x2', '\xDAE', '\xDB0', '\x5', 
		'\x21C', '\x10F', '\x2', '\xDAF', '\xDAE', '\x3', '\x2', '\x2', '\x2', 
		'\xDAF', '\xDB0', '\x3', '\x2', '\x2', '\x2', '\xDB0', '\x21B', '\x3', 
		'\x2', '\x2', '\x2', '\xDB1', '\xDB2', '\a', '\x24D', '\x2', '\x2', '\xDB2', 
		'\xDB3', '\a', '\x180', '\x2', '\x2', '\xDB3', '\xDB4', '\x5', 'N', '(', 
		'\x2', '\xDB4', '\xDB5', '\x5', '\x21E', '\x110', '\x2', '\xDB5', '\xDB6', 
		'\a', '\x24E', '\x2', '\x2', '\xDB6', '\x21D', '\x3', '\x2', '\x2', '\x2', 
		'\xDB7', '\xDC0', '\a', '\x33', '\x2', '\x2', '\xDB8', '\xDC1', '\a', 
		'\x11', '\x2', '\x2', '\xDB9', '\xDBA', '\a', '\x227', '\x2', '\x2', '\xDBA', 
		'\xDC1', '\x5', '\x220', '\x111', '\x2', '\xDBB', '\xDBC', '\t', '\'', 
		'\x2', '\x2', '\xDBC', '\xDBE', '\x5', '\x368', '\x1B5', '\x2', '\xDBD', 
		'\xDBF', '\x5', '\x222', '\x112', '\x2', '\xDBE', '\xDBD', '\x3', '\x2', 
		'\x2', '\x2', '\xDBE', '\xDBF', '\x3', '\x2', '\x2', '\x2', '\xDBF', '\xDC1', 
		'\x3', '\x2', '\x2', '\x2', '\xDC0', '\xDB8', '\x3', '\x2', '\x2', '\x2', 
		'\xDC0', '\xDB9', '\x3', '\x2', '\x2', '\x2', '\xDC0', '\xDBB', '\x3', 
		'\x2', '\x2', '\x2', '\xDC1', '\x21F', '\x3', '\x2', '\x2', '\x2', '\xDC2', 
		'\xDC3', '\a', '\x24D', '\x2', '\x2', '\xDC3', '\xDC4', '\x5', '\x17C', 
		'\xBF', '\x2', '\xDC4', '\xDC5', '\a', '\x24E', '\x2', '\x2', '\xDC5', 
		'\x221', '\x3', '\x2', '\x2', '\x2', '\xDC6', '\xDC7', '\t', '(', '\x2', 
		'\x2', '\xDC7', '\xDC8', '\x5', '\xC6', '\x64', '\x2', '\xDC8', '\xDC9', 
		'\x5', '\x224', '\x113', '\x2', '\xDC9', '\x223', '\x3', '\x2', '\x2', 
		'\x2', '\xDCA', '\xDCB', '\a', '\x33', '\x2', '\x2', '\xDCB', '\xDCC', 
		'\x5', '\x368', '\x1B5', '\x2', '\xDCC', '\x225', '\x3', '\x2', '\x2', 
		'\x2', '\xDCD', '\xDCF', '\a', '\x1B4', '\x2', '\x2', '\xDCE', '\xDD0', 
		'\x5', '\x228', '\x115', '\x2', '\xDCF', '\xDCE', '\x3', '\x2', '\x2', 
		'\x2', '\xDCF', '\xDD0', '\x3', '\x2', '\x2', '\x2', '\xDD0', '\x227', 
		'\x3', '\x2', '\x2', '\x2', '\xDD1', '\xDD2', '\a', '\x1AE', '\x2', '\x2', 
		'\xDD2', '\xDD3', '\a', '\x24D', '\x2', '\x2', '\xDD3', '\xDD8', '\x5', 
		'\x42', '\"', '\x2', '\xDD4', '\xDD5', '\a', '\x24F', '\x2', '\x2', '\xDD5', 
		'\xDD7', '\x5', '\x42', '\"', '\x2', '\xDD6', '\xDD4', '\x3', '\x2', '\x2', 
		'\x2', '\xDD7', '\xDDA', '\x3', '\x2', '\x2', '\x2', '\xDD8', '\xDD6', 
		'\x3', '\x2', '\x2', '\x2', '\xDD8', '\xDD9', '\x3', '\x2', '\x2', '\x2', 
		'\xDD9', '\xDDB', '\x3', '\x2', '\x2', '\x2', '\xDDA', '\xDD8', '\x3', 
		'\x2', '\x2', '\x2', '\xDDB', '\xDDC', '\a', '\x24E', '\x2', '\x2', '\xDDC', 
		'\x229', '\x3', '\x2', '\x2', '\x2', '\xDDD', '\xDDE', '\a', '\t', '\x2', 
		'\x2', '\xDDE', '\xDDF', '\a', '\x225', '\x2', '\x2', '\xDDF', '\xDE0', 
		'\x5', '\x42', '\"', '\x2', '\xDE0', '\x22B', '\x3', '\x2', '\x2', '\x2', 
		'\xDE1', '\xDE4', '\a', '\x18D', '\x2', '\x2', '\xDE2', '\xDE3', '\t', 
		')', '\x2', '\x2', '\xDE3', '\xDE5', '\a', '\x18F', '\x2', '\x2', '\xDE4', 
		'\xDE2', '\x3', '\x2', '\x2', '\x2', '\xDE4', '\xDE5', '\x3', '\x2', '\x2', 
		'\x2', '\xDE5', '\xDE8', '\x3', '\x2', '\x2', '\x2', '\xDE6', '\xDE7', 
		'\a', '\x225', '\x2', '\x2', '\xDE7', '\xDE9', '\x5', '\x42', '\"', '\x2', 
		'\xDE8', '\xDE6', '\x3', '\x2', '\x2', '\x2', '\xDE8', '\xDE9', '\x3', 
		'\x2', '\x2', '\x2', '\xDE9', '\x22D', '\x3', '\x2', '\x2', '\x2', '\xDEA', 
		'\xDEE', '\x5', '\x230', '\x119', '\x2', '\xDEB', '\xDEF', '\x5', '\x232', 
		'\x11A', '\x2', '\xDEC', '\xDEF', '\x5', '\x240', '\x121', '\x2', '\xDED', 
		'\xDEF', '\x5', '\x242', '\x122', '\x2', '\xDEE', '\xDEB', '\x3', '\x2', 
		'\x2', '\x2', '\xDEE', '\xDEC', '\x3', '\x2', '\x2', '\x2', '\xDEE', '\xDED', 
		'\x3', '\x2', '\x2', '\x2', '\xDEF', '\xDF1', '\x3', '\x2', '\x2', '\x2', 
		'\xDF0', '\xDF2', '\x5', '\x234', '\x11B', '\x2', '\xDF1', '\xDF0', '\x3', 
		'\x2', '\x2', '\x2', '\xDF1', '\xDF2', '\x3', '\x2', '\x2', '\x2', '\xDF2', 
		'\xDF4', '\x3', '\x2', '\x2', '\x2', '\xDF3', '\xDF5', '\x5', '\x236', 
		'\x11C', '\x2', '\xDF4', '\xDF3', '\x3', '\x2', '\x2', '\x2', '\xDF4', 
		'\xDF5', '\x3', '\x2', '\x2', '\x2', '\xDF5', '\x22F', '\x3', '\x2', '\x2', 
		'\x2', '\xDF6', '\xDF7', '\a', '\xCC', '\x2', '\x2', '\xDF7', '\xDFD', 
		'\a', '\x201', '\x2', '\x2', '\xDF8', '\xDF9', '\a', '\x197', '\x2', '\x2', 
		'\xDF9', '\xDFD', '\a', '\x201', '\x2', '\x2', '\xDFA', '\xDFD', '\a', 
		'\x1F1', '\x2', '\x2', '\xDFB', '\xDFD', '\a', '\x90', '\x2', '\x2', '\xDFC', 
		'\xDF6', '\x3', '\x2', '\x2', '\x2', '\xDFC', '\xDF8', '\x3', '\x2', '\x2', 
		'\x2', '\xDFC', '\xDFA', '\x3', '\x2', '\x2', '\x2', '\xDFC', '\xDFB', 
		'\x3', '\x2', '\x2', '\x2', '\xDFC', '\xDFD', '\x3', '\x2', '\x2', '\x2', 
		'\xDFD', '\xDFE', '\x3', '\x2', '\x2', '\x2', '\xDFE', '\xDFF', '\a', 
		'\x1FD', '\x2', '\x2', '\xDFF', '\xE09', '\x5', '\x44', '#', '\x2', '\xE00', 
		'\xE01', '\a', '\x1F2', '\x2', '\x2', '\xE01', '\xE07', '\a', '\x255', 
		'\x2', '\x2', '\xE02', '\xE08', '\a', '\x12B', '\x2', '\x2', '\xE03', 
		'\xE08', '\a', 'l', '\x2', '\x2', '\xE04', '\xE05', '\a', '\xAF', '\x2', 
		'\x2', '\xE05', '\xE08', '\a', 'l', '\x2', '\x2', '\xE06', '\xE08', '\a', 
		'\x152', '\x2', '\x2', '\xE07', '\xE02', '\x3', '\x2', '\x2', '\x2', '\xE07', 
		'\xE03', '\x3', '\x2', '\x2', '\x2', '\xE07', '\xE04', '\x3', '\x2', '\x2', 
		'\x2', '\xE07', '\xE06', '\x3', '\x2', '\x2', '\x2', '\xE08', '\xE0A', 
		'\x3', '\x2', '\x2', '\x2', '\xE09', '\xE00', '\x3', '\x2', '\x2', '\x2', 
		'\xE09', '\xE0A', '\x3', '\x2', '\x2', '\x2', '\xE0A', '\x231', '\x3', 
		'\x2', '\x2', '\x2', '\xE0B', '\xE0D', '\x5', '\x23E', '\x120', '\x2', 
		'\xE0C', '\xE0E', '\x5', '\x25E', '\x130', '\x2', '\xE0D', '\xE0C', '\x3', 
		'\x2', '\x2', '\x2', '\xE0D', '\xE0E', '\x3', '\x2', '\x2', '\x2', '\xE0E', 
		'\xE10', '\x3', '\x2', '\x2', '\x2', '\xE0F', '\xE11', '\x5', '\x2E4', 
		'\x173', '\x2', '\xE10', '\xE0F', '\x3', '\x2', '\x2', '\x2', '\xE10', 
		'\xE11', '\x3', '\x2', '\x2', '\x2', '\xE11', '\xE13', '\x3', '\x2', '\x2', 
		'\x2', '\xE12', '\xE14', '\x5', '\x23C', '\x11F', '\x2', '\xE13', '\xE12', 
		'\x3', '\x2', '\x2', '\x2', '\xE13', '\xE14', '\x3', '\x2', '\x2', '\x2', 
		'\xE14', '\xE16', '\x3', '\x2', '\x2', '\x2', '\xE15', '\xE17', '\x5', 
		'\x238', '\x11D', '\x2', '\xE16', '\xE15', '\x3', '\x2', '\x2', '\x2', 
		'\xE16', '\xE17', '\x3', '\x2', '\x2', '\x2', '\xE17', '\xE19', '\x3', 
		'\x2', '\x2', '\x2', '\xE18', '\xE1A', '\x5', '\x2C4', '\x163', '\x2', 
		'\xE19', '\xE18', '\x3', '\x2', '\x2', '\x2', '\xE19', '\xE1A', '\x3', 
		'\x2', '\x2', '\x2', '\xE1A', '\xE1B', '\x3', '\x2', '\x2', '\x2', '\xE1B', 
		'\xE1C', '\x5', '\x244', '\x123', '\x2', '\xE1C', '\x233', '\x3', '\x2', 
		'\x2', '\x2', '\xE1D', '\xE1E', '\a', '\x129', '\x2', '\x2', '\xE1E', 
		'\xE1F', '\a', '\xBE', '\x2', '\x2', '\xE1F', '\xE21', '\t', '*', '\x2', 
		'\x2', '\xE20', '\xE1D', '\x3', '\x2', '\x2', '\x2', '\xE21', '\xE22', 
		'\x3', '\x2', '\x2', '\x2', '\xE22', '\xE20', '\x3', '\x2', '\x2', '\x2', 
		'\xE22', '\xE23', '\x3', '\x2', '\x2', '\x2', '\xE23', '\x235', '\x3', 
		'\x2', '\x2', '\x2', '\xE24', '\xE25', '\a', '\x17E', '\x2', '\x2', '\xE25', 
		'\xE26', '\x5', '\x44', '#', '\x2', '\xE26', '\x237', '\x3', '\x2', '\x2', 
		'\x2', '\xE27', '\xE29', '\a', '\x166', '\x2', '\x2', '\xE28', '\xE2A', 
		'\x5', '\x42', '\"', '\x2', '\xE29', '\xE28', '\x3', '\x2', '\x2', '\x2', 
		'\xE29', '\xE2A', '\x3', '\x2', '\x2', '\x2', '\xE2A', '\xE2B', '\x3', 
		'\x2', '\x2', '\x2', '\xE2B', '\xE2C', '\x5', '\x23A', '\x11E', '\x2', 
		'\xE2C', '\x239', '\x3', '\x2', '\x2', '\x2', '\xE2D', '\xE30', '\a', 
		'\x24D', '\x2', '\x2', '\xE2E', '\xE31', '\x5', '\x61E', '\x310', '\x2', 
		'\xE2F', '\xE31', '\x5', '\x380', '\x1C1', '\x2', '\xE30', '\xE2E', '\x3', 
		'\x2', '\x2', '\x2', '\xE30', '\xE2F', '\x3', '\x2', '\x2', '\x2', '\xE31', 
		'\xE32', '\x3', '\x2', '\x2', '\x2', '\xE32', '\xE30', '\x3', '\x2', '\x2', 
		'\x2', '\xE32', '\xE33', '\x3', '\x2', '\x2', '\x2', '\xE33', '\xE34', 
		'\x3', '\x2', '\x2', '\x2', '\xE34', '\xE35', '\a', '\x24E', '\x2', '\x2', 
		'\xE35', '\x23B', '\x3', '\x2', '\x2', '\x2', '\xE36', '\xE37', '\a', 
		'\x163', '\x2', '\x2', '\xE37', '\xE38', '\a', '\xDA', '\x2', '\x2', '\xE38', 
		'\xE3D', '\a', '\xF7', '\x2', '\x2', '\xE39', '\xE3A', '\a', '\x1FC', 
		'\x2', '\x2', '\xE3A', '\xE3E', '\a', '\xCB', '\x2', '\x2', '\xE3B', '\xE3C', 
		'\a', '\x195', '\x2', '\x2', '\xE3C', '\xE3E', '\a', '\x100', '\x2', '\x2', 
		'\xE3D', '\xE39', '\x3', '\x2', '\x2', '\x2', '\xE3D', '\xE3B', '\x3', 
		'\x2', '\x2', '\x2', '\xE3E', '\x23D', '\x3', '\x2', '\x2', '\x2', '\xE3F', 
		'\xE40', '\a', '\x164', '\x2', '\x2', '\xE40', '\xE42', '\x5', '\x44', 
		'#', '\x2', '\xE41', '\xE43', '\x5', '\x2AC', '\x157', '\x2', '\xE42', 
		'\xE41', '\x3', '\x2', '\x2', '\x2', '\xE42', '\xE43', '\x3', '\x2', '\x2', 
		'\x2', '\xE43', '\x23F', '\x3', '\x2', '\x2', '\x2', '\xE44', '\xE46', 
		'\x5', '\x2E6', '\x174', '\x2', '\xE45', '\xE44', '\x3', '\x2', '\x2', 
		'\x2', '\xE45', '\xE46', '\x3', '\x2', '\x2', '\x2', '\xE46', '\xE48', 
		'\x3', '\x2', '\x2', '\x2', '\xE47', '\xE49', '\x5', '\x192', '\xCA', 
		'\x2', '\xE48', '\xE47', '\x3', '\x2', '\x2', '\x2', '\xE48', '\xE49', 
		'\x3', '\x2', '\x2', '\x2', '\xE49', '\xE4B', '\x3', '\x2', '\x2', '\x2', 
		'\xE4A', '\xE4C', '\x5', '\x2E4', '\x173', '\x2', '\xE4B', '\xE4A', '\x3', 
		'\x2', '\x2', '\x2', '\xE4B', '\xE4C', '\x3', '\x2', '\x2', '\x2', '\xE4C', 
		'\xE4E', '\x3', '\x2', '\x2', '\x2', '\xE4D', '\xE4F', '\x5', '\x2C4', 
		'\x163', '\x2', '\xE4E', '\xE4D', '\x3', '\x2', '\x2', '\x2', '\xE4E', 
		'\xE4F', '\x3', '\x2', '\x2', '\x2', '\xE4F', '\xE50', '\x3', '\x2', '\x2', 
		'\x2', '\xE50', '\xE51', '\x5', '\x244', '\x123', '\x2', '\xE51', '\x241', 
		'\x3', '\x2', '\x2', '\x2', '\xE52', '\xE53', '\a', '\x164', '\x2', '\x2', 
		'\xE53', '\xE55', '\a', '\x244', '\x2', '\x2', '\xE54', '\xE56', '\x5', 
		'\x25E', '\x130', '\x2', '\xE55', '\xE54', '\x3', '\x2', '\x2', '\x2', 
		'\xE55', '\xE56', '\x3', '\x2', '\x2', '\x2', '\xE56', '\x243', '\x3', 
		'\x2', '\x2', '\x2', '\xE57', '\xE59', '\x5', '\x246', '\x124', '\x2', 
		'\xE58', '\xE57', '\x3', '\x2', '\x2', '\x2', '\xE58', '\xE59', '\x3', 
		'\x2', '\x2', '\x2', '\xE59', '\xE5B', '\x3', '\x2', '\x2', '\x2', '\xE5A', 
		'\xE5C', '\x5', '\x276', '\x13C', '\x2', '\xE5B', '\xE5A', '\x3', '\x2', 
		'\x2', '\x2', '\xE5B', '\xE5C', '\x3', '\x2', '\x2', '\x2', '\xE5C', '\xE5E', 
		'\x3', '\x2', '\x2', '\x2', '\xE5D', '\xE5F', '\x5', '\x2B8', '\x15D', 
		'\x2', '\xE5E', '\xE5D', '\x3', '\x2', '\x2', '\x2', '\xE5E', '\xE5F', 
		'\x3', '\x2', '\x2', '\x2', '\xE5F', '\xE61', '\x3', '\x2', '\x2', '\x2', 
		'\xE60', '\xE62', '\x5', '\x274', '\x13B', '\x2', '\xE61', '\xE60', '\x3', 
		'\x2', '\x2', '\x2', '\xE61', '\xE62', '\x3', '\x2', '\x2', '\x2', '\xE62', 
		'\xE64', '\x3', '\x2', '\x2', '\x2', '\xE63', '\xE65', '\x5', '\x272', 
		'\x13A', '\x2', '\xE64', '\xE63', '\x3', '\x2', '\x2', '\x2', '\xE64', 
		'\xE65', '\x3', '\x2', '\x2', '\x2', '\xE65', '\xE67', '\x3', '\x2', '\x2', 
		'\x2', '\xE66', '\xE68', '\x5', '\x270', '\x139', '\x2', '\xE67', '\xE66', 
		'\x3', '\x2', '\x2', '\x2', '\xE67', '\xE68', '\x3', '\x2', '\x2', '\x2', 
		'\xE68', '\xE6C', '\x3', '\x2', '\x2', '\x2', '\xE69', '\xE6B', '\x5', 
		'\x26A', '\x136', '\x2', '\xE6A', '\xE69', '\x3', '\x2', '\x2', '\x2', 
		'\xE6B', '\xE6E', '\x3', '\x2', '\x2', '\x2', '\xE6C', '\xE6A', '\x3', 
		'\x2', '\x2', '\x2', '\xE6C', '\xE6D', '\x3', '\x2', '\x2', '\x2', '\xE6D', 
		'\xE70', '\x3', '\x2', '\x2', '\x2', '\xE6E', '\xE6C', '\x3', '\x2', '\x2', 
		'\x2', '\xE6F', '\xE71', '\x5', '\x268', '\x135', '\x2', '\xE70', '\xE6F', 
		'\x3', '\x2', '\x2', '\x2', '\xE70', '\xE71', '\x3', '\x2', '\x2', '\x2', 
		'\xE71', '\xE73', '\x3', '\x2', '\x2', '\x2', '\xE72', '\xE74', '\x5', 
		'\x266', '\x134', '\x2', '\xE73', '\xE72', '\x3', '\x2', '\x2', '\x2', 
		'\xE73', '\xE74', '\x3', '\x2', '\x2', '\x2', '\xE74', '\x245', '\x3', 
		'\x2', '\x2', '\x2', '\xE75', '\xE7D', '\x5', '\x258', '\x12D', '\x2', 
		'\xE76', '\xE7D', '\x5', '\x254', '\x12B', '\x2', '\xE77', '\xE7A', '\x5', 
		'\x2A8', '\x155', '\x2', '\xE78', '\xE7A', '\x5', '\x2B4', '\x15B', '\x2', 
		'\xE79', '\xE77', '\x3', '\x2', '\x2', '\x2', '\xE79', '\xE78', '\x3', 
		'\x2', '\x2', '\x2', '\xE7A', '\xE7D', '\x3', '\x2', '\x2', '\x2', '\xE7B', 
		'\xE7D', '\x5', '\x248', '\x125', '\x2', '\xE7C', '\xE75', '\x3', '\x2', 
		'\x2', '\x2', '\xE7C', '\xE76', '\x3', '\x2', '\x2', '\x2', '\xE7C', '\xE79', 
		'\x3', '\x2', '\x2', '\x2', '\xE7C', '\xE7B', '\x3', '\x2', '\x2', '\x2', 
		'\xE7D', '\xE7E', '\x3', '\x2', '\x2', '\x2', '\xE7E', '\xE7C', '\x3', 
		'\x2', '\x2', '\x2', '\xE7E', '\xE7F', '\x3', '\x2', '\x2', '\x2', '\xE7F', 
		'\x247', '\x3', '\x2', '\x2', '\x2', '\xE80', '\xE82', '\a', '\x244', 
		'\x2', '\x2', '\xE81', '\xE83', '\a', 'J', '\x2', '\x2', '\xE82', '\xE81', 
		'\x3', '\x2', '\x2', '\x2', '\xE82', '\xE83', '\x3', '\x2', '\x2', '\x2', 
		'\xE83', '\xE84', '\x3', '\x2', '\x2', '\x2', '\xE84', '\xE86', '\x5', 
		'\x17C', '\xBF', '\x2', '\xE85', '\xE87', '\x5', '\x24A', '\x126', '\x2', 
		'\xE86', '\xE85', '\x3', '\x2', '\x2', '\x2', '\xE86', '\xE87', '\x3', 
		'\x2', '\x2', '\x2', '\xE87', '\xE88', '\x3', '\x2', '\x2', '\x2', '\xE88', 
		'\xE8B', '\x5', '\x342', '\x1A2', '\x2', '\xE89', '\xE8A', '\a', '\xD8', 
		'\x2', '\x2', '\xE8A', '\xE8C', '\x5', '&', '\x14', '\x2', '\xE8B', '\xE89', 
		'\x3', '\x2', '\x2', '\x2', '\xE8B', '\xE8C', '\x3', '\x2', '\x2', '\x2', 
		'\xE8C', '\x249', '\x3', '\x2', '\x2', '\x2', '\xE8D', '\xE90', '\x5', 
		'\x24C', '\x127', '\x2', '\xE8E', '\xE90', '\x5', '\x252', '\x12A', '\x2', 
		'\xE8F', '\xE8D', '\x3', '\x2', '\x2', '\x2', '\xE8F', '\xE8E', '\x3', 
		'\x2', '\x2', '\x2', '\xE90', '\x24B', '\x3', '\x2', '\x2', '\x2', '\xE91', 
		'\xE92', '\a', '\x1EE', '\x2', '\x2', '\xE92', '\xE95', '\a', '\x15', 
		'\x2', '\x2', '\xE93', '\xE96', '\x5', '\x24E', '\x128', '\x2', '\xE94', 
		'\xE96', '\x5', '\x250', '\x129', '\x2', '\xE95', '\xE93', '\x3', '\x2', 
		'\x2', '\x2', '\xE95', '\xE94', '\x3', '\x2', '\x2', '\x2', '\xE96', '\x24D', 
		'\x3', '\x2', '\x2', '\x2', '\xE97', '\xE98', '\a', '\x163', '\x2', '\x2', 
		'\xE98', '\xE99', '\a', '\x1AD', '\x2', '\x2', '\xE99', '\x24F', '\x3', 
		'\x2', '\x2', '\x2', '\xE9A', '\xE9C', '\t', '+', '\x2', '\x2', '\xE9B', 
		'\xE9A', '\x3', '\x2', '\x2', '\x2', '\xE9B', '\xE9C', '\x3', '\x2', '\x2', 
		'\x2', '\xE9C', '\xEA0', '\x3', '\x2', '\x2', '\x2', '\xE9D', '\xEA1', 
		'\a', '\x43', '\x2', '\x2', '\xE9E', '\xE9F', '\a', '\'', '\x2', '\x2', 
		'\xE9F', '\xEA1', '\a', '\x23D', '\x2', '\x2', '\xEA0', '\xE9D', '\x3', 
		'\x2', '\x2', '\x2', '\xEA0', '\xE9E', '\x3', '\x2', '\x2', '\x2', '\xEA1', 
		'\xEA3', '\x3', '\x2', '\x2', '\x2', '\xEA2', '\xEA4', '\x5', 'Z', '.', 
		'\x2', '\xEA3', '\xEA2', '\x3', '\x2', '\x2', '\x2', '\xEA3', '\xEA4', 
		'\x3', '\x2', '\x2', '\x2', '\xEA4', '\xEA6', '\x3', '\x2', '\x2', '\x2', 
		'\xEA5', '\xEA7', '\x5', '\x2B6', '\x15C', '\x2', '\xEA6', '\xEA5', '\x3', 
		'\x2', '\x2', '\x2', '\xEA6', '\xEA7', '\x3', '\x2', '\x2', '\x2', '\xEA7', 
		'\x251', '\x3', '\x2', '\x2', '\x2', '\xEA8', '\xEA9', '\a', '\x1EE', 
		'\x2', '\x2', '\xEA9', '\xEAA', '\a', '\n', '\x2', '\x2', '\xEAA', '\xEAB', 
		'\a', '\x22C', '\x2', '\x2', '\xEAB', '\xEAC', '\a', '\x15', '\x2', '\x2', 
		'\xEAC', '\xEAD', '\t', ',', '\x2', '\x2', '\xEAD', '\x253', '\x3', '\x2', 
		'\x2', '\x2', '\xEAE', '\xEAF', '\a', 'J', '\x2', '\x2', '\xEAF', '\xEB0', 
		'\x5', '\x17C', '\xBF', '\x2', '\xEB0', '\xEB1', '\x5', '\x2AA', '\x156', 
		'\x2', '\xEB1', '\x255', '\x3', '\x2', '\x2', '\x2', '\xEB2', '\xEB3', 
		'\a', '\x22B', '\x2', '\x2', '\xEB3', '\xEB4', '\x5', '\x17C', '\xBF', 
		'\x2', '\xEB4', '\xEB5', '\x5', '\x2AA', '\x156', '\x2', '\xEB5', '\x257', 
		'\x3', '\x2', '\x2', '\x2', '\xEB6', '\xEB7', '\a', '\x13F', '\x2', '\x2', 
		'\xEB7', '\xEB8', '\a', '\x1FD', '\x2', '\x2', '\xEB8', '\xEBA', '\x5', 
		'\x264', '\x133', '\x2', '\xEB9', '\xEBB', '\x5', '\x2AA', '\x156', '\x2', 
		'\xEBA', '\xEB9', '\x3', '\x2', '\x2', '\x2', '\xEBA', '\xEBB', '\x3', 
		'\x2', '\x2', '\x2', '\xEBB', '\xEBC', '\x3', '\x2', '\x2', '\x2', '\xEBC', 
		'\xEBE', '\x5', '\x262', '\x132', '\x2', '\xEBD', '\xEBF', '\x5', '\x25A', 
		'\x12E', '\x2', '\xEBE', '\xEBD', '\x3', '\x2', '\x2', '\x2', '\xEBE', 
		'\xEBF', '\x3', '\x2', '\x2', '\x2', '\xEBF', '\xEC1', '\x3', '\x2', '\x2', 
		'\x2', '\xEC0', '\xEC2', '\x5', '\x25C', '\x12F', '\x2', '\xEC1', '\xEC0', 
		'\x3', '\x2', '\x2', '\x2', '\xEC1', '\xEC2', '\x3', '\x2', '\x2', '\x2', 
		'\xEC2', '\x259', '\x3', '\x2', '\x2', '\x2', '\xEC3', '\xEC7', '\a', 
		'\x24D', '\x2', '\x2', '\xEC4', '\xEC8', '\x5', '\x25E', '\x130', '\x2', 
		'\xEC5', '\xEC8', '\x5', '\x2C4', '\x163', '\x2', '\xEC6', '\xEC8', '\x5', 
		'\x246', '\x124', '\x2', '\xEC7', '\xEC4', '\x3', '\x2', '\x2', '\x2', 
		'\xEC7', '\xEC5', '\x3', '\x2', '\x2', '\x2', '\xEC7', '\xEC6', '\x3', 
		'\x2', '\x2', '\x2', '\xEC8', '\xEC9', '\x3', '\x2', '\x2', '\x2', '\xEC9', 
		'\xECA', '\a', '\x24E', '\x2', '\x2', '\xECA', '\x25B', '\x3', '\x2', 
		'\x2', '\x2', '\xECB', '\xECD', '\a', '\x1B6', '\x2', '\x2', '\xECC', 
		'\xECE', '\a', '\x15', '\x2', '\x2', '\xECD', '\xECC', '\x3', '\x2', '\x2', 
		'\x2', '\xECD', '\xECE', '\x3', '\x2', '\x2', '\x2', '\xECE', '\xECF', 
		'\x3', '\x2', '\x2', '\x2', '\xECF', '\xED0', '\t', '-', '\x2', '\x2', 
		'\xED0', '\x25D', '\x3', '\x2', '\x2', '\x2', '\xED1', '\xED2', '\a', 
		'\x24D', '\x2', '\x2', '\xED2', '\xED7', '\x5', '\x260', '\x131', '\x2', 
		'\xED3', '\xED4', '\a', '\x24F', '\x2', '\x2', '\xED4', '\xED6', '\x5', 
		'\x260', '\x131', '\x2', '\xED5', '\xED3', '\x3', '\x2', '\x2', '\x2', 
		'\xED6', '\xED9', '\x3', '\x2', '\x2', '\x2', '\xED7', '\xED5', '\x3', 
		'\x2', '\x2', '\x2', '\xED7', '\xED8', '\x3', '\x2', '\x2', '\x2', '\xED8', 
		'\xEDA', '\x3', '\x2', '\x2', '\x2', '\xED9', '\xED7', '\x3', '\x2', '\x2', 
		'\x2', '\xEDA', '\xEDB', '\a', '\x24E', '\x2', '\x2', '\xEDB', '\x25F', 
		'\x3', '\x2', '\x2', '\x2', '\xEDC', '\xEEF', '\x5', '\x2FC', '\x17F', 
		'\x2', '\xEDD', '\xEEF', '\x5', '\x366', '\x1B4', '\x2', '\xEDE', '\xEEF', 
		'\x5', '\x2EA', '\x176', '\x2', '\xEDF', '\xEE2', '\x5', '\x17E', '\xC0', 
		'\x2', '\xEE0', '\xEE2', '\x5', '\x17C', '\xBF', '\x2', '\xEE1', '\xEDF', 
		'\x3', '\x2', '\x2', '\x2', '\xEE1', '\xEE0', '\x3', '\x2', '\x2', '\x2', 
		'\xEE2', '\xEE4', '\x3', '\x2', '\x2', '\x2', '\xEE3', '\xEE5', '\x5', 
		'\x5B6', '\x2DC', '\x2', '\xEE4', '\xEE3', '\x3', '\x2', '\x2', '\x2', 
		'\xEE4', '\xEE5', '\x3', '\x2', '\x2', '\x2', '\xEE5', '\xEEC', '\x3', 
		'\x2', '\x2', '\x2', '\xEE6', '\xEED', '\x5', '\x302', '\x182', '\x2', 
		'\xEE7', '\xEE9', '\x5', '\x36A', '\x1B6', '\x2', '\xEE8', '\xEE7', '\x3', 
		'\x2', '\x2', '\x2', '\xEE9', '\xEEA', '\x3', '\x2', '\x2', '\x2', '\xEEA', 
		'\xEE8', '\x3', '\x2', '\x2', '\x2', '\xEEA', '\xEEB', '\x3', '\x2', '\x2', 
		'\x2', '\xEEB', '\xEED', '\x3', '\x2', '\x2', '\x2', '\xEEC', '\xEE6', 
		'\x3', '\x2', '\x2', '\x2', '\xEEC', '\xEE8', '\x3', '\x2', '\x2', '\x2', 
		'\xEEC', '\xEED', '\x3', '\x2', '\x2', '\x2', '\xEED', '\xEEF', '\x3', 
		'\x2', '\x2', '\x2', '\xEEE', '\xEDC', '\x3', '\x2', '\x2', '\x2', '\xEEE', 
		'\xEDD', '\x3', '\x2', '\x2', '\x2', '\xEEE', '\xEDE', '\x3', '\x2', '\x2', 
		'\x2', '\xEEE', '\xEE1', '\x3', '\x2', '\x2', '\x2', '\xEEF', '\x261', 
		'\x3', '\x2', '\x2', '\x2', '\xEF0', '\xEF1', '\a', '\x1EE', '\x2', '\x2', 
		'\xEF1', '\xEF2', '\a', '\x15', '\x2', '\x2', '\xEF2', '\xEF3', '\x5', 
		'\x44', '#', '\x2', '\xEF3', '\x263', '\x3', '\x2', '\x2', '\x2', '\xEF4', 
		'\xEFA', '\a', 'K', '\x2', '\x2', '\xEF5', '\xEF8', '\x5', '\x17E', '\xC0', 
		'\x2', '\xEF6', '\xEF8', '\x5', '\x17C', '\xBF', '\x2', '\xEF7', '\xEF5', 
		'\x3', '\x2', '\x2', '\x2', '\xEF7', '\xEF6', '\x3', '\x2', '\x2', '\x2', 
		'\xEF8', '\xEFA', '\x3', '\x2', '\x2', '\x2', '\xEF9', '\xEF4', '\x3', 
		'\x2', '\x2', '\x2', '\xEF9', '\xEF7', '\x3', '\x2', '\x2', '\x2', '\xEFA', 
		'\x265', '\x3', '\x2', '\x2', '\x2', '\xEFB', '\xEFC', '\a', '\x15', '\x2', 
		'\x2', '\xEFC', '\xEFD', '\x5', '\x3F6', '\x1FC', '\x2', '\xEFD', '\x267', 
		'\x3', '\x2', '\x2', '\x2', '\xEFE', '\xEFF', '\x5', '\x372', '\x1BA', 
		'\x2', '\xEFF', '\xF00', '\a', '\x1BF', '\x2', '\x2', '\xF00', '\xF01', 
		'\a', '\x136', '\x2', '\x2', '\xF01', '\x269', '\x3', '\x2', '\x2', '\x2', 
		'\xF02', '\xF04', '\x5', '\x372', '\x1BA', '\x2', '\xF03', '\xF05', '\x5', 
		'\x3A2', '\x1D2', '\x2', '\xF04', '\xF03', '\x3', '\x2', '\x2', '\x2', 
		'\xF04', '\xF05', '\x3', '\x2', '\x2', '\x2', '\xF05', '\xF09', '\x3', 
		'\x2', '\x2', '\x2', '\xF06', '\xF0A', '\x5', '\x3AE', '\x1D8', '\x2', 
		'\xF07', '\xF0A', '\x5', '\x3AC', '\x1D7', '\x2', '\xF08', '\xF0A', '\x5', 
		'\x3A8', '\x1D5', '\x2', '\xF09', '\xF06', '\x3', '\x2', '\x2', '\x2', 
		'\xF09', '\xF07', '\x3', '\x2', '\x2', '\x2', '\xF09', '\xF08', '\x3', 
		'\x2', '\x2', '\x2', '\xF0A', '\xF0C', '\x3', '\x2', '\x2', '\x2', '\xF0B', 
		'\xF0D', '\x5', '\x376', '\x1BC', '\x2', '\xF0C', '\xF0B', '\x3', '\x2', 
		'\x2', '\x2', '\xF0C', '\xF0D', '\x3', '\x2', '\x2', '\x2', '\xF0D', '\xF0F', 
		'\x3', '\x2', '\x2', '\x2', '\xF0E', '\xF10', '\x5', '\x3A4', '\x1D3', 
		'\x2', '\xF0F', '\xF0E', '\x3', '\x2', '\x2', '\x2', '\xF0F', '\xF10', 
		'\x3', '\x2', '\x2', '\x2', '\xF10', '\xF12', '\x3', '\x2', '\x2', '\x2', 
		'\xF11', '\xF13', '\x5', '\x26E', '\x138', '\x2', '\xF12', '\xF11', '\x3', 
		'\x2', '\x2', '\x2', '\xF12', '\xF13', '\x3', '\x2', '\x2', '\x2', '\xF13', 
		'\xF15', '\x3', '\x2', '\x2', '\x2', '\xF14', '\xF16', '\x5', '\x26C', 
		'\x137', '\x2', '\xF15', '\xF14', '\x3', '\x2', '\x2', '\x2', '\xF15', 
		'\xF16', '\x3', '\x2', '\x2', '\x2', '\xF16', '\x26B', '\x3', '\x2', '\x2', 
		'\x2', '\xF17', '\xF18', '\t', '.', '\x2', '\x2', '\xF18', '\xF19', '\a', 
		'\xE2', '\x2', '\x2', '\xF19', '\x26D', '\x3', '\x2', '\x2', '\x2', '\xF1A', 
		'\xF1B', '\a', '\x38', '\x2', '\x2', '\xF1B', '\x26F', '\x3', '\x2', '\x2', 
		'\x2', '\xF1C', '\xF1D', '\t', '/', '\x2', '\x2', '\xF1D', '\x271', '\x3', 
		'\x2', '\x2', '\x2', '\xF1E', '\xF1F', '\t', '\x30', '\x2', '\x2', '\xF1F', 
		'\x273', '\x3', '\x2', '\x2', '\x2', '\xF20', '\xF22', '\a', '\x17B', 
		'\x2', '\x2', '\xF21', '\xF23', '\x5', '&', '\x14', '\x2', '\xF22', '\xF21', 
		'\x3', '\x2', '\x2', '\x2', '\xF22', '\xF23', '\x3', '\x2', '\x2', '\x2', 
		'\xF23', '\xF26', '\x3', '\x2', '\x2', '\x2', '\xF24', '\xF26', '\a', 
		'\x155', '\x2', '\x2', '\xF25', '\xF20', '\x3', '\x2', '\x2', '\x2', '\xF25', 
		'\xF24', '\x3', '\x2', '\x2', '\x2', '\xF26', '\x275', '\x3', '\x2', '\x2', 
		'\x2', '\xF27', '\xF28', '\a', '\x180', '\x2', '\x2', '\xF28', '\xF2D', 
		'\a', '\x33', '\x2', '\x2', '\xF29', '\xF2E', '\x5', '\x288', '\x145', 
		'\x2', '\xF2A', '\xF2E', '\x5', '\x278', '\x13D', '\x2', '\xF2B', '\xF2E', 
		'\x5', '\x290', '\x149', '\x2', '\xF2C', '\xF2E', '\x5', '\x286', '\x144', 
		'\x2', '\xF2D', '\xF29', '\x3', '\x2', '\x2', '\x2', '\xF2D', '\xF2A', 
		'\x3', '\x2', '\x2', '\x2', '\xF2D', '\xF2B', '\x3', '\x2', '\x2', '\x2', 
		'\xF2D', '\xF2C', '\x3', '\x2', '\x2', '\x2', '\xF2E', '\x277', '\x3', 
		'\x2', '\x2', '\x2', '\xF2F', '\xF30', '\a', '\x1A0', '\x2', '\x2', '\xF30', 
		'\xF33', '\x5', '\x368', '\x1B5', '\x2', '\xF31', '\xF34', '\x5', '\x27E', 
		'\x140', '\x2', '\xF32', '\xF34', '\x5', '\x27A', '\x13E', '\x2', '\xF33', 
		'\xF31', '\x3', '\x2', '\x2', '\x2', '\xF33', '\xF32', '\x3', '\x2', '\x2', 
		'\x2', '\xF34', '\xF35', '\x3', '\x2', '\x2', '\x2', '\xF35', '\xF36', 
		'\x5', '\x292', '\x14A', '\x2', '\xF36', '\x279', '\x3', '\x2', '\x2', 
		'\x2', '\xF37', '\xF38', '\a', '\x1F4', '\x2', '\x2', '\xF38', '\xF39', 
		'\a', '\x33', '\x2', '\x2', '\xF39', '\xF3A', '\a', '\xD3', '\x2', '\x2', 
		'\xF3A', '\xF3D', '\x5', '\x368', '\x1B5', '\x2', '\xF3B', '\xF3E', '\x5', 
		'\x27C', '\x13F', '\x2', '\xF3C', '\xF3E', '\x5', '\x280', '\x141', '\x2', 
		'\xF3D', '\xF3B', '\x3', '\x2', '\x2', '\x2', '\xF3D', '\xF3C', '\x3', 
		'\x2', '\x2', '\x2', '\xF3D', '\xF3E', '\x3', '\x2', '\x2', '\x2', '\xF3E', 
		'\x27B', '\x3', '\x2', '\x2', '\x2', '\xF3F', '\xF40', '\a', '\x1F5', 
		'\x2', '\x2', '\xF40', '\xF42', '\x5', '&', '\x14', '\x2', '\xF41', '\xF43', 
		'\x5', '\x2A4', '\x153', '\x2', '\xF42', '\xF41', '\x3', '\x2', '\x2', 
		'\x2', '\xF42', '\xF43', '\x3', '\x2', '\x2', '\x2', '\xF43', '\x27D', 
		'\x3', '\x2', '\x2', '\x2', '\xF44', '\xF45', '\a', '\x1F4', '\x2', '\x2', 
		'\xF45', '\xF46', '\a', '\x33', '\x2', '\x2', '\xF46', '\xF47', '\a', 
		'\x10E', '\x2', '\x2', '\xF47', '\xF49', '\x5', '\x368', '\x1B5', '\x2', 
		'\xF48', '\xF4A', '\x5', '\x280', '\x141', '\x2', '\xF49', '\xF48', '\x3', 
		'\x2', '\x2', '\x2', '\xF49', '\xF4A', '\x3', '\x2', '\x2', '\x2', '\xF4A', 
		'\x27F', '\x3', '\x2', '\x2', '\x2', '\xF4B', '\xF4C', '\a', '\x1F4', 
		'\x2', '\x2', '\xF4C', '\xF4F', '\a', '\x200', '\x2', '\x2', '\xF4D', 
		'\xF50', '\x5', '\x282', '\x142', '\x2', '\xF4E', '\xF50', '\x5', '&', 
		'\x14', '\x2', '\xF4F', '\xF4D', '\x3', '\x2', '\x2', '\x2', '\xF4F', 
		'\xF4E', '\x3', '\x2', '\x2', '\x2', '\xF50', '\x281', '\x3', '\x2', '\x2', 
		'\x2', '\xF51', '\xF52', '\a', '\x24D', '\x2', '\x2', '\xF52', '\xF57', 
		'\x5', '\x284', '\x143', '\x2', '\xF53', '\xF54', '\a', '\x24F', '\x2', 
		'\x2', '\xF54', '\xF56', '\x5', '\x284', '\x143', '\x2', '\xF55', '\xF53', 
		'\x3', '\x2', '\x2', '\x2', '\xF56', '\xF59', '\x3', '\x2', '\x2', '\x2', 
		'\xF57', '\xF55', '\x3', '\x2', '\x2', '\x2', '\xF57', '\xF58', '\x3', 
		'\x2', '\x2', '\x2', '\xF58', '\xF5A', '\x3', '\x2', '\x2', '\x2', '\xF59', 
		'\xF57', '\x3', '\x2', '\x2', '\x2', '\xF5A', '\xF5B', '\a', '\x24E', 
		'\x2', '\x2', '\xF5B', '\x283', '\x3', '\x2', '\x2', '\x2', '\xF5C', '\xF5D', 
		'\a', '\x1F4', '\x2', '\x2', '\xF5D', '\xF5F', '\x5', 'N', '(', '\x2', 
		'\xF5E', '\xF60', '\x5', '\x2A0', '\x151', '\x2', '\xF5F', '\xF5E', '\x3', 
		'\x2', '\x2', '\x2', '\xF5F', '\xF60', '\x3', '\x2', '\x2', '\x2', '\xF60', 
		'\xF62', '\x3', '\x2', '\x2', '\x2', '\xF61', '\xF63', '\x5', '\x29E', 
		'\x150', '\x2', '\xF62', '\xF61', '\x3', '\x2', '\x2', '\x2', '\xF62', 
		'\xF63', '\x3', '\x2', '\x2', '\x2', '\xF63', '\x285', '\x3', '\x2', '\x2', 
		'\x2', '\xF64', '\xF65', '\a', '\x10E', '\x2', '\x2', '\xF65', '\xF66', 
		'\x5', '\x368', '\x1B5', '\x2', '\xF66', '\xF67', '\x5', '\x292', '\x14A', 
		'\x2', '\xF67', '\x287', '\x3', '\x2', '\x2', '\x2', '\xF68', '\xF69', 
		'\a', '\xD3', '\x2', '\x2', '\xF69', '\xF6C', '\x5', '\x368', '\x1B5', 
		'\x2', '\xF6A', '\xF6D', '\x5', '\x28A', '\x146', '\x2', '\xF6B', '\xF6D', 
		'\x5', '\x28C', '\x147', '\x2', '\xF6C', '\xF6A', '\x3', '\x2', '\x2', 
		'\x2', '\xF6C', '\xF6B', '\x3', '\x2', '\x2', '\x2', '\xF6D', '\x289', 
		'\x3', '\x2', '\x2', '\x2', '\xF6E', '\xF6F', '\a', '\x181', '\x2', '\x2', 
		'\xF6F', '\xF71', '\x5', '&', '\x14', '\x2', '\xF70', '\xF72', '\x5', 
		'\x2A4', '\x153', '\x2', '\xF71', '\xF70', '\x3', '\x2', '\x2', '\x2', 
		'\xF71', '\xF72', '\x3', '\x2', '\x2', '\x2', '\xF72', '\xF74', '\x3', 
		'\x2', '\x2', '\x2', '\xF73', '\xF75', '\x5', '\x2D2', '\x16A', '\x2', 
		'\xF74', '\xF73', '\x3', '\x2', '\x2', '\x2', '\xF74', '\xF75', '\x3', 
		'\x2', '\x2', '\x2', '\xF75', '\x28B', '\x3', '\x2', '\x2', '\x2', '\xF76', 
		'\xF77', '\a', '\x24D', '\x2', '\x2', '\xF77', '\xF7C', '\x5', '\x28E', 
		'\x148', '\x2', '\xF78', '\xF79', '\a', '\x24F', '\x2', '\x2', '\xF79', 
		'\xF7B', '\x5', '\x28E', '\x148', '\x2', '\xF7A', '\xF78', '\x3', '\x2', 
		'\x2', '\x2', '\xF7B', '\xF7E', '\x3', '\x2', '\x2', '\x2', '\xF7C', '\xF7A', 
		'\x3', '\x2', '\x2', '\x2', '\xF7C', '\xF7D', '\x3', '\x2', '\x2', '\x2', 
		'\xF7D', '\xF7F', '\x3', '\x2', '\x2', '\x2', '\xF7E', '\xF7C', '\x3', 
		'\x2', '\x2', '\x2', '\xF7F', '\xF80', '\a', '\x24E', '\x2', '\x2', '\xF80', 
		'\x28D', '\x3', '\x2', '\x2', '\x2', '\xF81', '\xF87', '\a', '\x180', 
		'\x2', '\x2', '\xF82', '\xF88', '\x5', '\x29E', '\x150', '\x2', '\xF83', 
		'\xF85', '\x5', 'N', '(', '\x2', '\xF84', '\xF86', '\x5', '\x29E', '\x150', 
		'\x2', '\xF85', '\xF84', '\x3', '\x2', '\x2', '\x2', '\xF85', '\xF86', 
		'\x3', '\x2', '\x2', '\x2', '\xF86', '\xF88', '\x3', '\x2', '\x2', '\x2', 
		'\xF87', '\xF82', '\x3', '\x2', '\x2', '\x2', '\xF87', '\xF83', '\x3', 
		'\x2', '\x2', '\x2', '\xF87', '\xF88', '\x3', '\x2', '\x2', '\x2', '\xF88', 
		'\x28F', '\x3', '\x2', '\x2', '\x2', '\xF89', '\xF8A', '\x5', '\x2C2', 
		'\x162', '\x2', '\xF8A', '\xF8B', '\x5', '\x292', '\x14A', '\x2', '\xF8B', 
		'\x291', '\x3', '\x2', '\x2', '\x2', '\xF8C', '\xF8D', '\a', '\x24D', 
		'\x2', '\x2', '\xF8D', '\xF92', '\x5', '\x294', '\x14B', '\x2', '\xF8E', 
		'\xF8F', '\a', '\x24F', '\x2', '\x2', '\xF8F', '\xF91', '\x5', '\x294', 
		'\x14B', '\x2', '\xF90', '\xF8E', '\x3', '\x2', '\x2', '\x2', '\xF91', 
		'\xF94', '\x3', '\x2', '\x2', '\x2', '\xF92', '\xF90', '\x3', '\x2', '\x2', 
		'\x2', '\xF92', '\xF93', '\x3', '\x2', '\x2', '\x2', '\xF93', '\xF95', 
		'\x3', '\x2', '\x2', '\x2', '\xF94', '\xF92', '\x3', '\x2', '\x2', '\x2', 
		'\xF95', '\xF96', '\a', '\x24E', '\x2', '\x2', '\xF96', '\x293', '\x3', 
		'\x2', '\x2', '\x2', '\xF97', '\xF99', '\a', '\x180', '\x2', '\x2', '\xF98', 
		'\xF9A', '\x5', 'N', '(', '\x2', '\xF99', '\xF98', '\x3', '\x2', '\x2', 
		'\x2', '\xF99', '\xF9A', '\x3', '\x2', '\x2', '\x2', '\xF9A', '\xF9D', 
		'\x3', '\x2', '\x2', '\x2', '\xF9B', '\xF9E', '\x5', '\x2BC', '\x15F', 
		'\x2', '\xF9C', '\xF9E', '\x5', '\x2A0', '\x151', '\x2', '\xF9D', '\xF9B', 
		'\x3', '\x2', '\x2', '\x2', '\xF9D', '\xF9C', '\x3', '\x2', '\x2', '\x2', 
		'\xF9E', '\xF9F', '\x3', '\x2', '\x2', '\x2', '\xF9F', '\xFA0', '\x5', 
		'\x296', '\x14C', '\x2', '\xFA0', '\x295', '\x3', '\x2', '\x2', '\x2', 
		'\xFA1', '\xFA3', '\x5', '\x2E0', '\x171', '\x2', '\xFA2', '\xFA1', '\x3', 
		'\x2', '\x2', '\x2', '\xFA2', '\xFA3', '\x3', '\x2', '\x2', '\x2', '\xFA3', 
		'\xFA5', '\x3', '\x2', '\x2', '\x2', '\xFA4', '\xFA6', '\x5', '\x2DA', 
		'\x16E', '\x2', '\xFA5', '\xFA4', '\x3', '\x2', '\x2', '\x2', '\xFA5', 
		'\xFA6', '\x3', '\x2', '\x2', '\x2', '\xFA6', '\xFA8', '\x3', '\x2', '\x2', 
		'\x2', '\xFA7', '\xFA9', '\x5', '\x2D2', '\x16A', '\x2', '\xFA8', '\xFA7', 
		'\x3', '\x2', '\x2', '\x2', '\xFA8', '\xFA9', '\x3', '\x2', '\x2', '\x2', 
		'\xFA9', '\xFAE', '\x3', '\x2', '\x2', '\x2', '\xFAA', '\xFAD', '\x5', 
		'\x2A8', '\x155', '\x2', '\xFAB', '\xFAD', '\x5', '\x2B4', '\x15B', '\x2', 
		'\xFAC', '\xFAA', '\x3', '\x2', '\x2', '\x2', '\xFAC', '\xFAB', '\x3', 
		'\x2', '\x2', '\x2', '\xFAD', '\xFB0', '\x3', '\x2', '\x2', '\x2', '\xFAE', 
		'\xFAC', '\x3', '\x2', '\x2', '\x2', '\xFAE', '\xFAF', '\x3', '\x2', '\x2', 
		'\x2', '\xFAF', '\xFB2', '\x3', '\x2', '\x2', '\x2', '\xFB0', '\xFAE', 
		'\x3', '\x2', '\x2', '\x2', '\xFB1', '\xFB3', '\x5', '\x298', '\x14D', 
		'\x2', '\xFB2', '\xFB1', '\x3', '\x2', '\x2', '\x2', '\xFB2', '\xFB3', 
		'\x3', '\x2', '\x2', '\x2', '\xFB3', '\x297', '\x3', '\x2', '\x2', '\x2', 
		'\xFB4', '\xFB7', '\x5', '\x2A2', '\x152', '\x2', '\xFB5', '\xFB7', '\x5', 
		'\x29A', '\x14E', '\x2', '\xFB6', '\xFB4', '\x3', '\x2', '\x2', '\x2', 
		'\xFB6', '\xFB5', '\x3', '\x2', '\x2', '\x2', '\xFB7', '\x299', '\x3', 
		'\x2', '\x2', '\x2', '\xFB8', '\xFB9', '\a', '\x24D', '\x2', '\x2', '\xFB9', 
		'\xFBE', '\x5', '\x29C', '\x14F', '\x2', '\xFBA', '\xFBB', '\a', '\x24F', 
		'\x2', '\x2', '\xFBB', '\xFBD', '\x5', '\x29C', '\x14F', '\x2', '\xFBC', 
		'\xFBA', '\x3', '\x2', '\x2', '\x2', '\xFBD', '\xFC0', '\x3', '\x2', '\x2', 
		'\x2', '\xFBE', '\xFBC', '\x3', '\x2', '\x2', '\x2', '\xFBE', '\xFBF', 
		'\x3', '\x2', '\x2', '\x2', '\xFBF', '\xFC1', '\x3', '\x2', '\x2', '\x2', 
		'\xFC0', '\xFBE', '\x3', '\x2', '\x2', '\x2', '\xFC1', '\xFC2', '\a', 
		'\x24E', '\x2', '\x2', '\xFC2', '\x29B', '\x3', '\x2', '\x2', '\x2', '\xFC3', 
		'\xFD0', '\a', '\x1F4', '\x2', '\x2', '\xFC4', '\xFD1', '\x5', '\x29E', 
		'\x150', '\x2', '\xFC5', '\xFC7', '\x5', '\x2A0', '\x151', '\x2', '\xFC6', 
		'\xFC8', '\x5', '\x29E', '\x150', '\x2', '\xFC7', '\xFC6', '\x3', '\x2', 
		'\x2', '\x2', '\xFC7', '\xFC8', '\x3', '\x2', '\x2', '\x2', '\xFC8', '\xFD1', 
		'\x3', '\x2', '\x2', '\x2', '\xFC9', '\xFCB', '\x5', 'N', '(', '\x2', 
		'\xFCA', '\xFCC', '\x5', '\x2A0', '\x151', '\x2', '\xFCB', '\xFCA', '\x3', 
		'\x2', '\x2', '\x2', '\xFCB', '\xFCC', '\x3', '\x2', '\x2', '\x2', '\xFCC', 
		'\xFCE', '\x3', '\x2', '\x2', '\x2', '\xFCD', '\xFCF', '\x5', '\x29E', 
		'\x150', '\x2', '\xFCE', '\xFCD', '\x3', '\x2', '\x2', '\x2', '\xFCE', 
		'\xFCF', '\x3', '\x2', '\x2', '\x2', '\xFCF', '\xFD1', '\x3', '\x2', '\x2', 
		'\x2', '\xFD0', '\xFC4', '\x3', '\x2', '\x2', '\x2', '\xFD0', '\xFC5', 
		'\x3', '\x2', '\x2', '\x2', '\xFD0', '\xFC9', '\x3', '\x2', '\x2', '\x2', 
		'\xFD0', '\xFD1', '\x3', '\x2', '\x2', '\x2', '\xFD1', '\x29D', '\x3', 
		'\x2', '\x2', '\x2', '\xFD2', '\xFD7', '\x5', '\x380', '\x1C1', '\x2', 
		'\xFD3', '\xFD7', '\x5', '\x2D2', '\x16A', '\x2', '\xFD4', '\xFD7', '\x5', 
		'\x2A8', '\x155', '\x2', '\xFD5', '\xFD7', '\x5', '\x2B4', '\x15B', '\x2', 
		'\xFD6', '\xFD2', '\x3', '\x2', '\x2', '\x2', '\xFD6', '\xFD3', '\x3', 
		'\x2', '\x2', '\x2', '\xFD6', '\xFD4', '\x3', '\x2', '\x2', '\x2', '\xFD6', 
		'\xFD5', '\x3', '\x2', '\x2', '\x2', '\xFD7', '\xFD8', '\x3', '\x2', '\x2', 
		'\x2', '\xFD8', '\xFD6', '\x3', '\x2', '\x2', '\x2', '\xFD8', '\xFD9', 
		'\x3', '\x2', '\x2', '\x2', '\xFD9', '\x29F', '\x3', '\x2', '\x2', '\x2', 
		'\xFDA', '\xFDB', '\a', '\x228', '\x2', '\x2', '\xFDB', '\xFDC', '\x5', 
		'\x352', '\x1AA', '\x2', '\xFDC', '\x2A1', '\x3', '\x2', '\x2', '\x2', 
		'\xFDD', '\xFDE', '\a', '\x1F5', '\x2', '\x2', '\xFDE', '\xFE0', '\x5', 
		'&', '\x14', '\x2', '\xFDF', '\xFE1', '\x5', '\x2A4', '\x153', '\x2', 
		'\xFE0', '\xFDF', '\x3', '\x2', '\x2', '\x2', '\xFE0', '\xFE1', '\x3', 
		'\x2', '\x2', '\x2', '\xFE1', '\x2A3', '\x3', '\x2', '\x2', '\x2', '\xFE2', 
		'\xFE3', '\a', '\x1EE', '\x2', '\x2', '\xFE3', '\xFE4', '\a', '\xDE', 
		'\x2', '\x2', '\xFE4', '\xFE5', '\x5', '\x2A6', '\x154', '\x2', '\xFE5', 
		'\x2A5', '\x3', '\x2', '\x2', '\x2', '\xFE6', '\xFE7', '\a', '\x24D', 
		'\x2', '\x2', '\xFE7', '\xFEC', '\x5', '\\', '/', '\x2', '\xFE8', '\xFE9', 
		'\a', '\x24F', '\x2', '\x2', '\xFE9', '\xFEB', '\x5', '\\', '/', '\x2', 
		'\xFEA', '\xFE8', '\x3', '\x2', '\x2', '\x2', '\xFEB', '\xFEE', '\x3', 
		'\x2', '\x2', '\x2', '\xFEC', '\xFEA', '\x3', '\x2', '\x2', '\x2', '\xFEC', 
		'\xFED', '\x3', '\x2', '\x2', '\x2', '\xFED', '\xFEF', '\x3', '\x2', '\x2', 
		'\x2', '\xFEE', '\xFEC', '\x3', '\x2', '\x2', '\x2', '\xFEF', '\xFF0', 
		'\a', '\x24E', '\x2', '\x2', '\xFF0', '\x2A7', '\x3', '\x2', '\x2', '\x2', 
		'\xFF1', '\xFF2', '\a', '\x22B', '\x2', '\x2', '\xFF2', '\xFF4', '\x5', 
		'N', '(', '\x2', '\xFF3', '\xFF5', '\x5', '\x2AA', '\x156', '\x2', '\xFF4', 
		'\xFF3', '\x3', '\x2', '\x2', '\x2', '\xFF4', '\xFF5', '\x3', '\x2', '\x2', 
		'\x2', '\xFF5', '\xFF7', '\x3', '\x2', '\x2', '\x2', '\xFF6', '\xFF8', 
		'\x5', '\x2B2', '\x15A', '\x2', '\xFF7', '\xFF6', '\x3', '\x2', '\x2', 
		'\x2', '\xFF7', '\xFF8', '\x3', '\x2', '\x2', '\x2', '\xFF8', '\x2A9', 
		'\x3', '\x2', '\x2', '\x2', '\xFF9', '\xFFC', '\x5', '\x2AE', '\x158', 
		'\x2', '\xFFA', '\xFFC', '\x5', '\x2AC', '\x157', '\x2', '\xFFB', '\xFF9', 
		'\x3', '\x2', '\x2', '\x2', '\xFFB', '\xFFA', '\x3', '\x2', '\x2', '\x2', 
		'\xFFC', '\x2AB', '\x3', '\x2', '\x2', '\x2', '\xFFD', '\xFFF', '\a', 
		'\x15C', '\x2', '\x2', '\xFFE', '\xFFD', '\x3', '\x2', '\x2', '\x2', '\xFFE', 
		'\xFFF', '\x3', '\x2', '\x2', '\x2', '\xFFF', '\x1000', '\x3', '\x2', 
		'\x2', '\x2', '\x1000', '\x1001', '\a', '\x1F6', '\x2', '\x2', '\x1001', 
		'\x1002', '\a', '\x18', '\x2', '\x2', '\x1002', '\x1003', '\a', '\n', 
		'\x2', '\x2', '\x1003', '\x1004', '\a', '\x107', '\x2', '\x2', '\x1004', 
		'\x2AD', '\x3', '\x2', '\x2', '\x2', '\x1005', '\x1007', '\a', '\x96', 
		'\x2', '\x2', '\x1006', '\x1005', '\x3', '\x2', '\x2', '\x2', '\x1006', 
		'\x1007', '\x3', '\x2', '\x2', '\x2', '\x1007', '\x1008', '\x3', '\x2', 
		'\x2', '\x2', '\x1008', '\x1009', '\a', '\xF7', '\x2', '\x2', '\x1009', 
		'\x100B', '\a', '\x164', '\x2', '\x2', '\x100A', '\x100C', '\a', '\x215', 
		'\x2', '\x2', '\x100B', '\x100A', '\x3', '\x2', '\x2', '\x2', '\x100B', 
		'\x100C', '\x3', '\x2', '\x2', '\x2', '\x100C', '\x100D', '\x3', '\x2', 
		'\x2', '\x2', '\x100D', '\x100F', '\a', '\x24D', '\x2', '\x2', '\x100E', 
		'\x1010', '\x5', '\x2B0', '\x159', '\x2', '\x100F', '\x100E', '\x3', '\x2', 
		'\x2', '\x2', '\x100F', '\x1010', '\x3', '\x2', '\x2', '\x2', '\x1010', 
		'\x1011', '\x3', '\x2', '\x2', '\x2', '\x1011', '\x1012', '\x5', '`', 
		'\x31', '\x2', '\x1012', '\x1013', '\a', '\x24E', '\x2', '\x2', '\x1013', 
		'\x2AF', '\x3', '\x2', '\x2', '\x2', '\x1014', '\x1015', '\a', '\x169', 
		'\x2', '\x2', '\x1015', '\x2B1', '\x3', '\x2', '\x2', '\x2', '\x1016', 
		'\x1017', '\a', '\x1EE', '\x2', '\x2', '\x1017', '\x1019', '\a', '\x15', 
		'\x2', '\x2', '\x1018', '\x101A', '\t', '+', '\x2', '\x2', '\x1019', '\x1018', 
		'\x3', '\x2', '\x2', '\x2', '\x1019', '\x101A', '\x3', '\x2', '\x2', '\x2', 
		'\x101A', '\x101B', '\x3', '\x2', '\x2', '\x2', '\x101B', '\x1021', '\a', 
		'\x10F', '\x2', '\x2', '\x101C', '\x1022', '\x5', '\x2B6', '\x15C', '\x2', 
		'\x101D', '\x101F', '\x5', '\\', '/', '\x2', '\x101E', '\x1020', '\x5', 
		'\x2B6', '\x15C', '\x2', '\x101F', '\x101E', '\x3', '\x2', '\x2', '\x2', 
		'\x101F', '\x1020', '\x3', '\x2', '\x2', '\x2', '\x1020', '\x1022', '\x3', 
		'\x2', '\x2', '\x2', '\x1021', '\x101C', '\x3', '\x2', '\x2', '\x2', '\x1021', 
		'\x101D', '\x3', '\x2', '\x2', '\x2', '\x1022', '\x2B3', '\x3', '\x2', 
		'\x2', '\x2', '\x1023', '\x1029', '\x5', '\x2BA', '\x15E', '\x2', '\x1024', 
		'\x102A', '\x5', '\x2B6', '\x15C', '\x2', '\x1025', '\x1027', '\x5', '\\', 
		'/', '\x2', '\x1026', '\x1028', '\x5', '\x2B6', '\x15C', '\x2', '\x1027', 
		'\x1026', '\x3', '\x2', '\x2', '\x2', '\x1027', '\x1028', '\x3', '\x2', 
		'\x2', '\x2', '\x1028', '\x102A', '\x3', '\x2', '\x2', '\x2', '\x1029', 
		'\x1024', '\x3', '\x2', '\x2', '\x2', '\x1029', '\x1025', '\x3', '\x2', 
		'\x2', '\x2', '\x102A', '\x2B5', '\x3', '\x2', '\x2', '\x2', '\x102B', 
		'\x102F', '\a', '\x24D', '\x2', '\x2', '\x102C', '\x1030', '\x5', '\x380', 
		'\x1C1', '\x2', '\x102D', '\x1030', '\x5', '\x384', '\x1C3', '\x2', '\x102E', 
		'\x1030', '\x5', '\x2B8', '\x15D', '\x2', '\x102F', '\x102C', '\x3', '\x2', 
		'\x2', '\x2', '\x102F', '\x102D', '\x3', '\x2', '\x2', '\x2', '\x102F', 
		'\x102E', '\x3', '\x2', '\x2', '\x2', '\x1030', '\x1031', '\x3', '\x2', 
		'\x2', '\x2', '\x1031', '\x102F', '\x3', '\x2', '\x2', '\x2', '\x1031', 
		'\x1032', '\x3', '\x2', '\x2', '\x2', '\x1032', '\x1033', '\x3', '\x2', 
		'\x2', '\x2', '\x1033', '\x1034', '\a', '\x24E', '\x2', '\x2', '\x1034', 
		'\x2B7', '\x3', '\x2', '\x2', '\x2', '\x1035', '\x1036', '\a', '\x1B5', 
		'\x2', '\x2', '\x1036', '\x106D', '\a', '\x122', '\x2', '\x2', '\x1037', 
		'\x1038', '\a', '\x1B5', '\x2', '\x2', '\x1038', '\x1039', '\a', '\x12C', 
		'\x2', '\x2', '\x1039', '\x106D', '\x5', '&', '\x14', '\x2', '\x103A', 
		'\x103B', '\a', '\x1B5', '\x2', '\x2', '\x103B', '\x106D', '\a', '\x1E', 
		'\x2', '\x2', '\x103C', '\x103D', '\a', '\x1B5', '\x2', '\x2', '\x103D', 
		'\x106D', '\a', '\x152', '\x2', '\x2', '\x103E', '\x103F', '\a', '\x9B', 
		'\x2', '\x2', '\x103F', '\x1040', '\a', '\x225', '\x2', '\x2', '\x1040', 
		'\x106D', '\x5', '*', '\x16', '\x2', '\x1041', '\x1042', '\a', '\x9B', 
		'\x2', '\x2', '\x1042', '\x1043', '\a', '\xD9', '\x2', '\x2', '\x1043', 
		'\x1044', '\a', '\x33', '\x2', '\x2', '\x1044', '\x106D', '\x5', 'N', 
		'(', '\x2', '\x1045', '\x1046', '\a', '\x9B', '\x2', '\x2', '\x1046', 
		'\x106D', '\a', '\x1C5', '\x2', '\x2', '\x1047', '\x1048', '\a', '\x9B', 
		'\x2', '\x2', '\x1048', '\x1049', '\a', '\x144', '\x2', '\x2', '\x1049', 
		'\x106D', '\a', '\x1C5', '\x2', '\x2', '\x104A', '\x104B', '\a', '\x36', 
		'\x2', '\x2', '\x104B', '\x104D', '\a', '\x1A3', '\x2', '\x2', '\x104C', 
		'\x104E', '\x5', '\x37E', '\x1C0', '\x2', '\x104D', '\x104C', '\x3', '\x2', 
		'\x2', '\x2', '\x104D', '\x104E', '\x3', '\x2', '\x2', '\x2', '\x104E', 
		'\x106D', '\x3', '\x2', '\x2', '\x2', '\x104F', '\x1050', '\a', 'T', '\x2', 
		'\x2', '\x1050', '\x106D', '\a', '\xD6', '\x2', '\x2', '\x1051', '\x1052', 
		'\a', 'T', '\x2', '\x2', '\x1052', '\x106D', '\a', '\x127', '\x2', '\x2', 
		'\x1053', '\x1054', '\a', '\x9A', '\x2', '\x2', '\x1054', '\x1055', '\a', 
		'\x1ED', '\x2', '\x2', '\x1055', '\x1056', '\a', '\xDE', '\x2', '\x2', 
		'\x1056', '\x106D', '\a', '\x1BF', '\x2', '\x2', '\x1057', '\x1058', '\a', 
		'\x8A', '\x2', '\x2', '\x1058', '\x1059', '\a', '\x1ED', '\x2', '\x2', 
		'\x1059', '\x105A', '\a', '\xDE', '\x2', '\x2', '\x105A', '\x106D', '\a', 
		'\x1BF', '\x2', '\x2', '\x105B', '\x106D', '\a', '\x36', '\x2', '\x2', 
		'\x105C', '\x105D', '\a', '\x42', '\x2', '\x2', '\x105D', '\x106D', '\x5', 
		'&', '\x14', '\x2', '\x105E', '\x105F', '\a', '\x189', '\x2', '\x2', '\x105F', 
		'\x106D', '\x5', '&', '\x14', '\x2', '\x1060', '\x106D', '\a', '\x1B5', 
		'\x2', '\x2', '\x1061', '\x1062', '\a', '\xC7', '\x2', '\x2', '\x1062', 
		'\x106D', '\x5', '&', '\x14', '\x2', '\x1063', '\x1065', '\a', '\x146', 
		'\x2', '\x2', '\x1064', '\x1066', '\x5', '\x37E', '\x1C0', '\x2', '\x1065', 
		'\x1064', '\x3', '\x2', '\x2', '\x2', '\x1065', '\x1066', '\x3', '\x2', 
		'\x2', '\x2', '\x1066', '\x106D', '\x3', '\x2', '\x2', '\x2', '\x1067', 
		'\x106D', '\a', 'x', '\x2', '\x2', '\x1068', '\x106D', '\a', '\xFF', '\x2', 
		'\x2', '\x1069', '\x106D', '\a', 'w', '\x2', '\x2', '\x106A', '\x106D', 
		'\a', 'T', '\x2', '\x2', '\x106B', '\x106D', '\a', '\x147', '\x2', '\x2', 
		'\x106C', '\x1035', '\x3', '\x2', '\x2', '\x2', '\x106C', '\x1037', '\x3', 
		'\x2', '\x2', '\x2', '\x106C', '\x103A', '\x3', '\x2', '\x2', '\x2', '\x106C', 
		'\x103C', '\x3', '\x2', '\x2', '\x2', '\x106C', '\x103E', '\x3', '\x2', 
		'\x2', '\x2', '\x106C', '\x1041', '\x3', '\x2', '\x2', '\x2', '\x106C', 
		'\x1045', '\x3', '\x2', '\x2', '\x2', '\x106C', '\x1047', '\x3', '\x2', 
		'\x2', '\x2', '\x106C', '\x104A', '\x3', '\x2', '\x2', '\x2', '\x106C', 
		'\x104F', '\x3', '\x2', '\x2', '\x2', '\x106C', '\x1051', '\x3', '\x2', 
		'\x2', '\x2', '\x106C', '\x1053', '\x3', '\x2', '\x2', '\x2', '\x106C', 
		'\x1057', '\x3', '\x2', '\x2', '\x2', '\x106C', '\x105B', '\x3', '\x2', 
		'\x2', '\x2', '\x106C', '\x105C', '\x3', '\x2', '\x2', '\x2', '\x106C', 
		'\x105E', '\x3', '\x2', '\x2', '\x2', '\x106C', '\x1060', '\x3', '\x2', 
		'\x2', '\x2', '\x106C', '\x1061', '\x3', '\x2', '\x2', '\x2', '\x106C', 
		'\x1063', '\x3', '\x2', '\x2', '\x2', '\x106C', '\x1067', '\x3', '\x2', 
		'\x2', '\x2', '\x106C', '\x1068', '\x3', '\x2', '\x2', '\x2', '\x106C', 
		'\x1069', '\x3', '\x2', '\x2', '\x2', '\x106C', '\x106A', '\x3', '\x2', 
		'\x2', '\x2', '\x106C', '\x106B', '\x3', '\x2', '\x2', '\x2', '\x106D', 
		'\x2B9', '\x3', '\x2', '\x2', '\x2', '\x106E', '\x106F', '\a', '\x10F', 
		'\x2', '\x2', '\x106F', '\x1070', '\a', '\x24D', '\x2', '\x2', '\x1070', 
		'\x1075', '\x5', 'N', '(', '\x2', '\x1071', '\x1072', '\a', '\x24F', '\x2', 
		'\x2', '\x1072', '\x1074', '\x5', 'N', '(', '\x2', '\x1073', '\x1071', 
		'\x3', '\x2', '\x2', '\x2', '\x1074', '\x1077', '\x3', '\x2', '\x2', '\x2', 
		'\x1075', '\x1073', '\x3', '\x2', '\x2', '\x2', '\x1075', '\x1076', '\x3', 
		'\x2', '\x2', '\x2', '\x1076', '\x1078', '\x3', '\x2', '\x2', '\x2', '\x1077', 
		'\x1075', '\x3', '\x2', '\x2', '\x2', '\x1078', '\x1079', '\a', '\x24E', 
		'\x2', '\x2', '\x1079', '\x107A', '\a', '\x1EE', '\x2', '\x2', '\x107A', 
		'\x107B', '\a', '\x15', '\x2', '\x2', '\x107B', '\x2BB', '\x3', '\x2', 
		'\x2', '\x2', '\x107C', '\x107D', '\a', '\x228', '\x2', '\x2', '\x107D', 
		'\x107E', '\a', '\x105', '\x2', '\x2', '\x107E', '\x107F', '\a', '\x202', 
		'\x2', '\x2', '\x107F', '\x1080', '\x5', '\x2BE', '\x160', '\x2', '\x1080', 
		'\x2BD', '\x3', '\x2', '\x2', '\x2', '\x1081', '\x1082', '\a', '\x24D', 
		'\x2', '\x2', '\x1082', '\x1087', '\x5', '\x2C0', '\x161', '\x2', '\x1083', 
		'\x1084', '\a', '\x24F', '\x2', '\x2', '\x1084', '\x1086', '\x5', '\x2C0', 
		'\x161', '\x2', '\x1085', '\x1083', '\x3', '\x2', '\x2', '\x2', '\x1086', 
		'\x1089', '\x3', '\x2', '\x2', '\x2', '\x1087', '\x1085', '\x3', '\x2', 
		'\x2', '\x2', '\x1087', '\x1088', '\x3', '\x2', '\x2', '\x2', '\x1088', 
		'\x108A', '\x3', '\x2', '\x2', '\x2', '\x1089', '\x1087', '\x3', '\x2', 
		'\x2', '\x2', '\x108A', '\x108B', '\a', '\x24E', '\x2', '\x2', '\x108B', 
		'\x2BF', '\x3', '\x2', '\x2', '\x2', '\x108C', '\x108F', '\a', '\x126', 
		'\x2', '\x2', '\x108D', '\x108F', '\x5', '&', '\x14', '\x2', '\x108E', 
		'\x108C', '\x3', '\x2', '\x2', '\x2', '\x108E', '\x108D', '\x3', '\x2', 
		'\x2', '\x2', '\x108F', '\x2C1', '\x3', '\x2', '\x2', '\x2', '\x1090', 
		'\x1091', '\a', '\x1A0', '\x2', '\x2', '\x1091', '\x1092', '\x5', '\x368', 
		'\x1B5', '\x2', '\x1092', '\x2C3', '\x3', '\x2', '\x2', '\x2', '\x1093', 
		'\x1095', '\x5', '\x2CA', '\x166', '\x2', '\x1094', '\x1093', '\x3', '\x2', 
		'\x2', '\x2', '\x1094', '\x1095', '\x3', '\x2', '\x2', '\x2', '\x1095', 
		'\x1096', '\x3', '\x2', '\x2', '\x2', '\x1096', '\x10A2', '\x5', '\x2C8', 
		'\x165', '\x2', '\x1097', '\x1099', '\x5', '\x2CA', '\x166', '\x2', '\x1098', 
		'\x1097', '\x3', '\x2', '\x2', '\x2', '\x1098', '\x1099', '\x3', '\x2', 
		'\x2', '\x2', '\x1099', '\x109C', '\x3', '\x2', '\x2', '\x2', '\x109A', 
		'\x109D', '\x5', '\x2E2', '\x172', '\x2', '\x109B', '\x109D', '\x5', '\x2DA', 
		'\x16E', '\x2', '\x109C', '\x109A', '\x3', '\x2', '\x2', '\x2', '\x109C', 
		'\x109B', '\x3', '\x2', '\x2', '\x2', '\x109D', '\x109E', '\x3', '\x2', 
		'\x2', '\x2', '\x109E', '\x109C', '\x3', '\x2', '\x2', '\x2', '\x109E', 
		'\x109F', '\x3', '\x2', '\x2', '\x2', '\x109F', '\x10A2', '\x3', '\x2', 
		'\x2', '\x2', '\x10A0', '\x10A2', '\x5', '\x2C6', '\x164', '\x2', '\x10A1', 
		'\x1094', '\x3', '\x2', '\x2', '\x2', '\x10A1', '\x1098', '\x3', '\x2', 
		'\x2', '\x2', '\x10A1', '\x10A0', '\x3', '\x2', '\x2', '\x2', '\x10A2', 
		'\x2C5', '\x3', '\x2', '\x2', '\x2', '\x10A3', '\x10A4', '\a', '\x45', 
		'\x2', '\x2', '\x10A4', '\x10A5', '\x5', '\\', '/', '\x2', '\x10A5', '\x10A6', 
		'\x5', '\x368', '\x1B5', '\x2', '\x10A6', '\x2C7', '\x3', '\x2', '\x2', 
		'\x2', '\x10A7', '\x10B9', '\a', '\x173', '\x2', '\x2', '\x10A8', '\x10AB', 
		'\a', '\xD5', '\x2', '\x2', '\x10A9', '\x10AC', '\x5', '\x2E2', '\x172', 
		'\x2', '\x10AA', '\x10AC', '\x5', '\x2CC', '\x167', '\x2', '\x10AB', '\x10A9', 
		'\x3', '\x2', '\x2', '\x2', '\x10AB', '\x10AA', '\x3', '\x2', '\x2', '\x2', 
		'\x10AC', '\x10AD', '\x3', '\x2', '\x2', '\x2', '\x10AD', '\x10AB', '\x3', 
		'\x2', '\x2', '\x2', '\x10AD', '\x10AE', '\x3', '\x2', '\x2', '\x2', '\x10AE', 
		'\x10BA', '\x3', '\x2', '\x2', '\x2', '\x10AF', '\x10B2', '\a', '\xE2', 
		'\x2', '\x2', '\x10B0', '\x10B3', '\x5', '\x2E2', '\x172', '\x2', '\x10B1', 
		'\x10B3', '\x5', '\x2CE', '\x168', '\x2', '\x10B2', '\x10B0', '\x3', '\x2', 
		'\x2', '\x2', '\x10B2', '\x10B1', '\x3', '\x2', '\x2', '\x2', '\x10B3', 
		'\x10B4', '\x3', '\x2', '\x2', '\x2', '\x10B4', '\x10B2', '\x3', '\x2', 
		'\x2', '\x2', '\x10B4', '\x10B5', '\x3', '\x2', '\x2', '\x2', '\x10B5', 
		'\x10B7', '\x3', '\x2', '\x2', '\x2', '\x10B6', '\x10B8', '\x5', '\x2D0', 
		'\x169', '\x2', '\x10B7', '\x10B6', '\x3', '\x2', '\x2', '\x2', '\x10B7', 
		'\x10B8', '\x3', '\x2', '\x2', '\x2', '\x10B8', '\x10BA', '\x3', '\x2', 
		'\x2', '\x2', '\x10B9', '\x10A8', '\x3', '\x2', '\x2', '\x2', '\x10B9', 
		'\x10AF', '\x3', '\x2', '\x2', '\x2', '\x10BA', '\x2C9', '\x3', '\x2', 
		'\x2', '\x2', '\x10BB', '\x10BC', '\a', '\x1D1', '\x2', '\x2', '\x10BC', 
		'\x10BD', '\a', '\x65', '\x2', '\x2', '\x10BD', '\x10BE', '\t', '\x1D', 
		'\x2', '\x2', '\x10BE', '\x2CB', '\x3', '\x2', '\x2', '\x2', '\x10BF', 
		'\x10C0', '\x5', '\x2DA', '\x16E', '\x2', '\x10C0', '\x2CD', '\x3', '\x2', 
		'\x2', '\x2', '\x10C1', '\x10C5', '\x5', '\x2D6', '\x16C', '\x2', '\x10C2', 
		'\x10C5', '\x5', '\x2DC', '\x16F', '\x2', '\x10C3', '\x10C5', '\x5', '\x2D8', 
		'\x16D', '\x2', '\x10C4', '\x10C1', '\x3', '\x2', '\x2', '\x2', '\x10C4', 
		'\x10C2', '\x3', '\x2', '\x2', '\x2', '\x10C4', '\x10C3', '\x3', '\x2', 
		'\x2', '\x2', '\x10C5', '\x2CF', '\x3', '\x2', '\x2', '\x2', '\x10C6', 
		'\x10C8', '\x5', '\x2D4', '\x16B', '\x2', '\x10C7', '\x10C6', '\x3', '\x2', 
		'\x2', '\x2', '\x10C7', '\x10C8', '\x3', '\x2', '\x2', '\x2', '\x10C8', 
		'\x10C9', '\x3', '\x2', '\x2', '\x2', '\x10C9', '\x10CB', '\x5', '\x2D2', 
		'\x16A', '\x2', '\x10CA', '\x10CC', '\x5', '\x2E0', '\x171', '\x2', '\x10CB', 
		'\x10CA', '\x3', '\x2', '\x2', '\x2', '\x10CB', '\x10CC', '\x3', '\x2', 
		'\x2', '\x2', '\x10CC', '\x2D1', '\x3', '\x2', '\x2', '\x2', '\x10CD', 
		'\x10CF', '\a', '\x177', '\x2', '\x2', '\x10CE', '\x10D0', '\x5', '\x2E0', 
		'\x171', '\x2', '\x10CF', '\x10CE', '\x3', '\x2', '\x2', '\x2', '\x10CF', 
		'\x10D0', '\x3', '\x2', '\x2', '\x2', '\x10D0', '\x10D2', '\x3', '\x2', 
		'\x2', '\x2', '\x10D1', '\x10D3', '\x5', '\x2A4', '\x153', '\x2', '\x10D2', 
		'\x10D1', '\x3', '\x2', '\x2', '\x2', '\x10D2', '\x10D3', '\x3', '\x2', 
		'\x2', '\x2', '\x10D3', '\x2D3', '\x3', '\x2', '\x2', '\x2', '\x10D4', 
		'\x10D5', '\a', '\xE0', '\x2', '\x2', '\x10D5', '\x10D6', '\x5', '\\', 
		'/', '\x2', '\x10D6', '\x2D5', '\x3', '\x2', '\x2', '\x2', '\x10D7', '\x10D8', 
		'\a', '\x187', '\x2', '\x2', '\x10D8', '\x10D9', '\x5', '&', '\x14', '\x2', 
		'\x10D9', '\x2D7', '\x3', '\x2', '\x2', '\x2', '\x10DA', '\x10DB', '\a', 
		'\x11E', '\x2', '\x2', '\x10DB', '\x10DE', '\a', '\x1FD', '\x2', '\x2', 
		'\x10DC', '\x10DE', '\a', '\x14D', '\x2', '\x2', '\x10DD', '\x10DA', '\x3', 
		'\x2', '\x2', '\x2', '\x10DD', '\x10DC', '\x3', '\x2', '\x2', '\x2', '\x10DE', 
		'\x2D9', '\x3', '\x2', '\x2', '\x2', '\x10DF', '\x10E1', '\a', 'T', '\x2', 
		'\x2', '\x10E0', '\x10E2', '\x5', '\x2DE', '\x170', '\x2', '\x10E1', '\x10E0', 
		'\x3', '\x2', '\x2', '\x2', '\x10E1', '\x10E2', '\x3', '\x2', '\x2', '\x2', 
		'\x10E2', '\x10E4', '\x3', '\x2', '\x2', '\x2', '\x10E3', '\x10E5', '\x5', 
		'&', '\x14', '\x2', '\x10E4', '\x10E3', '\x3', '\x2', '\x2', '\x2', '\x10E4', 
		'\x10E5', '\x3', '\x2', '\x2', '\x2', '\x10E5', '\x1100', '\x3', '\x2', 
		'\x2', '\x2', '\x10E6', '\x10E7', '\a', '\x1BF', '\x2', '\x2', '\x10E7', 
		'\x10E8', '\a', '\x1EE', '\x2', '\x2', '\x10E8', '\x10EA', '\a', 'T', 
		'\x2', '\x2', '\x10E9', '\x10EB', '\t', '\x31', '\x2', '\x2', '\x10EA', 
		'\x10E9', '\x3', '\x2', '\x2', '\x2', '\x10EA', '\x10EB', '\x3', '\x2', 
		'\x2', '\x2', '\x10EB', '\x1100', '\x3', '\x2', '\x2', '\x2', '\x10EC', 
		'\x10ED', '\a', 'J', '\x2', '\x2', '\x10ED', '\x10EE', '\a', '\x1EE', 
		'\x2', '\x2', '\x10EE', '\x10F4', '\a', 'T', '\x2', '\x2', '\x10EF', '\x10F0', 
		'\a', '\xBE', '\x2', '\x2', '\x10F0', '\x10F2', '\t', '\x32', '\x2', '\x2', 
		'\x10F1', '\x10F3', '\t', '\x33', '\x2', '\x2', '\x10F2', '\x10F1', '\x3', 
		'\x2', '\x2', '\x2', '\x10F2', '\x10F3', '\x3', '\x2', '\x2', '\x2', '\x10F3', 
		'\x10F5', '\x3', '\x2', '\x2', '\x2', '\x10F4', '\x10EF', '\x3', '\x2', 
		'\x2', '\x2', '\x10F4', '\x10F5', '\x3', '\x2', '\x2', '\x2', '\x10F5', 
		'\x10FC', '\x3', '\x2', '\x2', '\x2', '\x10F6', '\x10F8', '\a', '\x144', 
		'\x2', '\x2', '\x10F7', '\x10F6', '\x3', '\x2', '\x2', '\x2', '\x10F7', 
		'\x10F8', '\x3', '\x2', '\x2', '\x2', '\x10F8', '\x10F9', '\x3', '\x2', 
		'\x2', '\x2', '\x10F9', '\x10FA', '\a', '\x1BF', '\x2', '\x2', '\x10FA', 
		'\x10FB', '\a', '\x106', '\x2', '\x2', '\x10FB', '\x10FD', '\a', '\x115', 
		'\x2', '\x2', '\x10FC', '\x10F7', '\x3', '\x2', '\x2', '\x2', '\x10FC', 
		'\x10FD', '\x3', '\x2', '\x2', '\x2', '\x10FD', '\x1100', '\x3', '\x2', 
		'\x2', '\x2', '\x10FE', '\x1100', '\a', '\x147', '\x2', '\x2', '\x10FF', 
		'\x10DF', '\x3', '\x2', '\x2', '\x2', '\x10FF', '\x10E6', '\x3', '\x2', 
		'\x2', '\x2', '\x10FF', '\x10EC', '\x3', '\x2', '\x2', '\x2', '\x10FF', 
		'\x10FE', '\x3', '\x2', '\x2', '\x2', '\x1100', '\x2DB', '\x3', '\x2', 
		'\x2', '\x2', '\x1101', '\x1107', '\a', 'T', '\x2', '\x2', '\x1102', '\x1103', 
		'\a', '\x6', '\x2', '\x2', '\x1103', '\x1108', '\t', '\x33', '\x2', '\x2', 
		'\x1104', '\x1106', '\x5', '&', '\x14', '\x2', '\x1105', '\x1104', '\x3', 
		'\x2', '\x2', '\x2', '\x1105', '\x1106', '\x3', '\x2', '\x2', '\x2', '\x1106', 
		'\x1108', '\x3', '\x2', '\x2', '\x2', '\x1107', '\x1102', '\x3', '\x2', 
		'\x2', '\x2', '\x1107', '\x1105', '\x3', '\x2', '\x2', '\x2', '\x1108', 
		'\x110B', '\x3', '\x2', '\x2', '\x2', '\x1109', '\x110B', '\a', '\x147', 
		'\x2', '\x2', '\x110A', '\x1101', '\x3', '\x2', '\x2', '\x2', '\x110A', 
		'\x1109', '\x3', '\x2', '\x2', '\x2', '\x110B', '\x2DD', '\x3', '\x2', 
		'\x2', '\x2', '\x110C', '\x110D', '\a', '\xBE', '\x2', '\x2', '\x110D', 
		'\x110E', '\t', '\x34', '\x2', '\x2', '\x110E', '\x110F', '\a', '\x16D', 
		'\x2', '\x2', '\x110F', '\x2DF', '\x3', '\x2', '\x2', '\x2', '\x1110', 
		'\x1112', '\x5', '\x2E2', '\x172', '\x2', '\x1111', '\x1110', '\x3', '\x2', 
		'\x2', '\x2', '\x1112', '\x1113', '\x3', '\x2', '\x2', '\x2', '\x1113', 
		'\x1111', '\x3', '\x2', '\x2', '\x2', '\x1113', '\x1114', '\x3', '\x2', 
		'\x2', '\x2', '\x1114', '\x2E1', '\x3', '\x2', '\x2', '\x2', '\x1115', 
		'\x1119', '\x5', '\x380', '\x1C1', '\x2', '\x1116', '\x1119', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1117', '\x1119', '\x5', '\x61E', '\x310', '\x2', '\x1118', 
		'\x1115', '\x3', '\x2', '\x2', '\x2', '\x1118', '\x1116', '\x3', '\x2', 
		'\x2', '\x2', '\x1118', '\x1117', '\x3', '\x2', '\x2', '\x2', '\x1119', 
		'\x2E3', '\x3', '\x2', '\x2', '\x2', '\x111A', '\x111B', '\a', '\x168', 
		'\x2', '\x2', '\x111B', '\x111C', '\a', 'N', '\x2', '\x2', '\x111C', '\x111D', 
		'\t', '\x35', '\x2', '\x2', '\x111D', '\x111E', '\a', '\x1C3', '\x2', 
		'\x2', '\x111E', '\x2E5', '\x3', '\x2', '\x2', '\x2', '\x111F', '\x1120', 
		'\a', '\x24D', '\x2', '\x2', '\x1120', '\x1125', '\x5', '\x2E8', '\x175', 
		'\x2', '\x1121', '\x1122', '\a', '\x24F', '\x2', '\x2', '\x1122', '\x1124', 
		'\x5', '\x2E8', '\x175', '\x2', '\x1123', '\x1121', '\x3', '\x2', '\x2', 
		'\x2', '\x1124', '\x1127', '\x3', '\x2', '\x2', '\x2', '\x1125', '\x1123', 
		'\x3', '\x2', '\x2', '\x2', '\x1125', '\x1126', '\x3', '\x2', '\x2', '\x2', 
		'\x1126', '\x1128', '\x3', '\x2', '\x2', '\x2', '\x1127', '\x1125', '\x3', 
		'\x2', '\x2', '\x2', '\x1128', '\x1129', '\a', '\x24E', '\x2', '\x2', 
		'\x1129', '\x2E7', '\x3', '\x2', '\x2', '\x2', '\x112A', '\x112F', '\x5', 
		'\x2FC', '\x17F', '\x2', '\x112B', '\x112F', '\x5', '\x366', '\x1B4', 
		'\x2', '\x112C', '\x112F', '\x5', '\x2EA', '\x176', '\x2', '\x112D', '\x112F', 
		'\x5', '\x2F2', '\x17A', '\x2', '\x112E', '\x112A', '\x3', '\x2', '\x2', 
		'\x2', '\x112E', '\x112B', '\x3', '\x2', '\x2', '\x2', '\x112E', '\x112C', 
		'\x3', '\x2', '\x2', '\x2', '\x112E', '\x112D', '\x3', '\x2', '\x2', '\x2', 
		'\x112F', '\x2E9', '\x3', '\x2', '\x2', '\x2', '\x1130', '\x1131', '\a', 
		'\x1F8', '\x2', '\x2', '\x1131', '\x1134', '\a', '\x116', '\x2', '\x2', 
		'\x1132', '\x1135', '\x5', '\x2EC', '\x177', '\x2', '\x1133', '\x1135', 
		'\x5', '\x2EE', '\x178', '\x2', '\x1134', '\x1132', '\x3', '\x2', '\x2', 
		'\x2', '\x1134', '\x1133', '\x3', '\x2', '\x2', '\x2', '\x1135', '\x2EB', 
		'\x3', '\x2', '\x2', '\x2', '\x1136', '\x1137', '\a', '\xD0', '\x2', '\x2', 
		'\x1137', '\x1138', '\x5', '\\', '/', '\x2', '\x1138', '\x113A', '\x5', 
		'\x368', '\x1B5', '\x2', '\x1139', '\x113B', '\a', '\xE', '\x2', '\x2', 
		'\x113A', '\x1139', '\x3', '\x2', '\x2', '\x2', '\x113A', '\x113B', '\x3', 
		'\x2', '\x2', '\x2', '\x113B', '\x2ED', '\x3', '\x2', '\x2', '\x2', '\x113C', 
		'\x113D', '\a', 'l', '\x2', '\x2', '\x113D', '\x113E', '\a', '\x24D', 
		'\x2', '\x2', '\x113E', '\x1143', '\x5', '\x2F0', '\x179', '\x2', '\x113F', 
		'\x1140', '\a', '\x24F', '\x2', '\x2', '\x1140', '\x1142', '\x5', '\x2F0', 
		'\x179', '\x2', '\x1141', '\x113F', '\x3', '\x2', '\x2', '\x2', '\x1142', 
		'\x1145', '\x3', '\x2', '\x2', '\x2', '\x1143', '\x1141', '\x3', '\x2', 
		'\x2', '\x2', '\x1143', '\x1144', '\x3', '\x2', '\x2', '\x2', '\x1144', 
		'\x1146', '\x3', '\x2', '\x2', '\x2', '\x1145', '\x1143', '\x3', '\x2', 
		'\x2', '\x2', '\x1146', '\x1147', '\a', '\x24E', '\x2', '\x2', '\x1147', 
		'\x1148', '\a', 'L', '\x2', '\x2', '\x1148', '\x2EF', '\x3', '\x2', '\x2', 
		'\x2', '\x1149', '\x1150', '\a', '\n', '\x2', '\x2', '\x114A', '\x114B', 
		'\a', '\x195', '\x2', '\x2', '\x114B', '\x1150', '\a', '\x100', '\x2', 
		'\x2', '\x114C', '\x1150', '\a', '\x21A', '\x2', '\x2', '\x114D', '\x114E', 
		'\a', '\xC1', '\x2', '\x2', '\x114E', '\x1150', '\a', '\x100', '\x2', 
		'\x2', '\x114F', '\x1149', '\x3', '\x2', '\x2', '\x2', '\x114F', '\x114A', 
		'\x3', '\x2', '\x2', '\x2', '\x114F', '\x114C', '\x3', '\x2', '\x2', '\x2', 
		'\x114F', '\x114D', '\x3', '\x2', '\x2', '\x2', '\x1150', '\x2F1', '\x3', 
		'\x2', '\x2', '\x2', '\x1151', '\x1152', '\x5', '\\', '/', '\x2', '\x1152', 
		'\x1154', '\x5', '`', '\x31', '\x2', '\x1153', '\x1155', '\x5', '\x382', 
		'\x1C2', '\x2', '\x1154', '\x1153', '\x3', '\x2', '\x2', '\x2', '\x1154', 
		'\x1155', '\x3', '\x2', '\x2', '\x2', '\x1155', '\x1159', '\x3', '\x2', 
		'\x2', '\x2', '\x1156', '\x115A', '\x5', '\x2F6', '\x17C', '\x2', '\x1157', 
		'\x115A', '\x5', '\x2F4', '\x17B', '\x2', '\x1158', '\x115A', '\x5', '\x2F8', 
		'\x17D', '\x2', '\x1159', '\x1156', '\x3', '\x2', '\x2', '\x2', '\x1159', 
		'\x1157', '\x3', '\x2', '\x2', '\x2', '\x1159', '\x1158', '\x3', '\x2', 
		'\x2', '\x2', '\x1159', '\x115A', '\x3', '\x2', '\x2', '\x2', '\x115A', 
		'\x1161', '\x3', '\x2', '\x2', '\x2', '\x115B', '\x1162', '\x5', '\x302', 
		'\x182', '\x2', '\x115C', '\x115E', '\x5', '\x36A', '\x1B6', '\x2', '\x115D', 
		'\x115C', '\x3', '\x2', '\x2', '\x2', '\x115E', '\x115F', '\x3', '\x2', 
		'\x2', '\x2', '\x115F', '\x115D', '\x3', '\x2', '\x2', '\x2', '\x115F', 
		'\x1160', '\x3', '\x2', '\x2', '\x2', '\x1160', '\x1162', '\x3', '\x2', 
		'\x2', '\x2', '\x1161', '\x115B', '\x3', '\x2', '\x2', '\x2', '\x1161', 
		'\x115D', '\x3', '\x2', '\x2', '\x2', '\x1161', '\x1162', '\x3', '\x2', 
		'\x2', '\x2', '\x1162', '\x2F3', '\x3', '\x2', '\x2', '\x2', '\x1163', 
		'\x116B', '\a', '\xCB', '\x2', '\x2', '\x1164', '\x116C', '\a', '\xE', 
		'\x2', '\x2', '\x1165', '\x1166', '\a', '\x33', '\x2', '\x2', '\x1166', 
		'\x1169', '\a', 'y', '\x2', '\x2', '\x1167', '\x1168', '\a', '\x168', 
		'\x2', '\x2', '\x1168', '\x116A', '\a', '\x160', '\x2', '\x2', '\x1169', 
		'\x1167', '\x3', '\x2', '\x2', '\x2', '\x1169', '\x116A', '\x3', '\x2', 
		'\x2', '\x2', '\x116A', '\x116C', '\x3', '\x2', '\x2', '\x2', '\x116B', 
		'\x1164', '\x3', '\x2', '\x2', '\x2', '\x116B', '\x1165', '\x3', '\x2', 
		'\x2', '\x2', '\x116B', '\x116C', '\x3', '\x2', '\x2', '\x2', '\x116C', 
		'\x116D', '\x3', '\x2', '\x2', '\x2', '\x116D', '\x116E', '\a', '\x15', 
		'\x2', '\x2', '\x116E', '\x117D', '\a', '\xDB', '\x2', '\x2', '\x116F', 
		'\x1173', '\a', '\x24D', '\x2', '\x2', '\x1170', '\x1172', '\x5', '\x66C', 
		'\x337', '\x2', '\x1171', '\x1170', '\x3', '\x2', '\x2', '\x2', '\x1172', 
		'\x1175', '\x3', '\x2', '\x2', '\x2', '\x1173', '\x1171', '\x3', '\x2', 
		'\x2', '\x2', '\x1173', '\x1174', '\x3', '\x2', '\x2', '\x2', '\x1174', 
		'\x1176', '\x3', '\x2', '\x2', '\x2', '\x1175', '\x1173', '\x3', '\x2', 
		'\x2', '\x2', '\x1176', '\x117E', '\a', '\x24E', '\x2', '\x2', '\x1177', 
		'\x1179', '\x5', '\x66C', '\x337', '\x2', '\x1178', '\x1177', '\x3', '\x2', 
		'\x2', '\x2', '\x1179', '\x117C', '\x3', '\x2', '\x2', '\x2', '\x117A', 
		'\x1178', '\x3', '\x2', '\x2', '\x2', '\x117A', '\x117B', '\x3', '\x2', 
		'\x2', '\x2', '\x117B', '\x117E', '\x3', '\x2', '\x2', '\x2', '\x117C', 
		'\x117A', '\x3', '\x2', '\x2', '\x2', '\x117D', '\x116F', '\x3', '\x2', 
		'\x2', '\x2', '\x117D', '\x117A', '\x3', '\x2', '\x2', '\x2', '\x117E', 
		'\x2F5', '\x3', '\x2', '\x2', '\x2', '\x117F', '\x1182', '\a', 'y', '\x2', 
		'\x2', '\x1180', '\x1181', '\a', '\x168', '\x2', '\x2', '\x1181', '\x1183', 
		'\a', '\x160', '\x2', '\x2', '\x1182', '\x1180', '\x3', '\x2', '\x2', 
		'\x2', '\x1182', '\x1183', '\x3', '\x2', '\x2', '\x2', '\x1183', '\x1184', 
		'\x3', '\x2', '\x2', '\x2', '\x1184', '\x1185', '\x5', '\xA0', 'Q', '\x2', 
		'\x1185', '\x2F7', '\x3', '\x2', '\x2', '\x2', '\x1186', '\x1187', '\a', 
		'\xCB', '\x2', '\x2', '\x1187', '\x1189', '\a', '\xE', '\x2', '\x2', '\x1188', 
		'\x1186', '\x3', '\x2', '\x2', '\x2', '\x1188', '\x1189', '\x3', '\x2', 
		'\x2', '\x2', '\x1189', '\x118A', '\x3', '\x2', '\x2', '\x2', '\x118A', 
		'\x118B', '\a', '\x15', '\x2', '\x2', '\x118B', '\x118C', '\a', '\x24D', 
		'\x2', '\x2', '\x118C', '\x118D', '\x5', '\x2FA', '\x17E', '\x2', '\x118D', 
		'\x118F', '\a', '\x24E', '\x2', '\x2', '\x118E', '\x1190', '\a', '\x230', 
		'\x2', '\x2', '\x118F', '\x118E', '\x3', '\x2', '\x2', '\x2', '\x118F', 
		'\x1190', '\x3', '\x2', '\x2', '\x2', '\x1190', '\x1192', '\x3', '\x2', 
		'\x2', '\x2', '\x1191', '\x1193', '\x5', '\x1CA', '\xE6', '\x2', '\x1192', 
		'\x1191', '\x3', '\x2', '\x2', '\x2', '\x1192', '\x1193', '\x3', '\x2', 
		'\x2', '\x2', '\x1193', '\x2F9', '\x3', '\x2', '\x2', '\x2', '\x1194', 
		'\x1195', '\x5', '\xA0', 'Q', '\x2', '\x1195', '\x2FB', '\x3', '\x2', 
		'\x2', '\x2', '\x1196', '\x119A', '\x5', '\x2FE', '\x180', '\x2', '\x1197', 
		'\x119A', '\x5', '\x30A', '\x186', '\x2', '\x1198', '\x119A', '\x5', '\x300', 
		'\x181', '\x2', '\x1199', '\x1196', '\x3', '\x2', '\x2', '\x2', '\x1199', 
		'\x1197', '\x3', '\x2', '\x2', '\x2', '\x1199', '\x1198', '\x3', '\x2', 
		'\x2', '\x2', '\x119A', '\x2FD', '\x3', '\x2', '\x2', '\x2', '\x119B', 
		'\x119C', '\a', '\x1A8', '\x2', '\x2', '\x119C', '\x119D', '\x5', '\x368', 
		'\x1B5', '\x2', '\x119D', '\x119E', '\a', '\x236', '\x2', '\x2', '\x119E', 
		'\x119F', '\a', '\x1C2', '\x2', '\x2', '\x119F', '\x2FF', '\x3', '\x2', 
		'\x2', '\x2', '\x11A0', '\x11A1', '\a', '\x1CC', '\x2', '\x2', '\x11A1', 
		'\x11A2', '\a', '\xBE', '\x2', '\x2', '\x11A2', '\x11A3', '\x5', '\x368', 
		'\x1B5', '\x2', '\x11A3', '\x11A4', '\a', '\xF7', '\x2', '\x2', '\x11A4', 
		'\x11A5', '\x5', '\x44', '#', '\x2', '\x11A5', '\x301', '\x3', '\x2', 
		'\x2', '\x2', '\x11A6', '\x11A8', '\x5', '\x3A8', '\x1D5', '\x2', '\x11A7', 
		'\x11A6', '\x3', '\x2', '\x2', '\x2', '\x11A7', '\x11A8', '\x3', '\x2', 
		'\x2', '\x2', '\x11A8', '\x11A9', '\x3', '\x2', '\x2', '\x2', '\x11A9', 
		'\x11AB', '\x5', '\x3B6', '\x1DC', '\x2', '\x11AA', '\x11AC', '\x5', '\x3B8', 
		'\x1DD', '\x2', '\x11AB', '\x11AA', '\x3', '\x2', '\x2', '\x2', '\x11AB', 
		'\x11AC', '\x3', '\x2', '\x2', '\x2', '\x11AC', '\x11AE', '\x3', '\x2', 
		'\x2', '\x2', '\x11AD', '\x11AF', '\x5', '\x36C', '\x1B7', '\x2', '\x11AE', 
		'\x11AD', '\x3', '\x2', '\x2', '\x2', '\x11AE', '\x11AF', '\x3', '\x2', 
		'\x2', '\x2', '\x11AF', '\x11B3', '\x3', '\x2', '\x2', '\x2', '\x11B0', 
		'\x11B3', '\x5', '\x304', '\x183', '\x2', '\x11B1', '\x11B3', '\x5', '\x306', 
		'\x184', '\x2', '\x11B2', '\x11A7', '\x3', '\x2', '\x2', '\x2', '\x11B2', 
		'\x11B0', '\x3', '\x2', '\x2', '\x2', '\x11B2', '\x11B1', '\x3', '\x2', 
		'\x2', '\x2', '\x11B3', '\x303', '\x3', '\x2', '\x2', '\x2', '\x11B4', 
		'\x11B5', '\a', '\x236', '\x2', '\x2', '\x11B5', '\x11B6', '\a', '\x1C2', 
		'\x2', '\x2', '\x11B6', '\x305', '\x3', '\x2', '\x2', '\x2', '\x11B7', 
		'\x11B8', '\a', '\x1CC', '\x2', '\x2', '\x11B8', '\x11B9', '\a', '\xF7', 
		'\x2', '\x2', '\x11B9', '\x11BA', '\x5', '\x44', '#', '\x2', '\x11BA', 
		'\x307', '\x3', '\x2', '\x2', '\x2', '\x11BB', '\x11BC', '\a', '\xC1', 
		'\x2', '\x2', '\x11BC', '\x11BD', '\a', '\x100', '\x2', '\x2', '\x11BD', 
		'\x11BE', '\x5', '\x368', '\x1B5', '\x2', '\x11BE', '\x309', '\x3', '\x2', 
		'\x2', '\x2', '\x11BF', '\x11C1', '\x5', '\x3A8', '\x1D5', '\x2', '\x11C0', 
		'\x11BF', '\x3', '\x2', '\x2', '\x2', '\x11C0', '\x11C1', '\x3', '\x2', 
		'\x2', '\x2', '\x11C1', '\x11C2', '\x3', '\x2', '\x2', '\x2', '\x11C2', 
		'\x11C3', '\x5', '\x308', '\x185', '\x2', '\x11C3', '\x11C5', '\x5', '\x3B6', 
		'\x1DC', '\x2', '\x11C4', '\x11C6', '\x5', '\x3B8', '\x1DD', '\x2', '\x11C5', 
		'\x11C4', '\x3', '\x2', '\x2', '\x2', '\x11C5', '\x11C6', '\x3', '\x2', 
		'\x2', '\x2', '\x11C6', '\x11C8', '\x3', '\x2', '\x2', '\x2', '\x11C7', 
		'\x11C9', '\x5', '\x36C', '\x1B7', '\x2', '\x11C8', '\x11C7', '\x3', '\x2', 
		'\x2', '\x2', '\x11C8', '\x11C9', '\x3', '\x2', '\x2', '\x2', '\x11C9', 
		'\x30B', '\x3', '\x2', '\x2', '\x2', '\x11CA', '\x11CB', '\x5', '\x30E', 
		'\x188', '\x2', '\x11CB', '\x11CC', '\a', '\x15', '\x2', '\x2', '\x11CC', 
		'\x11CD', '\x5', '\x356', '\x1AC', '\x2', '\x11CD', '\x30D', '\x3', '\x2', 
		'\x2', '\x2', '\x11CE', '\x11CF', '\a', '\x121', '\x2', '\x2', '\x11CF', 
		'\x11D0', '\a', '\x22F', '\x2', '\x2', '\x11D0', '\x11D2', '\x5', '\x44', 
		'#', '\x2', '\x11D1', '\x11D3', '\x5', '\x310', '\x189', '\x2', '\x11D2', 
		'\x11D1', '\x3', '\x2', '\x2', '\x2', '\x11D2', '\x11D3', '\x3', '\x2', 
		'\x2', '\x2', '\x11D3', '\x11D5', '\x3', '\x2', '\x2', '\x2', '\x11D4', 
		'\x11D6', '\x5', '\x35A', '\x1AE', '\x2', '\x11D5', '\x11D4', '\x3', '\x2', 
		'\x2', '\x2', '\x11D5', '\x11D6', '\x3', '\x2', '\x2', '\x2', '\x11D6', 
		'\x11D8', '\x3', '\x2', '\x2', '\x2', '\x11D7', '\x11D9', '\x5', '\x192', 
		'\xCA', '\x2', '\x11D8', '\x11D7', '\x3', '\x2', '\x2', '\x2', '\x11D8', 
		'\x11D9', '\x3', '\x2', '\x2', '\x2', '\x11D9', '\x11DE', '\x3', '\x2', 
		'\x2', '\x2', '\x11DA', '\x11DF', '\x5', '\x312', '\x18A', '\x2', '\x11DB', 
		'\x11DC', '\x5', '\x2C4', '\x163', '\x2', '\x11DC', '\x11DD', '\x5', '\x318', 
		'\x18D', '\x2', '\x11DD', '\x11DF', '\x3', '\x2', '\x2', '\x2', '\x11DE', 
		'\x11DA', '\x3', '\x2', '\x2', '\x2', '\x11DE', '\x11DB', '\x3', '\x2', 
		'\x2', '\x2', '\x11DE', '\x11DF', '\x3', '\x2', '\x2', '\x2', '\x11DF', 
		'\x11E1', '\x3', '\x2', '\x2', '\x2', '\x11E0', '\x11E2', '\x5', '\x31E', 
		'\x190', '\x2', '\x11E1', '\x11E0', '\x3', '\x2', '\x2', '\x2', '\x11E1', 
		'\x11E2', '\x3', '\x2', '\x2', '\x2', '\x11E2', '\x11E4', '\x3', '\x2', 
		'\x2', '\x2', '\x11E3', '\x11E5', '\x5', '\x322', '\x192', '\x2', '\x11E4', 
		'\x11E3', '\x3', '\x2', '\x2', '\x2', '\x11E4', '\x11E5', '\x3', '\x2', 
		'\x2', '\x2', '\x11E5', '\x11E7', '\x3', '\x2', '\x2', '\x2', '\x11E6', 
		'\x11E8', '\x5', '\x332', '\x19A', '\x2', '\x11E7', '\x11E6', '\x3', '\x2', 
		'\x2', '\x2', '\x11E7', '\x11E8', '\x3', '\x2', '\x2', '\x2', '\x11E8', 
		'\x11EA', '\x3', '\x2', '\x2', '\x2', '\x11E9', '\x11EB', '\x5', '\x334', 
		'\x19B', '\x2', '\x11EA', '\x11E9', '\x3', '\x2', '\x2', '\x2', '\x11EA', 
		'\x11EB', '\x3', '\x2', '\x2', '\x2', '\x11EB', '\x11ED', '\x3', '\x2', 
		'\x2', '\x2', '\x11EC', '\x11EE', '\x5', '\x336', '\x19C', '\x2', '\x11ED', 
		'\x11EC', '\x3', '\x2', '\x2', '\x2', '\x11ED', '\x11EE', '\x3', '\x2', 
		'\x2', '\x2', '\x11EE', '\x30F', '\x3', '\x2', '\x2', '\x2', '\x11EF', 
		'\x11F0', '\a', '\x164', '\x2', '\x2', '\x11F0', '\x11F1', '\x5', '\x44', 
		'#', '\x2', '\x11F1', '\x311', '\x3', '\x2', '\x2', '\x2', '\x11F2', '\x11F3', 
		'\a', '\x168', '\x2', '\x2', '\x11F3', '\x11F4', '\a', '\x191', '\x2', 
		'\x2', '\x11F4', '\x11F8', '\a', '\x1FD', '\x2', '\x2', '\x11F5', '\x11F6', 
		'\t', '\x36', '\x2', '\x2', '\x11F6', '\x11F7', '\a', '\x1A7', '\x2', 
		'\x2', '\x11F7', '\x11F9', '\a', '\x193', '\x2', '\x2', '\x11F8', '\x11F5', 
		'\x3', '\x2', '\x2', '\x2', '\x11F8', '\x11F9', '\x3', '\x2', '\x2', '\x2', 
		'\x11F9', '\x313', '\x3', '\x2', '\x2', '\x2', '\x11FA', '\x11FB', '\a', 
		'\x45', '\x2', '\x2', '\x11FB', '\x11FC', '\x5', 'Z', '.', '\x2', '\x11FC', 
		'\x11FD', '\x5', '\x316', '\x18C', '\x2', '\x11FD', '\x315', '\x3', '\x2', 
		'\x2', '\x2', '\x11FE', '\x1200', '\a', '\x24D', '\x2', '\x2', '\x11FF', 
		'\x1201', '\x5', 'Z', '.', '\x2', '\x1200', '\x11FF', '\x3', '\x2', '\x2', 
		'\x2', '\x1201', '\x1202', '\x3', '\x2', '\x2', '\x2', '\x1202', '\x1200', 
		'\x3', '\x2', '\x2', '\x2', '\x1202', '\x1203', '\x3', '\x2', '\x2', '\x2', 
		'\x1203', '\x1204', '\x3', '\x2', '\x2', '\x2', '\x1204', '\x1205', '\a', 
		'\x24E', '\x2', '\x2', '\x1205', '\x317', '\x3', '\x2', '\x2', '\x2', 
		'\x1206', '\x1208', '\x5', '\x246', '\x124', '\x2', '\x1207', '\x1206', 
		'\x3', '\x2', '\x2', '\x2', '\x1207', '\x1208', '\x3', '\x2', '\x2', '\x2', 
		'\x1208', '\x120A', '\x3', '\x2', '\x2', '\x2', '\x1209', '\x120B', '\x5', 
		'\x276', '\x13C', '\x2', '\x120A', '\x1209', '\x3', '\x2', '\x2', '\x2', 
		'\x120A', '\x120B', '\x3', '\x2', '\x2', '\x2', '\x120B', '\x120D', '\x3', 
		'\x2', '\x2', '\x2', '\x120C', '\x120E', '\x5', '\x31A', '\x18E', '\x2', 
		'\x120D', '\x120C', '\x3', '\x2', '\x2', '\x2', '\x120D', '\x120E', '\x3', 
		'\x2', '\x2', '\x2', '\x120E', '\x1210', '\x3', '\x2', '\x2', '\x2', '\x120F', 
		'\x1211', '\x5', '\x274', '\x13B', '\x2', '\x1210', '\x120F', '\x3', '\x2', 
		'\x2', '\x2', '\x1210', '\x1211', '\x3', '\x2', '\x2', '\x2', '\x1211', 
		'\x1213', '\x3', '\x2', '\x2', '\x2', '\x1212', '\x1214', '\x5', '\x31C', 
		'\x18F', '\x2', '\x1213', '\x1212', '\x3', '\x2', '\x2', '\x2', '\x1213', 
		'\x1214', '\x3', '\x2', '\x2', '\x2', '\x1214', '\x319', '\x3', '\x2', 
		'\x2', '\x2', '\x1215', '\x1216', '\t', '\x37', '\x2', '\x2', '\x1216', 
		'\x31B', '\x3', '\x2', '\x2', '\x2', '\x1217', '\x1218', '\a', '.', '\x2', 
		'\x2', '\x1218', '\x1219', '\t', '\x1D', '\x2', '\x2', '\x1219', '\x31D', 
		'\x3', '\x2', '\x2', '\x2', '\x121A', '\x1221', '\a', '\x225', '\x2', 
		'\x2', '\x121B', '\x121C', '\a', '\x144', '\x2', '\x2', '\x121C', '\x1222', 
		'\a', '\xE2', '\x2', '\x2', '\x121D', '\x121F', '\a', '\xE2', '\x2', '\x2', 
		'\x121E', '\x1220', '\x5', '\x320', '\x191', '\x2', '\x121F', '\x121E', 
		'\x3', '\x2', '\x2', '\x2', '\x121F', '\x1220', '\x3', '\x2', '\x2', '\x2', 
		'\x1220', '\x1222', '\x3', '\x2', '\x2', '\x2', '\x1221', '\x121B', '\x3', 
		'\x2', '\x2', '\x2', '\x1221', '\x121D', '\x3', '\x2', '\x2', '\x2', '\x1222', 
		'\x31F', '\x3', '\x2', '\x2', '\x2', '\x1223', '\x1226', '\x5', '\x380', 
		'\x1C1', '\x2', '\x1224', '\x1226', '\x5', '\x61E', '\x310', '\x2', '\x1225', 
		'\x1223', '\x3', '\x2', '\x2', '\x2', '\x1225', '\x1224', '\x3', '\x2', 
		'\x2', '\x2', '\x1226', '\x1227', '\x3', '\x2', '\x2', '\x2', '\x1227', 
		'\x1225', '\x3', '\x2', '\x2', '\x2', '\x1227', '\x1228', '\x3', '\x2', 
		'\x2', '\x2', '\x1228', '\x321', '\x3', '\x2', '\x2', '\x2', '\x1229', 
		'\x122A', '\a', '\x1AB', '\x2', '\x2', '\x122A', '\x122E', '\x5', '\x324', 
		'\x193', '\x2', '\x122B', '\x122C', '\a', '\x140', '\x2', '\x2', '\x122C', 
		'\x122E', '\a', '\x1AB', '\x2', '\x2', '\x122D', '\x1229', '\x3', '\x2', 
		'\x2', '\x2', '\x122D', '\x122B', '\x3', '\x2', '\x2', '\x2', '\x122E', 
		'\x323', '\x3', '\x2', '\x2', '\x2', '\x122F', '\x1236', '\x5', '\x326', 
		'\x194', '\x2', '\x1230', '\x1236', '\x5', '\x328', '\x195', '\x2', '\x1231', 
		'\x1236', '\x5', '\x32A', '\x196', '\x2', '\x1232', '\x1236', '\x5', '\x32C', 
		'\x197', '\x2', '\x1233', '\x1236', '\x5', '\x32E', '\x198', '\x2', '\x1234', 
		'\x1236', '\x5', '\x330', '\x199', '\x2', '\x1235', '\x122F', '\x3', '\x2', 
		'\x2', '\x2', '\x1235', '\x1230', '\x3', '\x2', '\x2', '\x2', '\x1235', 
		'\x1231', '\x3', '\x2', '\x2', '\x2', '\x1235', '\x1232', '\x3', '\x2', 
		'\x2', '\x2', '\x1235', '\x1233', '\x3', '\x2', '\x2', '\x2', '\x1235', 
		'\x1234', '\x3', '\x2', '\x2', '\x2', '\x1236', '\x1237', '\x3', '\x2', 
		'\x2', '\x2', '\x1237', '\x1235', '\x3', '\x2', '\x2', '\x2', '\x1237', 
		'\x1238', '\x3', '\x2', '\x2', '\x2', '\x1238', '\x325', '\x3', '\x2', 
		'\x2', '\x2', '\x1239', '\x123A', '\t', '\x38', '\x2', '\x2', '\x123A', 
		'\x327', '\x3', '\x2', '\x2', '\x2', '\x123B', '\x123C', '\a', '\x168', 
		'\x2', '\x2', '\x123C', '\x123D', '\t', '\x39', '\x2', '\x2', '\x123D', 
		'\x329', '\x3', '\x2', '\x2', '\x2', '\x123E', '\x123F', '\a', '\x1E8', 
		'\x2', '\x2', '\x123F', '\x1242', '\a', '\x236', '\x2', '\x2', '\x1240', 
		'\x1242', '\a', '\x143', '\x2', '\x2', '\x1241', '\x123E', '\x3', '\x2', 
		'\x2', '\x2', '\x1241', '\x1240', '\x3', '\x2', '\x2', '\x2', '\x1242', 
		'\x1243', '\x3', '\x2', '\x2', '\x2', '\x1243', '\x1244', '\x5', '\xA0', 
		'Q', '\x2', '\x1244', '\x32B', '\x3', '\x2', '\x2', '\x2', '\x1245', '\x1249', 
		'\a', '\x236', '\x2', '\x2', '\x1246', '\x1247', '\a', '\x195', '\x2', 
		'\x2', '\x1247', '\x124A', '\a', '\x100', '\x2', '\x2', '\x1248', '\x124A', 
		'\a', '\x1C2', '\x2', '\x2', '\x1249', '\x1246', '\x3', '\x2', '\x2', 
		'\x2', '\x1249', '\x1248', '\x3', '\x2', '\x2', '\x2', '\x124A', '\x32D', 
		'\x3', '\x2', '\x2', '\x2', '\x124B', '\x1258', '\a', '\x225', '\x2', 
		'\x2', '\x124C', '\x124E', '\a', 'y', '\x2', '\x2', '\x124D', '\x124F', 
		'\t', ':', '\x2', '\x2', '\x124E', '\x124D', '\x3', '\x2', '\x2', '\x2', 
		'\x124E', '\x124F', '\x3', '\x2', '\x2', '\x2', '\x124F', '\x1250', '\x3', 
		'\x2', '\x2', '\x2', '\x1250', '\x1251', '\a', '\x1BD', '\x2', '\x2', 
		'\x1251', '\x1259', '\a', '\x1D1', '\x2', '\x2', '\x1252', '\x1254', '\t', 
		':', '\x2', '\x2', '\x1253', '\x1252', '\x3', '\x2', '\x2', '\x2', '\x1253', 
		'\x1254', '\x3', '\x2', '\x2', '\x2', '\x1254', '\x1255', '\x3', '\x2', 
		'\x2', '\x2', '\x1255', '\x1256', '\a', '\x1BD', '\x2', '\x2', '\x1256', 
		'\x1257', '\a', '\x1D1', '\x2', '\x2', '\x1257', '\x1259', '\x5', 'Z', 
		'.', '\x2', '\x1258', '\x124C', '\x3', '\x2', '\x2', '\x2', '\x1258', 
		'\x1253', '\x3', '\x2', '\x2', '\x2', '\x1259', '\x32F', '\x3', '\x2', 
		'\x2', '\x2', '\x125A', '\x125B', '\a', '\x225', '\x2', '\x2', '\x125B', 
		'\x125C', '\t', ';', '\x2', '\x2', '\x125C', '\x125D', '\a', '\\', '\x2', 
		'\x2', '\x125D', '\x331', '\x3', '\x2', '\x2', '\x2', '\x125E', '\x125F', 
		'\a', '\xA3', '\x2', '\x2', '\x125F', '\x1266', '\a', '\x225', '\x2', 
		'\x2', '\x1260', '\x1261', '\a', 'h', '\x2', '\x2', '\x1261', '\x1267', 
		'\a', '\x92', '\x2', '\x2', '\x1262', '\x1263', '\a', '\x92', '\x2', '\x2', 
		'\x1263', '\x1267', '\x5', 'Z', '.', '\x2', '\x1264', '\x1265', '\a', 
		'\x160', '\x2', '\x2', '\x1265', '\x1267', '\a', '\x92', '\x2', '\x2', 
		'\x1266', '\x1260', '\x3', '\x2', '\x2', '\x2', '\x1266', '\x1262', '\x3', 
		'\x2', '\x2', '\x2', '\x1266', '\x1264', '\x3', '\x2', '\x2', '\x2', '\x1267', 
		'\x333', '\x3', '\x2', '\x2', '\x2', '\x1268', '\x1269', '\t', '<', '\x2', 
		'\x2', '\x1269', '\x126A', '\a', '\x168', '\x2', '\x2', '\x126A', '\x126B', 
		'\a', '\x19C', '\x2', '\x2', '\x126B', '\x126C', '\a', 'U', '\x2', '\x2', 
		'\x126C', '\x335', '\x3', '\x2', '\x2', '\x2', '\x126D', '\x126E', '\t', 
		'<', '\x2', '\x2', '\x126E', '\x126F', '\a', '\x19C', '\x2', '\x2', '\x126F', 
		'\x1271', '\a', '\x1BB', '\x2', '\x2', '\x1270', '\x1272', '\x5', '\x338', 
		'\x19D', '\x2', '\x1271', '\x1270', '\x3', '\x2', '\x2', '\x2', '\x1271', 
		'\x1272', '\x3', '\x2', '\x2', '\x2', '\x1272', '\x1274', '\x3', '\x2', 
		'\x2', '\x2', '\x1273', '\x1275', '\x5', '\x33A', '\x19E', '\x2', '\x1274', 
		'\x1273', '\x3', '\x2', '\x2', '\x2', '\x1274', '\x1275', '\x3', '\x2', 
		'\x2', '\x2', '\x1275', '\x337', '\x3', '\x2', '\x2', '\x2', '\x1276', 
		'\x1277', '\a', '\x21E', '\x2', '\x2', '\x1277', '\x127C', '\a', '#', 
		'\x2', '\x2', '\x1278', '\x1279', '\a', 'h', '\x2', '\x2', '\x1279', '\x127D', 
		'\a', '\x92', '\x2', '\x2', '\x127A', '\x127B', '\a', '\x92', '\x2', '\x2', 
		'\x127B', '\x127D', '\x5', 'Z', '.', '\x2', '\x127C', '\x1278', '\x3', 
		'\x2', '\x2', '\x2', '\x127C', '\x127A', '\x3', '\x2', '\x2', '\x2', '\x127D', 
		'\x339', '\x3', '\x2', '\x2', '\x2', '\x127E', '\x127F', '\a', '\x21E', 
		'\x2', '\x2', '\x127F', '\x1280', '\a', '%', '\x2', '\x2', '\x1280', '\x1287', 
		'\a', '\x236', '\x2', '\x2', '\x1281', '\x1282', '\a', 'h', '\x2', '\x2', 
		'\x1282', '\x1288', '\a', '\x92', '\x2', '\x2', '\x1283', '\x1284', '\a', 
		'\x92', '\x2', '\x2', '\x1284', '\x1288', '\x5', 'Z', '.', '\x2', '\x1285', 
		'\x1286', '\a', '\x160', '\x2', '\x2', '\x1286', '\x1288', '\a', '\x92', 
		'\x2', '\x2', '\x1287', '\x1281', '\x3', '\x2', '\x2', '\x2', '\x1287', 
		'\x1283', '\x3', '\x2', '\x2', '\x2', '\x1287', '\x1285', '\x3', '\x2', 
		'\x2', '\x2', '\x1288', '\x33B', '\x3', '\x2', '\x2', '\x2', '\x1289', 
		'\x128B', '\x5', '\x354', '\x1AB', '\x2', '\x128A', '\x1289', '\x3', '\x2', 
		'\x2', '\x2', '\x128A', '\x128B', '\x3', '\x2', '\x2', '\x2', '\x128B', 
		'\x128D', '\x3', '\x2', '\x2', '\x2', '\x128C', '\x128E', '\x5', '\x1DE', 
		'\xF0', '\x2', '\x128D', '\x128C', '\x3', '\x2', '\x2', '\x2', '\x128D', 
		'\x128E', '\x3', '\x2', '\x2', '\x2', '\x128E', '\x1290', '\x3', '\x2', 
		'\x2', '\x2', '\x128F', '\x1291', '\a', '\x94', '\x2', '\x2', '\x1290', 
		'\x128F', '\x3', '\x2', '\x2', '\x2', '\x1290', '\x1291', '\x3', '\x2', 
		'\x2', '\x2', '\x1291', '\x1292', '\x3', '\x2', '\x2', '\x2', '\x1292', 
		'\x1293', '\x5', '\x33E', '\x1A0', '\x2', '\x1293', '\x1294', '\x5', '\x356', 
		'\x1AC', '\x2', '\x1294', '\x33D', '\x3', '\x2', '\x2', '\x2', '\x1295', 
		'\x1296', '\a', '\x22F', '\x2', '\x2', '\x1296', '\x129A', '\x5', '\x44', 
		'#', '\x2', '\x1297', '\x129B', '\x5', '\x35A', '\x1AE', '\x2', '\x1298', 
		'\x129B', '\x5', '\x340', '\x1A1', '\x2', '\x1299', '\x129B', '\x5', '\x34C', 
		'\x1A7', '\x2', '\x129A', '\x1297', '\x3', '\x2', '\x2', '\x2', '\x129A', 
		'\x1298', '\x3', '\x2', '\x2', '\x2', '\x129A', '\x1299', '\x3', '\x2', 
		'\x2', '\x2', '\x129A', '\x129B', '\x3', '\x2', '\x2', '\x2', '\x129B', 
		'\x129D', '\x3', '\x2', '\x2', '\x2', '\x129C', '\x129E', '\x5', '\x192', 
		'\xCA', '\x2', '\x129D', '\x129C', '\x3', '\x2', '\x2', '\x2', '\x129D', 
		'\x129E', '\x3', '\x2', '\x2', '\x2', '\x129E', '\x129F', '\x3', '\x2', 
		'\x2', '\x2', '\x129F', '\x12A0', '\a', '\x15', '\x2', '\x2', '\x12A0', 
		'\x33F', '\x3', '\x2', '\x2', '\x2', '\x12A1', '\x12A2', '\a', '\x164', 
		'\x2', '\x2', '\x12A2', '\x12A3', '\a', '\x244', '\x2', '\x2', '\x12A3', 
		'\x12A4', '\x5', '\x342', '\x1A2', '\x2', '\x12A4', '\x12A5', '\x5', '\x350', 
		'\x1A9', '\x2', '\x12A5', '\x341', '\x3', '\x2', '\x2', '\x2', '\x12A6', 
		'\x12A8', '\x5', '\x344', '\x1A3', '\x2', '\x12A7', '\x12A6', '\x3', '\x2', 
		'\x2', '\x2', '\x12A7', '\x12A8', '\x3', '\x2', '\x2', '\x2', '\x12A8', 
		'\x12AA', '\x3', '\x2', '\x2', '\x2', '\x12A9', '\x12AB', '\x5', '\x346', 
		'\x1A4', '\x2', '\x12AA', '\x12A9', '\x3', '\x2', '\x2', '\x2', '\x12AA', 
		'\x12AB', '\x3', '\x2', '\x2', '\x2', '\x12AB', '\x12AD', '\x3', '\x2', 
		'\x2', '\x2', '\x12AC', '\x12AE', '\x5', '\x252', '\x12A', '\x2', '\x12AD', 
		'\x12AC', '\x3', '\x2', '\x2', '\x2', '\x12AD', '\x12AE', '\x3', '\x2', 
		'\x2', '\x2', '\x12AE', '\x12B0', '\x3', '\x2', '\x2', '\x2', '\x12AF', 
		'\x12B1', '\x5', '\x348', '\x1A5', '\x2', '\x12B0', '\x12AF', '\x3', '\x2', 
		'\x2', '\x2', '\x12B0', '\x12B1', '\x3', '\x2', '\x2', '\x2', '\x12B1', 
		'\x12B3', '\x3', '\x2', '\x2', '\x2', '\x12B2', '\x12B4', '\x5', '\x34A', 
		'\x1A6', '\x2', '\x12B3', '\x12B2', '\x3', '\x2', '\x2', '\x2', '\x12B3', 
		'\x12B4', '\x3', '\x2', '\x2', '\x2', '\x12B4', '\x343', '\x3', '\x2', 
		'\x2', '\x2', '\x12B5', '\x12B6', '\a', '\x242', '\x2', '\x2', '\x12B6', 
		'\x12B7', '\x5', 'Z', '.', '\x2', '\x12B7', '\x345', '\x3', '\x2', '\x2', 
		'\x2', '\x12B8', '\x12B9', '\a', '\x96', '\x2', '\x2', '\x12B9', '\x12BC', 
		'\x5', 'Z', '.', '\x2', '\x12BA', '\x12BB', '\a', '\x25A', '\x2', '\x2', 
		'\x12BB', '\x12BD', '\x5', 'Z', '.', '\x2', '\x12BC', '\x12BA', '\x3', 
		'\x2', '\x2', '\x2', '\x12BC', '\x12BD', '\x3', '\x2', '\x2', '\x2', '\x12BD', 
		'\x347', '\x3', '\x2', '\x2', '\x2', '\x12BE', '\x12BF', '\t', '=', '\x2', 
		'\x2', '\x12BF', '\x12C0', '\a', '\x154', '\x2', '\x2', '\x12C0', '\x349', 
		'\x3', '\x2', '\x2', '\x2', '\x12C1', '\x12C2', '\t', '=', '\x2', '\x2', 
		'\x12C2', '\x12C3', '\a', '\x12', '\x2', '\x2', '\x12C3', '\x34B', '\x3', 
		'\x2', '\x2', '\x2', '\x12C4', '\x12C5', '\a', '\x164', '\x2', '\x2', 
		'\x12C5', '\x12C8', '\x5', '\x44', '#', '\x2', '\x12C6', '\x12C9', '\x5', 
		'\x350', '\x1A9', '\x2', '\x12C7', '\x12C9', '\x5', '\x34E', '\x1A8', 
		'\x2', '\x12C8', '\x12C6', '\x3', '\x2', '\x2', '\x2', '\x12C8', '\x12C7', 
		'\x3', '\x2', '\x2', '\x2', '\x12C9', '\x12CB', '\x3', '\x2', '\x2', '\x2', 
		'\x12CA', '\x12CC', '\x5', '\x360', '\x1B1', '\x2', '\x12CB', '\x12CA', 
		'\x3', '\x2', '\x2', '\x2', '\x12CB', '\x12CC', '\x3', '\x2', '\x2', '\x2', 
		'\x12CC', '\x34D', '\x3', '\x2', '\x2', '\x2', '\x12CD', '\x12CE', '\a', 
		'\x218', '\x2', '\x2', '\x12CE', '\x12CF', '\x5', '\x44', '#', '\x2', 
		'\x12CF', '\x34F', '\x3', '\x2', '\x2', '\x2', '\x12D0', '\x12D1', '\a', 
		'\x236', '\x2', '\x2', '\x12D1', '\x12D2', '\a', '\x163', '\x2', '\x2', 
		'\x12D2', '\x12D5', '\t', '>', '\x2', '\x2', '\x12D3', '\x12D6', '\x5', 
		'\x352', '\x1AA', '\x2', '\x12D4', '\x12D6', '\a', 'y', '\x2', '\x2', 
		'\x12D5', '\x12D3', '\x3', '\x2', '\x2', '\x2', '\x12D5', '\x12D4', '\x3', 
		'\x2', '\x2', '\x2', '\x12D6', '\x351', '\x3', '\x2', '\x2', '\x2', '\x12D7', 
		'\x12D8', '\a', '\x24D', '\x2', '\x2', '\x12D8', '\x12D9', '\x5', '\x16A', 
		'\xB6', '\x2', '\x12D9', '\x12DA', '\a', '\x24E', '\x2', '\x2', '\x12DA', 
		'\x353', '\x3', '\x2', '\x2', '\x2', '\x12DB', '\x12DD', '\a', '\x144', 
		'\x2', '\x2', '\x12DC', '\x12DB', '\x3', '\x2', '\x2', '\x2', '\x12DC', 
		'\x12DD', '\x3', '\x2', '\x2', '\x2', '\x12DD', '\x12DE', '\x3', '\x2', 
		'\x2', '\x2', '\x12DE', '\x12DF', '\a', '\xC0', '\x2', '\x2', '\x12DF', 
		'\x355', '\x3', '\x2', '\x2', '\x2', '\x12E0', '\x12E1', '\x5', '\x3F6', 
		'\x1FC', '\x2', '\x12E1', '\x357', '\x3', '\x2', '\x2', '\x2', '\x12E2', 
		'\x12E5', '\a', '\x236', '\x2', '\x2', '\x12E3', '\x12E6', '\x5', '\x3FC', 
		'\x1FF', '\x2', '\x12E4', '\x12E6', '\x5', '\x3FE', '\x200', '\x2', '\x12E5', 
		'\x12E3', '\x3', '\x2', '\x2', '\x2', '\x12E5', '\x12E4', '\x3', '\x2', 
		'\x2', '\x2', '\x12E6', '\x12E8', '\x3', '\x2', '\x2', '\x2', '\x12E7', 
		'\x12E9', '\x5', '\x3A8', '\x1D5', '\x2', '\x12E8', '\x12E7', '\x3', '\x2', 
		'\x2', '\x2', '\x12E8', '\x12E9', '\x3', '\x2', '\x2', '\x2', '\x12E9', 
		'\x359', '\x3', '\x2', '\x2', '\x2', '\x12EA', '\x12EB', '\a', '\x24D', 
		'\x2', '\x2', '\x12EB', '\x12F0', '\x5', '\x35C', '\x1AF', '\x2', '\x12EC', 
		'\x12ED', '\a', '\x24F', '\x2', '\x2', '\x12ED', '\x12EF', '\x5', '\x35C', 
		'\x1AF', '\x2', '\x12EE', '\x12EC', '\x3', '\x2', '\x2', '\x2', '\x12EF', 
		'\x12F2', '\x3', '\x2', '\x2', '\x2', '\x12F0', '\x12EE', '\x3', '\x2', 
		'\x2', '\x2', '\x12F0', '\x12F1', '\x3', '\x2', '\x2', '\x2', '\x12F1', 
		'\x12F3', '\x3', '\x2', '\x2', '\x2', '\x12F2', '\x12F0', '\x3', '\x2', 
		'\x2', '\x2', '\x12F3', '\x12F4', '\a', '\x24E', '\x2', '\x2', '\x12F4', 
		'\x35B', '\x3', '\x2', '\x2', '\x2', '\x12F5', '\x12F8', '\x5', '\x35E', 
		'\x1B0', '\x2', '\x12F6', '\x12F8', '\x5', '\x366', '\x1B4', '\x2', '\x12F7', 
		'\x12F5', '\x3', '\x2', '\x2', '\x2', '\x12F7', '\x12F6', '\x3', '\x2', 
		'\x2', '\x2', '\x12F8', '\x35D', '\x3', '\x2', '\x2', '\x2', '\x12F9', 
		'\x12FD', '\x5', '\x44', '#', '\x2', '\x12FA', '\x12FC', '\x5', '\x36A', 
		'\x1B6', '\x2', '\x12FB', '\x12FA', '\x3', '\x2', '\x2', '\x2', '\x12FC', 
		'\x12FF', '\x3', '\x2', '\x2', '\x2', '\x12FD', '\x12FB', '\x3', '\x2', 
		'\x2', '\x2', '\x12FD', '\x12FE', '\x3', '\x2', '\x2', '\x2', '\x12FE', 
		'\x35F', '\x3', '\x2', '\x2', '\x2', '\x12FF', '\x12FD', '\x3', '\x2', 
		'\x2', '\x2', '\x1300', '\x1301', '\a', '\x24D', '\x2', '\x2', '\x1301', 
		'\x1306', '\x5', '\x362', '\x1B2', '\x2', '\x1302', '\x1303', '\a', '\x24F', 
		'\x2', '\x2', '\x1303', '\x1305', '\x5', '\x362', '\x1B2', '\x2', '\x1304', 
		'\x1302', '\x3', '\x2', '\x2', '\x2', '\x1305', '\x1308', '\x3', '\x2', 
		'\x2', '\x2', '\x1306', '\x1304', '\x3', '\x2', '\x2', '\x2', '\x1306', 
		'\x1307', '\x3', '\x2', '\x2', '\x2', '\x1307', '\x1309', '\x3', '\x2', 
		'\x2', '\x2', '\x1308', '\x1306', '\x3', '\x2', '\x2', '\x2', '\x1309', 
		'\x130A', '\a', '\x24E', '\x2', '\x2', '\x130A', '\x361', '\x3', '\x2', 
		'\x2', '\x2', '\x130B', '\x130E', '\x5', '\x364', '\x1B3', '\x2', '\x130C', 
		'\x130E', '\x5', '\x366', '\x1B4', '\x2', '\x130D', '\x130B', '\x3', '\x2', 
		'\x2', '\x2', '\x130D', '\x130C', '\x3', '\x2', '\x2', '\x2', '\x130E', 
		'\x363', '\x3', '\x2', '\x2', '\x2', '\x130F', '\x1311', '\x5', '\x42', 
		'\"', '\x2', '\x1310', '\x1312', '\x5', '\x36A', '\x1B6', '\x2', '\x1311', 
		'\x1310', '\x3', '\x2', '\x2', '\x2', '\x1312', '\x1313', '\x3', '\x2', 
		'\x2', '\x2', '\x1313', '\x1311', '\x3', '\x2', '\x2', '\x2', '\x1313', 
		'\x1314', '\x3', '\x2', '\x2', '\x2', '\x1314', '\x365', '\x3', '\x2', 
		'\x2', '\x2', '\x1315', '\x1317', '\x5', '\x3A8', '\x1D5', '\x2', '\x1316', 
		'\x1315', '\x3', '\x2', '\x2', '\x2', '\x1316', '\x1317', '\x3', '\x2', 
		'\x2', '\x2', '\x1317', '\x131C', '\x3', '\x2', '\x2', '\x2', '\x1318', 
		'\x131D', '\x5', '\x3AC', '\x1D7', '\x2', '\x1319', '\x131D', '\x5', '\x3AE', 
		'\x1D8', '\x2', '\x131A', '\x131D', '\x5', '\x3B4', '\x1DB', '\x2', '\x131B', 
		'\x131D', '\x5', '\x3B0', '\x1D9', '\x2', '\x131C', '\x1318', '\x3', '\x2', 
		'\x2', '\x2', '\x131C', '\x1319', '\x3', '\x2', '\x2', '\x2', '\x131C', 
		'\x131A', '\x3', '\x2', '\x2', '\x2', '\x131C', '\x131B', '\x3', '\x2', 
		'\x2', '\x2', '\x131D', '\x131F', '\x3', '\x2', '\x2', '\x2', '\x131E', 
		'\x1320', '\x5', '\x36C', '\x1B7', '\x2', '\x131F', '\x131E', '\x3', '\x2', 
		'\x2', '\x2', '\x131F', '\x1320', '\x3', '\x2', '\x2', '\x2', '\x1320', 
		'\x367', '\x3', '\x2', '\x2', '\x2', '\x1321', '\x1324', '\a', '\x24D', 
		'\x2', '\x2', '\x1322', '\x1325', '\x5', '\x17E', '\xC0', '\x2', '\x1323', 
		'\x1325', '\x5', '\x17C', '\xBF', '\x2', '\x1324', '\x1322', '\x3', '\x2', 
		'\x2', '\x2', '\x1324', '\x1323', '\x3', '\x2', '\x2', '\x2', '\x1325', 
		'\x132D', '\x3', '\x2', '\x2', '\x2', '\x1326', '\x1329', '\a', '\x24F', 
		'\x2', '\x2', '\x1327', '\x132A', '\x5', '\x17E', '\xC0', '\x2', '\x1328', 
		'\x132A', '\x5', '\x17C', '\xBF', '\x2', '\x1329', '\x1327', '\x3', '\x2', 
		'\x2', '\x2', '\x1329', '\x1328', '\x3', '\x2', '\x2', '\x2', '\x132A', 
		'\x132C', '\x3', '\x2', '\x2', '\x2', '\x132B', '\x1326', '\x3', '\x2', 
		'\x2', '\x2', '\x132C', '\x132F', '\x3', '\x2', '\x2', '\x2', '\x132D', 
		'\x132B', '\x3', '\x2', '\x2', '\x2', '\x132D', '\x132E', '\x3', '\x2', 
		'\x2', '\x2', '\x132E', '\x1330', '\x3', '\x2', '\x2', '\x2', '\x132F', 
		'\x132D', '\x3', '\x2', '\x2', '\x2', '\x1330', '\x1331', '\a', '\x24E', 
		'\x2', '\x2', '\x1331', '\x369', '\x3', '\x2', '\x2', '\x2', '\x1332', 
		'\x1334', '\x5', '\x3A8', '\x1D5', '\x2', '\x1333', '\x1332', '\x3', '\x2', 
		'\x2', '\x2', '\x1333', '\x1334', '\x3', '\x2', '\x2', '\x2', '\x1334', 
		'\x133A', '\x3', '\x2', '\x2', '\x2', '\x1335', '\x133B', '\x5', '\x3AA', 
		'\x1D6', '\x2', '\x1336', '\x133B', '\x5', '\x3AC', '\x1D7', '\x2', '\x1337', 
		'\x133B', '\x5', '\x3AE', '\x1D8', '\x2', '\x1338', '\x133B', '\x5', '\x3B4', 
		'\x1DB', '\x2', '\x1339', '\x133B', '\x5', '\x3B0', '\x1D9', '\x2', '\x133A', 
		'\x1335', '\x3', '\x2', '\x2', '\x2', '\x133A', '\x1336', '\x3', '\x2', 
		'\x2', '\x2', '\x133A', '\x1337', '\x3', '\x2', '\x2', '\x2', '\x133A', 
		'\x1338', '\x3', '\x2', '\x2', '\x2', '\x133A', '\x1339', '\x3', '\x2', 
		'\x2', '\x2', '\x133B', '\x133D', '\x3', '\x2', '\x2', '\x2', '\x133C', 
		'\x133E', '\x5', '\x36C', '\x1B7', '\x2', '\x133D', '\x133C', '\x3', '\x2', 
		'\x2', '\x2', '\x133D', '\x133E', '\x3', '\x2', '\x2', '\x2', '\x133E', 
		'\x36B', '\x3', '\x2', '\x2', '\x2', '\x133F', '\x1347', '\x5', '\x36E', 
		'\x1B8', '\x2', '\x1340', '\x1347', '\x5', '\x370', '\x1B9', '\x2', '\x1341', 
		'\x1347', '\x5', '\x374', '\x1BB', '\x2', '\x1342', '\x1347', '\x5', '\x376', 
		'\x1BC', '\x2', '\x1343', '\x1347', '\x5', '\x372', '\x1BA', '\x2', '\x1344', 
		'\x1347', '\x5', '\x3A2', '\x1D2', '\x2', '\x1345', '\x1347', '\x5', '\x3A4', 
		'\x1D3', '\x2', '\x1346', '\x133F', '\x3', '\x2', '\x2', '\x2', '\x1346', 
		'\x1340', '\x3', '\x2', '\x2', '\x2', '\x1346', '\x1341', '\x3', '\x2', 
		'\x2', '\x2', '\x1346', '\x1342', '\x3', '\x2', '\x2', '\x2', '\x1346', 
		'\x1343', '\x3', '\x2', '\x2', '\x2', '\x1346', '\x1344', '\x3', '\x2', 
		'\x2', '\x2', '\x1346', '\x1345', '\x3', '\x2', '\x2', '\x2', '\x1347', 
		'\x1348', '\x3', '\x2', '\x2', '\x2', '\x1348', '\x1346', '\x3', '\x2', 
		'\x2', '\x2', '\x1348', '\x1349', '\x3', '\x2', '\x2', '\x2', '\x1349', 
		'\x36D', '\x3', '\x2', '\x2', '\x2', '\x134A', '\x134C', '\a', '\x15C', 
		'\x2', '\x2', '\x134B', '\x134A', '\x3', '\x2', '\x2', '\x2', '\x134B', 
		'\x134C', '\x3', '\x2', '\x2', '\x2', '\x134C', '\x134D', '\x3', '\x2', 
		'\x2', '\x2', '\x134D', '\x134E', '\a', 'z', '\x2', '\x2', '\x134E', '\x36F', 
		'\x3', '\x2', '\x2', '\x2', '\x134F', '\x1350', '\a', '\xE9', '\x2', '\x2', 
		'\x1350', '\x1351', '\t', '\x1D', '\x2', '\x2', '\x1351', '\x371', '\x3', 
		'\x2', '\x2', '\x2', '\x1352', '\x1353', '\t', '<', '\x2', '\x2', '\x1353', 
		'\x373', '\x3', '\x2', '\x2', '\x2', '\x1354', '\x1355', '\t', '?', '\x2', 
		'\x2', '\x1355', '\x375', '\x3', '\x2', '\x2', '\x2', '\x1356', '\x1357', 
		'\a', '\x225', '\x2', '\x2', '\x1357', '\x135A', '\a', '\xE2', '\x2', 
		'\x2', '\x1358', '\x135B', '\x5', '\x378', '\x1BD', '\x2', '\x1359', '\x135B', 
		'\x5', '\x44', '#', '\x2', '\x135A', '\x1358', '\x3', '\x2', '\x2', '\x2', 
		'\x135A', '\x1359', '\x3', '\x2', '\x2', '\x2', '\x135B', '\x377', '\x3', 
		'\x2', '\x2', '\x2', '\x135C', '\x1363', '\x5', '\x37E', '\x1C0', '\x2', 
		'\x135D', '\x1363', '\x5', '\x380', '\x1C1', '\x2', '\x135E', '\x1363', 
		'\x5', '\x382', '\x1C2', '\x2', '\x135F', '\x1363', '\x5', '\x61E', '\x310', 
		'\x2', '\x1360', '\x1363', '\x5', '\x37A', '\x1BE', '\x2', '\x1361', '\x1363', 
		'\x5', '\x3A0', '\x1D1', '\x2', '\x1362', '\x135C', '\x3', '\x2', '\x2', 
		'\x2', '\x1362', '\x135D', '\x3', '\x2', '\x2', '\x2', '\x1362', '\x135E', 
		'\x3', '\x2', '\x2', '\x2', '\x1362', '\x135F', '\x3', '\x2', '\x2', '\x2', 
		'\x1362', '\x1360', '\x3', '\x2', '\x2', '\x2', '\x1362', '\x1361', '\x3', 
		'\x2', '\x2', '\x2', '\x1363', '\x1364', '\x3', '\x2', '\x2', '\x2', '\x1364', 
		'\x1362', '\x3', '\x2', '\x2', '\x2', '\x1364', '\x1365', '\x3', '\x2', 
		'\x2', '\x2', '\x1365', '\x379', '\x3', '\x2', '\x2', '\x2', '\x1366', 
		'\x1369', '\x5', '\x37C', '\x1BF', '\x2', '\x1367', '\x1369', '\x5', '\x2DC', 
		'\x16F', '\x2', '\x1368', '\x1366', '\x3', '\x2', '\x2', '\x2', '\x1368', 
		'\x1367', '\x3', '\x2', '\x2', '\x2', '\x1369', '\x37B', '\x3', '\x2', 
		'\x2', '\x2', '\x136A', '\x136B', '\a', 'T', '\x2', '\x2', '\x136B', '\x136E', 
		'\a', '\x247', '\x2', '\x2', '\x136C', '\x136E', '\a', '\x147', '\x2', 
		'\x2', '\x136D', '\x136A', '\x3', '\x2', '\x2', '\x2', '\x136D', '\x136C', 
		'\x3', '\x2', '\x2', '\x2', '\x136E', '\x37D', '\x3', '\x2', '\x2', '\x2', 
		'\x136F', '\x1370', '\t', '@', '\x2', '\x2', '\x1370', '\x37F', '\x3', 
		'\x2', '\x2', '\x2', '\x1371', '\x1373', '\a', '\x1FF', '\x2', '\x2', 
		'\x1372', '\x1374', '\a', '\x1DA', '\x2', '\x2', '\x1373', '\x1372', '\x3', 
		'\x2', '\x2', '\x2', '\x1373', '\x1374', '\x3', '\x2', '\x2', '\x2', '\x1374', 
		'\x1377', '\x3', '\x2', '\x2', '\x2', '\x1375', '\x1378', '\a', 'y', '\x2', 
		'\x2', '\x1376', '\x1378', '\x5', '\\', '/', '\x2', '\x1377', '\x1375', 
		'\x3', '\x2', '\x2', '\x2', '\x1377', '\x1376', '\x3', '\x2', '\x2', '\x2', 
		'\x1378', '\x381', '\x3', '\x2', '\x2', '\x2', '\x1379', '\x137A', '\t', 
		'\x41', '\x2', '\x2', '\x137A', '\x383', '\x3', '\x2', '\x2', '\x2', '\x137B', 
		'\x137C', '\a', '\x1ED', '\x2', '\x2', '\x137C', '\x137E', '\a', '\x24D', 
		'\x2', '\x2', '\x137D', '\x137F', '\x5', '\x386', '\x1C4', '\x2', '\x137E', 
		'\x137D', '\x3', '\x2', '\x2', '\x2', '\x137F', '\x1380', '\x3', '\x2', 
		'\x2', '\x2', '\x1380', '\x137E', '\x3', '\x2', '\x2', '\x2', '\x1380', 
		'\x1381', '\x3', '\x2', '\x2', '\x2', '\x1381', '\x1382', '\x3', '\x2', 
		'\x2', '\x2', '\x1382', '\x1383', '\a', '\x24E', '\x2', '\x2', '\x1383', 
		'\x385', '\x3', '\x2', '\x2', '\x2', '\x1384', '\x1391', '\x5', '\x38C', 
		'\x1C7', '\x2', '\x1385', '\x1391', '\x5', '\x390', '\x1C9', '\x2', '\x1386', 
		'\x1391', '\x5', '\x394', '\x1CB', '\x2', '\x1387', '\x1391', '\x5', '\x396', 
		'\x1CC', '\x2', '\x1388', '\x1391', '\x5', '\x398', '\x1CD', '\x2', '\x1389', 
		'\x1391', '\x5', '\x38E', '\x1C8', '\x2', '\x138A', '\x1391', '\x5', '\x392', 
		'\x1CA', '\x2', '\x138B', '\x1391', '\x5', '\x39A', '\x1CE', '\x2', '\x138C', 
		'\x1391', '\x5', '\x39C', '\x1CF', '\x2', '\x138D', '\x1391', '\x5', '\x39E', 
		'\x1D0', '\x2', '\x138E', '\x1391', '\x5', '\x388', '\x1C5', '\x2', '\x138F', 
		'\x1391', '\x5', '\x38A', '\x1C6', '\x2', '\x1390', '\x1384', '\x3', '\x2', 
		'\x2', '\x2', '\x1390', '\x1385', '\x3', '\x2', '\x2', '\x2', '\x1390', 
		'\x1386', '\x3', '\x2', '\x2', '\x2', '\x1390', '\x1387', '\x3', '\x2', 
		'\x2', '\x2', '\x1390', '\x1388', '\x3', '\x2', '\x2', '\x2', '\x1390', 
		'\x1389', '\x3', '\x2', '\x2', '\x2', '\x1390', '\x138A', '\x3', '\x2', 
		'\x2', '\x2', '\x1390', '\x138B', '\x3', '\x2', '\x2', '\x2', '\x1390', 
		'\x138C', '\x3', '\x2', '\x2', '\x2', '\x1390', '\x138D', '\x3', '\x2', 
		'\x2', '\x2', '\x1390', '\x138E', '\x3', '\x2', '\x2', '\x2', '\x1390', 
		'\x138F', '\x3', '\x2', '\x2', '\x2', '\x1391', '\x387', '\x3', '\x2', 
		'\x2', '\x2', '\x1392', '\x1395', '\a', '\x124', '\x2', '\x2', '\x1393', 
		'\x1396', '\a', '\x21B', '\x2', '\x2', '\x1394', '\x1396', '\x5', '\x3A6', 
		'\x1D4', '\x2', '\x1395', '\x1393', '\x3', '\x2', '\x2', '\x2', '\x1395', 
		'\x1394', '\x3', '\x2', '\x2', '\x2', '\x1396', '\x389', '\x3', '\x2', 
		'\x2', '\x2', '\x1397', '\x1398', '\a', '\x9B', '\x2', '\x2', '\x1398', 
		'\x38B', '\x3', '\x2', '\x2', '\x2', '\x1399', '\x139A', '\t', '\x42', 
		'\x2', '\x2', '\x139A', '\x139B', '\x5', '\x3A6', '\x1D4', '\x2', '\x139B', 
		'\x38D', '\x3', '\x2', '\x2', '\x2', '\x139C', '\x13A1', '\a', '\x16E', 
		'\x2', '\x2', '\x139D', '\x13A2', '\a', '\x160', '\x2', '\x2', '\x139E', 
		'\x13A0', '\x5', '\x3A6', '\x1D4', '\x2', '\x139F', '\x139E', '\x3', '\x2', 
		'\x2', '\x2', '\x139F', '\x13A0', '\x3', '\x2', '\x2', '\x2', '\x13A0', 
		'\x13A2', '\x3', '\x2', '\x2', '\x2', '\x13A1', '\x139D', '\x3', '\x2', 
		'\x2', '\x2', '\x13A1', '\x139F', '\x3', '\x2', '\x2', '\x2', '\x13A2', 
		'\x38F', '\x3', '\x2', '\x2', '\x2', '\x13A3', '\x13A4', '\a', '\x12D', 
		'\x2', '\x2', '\x13A4', '\x13A5', '\x5', '&', '\x14', '\x2', '\x13A5', 
		'\x391', '\x3', '\x2', '\x2', '\x2', '\x13A6', '\x13A9', '\a', '\x123', 
		'\x2', '\x2', '\x13A7', '\x13AA', '\a', '\x21B', '\x2', '\x2', '\x13A8', 
		'\x13AA', '\x5', '&', '\x14', '\x2', '\x13A9', '\x13A7', '\x3', '\x2', 
		'\x2', '\x2', '\x13A9', '\x13A8', '\x3', '\x2', '\x2', '\x2', '\x13AA', 
		'\x393', '\x3', '\x2', '\x2', '\x2', '\x13AB', '\x13AC', '\a', '\x186', 
		'\x2', '\x2', '\x13AC', '\x13AD', '\x5', '&', '\x14', '\x2', '\x13AD', 
		'\x395', '\x3', '\x2', '\x2', '\x2', '\x13AE', '\x13AF', '\a', '\xC6', 
		'\x2', '\x2', '\x13AF', '\x13B0', '\x5', '&', '\x14', '\x2', '\x13B0', 
		'\x397', '\x3', '\x2', '\x2', '\x2', '\x13B1', '\x13B2', '\a', '\xC5', 
		'\x2', '\x2', '\x13B2', '\x13B3', '\a', '\xD2', '\x2', '\x2', '\x13B3', 
		'\x13B4', '\x5', '&', '\x14', '\x2', '\x13B4', '\x399', '\x3', '\x2', 
		'\x2', '\x2', '\x13B5', '\x13B6', '\a', '-', '\x2', '\x2', '\x13B6', '\x13B7', 
		'\t', '\x43', '\x2', '\x2', '\x13B7', '\x39B', '\x3', '\x2', '\x2', '\x2', 
		'\x13B8', '\x13B9', '\a', '\xC4', '\x2', '\x2', '\x13B9', '\x13BA', '\t', 
		'\x44', '\x2', '\x2', '\x13BA', '\x39D', '\x3', '\x2', '\x2', '\x2', '\x13BB', 
		'\x13BC', '\a', ';', '\x2', '\x2', '\x13BC', '\x13BD', '\t', '\x44', '\x2', 
		'\x2', '\x13BD', '\x39F', '\x3', '\x2', '\x2', '\x2', '\x13BE', '\x13BF', 
		'\a', 'V', '\x2', '\x2', '\x13BF', '\x13C0', '\a', '\x1EC', '\x2', '\x2', 
		'\x13C0', '\x3A1', '\x3', '\x2', '\x2', '\x2', '\x13C1', '\x13C2', '\t', 
		'\x45', '\x2', '\x2', '\x13C2', '\x3A3', '\x3', '\x2', '\x2', '\x2', '\x13C3', 
		'\x13C4', '\a', '\xA7', '\x2', '\x2', '\x13C4', '\x13C5', '\a', '\xF3', 
		'\x2', '\x2', '\x13C5', '\x13C6', '\x5', '\x44', '#', '\x2', '\x13C6', 
		'\x3A5', '\x3', '\x2', '\x2', '\x2', '\x13C7', '\x13C8', '\t', '\x46', 
		'\x2', '\x2', '\x13C8', '\x3A7', '\x3', '\x2', '\x2', '\x2', '\x13C9', 
		'\x13CA', '\a', '[', '\x2', '\x2', '\x13CA', '\x13CB', '\x5', 'N', '(', 
		'\x2', '\x13CB', '\x3A9', '\x3', '\x2', '\x2', '\x2', '\x13CC', '\x13CE', 
		'\a', '\x15C', '\x2', '\x2', '\x13CD', '\x13CC', '\x3', '\x2', '\x2', 
		'\x2', '\x13CD', '\x13CE', '\x3', '\x2', '\x2', '\x2', '\x13CE', '\x13CF', 
		'\x3', '\x2', '\x2', '\x2', '\x13CF', '\x13D0', '\a', '\x160', '\x2', 
		'\x2', '\x13D0', '\x3AB', '\x3', '\x2', '\x2', '\x2', '\x13D1', '\x13D3', 
		'\a', '\x21A', '\x2', '\x2', '\x13D2', '\x13D4', '\x5', '\x368', '\x1B5', 
		'\x2', '\x13D3', '\x13D2', '\x3', '\x2', '\x2', '\x2', '\x13D3', '\x13D4', 
		'\x3', '\x2', '\x2', '\x2', '\x13D4', '\x3AD', '\x3', '\x2', '\x2', '\x2', 
		'\x13D5', '\x13D6', '\a', '\x195', '\x2', '\x2', '\x13D6', '\x13D8', '\a', 
		'\x100', '\x2', '\x2', '\x13D7', '\x13D9', '\x5', '\x368', '\x1B5', '\x2', 
		'\x13D8', '\x13D7', '\x3', '\x2', '\x2', '\x2', '\x13D8', '\x13D9', '\x3', 
		'\x2', '\x2', '\x2', '\x13D9', '\x3AF', '\x3', '\x2', '\x2', '\x2', '\x13DA', 
		'\x13DB', '\a', '@', '\x2', '\x2', '\x13DB', '\x13DC', '\x5', '\x3B2', 
		'\x1DA', '\x2', '\x13DC', '\x3B1', '\x3', '\x2', '\x2', '\x2', '\x13DD', 
		'\x13DE', '\a', '\x24D', '\x2', '\x2', '\x13DE', '\x13DF', '\x5', '\xA0', 
		'Q', '\x2', '\x13DF', '\x13E0', '\a', '\x24E', '\x2', '\x2', '\x13E0', 
		'\x3B3', '\x3', '\x2', '\x2', '\x2', '\x13E1', '\x13E2', '\a', '\xC1', 
		'\x2', '\x2', '\x13E2', '\x13E4', '\a', '\x100', '\x2', '\x2', '\x13E3', 
		'\x13E1', '\x3', '\x2', '\x2', '\x2', '\x13E3', '\x13E4', '\x3', '\x2', 
		'\x2', '\x2', '\x13E4', '\x13E6', '\x3', '\x2', '\x2', '\x2', '\x13E5', 
		'\x13E7', '\x5', '\x368', '\x1B5', '\x2', '\x13E6', '\x13E5', '\x3', '\x2', 
		'\x2', '\x2', '\x13E6', '\x13E7', '\x3', '\x2', '\x2', '\x2', '\x13E7', 
		'\x13E8', '\x3', '\x2', '\x2', '\x2', '\x13E8', '\x13EA', '\x5', '\x3B6', 
		'\x1DC', '\x2', '\x13E9', '\x13EB', '\x5', '\x3B8', '\x1DD', '\x2', '\x13EA', 
		'\x13E9', '\x3', '\x2', '\x2', '\x2', '\x13EA', '\x13EB', '\x3', '\x2', 
		'\x2', '\x2', '\x13EB', '\x3B5', '\x3', '\x2', '\x2', '\x2', '\x13EC', 
		'\x13ED', '\a', '\x1A9', '\x2', '\x2', '\x13ED', '\x13EF', '\x5', '\x44', 
		'#', '\x2', '\x13EE', '\x13F0', '\x5', '\x368', '\x1B5', '\x2', '\x13EF', 
		'\x13EE', '\x3', '\x2', '\x2', '\x2', '\x13EF', '\x13F0', '\x3', '\x2', 
		'\x2', '\x2', '\x13F0', '\x3B7', '\x3', '\x2', '\x2', '\x2', '\x13F1', 
		'\x13F2', '\a', '\x168', '\x2', '\x2', '\x13F2', '\x13F6', '\a', '}', 
		'\x2', '\x2', '\x13F3', '\x13F7', '\a', '\x38', '\x2', '\x2', '\x13F4', 
		'\x13F5', '\a', '\x1DA', '\x2', '\x2', '\x13F5', '\x13F7', '\a', '\x160', 
		'\x2', '\x2', '\x13F6', '\x13F3', '\x3', '\x2', '\x2', '\x2', '\x13F6', 
		'\x13F4', '\x3', '\x2', '\x2', '\x2', '\x13F7', '\x3B9', '\x3', '\x2', 
		'\x2', '\x2', '\x13F8', '\x13F9', '\a', '\x210', '\x2', '\x2', '\x13F9', 
		'\x13FE', '\x5', '\x44', '#', '\x2', '\x13FA', '\x13FF', '\x5', '\x3BC', 
		'\x1DF', '\x2', '\x13FB', '\x13FF', '\x5', '\x3BE', '\x1E0', '\x2', '\x13FC', 
		'\x13FF', '\x5', '\x3C0', '\x1E1', '\x2', '\x13FD', '\x13FF', '\x5', '\x3C2', 
		'\x1E2', '\x2', '\x13FE', '\x13FA', '\x3', '\x2', '\x2', '\x2', '\x13FE', 
		'\x13FB', '\x3', '\x2', '\x2', '\x2', '\x13FE', '\x13FC', '\x3', '\x2', 
		'\x2', '\x2', '\x13FE', '\x13FD', '\x3', '\x2', '\x2', '\x2', '\x13FF', 
		'\x3BB', '\x3', '\x2', '\x2', '\x2', '\x1400', '\x1401', '\x5', '\x3DE', 
		'\x1F0', '\x2', '\x1401', '\x1403', '\x5', '\x3E0', '\x1F1', '\x2', '\x1402', 
		'\x1404', '\x5', '\x3D2', '\x1EA', '\x2', '\x1403', '\x1402', '\x3', '\x2', 
		'\x2', '\x2', '\x1403', '\x1404', '\x3', '\x2', '\x2', '\x2', '\x1404', 
		'\x1407', '\x3', '\x2', '\x2', '\x2', '\x1405', '\x1408', '\x5', '\x3CA', 
		'\x1E6', '\x2', '\x1406', '\x1408', '\x5', '\x590', '\x2C9', '\x2', '\x1407', 
		'\x1405', '\x3', '\x2', '\x2', '\x2', '\x1407', '\x1406', '\x3', '\x2', 
		'\x2', '\x2', '\x1408', '\x3BD', '\x3', '\x2', '\x2', '\x2', '\x1409', 
		'\x140A', '\x5', '\x3DE', '\x1F0', '\x2', '\x140A', '\x140D', '\x5', '\x3E0', 
		'\x1F1', '\x2', '\x140B', '\x140E', '\x5', '\x3CA', '\x1E6', '\x2', '\x140C', 
		'\x140E', '\x5', '\x590', '\x2C9', '\x2', '\x140D', '\x140B', '\x3', '\x2', 
		'\x2', '\x2', '\x140D', '\x140C', '\x3', '\x2', '\x2', '\x2', '\x140E', 
		'\x3BF', '\x3', '\x2', '\x2', '\x2', '\x140F', '\x1410', '\x5', '\x3DE', 
		'\x1F0', '\x2', '\x1410', '\x1412', '\x5', '\x3E0', '\x1F1', '\x2', '\x1411', 
		'\x1413', '\x5', '\x3D2', '\x1EA', '\x2', '\x1412', '\x1411', '\x3', '\x2', 
		'\x2', '\x2', '\x1412', '\x1413', '\x3', '\x2', '\x2', '\x2', '\x1413', 
		'\x1414', '\x3', '\x2', '\x2', '\x2', '\x1414', '\x1415', '\x5', '\x3C4', 
		'\x1E3', '\x2', '\x1415', '\x3C1', '\x3', '\x2', '\x2', '\x2', '\x1416', 
		'\x1419', '\x5', '\x3DE', '\x1F0', '\x2', '\x1417', '\x141A', '\x5', '\x3D6', 
		'\x1EC', '\x2', '\x1418', '\x141A', '\x5', '\x3D8', '\x1ED', '\x2', '\x1419', 
		'\x1417', '\x3', '\x2', '\x2', '\x2', '\x1419', '\x1418', '\x3', '\x2', 
		'\x2', '\x2', '\x141A', '\x141B', '\x3', '\x2', '\x2', '\x2', '\x141B', 
		'\x141E', '\x5', '\x3D4', '\x1EB', '\x2', '\x141C', '\x141F', '\x5', '\x3CA', 
		'\x1E6', '\x2', '\x141D', '\x141F', '\x5', '\x590', '\x2C9', '\x2', '\x141E', 
		'\x141C', '\x3', '\x2', '\x2', '\x2', '\x141E', '\x141D', '\x3', '\x2', 
		'\x2', '\x2', '\x141F', '\x3C3', '\x3', '\x2', '\x2', '\x2', '\x1420', 
		'\x1421', '\a', 'S', '\x2', '\x2', '\x1421', '\x1423', '\a', '\x210', 
		'\x2', '\x2', '\x1422', '\x1424', '\x5', '\x5AE', '\x2D8', '\x2', '\x1423', 
		'\x1422', '\x3', '\x2', '\x2', '\x2', '\x1423', '\x1424', '\x3', '\x2', 
		'\x2', '\x2', '\x1424', '\x1426', '\x3', '\x2', '\x2', '\x2', '\x1425', 
		'\x1427', '\x5', '\x3C6', '\x1E4', '\x2', '\x1426', '\x1425', '\x3', '\x2', 
		'\x2', '\x2', '\x1427', '\x1428', '\x3', '\x2', '\x2', '\x2', '\x1428', 
		'\x1426', '\x3', '\x2', '\x2', '\x2', '\x1428', '\x1429', '\x3', '\x2', 
		'\x2', '\x2', '\x1429', '\x142A', '\x3', '\x2', '\x2', '\x2', '\x142A', 
		'\x142B', '\x5', '\x594', '\x2CB', '\x2', '\x142B', '\x3C5', '\x3', '\x2', 
		'\x2', '\x2', '\x142C', '\x142D', '\x5', '\x3C8', '\x1E5', '\x2', '\x142D', 
		'\x142E', '\a', '\xF7', '\x2', '\x2', '\x142E', '\x142F', '\x5', '\x592', 
		'\x2CA', '\x2', '\x142F', '\x1430', '\x5', '\x3C8', '\x1E5', '\x2', '\x1430', 
		'\x1431', '\a', '\x250', '\x2', '\x2', '\x1431', '\x3C7', '\x3', '\x2', 
		'\x2', '\x2', '\x1432', '\x1433', '\t', 'G', '\x2', '\x2', '\x1433', '\x143D', 
		'\a', '\x1EA', '\x2', '\x2', '\x1434', '\x1439', '\a', '#', '\x2', '\x2', 
		'\x1435', '\x1439', '\a', '\a', '\x2', '\x2', '\x1436', '\x1437', '\a', 
		'\xEF', '\x2', '\x2', '\x1437', '\x1439', '\a', '\x164', '\x2', '\x2', 
		'\x1438', '\x1434', '\x3', '\x2', '\x2', '\x2', '\x1438', '\x1435', '\x3', 
		'\x2', '\x2', '\x2', '\x1438', '\x1436', '\x3', '\x2', '\x2', '\x2', '\x1439', 
		'\x143A', '\x3', '\x2', '\x2', '\x2', '\x143A', '\x143B', '\a', '\x91', 
		'\x2', '\x2', '\x143B', '\x143D', '\a', '\x1BF', '\x2', '\x2', '\x143C', 
		'\x1432', '\x3', '\x2', '\x2', '\x2', '\x143C', '\x1438', '\x3', '\x2', 
		'\x2', '\x2', '\x143D', '\x3C9', '\x3', '\x2', '\x2', '\x2', '\x143E', 
		'\x143F', '\a', '\x37', '\x2', '\x2', '\x143F', '\x1441', '\x5', '\x42', 
		'\"', '\x2', '\x1440', '\x1442', '\x5', '\x3CE', '\x1E8', '\x2', '\x1441', 
		'\x1440', '\x3', '\x2', '\x2', '\x2', '\x1441', '\x1442', '\x3', '\x2', 
		'\x2', '\x2', '\x1442', '\x3CB', '\x3', '\x2', '\x2', '\x2', '\x1443', 
		'\x1444', '\x5', '\xA0', 'Q', '\x2', '\x1444', '\x1445', '\a', '\x25E', 
		'\x2', '\x2', '\x1445', '\x1446', '\x5', '\x42', '\"', '\x2', '\x1446', 
		'\x3CD', '\x3', '\x2', '\x2', '\x2', '\x1447', '\x1448', '\a', '\xF3', 
		'\x2', '\x2', '\x1448', '\x144A', '\x5', 'N', '(', '\x2', '\x1449', '\x144B', 
		'\x5', '\x3D0', '\x1E9', '\x2', '\x144A', '\x1449', '\x3', '\x2', '\x2', 
		'\x2', '\x144A', '\x144B', '\x3', '\x2', '\x2', '\x2', '\x144B', '\x3CF', 
		'\x3', '\x2', '\x2', '\x2', '\x144C', '\x144E', '\a', '\xE5', '\x2', '\x2', 
		'\x144D', '\x144C', '\x3', '\x2', '\x2', '\x2', '\x144D', '\x144E', '\x3', 
		'\x2', '\x2', '\x2', '\x144E', '\x144F', '\x3', '\x2', '\x2', '\x2', '\x144F', 
		'\x1450', '\x5', 'N', '(', '\x2', '\x1450', '\x3D1', '\x3', '\x2', '\x2', 
		'\x2', '\x1451', '\x1452', '\a', '\x233', '\x2', '\x2', '\x1452', '\x1453', 
		'\x5', '\x3B2', '\x1DA', '\x2', '\x1453', '\x3D3', '\x3', '\x2', '\x2', 
		'\x2', '\x1454', '\x1455', '\a', '\x168', '\x2', '\x2', '\x1455', '\x1456', 
		'\t', 'H', '\x2', '\x2', '\x1456', '\x3D5', '\x3', '\x2', '\x2', '\x2', 
		'\x1457', '\x145C', '\x5', '\x3DA', '\x1EE', '\x2', '\x1458', '\x1459', 
		'\a', '\x170', '\x2', '\x2', '\x1459', '\x145B', '\x5', '\x3DA', '\x1EE', 
		'\x2', '\x145A', '\x1458', '\x3', '\x2', '\x2', '\x2', '\x145B', '\x145E', 
		'\x3', '\x2', '\x2', '\x2', '\x145C', '\x145A', '\x3', '\x2', '\x2', '\x2', 
		'\x145C', '\x145D', '\x3', '\x2', '\x2', '\x2', '\x145D', '\x3D7', '\x3', 
		'\x2', '\x2', '\x2', '\x145E', '\x145C', '\x3', '\x2', '\x2', '\x2', '\x145F', 
		'\x1464', '\x5', '\x3DC', '\x1EF', '\x2', '\x1460', '\x1461', '\a', '\x170', 
		'\x2', '\x2', '\x1461', '\x1463', '\x5', '\x3DC', '\x1EF', '\x2', '\x1462', 
		'\x1460', '\x3', '\x2', '\x2', '\x2', '\x1463', '\x1466', '\x3', '\x2', 
		'\x2', '\x2', '\x1464', '\x1462', '\x3', '\x2', '\x2', '\x2', '\x1464', 
		'\x1465', '\x3', '\x2', '\x2', '\x2', '\x1465', '\x3D9', '\x3', '\x2', 
		'\x2', '\x2', '\x1466', '\x1464', '\x3', '\x2', '\x2', '\x2', '\x1467', 
		'\x1478', '\a', '\r', '\x2', '\x2', '\x1468', '\x1478', '\a', '\xF', '\x2', 
		'\x2', '\x1469', '\x146A', '\a', '\x17', '\x2', '\x2', '\x146A', '\x1478', 
		'\a', '\x1EC', '\x2', '\x2', '\x146B', '\x1478', '\a', '\x1B', '\x2', 
		'\x2', '\x146C', '\x1478', '\a', 'M', '\x2', '\x2', '\x146D', '\x1478', 
		'\a', '\x64', '\x2', '\x2', '\x146E', '\x146F', '\a', '\x8C', '\x2', '\x2', 
		'\x146F', '\x1478', '\a', '\x1EC', '\x2', '\x2', '\x1470', '\x1478', '\a', 
		'\x8F', '\x2', '\x2', '\x1471', '\x1478', '\a', '\xCF', '\x2', '\x2', 
		'\x1472', '\x1478', '\a', '\x145', '\x2', '\x2', '\x1473', '\x1478', '\a', 
		'\x1B0', '\x2', '\x2', '\x1474', '\x1478', '\a', '\x1BA', '\x2', '\x2', 
		'\x1475', '\x1478', '\a', '\x213', '\x2', '\x2', '\x1476', '\x1478', '\a', 
		'r', '\x2', '\x2', '\x1477', '\x1467', '\x3', '\x2', '\x2', '\x2', '\x1477', 
		'\x1468', '\x3', '\x2', '\x2', '\x2', '\x1477', '\x1469', '\x3', '\x2', 
		'\x2', '\x2', '\x1477', '\x146B', '\x3', '\x2', '\x2', '\x2', '\x1477', 
		'\x146C', '\x3', '\x2', '\x2', '\x2', '\x1477', '\x146D', '\x3', '\x2', 
		'\x2', '\x2', '\x1477', '\x146E', '\x3', '\x2', '\x2', '\x2', '\x1477', 
		'\x1470', '\x3', '\x2', '\x2', '\x2', '\x1477', '\x1471', '\x3', '\x2', 
		'\x2', '\x2', '\x1477', '\x1472', '\x3', '\x2', '\x2', '\x2', '\x1477', 
		'\x1473', '\x3', '\x2', '\x2', '\x2', '\x1477', '\x1474', '\x3', '\x2', 
		'\x2', '\x2', '\x1477', '\x1475', '\x3', '\x2', '\x2', '\x2', '\x1477', 
		'\x1476', '\x3', '\x2', '\x2', '\x2', '\x1478', '\x3DB', '\x3', '\x2', 
		'\x2', '\x2', '\x1479', '\x147A', '\t', 'I', '\x2', '\x2', '\x147A', '\x3DD', 
		'\x3', '\x2', '\x2', '\x2', '\x147B', '\x1481', '\a', '#', '\x2', '\x2', 
		'\x147C', '\x1481', '\a', '\a', '\x2', '\x2', '\x147D', '\x147E', '\a', 
		'\xEF', '\x2', '\x2', '\x147E', '\x1481', '\a', '\x164', '\x2', '\x2', 
		'\x147F', '\x1481', '\a', '\xBE', '\x2', '\x2', '\x1480', '\x147B', '\x3', 
		'\x2', '\x2', '\x2', '\x1480', '\x147C', '\x3', '\x2', '\x2', '\x2', '\x1480', 
		'\x147D', '\x3', '\x2', '\x2', '\x2', '\x1480', '\x147F', '\x3', '\x2', 
		'\x2', '\x2', '\x1481', '\x3DF', '\x3', '\x2', '\x2', '\x2', '\x1482', 
		'\x1483', '\x5', '\x3E2', '\x1F2', '\x2', '\x1483', '\x1485', '\x5', '\x3E8', 
		'\x1F5', '\x2', '\x1484', '\x1486', '\x5', '\x3EC', '\x1F7', '\x2', '\x1485', 
		'\x1484', '\x3', '\x2', '\x2', '\x2', '\x1485', '\x1486', '\x3', '\x2', 
		'\x2', '\x2', '\x1486', '\x1488', '\x3', '\x2', '\x2', '\x2', '\x1487', 
		'\x1489', '\x5', '\x3F0', '\x1F9', '\x2', '\x1488', '\x1487', '\x3', '\x2', 
		'\x2', '\x2', '\x1488', '\x1489', '\x3', '\x2', '\x2', '\x2', '\x1489', 
		'\x3E1', '\x3', '\x2', '\x2', '\x2', '\x148A', '\x148F', '\x5', '\x3E4', 
		'\x1F3', '\x2', '\x148B', '\x148C', '\a', '\x170', '\x2', '\x2', '\x148C', 
		'\x148E', '\x5', '\x3E4', '\x1F3', '\x2', '\x148D', '\x148B', '\x3', '\x2', 
		'\x2', '\x2', '\x148E', '\x1491', '\x3', '\x2', '\x2', '\x2', '\x148F', 
		'\x148D', '\x3', '\x2', '\x2', '\x2', '\x148F', '\x1490', '\x3', '\x2', 
		'\x2', '\x2', '\x1490', '\x3E3', '\x3', '\x2', '\x2', '\x2', '\x1491', 
		'\x148F', '\x3', '\x2', '\x2', '\x2', '\x1492', '\x1494', '\t', 'J', '\x2', 
		'\x2', '\x1493', '\x1495', '\x5', '\x3E6', '\x1F4', '\x2', '\x1494', '\x1493', 
		'\x3', '\x2', '\x2', '\x2', '\x1494', '\x1495', '\x3', '\x2', '\x2', '\x2', 
		'\x1495', '\x3E5', '\x3', '\x2', '\x2', '\x2', '\x1496', '\x1497', '\a', 
		'\x164', '\x2', '\x2', '\x1497', '\x1498', '\x5', '\x17A', '\xBE', '\x2', 
		'\x1498', '\x3E7', '\x3', '\x2', '\x2', '\x2', '\x1499', '\x149E', '\a', 
		'\x168', '\x2', '\x2', '\x149A', '\x149B', '\x5', '\x3EA', '\x1F6', '\x2', 
		'\x149B', '\x149C', '\x5', '\x44', '#', '\x2', '\x149C', '\x149F', '\x3', 
		'\x2', '\x2', '\x2', '\x149D', '\x149F', '\x5', '\x44', '#', '\x2', '\x149E', 
		'\x149A', '\x3', '\x2', '\x2', '\x2', '\x149E', '\x149D', '\x3', '\x2', 
		'\x2', '\x2', '\x149F', '\x3E9', '\x3', '\x2', '\x2', '\x2', '\x14A0', 
		'\x14A1', '\a', '\x13F', '\x2', '\x2', '\x14A1', '\x14A2', '\a', '\x1FD', 
		'\x2', '\x2', '\x14A2', '\x14A3', '\x5', '\\', '/', '\x2', '\x14A3', '\x14A4', 
		'\a', '\x164', '\x2', '\x2', '\x14A4', '\x3EB', '\x3', '\x2', '\x2', '\x2', 
		'\x14A5', '\x14A7', '\a', '\x1AA', '\x2', '\x2', '\x14A6', '\x14A8', '\x5', 
		'\x3EE', '\x1F8', '\x2', '\x14A7', '\x14A6', '\x3', '\x2', '\x2', '\x2', 
		'\x14A8', '\x14A9', '\x3', '\x2', '\x2', '\x2', '\x14A9', '\x14A7', '\x3', 
		'\x2', '\x2', '\x2', '\x14A9', '\x14AA', '\x3', '\x2', '\x2', '\x2', '\x14AA', 
		'\x3ED', '\x3', '\x2', '\x2', '\x2', '\x14AB', '\x14AD', '\t', 'K', '\x2', 
		'\x2', '\x14AC', '\x14AE', '\a', '\x15', '\x2', '\x2', '\x14AD', '\x14AC', 
		'\x3', '\x2', '\x2', '\x2', '\x14AD', '\x14AE', '\x3', '\x2', '\x2', '\x2', 
		'\x14AE', '\x14AF', '\x3', '\x2', '\x2', '\x2', '\x14AF', '\x14B0', '\x5', 
		'N', '(', '\x2', '\x14B0', '\x3EF', '\x3', '\x2', '\x2', '\x2', '\x14B1', 
		'\x14B2', '\a', '\xBE', '\x2', '\x2', '\x14B2', '\x14B3', '\a', '\x91', 
		'\x2', '\x2', '\x14B3', '\x14B4', '\a', '\x1BF', '\x2', '\x2', '\x14B4', 
		'\x3F1', '\x3', '\x2', '\x2', '\x2', '\x14B5', '\x14B6', '\a', '\x1B7', 
		'\x2', '\x2', '\x14B6', '\x14B9', '\x5', '\x16A', '\xB6', '\x2', '\x14B7', 
		'\x14BA', '\x5', '\x42A', '\x216', '\x2', '\x14B8', '\x14BA', '\x5', '\x4FE', 
		'\x280', '\x2', '\x14B9', '\x14B7', '\x3', '\x2', '\x2', '\x2', '\x14B9', 
		'\x14B8', '\x3', '\x2', '\x2', '\x2', '\x14BA', '\x3F3', '\x3', '\x2', 
		'\x2', '\x2', '\x14BB', '\x14BC', '\a', '\x169', '\x2', '\x2', '\x14BC', 
		'\x14BD', '\a', '\x24D', '\x2', '\x2', '\x14BD', '\x14BE', '\x5', '\x468', 
		'\x235', '\x2', '\x14BE', '\x14BF', '\a', '\x24E', '\x2', '\x2', '\x14BF', 
		'\x3F5', '\x3', '\x2', '\x2', '\x2', '\x14C0', '\x14C2', '\x5', '\x416', 
		'\x20C', '\x2', '\x14C1', '\x14C0', '\x3', '\x2', '\x2', '\x2', '\x14C1', 
		'\x14C2', '\x3', '\x2', '\x2', '\x2', '\x14C2', '\x14C3', '\x3', '\x2', 
		'\x2', '\x2', '\x14C3', '\x14C9', '\x5', '\x3F8', '\x1FD', '\x2', '\x14C4', 
		'\x14C5', '\x5', '\x3FA', '\x1FE', '\x2', '\x14C5', '\x14C6', '\x5', '\x3F8', 
		'\x1FD', '\x2', '\x14C6', '\x14C8', '\x3', '\x2', '\x2', '\x2', '\x14C7', 
		'\x14C4', '\x3', '\x2', '\x2', '\x2', '\x14C8', '\x14CB', '\x3', '\x2', 
		'\x2', '\x2', '\x14C9', '\x14C7', '\x3', '\x2', '\x2', '\x2', '\x14C9', 
		'\x14CA', '\x3', '\x2', '\x2', '\x2', '\x14CA', '\x14D4', '\x3', '\x2', 
		'\x2', '\x2', '\x14CB', '\x14C9', '\x3', '\x2', '\x2', '\x2', '\x14CC', 
		'\x14CE', '\x5', '\x404', '\x203', '\x2', '\x14CD', '\x14CF', '\x5', '\x40E', 
		'\x208', '\x2', '\x14CE', '\x14CD', '\x3', '\x2', '\x2', '\x2', '\x14CE', 
		'\x14CF', '\x3', '\x2', '\x2', '\x2', '\x14CF', '\x14D5', '\x3', '\x2', 
		'\x2', '\x2', '\x14D0', '\x14D2', '\x5', '\x40E', '\x208', '\x2', '\x14D1', 
		'\x14D3', '\x5', '\x404', '\x203', '\x2', '\x14D2', '\x14D1', '\x3', '\x2', 
		'\x2', '\x2', '\x14D2', '\x14D3', '\x3', '\x2', '\x2', '\x2', '\x14D3', 
		'\x14D5', '\x3', '\x2', '\x2', '\x2', '\x14D4', '\x14CC', '\x3', '\x2', 
		'\x2', '\x2', '\x14D4', '\x14D0', '\x3', '\x2', '\x2', '\x2', '\x14D4', 
		'\x14D5', '\x3', '\x2', '\x2', '\x2', '\x14D5', '\x14D7', '\x3', '\x2', 
		'\x2', '\x2', '\x14D6', '\x14D8', '\x5', '\x358', '\x1AD', '\x2', '\x14D7', 
		'\x14D6', '\x3', '\x2', '\x2', '\x2', '\x14D7', '\x14D8', '\x3', '\x2', 
		'\x2', '\x2', '\x14D8', '\x3F7', '\x3', '\x2', '\x2', '\x2', '\x14D9', 
		'\x14DF', '\x5', '\x426', '\x214', '\x2', '\x14DA', '\x14DB', '\a', '\x24D', 
		'\x2', '\x2', '\x14DB', '\x14DC', '\x5', '\x3F6', '\x1FC', '\x2', '\x14DC', 
		'\x14DD', '\a', '\x24E', '\x2', '\x2', '\x14DD', '\x14DF', '\x3', '\x2', 
		'\x2', '\x2', '\x14DE', '\x14D9', '\x3', '\x2', '\x2', '\x2', '\x14DE', 
		'\x14DA', '\x3', '\x2', '\x2', '\x2', '\x14DF', '\x3F9', '\x3', '\x2', 
		'\x2', '\x2', '\x14E0', '\x14E1', '\a', '\x219', '\x2', '\x2', '\x14E1', 
		'\x14E6', '\a', '\n', '\x2', '\x2', '\x14E2', '\x14E6', '\a', '\x219', 
		'\x2', '\x2', '\x14E3', '\x14E6', '\a', '\x12E', '\x2', '\x2', '\x14E4', 
		'\x14E6', '\a', '\xF1', '\x2', '\x2', '\x14E5', '\x14E0', '\x3', '\x2', 
		'\x2', '\x2', '\x14E5', '\x14E2', '\x3', '\x2', '\x2', '\x2', '\x14E5', 
		'\x14E3', '\x3', '\x2', '\x2', '\x2', '\x14E5', '\x14E4', '\x3', '\x2', 
		'\x2', '\x2', '\x14E6', '\x3FB', '\x3', '\x2', '\x2', '\x2', '\x14E7', 
		'\x14E8', '\a', '@', '\x2', '\x2', '\x14E8', '\x14E9', '\a', '\x16F', 
		'\x2', '\x2', '\x14E9', '\x3FD', '\x3', '\x2', '\x2', '\x2', '\x14EA', 
		'\x14EB', '\a', '\x1A2', '\x2', '\x2', '\x14EB', '\x14EC', '\a', '\x169', 
		'\x2', '\x2', '\x14EC', '\x3FF', '\x3', '\x2', '\x2', '\x2', '\x14ED', 
		'\x14EF', '\a', '\x171', '\x2', '\x2', '\x14EE', '\x14F0', '\a', '\x1E0', 
		'\x2', '\x2', '\x14EF', '\x14EE', '\x3', '\x2', '\x2', '\x2', '\x14EF', 
		'\x14F0', '\x3', '\x2', '\x2', '\x2', '\x14F0', '\x14F1', '\x3', '\x2', 
		'\x2', '\x2', '\x14F1', '\x14F2', '\a', '\x33', '\x2', '\x2', '\x14F2', 
		'\x14F3', '\x5', '\x406', '\x204', '\x2', '\x14F3', '\x401', '\x3', '\x2', 
		'\x2', '\x2', '\x14F4', '\x14F6', '\a', '\x171', '\x2', '\x2', '\x14F5', 
		'\x14F7', '\a', '\x1E0', '\x2', '\x2', '\x14F6', '\x14F5', '\x3', '\x2', 
		'\x2', '\x2', '\x14F6', '\x14F7', '\x3', '\x2', '\x2', '\x2', '\x14F7', 
		'\x14F8', '\x3', '\x2', '\x2', '\x2', '\x14F8', '\x14F9', '\a', '\x33', 
		'\x2', '\x2', '\x14F9', '\x14FA', '\x5', '\x406', '\x204', '\x2', '\x14FA', 
		'\x403', '\x3', '\x2', '\x2', '\x2', '\x14FB', '\x14FD', '\a', '\x171', 
		'\x2', '\x2', '\x14FC', '\x14FE', '\a', '\x1E0', '\x2', '\x2', '\x14FD', 
		'\x14FC', '\x3', '\x2', '\x2', '\x2', '\x14FD', '\x14FE', '\x3', '\x2', 
		'\x2', '\x2', '\x14FE', '\x14FF', '\x3', '\x2', '\x2', '\x2', '\x14FF', 
		'\x1500', '\a', '\x33', '\x2', '\x2', '\x1500', '\x1501', '\x5', '\x406', 
		'\x204', '\x2', '\x1501', '\x405', '\x3', '\x2', '\x2', '\x2', '\x1502', 
		'\x1507', '\x5', '\x408', '\x205', '\x2', '\x1503', '\x1504', '\a', '\x24F', 
		'\x2', '\x2', '\x1504', '\x1506', '\x5', '\x408', '\x205', '\x2', '\x1505', 
		'\x1503', '\x3', '\x2', '\x2', '\x2', '\x1506', '\x1509', '\x3', '\x2', 
		'\x2', '\x2', '\x1507', '\x1505', '\x3', '\x2', '\x2', '\x2', '\x1507', 
		'\x1508', '\x3', '\x2', '\x2', '\x2', '\x1508', '\x407', '\x3', '\x2', 
		'\x2', '\x2', '\x1509', '\x1507', '\x3', '\x2', '\x2', '\x2', '\x150A', 
		'\x150C', '\x5', '\xA0', 'Q', '\x2', '\x150B', '\x150D', '\x5', '\x40A', 
		'\x206', '\x2', '\x150C', '\x150B', '\x3', '\x2', '\x2', '\x2', '\x150C', 
		'\x150D', '\x3', '\x2', '\x2', '\x2', '\x150D', '\x150F', '\x3', '\x2', 
		'\x2', '\x2', '\x150E', '\x1510', '\x5', '\x40C', '\x207', '\x2', '\x150F', 
		'\x150E', '\x3', '\x2', '\x2', '\x2', '\x150F', '\x1510', '\x3', '\x2', 
		'\x2', '\x2', '\x1510', '\x409', '\x3', '\x2', '\x2', '\x2', '\x1511', 
		'\x1512', '\t', '\x1E', '\x2', '\x2', '\x1512', '\x40B', '\x3', '\x2', 
		'\x2', '\x2', '\x1513', '\x1514', '\a', '\x161', '\x2', '\x2', '\x1514', 
		'\x1515', '\t', '\x10', '\x2', '\x2', '\x1515', '\x40D', '\x3', '\x2', 
		'\x2', '\x2', '\x1516', '\x1517', '\a', '\xBE', '\x2', '\x2', '\x1517', 
		'\x151B', '\a', '\x220', '\x2', '\x2', '\x1518', '\x1519', '\x5', '\x410', 
		'\x209', '\x2', '\x1519', '\x151A', '\x5', '\x178', '\xBD', '\x2', '\x151A', 
		'\x151C', '\x3', '\x2', '\x2', '\x2', '\x151B', '\x1518', '\x3', '\x2', 
		'\x2', '\x2', '\x151B', '\x151C', '\x3', '\x2', '\x2', '\x2', '\x151C', 
		'\x151F', '\x3', '\x2', '\x2', '\x2', '\x151D', '\x1520', '\x5', '\x412', 
		'\x20A', '\x2', '\x151E', '\x1520', '\x5', '\x414', '\x20B', '\x2', '\x151F', 
		'\x151D', '\x3', '\x2', '\x2', '\x2', '\x151F', '\x151E', '\x3', '\x2', 
		'\x2', '\x2', '\x151F', '\x1520', '\x3', '\x2', '\x2', '\x2', '\x1520', 
		'\x40F', '\x3', '\x2', '\x2', '\x2', '\x1521', '\x1522', '\a', '\x164', 
		'\x2', '\x2', '\x1522', '\x411', '\x3', '\x2', '\x2', '\x2', '\x1523', 
		'\x1527', '\a', '\x15F', '\x2', '\x2', '\x1524', '\x1525', '\a', '\x232', 
		'\x2', '\x2', '\x1525', '\x1527', '\x5', '&', '\x14', '\x2', '\x1526', 
		'\x1523', '\x3', '\x2', '\x2', '\x2', '\x1526', '\x1524', '\x3', '\x2', 
		'\x2', '\x2', '\x1527', '\x413', '\x3', '\x2', '\x2', '\x2', '\x1528', 
		'\x1529', '\a', '\x1E2', '\x2', '\x2', '\x1529', '\x152A', '\a', '\x114', 
		'\x2', '\x2', '\x152A', '\x415', '\x3', '\x2', '\x2', '\x2', '\x152B', 
		'\x152C', '\a', '\x236', '\x2', '\x2', '\x152C', '\x1531', '\x5', '\x418', 
		'\x20D', '\x2', '\x152D', '\x152E', '\a', '\x24F', '\x2', '\x2', '\x152E', 
		'\x1530', '\x5', '\x418', '\x20D', '\x2', '\x152F', '\x152D', '\x3', '\x2', 
		'\x2', '\x2', '\x1530', '\x1533', '\x3', '\x2', '\x2', '\x2', '\x1531', 
		'\x152F', '\x3', '\x2', '\x2', '\x2', '\x1531', '\x1532', '\x3', '\x2', 
		'\x2', '\x2', '\x1532', '\x417', '\x3', '\x2', '\x2', '\x2', '\x1533', 
		'\x1531', '\x3', '\x2', '\x2', '\x2', '\x1534', '\x1536', '\x5', '\x44', 
		'#', '\x2', '\x1535', '\x1537', '\x5', '\x41A', '\x20E', '\x2', '\x1536', 
		'\x1535', '\x3', '\x2', '\x2', '\x2', '\x1536', '\x1537', '\x3', '\x2', 
		'\x2', '\x2', '\x1537', '\x1538', '\x3', '\x2', '\x2', '\x2', '\x1538', 
		'\x153A', '\x5', '\x162', '\xB2', '\x2', '\x1539', '\x153B', '\x5', '\x41C', 
		'\x20F', '\x2', '\x153A', '\x1539', '\x3', '\x2', '\x2', '\x2', '\x153A', 
		'\x153B', '\x3', '\x2', '\x2', '\x2', '\x153B', '\x153D', '\x3', '\x2', 
		'\x2', '\x2', '\x153C', '\x153E', '\x5', '\x420', '\x211', '\x2', '\x153D', 
		'\x153C', '\x3', '\x2', '\x2', '\x2', '\x153D', '\x153E', '\x3', '\x2', 
		'\x2', '\x2', '\x153E', '\x419', '\x3', '\x2', '\x2', '\x2', '\x153F', 
		'\x1540', '\a', '\x24D', '\x2', '\x2', '\x1540', '\x1541', '\x5', '\x178', 
		'\xBD', '\x2', '\x1541', '\x1542', '\a', '\x24E', '\x2', '\x2', '\x1542', 
		'\x41B', '\x3', '\x2', '\x2', '\x2', '\x1543', '\x1544', '\a', '\x1CD', 
		'\x2', '\x2', '\x1544', '\x1545', '\t', 'L', '\x2', '\x2', '\x1545', '\x1546', 
		'\a', '\xBA', '\x2', '\x2', '\x1546', '\x1547', '\a', '\x33', '\x2', '\x2', 
		'\x1547', '\x1548', '\x5', '\x406', '\x204', '\x2', '\x1548', '\x1549', 
		'\x5', '\x41E', '\x210', '\x2', '\x1549', '\x41D', '\x3', '\x2', '\x2', 
		'\x2', '\x154A', '\x154B', '\a', '\x1DA', '\x2', '\x2', '\x154B', '\x154C', 
		'\x5', '\x44', '#', '\x2', '\x154C', '\x41F', '\x3', '\x2', '\x2', '\x2', 
		'\x154D', '\x154E', '\a', 'k', '\x2', '\x2', '\x154E', '\x154F', '\x5', 
		'\x178', '\xBD', '\x2', '\x154F', '\x1550', '\x5', '\x41E', '\x210', '\x2', 
		'\x1550', '\x1551', '\x5', '\x422', '\x212', '\x2', '\x1551', '\x1552', 
		'\x5', '\x424', '\x213', '\x2', '\x1552', '\x421', '\x3', '\x2', '\x2', 
		'\x2', '\x1553', '\x1554', '\a', '\x20B', '\x2', '\x2', '\x1554', '\x1555', 
		'\x5', '&', '\x14', '\x2', '\x1555', '\x423', '\x3', '\x2', '\x2', '\x2', 
		'\x1556', '\x1557', '\a', 'y', '\x2', '\x2', '\x1557', '\x1558', '\x5', 
		'&', '\x14', '\x2', '\x1558', '\x425', '\x3', '\x2', '\x2', '\x2', '\x1559', 
		'\x155B', '\a', '\x1D2', '\x2', '\x2', '\x155A', '\x155C', '\t', '\b', 
		'\x2', '\x2', '\x155B', '\x155A', '\x3', '\x2', '\x2', '\x2', '\x155B', 
		'\x155C', '\x3', '\x2', '\x2', '\x2', '\x155C', '\x155D', '\x3', '\x2', 
		'\x2', '\x2', '\x155D', '\x1560', '\x5', '\x428', '\x215', '\x2', '\x155E', 
		'\x1561', '\x5', '\x42A', '\x216', '\x2', '\x155F', '\x1561', '\x5', '\x4FE', 
		'\x280', '\x2', '\x1560', '\x155E', '\x3', '\x2', '\x2', '\x2', '\x1560', 
		'\x155F', '\x3', '\x2', '\x2', '\x2', '\x1560', '\x1561', '\x3', '\x2', 
		'\x2', '\x2', '\x1561', '\x1562', '\x3', '\x2', '\x2', '\x2', '\x1562', 
		'\x1564', '\x5', '\x454', '\x22B', '\x2', '\x1563', '\x1565', '\x5', '\x42C', 
		'\x217', '\x2', '\x1564', '\x1563', '\x3', '\x2', '\x2', '\x2', '\x1564', 
		'\x1565', '\x3', '\x2', '\x2', '\x2', '\x1565', '\x156D', '\x3', '\x2', 
		'\x2', '\x2', '\x1566', '\x1568', '\x5', '\x44E', '\x228', '\x2', '\x1567', 
		'\x1569', '\x5', '\x450', '\x229', '\x2', '\x1568', '\x1567', '\x3', '\x2', 
		'\x2', '\x2', '\x1568', '\x1569', '\x3', '\x2', '\x2', '\x2', '\x1569', 
		'\x156E', '\x3', '\x2', '\x2', '\x2', '\x156A', '\x156B', '\x5', '\x450', 
		'\x229', '\x2', '\x156B', '\x156C', '\x5', '\x44E', '\x228', '\x2', '\x156C', 
		'\x156E', '\x3', '\x2', '\x2', '\x2', '\x156D', '\x1566', '\x3', '\x2', 
		'\x2', '\x2', '\x156D', '\x156A', '\x3', '\x2', '\x2', '\x2', '\x156D', 
		'\x156E', '\x3', '\x2', '\x2', '\x2', '\x156E', '\x1577', '\x3', '\x2', 
		'\x2', '\x2', '\x156F', '\x1571', '\x5', '\x42E', '\x218', '\x2', '\x1570', 
		'\x1572', '\x5', '\x452', '\x22A', '\x2', '\x1571', '\x1570', '\x3', '\x2', 
		'\x2', '\x2', '\x1571', '\x1572', '\x3', '\x2', '\x2', '\x2', '\x1572', 
		'\x1578', '\x3', '\x2', '\x2', '\x2', '\x1573', '\x1575', '\x5', '\x452', 
		'\x22A', '\x2', '\x1574', '\x1576', '\x5', '\x42E', '\x218', '\x2', '\x1575', 
		'\x1574', '\x3', '\x2', '\x2', '\x2', '\x1575', '\x1576', '\x3', '\x2', 
		'\x2', '\x2', '\x1576', '\x1578', '\x3', '\x2', '\x2', '\x2', '\x1577', 
		'\x156F', '\x3', '\x2', '\x2', '\x2', '\x1577', '\x1573', '\x3', '\x2', 
		'\x2', '\x2', '\x1577', '\x1578', '\x3', '\x2', '\x2', '\x2', '\x1578', 
		'\x427', '\x3', '\x2', '\x2', '\x2', '\x1579', '\x157A', '\x5', '\x16A', 
		'\xB6', '\x2', '\x157A', '\x429', '\x3', '\x2', '\x2', '\x2', '\x157B', 
		'\x157C', '\a', '\xF3', '\x2', '\x2', '\x157C', '\x157D', '\x5', '\x178', 
		'\xBD', '\x2', '\x157D', '\x42B', '\x3', '\x2', '\x2', '\x2', '\x157E', 
		'\x157F', '\a', '\x234', '\x2', '\x2', '\x157F', '\x1580', '\x5', '\xA0', 
		'Q', '\x2', '\x1580', '\x42D', '\x3', '\x2', '\x2', '\x2', '\x1581', '\x1582', 
		'\a', '\xD0', '\x2', '\x2', '\x1582', '\x1583', '\a', '\x33', '\x2', '\x2', 
		'\x1583', '\x1584', '\x5', '\x430', '\x219', '\x2', '\x1584', '\x42F', 
		'\x3', '\x2', '\x2', '\x2', '\x1585', '\x1586', '\x5', '\x432', '\x21A', 
		'\x2', '\x1586', '\x431', '\x3', '\x2', '\x2', '\x2', '\x1587', '\x158C', 
		'\x5', '\x434', '\x21B', '\x2', '\x1588', '\x1589', '\a', '\x24F', '\x2', 
		'\x2', '\x1589', '\x158B', '\x5', '\x434', '\x21B', '\x2', '\x158A', '\x1588', 
		'\x3', '\x2', '\x2', '\x2', '\x158B', '\x158E', '\x3', '\x2', '\x2', '\x2', 
		'\x158C', '\x158A', '\x3', '\x2', '\x2', '\x2', '\x158C', '\x158D', '\x3', 
		'\x2', '\x2', '\x2', '\x158D', '\x433', '\x3', '\x2', '\x2', '\x2', '\x158E', 
		'\x158C', '\x3', '\x2', '\x2', '\x2', '\x158F', '\x1592', '\x5', '\x438', 
		'\x21D', '\x2', '\x1590', '\x1592', '\x5', '\x436', '\x21C', '\x2', '\x1591', 
		'\x158F', '\x3', '\x2', '\x2', '\x2', '\x1591', '\x1590', '\x3', '\x2', 
		'\x2', '\x2', '\x1592', '\x435', '\x3', '\x2', '\x2', '\x2', '\x1593', 
		'\x1594', '\a', '\x24D', '\x2', '\x2', '\x1594', '\x1599', '\x5', '\x434', 
		'\x21B', '\x2', '\x1595', '\x1596', '\a', '\x24F', '\x2', '\x2', '\x1596', 
		'\x1598', '\x5', '\x434', '\x21B', '\x2', '\x1597', '\x1595', '\x3', '\x2', 
		'\x2', '\x2', '\x1598', '\x159B', '\x3', '\x2', '\x2', '\x2', '\x1599', 
		'\x1597', '\x3', '\x2', '\x2', '\x2', '\x1599', '\x159A', '\x3', '\x2', 
		'\x2', '\x2', '\x159A', '\x159C', '\x3', '\x2', '\x2', '\x2', '\x159B', 
		'\x1599', '\x3', '\x2', '\x2', '\x2', '\x159C', '\x159D', '\a', '\x24E', 
		'\x2', '\x2', '\x159D', '\x437', '\x3', '\x2', '\x2', '\x2', '\x159E', 
		'\x15A3', '\x5', '\x446', '\x224', '\x2', '\x159F', '\x15A3', '\x5', '\x43C', 
		'\x21F', '\x2', '\x15A0', '\x15A3', '\x5', '\x43A', '\x21E', '\x2', '\x15A1', 
		'\x15A3', '\x5', '\xA0', 'Q', '\x2', '\x15A2', '\x159E', '\x3', '\x2', 
		'\x2', '\x2', '\x15A2', '\x159F', '\x3', '\x2', '\x2', '\x2', '\x15A2', 
		'\x15A0', '\x3', '\x2', '\x2', '\x2', '\x15A2', '\x15A1', '\x3', '\x2', 
		'\x2', '\x2', '\x15A3', '\x439', '\x3', '\x2', '\x2', '\x2', '\x15A4', 
		'\x15A5', '\a', '\x24D', '\x2', '\x2', '\x15A5', '\x15A6', '\a', '\x24E', 
		'\x2', '\x2', '\x15A6', '\x43B', '\x3', '\x2', '\x2', '\x2', '\x15A7', 
		'\x15A8', '\a', '\xD1', '\x2', '\x2', '\x15A8', '\x15A9', '\a', '\x1DB', 
		'\x2', '\x2', '\x15A9', '\x15AA', '\a', '\x24D', '\x2', '\x2', '\x15AA', 
		'\x15AB', '\x5', '\x43E', '\x220', '\x2', '\x15AB', '\x15AC', '\a', '\x24E', 
		'\x2', '\x2', '\x15AC', '\x43D', '\x3', '\x2', '\x2', '\x2', '\x15AD', 
		'\x15B2', '\x5', '\x440', '\x221', '\x2', '\x15AE', '\x15AF', '\a', '\x24F', 
		'\x2', '\x2', '\x15AF', '\x15B1', '\x5', '\x440', '\x221', '\x2', '\x15B0', 
		'\x15AE', '\x3', '\x2', '\x2', '\x2', '\x15B1', '\x15B4', '\x3', '\x2', 
		'\x2', '\x2', '\x15B2', '\x15B0', '\x3', '\x2', '\x2', '\x2', '\x15B2', 
		'\x15B3', '\x3', '\x2', '\x2', '\x2', '\x15B3', '\x43F', '\x3', '\x2', 
		'\x2', '\x2', '\x15B4', '\x15B2', '\x3', '\x2', '\x2', '\x2', '\x15B5', 
		'\x15B9', '\x5', '\x43A', '\x21E', '\x2', '\x15B6', '\x15B9', '\x5', '\x444', 
		'\x223', '\x2', '\x15B7', '\x15B9', '\x5', '\x442', '\x222', '\x2', '\x15B8', 
		'\x15B5', '\x3', '\x2', '\x2', '\x2', '\x15B8', '\x15B6', '\x3', '\x2', 
		'\x2', '\x2', '\x15B8', '\x15B7', '\x3', '\x2', '\x2', '\x2', '\x15B9', 
		'\x441', '\x3', '\x2', '\x2', '\x2', '\x15BA', '\x15BD', '\x5', '\x446', 
		'\x224', '\x2', '\x15BB', '\x15BD', '\x5', '\xA0', 'Q', '\x2', '\x15BC', 
		'\x15BA', '\x3', '\x2', '\x2', '\x2', '\x15BC', '\x15BB', '\x3', '\x2', 
		'\x2', '\x2', '\x15BD', '\x443', '\x3', '\x2', '\x2', '\x2', '\x15BE', 
		'\x15BF', '\a', '\x24D', '\x2', '\x2', '\x15BF', '\x15C4', '\x5', '\xA0', 
		'Q', '\x2', '\x15C0', '\x15C1', '\a', '\x24F', '\x2', '\x2', '\x15C1', 
		'\x15C3', '\x5', '\xA0', 'Q', '\x2', '\x15C2', '\x15C0', '\x3', '\x2', 
		'\x2', '\x2', '\x15C3', '\x15C6', '\x3', '\x2', '\x2', '\x2', '\x15C4', 
		'\x15C2', '\x3', '\x2', '\x2', '\x2', '\x15C4', '\x15C5', '\x3', '\x2', 
		'\x2', '\x2', '\x15C5', '\x15C7', '\x3', '\x2', '\x2', '\x2', '\x15C6', 
		'\x15C4', '\x3', '\x2', '\x2', '\x2', '\x15C7', '\x15C8', '\a', '\x24E', 
		'\x2', '\x2', '\x15C8', '\x445', '\x3', '\x2', '\x2', '\x2', '\x15C9', 
		'\x15CA', '\t', 'M', '\x2', '\x2', '\x15CA', '\x15CB', '\a', '\x24D', 
		'\x2', '\x2', '\x15CB', '\x15CC', '\x5', '\x448', '\x225', '\x2', '\x15CC', 
		'\x15CD', '\a', '\x24E', '\x2', '\x2', '\x15CD', '\x447', '\x3', '\x2', 
		'\x2', '\x2', '\x15CE', '\x15D3', '\x5', '\x44A', '\x226', '\x2', '\x15CF', 
		'\x15D0', '\a', '\x24F', '\x2', '\x2', '\x15D0', '\x15D2', '\x5', '\x44A', 
		'\x226', '\x2', '\x15D1', '\x15CF', '\x3', '\x2', '\x2', '\x2', '\x15D2', 
		'\x15D5', '\x3', '\x2', '\x2', '\x2', '\x15D3', '\x15D1', '\x3', '\x2', 
		'\x2', '\x2', '\x15D3', '\x15D4', '\x3', '\x2', '\x2', '\x2', '\x15D4', 
		'\x449', '\x3', '\x2', '\x2', '\x2', '\x15D5', '\x15D3', '\x3', '\x2', 
		'\x2', '\x2', '\x15D6', '\x15D9', '\x5', '\x44C', '\x227', '\x2', '\x15D7', 
		'\x15D9', '\x5', '\xA0', 'Q', '\x2', '\x15D8', '\x15D6', '\x3', '\x2', 
		'\x2', '\x2', '\x15D8', '\x15D7', '\x3', '\x2', '\x2', '\x2', '\x15D9', 
		'\x44B', '\x3', '\x2', '\x2', '\x2', '\x15DA', '\x15DB', '\a', '\x24D', 
		'\x2', '\x2', '\x15DB', '\x15E0', '\x5', '\xA0', 'Q', '\x2', '\x15DC', 
		'\x15DD', '\a', '\x24F', '\x2', '\x2', '\x15DD', '\x15DF', '\x5', '\xA0', 
		'Q', '\x2', '\x15DE', '\x15DC', '\x3', '\x2', '\x2', '\x2', '\x15DF', 
		'\x15E2', '\x3', '\x2', '\x2', '\x2', '\x15E0', '\x15DE', '\x3', '\x2', 
		'\x2', '\x2', '\x15E0', '\x15E1', '\x3', '\x2', '\x2', '\x2', '\x15E1', 
		'\x15E3', '\x3', '\x2', '\x2', '\x2', '\x15E2', '\x15E0', '\x3', '\x2', 
		'\x2', '\x2', '\x15E3', '\x15E4', '\a', '\x24E', '\x2', '\x2', '\x15E4', 
		'\x44D', '\x3', '\x2', '\x2', '\x2', '\x15E5', '\x15E6', '\a', 'X', '\x2', 
		'\x2', '\x15E6', '\x15E8', '\a', '\x33', '\x2', '\x2', '\x15E7', '\x15E9', 
		'\a', '\x149', '\x2', '\x2', '\x15E8', '\x15E7', '\x3', '\x2', '\x2', 
		'\x2', '\x15E8', '\x15E9', '\x3', '\x2', '\x2', '\x2', '\x15E9', '\x15EA', 
		'\x3', '\x2', '\x2', '\x2', '\x15EA', '\x15EB', '\x5', '\xA0', 'Q', '\x2', 
		'\x15EB', '\x44F', '\x3', '\x2', '\x2', '\x2', '\x15EC', '\x15ED', '\a', 
		'\x1E8', '\x2', '\x2', '\x15ED', '\x15EE', '\a', '\x236', '\x2', '\x2', 
		'\x15EE', '\x15EF', '\x5', '\xA0', 'Q', '\x2', '\x15EF', '\x451', '\x3', 
		'\x2', '\x2', '\x2', '\x15F0', '\x15F1', '\a', '\xD4', '\x2', '\x2', '\x15F1', 
		'\x15F2', '\x5', '\xA0', 'Q', '\x2', '\x15F2', '\x453', '\x3', '\x2', 
		'\x2', '\x2', '\x15F3', '\x15F4', '\a', '\xC8', '\x2', '\x2', '\x15F4', 
		'\x15F9', '\x5', '\x456', '\x22C', '\x2', '\x15F5', '\x15F6', '\a', '\x24F', 
		'\x2', '\x2', '\x15F6', '\x15F8', '\x5', '\x456', '\x22C', '\x2', '\x15F7', 
		'\x15F5', '\x3', '\x2', '\x2', '\x2', '\x15F8', '\x15FB', '\x3', '\x2', 
		'\x2', '\x2', '\x15F9', '\x15F7', '\x3', '\x2', '\x2', '\x2', '\x15F9', 
		'\x15FA', '\x3', '\x2', '\x2', '\x2', '\x15FA', '\x455', '\x3', '\x2', 
		'\x2', '\x2', '\x15FB', '\x15F9', '\x3', '\x2', '\x2', '\x2', '\x15FC', 
		'\x15FE', '\x5', '\x458', '\x22D', '\x2', '\x15FD', '\x15FF', '\x5', '\x49A', 
		'\x24E', '\x2', '\x15FE', '\x15FD', '\x3', '\x2', '\x2', '\x2', '\x15FE', 
		'\x15FF', '\x3', '\x2', '\x2', '\x2', '\x15FF', '\x457', '\x3', '\x2', 
		'\x2', '\x2', '\x1600', '\x1602', '\x5', '\x468', '\x235', '\x2', '\x1601', 
		'\x1603', '\x5', '\x464', '\x233', '\x2', '\x1602', '\x1601', '\x3', '\x2', 
		'\x2', '\x2', '\x1602', '\x1603', '\x3', '\x2', '\x2', '\x2', '\x1603', 
		'\x160F', '\x3', '\x2', '\x2', '\x2', '\x1604', '\x1605', '\x5', '\x45C', 
		'\x22F', '\x2', '\x1605', '\x1608', '\x5', '\x458', '\x22D', '\x2', '\x1606', 
		'\x1609', '\x5', '\x460', '\x231', '\x2', '\x1607', '\x1609', '\x5', '\x462', 
		'\x232', '\x2', '\x1608', '\x1606', '\x3', '\x2', '\x2', '\x2', '\x1608', 
		'\x1607', '\x3', '\x2', '\x2', '\x2', '\x1608', '\x1609', '\x3', '\x2', 
		'\x2', '\x2', '\x1609', '\x160E', '\x3', '\x2', '\x2', '\x2', '\x160A', 
		'\x160B', '\x5', '\x45A', '\x22E', '\x2', '\x160B', '\x160C', '\x5', '\x458', 
		'\x22D', '\x2', '\x160C', '\x160E', '\x3', '\x2', '\x2', '\x2', '\x160D', 
		'\x1604', '\x3', '\x2', '\x2', '\x2', '\x160D', '\x160A', '\x3', '\x2', 
		'\x2', '\x2', '\x160E', '\x1611', '\x3', '\x2', '\x2', '\x2', '\x160F', 
		'\x160D', '\x3', '\x2', '\x2', '\x2', '\x160F', '\x1610', '\x3', '\x2', 
		'\x2', '\x2', '\x1610', '\x459', '\x3', '\x2', '\x2', '\x2', '\x1611', 
		'\x160F', '\x3', '\x2', '\x2', '\x2', '\x1612', '\x1613', '\a', '\x66', 
		'\x2', '\x2', '\x1613', '\x161B', '\a', '\xFB', '\x2', '\x2', '\x1614', 
		'\x1617', '\a', '\x13B', '\x2', '\x2', '\x1615', '\x1618', '\a', '\xEB', 
		'\x2', '\x2', '\x1616', '\x1618', '\x5', '\x45E', '\x230', '\x2', '\x1617', 
		'\x1615', '\x3', '\x2', '\x2', '\x2', '\x1617', '\x1616', '\x3', '\x2', 
		'\x2', '\x2', '\x1617', '\x1618', '\x3', '\x2', '\x2', '\x2', '\x1618', 
		'\x1619', '\x3', '\x2', '\x2', '\x2', '\x1619', '\x161B', '\a', '\xFB', 
		'\x2', '\x2', '\x161A', '\x1612', '\x3', '\x2', '\x2', '\x2', '\x161A', 
		'\x1614', '\x3', '\x2', '\x2', '\x2', '\x161B', '\x45B', '\x3', '\x2', 
		'\x2', '\x2', '\x161C', '\x161F', '\x5', '\x45E', '\x230', '\x2', '\x161D', 
		'\x161F', '\a', '\xEB', '\x2', '\x2', '\x161E', '\x161C', '\x3', '\x2', 
		'\x2', '\x2', '\x161E', '\x161D', '\x3', '\x2', '\x2', '\x2', '\x161E', 
		'\x161F', '\x3', '\x2', '\x2', '\x2', '\x161F', '\x1620', '\x3', '\x2', 
		'\x2', '\x2', '\x1620', '\x1621', '\a', '\xFB', '\x2', '\x2', '\x1621', 
		'\x45D', '\x3', '\x2', '\x2', '\x2', '\x1622', '\x1624', '\t', 'N', '\x2', 
		'\x2', '\x1623', '\x1625', '\a', '\x175', '\x2', '\x2', '\x1624', '\x1623', 
		'\x3', '\x2', '\x2', '\x2', '\x1624', '\x1625', '\x3', '\x2', '\x2', '\x2', 
		'\x1625', '\x45F', '\x3', '\x2', '\x2', '\x2', '\x1626', '\x1627', '\a', 
		'\x168', '\x2', '\x2', '\x1627', '\x1628', '\x5', '\xA0', 'Q', '\x2', 
		'\x1628', '\x461', '\x3', '\x2', '\x2', '\x2', '\x1629', '\x162A', '\a', 
		'\x225', '\x2', '\x2', '\x162A', '\x162B', '\a', '\x24D', '\x2', '\x2', 
		'\x162B', '\x1630', '\x5', '\x42', '\"', '\x2', '\x162C', '\x162D', '\a', 
		'\x24F', '\x2', '\x2', '\x162D', '\x162F', '\x5', '\x42', '\"', '\x2', 
		'\x162E', '\x162C', '\x3', '\x2', '\x2', '\x2', '\x162F', '\x1632', '\x3', 
		'\x2', '\x2', '\x2', '\x1630', '\x162E', '\x3', '\x2', '\x2', '\x2', '\x1630', 
		'\x1631', '\x3', '\x2', '\x2', '\x2', '\x1631', '\x1633', '\x3', '\x2', 
		'\x2', '\x2', '\x1632', '\x1630', '\x3', '\x2', '\x2', '\x2', '\x1633', 
		'\x1634', '\a', '\x24E', '\x2', '\x2', '\x1634', '\x463', '\x3', '\x2', 
		'\x2', '\x2', '\x1635', '\x1636', '\a', '\x180', '\x2', '\x2', '\x1636', 
		'\x1637', '\a', '\x33', '\x2', '\x2', '\x1637', '\x1638', '\a', '\x24D', 
		'\x2', '\x2', '\x1638', '\x1639', '\x5', '\x16A', '\xB6', '\x2', '\x1639', 
		'\x163A', '\a', '\x24E', '\x2', '\x2', '\x163A', '\x465', '\x3', '\x2', 
		'\x2', '\x2', '\x163B', '\x163C', '\t', 'O', '\x2', '\x2', '\x163C', '\x163D', 
		'\a', '\x24D', '\x2', '\x2', '\x163D', '\x163E', '\x5', '\x42', '\"', 
		'\x2', '\x163E', '\x163F', '\a', '\x24E', '\x2', '\x2', '\x163F', '\x467', 
		'\x3', '\x2', '\x2', '\x2', '\x1640', '\x1646', '\x5', '\x44', '#', '\x2', 
		'\x1641', '\x1643', '\x5', '\x466', '\x234', '\x2', '\x1642', '\x1644', 
		'\x5', '\x4CC', '\x267', '\x2', '\x1643', '\x1642', '\x3', '\x2', '\x2', 
		'\x2', '\x1643', '\x1644', '\x3', '\x2', '\x2', '\x2', '\x1644', '\x1647', 
		'\x3', '\x2', '\x2', '\x2', '\x1645', '\x1647', '\x5', '\x4CC', '\x267', 
		'\x2', '\x1646', '\x1641', '\x3', '\x2', '\x2', '\x2', '\x1646', '\x1645', 
		'\x3', '\x2', '\x2', '\x2', '\x1646', '\x1647', '\x3', '\x2', '\x2', '\x2', 
		'\x1647', '\x1651', '\x3', '\x2', '\x2', '\x2', '\x1648', '\x1649', '\a', 
		'\x24D', '\x2', '\x2', '\x1649', '\x164A', '\x5', '\x456', '\x22C', '\x2', 
		'\x164A', '\x164B', '\a', '\x24E', '\x2', '\x2', '\x164B', '\x1651', '\x3', 
		'\x2', '\x2', '\x2', '\x164C', '\x1651', '\x5', '\x490', '\x249', '\x2', 
		'\x164D', '\x1651', '\x5', '\x164', '\xB3', '\x2', '\x164E', '\x1651', 
		'\x5', '\x160', '\xB1', '\x2', '\x164F', '\x1651', '\x5', '\x46A', '\x236', 
		'\x2', '\x1650', '\x1640', '\x3', '\x2', '\x2', '\x2', '\x1650', '\x1648', 
		'\x3', '\x2', '\x2', '\x2', '\x1650', '\x164C', '\x3', '\x2', '\x2', '\x2', 
		'\x1650', '\x164D', '\x3', '\x2', '\x2', '\x2', '\x1650', '\x164E', '\x3', 
		'\x2', '\x2', '\x2', '\x1650', '\x164F', '\x3', '\x2', '\x2', '\x2', '\x1651', 
		'\x1653', '\x3', '\x2', '\x2', '\x2', '\x1652', '\x1654', '\x5', '\x48E', 
		'\x248', '\x2', '\x1653', '\x1652', '\x3', '\x2', '\x2', '\x2', '\x1653', 
		'\x1654', '\x3', '\x2', '\x2', '\x2', '\x1654', '\x165A', '\x3', '\x2', 
		'\x2', '\x2', '\x1655', '\x1657', '\x6', '\x235', '\x3', '\x2', '\x1656', 
		'\x1658', '\x5', '\x4D2', '\x26A', '\x2', '\x1657', '\x1656', '\x3', '\x2', 
		'\x2', '\x2', '\x1657', '\x1658', '\x3', '\x2', '\x2', '\x2', '\x1658', 
		'\x165B', '\x3', '\x2', '\x2', '\x2', '\x1659', '\x165B', '\x3', '\x2', 
		'\x2', '\x2', '\x165A', '\x1655', '\x3', '\x2', '\x2', '\x2', '\x165A', 
		'\x1659', '\x3', '\x2', '\x2', '\x2', '\x165B', '\x469', '\x3', '\x2', 
		'\x2', '\x2', '\x165C', '\x165D', '\a', '\xFD', '\x2', '\x2', '\x165D', 
		'\x165E', '\a', '\x24D', '\x2', '\x2', '\x165E', '\x1661', '\x5', '\xA0', 
		'Q', '\x2', '\x165F', '\x1660', '\a', '\xC2', '\x2', '\x2', '\x1660', 
		'\x1662', '\a', '\xFC', '\x2', '\x2', '\x1661', '\x165F', '\x3', '\x2', 
		'\x2', '\x2', '\x1661', '\x1662', '\x3', '\x2', '\x2', '\x2', '\x1662', 
		'\x1665', '\x3', '\x2', '\x2', '\x2', '\x1663', '\x1664', '\a', '\x24F', 
		'\x2', '\x2', '\x1664', '\x1666', '\x5', '\x470', '\x239', '\x2', '\x1665', 
		'\x1663', '\x3', '\x2', '\x2', '\x2', '\x1665', '\x1666', '\x3', '\x2', 
		'\x2', '\x2', '\x1666', '\x166A', '\x3', '\x2', '\x2', '\x2', '\x1667', 
		'\x1669', '\x5', '\x46C', '\x237', '\x2', '\x1668', '\x1667', '\x3', '\x2', 
		'\x2', '\x2', '\x1669', '\x166C', '\x3', '\x2', '\x2', '\x2', '\x166A', 
		'\x1668', '\x3', '\x2', '\x2', '\x2', '\x166A', '\x166B', '\x3', '\x2', 
		'\x2', '\x2', '\x166B', '\x166D', '\x3', '\x2', '\x2', '\x2', '\x166C', 
		'\x166A', '\x3', '\x2', '\x2', '\x2', '\x166D', '\x166E', '\x5', '\x472', 
		'\x23A', '\x2', '\x166E', '\x166F', '\a', '\x24E', '\x2', '\x2', '\x166F', 
		'\x46B', '\x3', '\x2', '\x2', '\x2', '\x1670', '\x1671', '\x5', '\x46E', 
		'\x238', '\x2', '\x1671', '\x1672', '\t', 'P', '\x2', '\x2', '\x1672', 
		'\x46D', '\x3', '\x2', '\x2', '\x2', '\x1673', '\x1674', '\t', 'Q', '\x2', 
		'\x2', '\x1674', '\x1675', '\a', '\x168', '\x2', '\x2', '\x1675', '\x46F', 
		'\x3', '\x2', '\x2', '\x2', '\x1676', '\x1679', '\x5', '\x44', '#', '\x2', 
		'\x1677', '\x1679', '\x5', '&', '\x14', '\x2', '\x1678', '\x1676', '\x3', 
		'\x2', '\x2', '\x2', '\x1678', '\x1677', '\x3', '\x2', '\x2', '\x2', '\x1679', 
		'\x471', '\x3', '\x2', '\x2', '\x2', '\x167A', '\x167B', '\a', 'L', '\x2', 
		'\x2', '\x167B', '\x167C', '\a', '\x24D', '\x2', '\x2', '\x167C', '\x1681', 
		'\x5', '\x474', '\x23B', '\x2', '\x167D', '\x167E', '\a', '\x24F', '\x2', 
		'\x2', '\x167E', '\x1680', '\x5', '\x474', '\x23B', '\x2', '\x167F', '\x167D', 
		'\x3', '\x2', '\x2', '\x2', '\x1680', '\x1683', '\x3', '\x2', '\x2', '\x2', 
		'\x1681', '\x167F', '\x3', '\x2', '\x2', '\x2', '\x1681', '\x1682', '\x3', 
		'\x2', '\x2', '\x2', '\x1682', '\x1684', '\x3', '\x2', '\x2', '\x2', '\x1683', 
		'\x1681', '\x3', '\x2', '\x2', '\x2', '\x1684', '\x1685', '\a', '\x24E', 
		'\x2', '\x2', '\x1685', '\x473', '\x3', '\x2', '\x2', '\x2', '\x1686', 
		'\x168C', '\x5', '\x476', '\x23C', '\x2', '\x1687', '\x168C', '\x5', '\x47C', 
		'\x23F', '\x2', '\x1688', '\x168C', '\x5', '\x484', '\x243', '\x2', '\x1689', 
		'\x168C', '\x5', '\x48A', '\x246', '\x2', '\x168A', '\x168C', '\x5', '\x48C', 
		'\x247', '\x2', '\x168B', '\x1686', '\x3', '\x2', '\x2', '\x2', '\x168B', 
		'\x1687', '\x3', '\x2', '\x2', '\x2', '\x168B', '\x1688', '\x3', '\x2', 
		'\x2', '\x2', '\x168B', '\x1689', '\x3', '\x2', '\x2', '\x2', '\x168B', 
		'\x168A', '\x3', '\x2', '\x2', '\x2', '\x168C', '\x475', '\x3', '\x2', 
		'\x2', '\x2', '\x168D', '\x168F', '\x5', '\x44', '#', '\x2', '\x168E', 
		'\x1690', '\x5', '`', '\x31', '\x2', '\x168F', '\x168E', '\x3', '\x2', 
		'\x2', '\x2', '\x168F', '\x1690', '\x3', '\x2', '\x2', '\x2', '\x1690', 
		'\x1691', '\x3', '\x2', '\x2', '\x2', '\x1691', '\x1694', '\a', '\xAB', 
		'\x2', '\x2', '\x1692', '\x1693', '\a', '\x184', '\x2', '\x2', '\x1693', 
		'\x1695', '\x5', '\x470', '\x239', '\x2', '\x1694', '\x1692', '\x3', '\x2', 
		'\x2', '\x2', '\x1694', '\x1695', '\x3', '\x2', '\x2', '\x2', '\x1695', 
		'\x1699', '\x3', '\x2', '\x2', '\x2', '\x1696', '\x1698', '\x5', '\x478', 
		'\x23D', '\x2', '\x1697', '\x1696', '\x3', '\x2', '\x2', '\x2', '\x1698', 
		'\x169B', '\x3', '\x2', '\x2', '\x2', '\x1699', '\x1697', '\x3', '\x2', 
		'\x2', '\x2', '\x1699', '\x169A', '\x3', '\x2', '\x2', '\x2', '\x169A', 
		'\x477', '\x3', '\x2', '\x2', '\x2', '\x169B', '\x1699', '\x3', '\x2', 
		'\x2', '\x2', '\x169C', '\x169D', '\x5', '\x47A', '\x23E', '\x2', '\x169D', 
		'\x169E', '\t', 'P', '\x2', '\x2', '\x169E', '\x479', '\x3', '\x2', '\x2', 
		'\x2', '\x169F', '\x16A0', '\t', 'R', '\x2', '\x2', '\x16A0', '\x16A1', 
		'\a', '\x168', '\x2', '\x2', '\x16A1', '\x47B', '\x3', '\x2', '\x2', '\x2', 
		'\x16A2', '\x16A4', '\x5', '\x44', '#', '\x2', '\x16A3', '\x16A5', '\x5', 
		'`', '\x31', '\x2', '\x16A4', '\x16A3', '\x3', '\x2', '\x2', '\x2', '\x16A4', 
		'\x16A5', '\x3', '\x2', '\x2', '\x2', '\x16A5', '\x16A7', '\x3', '\x2', 
		'\x2', '\x2', '\x16A6', '\x16A8', '\a', '\x213', '\x2', '\x2', '\x16A7', 
		'\x16A6', '\x3', '\x2', '\x2', '\x2', '\x16A7', '\x16A8', '\x3', '\x2', 
		'\x2', '\x2', '\x16A8', '\x16A9', '\x3', '\x2', '\x2', '\x2', '\x16A9', 
		'\x16AA', '\a', '\xC2', '\x2', '\x2', '\x16AA', '\x16AC', '\a', '\xFC', 
		'\x2', '\x2', '\x16AB', '\x16AD', '\x5', '\x47E', '\x240', '\x2', '\x16AC', 
		'\x16AB', '\x3', '\x2', '\x2', '\x2', '\x16AC', '\x16AD', '\x3', '\x2', 
		'\x2', '\x2', '\x16AD', '\x16B0', '\x3', '\x2', '\x2', '\x2', '\x16AE', 
		'\x16AF', '\a', '\x184', '\x2', '\x2', '\x16AF', '\x16B1', '\x5', '\x470', 
		'\x239', '\x2', '\x16B0', '\x16AE', '\x3', '\x2', '\x2', '\x2', '\x16B0', 
		'\x16B1', '\x3', '\x2', '\x2', '\x2', '\x16B1', '\x16B5', '\x3', '\x2', 
		'\x2', '\x2', '\x16B2', '\x16B4', '\x5', '\x480', '\x241', '\x2', '\x16B3', 
		'\x16B2', '\x3', '\x2', '\x2', '\x2', '\x16B4', '\x16B7', '\x3', '\x2', 
		'\x2', '\x2', '\x16B5', '\x16B3', '\x3', '\x2', '\x2', '\x2', '\x16B5', 
		'\x16B6', '\x3', '\x2', '\x2', '\x2', '\x16B6', '\x47D', '\x3', '\x2', 
		'\x2', '\x2', '\x16B7', '\x16B5', '\x3', '\x2', '\x2', '\x2', '\x16B8', 
		'\x16BA', '\a', '\x236', '\x2', '\x2', '\x16B9', '\x16BB', '\t', 'S', 
		'\x2', '\x2', '\x16BA', '\x16B9', '\x3', '\x2', '\x2', '\x2', '\x16BA', 
		'\x16BB', '\x3', '\x2', '\x2', '\x2', '\x16BB', '\x16BE', '\x3', '\x2', 
		'\x2', '\x2', '\x16BC', '\x16BE', '\a', '\x238', '\x2', '\x2', '\x16BD', 
		'\x16B8', '\x3', '\x2', '\x2', '\x2', '\x16BD', '\x16BC', '\x3', '\x2', 
		'\x2', '\x2', '\x16BE', '\x16C0', '\x3', '\x2', '\x2', '\x2', '\x16BF', 
		'\x16C1', '\a', '\x14', '\x2', '\x2', '\x16C0', '\x16BF', '\x3', '\x2', 
		'\x2', '\x2', '\x16C0', '\x16C1', '\x3', '\x2', '\x2', '\x2', '\x16C1', 
		'\x16C2', '\x3', '\x2', '\x2', '\x2', '\x16C2', '\x16C3', '\a', '\x23B', 
		'\x2', '\x2', '\x16C3', '\x47F', '\x3', '\x2', '\x2', '\x2', '\x16C4', 
		'\x16C5', '\x5', '\x482', '\x242', '\x2', '\x16C5', '\x16C6', '\t', 'P', 
		'\x2', '\x2', '\x16C6', '\x481', '\x3', '\x2', '\x2', '\x2', '\x16C7', 
		'\x16CE', '\a', '\xA0', '\x2', '\x2', '\x16C8', '\x16CE', '\a', '\x160', 
		'\x2', '\x2', '\x16C9', '\x16CB', '\a', '\x99', '\x2', '\x2', '\x16CA', 
		'\x16CC', '\t', 'T', '\x2', '\x2', '\x16CB', '\x16CA', '\x3', '\x2', '\x2', 
		'\x2', '\x16CB', '\x16CC', '\x3', '\x2', '\x2', '\x2', '\x16CC', '\x16CE', 
		'\x3', '\x2', '\x2', '\x2', '\x16CD', '\x16C7', '\x3', '\x2', '\x2', '\x2', 
		'\x16CD', '\x16C8', '\x3', '\x2', '\x2', '\x2', '\x16CD', '\x16C9', '\x3', 
		'\x2', '\x2', '\x2', '\x16CE', '\x16CF', '\x3', '\x2', '\x2', '\x2', '\x16CF', 
		'\x16D0', '\a', '\x168', '\x2', '\x2', '\x16D0', '\x483', '\x3', '\x2', 
		'\x2', '\x2', '\x16D1', '\x16D3', '\x5', '\x44', '#', '\x2', '\x16D2', 
		'\x16D4', '\x5', '`', '\x31', '\x2', '\x16D3', '\x16D2', '\x3', '\x2', 
		'\x2', '\x2', '\x16D3', '\x16D4', '\x3', '\x2', '\x2', '\x2', '\x16D4', 
		'\x16D6', '\x3', '\x2', '\x2', '\x2', '\x16D5', '\x16D7', '\a', '\x213', 
		'\x2', '\x2', '\x16D6', '\x16D5', '\x3', '\x2', '\x2', '\x2', '\x16D6', 
		'\x16D7', '\x3', '\x2', '\x2', '\x2', '\x16D7', '\x16DA', '\x3', '\x2', 
		'\x2', '\x2', '\x16D8', '\x16D9', '\a', '\x184', '\x2', '\x2', '\x16D9', 
		'\x16DB', '\x5', '\x470', '\x239', '\x2', '\x16DA', '\x16D8', '\x3', '\x2', 
		'\x2', '\x2', '\x16DA', '\x16DB', '\x3', '\x2', '\x2', '\x2', '\x16DB', 
		'\x16DF', '\x3', '\x2', '\x2', '\x2', '\x16DC', '\x16DE', '\x5', '\x486', 
		'\x244', '\x2', '\x16DD', '\x16DC', '\x3', '\x2', '\x2', '\x2', '\x16DE', 
		'\x16E1', '\x3', '\x2', '\x2', '\x2', '\x16DF', '\x16DD', '\x3', '\x2', 
		'\x2', '\x2', '\x16DF', '\x16E0', '\x3', '\x2', '\x2', '\x2', '\x16E0', 
		'\x485', '\x3', '\x2', '\x2', '\x2', '\x16E1', '\x16DF', '\x3', '\x2', 
		'\x2', '\x2', '\x16E2', '\x16E3', '\x5', '\x488', '\x245', '\x2', '\x16E3', 
		'\x16E4', '\t', 'P', '\x2', '\x2', '\x16E4', '\x487', '\x3', '\x2', '\x2', 
		'\x2', '\x16E5', '\x16EA', '\a', '\xA0', '\x2', '\x2', '\x16E6', '\x16EA', 
		'\a', '\x160', '\x2', '\x2', '\x16E7', '\x16E8', '\a', 'y', '\x2', '\x2', 
		'\x16E8', '\x16EA', '\x5', '&', '\x14', '\x2', '\x16E9', '\x16E5', '\x3', 
		'\x2', '\x2', '\x2', '\x16E9', '\x16E6', '\x3', '\x2', '\x2', '\x2', '\x16E9', 
		'\x16E7', '\x3', '\x2', '\x2', '\x2', '\x16EA', '\x16EB', '\x3', '\x2', 
		'\x2', '\x2', '\x16EB', '\x16EC', '\a', '\x168', '\x2', '\x2', '\x16EC', 
		'\x489', '\x3', '\x2', '\x2', '\x2', '\x16ED', '\x16EF', '\a', '\x13F', 
		'\x2', '\x2', '\x16EE', '\x16F0', '\a', '\x184', '\x2', '\x2', '\x16EF', 
		'\x16EE', '\x3', '\x2', '\x2', '\x2', '\x16EF', '\x16F0', '\x3', '\x2', 
		'\x2', '\x2', '\x16F0', '\x16F1', '\x3', '\x2', '\x2', '\x2', '\x16F1', 
		'\x16F2', '\x5', '\x470', '\x239', '\x2', '\x16F2', '\x16F3', '\x5', '\x472', 
		'\x23A', '\x2', '\x16F3', '\x48B', '\x3', '\x2', '\x2', '\x2', '\x16F4', 
		'\x16F5', '\x5', '\x44', '#', '\x2', '\x16F5', '\x16F6', '\a', '\xBE', 
		'\x2', '\x2', '\x16F6', '\x16F7', '\a', '\x172', '\x2', '\x2', '\x16F7', 
		'\x48D', '\x3', '\x2', '\x2', '\x2', '\x16F8', '\x16FA', '\x5', '\x49A', 
		'\x24E', '\x2', '\x16F9', '\x16FB', '\x5', '\x4C2', '\x262', '\x2', '\x16FA', 
		'\x16F9', '\x3', '\x2', '\x2', '\x2', '\x16FA', '\x16FB', '\x3', '\x2', 
		'\x2', '\x2', '\x16FB', '\x1701', '\x3', '\x2', '\x2', '\x2', '\x16FC', 
		'\x16FE', '\x5', '\x4C2', '\x262', '\x2', '\x16FD', '\x16FF', '\x5', '\x49A', 
		'\x24E', '\x2', '\x16FE', '\x16FD', '\x3', '\x2', '\x2', '\x2', '\x16FE', 
		'\x16FF', '\x3', '\x2', '\x2', '\x2', '\x16FF', '\x1701', '\x3', '\x2', 
		'\x2', '\x2', '\x1700', '\x16F8', '\x3', '\x2', '\x2', '\x2', '\x1700', 
		'\x16FC', '\x3', '\x2', '\x2', '\x2', '\x1701', '\x48F', '\x3', '\x2', 
		'\x2', '\x2', '\x1702', '\x1703', '\a', '\x243', '\x2', '\x2', '\x1703', 
		'\x1707', '\a', '\x24D', '\x2', '\x2', '\x1704', '\x1705', '\x5', '\x492', 
		'\x24A', '\x2', '\x1705', '\x1706', '\a', '\x24F', '\x2', '\x2', '\x1706', 
		'\x1708', '\x3', '\x2', '\x2', '\x2', '\x1707', '\x1704', '\x3', '\x2', 
		'\x2', '\x2', '\x1707', '\x1708', '\x3', '\x2', '\x2', '\x2', '\x1708', 
		'\x1709', '\x3', '\x2', '\x2', '\x2', '\x1709', '\x170A', '\x5', '&', 
		'\x14', '\x2', '\x170A', '\x170B', '\x5', '\x494', '\x24B', '\x2', '\x170B', 
		'\x170C', '\a', '\x24E', '\x2', '\x2', '\x170C', '\x491', '\x3', '\x2', 
		'\x2', '\x2', '\x170D', '\x170E', '\a', '\x240', '\x2', '\x2', '\x170E', 
		'\x1710', '\a', '\x24D', '\x2', '\x2', '\x170F', '\x1711', '\x5', '\x16A', 
		'\xB6', '\x2', '\x1710', '\x170F', '\x3', '\x2', '\x2', '\x2', '\x1710', 
		'\x1711', '\x3', '\x2', '\x2', '\x2', '\x1711', '\x1714', '\x3', '\x2', 
		'\x2', '\x2', '\x1712', '\x1713', '\a', 'y', '\x2', '\x2', '\x1713', '\x1715', 
		'\x5', '&', '\x14', '\x2', '\x1714', '\x1712', '\x3', '\x2', '\x2', '\x2', 
		'\x1714', '\x1715', '\x3', '\x2', '\x2', '\x2', '\x1715', '\x1716', '\x3', 
		'\x2', '\x2', '\x2', '\x1716', '\x1717', '\a', '\x24E', '\x2', '\x2', 
		'\x1717', '\x493', '\x3', '\x2', '\x2', '\x2', '\x1718', '\x171A', '\x5', 
		'\x496', '\x24C', '\x2', '\x1719', '\x1718', '\x3', '\x2', '\x2', '\x2', 
		'\x1719', '\x171A', '\x3', '\x2', '\x2', '\x2', '\x171A', '\x1724', '\x3', 
		'\x2', '\x2', '\x2', '\x171B', '\x171C', '\a', 'L', '\x2', '\x2', '\x171C', 
		'\x1721', '\x5', '\x498', '\x24D', '\x2', '\x171D', '\x171E', '\a', '\x24F', 
		'\x2', '\x2', '\x171E', '\x1720', '\x5', '\x498', '\x24D', '\x2', '\x171F', 
		'\x171D', '\x3', '\x2', '\x2', '\x2', '\x1720', '\x1723', '\x3', '\x2', 
		'\x2', '\x2', '\x1721', '\x171F', '\x3', '\x2', '\x2', '\x2', '\x1721', 
		'\x1722', '\x3', '\x2', '\x2', '\x2', '\x1722', '\x1725', '\x3', '\x2', 
		'\x2', '\x2', '\x1723', '\x1721', '\x3', '\x2', '\x2', '\x2', '\x1724', 
		'\x171B', '\x3', '\x2', '\x2', '\x2', '\x1724', '\x1725', '\x3', '\x2', 
		'\x2', '\x2', '\x1725', '\x495', '\x3', '\x2', '\x2', '\x2', '\x1726', 
		'\x1729', '\a', '\x182', '\x2', '\x2', '\x1727', '\x1728', '\a', '\x33', 
		'\x2', '\x2', '\x1728', '\x172A', '\a', '\x227', '\x2', '\x2', '\x1729', 
		'\x1727', '\x3', '\x2', '\x2', '\x2', '\x1729', '\x172A', '\x3', '\x2', 
		'\x2', '\x2', '\x172A', '\x172B', '\x3', '\x2', '\x2', '\x2', '\x172B', 
		'\x172C', '\x5', '\x16A', '\xB6', '\x2', '\x172C', '\x497', '\x3', '\x2', 
		'\x2', '\x2', '\x172D', '\x1739', '\x5', '\xA0', 'Q', '\x2', '\x172E', 
		'\x172F', '\a', '\xBE', '\x2', '\x2', '\x172F', '\x173A', '\a', '\x172', 
		'\x2', '\x2', '\x1730', '\x1733', '\x5', '`', '\x31', '\x2', '\x1731', 
		'\x1732', '\a', '\x184', '\x2', '\x2', '\x1732', '\x1734', '\x5', '&', 
		'\x14', '\x2', '\x1733', '\x1731', '\x3', '\x2', '\x2', '\x2', '\x1733', 
		'\x1734', '\x3', '\x2', '\x2', '\x2', '\x1734', '\x1737', '\x3', '\x2', 
		'\x2', '\x2', '\x1735', '\x1736', '\a', 'y', '\x2', '\x2', '\x1736', '\x1738', 
		'\x5', '\xA0', 'Q', '\x2', '\x1737', '\x1735', '\x3', '\x2', '\x2', '\x2', 
		'\x1737', '\x1738', '\x3', '\x2', '\x2', '\x2', '\x1738', '\x173A', '\x3', 
		'\x2', '\x2', '\x2', '\x1739', '\x172E', '\x3', '\x2', '\x2', '\x2', '\x1739', 
		'\x1730', '\x3', '\x2', '\x2', '\x2', '\x173A', '\x499', '\x3', '\x2', 
		'\x2', '\x2', '\x173B', '\x173E', '\x5', '\x49C', '\x24F', '\x2', '\x173C', 
		'\x173E', '\x5', '\x4B2', '\x25A', '\x2', '\x173D', '\x173B', '\x3', '\x2', 
		'\x2', '\x2', '\x173D', '\x173C', '\x3', '\x2', '\x2', '\x2', '\x173E', 
		'\x49B', '\x3', '\x2', '\x2', '\x2', '\x173F', '\x1741', '\a', '\x18E', 
		'\x2', '\x2', '\x1740', '\x1742', '\a', '\x23D', '\x2', '\x2', '\x1741', 
		'\x1740', '\x3', '\x2', '\x2', '\x2', '\x1741', '\x1742', '\x3', '\x2', 
		'\x2', '\x2', '\x1742', '\x1743', '\x3', '\x2', '\x2', '\x2', '\x1743', 
		'\x1744', '\x5', '\x49E', '\x250', '\x2', '\x1744', '\x49D', '\x3', '\x2', 
		'\x2', '\x2', '\x1745', '\x1746', '\a', '\x24D', '\x2', '\x2', '\x1746', 
		'\x1747', '\x5', '\x16A', '\xB6', '\x2', '\x1747', '\x1748', '\x5', '\x4A0', 
		'\x251', '\x2', '\x1748', '\x1749', '\x5', '\x4A6', '\x254', '\x2', '\x1749', 
		'\x174A', '\a', '\x24E', '\x2', '\x2', '\x174A', '\x49F', '\x3', '\x2', 
		'\x2', '\x2', '\x174B', '\x174C', '\a', '\xBE', '\x2', '\x2', '\x174C', 
		'\x174D', '\x5', '\x4A2', '\x252', '\x2', '\x174D', '\x4A1', '\x3', '\x2', 
		'\x2', '\x2', '\x174E', '\x1751', '\x5', '\x4A4', '\x253', '\x2', '\x174F', 
		'\x1751', '\x5', '\x42', '\"', '\x2', '\x1750', '\x174E', '\x3', '\x2', 
		'\x2', '\x2', '\x1750', '\x174F', '\x3', '\x2', '\x2', '\x2', '\x1751', 
		'\x4A3', '\x3', '\x2', '\x2', '\x2', '\x1752', '\x1753', '\a', '\x24D', 
		'\x2', '\x2', '\x1753', '\x1754', '\x5', '\x178', '\xBD', '\x2', '\x1754', 
		'\x1755', '\a', '\x24E', '\x2', '\x2', '\x1755', '\x4A5', '\x3', '\x2', 
		'\x2', '\x2', '\x1756', '\x1759', '\a', '\xDE', '\x2', '\x2', '\x1757', 
		'\x175A', '\x5', '\x160', '\xB1', '\x2', '\x1758', '\x175A', '\x5', '\x4A8', 
		'\x255', '\x2', '\x1759', '\x1757', '\x3', '\x2', '\x2', '\x2', '\x1759', 
		'\x1758', '\x3', '\x2', '\x2', '\x2', '\x175A', '\x4A7', '\x3', '\x2', 
		'\x2', '\x2', '\x175B', '\x175C', '\a', '\x24D', '\x2', '\x2', '\x175C', 
		'\x1761', '\x5', '\x4AA', '\x256', '\x2', '\x175D', '\x175E', '\a', '\x24F', 
		'\x2', '\x2', '\x175E', '\x1760', '\x5', '\x4AA', '\x256', '\x2', '\x175F', 
		'\x175D', '\x3', '\x2', '\x2', '\x2', '\x1760', '\x1763', '\x3', '\x2', 
		'\x2', '\x2', '\x1761', '\x175F', '\x3', '\x2', '\x2', '\x2', '\x1761', 
		'\x1762', '\x3', '\x2', '\x2', '\x2', '\x1762', '\x1764', '\x3', '\x2', 
		'\x2', '\x2', '\x1763', '\x1761', '\x3', '\x2', '\x2', '\x2', '\x1764', 
		'\x1765', '\a', '\x24E', '\x2', '\x2', '\x1765', '\x4A9', '\x3', '\x2', 
		'\x2', '\x2', '\x1766', '\x176C', '\x5', '\x4AC', '\x257', '\x2', '\x1767', 
		'\x1769', '\x5', '\x4AE', '\x258', '\x2', '\x1768', '\x176A', '\x5', '\x176', 
		'\xBC', '\x2', '\x1769', '\x1768', '\x3', '\x2', '\x2', '\x2', '\x1769', 
		'\x176A', '\x3', '\x2', '\x2', '\x2', '\x176A', '\x176C', '\x3', '\x2', 
		'\x2', '\x2', '\x176B', '\x1766', '\x3', '\x2', '\x2', '\x2', '\x176B', 
		'\x1767', '\x3', '\x2', '\x2', '\x2', '\x176C', '\x4AB', '\x3', '\x2', 
		'\x2', '\x2', '\x176D', '\x176E', '\a', '\x11', '\x2', '\x2', '\x176E', 
		'\x4AD', '\x3', '\x2', '\x2', '\x2', '\x176F', '\x1772', '\x5', '\x4B0', 
		'\x259', '\x2', '\x1770', '\x1772', '\x5', '\xA0', 'Q', '\x2', '\x1771', 
		'\x176F', '\x3', '\x2', '\x2', '\x2', '\x1771', '\x1770', '\x3', '\x2', 
		'\x2', '\x2', '\x1772', '\x4AF', '\x3', '\x2', '\x2', '\x2', '\x1773', 
		'\x1774', '\a', '\x24D', '\x2', '\x2', '\x1774', '\x1775', '\x5', '\x16A', 
		'\xB6', '\x2', '\x1775', '\x1776', '\a', '\x24E', '\x2', '\x2', '\x1776', 
		'\x4B1', '\x3', '\x2', '\x2', '\x2', '\x1777', '\x177C', '\a', '\x21D', 
		'\x2', '\x2', '\x1778', '\x1779', '\a', '\xDF', '\x2', '\x2', '\x1779', 
		'\x177D', '\a', '\x161', '\x2', '\x2', '\x177A', '\x177B', '\a', '\xA8', 
		'\x2', '\x2', '\x177B', '\x177D', '\a', '\x161', '\x2', '\x2', '\x177C', 
		'\x1778', '\x3', '\x2', '\x2', '\x2', '\x177C', '\x177A', '\x3', '\x2', 
		'\x2', '\x2', '\x177C', '\x177D', '\x3', '\x2', '\x2', '\x2', '\x177D', 
		'\x177E', '\x3', '\x2', '\x2', '\x2', '\x177E', '\x177F', '\x5', '\x4B4', 
		'\x25B', '\x2', '\x177F', '\x4B3', '\x3', '\x2', '\x2', '\x2', '\x1780', 
		'\x1781', '\a', '\x24D', '\x2', '\x2', '\x1781', '\x1782', '\x5', '\x4A2', 
		'\x252', '\x2', '\x1782', '\x1783', '\x5', '\x4A0', '\x251', '\x2', '\x1783', 
		'\x1784', '\x5', '\x4B6', '\x25C', '\x2', '\x1784', '\x1785', '\a', '\x24E', 
		'\x2', '\x2', '\x1785', '\x4B5', '\x3', '\x2', '\x2', '\x2', '\x1786', 
		'\x1787', '\a', '\xDE', '\x2', '\x2', '\x1787', '\x1788', '\x5', '\x4B8', 
		'\x25D', '\x2', '\x1788', '\x4B7', '\x3', '\x2', '\x2', '\x2', '\x1789', 
		'\x178A', '\a', '\x24D', '\x2', '\x2', '\x178A', '\x178F', '\x5', '\x4BA', 
		'\x25E', '\x2', '\x178B', '\x178C', '\a', '\x24F', '\x2', '\x2', '\x178C', 
		'\x178E', '\x5', '\x4BA', '\x25E', '\x2', '\x178D', '\x178B', '\x3', '\x2', 
		'\x2', '\x2', '\x178E', '\x1791', '\x3', '\x2', '\x2', '\x2', '\x178F', 
		'\x178D', '\x3', '\x2', '\x2', '\x2', '\x178F', '\x1790', '\x3', '\x2', 
		'\x2', '\x2', '\x1790', '\x1792', '\x3', '\x2', '\x2', '\x2', '\x1791', 
		'\x178F', '\x3', '\x2', '\x2', '\x2', '\x1792', '\x1793', '\a', '\x24E', 
		'\x2', '\x2', '\x1793', '\x4B9', '\x3', '\x2', '\x2', '\x2', '\x1794', 
		'\x1796', '\x5', '\x4A2', '\x252', '\x2', '\x1795', '\x1797', '\x5', '\x4BC', 
		'\x25F', '\x2', '\x1796', '\x1795', '\x3', '\x2', '\x2', '\x2', '\x1796', 
		'\x1797', '\x3', '\x2', '\x2', '\x2', '\x1797', '\x4BB', '\x3', '\x2', 
		'\x2', '\x2', '\x1798', '\x1799', '\a', '\x15', '\x2', '\x2', '\x1799', 
		'\x179A', '\x5', '\x4BE', '\x260', '\x2', '\x179A', '\x4BD', '\x3', '\x2', 
		'\x2', '\x2', '\x179B', '\x179E', '\x5', '\x4C0', '\x261', '\x2', '\x179C', 
		'\x179E', '\x5', '&', '\x14', '\x2', '\x179D', '\x179B', '\x3', '\x2', 
		'\x2', '\x2', '\x179D', '\x179C', '\x3', '\x2', '\x2', '\x2', '\x179E', 
		'\x4BF', '\x3', '\x2', '\x2', '\x2', '\x179F', '\x17A0', '\a', '\x24D', 
		'\x2', '\x2', '\x17A0', '\x17A5', '\x5', '&', '\x14', '\x2', '\x17A1', 
		'\x17A2', '\a', '\x24F', '\x2', '\x2', '\x17A2', '\x17A4', '\x5', '&', 
		'\x14', '\x2', '\x17A3', '\x17A1', '\x3', '\x2', '\x2', '\x2', '\x17A4', 
		'\x17A7', '\x3', '\x2', '\x2', '\x2', '\x17A5', '\x17A3', '\x3', '\x2', 
		'\x2', '\x2', '\x17A5', '\x17A6', '\x3', '\x2', '\x2', '\x2', '\x17A6', 
		'\x17A8', '\x3', '\x2', '\x2', '\x2', '\x17A7', '\x17A5', '\x3', '\x2', 
		'\x2', '\x2', '\x17A8', '\x17A9', '\a', '\x24E', '\x2', '\x2', '\x17A9', 
		'\x4C1', '\x3', '\x2', '\x2', '\x2', '\x17AA', '\x17AD', '\x5', '\x4C4', 
		'\x263', '\x2', '\x17AB', '\x17AD', '\x5', '\x4C6', '\x264', '\x2', '\x17AC', 
		'\x17AA', '\x3', '\x2', '\x2', '\x2', '\x17AC', '\x17AB', '\x3', '\x2', 
		'\x2', '\x2', '\x17AD', '\x4C3', '\x3', '\x2', '\x2', '\x2', '\x17AE', 
		'\x17AF', '\a', '\x15', '\x2', '\x2', '\x17AF', '\x17B4', '\a', '\x164', 
		'\x2', '\x2', '\x17B0', '\x17B1', '\x5', '\x4CA', '\x266', '\x2', '\x17B1', 
		'\x17B2', '\x5', '\x16A', '\xB6', '\x2', '\x17B2', '\x17B5', '\x3', '\x2', 
		'\x2', '\x2', '\x17B3', '\x17B5', '\x5', '\x4C8', '\x265', '\x2', '\x17B4', 
		'\x17B0', '\x3', '\x2', '\x2', '\x2', '\x17B4', '\x17B3', '\x3', '\x2', 
		'\x2', '\x2', '\x17B5', '\x4C5', '\x3', '\x2', '\x2', '\x2', '\x17B6', 
		'\x17BA', '\a', '\x22E', '\x2', '\x2', '\x17B7', '\x17B8', '\a', '&', 
		'\x2', '\x2', '\x17B8', '\x17BB', '\x5', '\x4CA', '\x266', '\x2', '\x17B9', 
		'\x17BB', '\x5', '\x4C8', '\x265', '\x2', '\x17BA', '\x17B7', '\x3', '\x2', 
		'\x2', '\x2', '\x17BA', '\x17B9', '\x3', '\x2', '\x2', '\x2', '\x17BB', 
		'\x17BC', '\x3', '\x2', '\x2', '\x2', '\x17BC', '\x17BD', '\x5', '\xC6', 
		'\x64', '\x2', '\x17BD', '\x17BE', '\a', '\x10', '\x2', '\x2', '\x17BE', 
		'\x17BF', '\x5', '\xC6', '\x64', '\x2', '\x17BF', '\x4C7', '\x3', '\x2', 
		'\x2', '\x2', '\x17C0', '\x17C1', '\a', '\x18B', '\x2', '\x2', '\x17C1', 
		'\x17C2', '\a', '\xBE', '\x2', '\x2', '\x17C2', '\x17C5', '\x5', '\x42', 
		'\"', '\x2', '\x17C3', '\x17C6', '\x5', '\xA0', 'Q', '\x2', '\x17C4', 
		'\x17C6', '\a', '&', '\x2', '\x2', '\x17C5', '\x17C3', '\x3', '\x2', '\x2', 
		'\x2', '\x17C5', '\x17C4', '\x3', '\x2', '\x2', '\x2', '\x17C6', '\x4C9', 
		'\x3', '\x2', '\x2', '\x2', '\x17C7', '\x17C8', '\t', 'U', '\x2', '\x2', 
		'\x17C8', '\x4CB', '\x3', '\x2', '\x2', '\x2', '\x17C9', '\x17CB', '\a', 
		'\x1C6', '\x2', '\x2', '\x17CA', '\x17CC', '\a', ')', '\x2', '\x2', '\x17CB', 
		'\x17CA', '\x3', '\x2', '\x2', '\x2', '\x17CB', '\x17CC', '\x3', '\x2', 
		'\x2', '\x2', '\x17CC', '\x17CD', '\x3', '\x2', '\x2', '\x2', '\x17CD', 
		'\x17CF', '\x5', '\x4D0', '\x269', '\x2', '\x17CE', '\x17D0', '\x5', '\x4CE', 
		'\x268', '\x2', '\x17CF', '\x17CE', '\x3', '\x2', '\x2', '\x2', '\x17CF', 
		'\x17D0', '\x3', '\x2', '\x2', '\x2', '\x17D0', '\x4CD', '\x3', '\x2', 
		'\x2', '\x2', '\x17D1', '\x17D2', '\a', '\x1D0', '\x2', '\x2', '\x17D2', 
		'\x17D3', '\x5', '\x4D0', '\x269', '\x2', '\x17D3', '\x4CF', '\x3', '\x2', 
		'\x2', '\x2', '\x17D4', '\x17D5', '\a', '\x24D', '\x2', '\x2', '\x17D5', 
		'\x17D6', '\x5', '\xA0', 'Q', '\x2', '\x17D6', '\x17D7', '\a', '\x24E', 
		'\x2', '\x2', '\x17D7', '\x4D1', '\x3', '\x2', '\x2', '\x2', '\x17D8', 
		'\x17DA', '\a', '\x15', '\x2', '\x2', '\x17D9', '\x17D8', '\x3', '\x2', 
		'\x2', '\x2', '\x17D9', '\x17DA', '\x3', '\x2', '\x2', '\x2', '\x17DA', 
		'\x17DB', '\x3', '\x2', '\x2', '\x2', '\x17DB', '\x17DC', '\x5', '\\', 
		'/', '\x2', '\x17DC', '\x4D3', '\x3', '\x2', '\x2', '\x2', '\x17DD', '\x17DE', 
		'\x5', 'Z', '.', '\x2', '\x17DE', '\x4D5', '\x3', '\x2', '\x2', '\x2', 
		'\x17DF', '\x17E0', '\a', '\x24D', '\x2', '\x2', '\x17E0', '\x17E1', '\x5', 
		'\x178', '\xBD', '\x2', '\x17E1', '\x17E2', '\a', '\x24E', '\x2', '\x2', 
		'\x17E2', '\x4D7', '\x3', '\x2', '\x2', '\x2', '\x17E3', '\x17E9', '\a', 
		'\x228', '\x2', '\x2', '\x17E4', '\x17E5', '\a', '\x24D', '\x2', '\x2', 
		'\x17E5', '\x17E6', '\x5', '\x4DA', '\x26E', '\x2', '\x17E6', '\x17E7', 
		'\a', '\x24E', '\x2', '\x2', '\x17E7', '\x17EA', '\x3', '\x2', '\x2', 
		'\x2', '\x17E8', '\x17EA', '\x5', '\x42', '\"', '\x2', '\x17E9', '\x17E4', 
		'\x3', '\x2', '\x2', '\x2', '\x17E9', '\x17E8', '\x3', '\x2', '\x2', '\x2', 
		'\x17EA', '\x4D9', '\x3', '\x2', '\x2', '\x2', '\x17EB', '\x17EC', '\x5', 
		'\x16A', '\xB6', '\x2', '\x17EC', '\x4DB', '\x3', '\x2', '\x2', '\x2', 
		'\x17ED', '\x17F1', '\a', '\xEC', '\x2', '\x2', '\x17EE', '\x17F2', '\x5', 
		'\x4DE', '\x270', '\x2', '\x17EF', '\x17F2', '\x5', '\x4E0', '\x271', 
		'\x2', '\x17F0', '\x17F2', '\x5', '\x4E4', '\x273', '\x2', '\x17F1', '\x17EE', 
		'\x3', '\x2', '\x2', '\x2', '\x17F1', '\x17EF', '\x3', '\x2', '\x2', '\x2', 
		'\x17F1', '\x17F0', '\x3', '\x2', '\x2', '\x2', '\x17F2', '\x4DD', '\x3', 
		'\x2', '\x2', '\x2', '\x17F3', '\x17F4', '\a', '\xF3', '\x2', '\x2', '\x17F4', 
		'\x17F6', '\x5', '\x468', '\x235', '\x2', '\x17F5', '\x17F7', '\x5', '\x4D6', 
		'\x26C', '\x2', '\x17F6', '\x17F5', '\x3', '\x2', '\x2', '\x2', '\x17F6', 
		'\x17F7', '\x3', '\x2', '\x2', '\x2', '\x17F7', '\x17FA', '\x3', '\x2', 
		'\x2', '\x2', '\x17F8', '\x17FB', '\x5', '\x4D8', '\x26D', '\x2', '\x17F9', 
		'\x17FB', '\x5', '\x3F6', '\x1FC', '\x2', '\x17FA', '\x17F8', '\x3', '\x2', 
		'\x2', '\x2', '\x17FA', '\x17F9', '\x3', '\x2', '\x2', '\x2', '\x17FB', 
		'\x17FD', '\x3', '\x2', '\x2', '\x2', '\x17FC', '\x17FE', '\x5', '\x3F2', 
		'\x1FA', '\x2', '\x17FD', '\x17FC', '\x3', '\x2', '\x2', '\x2', '\x17FD', 
		'\x17FE', '\x3', '\x2', '\x2', '\x2', '\x17FE', '\x1800', '\x3', '\x2', 
		'\x2', '\x2', '\x17FF', '\x1801', '\x5', '\x524', '\x293', '\x2', '\x1800', 
		'\x17FF', '\x3', '\x2', '\x2', '\x2', '\x1800', '\x1801', '\x3', '\x2', 
		'\x2', '\x2', '\x1801', '\x4DF', '\x3', '\x2', '\x2', '\x2', '\x1802', 
		'\x1804', '\a', '\n', '\x2', '\x2', '\x1803', '\x1805', '\x5', '\x4E2', 
		'\x272', '\x2', '\x1804', '\x1803', '\x3', '\x2', '\x2', '\x2', '\x1805', 
		'\x1806', '\x3', '\x2', '\x2', '\x2', '\x1806', '\x1804', '\x3', '\x2', 
		'\x2', '\x2', '\x1806', '\x1807', '\x3', '\x2', '\x2', '\x2', '\x1807', 
		'\x1808', '\x3', '\x2', '\x2', '\x2', '\x1808', '\x1809', '\x5', '\x3F6', 
		'\x1FC', '\x2', '\x1809', '\x4E1', '\x3', '\x2', '\x2', '\x2', '\x180A', 
		'\x180B', '\a', '\xF3', '\x2', '\x2', '\x180B', '\x180D', '\x5', '\x468', 
		'\x235', '\x2', '\x180C', '\x180E', '\x5', '\x4D6', '\x26C', '\x2', '\x180D', 
		'\x180C', '\x3', '\x2', '\x2', '\x2', '\x180D', '\x180E', '\x3', '\x2', 
		'\x2', '\x2', '\x180E', '\x1810', '\x3', '\x2', '\x2', '\x2', '\x180F', 
		'\x1811', '\x5', '\x4D8', '\x26D', '\x2', '\x1810', '\x180F', '\x3', '\x2', 
		'\x2', '\x2', '\x1810', '\x1811', '\x3', '\x2', '\x2', '\x2', '\x1811', 
		'\x1813', '\x3', '\x2', '\x2', '\x2', '\x1812', '\x1814', '\x5', '\x524', 
		'\x293', '\x2', '\x1813', '\x1812', '\x3', '\x2', '\x2', '\x2', '\x1813', 
		'\x1814', '\x3', '\x2', '\x2', '\x2', '\x1814', '\x4E3', '\x3', '\x2', 
		'\x2', '\x2', '\x1815', '\x1817', '\t', 'V', '\x2', '\x2', '\x1816', '\x1815', 
		'\x3', '\x2', '\x2', '\x2', '\x1816', '\x1817', '\x3', '\x2', '\x2', '\x2', 
		'\x1817', '\x1819', '\x3', '\x2', '\x2', '\x2', '\x1818', '\x181A', '\x5', 
		'\x4E6', '\x274', '\x2', '\x1819', '\x1818', '\x3', '\x2', '\x2', '\x2', 
		'\x181A', '\x181B', '\x3', '\x2', '\x2', '\x2', '\x181B', '\x1819', '\x3', 
		'\x2', '\x2', '\x2', '\x181B', '\x181C', '\x3', '\x2', '\x2', '\x2', '\x181C', 
		'\x181E', '\x3', '\x2', '\x2', '\x2', '\x181D', '\x181F', '\x5', '\x4EA', 
		'\x276', '\x2', '\x181E', '\x181D', '\x3', '\x2', '\x2', '\x2', '\x181E', 
		'\x181F', '\x3', '\x2', '\x2', '\x2', '\x181F', '\x1820', '\x3', '\x2', 
		'\x2', '\x2', '\x1820', '\x1821', '\x5', '\x3F6', '\x1FC', '\x2', '\x1821', 
		'\x4E5', '\x3', '\x2', '\x2', '\x2', '\x1822', '\x1823', '\a', '\x233', 
		'\x2', '\x2', '\x1823', '\x1824', '\x5', '\xA0', 'Q', '\x2', '\x1824', 
		'\x1825', '\x5', '\x4E8', '\x275', '\x2', '\x1825', '\x4E7', '\x3', '\x2', 
		'\x2', '\x2', '\x1826', '\x1828', '\a', '\x204', '\x2', '\x2', '\x1827', 
		'\x1829', '\x5', '\x4E2', '\x272', '\x2', '\x1828', '\x1827', '\x3', '\x2', 
		'\x2', '\x2', '\x1829', '\x182A', '\x3', '\x2', '\x2', '\x2', '\x182A', 
		'\x1828', '\x3', '\x2', '\x2', '\x2', '\x182A', '\x182B', '\x3', '\x2', 
		'\x2', '\x2', '\x182B', '\x4E9', '\x3', '\x2', '\x2', '\x2', '\x182C', 
		'\x182E', '\a', '\x97', '\x2', '\x2', '\x182D', '\x182F', '\x5', '\x4E2', 
		'\x272', '\x2', '\x182E', '\x182D', '\x3', '\x2', '\x2', '\x2', '\x182F', 
		'\x1830', '\x3', '\x2', '\x2', '\x2', '\x1830', '\x182E', '\x3', '\x2', 
		'\x2', '\x2', '\x1830', '\x1831', '\x3', '\x2', '\x2', '\x2', '\x1831', 
		'\x4EB', '\x3', '\x2', '\x2', '\x2', '\x1832', '\x183C', '\a', '\x1DA', 
		'\x2', '\x2', '\x1833', '\x183D', '\x5', '\x4EE', '\x278', '\x2', '\x1834', 
		'\x1839', '\x5', '\x4F0', '\x279', '\x2', '\x1835', '\x1836', '\a', '\x24F', 
		'\x2', '\x2', '\x1836', '\x1838', '\x5', '\x4F0', '\x279', '\x2', '\x1837', 
		'\x1835', '\x3', '\x2', '\x2', '\x2', '\x1838', '\x183B', '\x3', '\x2', 
		'\x2', '\x2', '\x1839', '\x1837', '\x3', '\x2', '\x2', '\x2', '\x1839', 
		'\x183A', '\x3', '\x2', '\x2', '\x2', '\x183A', '\x183D', '\x3', '\x2', 
		'\x2', '\x2', '\x183B', '\x1839', '\x3', '\x2', '\x2', '\x2', '\x183C', 
		'\x1833', '\x3', '\x2', '\x2', '\x2', '\x183C', '\x1834', '\x3', '\x2', 
		'\x2', '\x2', '\x183D', '\x4ED', '\x3', '\x2', '\x2', '\x2', '\x183E', 
		'\x183F', '\a', '\x227', '\x2', '\x2', '\x183F', '\x1840', '\a', '\x24D', 
		'\x2', '\x2', '\x1840', '\x1841', '\x5', '\x42', '\"', '\x2', '\x1841', 
		'\x1842', '\a', '\x24E', '\x2', '\x2', '\x1842', '\x1843', '\a', '\x255', 
		'\x2', '\x2', '\x1843', '\x1844', '\x5', '\xA0', 'Q', '\x2', '\x1844', 
		'\x4EF', '\x3', '\x2', '\x2', '\x2', '\x1845', '\x184B', '\x5', '\x42', 
		'\"', '\x2', '\x1846', '\x1847', '\a', '\x24D', '\x2', '\x2', '\x1847', 
		'\x1848', '\x5', '\x42', '\"', '\x2', '\x1848', '\x1849', '\a', '\x24E', 
		'\x2', '\x2', '\x1849', '\x184B', '\x3', '\x2', '\x2', '\x2', '\x184A', 
		'\x1845', '\x3', '\x2', '\x2', '\x2', '\x184A', '\x1846', '\x3', '\x2', 
		'\x2', '\x2', '\x184B', '\x184C', '\x3', '\x2', '\x2', '\x2', '\x184C', 
		'\x1850', '\a', '\x255', '\x2', '\x2', '\x184D', '\x1851', '\x5', '\x160', 
		'\xB1', '\x2', '\x184E', '\x1851', '\x5', '\xA0', 'Q', '\x2', '\x184F', 
		'\x1851', '\x5', '\x16E', '\xB8', '\x2', '\x1850', '\x184D', '\x3', '\x2', 
		'\x2', '\x2', '\x1850', '\x184E', '\x3', '\x2', '\x2', '\x2', '\x1850', 
		'\x184F', '\x3', '\x2', '\x2', '\x2', '\x1851', '\x1857', '\x3', '\x2', 
		'\x2', '\x2', '\x1852', '\x1853', '\x5', '\x4F2', '\x27A', '\x2', '\x1853', 
		'\x1854', '\a', '\x255', '\x2', '\x2', '\x1854', '\x1855', '\x5', '\x160', 
		'\xB1', '\x2', '\x1855', '\x1857', '\x3', '\x2', '\x2', '\x2', '\x1856', 
		'\x184A', '\x3', '\x2', '\x2', '\x2', '\x1856', '\x1852', '\x3', '\x2', 
		'\x2', '\x2', '\x1857', '\x4F1', '\x3', '\x2', '\x2', '\x2', '\x1858', 
		'\x1859', '\a', '\x24D', '\x2', '\x2', '\x1859', '\x185A', '\x5', '\x178', 
		'\xBD', '\x2', '\x185A', '\x185B', '\a', '\x24E', '\x2', '\x2', '\x185B', 
		'\x4F3', '\x3', '\x2', '\x2', '\x2', '\x185C', '\x185F', '\a', '\x220', 
		'\x2', '\x2', '\x185D', '\x1860', '\x5', '\x3F4', '\x1FB', '\x2', '\x185E', 
		'\x1860', '\x5', '\x468', '\x235', '\x2', '\x185F', '\x185D', '\x3', '\x2', 
		'\x2', '\x2', '\x185F', '\x185E', '\x3', '\x2', '\x2', '\x2', '\x1860', 
		'\x1861', '\x3', '\x2', '\x2', '\x2', '\x1861', '\x1863', '\x5', '\x4EC', 
		'\x277', '\x2', '\x1862', '\x1864', '\x5', '\x42C', '\x217', '\x2', '\x1863', 
		'\x1862', '\x3', '\x2', '\x2', '\x2', '\x1863', '\x1864', '\x3', '\x2', 
		'\x2', '\x2', '\x1864', '\x1866', '\x3', '\x2', '\x2', '\x2', '\x1865', 
		'\x1867', '\x5', '\x3F2', '\x1FA', '\x2', '\x1866', '\x1865', '\x3', '\x2', 
		'\x2', '\x2', '\x1866', '\x1867', '\x3', '\x2', '\x2', '\x2', '\x1867', 
		'\x1869', '\x3', '\x2', '\x2', '\x2', '\x1868', '\x186A', '\x5', '\x524', 
		'\x293', '\x2', '\x1869', '\x1868', '\x3', '\x2', '\x2', '\x2', '\x1869', 
		'\x186A', '\x3', '\x2', '\x2', '\x2', '\x186A', '\x4F5', '\x3', '\x2', 
		'\x2', '\x2', '\x186B', '\x186D', '\a', '}', '\x2', '\x2', '\x186C', '\x186E', 
		'\a', '\xC8', '\x2', '\x2', '\x186D', '\x186C', '\x3', '\x2', '\x2', '\x2', 
		'\x186D', '\x186E', '\x3', '\x2', '\x2', '\x2', '\x186E', '\x1871', '\x3', 
		'\x2', '\x2', '\x2', '\x186F', '\x1872', '\x5', '\x3F4', '\x1FB', '\x2', 
		'\x1870', '\x1872', '\x5', '\x468', '\x235', '\x2', '\x1871', '\x186F', 
		'\x3', '\x2', '\x2', '\x2', '\x1871', '\x1870', '\x3', '\x2', '\x2', '\x2', 
		'\x1872', '\x1874', '\x3', '\x2', '\x2', '\x2', '\x1873', '\x1875', '\x5', 
		'\x42C', '\x217', '\x2', '\x1874', '\x1873', '\x3', '\x2', '\x2', '\x2', 
		'\x1874', '\x1875', '\x3', '\x2', '\x2', '\x2', '\x1875', '\x1877', '\x3', 
		'\x2', '\x2', '\x2', '\x1876', '\x1878', '\x5', '\x3F2', '\x1FA', '\x2', 
		'\x1877', '\x1876', '\x3', '\x2', '\x2', '\x2', '\x1877', '\x1878', '\x3', 
		'\x2', '\x2', '\x2', '\x1878', '\x187A', '\x3', '\x2', '\x2', '\x2', '\x1879', 
		'\x187B', '\x5', '\x524', '\x293', '\x2', '\x187A', '\x1879', '\x3', '\x2', 
		'\x2', '\x2', '\x187A', '\x187B', '\x3', '\x2', '\x2', '\x2', '\x187B', 
		'\x4F7', '\x3', '\x2', '\x2', '\x2', '\x187C', '\x187D', '\a', '\x44', 
		'\x2', '\x2', '\x187D', '\x187E', '\x5', '\x42', '\"', '\x2', '\x187E', 
		'\x4F9', '\x3', '\x2', '\x2', '\x2', '\x187F', '\x1880', '\a', '\xB6', 
		'\x2', '\x2', '\x1880', '\x1883', '\x5', '\x42', '\"', '\x2', '\x1881', 
		'\x1884', '\x5', '\x4FC', '\x27F', '\x2', '\x1882', '\x1884', '\x5', '\x4FE', 
		'\x280', '\x2', '\x1883', '\x1881', '\x3', '\x2', '\x2', '\x2', '\x1883', 
		'\x1882', '\x3', '\x2', '\x2', '\x2', '\x1884', '\x1886', '\x3', '\x2', 
		'\x2', '\x2', '\x1885', '\x1887', '\x5', '\x500', '\x281', '\x2', '\x1886', 
		'\x1885', '\x3', '\x2', '\x2', '\x2', '\x1886', '\x1887', '\x3', '\x2', 
		'\x2', '\x2', '\x1887', '\x4FB', '\x3', '\x2', '\x2', '\x2', '\x1888', 
		'\x1889', '\a', '\xF3', '\x2', '\x2', '\x1889', '\x188A', '\x5', '\x178', 
		'\xBD', '\x2', '\x188A', '\x4FD', '\x3', '\x2', '\x2', '\x2', '\x188B', 
		'\x188C', '\a', '\x30', '\x2', '\x2', '\x188C', '\x188D', '\a', 'I', '\x2', 
		'\x2', '\x188D', '\x188E', '\a', '\xF3', '\x2', '\x2', '\x188E', '\x188F', 
		'\x5', '\x178', '\xBD', '\x2', '\x188F', '\x4FF', '\x3', '\x2', '\x2', 
		'\x2', '\x1890', '\x1891', '\a', '\x10D', '\x2', '\x2', '\x1891', '\x1892', 
		'\x5', '\xA0', 'Q', '\x2', '\x1892', '\x501', '\x3', '\x2', '\x2', '\x2', 
		'\x1893', '\x1894', '\a', '\x16C', '\x2', '\x2', '\x1894', '\x1896', '\x5', 
		'\x42', '\"', '\x2', '\x1895', '\x1897', '\x5', '\x504', '\x283', '\x2', 
		'\x1896', '\x1895', '\x3', '\x2', '\x2', '\x2', '\x1896', '\x1897', '\x3', 
		'\x2', '\x2', '\x2', '\x1897', '\x503', '\x3', '\x2', '\x2', '\x2', '\x1898', 
		'\x189E', '\a', '\xBE', '\x2', '\x2', '\x1899', '\x189F', '\x5', '\x3F6', 
		'\x1FC', '\x2', '\x189A', '\x189C', '\x5', '\xA0', 'Q', '\x2', '\x189B', 
		'\x189D', '\x5', '\x506', '\x284', '\x2', '\x189C', '\x189B', '\x3', '\x2', 
		'\x2', '\x2', '\x189C', '\x189D', '\x3', '\x2', '\x2', '\x2', '\x189D', 
		'\x189F', '\x3', '\x2', '\x2', '\x2', '\x189E', '\x1899', '\x3', '\x2', 
		'\x2', '\x2', '\x189E', '\x189A', '\x3', '\x2', '\x2', '\x2', '\x189F', 
		'\x505', '\x3', '\x2', '\x2', '\x2', '\x18A0', '\x18A1', '\a', '\x225', 
		'\x2', '\x2', '\x18A1', '\x18A6', '\x5', '\x508', '\x285', '\x2', '\x18A2', 
		'\x18A3', '\a', '\x24F', '\x2', '\x2', '\x18A3', '\x18A5', '\x5', '\x508', 
		'\x285', '\x2', '\x18A4', '\x18A2', '\x3', '\x2', '\x2', '\x2', '\x18A5', 
		'\x18A8', '\x3', '\x2', '\x2', '\x2', '\x18A6', '\x18A4', '\x3', '\x2', 
		'\x2', '\x2', '\x18A6', '\x18A7', '\x3', '\x2', '\x2', '\x2', '\x18A7', 
		'\x507', '\x3', '\x2', '\x2', '\x2', '\x18A8', '\x18A6', '\x3', '\x2', 
		'\x2', '\x2', '\x18A9', '\x18AA', '\a', '\xDE', '\x2', '\x2', '\x18AA', 
		'\x18AE', '\a', '\x174', '\x2', '\x2', '\x18AB', '\x18AE', '\a', '\xDE', 
		'\x2', '\x2', '\x18AC', '\x18AE', '\a', '\x174', '\x2', '\x2', '\x18AD', 
		'\x18A9', '\x3', '\x2', '\x2', '\x2', '\x18AD', '\x18AB', '\x3', '\x2', 
		'\x2', '\x2', '\x18AD', '\x18AC', '\x3', '\x2', '\x2', '\x2', '\x18AD', 
		'\x18AE', '\x3', '\x2', '\x2', '\x2', '\x18AE', '\x18AF', '\x3', '\x2', 
		'\x2', '\x2', '\x18AF', '\x18B0', '\x5', '\xA0', 'Q', '\x2', '\x18B0', 
		'\x509', '\x3', '\x2', '\x2', '\x2', '\x18B1', '\x18B3', '\a', 'N', '\x2', 
		'\x2', '\x18B2', '\x18B4', '\a', '\x239', '\x2', '\x2', '\x18B3', '\x18B2', 
		'\x3', '\x2', '\x2', '\x2', '\x18B3', '\x18B4', '\x3', '\x2', '\x2', '\x2', 
		'\x18B4', '\x18BB', '\x3', '\x2', '\x2', '\x2', '\x18B5', '\x18B7', '\x5', 
		'\x50C', '\x287', '\x2', '\x18B6', '\x18B8', '\x5', '\x50E', '\x288', 
		'\x2', '\x18B7', '\x18B6', '\x3', '\x2', '\x2', '\x2', '\x18B7', '\x18B8', 
		'\x3', '\x2', '\x2', '\x2', '\x18B8', '\x18BC', '\x3', '\x2', '\x2', '\x2', 
		'\x18B9', '\x18BC', '\x5', '\x50E', '\x288', '\x2', '\x18BA', '\x18BC', 
		'\x5', '\x510', '\x289', '\x2', '\x18BB', '\x18B5', '\x3', '\x2', '\x2', 
		'\x2', '\x18BB', '\x18B9', '\x3', '\x2', '\x2', '\x2', '\x18BB', '\x18BA', 
		'\x3', '\x2', '\x2', '\x2', '\x18BB', '\x18BC', '\x3', '\x2', '\x2', '\x2', 
		'\x18BC', '\x50B', '\x3', '\x2', '\x2', '\x2', '\x18BD', '\x18BE', '\a', 
		'M', '\x2', '\x2', '\x18BE', '\x18BF', '\x5', '&', '\x14', '\x2', '\x18BF', 
		'\x50D', '\x3', '\x2', '\x2', '\x2', '\x18C0', '\x18C2', '\a', '\x23C', 
		'\x2', '\x2', '\x18C1', '\x18C3', '\t', 'W', '\x2', '\x2', '\x18C2', '\x18C1', 
		'\x3', '\x2', '\x2', '\x2', '\x18C2', '\x18C3', '\x3', '\x2', '\x2', '\x2', 
		'\x18C3', '\x18C5', '\x3', '\x2', '\x2', '\x2', '\x18C4', '\x18C6', '\t', 
		'X', '\x2', '\x2', '\x18C5', '\x18C4', '\x3', '\x2', '\x2', '\x2', '\x18C5', 
		'\x18C6', '\x3', '\x2', '\x2', '\x2', '\x18C6', '\x50F', '\x3', '\x2', 
		'\x2', '\x2', '\x18C7', '\x18C8', '\a', '\xC0', '\x2', '\x2', '\x18C8', 
		'\x18CB', '\x5', '&', '\x14', '\x2', '\x18C9', '\x18CA', '\a', '\x24F', 
		'\x2', '\x2', '\x18CA', '\x18CC', '\a', '\x247', '\x2', '\x2', '\x18CB', 
		'\x18C9', '\x3', '\x2', '\x2', '\x2', '\x18CB', '\x18CC', '\x3', '\x2', 
		'\x2', '\x2', '\x18CC', '\x511', '\x3', '\x2', '\x2', '\x2', '\x18CD', 
		'\x18CE', '\a', '\x1DA', '\x2', '\x2', '\x18CE', '\x18D8', '\a', '\x20D', 
		'\x2', '\x2', '\x18CF', '\x18D3', '\x5', '\x516', '\x28C', '\x2', '\x18D0', 
		'\x18D3', '\x5', '\x518', '\x28D', '\x2', '\x18D1', '\x18D3', '\x5', '\x51A', 
		'\x28E', '\x2', '\x18D2', '\x18CF', '\x3', '\x2', '\x2', '\x2', '\x18D2', 
		'\x18D0', '\x3', '\x2', '\x2', '\x2', '\x18D2', '\x18D1', '\x3', '\x2', 
		'\x2', '\x2', '\x18D3', '\x18D5', '\x3', '\x2', '\x2', '\x2', '\x18D4', 
		'\x18D6', '\x5', '\x514', '\x28B', '\x2', '\x18D5', '\x18D4', '\x3', '\x2', 
		'\x2', '\x2', '\x18D5', '\x18D6', '\x3', '\x2', '\x2', '\x2', '\x18D6', 
		'\x18D9', '\x3', '\x2', '\x2', '\x2', '\x18D7', '\x18D9', '\x5', '\x514', 
		'\x28B', '\x2', '\x18D8', '\x18D2', '\x3', '\x2', '\x2', '\x2', '\x18D8', 
		'\x18D7', '\x3', '\x2', '\x2', '\x2', '\x18D9', '\x513', '\x3', '\x2', 
		'\x2', '\x2', '\x18DA', '\x18DB', '\a', '\x138', '\x2', '\x2', '\x18DB', 
		'\x18DC', '\x5', '&', '\x14', '\x2', '\x18DC', '\x515', '\x3', '\x2', 
		'\x2', '\x2', '\x18DD', '\x18DF', '\a', '\x1A2', '\x2', '\x2', '\x18DE', 
		'\x18E0', '\t', 'Y', '\x2', '\x2', '\x18DF', '\x18DE', '\x3', '\x2', '\x2', 
		'\x2', '\x18DF', '\x18E0', '\x3', '\x2', '\x2', '\x2', '\x18E0', '\x517', 
		'\x3', '\x2', '\x2', '\x2', '\x18E1', '\x18E2', '\a', '\xF8', '\x2', '\x2', 
		'\x18E2', '\x18E6', '\a', '\x106', '\x2', '\x2', '\x18E3', '\x18E7', '\a', 
		'\x1D5', '\x2', '\x2', '\x18E4', '\x18E5', '\a', '\x1A2', '\x2', '\x2', 
		'\x18E5', '\x18E7', '\a', 'O', '\x2', '\x2', '\x18E6', '\x18E3', '\x3', 
		'\x2', '\x2', '\x2', '\x18E6', '\x18E4', '\x3', '\x2', '\x2', '\x2', '\x18E6', 
		'\x18E7', '\x3', '\x2', '\x2', '\x2', '\x18E7', '\x519', '\x3', '\x2', 
		'\x2', '\x2', '\x18E8', '\x18E9', '\a', '\x223', '\x2', '\x2', '\x18E9', 
		'\x18EA', '\a', '\x1BD', '\x2', '\x2', '\x18EA', '\x18EB', '\a', '\x1D1', 
		'\x2', '\x2', '\x18EB', '\x18EC', '\x5', '\\', '/', '\x2', '\x18EC', '\x51B', 
		'\x3', '\x2', '\x2', '\x2', '\x18ED', '\x18EF', '\a', '\x1BD', '\x2', 
		'\x2', '\x18EE', '\x18F0', '\a', '\x239', '\x2', '\x2', '\x18EF', '\x18EE', 
		'\x3', '\x2', '\x2', '\x2', '\x18EF', '\x18F0', '\x3', '\x2', '\x2', '\x2', 
		'\x18F0', '\x18F2', '\x3', '\x2', '\x2', '\x2', '\x18F1', '\x18F3', '\x5', 
		'\x51E', '\x290', '\x2', '\x18F2', '\x18F1', '\x3', '\x2', '\x2', '\x2', 
		'\x18F2', '\x18F3', '\x3', '\x2', '\x2', '\x2', '\x18F3', '\x51D', '\x3', 
		'\x2', '\x2', '\x2', '\x18F4', '\x18F6', '\a', '\x20B', '\x2', '\x2', 
		'\x18F5', '\x18F7', '\a', '\x1C8', '\x2', '\x2', '\x18F6', '\x18F5', '\x3', 
		'\x2', '\x2', '\x2', '\x18F6', '\x18F7', '\x3', '\x2', '\x2', '\x2', '\x18F7', 
		'\x18F8', '\x3', '\x2', '\x2', '\x2', '\x18F8', '\x18F9', '\x5', 'N', 
		'(', '\x2', '\x18F9', '\x51F', '\x3', '\x2', '\x2', '\x2', '\x18FA', '\x18FB', 
		'\a', '\x1C8', '\x2', '\x2', '\x18FB', '\x18FC', '\x5', 'N', '(', '\x2', 
		'\x18FC', '\x521', '\x3', '\x2', '\x2', '\x2', '\x18FD', '\x18FE', '\x5', 
		'\x42', '\"', '\x2', '\x18FE', '\x18FF', '\a', '\x248', '\x2', '\x2', 
		'\x18FF', '\x1900', '\x5', '\xA0', 'Q', '\x2', '\x1900', '\x523', '\x3', 
		'\x2', '\x2', '\x2', '\x1901', '\x1902', '\a', '\x116', '\x2', '\x2', 
		'\x1902', '\x1904', '\a', '\xA1', '\x2', '\x2', '\x1903', '\x1905', '\x5', 
		'\x526', '\x294', '\x2', '\x1904', '\x1903', '\x3', '\x2', '\x2', '\x2', 
		'\x1904', '\x1905', '\x3', '\x2', '\x2', '\x2', '\x1905', '\x1907', '\x3', 
		'\x2', '\x2', '\x2', '\x1906', '\x1908', '\x5', '\x528', '\x295', '\x2', 
		'\x1907', '\x1906', '\x3', '\x2', '\x2', '\x2', '\x1907', '\x1908', '\x3', 
		'\x2', '\x2', '\x2', '\x1908', '\x190A', '\x3', '\x2', '\x2', '\x2', '\x1909', 
		'\x190B', '\x5', '\x52A', '\x296', '\x2', '\x190A', '\x1909', '\x3', '\x2', 
		'\x2', '\x2', '\x190A', '\x190B', '\x3', '\x2', '\x2', '\x2', '\x190B', 
		'\x525', '\x3', '\x2', '\x2', '\x2', '\x190C', '\x190D', '\a', '\xF3', 
		'\x2', '\x2', '\x190D', '\x190E', '\x5', '\x42', '\"', '\x2', '\x190E', 
		'\x527', '\x3', '\x2', '\x2', '\x2', '\x190F', '\x1910', '\a', '\x24D', 
		'\x2', '\x2', '\x1910', '\x1911', '\x5', '\xA0', 'Q', '\x2', '\x1911', 
		'\x1912', '\a', '\x24E', '\x2', '\x2', '\x1912', '\x529', '\x3', '\x2', 
		'\x2', '\x2', '\x1913', '\x1914', '\a', '\x1AC', '\x2', '\x2', '\x1914', 
		'\x1917', '\a', '\x10D', '\x2', '\x2', '\x1915', '\x1918', '\a', '\x21B', 
		'\x2', '\x2', '\x1916', '\x1918', '\x5', '&', '\x14', '\x2', '\x1917', 
		'\x1915', '\x3', '\x2', '\x2', '\x2', '\x1917', '\x1916', '\x3', '\x2', 
		'\x2', '\x2', '\x1918', '\x52B', '\x3', '\x2', '\x2', '\x2', '\x1919', 
		'\x191A', '\a', '\x12A', '\x2', '\x2', '\x191A', '\x191B', '\a', '\xF3', 
		'\x2', '\x2', '\x191B', '\x191C', '\x5', '\x468', '\x235', '\x2', '\x191C', 
		'\x191D', '\x5', '\x530', '\x299', '\x2', '\x191D', '\x191F', '\x5', '\x532', 
		'\x29A', '\x2', '\x191E', '\x1920', '\x5', '\x52E', '\x298', '\x2', '\x191F', 
		'\x191E', '\x3', '\x2', '\x2', '\x2', '\x191F', '\x1920', '\x3', '\x2', 
		'\x2', '\x2', '\x1920', '\x1922', '\x3', '\x2', '\x2', '\x2', '\x1921', 
		'\x1923', '\x5', '\x524', '\x293', '\x2', '\x1922', '\x1921', '\x3', '\x2', 
		'\x2', '\x2', '\x1922', '\x1923', '\x3', '\x2', '\x2', '\x2', '\x1923', 
		'\x52D', '\x3', '\x2', '\x2', '\x2', '\x1924', '\x1926', '\x5', '\x534', 
		'\x29B', '\x2', '\x1925', '\x1927', '\x5', '\x538', '\x29D', '\x2', '\x1926', 
		'\x1925', '\x3', '\x2', '\x2', '\x2', '\x1926', '\x1927', '\x3', '\x2', 
		'\x2', '\x2', '\x1927', '\x192D', '\x3', '\x2', '\x2', '\x2', '\x1928', 
		'\x192A', '\x5', '\x538', '\x29D', '\x2', '\x1929', '\x192B', '\x5', '\x534', 
		'\x29B', '\x2', '\x192A', '\x1929', '\x3', '\x2', '\x2', '\x2', '\x192A', 
		'\x192B', '\x3', '\x2', '\x2', '\x2', '\x192B', '\x192D', '\x3', '\x2', 
		'\x2', '\x2', '\x192C', '\x1924', '\x3', '\x2', '\x2', '\x2', '\x192C', 
		'\x1928', '\x3', '\x2', '\x2', '\x2', '\x192D', '\x52F', '\x3', '\x2', 
		'\x2', '\x2', '\x192E', '\x192F', '\a', '\x225', '\x2', '\x2', '\x192F', 
		'\x1930', '\x5', '\x468', '\x235', '\x2', '\x1930', '\x531', '\x3', '\x2', 
		'\x2', '\x2', '\x1931', '\x1932', '\a', '\x168', '\x2', '\x2', '\x1932', 
		'\x1933', '\a', '\x24D', '\x2', '\x2', '\x1933', '\x1934', '\x5', '\xA0', 
		'Q', '\x2', '\x1934', '\x1935', '\a', '\x24E', '\x2', '\x2', '\x1935', 
		'\x533', '\x3', '\x2', '\x2', '\x2', '\x1936', '\x1937', '\a', '\x233', 
		'\x2', '\x2', '\x1937', '\x1938', '\a', '\x120', '\x2', '\x2', '\x1938', 
		'\x1939', '\a', '\x204', '\x2', '\x2', '\x1939', '\x193A', '\a', '\x220', 
		'\x2', '\x2', '\x193A', '\x193C', '\x5', '\x4EC', '\x277', '\x2', '\x193B', 
		'\x193D', '\x5', '\x42C', '\x217', '\x2', '\x193C', '\x193B', '\x3', '\x2', 
		'\x2', '\x2', '\x193C', '\x193D', '\x3', '\x2', '\x2', '\x2', '\x193D', 
		'\x193F', '\x3', '\x2', '\x2', '\x2', '\x193E', '\x1940', '\x5', '\x536', 
		'\x29C', '\x2', '\x193F', '\x193E', '\x3', '\x2', '\x2', '\x2', '\x193F', 
		'\x1940', '\x3', '\x2', '\x2', '\x2', '\x1940', '\x535', '\x3', '\x2', 
		'\x2', '\x2', '\x1941', '\x1942', '\a', '}', '\x2', '\x2', '\x1942', '\x1943', 
		'\x5', '\x42C', '\x217', '\x2', '\x1943', '\x537', '\x3', '\x2', '\x2', 
		'\x2', '\x1944', '\x1945', '\a', '\x233', '\x2', '\x2', '\x1945', '\x1946', 
		'\a', '\x15C', '\x2', '\x2', '\x1946', '\x1947', '\a', '\x120', '\x2', 
		'\x2', '\x1947', '\x1948', '\a', '\x204', '\x2', '\x2', '\x1948', '\x194A', 
		'\a', '\xEC', '\x2', '\x2', '\x1949', '\x194B', '\x5', '\x4D6', '\x26C', 
		'\x2', '\x194A', '\x1949', '\x3', '\x2', '\x2', '\x2', '\x194A', '\x194B', 
		'\x3', '\x2', '\x2', '\x2', '\x194B', '\x194C', '\x3', '\x2', '\x2', '\x2', 
		'\x194C', '\x194E', '\x5', '\x4D8', '\x26D', '\x2', '\x194D', '\x194F', 
		'\x5', '\x42C', '\x217', '\x2', '\x194E', '\x194D', '\x3', '\x2', '\x2', 
		'\x2', '\x194E', '\x194F', '\x3', '\x2', '\x2', '\x2', '\x194F', '\x539', 
		'\x3', '\x2', '\x2', '\x2', '\x1950', '\x1951', '\a', '\xAA', '\x2', '\x2', 
		'\x1951', '\x1952', '\a', '\xDD', '\x2', '\x2', '\x1952', '\x1955', '\x5', 
		'\xA0', 'Q', '\x2', '\x1953', '\x1956', '\x5', '\x42A', '\x216', '\x2', 
		'\x1954', '\x1956', '\x5', '\x4FE', '\x280', '\x2', '\x1955', '\x1953', 
		'\x3', '\x2', '\x2', '\x2', '\x1955', '\x1954', '\x3', '\x2', '\x2', '\x2', 
		'\x1955', '\x1956', '\x3', '\x2', '\x2', '\x2', '\x1956', '\x1958', '\x3', 
		'\x2', '\x2', '\x2', '\x1957', '\x1959', '\x5', '\x506', '\x284', '\x2', 
		'\x1958', '\x1957', '\x3', '\x2', '\x2', '\x2', '\x1958', '\x1959', '\x3', 
		'\x2', '\x2', '\x2', '\x1959', '\x195B', '\x3', '\x2', '\x2', '\x2', '\x195A', 
		'\x195C', '\x5', '\x53C', '\x29F', '\x2', '\x195B', '\x195A', '\x3', '\x2', 
		'\x2', '\x2', '\x195B', '\x195C', '\x3', '\x2', '\x2', '\x2', '\x195C', 
		'\x53B', '\x3', '\x2', '\x2', '\x2', '\x195D', '\x195E', '\t', 'Z', '\x2', 
		'\x2', '\x195E', '\x195F', '\x5', '\x42A', '\x216', '\x2', '\x195F', '\x53D', 
		'\x3', '\x2', '\x2', '\x2', '\x1960', '\x1961', '\a', '\x18C', '\x2', 
		'\x2', '\x1961', '\x1962', '\a', '\x1BF', '\x2', '\x2', '\x1962', '\x1963', 
		'\a', '\x24D', '\x2', '\x2', '\x1963', '\x1964', '\x5', '\xC6', '\x64', 
		'\x2', '\x1964', '\x1965', '\a', '\x24E', '\x2', '\x2', '\x1965', '\x53F', 
		'\x3', '\x2', '\x2', '\x2', '\x1966', '\x1968', '\a', '\x19E', '\x2', 
		'\x2', '\x1967', '\x1969', '\x5', '\x42', '\"', '\x2', '\x1968', '\x1967', 
		'\x3', '\x2', '\x2', '\x2', '\x1968', '\x1969', '\x3', '\x2', '\x2', '\x2', 
		'\x1969', '\x541', '\x3', '\x2', '\x2', '\x2', '\x196A', '\x196B', '\a', 
		'\x213', '\x2', '\x2', '\x196B', '\x196C', '\a', '\x1FD', '\x2', '\x2', 
		'\x196C', '\x196E', '\x5', '\x42', '\"', '\x2', '\x196D', '\x196F', '\x5', 
		'\x544', '\x2A3', '\x2', '\x196E', '\x196D', '\x3', '\x2', '\x2', '\x2', 
		'\x196E', '\x196F', '\x3', '\x2', '\x2', '\x2', '\x196F', '\x1971', '\x3', 
		'\x2', '\x2', '\x2', '\x1970', '\x1972', '\x5', '\x54A', '\x2A6', '\x2', 
		'\x1971', '\x1970', '\x3', '\x2', '\x2', '\x2', '\x1971', '\x1972', '\x3', 
		'\x2', '\x2', '\x2', '\x1972', '\x543', '\x3', '\x2', '\x2', '\x2', '\x1973', 
		'\x1974', '\x5', '\x546', '\x2A4', '\x2', '\x1974', '\x1975', '\a', '\x121', 
		'\x2', '\x2', '\x1975', '\x1976', '\a', '\x22F', '\x2', '\x2', '\x1976', 
		'\x1977', '\a', '\x116', '\x2', '\x2', '\x1977', '\x545', '\x3', '\x2', 
		'\x2', '\x2', '\x1978', '\x1979', '\t', '[', '\x2', '\x2', '\x1979', '\x547', 
		'\x3', '\x2', '\x2', '\x2', '\x197A', '\x197B', '\a', '\x213', '\x2', 
		'\x2', '\x197B', '\x197C', '\a', '\x45', '\x2', '\x2', '\x197C', '\x197E', 
		'\x5', '\x42', '\"', '\x2', '\x197D', '\x197F', '\x5', '\x54A', '\x2A6', 
		'\x2', '\x197E', '\x197D', '\x3', '\x2', '\x2', '\x2', '\x197E', '\x197F', 
		'\x3', '\x2', '\x2', '\x2', '\x197F', '\x549', '\x3', '\x2', '\x2', '\x2', 
		'\x1980', '\x1981', '\t', '\\', '\x2', '\x2', '\x1981', '\x1982', '\a', 
		'\x1ED', '\x2', '\x2', '\x1982', '\x54B', '\x3', '\x2', '\x2', '\x2', 
		'\x1983', '\x1984', '\a', '\x113', '\x2', '\x2', '\x1984', '\x1985', '\a', 
		'\x1FD', '\x2', '\x2', '\x1985', '\x1986', '\x5', '\x54E', '\x2A8', '\x2', 
		'\x1986', '\x1988', '\x5', '\x550', '\x2A9', '\x2', '\x1987', '\x1989', 
		'\x5', '\x552', '\x2AA', '\x2', '\x1988', '\x1987', '\x3', '\x2', '\x2', 
		'\x2', '\x1988', '\x1989', '\x3', '\x2', '\x2', '\x2', '\x1989', '\x54D', 
		'\x3', '\x2', '\x2', '\x2', '\x198A', '\x198F', '\x5', '\x468', '\x235', 
		'\x2', '\x198B', '\x198C', '\a', '\x24F', '\x2', '\x2', '\x198C', '\x198E', 
		'\x5', '\x468', '\x235', '\x2', '\x198D', '\x198B', '\x3', '\x2', '\x2', 
		'\x2', '\x198E', '\x1991', '\x3', '\x2', '\x2', '\x2', '\x198F', '\x198D', 
		'\x3', '\x2', '\x2', '\x2', '\x198F', '\x1990', '\x3', '\x2', '\x2', '\x2', 
		'\x1990', '\x54F', '\x3', '\x2', '\x2', '\x2', '\x1991', '\x198F', '\x3', 
		'\x2', '\x2', '\x2', '\x1992', '\x199C', '\a', '\xDE', '\x2', '\x2', '\x1993', 
		'\x1994', '\a', '\x1BF', '\x2', '\x2', '\x1994', '\x199D', '\t', ']', 
		'\x2', '\x2', '\x1995', '\x1999', '\a', '\x1DD', '\x2', '\x2', '\x1996', 
		'\x199A', '\a', '\x220', '\x2', '\x2', '\x1997', '\x1998', '\a', '\x1BF', 
		'\x2', '\x2', '\x1998', '\x199A', '\a', '\xA9', '\x2', '\x2', '\x1999', 
		'\x1996', '\x3', '\x2', '\x2', '\x2', '\x1999', '\x1997', '\x3', '\x2', 
		'\x2', '\x2', '\x199A', '\x199D', '\x3', '\x2', '\x2', '\x2', '\x199B', 
		'\x199D', '\a', '\xA9', '\x2', '\x2', '\x199C', '\x1993', '\x3', '\x2', 
		'\x2', '\x2', '\x199C', '\x1995', '\x3', '\x2', '\x2', '\x2', '\x199C', 
		'\x199B', '\x3', '\x2', '\x2', '\x2', '\x199D', '\x199E', '\x3', '\x2', 
		'\x2', '\x2', '\x199E', '\x199F', '\a', '\x132', '\x2', '\x2', '\x199F', 
		'\x551', '\x3', '\x2', '\x2', '\x2', '\x19A0', '\x19A1', '\a', '\x15F', 
		'\x2', '\x2', '\x19A1', '\x553', '\x3', '\x2', '\x2', '\x2', '\x19A2', 
		'\x19A3', '\a', '\x20E', '\x2', '\x2', '\x19A3', '\x19A4', '\a', '\x24D', 
		'\x2', '\x2', '\x19A4', '\x19A5', '\x5', '\xA0', 'Q', '\x2', '\x19A5', 
		'\x19A6', '\a', '\x225', '\x2', '\x2', '\x19A6', '\x19A7', '\t', '^', 
		'\x2', '\x2', '\x19A7', '\x19A8', '\a', '\x24E', '\x2', '\x2', '\x19A8', 
		'\x555', '\x3', '\x2', '\x2', '\x2', '\x19A9', '\x19AA', '\a', '\x41', 
		'\x2', '\x2', '\x19AA', '\x19AB', '\a', '\x24D', '\x2', '\x2', '\x19AB', 
		'\x19AC', '\x5', '\xA0', 'Q', '\x2', '\x19AC', '\x19AD', '\a', '\x225', 
		'\x2', '\x2', '\x19AD', '\x19AE', '\a', '\x13D', '\x2', '\x2', '\x19AE', 
		'\x19AF', '\a', '\x24E', '\x2', '\x2', '\x19AF', '\x19B6', '\x3', '\x2', 
		'\x2', '\x2', '\x19B0', '\x19B1', '\a', '\x13E', '\x2', '\x2', '\x19B1', 
		'\x19B2', '\a', '\x24D', '\x2', '\x2', '\x19B2', '\x19B3', '\x5', '\xA0', 
		'Q', '\x2', '\x19B3', '\x19B4', '\a', '\x24E', '\x2', '\x2', '\x19B4', 
		'\x19B6', '\x3', '\x2', '\x2', '\x2', '\x19B5', '\x19A9', '\x3', '\x2', 
		'\x2', '\x2', '\x19B5', '\x19B0', '\x3', '\x2', '\x2', '\x2', '\x19B6', 
		'\x557', '\x3', '\x2', '\x2', '\x2', '\x19B7', '\x19BE', '\x5', '\x568', 
		'\x2B5', '\x2', '\x19B8', '\x19BE', '\x5', '\x57E', '\x2C0', '\x2', '\x19B9', 
		'\x19BE', '\x5', '\x582', '\x2C2', '\x2', '\x19BA', '\x19BE', '\x5', '\x588', 
		'\x2C5', '\x2', '\x19BB', '\x19BE', '\x5', '\x57A', '\x2BE', '\x2', '\x19BC', 
		'\x19BE', '\x5', '\x55A', '\x2AE', '\x2', '\x19BD', '\x19B7', '\x3', '\x2', 
		'\x2', '\x2', '\x19BD', '\x19B8', '\x3', '\x2', '\x2', '\x2', '\x19BD', 
		'\x19B9', '\x3', '\x2', '\x2', '\x2', '\x19BD', '\x19BA', '\x3', '\x2', 
		'\x2', '\x2', '\x19BD', '\x19BB', '\x3', '\x2', '\x2', '\x2', '\x19BD', 
		'\x19BC', '\x3', '\x2', '\x2', '\x2', '\x19BE', '\x559', '\x3', '\x2', 
		'\x2', '\x2', '\x19BF', '\x19C0', '\a', '\xBF', '\x2', '\x2', '\x19C0', 
		'\x19C1', '\x5', 'N', '(', '\x2', '\x19C1', '\x19C3', '\x5', '\x55C', 
		'\x2AF', '\x2', '\x19C2', '\x19C4', '\x5', '\x566', '\x2B4', '\x2', '\x19C3', 
		'\x19C2', '\x3', '\x2', '\x2', '\x2', '\x19C3', '\x19C4', '\x3', '\x2', 
		'\x2', '\x2', '\x19C4', '\x19CA', '\x3', '\x2', '\x2', '\x2', '\x19C5', 
		'\x19CB', '\x5', '\x4DC', '\x26F', '\x2', '\x19C6', '\x19CB', '\x5', '\x4F6', 
		'\x27C', '\x2', '\x19C7', '\x19CB', '\x5', '\x4F4', '\x27B', '\x2', '\x19C8', 
		'\x19CB', '\x5', '\x52C', '\x297', '\x2', '\x19C9', '\x19CB', '\x5', '\x53A', 
		'\x29E', '\x2', '\x19CA', '\x19C5', '\x3', '\x2', '\x2', '\x2', '\x19CA', 
		'\x19C6', '\x3', '\x2', '\x2', '\x2', '\x19CA', '\x19C7', '\x3', '\x2', 
		'\x2', '\x2', '\x19CA', '\x19C8', '\x3', '\x2', '\x2', '\x2', '\x19CA', 
		'\x19C9', '\x3', '\x2', '\x2', '\x2', '\x19CB', '\x55B', '\x3', '\x2', 
		'\x2', '\x2', '\x19CC', '\x19D0', '\a', '\xDE', '\x2', '\x2', '\x19CD', 
		'\x19D1', '\x5', '\x55E', '\x2B0', '\x2', '\x19CE', '\x19D1', '\x5', '\x562', 
		'\x2B2', '\x2', '\x19CF', '\x19D1', '\x5', '\x564', '\x2B3', '\x2', '\x19D0', 
		'\x19CD', '\x3', '\x2', '\x2', '\x2', '\x19D0', '\x19CE', '\x3', '\x2', 
		'\x2', '\x2', '\x19D0', '\x19CF', '\x3', '\x2', '\x2', '\x2', '\x19D1', 
		'\x55D', '\x3', '\x2', '\x2', '\x2', '\x19D2', '\x19D3', '\a', '\xE6', 
		'\x2', '\x2', '\x19D3', '\x19D4', '\a', '\x164', '\x2', '\x2', '\x19D4', 
		'\x19D6', '\x5', '\x42', '\"', '\x2', '\x19D5', '\x19D7', '\x5', '\x560', 
		'\x2B1', '\x2', '\x19D6', '\x19D5', '\x3', '\x2', '\x2', '\x2', '\x19D6', 
		'\x19D7', '\x3', '\x2', '\x2', '\x2', '\x19D7', '\x55F', '\x3', '\x2', 
		'\x2', '\x2', '\x19D8', '\x19D9', '\a', '&', '\x2', '\x2', '\x19D9', '\x19DC', 
		'\x5', '\xA0', 'Q', '\x2', '\x19DA', '\x19DB', '\a', '\x10', '\x2', '\x2', 
		'\x19DB', '\x19DD', '\x5', '\xA0', 'Q', '\x2', '\x19DC', '\x19DA', '\x3', 
		'\x2', '\x2', '\x2', '\x19DC', '\x19DD', '\x3', '\x2', '\x2', '\x2', '\x19DD', 
		'\x561', '\x3', '\x2', '\x2', '\x2', '\x19DE', '\x19DF', '\a', '\x228', 
		'\x2', '\x2', '\x19DF', '\x19E0', '\a', '\x164', '\x2', '\x2', '\x19E0', 
		'\x19E1', '\x5', '\x42', '\"', '\x2', '\x19E1', '\x563', '\x3', '\x2', 
		'\x2', '\x2', '\x19E2', '\x19E3', '\x5', '\xA0', 'Q', '\x2', '\x19E3', 
		'\x19E4', '\x5', '\x9A', 'N', '\x2', '\x19E4', '\x19E5', '\x5', '\xA0', 
		'Q', '\x2', '\x19E5', '\x565', '\x3', '\x2', '\x2', '\x2', '\x19E6', '\x19E7', 
		'\a', '\x1C7', '\x2', '\x2', '\x19E7', '\x19E8', '\a', '\xA7', '\x2', 
		'\x2', '\x19E8', '\x567', '\x3', '\x2', '\x2', '\x2', '\x19E9', '\x19EA', 
		'\a', '\xDC', '\x2', '\x2', '\x19EA', '\x19EB', '\x5', '\xA0', 'Q', '\x2', 
		'\x19EB', '\x19EF', '\x5', '\x56A', '\x2B6', '\x2', '\x19EC', '\x19EE', 
		'\x5', '\x56E', '\x2B8', '\x2', '\x19ED', '\x19EC', '\x3', '\x2', '\x2', 
		'\x2', '\x19EE', '\x19F1', '\x3', '\x2', '\x2', '\x2', '\x19EF', '\x19ED', 
		'\x3', '\x2', '\x2', '\x2', '\x19EF', '\x19F0', '\x3', '\x2', '\x2', '\x2', 
		'\x19F0', '\x19F3', '\x3', '\x2', '\x2', '\x2', '\x19F1', '\x19EF', '\x3', 
		'\x2', '\x2', '\x2', '\x19F2', '\x19F4', '\x5', '\x56C', '\x2B7', '\x2', 
		'\x19F3', '\x19F2', '\x3', '\x2', '\x2', '\x2', '\x19F3', '\x19F4', '\x3', 
		'\x2', '\x2', '\x2', '\x19F4', '\x19F5', '\x3', '\x2', '\x2', '\x2', '\x19F5', 
		'\x19F6', '\a', '\x9C', '\x2', '\x2', '\x19F6', '\x19F7', '\a', '\xDC', 
		'\x2', '\x2', '\x19F7', '\x569', '\x3', '\x2', '\x2', '\x2', '\x19F8', 
		'\x19F9', '\a', '\x204', '\x2', '\x2', '\x19F9', '\x19FA', '\x5', '\x1E', 
		'\x10', '\x2', '\x19FA', '\x56B', '\x3', '\x2', '\x2', '\x2', '\x19FB', 
		'\x19FC', '\a', '\x97', '\x2', '\x2', '\x19FC', '\x19FD', '\x5', '\x1E', 
		'\x10', '\x2', '\x19FD', '\x56D', '\x3', '\x2', '\x2', '\x2', '\x19FE', 
		'\x19FF', '\a', '\x98', '\x2', '\x2', '\x19FF', '\x1A00', '\x5', '\xA0', 
		'Q', '\x2', '\x1A00', '\x1A01', '\x5', '\x56A', '\x2B6', '\x2', '\x1A01', 
		'\x56F', '\x3', '\x2', '\x2', '\x2', '\x1A02', '\x1A03', '\a', '\x88', 
		'\x2', '\x2', '\x1A03', '\x1A04', '\x5', '\xA0', 'Q', '\x2', '\x1A04', 
		'\x1A08', '\x5', '\x572', '\x2BA', '\x2', '\x1A05', '\x1A07', '\x5', '\x576', 
		'\x2BC', '\x2', '\x1A06', '\x1A05', '\x3', '\x2', '\x2', '\x2', '\x1A07', 
		'\x1A0A', '\x3', '\x2', '\x2', '\x2', '\x1A08', '\x1A06', '\x3', '\x2', 
		'\x2', '\x2', '\x1A08', '\x1A09', '\x3', '\x2', '\x2', '\x2', '\x1A09', 
		'\x1A0C', '\x3', '\x2', '\x2', '\x2', '\x1A0A', '\x1A08', '\x3', '\x2', 
		'\x2', '\x2', '\x1A0B', '\x1A0D', '\x5', '\x574', '\x2BB', '\x2', '\x1A0C', 
		'\x1A0B', '\x3', '\x2', '\x2', '\x2', '\x1A0C', '\x1A0D', '\x3', '\x2', 
		'\x2', '\x2', '\x1A0D', '\x1A0E', '\x3', '\x2', '\x2', '\x2', '\x1A0E', 
		'\x1A0F', '\a', '\x86', '\x2', '\x2', '\x1A0F', '\x571', '\x3', '\x2', 
		'\x2', '\x2', '\x1A10', '\x1A15', '\a', '\x89', '\x2', '\x2', '\x1A11', 
		'\x1A14', '\x5', '\x578', '\x2BD', '\x2', '\x1A12', '\x1A14', '\x5', '\x5B0', 
		'\x2D9', '\x2', '\x1A13', '\x1A11', '\x3', '\x2', '\x2', '\x2', '\x1A13', 
		'\x1A12', '\x3', '\x2', '\x2', '\x2', '\x1A14', '\x1A17', '\x3', '\x2', 
		'\x2', '\x2', '\x1A15', '\x1A13', '\x3', '\x2', '\x2', '\x2', '\x1A15', 
		'\x1A16', '\x3', '\x2', '\x2', '\x2', '\x1A16', '\x573', '\x3', '\x2', 
		'\x2', '\x2', '\x1A17', '\x1A15', '\x3', '\x2', '\x2', '\x2', '\x1A18', 
		'\x1A1D', '\a', '\x84', '\x2', '\x2', '\x1A19', '\x1A1C', '\x5', '\x578', 
		'\x2BD', '\x2', '\x1A1A', '\x1A1C', '\x5', '\x5B0', '\x2D9', '\x2', '\x1A1B', 
		'\x1A19', '\x3', '\x2', '\x2', '\x2', '\x1A1B', '\x1A1A', '\x3', '\x2', 
		'\x2', '\x2', '\x1A1C', '\x1A1F', '\x3', '\x2', '\x2', '\x2', '\x1A1D', 
		'\x1A1B', '\x3', '\x2', '\x2', '\x2', '\x1A1D', '\x1A1E', '\x3', '\x2', 
		'\x2', '\x2', '\x1A1E', '\x575', '\x3', '\x2', '\x2', '\x2', '\x1A1F', 
		'\x1A1D', '\x3', '\x2', '\x2', '\x2', '\x1A20', '\x1A21', '\a', '\x85', 
		'\x2', '\x2', '\x1A21', '\x1A22', '\x5', '\xA0', 'Q', '\x2', '\x1A22', 
		'\x1A23', '\x5', '\x572', '\x2BA', '\x2', '\x1A23', '\x577', '\x3', '\x2', 
		'\x2', '\x2', '\x1A24', '\x1A25', '\a', '\x87', '\x2', '\x2', '\x1A25', 
		'\x1A26', '\x5', '\xA0', 'Q', '\x2', '\x1A26', '\x1A27', '\a', '\x86', 
		'\x2', '\x2', '\x1A27', '\x579', '\x3', '\x2', '\x2', '\x2', '\x1A28', 
		'\x1A29', '\x5', '\x57C', '\x2BF', '\x2', '\x1A29', '\x57B', '\x3', '\x2', 
		'\x2', '\x2', '\x1A2A', '\x1A2B', '\a', '\x11B', '\x2', '\x2', '\x1A2B', 
		'\x1A2C', '\x5', '\x1E', '\x10', '\x2', '\x1A2C', '\x1A2D', '\x5', '\x580', 
		'\x2C1', '\x2', '\x1A2D', '\x57D', '\x3', '\x2', '\x2', '\x2', '\x1A2E', 
		'\x1A2F', '\a', '\x235', '\x2', '\x2', '\x1A2F', '\x1A30', '\x5', '\xA0', 
		'Q', '\x2', '\x1A30', '\x1A31', '\x5', '\x57C', '\x2BF', '\x2', '\x1A31', 
		'\x57F', '\x3', '\x2', '\x2', '\x2', '\x1A32', '\x1A33', '\a', '\x9C', 
		'\x2', '\x2', '\x1A33', '\x1A36', '\a', '\x11B', '\x2', '\x2', '\x1A34', 
		'\x1A37', '\x5', '>', ' ', '\x2', '\x1A35', '\x1A37', '\a', '\x269', '\x2', 
		'\x2', '\x1A36', '\x1A34', '\x3', '\x2', '\x2', '\x2', '\x1A36', '\x1A35', 
		'\x3', '\x2', '\x2', '\x2', '\x1A36', '\x1A37', '\x3', '\x2', '\x2', '\x2', 
		'\x1A37', '\x581', '\x3', '\x2', '\x2', '\x2', '\x1A38', '\x1A39', '\a', 
		'\xBE', '\x2', '\x2', '\x1A39', '\x1A3A', '\x5', 'N', '(', '\x2', '\x1A3A', 
		'\x1A3B', '\x5', '\x584', '\x2C3', '\x2', '\x1A3B', '\x1A3C', '\x5', '\x57C', 
		'\x2BF', '\x2', '\x1A3C', '\x583', '\x3', '\x2', '\x2', '\x2', '\x1A3D', 
		'\x1A3F', '\a', '\xDE', '\x2', '\x2', '\x1A3E', '\x1A40', '\a', '\x1B9', 
		'\x2', '\x2', '\x1A3F', '\x1A3E', '\x3', '\x2', '\x2', '\x2', '\x1A3F', 
		'\x1A40', '\x3', '\x2', '\x2', '\x2', '\x1A40', '\x1A41', '\x3', '\x2', 
		'\x2', '\x2', '\x1A41', '\x1A44', '\x5', '\xA0', 'Q', '\x2', '\x1A42', 
		'\x1A43', '\a', '\x24C', '\x2', '\x2', '\x1A43', '\x1A45', '\x5', '\xA0', 
		'Q', '\x2', '\x1A44', '\x1A42', '\x3', '\x2', '\x2', '\x2', '\x1A44', 
		'\x1A45', '\x3', '\x2', '\x2', '\x2', '\x1A45', '\x585', '\x3', '\x2', 
		'\x2', '\x2', '\x1A46', '\x1A48', '\a', '\x61', '\x2', '\x2', '\x1A47', 
		'\x1A49', '\x5', '\x5AA', '\x2D6', '\x2', '\x1A48', '\x1A47', '\x3', '\x2', 
		'\x2', '\x2', '\x1A48', '\x1A49', '\x3', '\x2', '\x2', '\x2', '\x1A49', 
		'\x587', '\x3', '\x2', '\x2', '\x2', '\x1A4A', '\x1A4D', '\a', '\x39', 
		'\x2', '\x2', '\x1A4B', '\x1A4E', '\x5', '\x58C', '\x2C7', '\x2', '\x1A4C', 
		'\x1A4E', '\x5', '\x58A', '\x2C6', '\x2', '\x1A4D', '\x1A4B', '\x3', '\x2', 
		'\x2', '\x2', '\x1A4D', '\x1A4C', '\x3', '\x2', '\x2', '\x2', '\x1A4E', 
		'\x1A4F', '\x3', '\x2', '\x2', '\x2', '\x1A4F', '\x1A50', '\a', '\x9C', 
		'\x2', '\x2', '\x1A50', '\x1A53', '\a', '\x39', '\x2', '\x2', '\x1A51', 
		'\x1A54', '\x5', '>', ' ', '\x2', '\x1A52', '\x1A54', '\a', '\x269', '\x2', 
		'\x2', '\x1A53', '\x1A51', '\x3', '\x2', '\x2', '\x2', '\x1A53', '\x1A52', 
		'\x3', '\x2', '\x2', '\x2', '\x1A53', '\x1A54', '\x3', '\x2', '\x2', '\x2', 
		'\x1A54', '\x589', '\x3', '\x2', '\x2', '\x2', '\x1A55', '\x1A57', '\x5', 
		'\xA0', 'Q', '\x2', '\x1A56', '\x1A58', '\x5', '\x58E', '\x2C8', '\x2', 
		'\x1A57', '\x1A56', '\x3', '\x2', '\x2', '\x2', '\x1A58', '\x1A59', '\x3', 
		'\x2', '\x2', '\x2', '\x1A59', '\x1A57', '\x3', '\x2', '\x2', '\x2', '\x1A59', 
		'\x1A5A', '\x3', '\x2', '\x2', '\x2', '\x1A5A', '\x1A5C', '\x3', '\x2', 
		'\x2', '\x2', '\x1A5B', '\x1A5D', '\x5', '\x56C', '\x2B7', '\x2', '\x1A5C', 
		'\x1A5B', '\x3', '\x2', '\x2', '\x2', '\x1A5C', '\x1A5D', '\x3', '\x2', 
		'\x2', '\x2', '\x1A5D', '\x58B', '\x3', '\x2', '\x2', '\x2', '\x1A5E', 
		'\x1A60', '\x5', '\x58E', '\x2C8', '\x2', '\x1A5F', '\x1A5E', '\x3', '\x2', 
		'\x2', '\x2', '\x1A60', '\x1A61', '\x3', '\x2', '\x2', '\x2', '\x1A61', 
		'\x1A5F', '\x3', '\x2', '\x2', '\x2', '\x1A61', '\x1A62', '\x3', '\x2', 
		'\x2', '\x2', '\x1A62', '\x1A64', '\x3', '\x2', '\x2', '\x2', '\x1A63', 
		'\x1A65', '\x5', '\x56C', '\x2B7', '\x2', '\x1A64', '\x1A63', '\x3', '\x2', 
		'\x2', '\x2', '\x1A64', '\x1A65', '\x3', '\x2', '\x2', '\x2', '\x1A65', 
		'\x58D', '\x3', '\x2', '\x2', '\x2', '\x1A66', '\x1A67', '\a', '\x233', 
		'\x2', '\x2', '\x1A67', '\x1A68', '\x5', '\xA0', 'Q', '\x2', '\x1A68', 
		'\x1A69', '\x5', '\x56A', '\x2B6', '\x2', '\x1A69', '\x58F', '\x3', '\x2', 
		'\x2', '\x2', '\x1A6A', '\x1A6C', '\x5', '\x5AE', '\x2D8', '\x2', '\x1A6B', 
		'\x1A6A', '\x3', '\x2', '\x2', '\x2', '\x1A6B', '\x1A6C', '\x3', '\x2', 
		'\x2', '\x2', '\x1A6C', '\x1A6D', '\x3', '\x2', '\x2', '\x2', '\x1A6D', 
		'\x1A6E', '\x5', '\x592', '\x2CA', '\x2', '\x1A6E', '\x591', '\x3', '\x2', 
		'\x2', '\x2', '\x1A6F', '\x1A70', '\a', '$', '\x2', '\x2', '\x1A70', '\x1A72', 
		'\x5', '\x1E', '\x10', '\x2', '\x1A71', '\x1A73', '\x5', '\x596', '\x2CC', 
		'\x2', '\x1A72', '\x1A71', '\x3', '\x2', '\x2', '\x2', '\x1A72', '\x1A73', 
		'\x3', '\x2', '\x2', '\x2', '\x1A73', '\x1A74', '\x3', '\x2', '\x2', '\x2', 
		'\x1A74', '\x1A75', '\x5', '\x594', '\x2CB', '\x2', '\x1A75', '\x593', 
		'\x3', '\x2', '\x2', '\x2', '\x1A76', '\x1A79', '\a', '\x9C', '\x2', '\x2', 
		'\x1A77', '\x1A7A', '\x5', '>', ' ', '\x2', '\x1A78', '\x1A7A', '\a', 
		'\x269', '\x2', '\x2', '\x1A79', '\x1A77', '\x3', '\x2', '\x2', '\x2', 
		'\x1A79', '\x1A78', '\x3', '\x2', '\x2', '\x2', '\x1A79', '\x1A7A', '\x3', 
		'\x2', '\x2', '\x2', '\x1A7A', '\x595', '\x3', '\x2', '\x2', '\x2', '\x1A7B', 
		'\x1A7D', '\a', '\xA5', '\x2', '\x2', '\x1A7C', '\x1A7E', '\x5', '\x598', 
		'\x2CD', '\x2', '\x1A7D', '\x1A7C', '\x3', '\x2', '\x2', '\x2', '\x1A7E', 
		'\x1A7F', '\x3', '\x2', '\x2', '\x2', '\x1A7F', '\x1A7D', '\x3', '\x2', 
		'\x2', '\x2', '\x1A7F', '\x1A80', '\x3', '\x2', '\x2', '\x2', '\x1A80', 
		'\x597', '\x3', '\x2', '\x2', '\x2', '\x1A81', '\x1A82', '\a', '\x233', 
		'\x2', '\x2', '\x1A82', '\x1A83', '\x5', '\x59A', '\x2CE', '\x2', '\x1A83', 
		'\x1A84', '\x5', '\x56A', '\x2B6', '\x2', '\x1A84', '\x599', '\x3', '\x2', 
		'\x2', '\x2', '\x1A85', '\x1A8A', '\x5', '\x42', '\"', '\x2', '\x1A86', 
		'\x1A87', '\a', '\x170', '\x2', '\x2', '\x1A87', '\x1A89', '\x5', '\x42', 
		'\"', '\x2', '\x1A88', '\x1A86', '\x3', '\x2', '\x2', '\x2', '\x1A89', 
		'\x1A8C', '\x3', '\x2', '\x2', '\x2', '\x1A8A', '\x1A88', '\x3', '\x2', 
		'\x2', '\x2', '\x1A8A', '\x1A8B', '\x3', '\x2', '\x2', '\x2', '\x1A8B', 
		'\x59B', '\x3', '\x2', '\x2', '\x2', '\x1A8C', '\x1A8A', '\x3', '\x2', 
		'\x2', '\x2', '\x1A8D', '\x1A8E', '\a', '\xCE', '\x2', '\x2', '\x1A8E', 
		'\x1A8F', '\x5', '\\', '/', '\x2', '\x1A8F', '\x59D', '\x3', '\x2', '\x2', 
		'\x2', '\x1A90', '\x1A91', '\x5', '\x5A0', '\x2D1', '\x2', '\x1A91', '\x59F', 
		'\x3', '\x2', '\x2', '\x2', '\x1A92', '\x1A93', '\a', '\x254', '\x2', 
		'\x2', '\x1A93', '\x1A94', '\a', '\x254', '\x2', '\x2', '\x1A94', '\x1A95', 
		'\x5', '\\', '/', '\x2', '\x1A95', '\x1A96', '\a', '\x253', '\x2', '\x2', 
		'\x1A96', '\x1A97', '\a', '\x253', '\x2', '\x2', '\x1A97', '\x5A1', '\x3', 
		'\x2', '\x2', '\x2', '\x1A98', '\x1A99', '\a', '\x160', '\x2', '\x2', 
		'\x1A99', '\x5A3', '\x3', '\x2', '\x2', '\x2', '\x1A9A', '\x1A9C', '\a', 
		'\x1B6', '\x2', '\x2', '\x1A9B', '\x1A9D', '\x5', '\xA0', 'Q', '\x2', 
		'\x1A9C', '\x1A9B', '\x3', '\x2', '\x2', '\x2', '\x1A9C', '\x1A9D', '\x3', 
		'\x2', '\x2', '\x2', '\x1A9D', '\x5A5', '\x3', '\x2', '\x2', '\x2', '\x1A9E', 
		'\x1A9F', '\x5', '\x42', '\"', '\x2', '\x1A9F', '\x5A7', '\x3', '\x2', 
		'\x2', '\x2', '\x1AA0', '\x1AA2', '\a', '\xAC', '\x2', '\x2', '\x1AA1', 
		'\x1AA3', '\x5', '\x5AA', '\x2D6', '\x2', '\x1AA2', '\x1AA1', '\x3', '\x2', 
		'\x2', '\x2', '\x1AA2', '\x1AA3', '\x3', '\x2', '\x2', '\x2', '\x1AA3', 
		'\x5A9', '\x3', '\x2', '\x2', '\x2', '\x1AA4', '\x1AAA', '\x5', '\x5AC', 
		'\x2D7', '\x2', '\x1AA5', '\x1AA7', '\x5', 'N', '(', '\x2', '\x1AA6', 
		'\x1AA8', '\x5', '\x5AC', '\x2D7', '\x2', '\x1AA7', '\x1AA6', '\x3', '\x2', 
		'\x2', '\x2', '\x1AA7', '\x1AA8', '\x3', '\x2', '\x2', '\x2', '\x1AA8', 
		'\x1AAA', '\x3', '\x2', '\x2', '\x2', '\x1AA9', '\x1AA4', '\x3', '\x2', 
		'\x2', '\x2', '\x1AA9', '\x1AA5', '\x3', '\x2', '\x2', '\x2', '\x1AAA', 
		'\x5AB', '\x3', '\x2', '\x2', '\x2', '\x1AAB', '\x1AAC', '\a', '\x233', 
		'\x2', '\x2', '\x1AAC', '\x1AAD', '\x5', '\xA0', 'Q', '\x2', '\x1AAD', 
		'\x5AD', '\x3', '\x2', '\x2', '\x2', '\x1AAE', '\x1AB0', '\x5', '\x5B0', 
		'\x2D9', '\x2', '\x1AAF', '\x1AAE', '\x3', '\x2', '\x2', '\x2', '\x1AB0', 
		'\x1AB1', '\x3', '\x2', '\x2', '\x2', '\x1AB1', '\x1AAF', '\x3', '\x2', 
		'\x2', '\x2', '\x1AB1', '\x1AB2', '\x3', '\x2', '\x2', '\x2', '\x1AB2', 
		'\x1ABB', '\x3', '\x2', '\x2', '\x2', '\x1AB3', '\x1AB7', '\a', 'u', '\x2', 
		'\x2', '\x1AB4', '\x1AB6', '\x5', '\x5B0', '\x2D9', '\x2', '\x1AB5', '\x1AB4', 
		'\x3', '\x2', '\x2', '\x2', '\x1AB6', '\x1AB9', '\x3', '\x2', '\x2', '\x2', 
		'\x1AB7', '\x1AB5', '\x3', '\x2', '\x2', '\x2', '\x1AB7', '\x1AB8', '\x3', 
		'\x2', '\x2', '\x2', '\x1AB8', '\x1ABB', '\x3', '\x2', '\x2', '\x2', '\x1AB9', 
		'\x1AB7', '\x3', '\x2', '\x2', '\x2', '\x1ABA', '\x1AAF', '\x3', '\x2', 
		'\x2', '\x2', '\x1ABA', '\x1AB3', '\x3', '\x2', '\x2', '\x2', '\x1ABB', 
		'\x5AF', '\x3', '\x2', '\x2', '\x2', '\x1ABC', '\x1ACA', '\x5', '\x570', 
		'\x2B9', '\x2', '\x1ABD', '\x1AC6', '\x5', '\x20E', '\x108', '\x2', '\x1ABE', 
		'\x1AC6', '\x5', '\x1E6', '\xF4', '\x2', '\x1ABF', '\x1AC6', '\x5', '\x5BA', 
		'\x2DE', '\x2', '\x1AC0', '\x1AC6', '\x5', '\x5BC', '\x2DF', '\x2', '\x1AC1', 
		'\x1AC6', '\x5', '\x5D6', '\x2EC', '\x2', '\x1AC2', '\x1AC6', '\x5', '\x5D8', 
		'\x2ED', '\x2', '\x1AC3', '\x1AC6', '\x5', '\x5DE', '\x2F0', '\x2', '\x1AC4', 
		'\x1AC6', '\x5', '\x5F2', '\x2FA', '\x2', '\x1AC5', '\x1ABD', '\x3', '\x2', 
		'\x2', '\x2', '\x1AC5', '\x1ABE', '\x3', '\x2', '\x2', '\x2', '\x1AC5', 
		'\x1ABF', '\x3', '\x2', '\x2', '\x2', '\x1AC5', '\x1AC0', '\x3', '\x2', 
		'\x2', '\x2', '\x1AC5', '\x1AC1', '\x3', '\x2', '\x2', '\x2', '\x1AC5', 
		'\x1AC2', '\x3', '\x2', '\x2', '\x2', '\x1AC5', '\x1AC3', '\x3', '\x2', 
		'\x2', '\x2', '\x1AC5', '\x1AC4', '\x3', '\x2', '\x2', '\x2', '\x1AC6', 
		'\x1AC7', '\x3', '\x2', '\x2', '\x2', '\x1AC7', '\x1AC8', '\a', '\x250', 
		'\x2', '\x2', '\x1AC8', '\x1ACA', '\x3', '\x2', '\x2', '\x2', '\x1AC9', 
		'\x1ABC', '\x3', '\x2', '\x2', '\x2', '\x1AC9', '\x1AC5', '\x3', '\x2', 
		'\x2', '\x2', '\x1ACA', '\x5B1', '\x3', '\x2', '\x2', '\x2', '\x1ACB', 
		'\x1ACC', '\a', '\x15C', '\x2', '\x2', '\x1ACC', '\x1ACD', '\a', '\x160', 
		'\x2', '\x2', '\x1ACD', '\x5B3', '\x3', '\x2', '\x2', '\x2', '\x1ACE', 
		'\x1ACF', '\a', '\x160', '\x2', '\x2', '\x1ACF', '\x5B5', '\x3', '\x2', 
		'\x2', '\x2', '\x1AD0', '\x1AD1', '\t', '&', '\x2', '\x2', '\x1AD1', '\x1AD2', 
		'\x5', '\xA0', 'Q', '\x2', '\x1AD2', '\x5B7', '\x3', '\x2', '\x2', '\x2', 
		'\x1AD3', '\x1AD4', '\a', '\x1B6', '\x2', '\x2', '\x1AD4', '\x1AD5', '\x5', 
		'`', '\x31', '\x2', '\x1AD5', '\x5B9', '\x3', '\x2', '\x2', '\x2', '\x1AD6', 
		'\x1AD7', '\x5', 'N', '(', '\x2', '\x1AD7', '\x1AD8', '\a', '\xA5', '\x2', 
		'\x2', '\x1AD8', '\x5BB', '\x3', '\x2', '\x2', '\x2', '\x1AD9', '\x1ADA', 
		'\a', '\x215', '\x2', '\x2', '\x1ADA', '\x1ADD', '\x5', 'N', '(', '\x2', 
		'\x1ADB', '\x1ADE', '\x5', '\xBA', '^', '\x2', '\x1ADC', '\x1ADE', '\x5', 
		'\x5BE', '\x2E0', '\x2', '\x1ADD', '\x1ADB', '\x3', '\x2', '\x2', '\x2', 
		'\x1ADD', '\x1ADC', '\x3', '\x2', '\x2', '\x2', '\x1ADE', '\x1AE0', '\x3', 
		'\x2', '\x2', '\x2', '\x1ADF', '\x1AE1', '\x5', '\x5C0', '\x2E1', '\x2', 
		'\x1AE0', '\x1ADF', '\x3', '\x2', '\x2', '\x2', '\x1AE0', '\x1AE1', '\x3', 
		'\x2', '\x2', '\x2', '\x1AE1', '\x1AE8', '\x3', '\x2', '\x2', '\x2', '\x1AE2', 
		'\x1AE9', '\x5', '\x5C2', '\x2E2', '\x2', '\x1AE3', '\x1AE9', '\x5', '\x5CA', 
		'\x2E6', '\x2', '\x1AE4', '\x1AE9', '\x5', '\x5D0', '\x2E9', '\x2', '\x1AE5', 
		'\x1AE9', '\x5', '\x5D4', '\x2EB', '\x2', '\x1AE6', '\x1AE9', '\x5', '\x5C6', 
		'\x2E4', '\x2', '\x1AE7', '\x1AE9', '\x5', '`', '\x31', '\x2', '\x1AE8', 
		'\x1AE2', '\x3', '\x2', '\x2', '\x2', '\x1AE8', '\x1AE3', '\x3', '\x2', 
		'\x2', '\x2', '\x1AE8', '\x1AE4', '\x3', '\x2', '\x2', '\x2', '\x1AE8', 
		'\x1AE5', '\x3', '\x2', '\x2', '\x2', '\x1AE8', '\x1AE6', '\x3', '\x2', 
		'\x2', '\x2', '\x1AE8', '\x1AE7', '\x3', '\x2', '\x2', '\x2', '\x1AE9', 
		'\x5BD', '\x3', '\x2', '\x2', '\x2', '\x1AEA', '\x1AEB', '\a', '\x15', 
		'\x2', '\x2', '\x1AEB', '\x5BF', '\x3', '\x2', '\x2', '\x2', '\x1AEC', 
		'\x1AED', '\a', '\x141', '\x2', '\x2', '\x1AED', '\x5C1', '\x3', '\x2', 
		'\x2', '\x2', '\x1AEE', '\x1AEF', '\a', '\x1A5', '\x2', '\x2', '\x1AEF', 
		'\x1AF0', '\a', '\x24D', '\x2', '\x2', '\x1AF0', '\x1AF5', '\x5', '\x5C4', 
		'\x2E3', '\x2', '\x1AF1', '\x1AF2', '\a', '\x24F', '\x2', '\x2', '\x1AF2', 
		'\x1AF4', '\x5', '\x5C4', '\x2E3', '\x2', '\x1AF3', '\x1AF1', '\x3', '\x2', 
		'\x2', '\x2', '\x1AF4', '\x1AF7', '\x3', '\x2', '\x2', '\x2', '\x1AF5', 
		'\x1AF3', '\x3', '\x2', '\x2', '\x2', '\x1AF5', '\x1AF6', '\x3', '\x2', 
		'\x2', '\x2', '\x1AF6', '\x1AF8', '\x3', '\x2', '\x2', '\x2', '\x1AF7', 
		'\x1AF5', '\x3', '\x2', '\x2', '\x2', '\x1AF8', '\x1AF9', '\a', '\x24E', 
		'\x2', '\x2', '\x1AF9', '\x5C3', '\x3', '\x2', '\x2', '\x2', '\x1AFA', 
		'\x1AFB', '\x5', 'N', '(', '\x2', '\x1AFB', '\x1B04', '\x5', '`', '\x31', 
		'\x2', '\x1AFC', '\x1AFE', '\x5', '\x5B2', '\x2DA', '\x2', '\x1AFD', '\x1AFC', 
		'\x3', '\x2', '\x2', '\x2', '\x1AFD', '\x1AFE', '\x3', '\x2', '\x2', '\x2', 
		'\x1AFE', '\x1AFF', '\x3', '\x2', '\x2', '\x2', '\x1AFF', '\x1B05', '\x5', 
		'\x5B6', '\x2DC', '\x2', '\x1B00', '\x1B02', '\x5', '\x5B4', '\x2DB', 
		'\x2', '\x1B01', '\x1B03', '\x5', '\x5B6', '\x2DC', '\x2', '\x1B02', '\x1B01', 
		'\x3', '\x2', '\x2', '\x2', '\x1B02', '\x1B03', '\x3', '\x2', '\x2', '\x2', 
		'\x1B03', '\x1B05', '\x3', '\x2', '\x2', '\x2', '\x1B04', '\x1AFD', '\x3', 
		'\x2', '\x2', '\x2', '\x1B04', '\x1B00', '\x3', '\x2', '\x2', '\x2', '\x1B04', 
		'\x1B05', '\x3', '\x2', '\x2', '\x2', '\x1B05', '\x5C5', '\x3', '\x2', 
		'\x2', '\x2', '\x1B06', '\x1B07', '\a', '\x163', '\x2', '\x2', '\x1B07', 
		'\x1B08', '\a', '\x24D', '\x2', '\x2', '\x1B08', '\x1B0D', '\x5', '\x5C8', 
		'\x2E5', '\x2', '\x1B09', '\x1B0A', '\a', '\x24F', '\x2', '\x2', '\x1B0A', 
		'\x1B0C', '\x5', '\x5C4', '\x2E3', '\x2', '\x1B0B', '\x1B09', '\x3', '\x2', 
		'\x2', '\x2', '\x1B0C', '\x1B0F', '\x3', '\x2', '\x2', '\x2', '\x1B0D', 
		'\x1B0B', '\x3', '\x2', '\x2', '\x2', '\x1B0D', '\x1B0E', '\x3', '\x2', 
		'\x2', '\x2', '\x1B0E', '\x1B10', '\x3', '\x2', '\x2', '\x2', '\x1B0F', 
		'\x1B0D', '\x3', '\x2', '\x2', '\x2', '\x1B10', '\x1B11', '\a', '\x24E', 
		'\x2', '\x2', '\x1B11', '\x5C7', '\x3', '\x2', '\x2', '\x2', '\x1B12', 
		'\x1B13', '\x5', 'N', '(', '\x2', '\x1B13', '\x1B1C', '\x5', '`', '\x31', 
		'\x2', '\x1B14', '\x1B16', '\x5', '\x5B2', '\x2DA', '\x2', '\x1B15', '\x1B14', 
		'\x3', '\x2', '\x2', '\x2', '\x1B15', '\x1B16', '\x3', '\x2', '\x2', '\x2', 
		'\x1B16', '\x1B17', '\x3', '\x2', '\x2', '\x2', '\x1B17', '\x1B1D', '\x5', 
		'\x5B6', '\x2DC', '\x2', '\x1B18', '\x1B1A', '\x5', '\x5B4', '\x2DB', 
		'\x2', '\x1B19', '\x1B1B', '\x5', '\x5B6', '\x2DC', '\x2', '\x1B1A', '\x1B19', 
		'\x3', '\x2', '\x2', '\x2', '\x1B1A', '\x1B1B', '\x3', '\x2', '\x2', '\x2', 
		'\x1B1B', '\x1B1D', '\x3', '\x2', '\x2', '\x2', '\x1B1C', '\x1B15', '\x3', 
		'\x2', '\x2', '\x2', '\x1B1C', '\x1B18', '\x3', '\x2', '\x2', '\x2', '\x1B1C', 
		'\x1B1D', '\x3', '\x2', '\x2', '\x2', '\x1B1D', '\x5C9', '\x3', '\x2', 
		'\x2', '\x2', '\x1B1E', '\x1B22', '\a', '\x22B', '\x2', '\x2', '\x1B1F', 
		'\x1B20', '\a', '\x22D', '\x2', '\x2', '\x1B20', '\x1B22', '\a', '\x14', 
		'\x2', '\x2', '\x1B21', '\x1B1E', '\x3', '\x2', '\x2', '\x2', '\x1B21', 
		'\x1B1F', '\x3', '\x2', '\x2', '\x2', '\x1B22', '\x1B23', '\x3', '\x2', 
		'\x2', '\x2', '\x1B23', '\x1B24', '\x5', '\x5CC', '\x2E7', '\x2', '\x1B24', 
		'\x1B25', '\x5', '\x5CE', '\x2E8', '\x2', '\x1B25', '\x5CB', '\x3', '\x2', 
		'\x2', '\x2', '\x1B26', '\x1B27', '\a', '\x24D', '\x2', '\x2', '\x1B27', 
		'\x1B28', '\x5', '&', '\x14', '\x2', '\x1B28', '\x1B29', '\a', '\x24E', 
		'\x2', '\x2', '\x1B29', '\x5CD', '\x3', '\x2', '\x2', '\x2', '\x1B2A', 
		'\x1B2B', '\a', '\x164', '\x2', '\x2', '\x1B2B', '\x1B2E', '\x5', '`', 
		'\x31', '\x2', '\x1B2C', '\x1B2F', '\x5', '\x5B2', '\x2DA', '\x2', '\x1B2D', 
		'\x1B2F', '\x5', '\x5B4', '\x2DB', '\x2', '\x1B2E', '\x1B2C', '\x3', '\x2', 
		'\x2', '\x2', '\x1B2E', '\x1B2D', '\x3', '\x2', '\x2', '\x2', '\x1B2E', 
		'\x1B2F', '\x3', '\x2', '\x2', '\x2', '\x1B2F', '\x5CF', '\x3', '\x2', 
		'\x2', '\x2', '\x1B30', '\x1B31', '\a', '\x1FD', '\x2', '\x2', '\x1B31', 
		'\x1B33', '\x5', '\x5CE', '\x2E8', '\x2', '\x1B32', '\x1B34', '\x5', '\x5D2', 
		'\x2EA', '\x2', '\x1B33', '\x1B32', '\x3', '\x2', '\x2', '\x2', '\x1B33', 
		'\x1B34', '\x3', '\x2', '\x2', '\x2', '\x1B34', '\x5D1', '\x3', '\x2', 
		'\x2', '\x2', '\x1B35', '\x1B36', '\a', '\xE2', '\x2', '\x2', '\x1B36', 
		'\x1B37', '\a', '\x33', '\x2', '\x2', '\x1B37', '\x1B3A', '\x5', '`', 
		'\x31', '\x2', '\x1B38', '\x1B3B', '\x5', '\x5B2', '\x2DA', '\x2', '\x1B39', 
		'\x1B3B', '\x5', '\x5B4', '\x2DB', '\x2', '\x1B3A', '\x1B38', '\x3', '\x2', 
		'\x2', '\x2', '\x1B3A', '\x1B39', '\x3', '\x2', '\x2', '\x2', '\x1B3A', 
		'\x1B3B', '\x3', '\x2', '\x2', '\x2', '\x1B3B', '\x5D3', '\x3', '\x2', 
		'\x2', '\x2', '\x1B3C', '\x1B3D', '\a', '\x1A8', '\x2', '\x2', '\x1B3D', 
		'\x1B3F', '\a', 'j', '\x2', '\x2', '\x1B3E', '\x1B40', '\x5', '\x5B8', 
		'\x2DD', '\x2', '\x1B3F', '\x1B3E', '\x3', '\x2', '\x2', '\x2', '\x1B3F', 
		'\x1B40', '\x3', '\x2', '\x2', '\x2', '\x1B40', '\x5D5', '\x3', '\x2', 
		'\x2', '\x2', '\x1B41', '\x1B42', '\a', '\x1F7', '\x2', '\x2', '\x1B42', 
		'\x1B43', '\x5', 'N', '(', '\x2', '\x1B43', '\x1B44', '\x5', '\xBA', '^', 
		'\x2', '\x1B44', '\x1B47', '\x5', '`', '\x31', '\x2', '\x1B45', '\x1B48', 
		'\x5', '\x5B2', '\x2DA', '\x2', '\x1B46', '\x1B48', '\x5', '\x5B4', '\x2DB', 
		'\x2', '\x1B47', '\x1B45', '\x3', '\x2', '\x2', '\x2', '\x1B47', '\x1B46', 
		'\x3', '\x2', '\x2', '\x2', '\x1B47', '\x1B48', '\x3', '\x2', '\x2', '\x2', 
		'\x1B48', '\x5D7', '\x3', '\x2', '\x2', '\x2', '\x1B49', '\x1B4B', '\x5', 
		'\x5DA', '\x2EE', '\x2', '\x1B4A', '\x1B4C', '\x5', '\x204', '\x103', 
		'\x2', '\x1B4B', '\x1B4A', '\x3', '\x2', '\x2', '\x2', '\x1B4B', '\x1B4C', 
		'\x3', '\x2', '\x2', '\x2', '\x1B4C', '\x1B4E', '\x3', '\x2', '\x2', '\x2', 
		'\x1B4D', '\x1B4F', '\x5', '\x5B8', '\x2DD', '\x2', '\x1B4E', '\x1B4D', 
		'\x3', '\x2', '\x2', '\x2', '\x1B4E', '\x1B4F', '\x3', '\x2', '\x2', '\x2', 
		'\x1B4F', '\x1B51', '\x3', '\x2', '\x2', '\x2', '\x1B50', '\x1B52', '\x5', 
		'\x5DC', '\x2EF', '\x2', '\x1B51', '\x1B50', '\x3', '\x2', '\x2', '\x2', 
		'\x1B51', '\x1B52', '\x3', '\x2', '\x2', '\x2', '\x1B52', '\x5D9', '\x3', 
		'\x2', '\x2', '\x2', '\x1B53', '\x1B54', '\a', 'j', '\x2', '\x2', '\x1B54', 
		'\x1B55', '\x5', '\\', '/', '\x2', '\x1B55', '\x5DB', '\x3', '\x2', '\x2', 
		'\x2', '\x1B56', '\x1B57', '\a', '\xF7', '\x2', '\x2', '\x1B57', '\x1B58', 
		'\x5', '\x3F6', '\x1FC', '\x2', '\x1B58', '\x5DD', '\x3', '\x2', '\x2', 
		'\x2', '\x1B59', '\x1B63', '\a', '\x190', '\x2', '\x2', '\x1B5A', '\x1B64', 
		'\x5', '\x5E0', '\x2F1', '\x2', '\x1B5B', '\x1B64', '\x5', '\x5E2', '\x2F2', 
		'\x2', '\x1B5C', '\x1B64', '\x5', '\x5E4', '\x2F3', '\x2', '\x1B5D', '\x1B64', 
		'\x5', '\x5E6', '\x2F4', '\x2', '\x1B5E', '\x1B64', '\x5', '\x5E8', '\x2F5', 
		'\x2', '\x1B5F', '\x1B64', '\x5', '\x5EA', '\x2F6', '\x2', '\x1B60', '\x1B64', 
		'\x5', '\x5EC', '\x2F7', '\x2', '\x1B61', '\x1B64', '\x5', '\x5EE', '\x2F8', 
		'\x2', '\x1B62', '\x1B64', '\x5', '\x5F0', '\x2F9', '\x2', '\x1B63', '\x1B5A', 
		'\x3', '\x2', '\x2', '\x2', '\x1B63', '\x1B5B', '\x3', '\x2', '\x2', '\x2', 
		'\x1B63', '\x1B5C', '\x3', '\x2', '\x2', '\x2', '\x1B63', '\x1B5D', '\x3', 
		'\x2', '\x2', '\x2', '\x1B63', '\x1B5E', '\x3', '\x2', '\x2', '\x2', '\x1B63', 
		'\x1B5F', '\x3', '\x2', '\x2', '\x2', '\x1B63', '\x1B60', '\x3', '\x2', 
		'\x2', '\x2', '\x1B63', '\x1B61', '\x3', '\x2', '\x2', '\x2', '\x1B63', 
		'\x1B62', '\x3', '\x2', '\x2', '\x2', '\x1B64', '\x5DF', '\x3', '\x2', 
		'\x2', '\x2', '\x1B65', '\x1B66', '\a', '\xA6', '\x2', '\x2', '\x1B66', 
		'\x1B67', '\a', '\x24D', '\x2', '\x2', '\x1B67', '\x1B68', '\x5', '\x42', 
		'\"', '\x2', '\x1B68', '\x1B69', '\a', '\x24F', '\x2', '\x2', '\x1B69', 
		'\x1B6A', '\x5', '\xA0', 'Q', '\x2', '\x1B6A', '\x1B6B', '\a', '\x24E', 
		'\x2', '\x2', '\x1B6B', '\x5E1', '\x3', '\x2', '\x2', '\x2', '\x1B6C', 
		'\x1B6D', '\a', '\x1F', '\x2', '\x2', '\x1B6D', '\x5E3', '\x3', '\x2', 
		'\x2', '\x2', '\x1B6E', '\x1B6F', '\a', '\x1D6', '\x2', '\x2', '\x1B6F', 
		'\x5E5', '\x3', '\x2', '\x2', '\x2', '\x1B70', '\x1B71', '\a', '\x1B2', 
		'\x2', '\x2', '\x1B71', '\x1B73', '\a', '\x24D', '\x2', '\x2', '\x1B72', 
		'\x1B74', '\x5', '\x178', '\xBD', '\x2', '\x1B73', '\x1B72', '\x3', '\x2', 
		'\x2', '\x2', '\x1B73', '\x1B74', '\x3', '\x2', '\x2', '\x2', '\x1B74', 
		'\x1B75', '\x3', '\x2', '\x2', '\x2', '\x1B75', '\x1B76', '\a', '\x24E', 
		'\x2', '\x2', '\x1B76', '\x5E7', '\x3', '\x2', '\x2', '\x2', '\x1B77', 
		'\x1B78', '\a', '/', '\x2', '\x2', '\x1B78', '\x1B7A', '\a', '\x24D', 
		'\x2', '\x2', '\x1B79', '\x1B7B', '\x5', '\x16A', '\xB6', '\x2', '\x1B7A', 
		'\x1B79', '\x3', '\x2', '\x2', '\x2', '\x1B7A', '\x1B7B', '\x3', '\x2', 
		'\x2', '\x2', '\x1B7B', '\x1B7C', '\x3', '\x2', '\x2', '\x2', '\x1B7C', 
		'\x1B7D', '\a', '\x24E', '\x2', '\x2', '\x1B7D', '\x5E9', '\x3', '\x2', 
		'\x2', '\x2', '\x1B7E', '\x1B7F', '\a', '\xB9', '\x2', '\x2', '\x1B7F', 
		'\x1B81', '\a', '\x24D', '\x2', '\x2', '\x1B80', '\x1B82', '\x5', '\x16A', 
		'\xB6', '\x2', '\x1B81', '\x1B80', '\x3', '\x2', '\x2', '\x2', '\x1B81', 
		'\x1B82', '\x3', '\x2', '\x2', '\x2', '\x1B82', '\x1B83', '\x3', '\x2', 
		'\x2', '\x2', '\x1B83', '\x1B84', '\a', '\x24E', '\x2', '\x2', '\x1B84', 
		'\x5EB', '\x3', '\x2', '\x2', '\x2', '\x1B85', '\x1B86', '\a', '\xF0', 
		'\x2', '\x2', '\x1B86', '\x1B88', '\a', '\x24D', '\x2', '\x2', '\x1B87', 
		'\x1B89', '\x5', '\x16A', '\xB6', '\x2', '\x1B88', '\x1B87', '\x3', '\x2', 
		'\x2', '\x2', '\x1B88', '\x1B89', '\x3', '\x2', '\x2', '\x2', '\x1B89', 
		'\x1B8A', '\x3', '\x2', '\x2', '\x2', '\x1B8A', '\x1B8B', '\a', '\x24E', 
		'\x2', '\x2', '\x1B8B', '\x5ED', '\x3', '\x2', '\x2', '\x2', '\x1B8C', 
		'\x1B8D', '\a', '\x206', '\x2', '\x2', '\x1B8D', '\x1B8F', '\a', '\x24D', 
		'\x2', '\x2', '\x1B8E', '\x1B90', '\x5', '\x16A', '\xB6', '\x2', '\x1B8F', 
		'\x1B8E', '\x3', '\x2', '\x2', '\x2', '\x1B8F', '\x1B90', '\x3', '\x2', 
		'\x2', '\x2', '\x1B90', '\x1B91', '\x3', '\x2', '\x2', '\x2', '\x1B91', 
		'\x1B92', '\a', '\x24E', '\x2', '\x2', '\x1B92', '\x5EF', '\x3', '\x2', 
		'\x2', '\x2', '\x1B93', '\x1B94', '\a', '\x142', '\x2', '\x2', '\x1B94', 
		'\x1B96', '\a', '\x24D', '\x2', '\x2', '\x1B95', '\x1B97', '\x5', '\x16A', 
		'\xB6', '\x2', '\x1B96', '\x1B95', '\x3', '\x2', '\x2', '\x2', '\x1B96', 
		'\x1B97', '\x3', '\x2', '\x2', '\x2', '\x1B97', '\x1B98', '\x3', '\x2', 
		'\x2', '\x2', '\x1B98', '\x1B99', '\a', '\x24E', '\x2', '\x2', '\x1B99', 
		'\x5F1', '\x3', '\x2', '\x2', '\x2', '\x1B9A', '\x1B9C', '\x5', 'N', '(', 
		'\x2', '\x1B9B', '\x1B9D', '\x5', '\x5F4', '\x2FB', '\x2', '\x1B9C', '\x1B9B', 
		'\x3', '\x2', '\x2', '\x2', '\x1B9C', '\x1B9D', '\x3', '\x2', '\x2', '\x2', 
		'\x1B9D', '\x1B9E', '\x3', '\x2', '\x2', '\x2', '\x1B9E', '\x1BA7', '\x5', 
		'`', '\x31', '\x2', '\x1B9F', '\x1BA1', '\x5', '\x5B2', '\x2DA', '\x2', 
		'\x1BA0', '\x1B9F', '\x3', '\x2', '\x2', '\x2', '\x1BA0', '\x1BA1', '\x3', 
		'\x2', '\x2', '\x2', '\x1BA1', '\x1BA2', '\x3', '\x2', '\x2', '\x2', '\x1BA2', 
		'\x1BA8', '\x5', '\x5B6', '\x2DC', '\x2', '\x1BA3', '\x1BA5', '\x5', '\x5B4', 
		'\x2DB', '\x2', '\x1BA4', '\x1BA6', '\x5', '\x5B6', '\x2DC', '\x2', '\x1BA5', 
		'\x1BA4', '\x3', '\x2', '\x2', '\x2', '\x1BA5', '\x1BA6', '\x3', '\x2', 
		'\x2', '\x2', '\x1BA6', '\x1BA8', '\x3', '\x2', '\x2', '\x2', '\x1BA7', 
		'\x1BA0', '\x3', '\x2', '\x2', '\x2', '\x1BA7', '\x1BA3', '\x3', '\x2', 
		'\x2', '\x2', '\x1BA7', '\x1BA8', '\x3', '\x2', '\x2', '\x2', '\x1BA8', 
		'\x5F3', '\x3', '\x2', '\x2', '\x2', '\x1BA9', '\x1BAA', '\a', 'Z', '\x2', 
		'\x2', '\x1BAA', '\x5F5', '\x3', '\x2', '\x2', '\x2', '\x1BAB', '\x1BB0', 
		'\a', '\x8F', '\x2', '\x2', '\x1BAC', '\x1BB1', '\x5', '\x5FC', '\x2FF', 
		'\x2', '\x1BAD', '\x1BB1', '\x5', '\x5F8', '\x2FD', '\x2', '\x1BAE', '\x1BB1', 
		'\x5', '\x5FE', '\x300', '\x2', '\x1BAF', '\x1BB1', '\x5', '\x600', '\x301', 
		'\x2', '\x1BB0', '\x1BAC', '\x3', '\x2', '\x2', '\x2', '\x1BB0', '\x1BAD', 
		'\x3', '\x2', '\x2', '\x2', '\x1BB0', '\x1BAE', '\x3', '\x2', '\x2', '\x2', 
		'\x1BB0', '\x1BAF', '\x3', '\x2', '\x2', '\x2', '\x1BB1', '\x5F7', '\x3', 
		'\x2', '\x2', '\x2', '\x1BB2', '\x1BB3', '\a', '\x215', '\x2', '\x2', 
		'\x1BB3', '\x1BB5', '\x5', '\x44', '#', '\x2', '\x1BB4', '\x1BB6', '\x5', 
		'\x5FA', '\x2FE', '\x2', '\x1BB5', '\x1BB4', '\x3', '\x2', '\x2', '\x2', 
		'\x1BB5', '\x1BB6', '\x3', '\x2', '\x2', '\x2', '\x1BB6', '\x5F9', '\x3', 
		'\x2', '\x2', '\x2', '\x1BB7', '\x1BB8', '\t', '_', '\x2', '\x2', '\x1BB8', 
		'\x5FB', '\x3', '\x2', '\x2', '\x2', '\x1BB9', '\x1BBA', '\a', '\x215', 
		'\x2', '\x2', '\x1BBA', '\x1BBB', '\a', '*', '\x2', '\x2', '\x1BBB', '\x1BBC', 
		'\x5', '\x44', '#', '\x2', '\x1BBC', '\x5FD', '\x3', '\x2', '\x2', '\x2', 
		'\x1BBD', '\x1BBE', '\a', '\x210', '\x2', '\x2', '\x1BBE', '\x1BBF', '\x5', 
		'\x44', '#', '\x2', '\x1BBF', '\x5FF', '\x3', '\x2', '\x2', '\x2', '\x1BC0', 
		'\x1BC1', '\a', '\xE2', '\x2', '\x2', '\x1BC1', '\x1BC3', '\x5', '\x44', 
		'#', '\x2', '\x1BC2', '\x1BC4', '\a', '\xC0', '\x2', '\x2', '\x1BC3', 
		'\x1BC2', '\x3', '\x2', '\x2', '\x2', '\x1BC3', '\x1BC4', '\x3', '\x2', 
		'\x2', '\x2', '\x1BC4', '\x601', '\x3', '\x2', '\x2', '\x2', '\x1BC5', 
		'\x1BCA', '\a', '\r', '\x2', '\x2', '\x1BC6', '\x1BCB', '\x5', '\x604', 
		'\x303', '\x2', '\x1BC7', '\x1BCB', '\x5', '\x668', '\x335', '\x2', '\x1BC8', 
		'\x1BCB', '\x5', '\x608', '\x305', '\x2', '\x1BC9', '\x1BCB', '\x5', '\x60E', 
		'\x308', '\x2', '\x1BCA', '\x1BC6', '\x3', '\x2', '\x2', '\x2', '\x1BCA', 
		'\x1BC7', '\x3', '\x2', '\x2', '\x2', '\x1BCA', '\x1BC8', '\x3', '\x2', 
		'\x2', '\x2', '\x1BCA', '\x1BC9', '\x3', '\x2', '\x2', '\x2', '\x1BCB', 
		'\x603', '\x3', '\x2', '\x2', '\x2', '\x1BCC', '\x1BCD', '\a', '\x215', 
		'\x2', '\x2', '\x1BCD', '\x1BD4', '\x5', '\x44', '#', '\x2', '\x1BCE', 
		'\x1BD5', '\x5', '\x644', '\x323', '\x2', '\x1BCF', '\x1BD5', '\x5', '\x648', 
		'\x325', '\x2', '\x1BD0', '\x1BD2', '\x5', '\x606', '\x304', '\x2', '\x1BD1', 
		'\x1BD3', '\x5', '\x65A', '\x32E', '\x2', '\x1BD2', '\x1BD1', '\x3', '\x2', 
		'\x2', '\x2', '\x1BD2', '\x1BD3', '\x3', '\x2', '\x2', '\x2', '\x1BD3', 
		'\x1BD5', '\x3', '\x2', '\x2', '\x2', '\x1BD4', '\x1BCE', '\x3', '\x2', 
		'\x2', '\x2', '\x1BD4', '\x1BCF', '\x3', '\x2', '\x2', '\x2', '\x1BD4', 
		'\x1BD0', '\x3', '\x2', '\x2', '\x2', '\x1BD5', '\x605', '\x3', '\x2', 
		'\x2', '\x2', '\x1BD6', '\x1BE0', '\x5', '\x64A', '\x326', '\x2', '\x1BD7', 
		'\x1BE0', '\x5', '\x658', '\x32D', '\x2', '\x1BD8', '\x1BE0', '\x5', '\x64E', 
		'\x328', '\x2', '\x1BD9', '\x1BDB', '\x5', '\x6AC', '\x357', '\x2', '\x1BDA', 
		'\x1BD9', '\x3', '\x2', '\x2', '\x2', '\x1BDB', '\x1BDE', '\x3', '\x2', 
		'\x2', '\x2', '\x1BDC', '\x1BDA', '\x3', '\x2', '\x2', '\x2', '\x1BDC', 
		'\x1BDD', '\x3', '\x2', '\x2', '\x2', '\x1BDD', '\x1BE0', '\x3', '\x2', 
		'\x2', '\x2', '\x1BDE', '\x1BDC', '\x3', '\x2', '\x2', '\x2', '\x1BDF', 
		'\x1BD6', '\x3', '\x2', '\x2', '\x2', '\x1BDF', '\x1BD7', '\x3', '\x2', 
		'\x2', '\x2', '\x1BDF', '\x1BD8', '\x3', '\x2', '\x2', '\x2', '\x1BDF', 
		'\x1BDC', '\x3', '\x2', '\x2', '\x2', '\x1BE0', '\x607', '\x3', '\x2', 
		'\x2', '\x2', '\x1BE1', '\x1BE2', '\a', '\x210', '\x2', '\x2', '\x1BE2', 
		'\x1BE7', '\x5', '\x44', '#', '\x2', '\x1BE3', '\x1BE8', '\a', '\x9A', 
		'\x2', '\x2', '\x1BE4', '\x1BE8', '\a', '\x8A', '\x2', '\x2', '\x1BE5', 
		'\x1BE8', '\x5', '\x60A', '\x306', '\x2', '\x1BE6', '\x1BE8', '\x5', '\x60C', 
		'\x307', '\x2', '\x1BE7', '\x1BE3', '\x3', '\x2', '\x2', '\x2', '\x1BE7', 
		'\x1BE4', '\x3', '\x2', '\x2', '\x2', '\x1BE7', '\x1BE5', '\x3', '\x2', 
		'\x2', '\x2', '\x1BE7', '\x1BE6', '\x3', '\x2', '\x2', '\x2', '\x1BE8', 
		'\x609', '\x3', '\x2', '\x2', '\x2', '\x1BE9', '\x1BEA', '\a', '\x1B0', 
		'\x2', '\x2', '\x1BEA', '\x1BEB', '\a', '\x20B', '\x2', '\x2', '\x1BEB', 
		'\x1BEC', '\x5', '\\', '/', '\x2', '\x1BEC', '\x60B', '\x3', '\x2', '\x2', 
		'\x2', '\x1BED', '\x1BEF', '\a', 'Q', '\x2', '\x2', '\x1BEE', '\x1BF0', 
		'\a', 't', '\x2', '\x2', '\x1BEF', '\x1BEE', '\x3', '\x2', '\x2', '\x2', 
		'\x1BEF', '\x1BF0', '\x3', '\x2', '\x2', '\x2', '\x1BF0', '\x1BF2', '\x3', 
		'\x2', '\x2', '\x2', '\x1BF1', '\x1BF3', '\x5', '\x646', '\x324', '\x2', 
		'\x1BF2', '\x1BF1', '\x3', '\x2', '\x2', '\x2', '\x1BF2', '\x1BF3', '\x3', 
		'\x2', '\x2', '\x2', '\x1BF3', '\x1BF6', '\x3', '\x2', '\x2', '\x2', '\x1BF4', 
		'\x1BF5', '\a', '\x1B8', '\x2', '\x2', '\x1BF5', '\x1BF7', '\a', '\x1DC', 
		'\x2', '\x2', '\x1BF6', '\x1BF4', '\x3', '\x2', '\x2', '\x2', '\x1BF6', 
		'\x1BF7', '\x3', '\x2', '\x2', '\x2', '\x1BF7', '\x60D', '\x3', '\x2', 
		'\x2', '\x2', '\x1BF8', '\x1BF9', '\a', '\xE2', '\x2', '\x2', '\x1BF9', 
		'\x1C08', '\x5', '\x44', '#', '\x2', '\x1BFA', '\x1C09', '\a', '\x9A', 
		'\x2', '\x2', '\x1BFB', '\x1C09', '\a', '\x8A', '\x2', '\x2', '\x1BFC', 
		'\x1C09', '\a', '\x21E', '\x2', '\x2', '\x1BFD', '\x1C09', '\a', '\x46', 
		'\x2', '\x2', '\x1BFE', '\x1BFF', '\t', '/', '\x2', '\x2', '\x1BFF', '\x1C09', 
		'\a', '\x222', '\x2', '\x2', '\x1C00', '\x1C01', '\a', '\x220', '\x2', 
		'\x2', '\x1C01', '\x1C02', '\a', ')', '\x2', '\x2', '\x1C02', '\x1C09', 
		'\a', '\x1A9', '\x2', '\x2', '\x1C03', '\x1C09', '\x5', '\x610', '\x309', 
		'\x2', '\x1C04', '\x1C09', '\x5', '\x620', '\x311', '\x2', '\x1C05', '\x1C09', 
		'\x5', '\x626', '\x314', '\x2', '\x1C06', '\x1C09', '\x5', '\x60A', '\x306', 
		'\x2', '\x1C07', '\x1C09', '\x5', '\x628', '\x315', '\x2', '\x1C08', '\x1BFA', 
		'\x3', '\x2', '\x2', '\x2', '\x1C08', '\x1BFB', '\x3', '\x2', '\x2', '\x2', 
		'\x1C08', '\x1BFC', '\x3', '\x2', '\x2', '\x2', '\x1C08', '\x1BFD', '\x3', 
		'\x2', '\x2', '\x2', '\x1C08', '\x1BFE', '\x3', '\x2', '\x2', '\x2', '\x1C08', 
		'\x1C00', '\x3', '\x2', '\x2', '\x2', '\x1C08', '\x1C03', '\x3', '\x2', 
		'\x2', '\x2', '\x1C08', '\x1C04', '\x3', '\x2', '\x2', '\x2', '\x1C08', 
		'\x1C05', '\x3', '\x2', '\x2', '\x2', '\x1C08', '\x1C06', '\x3', '\x2', 
		'\x2', '\x2', '\x1C08', '\x1C07', '\x3', '\x2', '\x2', '\x2', '\x1C09', 
		'\x60F', '\x3', '\x2', '\x2', '\x2', '\x1C0A', '\x1C11', '\x5', '\x612', 
		'\x30A', '\x2', '\x1C0B', '\x1C11', '\x5', '\x616', '\x30C', '\x2', '\x1C0C', 
		'\x1C11', '\x5', '\x61C', '\x30F', '\x2', '\x1C0D', '\x1C11', '\x5', '\x274', 
		'\x13B', '\x2', '\x1C0E', '\x1C11', '\x5', '\x61E', '\x310', '\x2', '\x1C0F', 
		'\x1C11', '\x5', '\x37E', '\x1C0', '\x2', '\x1C10', '\x1C0A', '\x3', '\x2', 
		'\x2', '\x2', '\x1C10', '\x1C0B', '\x3', '\x2', '\x2', '\x2', '\x1C10', 
		'\x1C0C', '\x3', '\x2', '\x2', '\x2', '\x1C10', '\x1C0D', '\x3', '\x2', 
		'\x2', '\x2', '\x1C10', '\x1C0E', '\x3', '\x2', '\x2', '\x2', '\x1C10', 
		'\x1C0F', '\x3', '\x2', '\x2', '\x2', '\x1C11', '\x1C14', '\x3', '\x2', 
		'\x2', '\x2', '\x1C12', '\x1C10', '\x3', '\x2', '\x2', '\x2', '\x1C12', 
		'\x1C13', '\x3', '\x2', '\x2', '\x2', '\x1C13', '\x611', '\x3', '\x2', 
		'\x2', '\x2', '\x1C14', '\x1C12', '\x3', '\x2', '\x2', '\x2', '\x1C15', 
		'\x1C16', '\a', 's', '\x2', '\x2', '\x1C16', '\x1C18', '\a', '\x21F', 
		'\x2', '\x2', '\x1C17', '\x1C19', '\x5', '\x614', '\x30B', '\x2', '\x1C18', 
		'\x1C17', '\x3', '\x2', '\x2', '\x2', '\x1C18', '\x1C19', '\x3', '\x2', 
		'\x2', '\x2', '\x1C19', '\x613', '\x3', '\x2', '\x2', '\x2', '\x1C1A', 
		'\x1C1B', '\a', '\xFE', '\x2', '\x2', '\x1C1B', '\x1C1C', '\x5', '\x3A6', 
		'\x1D4', '\x2', '\x1C1C', '\x615', '\x3', '\x2', '\x2', '\x2', '\x1C1D', 
		'\x1C1E', '\a', '\v', '\x2', '\x2', '\x1C1E', '\x1C20', '\a', '\xB0', 
		'\x2', '\x2', '\x1C1F', '\x1C21', '\x5', '\x618', '\x30D', '\x2', '\x1C20', 
		'\x1C1F', '\x3', '\x2', '\x2', '\x2', '\x1C20', '\x1C21', '\x3', '\x2', 
		'\x2', '\x2', '\x1C21', '\x617', '\x3', '\x2', '\x2', '\x2', '\x1C22', 
		'\x1C24', '\a', '\x24D', '\x2', '\x2', '\x1C23', '\x1C25', '\x5', '\x61A', 
		'\x30E', '\x2', '\x1C24', '\x1C23', '\x3', '\x2', '\x2', '\x2', '\x1C25', 
		'\x1C26', '\x3', '\x2', '\x2', '\x2', '\x1C26', '\x1C24', '\x3', '\x2', 
		'\x2', '\x2', '\x1C26', '\x1C27', '\x3', '\x2', '\x2', '\x2', '\x1C27', 
		'\x1C28', '\x3', '\x2', '\x2', '\x2', '\x1C28', '\x1C29', '\a', '\x24E', 
		'\x2', '\x2', '\x1C29', '\x619', '\x3', '\x2', '\x2', '\x2', '\x1C2A', 
		'\x1C2B', '\a', '\x1E1', '\x2', '\x2', '\x1C2B', '\x1C31', '\x5', '\x3A6', 
		'\x1D4', '\x2', '\x1C2C', '\x1C2D', '\a', 'n', '\x2', '\x2', '\x1C2D', 
		'\x1C31', '\x5', '\xA0', 'Q', '\x2', '\x1C2E', '\x1C2F', '\a', '\xED', 
		'\x2', '\x2', '\x1C2F', '\x1C31', '\x5', '&', '\x14', '\x2', '\x1C30', 
		'\x1C2A', '\x3', '\x2', '\x2', '\x2', '\x1C30', '\x1C2C', '\x3', '\x2', 
		'\x2', '\x2', '\x1C30', '\x1C2E', '\x3', '\x2', '\x2', '\x2', '\x1C31', 
		'\x61B', '\x3', '\x2', '\x2', '\x2', '\x1C32', '\x1C33', '\a', '\x1DE', 
		'\x2', '\x2', '\x1C33', '\x1C35', '\a', '\x1E5', '\x2', '\x2', '\x1C34', 
		'\x1C36', '\a', 'P', '\x2', '\x2', '\x1C35', '\x1C34', '\x3', '\x2', '\x2', 
		'\x2', '\x1C35', '\x1C36', '\x3', '\x2', '\x2', '\x2', '\x1C36', '\x1C38', 
		'\x3', '\x2', '\x2', '\x2', '\x1C37', '\x1C39', '\a', '\x38', '\x2', '\x2', 
		'\x1C38', '\x1C37', '\x3', '\x2', '\x2', '\x2', '\x1C38', '\x1C39', '\x3', 
		'\x2', '\x2', '\x2', '\x1C39', '\x61D', '\x3', '\x2', '\x2', '\x2', '\x1C3A', 
		'\x1C3B', '\a', '\x185', '\x2', '\x2', '\x1C3B', '\x1C44', '\x5', '&', 
		'\x14', '\x2', '\x1C3C', '\x1C3D', '\a', '\x188', '\x2', '\x2', '\x1C3D', 
		'\x1C44', '\x5', '&', '\x14', '\x2', '\x1C3E', '\x1C3F', '\a', '\xEA', 
		'\x2', '\x2', '\x1C3F', '\x1C44', '\x5', '&', '\x14', '\x2', '\x1C40', 
		'\x1C41', '\a', '\x125', '\x2', '\x2', '\x1C41', '\x1C44', '\x5', '&', 
		'\x14', '\x2', '\x1C42', '\x1C44', '\x5', '\x384', '\x1C3', '\x2', '\x1C43', 
		'\x1C3A', '\x3', '\x2', '\x2', '\x2', '\x1C43', '\x1C3C', '\x3', '\x2', 
		'\x2', '\x2', '\x1C43', '\x1C3E', '\x3', '\x2', '\x2', '\x2', '\x1C43', 
		'\x1C40', '\x3', '\x2', '\x2', '\x2', '\x1C43', '\x1C42', '\x3', '\x2', 
		'\x2', '\x2', '\x1C44', '\x61F', '\x3', '\x2', '\x2', '\x2', '\x1C45', 
		'\x1C4C', '\a', '\x1A4', '\x2', '\x2', '\x1C46', '\x1C47', '\a', '\x180', 
		'\x2', '\x2', '\x1C47', '\x1C4D', '\x5', '\\', '/', '\x2', '\x1C48', '\x1C49', 
		'\a', '\x1F4', '\x2', '\x2', '\x1C49', '\x1C4D', '\x5', '\\', '/', '\x2', 
		'\x1C4A', '\x1C4D', '\a', '\x1B9', '\x2', '\x2', '\x1C4B', '\x1C4D', '\a', 
		'\x157', '\x2', '\x2', '\x1C4C', '\x1C46', '\x3', '\x2', '\x2', '\x2', 
		'\x1C4C', '\x1C48', '\x3', '\x2', '\x2', '\x2', '\x1C4C', '\x1C4A', '\x3', 
		'\x2', '\x2', '\x2', '\x1C4C', '\x1C4B', '\x3', '\x2', '\x2', '\x2', '\x1C4C', 
		'\x1C4D', '\x3', '\x2', '\x2', '\x2', '\x1C4D', '\x1C51', '\x3', '\x2', 
		'\x2', '\x2', '\x1C4E', '\x1C50', '\x5', '\x622', '\x312', '\x2', '\x1C4F', 
		'\x1C4E', '\x3', '\x2', '\x2', '\x2', '\x1C50', '\x1C53', '\x3', '\x2', 
		'\x2', '\x2', '\x1C51', '\x1C4F', '\x3', '\x2', '\x2', '\x2', '\x1C51', 
		'\x1C52', '\x3', '\x2', '\x2', '\x2', '\x1C52', '\x621', '\x3', '\x2', 
		'\x2', '\x2', '\x1C53', '\x1C51', '\x3', '\x2', '\x2', '\x2', '\x1C54', 
		'\x1C5E', '\x5', '\x274', '\x13B', '\x2', '\x1C55', '\x1C5E', '\x5', '\x380', 
		'\x1C1', '\x2', '\x1C56', '\x1C5E', '\x5', '\x626', '\x314', '\x2', '\x1C57', 
		'\x1C5E', '\a', '\x16A', '\x2', '\x2', '\x1C58', '\x1C59', '\a', 'V', 
		'\x2', '\x2', '\x1C59', '\x1C5E', '\a', '\x1EC', '\x2', '\x2', '\x1C5A', 
		'\x1C5E', '\x5', '\x61E', '\x310', '\x2', '\x1C5B', '\x1C5E', '\x5', '\x624', 
		'\x313', '\x2', '\x1C5C', '\x1C5E', '\x5', '\x37E', '\x1C0', '\x2', '\x1C5D', 
		'\x1C54', '\x3', '\x2', '\x2', '\x2', '\x1C5D', '\x1C55', '\x3', '\x2', 
		'\x2', '\x2', '\x1C5D', '\x1C56', '\x3', '\x2', '\x2', '\x2', '\x1C5D', 
		'\x1C57', '\x3', '\x2', '\x2', '\x2', '\x1C5D', '\x1C58', '\x3', '\x2', 
		'\x2', '\x2', '\x1C5D', '\x1C5A', '\x3', '\x2', '\x2', '\x2', '\x1C5D', 
		'\x1C5B', '\x3', '\x2', '\x2', '\x2', '\x1C5D', '\x1C5C', '\x3', '\x2', 
		'\x2', '\x2', '\x1C5E', '\x623', '\x3', '\x2', '\x2', '\x2', '\x1C5F', 
		'\x1C61', '\a', 'T', '\x2', '\x2', '\x1C60', '\x1C62', '\x5', '&', '\x14', 
		'\x2', '\x1C61', '\x1C60', '\x3', '\x2', '\x2', '\x2', '\x1C61', '\x1C62', 
		'\x3', '\x2', '\x2', '\x2', '\x1C62', '\x1C65', '\x3', '\x2', '\x2', '\x2', 
		'\x1C63', '\x1C65', '\a', '\x147', '\x2', '\x2', '\x1C64', '\x1C5F', '\x3', 
		'\x2', '\x2', '\x2', '\x1C64', '\x1C63', '\x3', '\x2', '\x2', '\x2', '\x1C65', 
		'\x625', '\x3', '\x2', '\x2', '\x2', '\x1C66', '\x1C67', '\a', '\x17D', 
		'\x2', '\x2', '\x1C67', '\x1C68', '\x5', '\xA0', 'Q', '\x2', '\x1C68', 
		'\x627', '\x3', '\x2', '\x2', '\x2', '\x1C69', '\x1C72', '\x5', '\x62A', 
		'\x316', '\x2', '\x1C6A', '\x1C72', '\x5', '\x62E', '\x318', '\x2', '\x1C6B', 
		'\x1C72', '\x5', '\x632', '\x31A', '\x2', '\x1C6C', '\x1C72', '\x5', '\x636', 
		'\x31C', '\x2', '\x1C6D', '\x1C72', '\x5', '\x638', '\x31D', '\x2', '\x1C6E', 
		'\x1C72', '\x5', '\x63A', '\x31E', '\x2', '\x1C6F', '\x1C72', '\x5', '\x630', 
		'\x319', '\x2', '\x1C70', '\x1C72', '\x5', '\x642', '\x322', '\x2', '\x1C71', 
		'\x1C69', '\x3', '\x2', '\x2', '\x2', '\x1C71', '\x1C6A', '\x3', '\x2', 
		'\x2', '\x2', '\x1C71', '\x1C6B', '\x3', '\x2', '\x2', '\x2', '\x1C71', 
		'\x1C6C', '\x3', '\x2', '\x2', '\x2', '\x1C71', '\x1C6D', '\x3', '\x2', 
		'\x2', '\x2', '\x1C71', '\x1C6E', '\x3', '\x2', '\x2', '\x2', '\x1C71', 
		'\x1C6F', '\x3', '\x2', '\x2', '\x2', '\x1C71', '\x1C70', '\x3', '\x2', 
		'\x2', '\x2', '\x1C72', '\x629', '\x3', '\x2', '\x2', '\x2', '\x1C73', 
		'\x1C74', '\a', '\x133', '\x2', '\x2', '\x1C74', '\x1C75', '\a', 'y', 
		'\x2', '\x2', '\x1C75', '\x1C79', '\a', '\x1A', '\x2', '\x2', '\x1C76', 
		'\x1C77', '\a', '\xBE', '\x2', '\x2', '\x1C77', '\x1C78', '\a', '\x180', 
		'\x2', '\x2', '\x1C78', '\x1C7A', '\x5', '\\', '/', '\x2', '\x1C79', '\x1C76', 
		'\x3', '\x2', '\x2', '\x2', '\x1C79', '\x1C7A', '\x3', '\x2', '\x2', '\x2', 
		'\x1C7A', '\x1C7C', '\x3', '\x2', '\x2', '\x2', '\x1C7B', '\x1C7D', '\x5', 
		'\x62C', '\x317', '\x2', '\x1C7C', '\x1C7B', '\x3', '\x2', '\x2', '\x2', 
		'\x1C7D', '\x1C7E', '\x3', '\x2', '\x2', '\x2', '\x1C7E', '\x1C7C', '\x3', 
		'\x2', '\x2', '\x2', '\x1C7E', '\x1C7F', '\x3', '\x2', '\x2', '\x2', '\x1C7F', 
		'\x62B', '\x3', '\x2', '\x2', '\x2', '\x1C80', '\x1C84', '\x5', '\x61E', 
		'\x310', '\x2', '\x1C81', '\x1C84', '\x5', '\x380', '\x1C1', '\x2', '\x1C82', 
		'\x1C84', '\x5', '\x37E', '\x1C0', '\x2', '\x1C83', '\x1C80', '\x3', '\x2', 
		'\x2', '\x2', '\x1C83', '\x1C81', '\x3', '\x2', '\x2', '\x2', '\x1C83', 
		'\x1C82', '\x3', '\x2', '\x2', '\x2', '\x1C84', '\x62D', '\x3', '\x2', 
		'\x2', '\x2', '\x1C85', '\x1C86', '\a', '\x5', '\x2', '\x2', '\x1C86', 
		'\x1C88', '\a', '\x180', '\x2', '\x2', '\x1C87', '\x1C89', '\x5', '\\', 
		'/', '\x2', '\x1C88', '\x1C87', '\x3', '\x2', '\x2', '\x2', '\x1C88', 
		'\x1C89', '\x3', '\x2', '\x2', '\x2', '\x1C89', '\x1C8B', '\x3', '\x2', 
		'\x2', '\x2', '\x1C8A', '\x1C8C', '\x5', '\x380', '\x1C1', '\x2', '\x1C8B', 
		'\x1C8A', '\x3', '\x2', '\x2', '\x2', '\x1C8B', '\x1C8C', '\x3', '\x2', 
		'\x2', '\x2', '\x1C8C', '\x1C8E', '\x3', '\x2', '\x2', '\x2', '\x1C8D', 
		'\x1C8F', '\x5', '\x274', '\x13B', '\x2', '\x1C8E', '\x1C8D', '\x3', '\x2', 
		'\x2', '\x2', '\x1C8E', '\x1C8F', '\x3', '\x2', '\x2', '\x2', '\x1C8F', 
		'\x62F', '\x3', '\x2', '\x2', '\x2', '\x1C90', '\x1C91', '\a', '\x46', 
		'\x2', '\x2', '\x1C91', '\x1C93', '\a', '\x180', '\x2', '\x2', '\x1C92', 
		'\x1C94', '\x5', '\x274', '\x13B', '\x2', '\x1C93', '\x1C92', '\x3', '\x2', 
		'\x2', '\x2', '\x1C93', '\x1C94', '\x3', '\x2', '\x2', '\x2', '\x1C94', 
		'\x631', '\x3', '\x2', '\x2', '\x2', '\x1C95', '\x1C96', '\a', '\x133', 
		'\x2', '\x2', '\x1C96', '\x1C97', '\a', '\x180', '\x2', '\x2', '\x1C97', 
		'\x1C9F', '\x5', '\\', '/', '\x2', '\x1C98', '\x1CA0', '\x5', '\x634', 
		'\x31B', '\x2', '\x1C99', '\x1CA0', '\x5', '\x626', '\x314', '\x2', '\x1C9A', 
		'\x1CA0', '\a', '\x46', '\x2', '\x2', '\x1C9B', '\x1C9C', '\a', '\x220', 
		'\x2', '\x2', '\x1C9C', '\x1C9D', '\a', ')', '\x2', '\x2', '\x1C9D', '\x1CA0', 
		'\a', '\x1A9', '\x2', '\x2', '\x1C9E', '\x1CA0', '\a', '\x21E', '\x2', 
		'\x2', '\x1C9F', '\x1C98', '\x3', '\x2', '\x2', '\x2', '\x1C9F', '\x1C99', 
		'\x3', '\x2', '\x2', '\x2', '\x1C9F', '\x1C9A', '\x3', '\x2', '\x2', '\x2', 
		'\x1C9F', '\x1C9B', '\x3', '\x2', '\x2', '\x2', '\x1C9F', '\x1C9E', '\x3', 
		'\x2', '\x2', '\x2', '\x1CA0', '\x633', '\x3', '\x2', '\x2', '\x2', '\x1CA1', 
		'\x1CA7', '\x5', '\x612', '\x30A', '\x2', '\x1CA2', '\x1CA7', '\x5', '\x616', 
		'\x30C', '\x2', '\x1CA3', '\x1CA7', '\x5', '\x61E', '\x310', '\x2', '\x1CA4', 
		'\x1CA7', '\x5', '\x37E', '\x1C0', '\x2', '\x1CA5', '\x1CA7', '\x5', '\x624', 
		'\x313', '\x2', '\x1CA6', '\x1CA1', '\x3', '\x2', '\x2', '\x2', '\x1CA6', 
		'\x1CA2', '\x3', '\x2', '\x2', '\x2', '\x1CA6', '\x1CA3', '\x3', '\x2', 
		'\x2', '\x2', '\x1CA6', '\x1CA4', '\x3', '\x2', '\x2', '\x2', '\x1CA6', 
		'\x1CA5', '\x3', '\x2', '\x2', '\x2', '\x1CA7', '\x1CAA', '\x3', '\x2', 
		'\x2', '\x2', '\x1CA8', '\x1CA6', '\x3', '\x2', '\x2', '\x2', '\x1CA8', 
		'\x1CA9', '\x3', '\x2', '\x2', '\x2', '\x1CA9', '\x635', '\x3', '\x2', 
		'\x2', '\x2', '\x1CAA', '\x1CA8', '\x3', '\x2', '\x2', '\x2', '\x1CAB', 
		'\x1CAC', '\a', '\x1B0', '\x2', '\x2', '\x1CAC', '\x1CAD', '\t', 'O', 
		'\x2', '\x2', '\x1CAD', '\x1CAE', '\x5', '\\', '/', '\x2', '\x1CAE', '\x1CAF', 
		'\a', '\x20B', '\x2', '\x2', '\x1CAF', '\x1CB0', '\x5', '\\', '/', '\x2', 
		'\x1CB0', '\x637', '\x3', '\x2', '\x2', '\x2', '\x1CB1', '\x1CB2', '\a', 
		'\x8F', '\x2', '\x2', '\x1CB2', '\x1CB3', '\a', '\x180', '\x2', '\x2', 
		'\x1CB3', '\x1CB4', '\x5', '\\', '/', '\x2', '\x1CB4', '\x639', '\x3', 
		'\x2', '\x2', '\x2', '\x1CB5', '\x1CB6', '\a', '\x1E7', '\x2', '\x2', 
		'\x1CB6', '\x1CB7', '\a', '\x180', '\x2', '\x2', '\x1CB7', '\x1CB8', '\x5', 
		'\\', '/', '\x2', '\x1CB8', '\x1CBA', '\x5', '\x63C', '\x31F', '\x2', 
		'\x1CB9', '\x1CBB', '\x5', '\x63E', '\x320', '\x2', '\x1CBA', '\x1CB9', 
		'\x3', '\x2', '\x2', '\x2', '\x1CBA', '\x1CBB', '\x3', '\x2', '\x2', '\x2', 
		'\x1CBB', '\x1CBD', '\x3', '\x2', '\x2', '\x2', '\x1CBC', '\x1CBE', '\x5', 
		'\x274', '\x13B', '\x2', '\x1CBD', '\x1CBC', '\x3', '\x2', '\x2', '\x2', 
		'\x1CBD', '\x1CBE', '\x3', '\x2', '\x2', '\x2', '\x1CBE', '\x63B', '\x3', 
		'\x2', '\x2', '\x2', '\x1CBF', '\x1CC0', '\a', '\x18', '\x2', '\x2', '\x1CC0', 
		'\x1CC1', '\x5', '\x352', '\x1AA', '\x2', '\x1CC1', '\x63D', '\x3', '\x2', 
		'\x2', '\x2', '\x1CC2', '\x1CC3', '\a', '\xF3', '\x2', '\x2', '\x1CC3', 
		'\x1CC4', '\a', '\x24D', '\x2', '\x2', '\x1CC4', '\x1CC5', '\x5', '\x640', 
		'\x321', '\x2', '\x1CC5', '\x1CC6', '\a', '\x24F', '\x2', '\x2', '\x1CC6', 
		'\x1CC7', '\x5', '\x640', '\x321', '\x2', '\x1CC7', '\x1CC8', '\a', '\x24E', 
		'\x2', '\x2', '\x1CC8', '\x63F', '\x3', '\x2', '\x2', '\x2', '\x1CC9', 
		'\x1CD2', '\a', '\x180', '\x2', '\x2', '\x1CCA', '\x1CCF', '\x5', '\\', 
		'/', '\x2', '\x1CCB', '\x1CCE', '\x5', '\x2E0', '\x171', '\x2', '\x1CCC', 
		'\x1CCE', '\x5', '\x624', '\x313', '\x2', '\x1CCD', '\x1CCB', '\x3', '\x2', 
		'\x2', '\x2', '\x1CCD', '\x1CCC', '\x3', '\x2', '\x2', '\x2', '\x1CCE', 
		'\x1CD1', '\x3', '\x2', '\x2', '\x2', '\x1CCF', '\x1CCD', '\x3', '\x2', 
		'\x2', '\x2', '\x1CCF', '\x1CD0', '\x3', '\x2', '\x2', '\x2', '\x1CD0', 
		'\x1CD3', '\x3', '\x2', '\x2', '\x2', '\x1CD1', '\x1CCF', '\x3', '\x2', 
		'\x2', '\x2', '\x1CD2', '\x1CCA', '\x3', '\x2', '\x2', '\x2', '\x1CD2', 
		'\x1CD3', '\x3', '\x2', '\x2', '\x2', '\x1CD3', '\x641', '\x3', '\x2', 
		'\x2', '\x2', '\x1CD4', '\x1CD5', '\a', '\x133', '\x2', '\x2', '\x1CD5', 
		'\x1CD6', '\a', '\x1F4', '\x2', '\x2', '\x1CD6', '\x1CDA', '\x5', '\\', 
		'/', '\x2', '\x1CD7', '\x1CDB', '\a', '\x21E', '\x2', '\x2', '\x1CD8', 
		'\x1CDB', '\x5', '\x616', '\x30C', '\x2', '\x1CD9', '\x1CDB', '\x5', '\x612', 
		'\x30A', '\x2', '\x1CDA', '\x1CD7', '\x3', '\x2', '\x2', '\x2', '\x1CDA', 
		'\x1CD8', '\x3', '\x2', '\x2', '\x2', '\x1CDA', '\x1CD9', '\x3', '\x2', 
		'\x2', '\x2', '\x1CDB', '\x643', '\x3', '\x2', '\x2', '\x2', '\x1CDC', 
		'\x1CDE', '\a', 'Q', '\x2', '\x2', '\x1CDD', '\x1CDF', '\a', 't', '\x2', 
		'\x2', '\x1CDE', '\x1CDD', '\x3', '\x2', '\x2', '\x2', '\x1CDE', '\x1CDF', 
		'\x3', '\x2', '\x2', '\x2', '\x1CDF', '\x1CE1', '\x3', '\x2', '\x2', '\x2', 
		'\x1CE0', '\x1CE2', '\t', '`', '\x2', '\x2', '\x1CE1', '\x1CE0', '\x3', 
		'\x2', '\x2', '\x2', '\x1CE1', '\x1CE2', '\x3', '\x2', '\x2', '\x2', '\x1CE2', 
		'\x1CE4', '\x3', '\x2', '\x2', '\x2', '\x1CE3', '\x1CE5', '\x5', '\x646', 
		'\x324', '\x2', '\x1CE4', '\x1CE3', '\x3', '\x2', '\x2', '\x2', '\x1CE4', 
		'\x1CE5', '\x3', '\x2', '\x2', '\x2', '\x1CE5', '\x1CE8', '\x3', '\x2', 
		'\x2', '\x2', '\x1CE6', '\x1CE7', '\a', '\x1B8', '\x2', '\x2', '\x1CE7', 
		'\x1CE9', '\a', '\x1DC', '\x2', '\x2', '\x1CE8', '\x1CE6', '\x3', '\x2', 
		'\x2', '\x2', '\x1CE8', '\x1CE9', '\x3', '\x2', '\x2', '\x2', '\x1CE9', 
		'\x645', '\x3', '\x2', '\x2', '\x2', '\x1CEA', '\x1CEB', '\x5', '\\', 
		'/', '\x2', '\x1CEB', '\x1CEC', '\a', '\x255', '\x2', '\x2', '\x1CEC', 
		'\x1CED', '\x5', '\xA0', 'Q', '\x2', '\x1CED', '\x647', '\x3', '\x2', 
		'\x2', '\x2', '\x1CEE', '\x1CEF', '\a', '\x1B1', '\x2', '\x2', '\x1CEF', 
		'\x1CF0', '\x5', '\x68A', '\x346', '\x2', '\x1CF0', '\x649', '\x3', '\x2', 
		'\x2', '\x2', '\x1CF1', '\x1CF6', '\x5', '\x64C', '\x327', '\x2', '\x1CF2', 
		'\x1CF3', '\a', '\x24F', '\x2', '\x2', '\x1CF3', '\x1CF5', '\x5', '\x64C', 
		'\x327', '\x2', '\x1CF4', '\x1CF2', '\x3', '\x2', '\x2', '\x2', '\x1CF5', 
		'\x1CF8', '\x3', '\x2', '\x2', '\x2', '\x1CF6', '\x1CF4', '\x3', '\x2', 
		'\x2', '\x2', '\x1CF6', '\x1CF7', '\x3', '\x2', '\x2', '\x2', '\x1CF7', 
		'\x64B', '\x3', '\x2', '\x2', '\x2', '\x1CF8', '\x1CF6', '\x3', '\x2', 
		'\x2', '\x2', '\x1CF9', '\x1CFC', '\t', '\x61', '\x2', '\x2', '\x1CFA', 
		'\x1CFD', '\x5', '\x6AA', '\x356', '\x2', '\x1CFB', '\x1CFD', '\x5', '\x6A2', 
		'\x352', '\x2', '\x1CFC', '\x1CFA', '\x3', '\x2', '\x2', '\x2', '\x1CFC', 
		'\x1CFB', '\x3', '\x2', '\x2', '\x2', '\x1CFD', '\x64D', '\x3', '\x2', 
		'\x2', '\x2', '\x1CFE', '\x1D01', '\x5', '\x650', '\x329', '\x2', '\x1CFF', 
		'\x1D01', '\x5', '\x656', '\x32C', '\x2', '\x1D00', '\x1CFE', '\x3', '\x2', 
		'\x2', '\x2', '\x1D00', '\x1CFF', '\x3', '\x2', '\x2', '\x2', '\x1D01', 
		'\x64F', '\x3', '\x2', '\x2', '\x2', '\x1D02', '\x1D03', '\t', '\x62', 
		'\x2', '\x2', '\x1D03', '\x1D06', '\a', '\x19', '\x2', '\x2', '\x1D04', 
		'\x1D07', '\x5', '\x652', '\x32A', '\x2', '\x1D05', '\x1D07', '\x5', '\x654', 
		'\x32B', '\x2', '\x1D06', '\x1D04', '\x3', '\x2', '\x2', '\x2', '\x1D06', 
		'\x1D05', '\x3', '\x2', '\x2', '\x2', '\x1D07', '\x651', '\x3', '\x2', 
		'\x2', '\x2', '\x1D08', '\x1D0A', '\x5', 'N', '(', '\x2', '\x1D09', '\x1D0B', 
		'\x5', '`', '\x31', '\x2', '\x1D0A', '\x1D09', '\x3', '\x2', '\x2', '\x2', 
		'\x1D0A', '\x1D0B', '\x3', '\x2', '\x2', '\x2', '\x1D0B', '\x653', '\x3', 
		'\x2', '\x2', '\x2', '\x1D0C', '\x1D0D', '\a', '\x24D', '\x2', '\x2', 
		'\x1D0D', '\x1D12', '\x5', '\x694', '\x34B', '\x2', '\x1D0E', '\x1D0F', 
		'\a', '\x24F', '\x2', '\x2', '\x1D0F', '\x1D11', '\x5', '\x694', '\x34B', 
		'\x2', '\x1D10', '\x1D0E', '\x3', '\x2', '\x2', '\x2', '\x1D11', '\x1D14', 
		'\x3', '\x2', '\x2', '\x2', '\x1D12', '\x1D10', '\x3', '\x2', '\x2', '\x2', 
		'\x1D12', '\x1D13', '\x3', '\x2', '\x2', '\x2', '\x1D13', '\x1D15', '\x3', 
		'\x2', '\x2', '\x2', '\x1D14', '\x1D12', '\x3', '\x2', '\x2', '\x2', '\x1D15', 
		'\x1D16', '\a', '\x24E', '\x2', '\x2', '\x1D16', '\x655', '\x3', '\x2', 
		'\x2', '\x2', '\x1D17', '\x1D18', '\a', '\x8F', '\x2', '\x2', '\x1D18', 
		'\x1D19', '\a', '\x19', '\x2', '\x2', '\x1D19', '\x1D1A', '\x5', '\\', 
		'/', '\x2', '\x1D1A', '\x1D1B', '\x5', '\x368', '\x1B5', '\x2', '\x1D1B', 
		'\x657', '\x3', '\x2', '\x2', '\x2', '\x1D1C', '\x1D22', '\a', '\x133', 
		'\x2', '\x2', '\x1D1D', '\x1D1E', '\a', '\x10D', '\x2', '\x2', '\x1D1E', 
		'\x1D23', '\x5', '&', '\x14', '\x2', '\x1D1F', '\x1D20', '\a', '\x96', 
		'\x2', '\x2', '\x1D20', '\x1D21', '\a', '\x215', '\x2', '\x2', '\x1D21', 
		'\x1D23', '\x5', '`', '\x31', '\x2', '\x1D22', '\x1D1D', '\x3', '\x2', 
		'\x2', '\x2', '\x1D22', '\x1D1F', '\x3', '\x2', '\x2', '\x2', '\x1D23', 
		'\x659', '\x3', '\x2', '\x2', '\x2', '\x1D24', '\x1D27', '\x5', '\x65C', 
		'\x32F', '\x2', '\x1D25', '\x1D27', '\x5', '\x65E', '\x330', '\x2', '\x1D26', 
		'\x1D24', '\x3', '\x2', '\x2', '\x2', '\x1D26', '\x1D25', '\x3', '\x2', 
		'\x2', '\x2', '\x1D27', '\x65B', '\x3', '\x2', '\x2', '\x2', '\x1D28', 
		'\x1D29', '\a', '\xF4', '\x2', '\x2', '\x1D29', '\x65D', '\x3', '\x2', 
		'\x2', '\x2', '\x1D2A', '\x1D2C', '\a', '\x38', '\x2', '\x2', '\x1D2B', 
		'\x1D2D', '\x5', '\x660', '\x331', '\x2', '\x1D2C', '\x1D2B', '\x3', '\x2', 
		'\x2', '\x2', '\x1D2C', '\x1D2D', '\x3', '\x2', '\x2', '\x2', '\x1D2D', 
		'\x1D2F', '\x3', '\x2', '\x2', '\x2', '\x1D2E', '\x1D30', '\x5', '\x666', 
		'\x334', '\x2', '\x1D2F', '\x1D2E', '\x3', '\x2', '\x2', '\x2', '\x1D2F', 
		'\x1D30', '\x3', '\x2', '\x2', '\x2', '\x1D30', '\x65F', '\x3', '\x2', 
		'\x2', '\x2', '\x1D31', '\x1D34', '\x5', '\x662', '\x332', '\x2', '\x1D32', 
		'\x1D34', '\x5', '\x664', '\x333', '\x2', '\x1D33', '\x1D31', '\x3', '\x2', 
		'\x2', '\x2', '\x1D33', '\x1D32', '\x3', '\x2', '\x2', '\x2', '\x1D34', 
		'\x661', '\x3', '\x2', '\x2', '\x2', '\x1D35', '\x1D37', '\a', '\x15C', 
		'\x2', '\x2', '\x1D36', '\x1D35', '\x3', '\x2', '\x2', '\x2', '\x1D36', 
		'\x1D37', '\x3', '\x2', '\x2', '\x2', '\x1D37', '\x1D38', '\x3', '\x2', 
		'\x2', '\x2', '\x1D38', '\x1D39', '\a', '\xE0', '\x2', '\x2', '\x1D39', 
		'\x1D3A', '\a', '\x1FD', '\x2', '\x2', '\x1D3A', '\x1D3B', '\a', 'l', 
		'\x2', '\x2', '\x1D3B', '\x663', '\x3', '\x2', '\x2', '\x2', '\x1D3C', 
		'\x1D3D', '\a', '\x62', '\x2', '\x2', '\x1D3D', '\x1D3E', '\a', '\x20B', 
		'\x2', '\x2', '\x1D3E', '\x1D3F', '\a', '\x1F6', '\x2', '\x2', '\x1D3F', 
		'\x665', '\x3', '\x2', '\x2', '\x2', '\x1D40', '\x1D42', '\a', '\xC0', 
		'\x2', '\x2', '\x1D41', '\x1D40', '\x3', '\x2', '\x2', '\x2', '\x1D41', 
		'\x1D42', '\x3', '\x2', '\x2', '\x2', '\x1D42', '\x1D43', '\x3', '\x2', 
		'\x2', '\x2', '\x1D43', '\x1D44', '\x5', '\x3A4', '\x1D3', '\x2', '\x1D44', 
		'\x667', '\x3', '\x2', '\x2', '\x2', '\x1D45', '\x1D46', '\a', '\x1D4', 
		'\x2', '\x2', '\x1D46', '\x1D48', '\x5', '\x44', '#', '\x2', '\x1D47', 
		'\x1D49', '\x5', '\x66A', '\x336', '\x2', '\x1D48', '\x1D47', '\x3', '\x2', 
		'\x2', '\x2', '\x1D49', '\x1D4A', '\x3', '\x2', '\x2', '\x2', '\x1D4A', 
		'\x1D48', '\x3', '\x2', '\x2', '\x2', '\x1D4A', '\x1D4B', '\x3', '\x2', 
		'\x2', '\x2', '\x1D4B', '\x669', '\x3', '\x2', '\x2', '\x2', '\x1D4C', 
		'\x1D58', '\x5', '\x66E', '\x338', '\x2', '\x1D4D', '\x1D58', '\x5', '\x670', 
		'\x339', '\x2', '\x1D4E', '\x1D58', '\x5', '\x672', '\x33A', '\x2', '\x1D4F', 
		'\x1D58', '\x5', '\x674', '\x33B', '\x2', '\x1D50', '\x1D58', '\x5', '\x676', 
		'\x33C', '\x2', '\x1D51', '\x1D58', '\x5', '\x678', '\x33D', '\x2', '\x1D52', 
		'\x1D58', '\x5', '\x67A', '\x33E', '\x2', '\x1D53', '\x1D58', '\x5', '\x67C', 
		'\x33F', '\x2', '\x1D54', '\x1D58', '\x5', '\x67E', '\x340', '\x2', '\x1D55', 
		'\x1D58', '\x5', '\x680', '\x341', '\x2', '\x1D56', '\x1D58', '\x5', '\x682', 
		'\x342', '\x2', '\x1D57', '\x1D4C', '\x3', '\x2', '\x2', '\x2', '\x1D57', 
		'\x1D4D', '\x3', '\x2', '\x2', '\x2', '\x1D57', '\x1D4E', '\x3', '\x2', 
		'\x2', '\x2', '\x1D57', '\x1D4F', '\x3', '\x2', '\x2', '\x2', '\x1D57', 
		'\x1D50', '\x3', '\x2', '\x2', '\x2', '\x1D57', '\x1D51', '\x3', '\x2', 
		'\x2', '\x2', '\x1D57', '\x1D52', '\x3', '\x2', '\x2', '\x2', '\x1D57', 
		'\x1D53', '\x3', '\x2', '\x2', '\x2', '\x1D57', '\x1D54', '\x3', '\x2', 
		'\x2', '\x2', '\x1D57', '\x1D55', '\x3', '\x2', '\x2', '\x2', '\x1D57', 
		'\x1D56', '\x3', '\x2', '\x2', '\x2', '\x1D58', '\x66B', '\x3', '\x2', 
		'\x2', '\x2', '\x1D59', '\x1D63', '\x5', '\x66E', '\x338', '\x2', '\x1D5A', 
		'\x1D63', '\x5', '\x670', '\x339', '\x2', '\x1D5B', '\x1D63', '\x5', '\x672', 
		'\x33A', '\x2', '\x1D5C', '\x1D63', '\x5', '\x674', '\x33B', '\x2', '\x1D5D', 
		'\x1D63', '\x5', '\x676', '\x33C', '\x2', '\x1D5E', '\x1D63', '\x5', '\x678', 
		'\x33D', '\x2', '\x1D5F', '\x1D63', '\x5', '\x67A', '\x33E', '\x2', '\x1D60', 
		'\x1D63', '\x5', '\x67C', '\x33F', '\x2', '\x1D61', '\x1D63', '\x5', '\x67E', 
		'\x340', '\x2', '\x1D62', '\x1D59', '\x3', '\x2', '\x2', '\x2', '\x1D62', 
		'\x1D5A', '\x3', '\x2', '\x2', '\x2', '\x1D62', '\x1D5B', '\x3', '\x2', 
		'\x2', '\x2', '\x1D62', '\x1D5C', '\x3', '\x2', '\x2', '\x2', '\x1D62', 
		'\x1D5D', '\x3', '\x2', '\x2', '\x2', '\x1D62', '\x1D5E', '\x3', '\x2', 
		'\x2', '\x2', '\x1D62', '\x1D5F', '\x3', '\x2', '\x2', '\x2', '\x1D62', 
		'\x1D60', '\x3', '\x2', '\x2', '\x2', '\x1D62', '\x1D61', '\x3', '\x2', 
		'\x2', '\x2', '\x1D63', '\x66D', '\x3', '\x2', '\x2', '\x2', '\x1D64', 
		'\x1D65', '\a', '\xE1', '\x2', '\x2', '\x1D65', '\x1D67', '\a', '\x33', 
		'\x2', '\x2', '\x1D66', '\x1D68', '\a', '\x259', '\x2', '\x2', '\x1D67', 
		'\x1D66', '\x3', '\x2', '\x2', '\x2', '\x1D67', '\x1D68', '\x3', '\x2', 
		'\x2', '\x2', '\x1D68', '\x1D69', '\x3', '\x2', '\x2', '\x2', '\x1D69', 
		'\x1D6A', '\a', '\x247', '\x2', '\x2', '\x1D6A', '\x66F', '\x3', '\x2', 
		'\x2', '\x2', '\x1D6B', '\x1D6C', '\a', '\x1E8', '\x2', '\x2', '\x1D6C', 
		'\x1D73', '\a', '\x236', '\x2', '\x2', '\x1D6D', '\x1D6F', '\a', '\x259', 
		'\x2', '\x2', '\x1D6E', '\x1D6D', '\x3', '\x2', '\x2', '\x2', '\x1D6E', 
		'\x1D6F', '\x3', '\x2', '\x2', '\x2', '\x1D6F', '\x1D70', '\x3', '\x2', 
		'\x2', '\x2', '\x1D70', '\x1D74', '\a', '\x247', '\x2', '\x2', '\x1D71', 
		'\x1D72', '\a', '\x10D', '\x2', '\x2', '\x1D72', '\x1D74', '\a', '\x227', 
		'\x2', '\x2', '\x1D73', '\x1D6E', '\x3', '\x2', '\x2', '\x2', '\x1D73', 
		'\x1D71', '\x3', '\x2', '\x2', '\x2', '\x1D74', '\x671', '\x3', '\x2', 
		'\x2', '\x2', '\x1D75', '\x1D77', '\a', '\x126', '\x2', '\x2', '\x1D76', 
		'\x1D78', '\a', '\x259', '\x2', '\x2', '\x1D77', '\x1D76', '\x3', '\x2', 
		'\x2', '\x2', '\x1D77', '\x1D78', '\x3', '\x2', '\x2', '\x2', '\x1D78', 
		'\x1D79', '\x3', '\x2', '\x2', '\x2', '\x1D79', '\x1D7C', '\a', '\x247', 
		'\x2', '\x2', '\x1D7A', '\x1D7C', '\a', '\x14E', '\x2', '\x2', '\x1D7B', 
		'\x1D75', '\x3', '\x2', '\x2', '\x2', '\x1D7B', '\x1D7A', '\x3', '\x2', 
		'\x2', '\x2', '\x1D7C', '\x673', '\x3', '\x2', '\x2', '\x2', '\x1D7D', 
		'\x1D7F', '\a', '\x130', '\x2', '\x2', '\x1D7E', '\x1D80', '\a', '\x259', 
		'\x2', '\x2', '\x1D7F', '\x1D7E', '\x3', '\x2', '\x2', '\x2', '\x1D7F', 
		'\x1D80', '\x3', '\x2', '\x2', '\x2', '\x1D80', '\x1D81', '\x3', '\x2', 
		'\x2', '\x2', '\x1D81', '\x1D84', '\a', '\x247', '\x2', '\x2', '\x1D82', 
		'\x1D84', '\a', '\x14F', '\x2', '\x2', '\x1D83', '\x1D7D', '\x3', '\x2', 
		'\x2', '\x2', '\x1D83', '\x1D82', '\x3', '\x2', '\x2', '\x2', '\x1D84', 
		'\x675', '\x3', '\x2', '\x2', '\x2', '\x1D85', '\x1D86', '\t', '\x63', 
		'\x2', '\x2', '\x1D86', '\x677', '\x3', '\x2', '\x2', '\x2', '\x1D87', 
		'\x1D89', '\a', '\x36', '\x2', '\x2', '\x1D88', '\x1D8A', '\a', '\x259', 
		'\x2', '\x2', '\x1D89', '\x1D88', '\x3', '\x2', '\x2', '\x2', '\x1D89', 
		'\x1D8A', '\x3', '\x2', '\x2', '\x2', '\x1D8A', '\x1D8B', '\x3', '\x2', 
		'\x2', '\x2', '\x1D8B', '\x1D8E', '\a', '\x247', '\x2', '\x2', '\x1D8C', 
		'\x1D8E', '\a', '\x146', '\x2', '\x2', '\x1D8D', '\x1D87', '\x3', '\x2', 
		'\x2', '\x2', '\x1D8D', '\x1D8C', '\x3', '\x2', '\x2', '\x2', '\x1D8E', 
		'\x679', '\x3', '\x2', '\x2', '\x2', '\x1D8F', '\x1D90', '\t', '\x64', 
		'\x2', '\x2', '\x1D90', '\x67B', '\x3', '\x2', '\x2', '\x2', '\x1D91', 
		'\x1D93', '\a', '\x1C9', '\x2', '\x2', '\x1D92', '\x1D94', '\t', '\x65', 
		'\x2', '\x2', '\x1D93', '\x1D92', '\x3', '\x2', '\x2', '\x2', '\x1D93', 
		'\x1D94', '\x3', '\x2', '\x2', '\x2', '\x1D94', '\x1D97', '\x3', '\x2', 
		'\x2', '\x2', '\x1D95', '\x1D97', '\a', '\x159', '\x2', '\x2', '\x1D96', 
		'\x1D91', '\x3', '\x2', '\x2', '\x2', '\x1D96', '\x1D95', '\x3', '\x2', 
		'\x2', '\x2', '\x1D97', '\x67D', '\x3', '\x2', '\x2', '\x2', '\x1D98', 
		'\x1D99', '\t', '\x66', '\x2', '\x2', '\x1D99', '\x67F', '\x3', '\x2', 
		'\x2', '\x2', '\x1D9A', '\x1D9C', '\a', '\x1F0', '\x2', '\x2', '\x1D9B', 
		'\x1D9D', '\t', '\x65', '\x2', '\x2', '\x1D9C', '\x1D9B', '\x3', '\x2', 
		'\x2', '\x2', '\x1D9C', '\x1D9D', '\x3', '\x2', '\x2', '\x2', '\x1D9D', 
		'\x1DA0', '\x3', '\x2', '\x2', '\x2', '\x1D9E', '\x1DA0', '\a', '\x15A', 
		'\x2', '\x2', '\x1D9F', '\x1D9A', '\x3', '\x2', '\x2', '\x2', '\x1D9F', 
		'\x1D9E', '\x3', '\x2', '\x2', '\x2', '\x1DA0', '\x681', '\x3', '\x2', 
		'\x2', '\x2', '\x1DA1', '\x1DA2', '\t', 'g', '\x2', '\x2', '\x1DA2', '\x683', 
		'\x3', '\x2', '\x2', '\x2', '\x1DA3', '\x1DA4', '\a', '\x215', '\x2', 
		'\x2', '\x1DA4', '\x1DA6', '\x5', '\x44', '#', '\x2', '\x1DA5', '\x1DA7', 
		'\x5', '\x69A', '\x34E', '\x2', '\x1DA6', '\x1DA5', '\x3', '\x2', '\x2', 
		'\x2', '\x1DA6', '\x1DA7', '\x3', '\x2', '\x2', '\x2', '\x1DA7', '\x1DA9', 
		'\x3', '\x2', '\x2', '\x2', '\x1DA8', '\x1DAA', '\x5', '\x688', '\x345', 
		'\x2', '\x1DA9', '\x1DA8', '\x3', '\x2', '\x2', '\x2', '\x1DA9', '\x1DAA', 
		'\x3', '\x2', '\x2', '\x2', '\x1DAA', '\x1DAE', '\x3', '\x2', '\x2', '\x2', 
		'\x1DAB', '\x1DAD', '\x5', '\x686', '\x344', '\x2', '\x1DAC', '\x1DAB', 
		'\x3', '\x2', '\x2', '\x2', '\x1DAD', '\x1DB0', '\x3', '\x2', '\x2', '\x2', 
		'\x1DAE', '\x1DAC', '\x3', '\x2', '\x2', '\x2', '\x1DAE', '\x1DAF', '\x3', 
		'\x2', '\x2', '\x2', '\x1DAF', '\x685', '\x3', '\x2', '\x2', '\x2', '\x1DB0', 
		'\x1DAE', '\x3', '\x2', '\x2', '\x2', '\x1DB1', '\x1DB2', '\a', '\r', 
		'\x2', '\x2', '\x1DB2', '\x1DB3', '\x5', '\x604', '\x303', '\x2', '\x1DB3', 
		'\x687', '\x3', '\x2', '\x2', '\x2', '\x1DB4', '\x1DB8', '\x5', '\x68A', 
		'\x346', '\x2', '\x1DB5', '\x1DB8', '\x5', '\x696', '\x34C', '\x2', '\x1DB6', 
		'\x1DB8', '\x5', '\x698', '\x34D', '\x2', '\x1DB7', '\x1DB4', '\x3', '\x2', 
		'\x2', '\x2', '\x1DB7', '\x1DB5', '\x3', '\x2', '\x2', '\x2', '\x1DB7', 
		'\x1DB6', '\x3', '\x2', '\x2', '\x2', '\x1DB8', '\x689', '\x3', '\x2', 
		'\x2', '\x2', '\x1DB9', '\x1DBB', '\x5', '\x1F2', '\xFA', '\x2', '\x1DBA', 
		'\x1DB9', '\x3', '\x2', '\x2', '\x2', '\x1DBA', '\x1DBB', '\x3', '\x2', 
		'\x2', '\x2', '\x1DBB', '\x1DBE', '\x3', '\x2', '\x2', '\x2', '\x1DBC', 
		'\x1DBF', '\x5', '\x68C', '\x347', '\x2', '\x1DBD', '\x1DBF', '\x5', '\x68E', 
		'\x348', '\x2', '\x1DBE', '\x1DBC', '\x3', '\x2', '\x2', '\x2', '\x1DBE', 
		'\x1DBD', '\x3', '\x2', '\x2', '\x2', '\x1DBF', '\x1DC1', '\x3', '\x2', 
		'\x2', '\x2', '\x1DC0', '\x1DC2', '\x5', '\x690', '\x349', '\x2', '\x1DC1', 
		'\x1DC0', '\x3', '\x2', '\x2', '\x2', '\x1DC1', '\x1DC2', '\x3', '\x2', 
		'\x2', '\x2', '\x1DC2', '\x1DC6', '\x3', '\x2', '\x2', '\x2', '\x1DC3', 
		'\x1DC5', '\x5', '\x6AC', '\x357', '\x2', '\x1DC4', '\x1DC3', '\x3', '\x2', 
		'\x2', '\x2', '\x1DC5', '\x1DC8', '\x3', '\x2', '\x2', '\x2', '\x1DC6', 
		'\x1DC4', '\x3', '\x2', '\x2', '\x2', '\x1DC6', '\x1DC7', '\x3', '\x2', 
		'\x2', '\x2', '\x1DC7', '\x68B', '\x3', '\x2', '\x2', '\x2', '\x1DC8', 
		'\x1DC6', '\x3', '\x2', '\x2', '\x2', '\x1DC9', '\x1DCA', '\x5', '\x1F0', 
		'\xF9', '\x2', '\x1DCA', '\x1DCB', '\a', '\x163', '\x2', '\x2', '\x1DCB', 
		'\x68D', '\x3', '\x2', '\x2', '\x2', '\x1DCC', '\x1DCD', '\x5', '\x34E', 
		'\x1A8', '\x2', '\x1DCD', '\x68F', '\x3', '\x2', '\x2', '\x2', '\x1DCE', 
		'\x1DCF', '\a', '\x24D', '\x2', '\x2', '\x1DCF', '\x1DD4', '\x5', '\x692', 
		'\x34A', '\x2', '\x1DD0', '\x1DD1', '\a', '\x24F', '\x2', '\x2', '\x1DD1', 
		'\x1DD3', '\x5', '\x692', '\x34A', '\x2', '\x1DD2', '\x1DD0', '\x3', '\x2', 
		'\x2', '\x2', '\x1DD3', '\x1DD6', '\x3', '\x2', '\x2', '\x2', '\x1DD4', 
		'\x1DD2', '\x3', '\x2', '\x2', '\x2', '\x1DD4', '\x1DD5', '\x3', '\x2', 
		'\x2', '\x2', '\x1DD5', '\x1DD7', '\x3', '\x2', '\x2', '\x2', '\x1DD6', 
		'\x1DD4', '\x3', '\x2', '\x2', '\x2', '\x1DD7', '\x1DD8', '\a', '\x24E', 
		'\x2', '\x2', '\x1DD8', '\x691', '\x3', '\x2', '\x2', '\x2', '\x1DD9', 
		'\x1DDC', '\x5', '\x6A0', '\x351', '\x2', '\x1DDA', '\x1DDC', '\x5', '\x694', 
		'\x34B', '\x2', '\x1DDB', '\x1DD9', '\x3', '\x2', '\x2', '\x2', '\x1DDB', 
		'\x1DDA', '\x3', '\x2', '\x2', '\x2', '\x1DDC', '\x693', '\x3', '\x2', 
		'\x2', '\x2', '\x1DDD', '\x1DDE', '\x5', 'N', '(', '\x2', '\x1DDE', '\x1DDF', 
		'\x5', '`', '\x31', '\x2', '\x1DDF', '\x695', '\x3', '\x2', '\x2', '\x2', 
		'\x1DE0', '\x1DE1', '\x5', '\x1F0', '\xF9', '\x2', '\x1DE1', '\x1DE2', 
		'\x5', '\x5CA', '\x2E6', '\x2', '\x1DE2', '\x697', '\x3', '\x2', '\x2', 
		'\x2', '\x1DE3', '\x1DE4', '\x5', '\x1F0', '\xF9', '\x2', '\x1DE4', '\x1DE5', 
		'\x5', '\x5D0', '\x2E9', '\x2', '\x1DE5', '\x699', '\x3', '\x2', '\x2', 
		'\x2', '\x1DE6', '\x1DE7', '\a', '\x165', '\x2', '\x2', '\x1DE7', '\x1DE8', 
		'\x5', '*', '\x16', '\x2', '\x1DE8', '\x69B', '\x3', '\x2', '\x2', '\x2', 
		'\x1DE9', '\x1DEA', '\a', '\x215', '\x2', '\x2', '\x1DEA', '\x1DEB', '\a', 
		'*', '\x2', '\x2', '\x1DEB', '\x1DEC', '\x5', '\x44', '#', '\x2', '\x1DEC', 
		'\x1DED', '\x5', '\x1F0', '\xF9', '\x2', '\x1DED', '\x1DEE', '\x5', '\x69E', 
		'\x350', '\x2', '\x1DEE', '\x1DEF', '\a', '\x9C', '\x2', '\x2', '\x1DEF', 
		'\x69D', '\x3', '\x2', '\x2', '\x2', '\x1DF0', '\x1DF1', '\x5', '\x6A0', 
		'\x351', '\x2', '\x1DF1', '\x1DF7', '\a', '\x250', '\x2', '\x2', '\x1DF2', 
		'\x1DF3', '\x5', '\x6A0', '\x351', '\x2', '\x1DF3', '\x1DF4', '\a', '\x250', 
		'\x2', '\x2', '\x1DF4', '\x1DF6', '\x3', '\x2', '\x2', '\x2', '\x1DF5', 
		'\x1DF2', '\x3', '\x2', '\x2', '\x2', '\x1DF6', '\x1DF9', '\x3', '\x2', 
		'\x2', '\x2', '\x1DF7', '\x1DF5', '\x3', '\x2', '\x2', '\x2', '\x1DF7', 
		'\x1DF8', '\x3', '\x2', '\x2', '\x2', '\x1DF8', '\x69F', '\x3', '\x2', 
		'\x2', '\x2', '\x1DF9', '\x1DF7', '\x3', '\x2', '\x2', '\x2', '\x1DFA', 
		'\x1DFC', '\x5', '\x6AC', '\x357', '\x2', '\x1DFB', '\x1DFA', '\x3', '\x2', 
		'\x2', '\x2', '\x1DFB', '\x1DFC', '\x3', '\x2', '\x2', '\x2', '\x1DFC', 
		'\x1E00', '\x3', '\x2', '\x2', '\x2', '\x1DFD', '\x1E01', '\x5', '\x6A2', 
		'\x352', '\x2', '\x1DFE', '\x1E01', '\x5', '\x6A4', '\x353', '\x2', '\x1DFF', 
		'\x1E01', '\x5', '\x6AA', '\x356', '\x2', '\x1E00', '\x1DFD', '\x3', '\x2', 
		'\x2', '\x2', '\x1E00', '\x1DFE', '\x3', '\x2', '\x2', '\x2', '\x1E00', 
		'\x1DFF', '\x3', '\x2', '\x2', '\x2', '\x1E01', '\x6A1', '\x3', '\x2', 
		'\x2', '\x2', '\x1E02', '\x1E05', '\t', 'h', '\x2', '\x2', '\x1E03', '\x1E06', 
		'\x5', '\x1E6', '\xF4', '\x2', '\x1E04', '\x1E06', '\x5', '\x20E', '\x108', 
		'\x2', '\x1E05', '\x1E03', '\x3', '\x2', '\x2', '\x2', '\x1E05', '\x1E04', 
		'\x3', '\x2', '\x2', '\x2', '\x1E06', '\x6A3', '\x3', '\x2', '\x2', '\x2', 
		'\x1E07', '\x1E08', '\x5', '\x6A6', '\x354', '\x2', '\x1E08', '\x1E0B', 
		'\x5', '\x6A8', '\x355', '\x2', '\x1E09', '\x1E0C', '\x5', '\x1EE', '\xF8', 
		'\x2', '\x1E0A', '\x1E0C', '\x5', '\x1F4', '\xFB', '\x2', '\x1E0B', '\x1E09', 
		'\x3', '\x2', '\x2', '\x2', '\x1E0B', '\x1E0A', '\x3', '\x2', '\x2', '\x2', 
		'\x1E0B', '\x1E0C', '\x3', '\x2', '\x2', '\x2', '\x1E0C', '\x6A5', '\x3', 
		'\x2', '\x2', '\x2', '\x1E0D', '\x1E0E', '\a', ']', '\x2', '\x2', '\x1E0E', 
		'\x1E0F', '\a', '\xCA', '\x2', '\x2', '\x1E0F', '\x1E11', '\x5', '\x44', 
		'#', '\x2', '\x1E10', '\x1E12', '\x5', '\x204', '\x103', '\x2', '\x1E11', 
		'\x1E10', '\x3', '\x2', '\x2', '\x2', '\x1E11', '\x1E12', '\x3', '\x2', 
		'\x2', '\x2', '\x1E12', '\x6A7', '\x3', '\x2', '\x2', '\x2', '\x1E13', 
		'\x1E14', '\a', '\x1B6', '\x2', '\x2', '\x1E14', '\x1E15', '\a', '\x1D3', 
		'\x2', '\x2', '\x1E15', '\x1E16', '\a', '\x15', '\x2', '\x2', '\x1E16', 
		'\x1E17', '\a', '\x1B3', '\x2', '\x2', '\x1E17', '\x6A9', '\x3', '\x2', 
		'\x2', '\x2', '\x1E18', '\x1E19', '\t', 'i', '\x2', '\x2', '\x1E19', '\x1E1A', 
		'\a', '\x128', '\x2', '\x2', '\x1E1A', '\x1E1B', '\x5', '\x20E', '\x108', 
		'\x2', '\x1E1B', '\x6AB', '\x3', '\x2', '\x2', '\x2', '\x1E1C', '\x1E1E', 
		'\a', '\x15C', '\x2', '\x2', '\x1E1D', '\x1E1C', '\x3', '\x2', '\x2', 
		'\x2', '\x1E1D', '\x1E1E', '\x3', '\x2', '\x2', '\x2', '\x1E1E', '\x1E1F', 
		'\x3', '\x2', '\x2', '\x2', '\x1E1F', '\x1E20', '\t', 'j', '\x2', '\x2', 
		'\x1E20', '\x6AD', '\x3', '\x2', '\x2', '\x2', '\x1E21', '\x1E23', '\a', 
		'\x19A', '\x2', '\x2', '\x1E22', '\x1E21', '\x3', '\x2', '\x2', '\x2', 
		'\x1E22', '\x1E23', '\x3', '\x2', '\x2', '\x2', '\x1E23', '\x1E24', '\x3', 
		'\x2', '\x2', '\x2', '\x1E24', '\x1E25', '\a', '\x1FA', '\x2', '\x2', 
		'\x1E25', '\x1E27', '\x5', '\x44', '#', '\x2', '\x1E26', '\x1E28', '\x5', 
		'\x6B0', '\x359', '\x2', '\x1E27', '\x1E26', '\x3', '\x2', '\x2', '\x2', 
		'\x1E27', '\x1E28', '\x3', '\x2', '\x2', '\x2', '\x1E28', '\x1E29', '\x3', 
		'\x2', '\x2', '\x2', '\x1E29', '\x1E2A', '\a', '\xBE', '\x2', '\x2', '\x1E2A', 
		'\x1E2B', '\x5', '\x46', '$', '\x2', '\x1E2B', '\x6AF', '\x3', '\x2', 
		'\x2', '\x2', '\x1E2C', '\x1E2D', '\a', '\x1F2', '\x2', '\x2', '\x1E2D', 
		'\x1E2E', '\a', '\x255', '\x2', '\x2', '\x1E2E', '\x1E2F', '\t', 'k', 
		'\x2', '\x2', '\x1E2F', '\x6B1', '\x3', '\x2', '\x2', '\x2', '\x388', 
		'\x6BA', '\x6C3', '\x6CF', '\x6D2', '\x6D6', '\x6DB', '\x6DD', '\x6E6', 
		'\x6F3', '\x6F9', '\x6FB', '\x701', '\x715', '\x717', '\x71D', '\x721', 
		'\x73D', '\x743', '\x746', '\x74C', '\x751', '\x75D', '\x774', '\x778', 
		'\x77E', '\x786', '\x78E', '\x791', '\x793', '\x799', '\x7A1', '\x7AA', 
		'\x7AE', '\x7B6', '\x7BD', '\x7C2', '\x7C6', '\x7CB', '\x7CE', '\x7D1', 
		'\x7E0', '\x7E5', '\x7E9', '\x7EC', '\x7F2', '\x7F6', '\x7F9', '\x80B', 
		'\x80E', '\x812', '\x816', '\x81A', '\x81E', '\x822', '\x826', '\x82A', 
		'\x82E', '\x832', '\x83A', '\x83E', '\x841', '\x844', '\x849', '\x84C', 
		'\x84F', '\x853', '\x856', '\x859', '\x85D', '\x860', '\x864', '\x867', 
		'\x86B', '\x86E', '\x872', '\x875', '\x87A', '\x880', '\x884', '\x889', 
		'\x897', '\x89F', '\x8A4', '\x8AA', '\x8C3', '\x8CB', '\x8CF', '\x8D3', 
		'\x8DC', '\x8E8', '\x8EC', '\x8EF', '\x8F4', '\x8FD', '\x902', '\x907', 
		'\x90A', '\x913', '\x915', '\x92B', '\x92F', '\x935', '\x93C', '\x943', 
		'\x94B', '\x954', '\x97E', '\x981', '\x98B', '\x997', '\x99D', '\x9A4', 
		'\x9B0', '\x9B9', '\x9C6', '\x9CC', '\x9D1', '\x9DA', '\x9DF', '\x9EB', 
		'\x9F9', '\x9FD', '\x9FF', '\xA0A', '\xA1A', '\xA26', '\xA2F', '\xA3B', 
		'\xA46', '\xA4D', '\xA5B', '\xA63', '\xA66', '\xA73', '\xA76', '\xA89', 
		'\xA90', '\xA93', '\xA9E', '\xAB0', '\xABC', '\xAC7', '\xACB', '\xACF', 
		'\xAD1', '\xADE', '\xAE1', '\xAE9', '\xAEC', '\xAF3', '\xAFB', '\xB02', 
		'\xB1E', '\xB32', '\xB36', '\xB3D', '\xB45', '\xB4C', '\xB54', '\xB59', 
		'\xB5D', '\xB60', '\xB66', '\xB6E', '\xB77', '\xB7F', '\xB88', '\xB91', 
		'\xB9D', '\xBA4', '\xBAA', '\xBAF', '\xBB4', '\xBC2', '\xBCD', '\xBD6', 
		'\xBEC', '\xBF4', '\xBF7', '\xBFB', '\xC02', '\xC07', '\xC0F', '\xC14', 
		'\xC18', '\xC24', '\xC29', '\xC2E', '\xC33', '\xC37', '\xC3C', '\xC3E', 
		'\xC41', '\xC4A', '\xC52', '\xC59', '\xC5D', '\xC5F', '\xC63', '\xC6C', 
		'\xC71', '\xC75', '\xC78', '\xC7B', '\xC80', '\xC88', '\xC97', '\xC9C', 
		'\xCA0', '\xCA3', '\xCA6', '\xCB6', '\xCC1', '\xCC4', '\xCC7', '\xCD4', 
		'\xCE1', '\xCE6', '\xCEE', '\xCF8', '\xD02', '\xD06', '\xD0C', '\xD15', 
		'\xD1C', '\xD1E', '\xD21', '\xD25', '\xD29', '\xD2D', '\xD32', '\xD36', 
		'\xD42', '\xD4A', '\xD4E', '\xD51', '\xD54', '\xD6E', '\xD71', '\xD77', 
		'\xD7A', '\xD7E', '\xD86', '\xD8D', '\xD97', '\xD99', '\xD9E', '\xDA3', 
		'\xDA6', '\xDAF', '\xDBE', '\xDC0', '\xDCF', '\xDD8', '\xDE4', '\xDE8', 
		'\xDEE', '\xDF1', '\xDF4', '\xDFC', '\xE07', '\xE09', '\xE0D', '\xE10', 
		'\xE13', '\xE16', '\xE19', '\xE22', '\xE29', '\xE30', '\xE32', '\xE3D', 
		'\xE42', '\xE45', '\xE48', '\xE4B', '\xE4E', '\xE55', '\xE58', '\xE5B', 
		'\xE5E', '\xE61', '\xE64', '\xE67', '\xE6C', '\xE70', '\xE73', '\xE79', 
		'\xE7C', '\xE7E', '\xE82', '\xE86', '\xE8B', '\xE8F', '\xE95', '\xE9B', 
		'\xEA0', '\xEA3', '\xEA6', '\xEBA', '\xEBE', '\xEC1', '\xEC7', '\xECD', 
		'\xED7', '\xEE1', '\xEE4', '\xEEA', '\xEEC', '\xEEE', '\xEF7', '\xEF9', 
		'\xF04', '\xF09', '\xF0C', '\xF0F', '\xF12', '\xF15', '\xF22', '\xF25', 
		'\xF2D', '\xF33', '\xF3D', '\xF42', '\xF49', '\xF4F', '\xF57', '\xF5F', 
		'\xF62', '\xF6C', '\xF71', '\xF74', '\xF7C', '\xF85', '\xF87', '\xF92', 
		'\xF99', '\xF9D', '\xFA2', '\xFA5', '\xFA8', '\xFAC', '\xFAE', '\xFB2', 
		'\xFB6', '\xFBE', '\xFC7', '\xFCB', '\xFCE', '\xFD0', '\xFD6', '\xFD8', 
		'\xFE0', '\xFEC', '\xFF4', '\xFF7', '\xFFB', '\xFFE', '\x1006', '\x100B', 
		'\x100F', '\x1019', '\x101F', '\x1021', '\x1027', '\x1029', '\x102F', 
		'\x1031', '\x104D', '\x1065', '\x106C', '\x1075', '\x1087', '\x108E', 
		'\x1094', '\x1098', '\x109C', '\x109E', '\x10A1', '\x10AB', '\x10AD', 
		'\x10B2', '\x10B4', '\x10B7', '\x10B9', '\x10C4', '\x10C7', '\x10CB', 
		'\x10CF', '\x10D2', '\x10DD', '\x10E1', '\x10E4', '\x10EA', '\x10F2', 
		'\x10F4', '\x10F7', '\x10FC', '\x10FF', '\x1105', '\x1107', '\x110A', 
		'\x1113', '\x1118', '\x1125', '\x112E', '\x1134', '\x113A', '\x1143', 
		'\x114F', '\x1154', '\x1159', '\x115F', '\x1161', '\x1169', '\x116B', 
		'\x1173', '\x117A', '\x117D', '\x1182', '\x1188', '\x118F', '\x1192', 
		'\x1199', '\x11A7', '\x11AB', '\x11AE', '\x11B2', '\x11C0', '\x11C5', 
		'\x11C8', '\x11D2', '\x11D5', '\x11D8', '\x11DE', '\x11E1', '\x11E4', 
		'\x11E7', '\x11EA', '\x11ED', '\x11F8', '\x1202', '\x1207', '\x120A', 
		'\x120D', '\x1210', '\x1213', '\x121F', '\x1221', '\x1225', '\x1227', 
		'\x122D', '\x1235', '\x1237', '\x1241', '\x1249', '\x124E', '\x1253', 
		'\x1258', '\x1266', '\x1271', '\x1274', '\x127C', '\x1287', '\x128A', 
		'\x128D', '\x1290', '\x129A', '\x129D', '\x12A7', '\x12AA', '\x12AD', 
		'\x12B0', '\x12B3', '\x12BC', '\x12C8', '\x12CB', '\x12D5', '\x12DC', 
		'\x12E5', '\x12E8', '\x12F0', '\x12F7', '\x12FD', '\x1306', '\x130D', 
		'\x1313', '\x1316', '\x131C', '\x131F', '\x1324', '\x1329', '\x132D', 
		'\x1333', '\x133A', '\x133D', '\x1346', '\x1348', '\x134B', '\x135A', 
		'\x1362', '\x1364', '\x1368', '\x136D', '\x1373', '\x1377', '\x1380', 
		'\x1390', '\x1395', '\x139F', '\x13A1', '\x13A9', '\x13CD', '\x13D3', 
		'\x13D8', '\x13E3', '\x13E6', '\x13EA', '\x13EF', '\x13F6', '\x13FE', 
		'\x1403', '\x1407', '\x140D', '\x1412', '\x1419', '\x141E', '\x1423', 
		'\x1428', '\x1438', '\x143C', '\x1441', '\x144A', '\x144D', '\x145C', 
		'\x1464', '\x1477', '\x1480', '\x1485', '\x1488', '\x148F', '\x1494', 
		'\x149E', '\x14A9', '\x14AD', '\x14B9', '\x14C1', '\x14C9', '\x14CE', 
		'\x14D2', '\x14D4', '\x14D7', '\x14DE', '\x14E5', '\x14EF', '\x14F6', 
		'\x14FD', '\x1507', '\x150C', '\x150F', '\x151B', '\x151F', '\x1526', 
		'\x1531', '\x1536', '\x153A', '\x153D', '\x155B', '\x1560', '\x1564', 
		'\x1568', '\x156D', '\x1571', '\x1575', '\x1577', '\x158C', '\x1591', 
		'\x1599', '\x15A2', '\x15B2', '\x15B8', '\x15BC', '\x15C4', '\x15D3', 
		'\x15D8', '\x15E0', '\x15E8', '\x15F9', '\x15FE', '\x1602', '\x1608', 
		'\x160D', '\x160F', '\x1617', '\x161A', '\x161E', '\x1624', '\x1630', 
		'\x1643', '\x1646', '\x1650', '\x1653', '\x1657', '\x165A', '\x1661', 
		'\x1665', '\x166A', '\x1678', '\x1681', '\x168B', '\x168F', '\x1694', 
		'\x1699', '\x16A4', '\x16A7', '\x16AC', '\x16B0', '\x16B5', '\x16BA', 
		'\x16BD', '\x16C0', '\x16CB', '\x16CD', '\x16D3', '\x16D6', '\x16DA', 
		'\x16DF', '\x16E9', '\x16EF', '\x16FA', '\x16FE', '\x1700', '\x1707', 
		'\x1710', '\x1714', '\x1719', '\x1721', '\x1724', '\x1729', '\x1733', 
		'\x1737', '\x1739', '\x173D', '\x1741', '\x1750', '\x1759', '\x1761', 
		'\x1769', '\x176B', '\x1771', '\x177C', '\x178F', '\x1796', '\x179D', 
		'\x17A5', '\x17AC', '\x17B4', '\x17BA', '\x17C5', '\x17CB', '\x17CF', 
		'\x17D9', '\x17E9', '\x17F1', '\x17F6', '\x17FA', '\x17FD', '\x1800', 
		'\x1806', '\x180D', '\x1810', '\x1813', '\x1816', '\x181B', '\x181E', 
		'\x182A', '\x1830', '\x1839', '\x183C', '\x184A', '\x1850', '\x1856', 
		'\x185F', '\x1863', '\x1866', '\x1869', '\x186D', '\x1871', '\x1874', 
		'\x1877', '\x187A', '\x1883', '\x1886', '\x1896', '\x189C', '\x189E', 
		'\x18A6', '\x18AD', '\x18B3', '\x18B7', '\x18BB', '\x18C2', '\x18C5', 
		'\x18CB', '\x18D2', '\x18D5', '\x18D8', '\x18DF', '\x18E6', '\x18EF', 
		'\x18F2', '\x18F6', '\x1904', '\x1907', '\x190A', '\x1917', '\x191F', 
		'\x1922', '\x1926', '\x192A', '\x192C', '\x193C', '\x193F', '\x194A', 
		'\x194E', '\x1955', '\x1958', '\x195B', '\x1968', '\x196E', '\x1971', 
		'\x197E', '\x1988', '\x198F', '\x1999', '\x199C', '\x19B5', '\x19BD', 
		'\x19C3', '\x19CA', '\x19D0', '\x19D6', '\x19DC', '\x19EF', '\x19F3', 
		'\x1A08', '\x1A0C', '\x1A13', '\x1A15', '\x1A1B', '\x1A1D', '\x1A36', 
		'\x1A3F', '\x1A44', '\x1A48', '\x1A4D', '\x1A53', '\x1A59', '\x1A5C', 
		'\x1A61', '\x1A64', '\x1A6B', '\x1A72', '\x1A79', '\x1A7F', '\x1A8A', 
		'\x1A9C', '\x1AA2', '\x1AA7', '\x1AA9', '\x1AB1', '\x1AB7', '\x1ABA', 
		'\x1AC5', '\x1AC9', '\x1ADD', '\x1AE0', '\x1AE8', '\x1AF5', '\x1AFD', 
		'\x1B02', '\x1B04', '\x1B0D', '\x1B15', '\x1B1A', '\x1B1C', '\x1B21', 
		'\x1B2E', '\x1B33', '\x1B3A', '\x1B3F', '\x1B47', '\x1B4B', '\x1B4E', 
		'\x1B51', '\x1B63', '\x1B73', '\x1B7A', '\x1B81', '\x1B88', '\x1B8F', 
		'\x1B96', '\x1B9C', '\x1BA0', '\x1BA5', '\x1BA7', '\x1BB0', '\x1BB5', 
		'\x1BC3', '\x1BCA', '\x1BD2', '\x1BD4', '\x1BDC', '\x1BDF', '\x1BE7', 
		'\x1BEF', '\x1BF2', '\x1BF6', '\x1C08', '\x1C10', '\x1C12', '\x1C18', 
		'\x1C20', '\x1C26', '\x1C30', '\x1C35', '\x1C38', '\x1C43', '\x1C4C', 
		'\x1C51', '\x1C5D', '\x1C61', '\x1C64', '\x1C71', '\x1C79', '\x1C7E', 
		'\x1C83', '\x1C88', '\x1C8B', '\x1C8E', '\x1C93', '\x1C9F', '\x1CA6', 
		'\x1CA8', '\x1CBA', '\x1CBD', '\x1CCD', '\x1CCF', '\x1CD2', '\x1CDA', 
		'\x1CDE', '\x1CE1', '\x1CE4', '\x1CE8', '\x1CF6', '\x1CFC', '\x1D00', 
		'\x1D06', '\x1D0A', '\x1D12', '\x1D22', '\x1D26', '\x1D2C', '\x1D2F', 
		'\x1D33', '\x1D36', '\x1D41', '\x1D4A', '\x1D57', '\x1D62', '\x1D67', 
		'\x1D6E', '\x1D73', '\x1D77', '\x1D7B', '\x1D7F', '\x1D83', '\x1D89', 
		'\x1D8D', '\x1D93', '\x1D96', '\x1D9C', '\x1D9F', '\x1DA6', '\x1DA9', 
		'\x1DAE', '\x1DB7', '\x1DBA', '\x1DBE', '\x1DC1', '\x1DC6', '\x1DD4', 
		'\x1DDB', '\x1DF7', '\x1DFB', '\x1E00', '\x1E05', '\x1E0B', '\x1E11', 
		'\x1E1D', '\x1E22', '\x1E27',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
